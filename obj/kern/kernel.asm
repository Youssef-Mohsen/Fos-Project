
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 c0 17 00 	lgdtl  0x17c018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 c0 17 f0       	mov    $0xf017c000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 58 48 5f f0 01 	movl   $0x1,0xf05f4858
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 a4 47 5f f0 01 	movl   $0x1,0xf05f47a4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 70 74 61 f0       	mov    $0xf0617470,%edx
f010006a:	b8 70 b5 5c f0       	mov    $0xf05cb570,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 70 b5 5c f0       	push   $0xf05cb570
f010007e:	e8 b8 ec 01 00       	call   f011ed3b <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 80 14 12 f0       	push   $0xf0121480
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 c7 14 12 f0       	push   $0xf01214c7
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 db 14 12 f0       	push   $0xf01214db
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 ef 14 12 f0       	push   $0xf01214ef
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 d1 6f 00 00       	call   f01070ab <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 fb 14 12 f0       	push   $0xf01214fb
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 03 15 12 f0       	push   $0xf0121503
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 16 79 00 00       	call   f0107a18 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 b7 74 00 00       	call   f01075be <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 57 7c 00 00       	call   f0107d63 <initialize_paging>
		sharing_init();
f010010c:	e8 c8 88 00 00       	call   f01089d9 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 9f 8a 00 00       	call   f0108bc7 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 b3 e5 00 00       	call   f010e6e3 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 9c e6 00 00       	call   f010e7e0 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 77 e6 00 00       	call   f010e7c8 <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 97 e6 00 00       	call   f010e7f8 <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 29 f1 01 00       	call   f011f292 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 11 15 12 f0       	push   $0xf0121511
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 7c 9e 00 00       	call   f0109ffa <env_init>
		ts_init();
f010017e:	e8 15 bf 00 00       	call   f010c098 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 fb 14 12 f0       	push   $0xf01214fb
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 24 15 12 f0       	push   $0xf0121524
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 ef 6b 00 00       	call   f0106d97 <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 4d 15 12 f0       	push   $0xf012154d
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 c7 6d 00 00       	call   f0106f89 <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 63 15 12 f0       	push   $0xf0121563
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 aa 6d 00 00       	call   f0106f89 <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 80 15 12 f0       	push   $0xf0121580
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 8d 6d 00 00       	call   f0106f89 <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 9f 15 12 f0       	push   $0xf012159f
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 bc 15 12 f0       	push   $0xf01215bc
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 72 49 00 00       	call   f0104b96 <kclock_init>
		sched_init() ;
f0100224:	e8 a2 64 00 00       	call   f01066cb <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 e0 15 12 f0       	push   $0xf01215e0
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 c0 17 f0       	mov    $0xf017c000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 00 16 12 f0       	push   $0xf0121600
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 24 16 12 f0       	push   $0xf0121624
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 9c 4a 5f f0 00 	movl   $0x0,0xf05f4a9c
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 6c 16 12 f0       	push   $0xf012166c
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 98 16 12 f0       	push   $0xf0121698
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 bd 16 12 f0       	push   $0xf01216bd
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 c4 16 12 f0       	push   $0xf01216c4
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 0c 17 12 f0       	push   $0xf012170c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 54 17 12 f0       	push   $0xf0121754
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 0c 17 12 f0       	push   $0xf012170c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 c4 16 12 f0       	push   $0xf01216c4
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 99 17 12 f0       	push   $0xf0121799
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 c7 a8 00 00       	call   f010ac0b <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 80 b5 5c f0       	mov    %eax,0xf05cb580

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 a0 17 12 f0       	push   $0xf01217a0
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 c5 17 12 f0       	push   $0xf01217c5
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 23 a8 00 00       	call   f010abc9 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 c7 17 12 f0       	push   $0xf01217c7
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 80 b5 5c f0       	mov    %eax,0xf05cb580

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 d1 17 12 f0       	push   $0xf01217d1
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 c5 17 12 f0       	push   $0xf01217c5
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 47 6d 00 00       	call   f0107164 <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 7f 6c 00 00       	call   f01070a1 <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 80 6d 00 00       	call   f01071b6 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 32 60 00 00       	call   f0106473 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 c5 a7 00 00       	call   f010ac0b <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 6a a7 00 00       	call   f010abc9 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 80 b5 5c f0       	mov    %eax,0xf05cb580

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 d1 17 12 f0       	push   $0xf01217d1
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 c5 17 12 f0       	push   $0xf01217c5
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 53 a7 00 00       	call   f010ac0b <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 f8 a6 00 00       	call   f010abc9 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 ea 17 12 f0       	push   $0xf01217ea
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 c5 17 12 f0       	push   $0xf01217c5
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 a4 b5 5c f0       	mov    0xf05cb5a4,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 08 18 12 f0       	push   $0xf0121808
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 a4 b5 5c f0       	mov    %eax,0xf05cb5a4
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 27 cd 00 00       	call   f010d39c <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 a8 b5 5c f0 b4 	movl   $0x3b4,0xf05cb5a8
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 a8 b5 5c f0 d4 	movl   $0x3d4,0xf05cb5a8
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 a8 b5 5c f0       	mov    0xf05cb5a8,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 a8 b5 5c f0       	mov    0xf05cb5a8,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 a8 b5 5c f0       	mov    0xf05cb5a8,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 a8 b5 5c f0       	mov    0xf05cb5a8,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 ac b5 5c f0       	mov    %eax,0xf05cb5ac
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 b0 b5 5c f0    	mov    %ax,0xf05cb5b0
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 b0 b5 5c f0    	mov    %ax,0xf05cb5b0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 ac b5 5c f0    	mov    0xf05cb5ac,%edx
f010087a:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 b0 b5 5c f0    	mov    %ax,0xf05cb5b0
		text_length = 0;
f01008a6:	c7 05 a0 b5 5c f0 00 	movl   $0x0,0xf05cb5a0
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d b0 b5 5c f0 	mov    0xf05cb5b0,%cx
f01008b7:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 b0 b5 5c f0    	mov    %ax,0xf05cb5b0
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 b0 b5 5c f0    	mov    %ax,0xf05cb5b0
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 b0 b5 5c f0    	mov    %ax,0xf05cb5b0
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d ac b5 5c f0    	mov    0xf05cb5ac,%ecx
f0100972:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 b0 b5 5c f0 	mov    %dx,0xf05cb5b0
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 a0 b5 5c f0    	mov    0xf05cb5a0,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 a0 b5 5c f0       	mov    0xf05cb5a0,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 a0 b5 5c f0       	mov    %eax,0xf05cb5a0
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 ac b5 5c f0       	mov    0xf05cb5ac,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 ac b5 5c f0       	mov    0xf05cb5ac,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 80 e3 01 00       	call   f011ed6b <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 ac b5 5c f0    	mov    0xf05cb5ac,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 b0 b5 5c f0    	mov    %ax,0xf05cb5b0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 a8 b5 5c f0       	mov    0xf05cb5a8,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 a8 b5 5c f0    	mov    0xf05cb5a8,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 a8 b5 5c f0       	mov    0xf05cb5a8,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 a8 b5 5c f0    	mov    0xf05cb5a8,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 c8 b7 5c f0       	mov    %eax,0xf05cb7c8
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 c0 17 f0    	mov    -0xfe83fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 c8 b7 5c f0       	mov    %eax,0xf05cb7c8
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 c8 b7 5c f0       	mov    %eax,0xf05cb7c8
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 c0 17 f0    	mov    -0xfe83fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 c8 b7 5c f0       	mov    %eax,0xf05cb7c8
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 c1 17 f0    	mov    -0xfe83ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 c8 b7 5c f0       	mov    %eax,0xf05cb7c8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 c5 17 f0 	mov    -0xfe83ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 a0 b5 5c f0       	mov    0xf05cb5a0,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 a0 b5 5c f0    	mov    0xf05cb5a0,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 a0 b5 5c f0       	mov    0xf05cb5a0,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 a0 b5 5c f0       	mov    %eax,0xf05cb5a0
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 b0 b5 5c f0    	mov    0xf05cb5b0,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 ac b5 5c f0    	mov    0xf05cb5ac,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 ac b5 5c f0       	mov    0xf05cb5ac,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 a0 b5 5c f0       	mov    0xf05cb5a0,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 c8 b7 5c f0       	mov    0xf05cb7c8,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 1b 18 12 f0       	push   $0xf012181b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 87 c6 00 00       	call   f010d39c <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 c4 b7 5c f0       	mov    0xf05cb7c4,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 c4 b7 5c f0    	mov    %edx,0xf05cb7c4
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 c0 b5 5c f0    	mov    %dl,-0xfa34a40(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 c4 b7 5c f0       	mov    0xf05cb7c4,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 c4 b7 5c f0 00 	movl   $0x0,0xf05cb7c4
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 c0 b7 5c f0    	mov    0xf05cb7c0,%edx
f0100d7f:	a1 c4 b7 5c f0       	mov    0xf05cb7c4,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 c0 b7 5c f0       	mov    0xf05cb7c0,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 c0 b7 5c f0    	mov    %edx,0xf05cb7c0
f0100d96:	8a 80 c0 b5 5c f0    	mov    -0xfa34a40(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 c0 b7 5c f0       	mov    0xf05cb7c0,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 c0 b7 5c f0 00 	movl   $0x0,0xf05cb7c0
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 c0 b7 5c f0    	mov    0xf05cb7c0,%edx
f0100dd0:	a1 c4 b7 5c f0       	mov    0xf05cb7c4,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 c0 b7 5c f0       	mov    0xf05cb7c0,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 c0 b7 5c f0    	mov    %edx,0xf05cb7c0
f0100de7:	8a 80 c0 b5 5c f0    	mov    -0xfa34a40(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 c0 b7 5c f0       	mov    0xf05cb7c0,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 c0 b7 5c f0 00 	movl   $0x0,0xf05cb7c0
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 a4 b5 5c f0       	mov    0xf05cb5a4,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 27 18 12 f0       	push   $0xf0121827
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 9d 3d 00 00       	call   f0104c58 <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 4a 9d 00 00       	call   f010ac0b <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 44 18 12 f0       	push   $0xf0121844
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 6b 18 12 f0       	push   $0xf012186b
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 56 3d 00 00       	call   f0104c58 <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 03 9d 00 00       	call   f010ac0b <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 80 18 12 f0       	push   $0xf0121880
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 6b 18 12 f0       	push   $0xf012186b
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 08 d5 01 00       	call   f011e48b <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 ce 61 00 00       	call   f0107164 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 00 62 00 00       	call   f01071b6 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 60 db 60 f0       	add    $0xf060db60,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 55 db 01 00       	call   f011eb4d <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 80 2b 61 f0       	push   $0xf0612b80
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 58 dd 01 00       	call   f011ed6b <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 60 db 60 f0       	add    $0xf060db60,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 60 db 60 f0       	add    $0xf060db60,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 93 da 01 00       	call   f011eb4d <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 80 2b 61 f0       	push   $0xf0612b80
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 96 dc 01 00       	call   f011ed6b <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 60 4b 5f f0       	add    $0xf05f4b60,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 d3 db 01 00       	call   f011ed3b <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 ac 18 12 f0       	push   $0xf01218ac
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 c5 17 f0       	mov    0xf017c530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 af 18 12 f0       	push   $0xf01218af
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 c5 17 f0       	mov    0xf017c530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 c5 17 f0       	mov    0xf017c530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 60 4b 5f f0       	push   $0xf05f4b60
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 78 d8 01 00       	call   f011eb4d <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 8d d8 01 00       	call   f011eb9c <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 30 d8 01 00       	call   f011eb4d <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 bf 18 12 f0       	push   $0xf01218bf
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 0b de 01 00       	call   f011f162 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 c4 18 12 f0       	push   $0xf01218c4
f010137e:	50                   	push   %eax
f010137f:	e8 d5 d8 01 00       	call   f011ec59 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 c8 18 12 f0       	push   $0xf01218c8
f0101399:	50                   	push   %eax
f010139a:	e8 ba d8 01 00       	call   f011ec59 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 cd 18 12 f0       	push   $0xf01218cd
f01013b4:	50                   	push   %eax
f01013b5:	e8 9f d8 01 00       	call   f011ec59 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 cd 18 12 f0       	push   $0xf01218cd
f01013d5:	50                   	push   %eax
f01013d6:	e8 7e d8 01 00       	call   f011ec59 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 26 d7 01 00       	call   f011eb4d <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 28 d7 01 00       	call   f011eb9c <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 07 d7 01 00       	call   f011eb9c <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 84 d6 01 00       	call   f011eb4d <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 9f d7 01 00       	call   f011ec91 <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 d4 d5 01 00       	call   f011eb4d <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 60 4b 5f f0       	add    $0xf05f4b60,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 9f d7 01 00       	call   f011ed3b <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 60 4b 5f f0    	add    $0xf05f4b60,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 0a d6 01 00       	call   f011ebca <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 c9 17 f0       	mov    0xf017c948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 4a d5 01 00       	call   f011eb4d <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 cc 17 f0    	mov    0xf017cce0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 62 d6 01 00       	call   f011ec91 <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 ad d4 01 00       	call   f011eb4d <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 cc 17 f0    	mov    0xf017cce0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 cc 17 f0    	mov    0xf017cce0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 4d d4 01 00       	call   f011eb4d <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 60 4b 5f f0       	add    $0xf05f4b60,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 18 d6 01 00       	call   f011ed3b <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 60 4b 5f f0    	add    $0xf05f4b60,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 83 d4 01 00       	call   f011ebca <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 cc 17 f0       	mov    0xf017cce4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 c5 d3 01 00       	call   f011eb4d <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 cd 17 f0       	add    $0xf017cd00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 e0 d4 01 00       	call   f011ec91 <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 2b d3 01 00       	call   f011eb4d <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 cd 17 f0       	add    $0xf017cd00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 cd 17 f0       	add    $0xf017cd00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 d1 d2 01 00       	call   f011eb4d <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 60 4b 5f f0       	add    $0xf05f4b60,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 9c d4 01 00       	call   f011ed3b <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 60 4b 5f f0    	add    $0xf05f4b60,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 07 d3 01 00       	call   f011ebca <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 cd 17 f0       	mov    0xf017cdb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 60 4b 5f f0       	add    $0xf05f4b60,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 60 4b 5f f0       	push   $0xf05f4b60
f0101929:	e8 1f d2 01 00       	call   f011eb4d <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 c6 d1 01 00       	call   f011eb4d <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 b3 d1 01 00       	call   f011eb4d <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 60 4b 5f f0    	lea    -0xfa0b4a0(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 60 4b 5f f0       	add    $0xf05f4b60,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 58 d1 01 00       	call   f011eb4d <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 c5 17 f0       	mov    0xf017c530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 60 db 60 f0    	lea    -0xf9f24a0(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 60 db 60 f0       	add    $0xf060db60,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 4d d1 01 00       	call   f011ed6b <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 60 27 61 f0       	push   $0xf0612760
f0101c3a:	e8 2c d1 01 00       	call   f011ed6b <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 c5 17 f0       	mov    0xf017c530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 60 db 60 f0       	add    $0xf060db60,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 fc cf 01 00       	call   f011ec59 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 c5 17 f0       	mov    0xf017c530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 c5 17 f0       	mov    %eax,0xf017c530
f0101c6f:	a1 30 c5 17 f0       	mov    0xf017c530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 60 db 60 f0       	add    $0xf060db60,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 de d0 01 00       	call   f011ed6b <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 9c 4a 5f f0       	mov    0xf05f4a9c,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb d7 18 12 f0       	mov    $0xf01218d7,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb d7 1c 12 f0       	mov    $0xf0121cd7,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb d7 20 12 f0       	mov    $0xf01220d7,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 9c 4a 5f f0 00 	movl   $0x0,0xf05f4a9c
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 18 4a 5f f0 00 	movl   $0x0,0xf05f4a18
f0101d59:	00 00 00 
f0101d5c:	c7 05 1c 4a 5f f0 00 	movl   $0x0,0xf05f4a1c
f0101d63:	00 00 00 
f0101d66:	c7 05 24 4a 5f f0 00 	movl   $0x0,0xf05f4a24
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 b5 cf 01 00       	call   f011ed3b <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 d1 18 12 f0       	push   $0xf01218d1
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 b1 90 00 00       	call   f010ae90 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 bd 52 00 00       	call   f01070a1 <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 40 4b 5f f0       	mov    %eax,0xf05f4b40
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 60 2b 61 f0       	mov    %eax,0xf0612b60
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 40 4b 5f f0       	mov    0xf05f4b40,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 40 4b 5f f0    	mov    %edx,0xf05f4b40
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 60 2b 61 f0       	mov    0xf0612b60,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 60 2b 61 f0       	mov    %eax,0xf0612b60
f0101e98:	a1 60 2b 61 f0       	mov    0xf0612b60,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 40 4b 5f f0       	mov    %eax,0xf05f4b40
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 60 2b 61 f0       	mov    %eax,0xf0612b60
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 40 4b 5f f0       	mov    0xf05f4b40,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 40 4b 5f f0    	mov    %edx,0xf05f4b40
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 60 2b 61 f0       	mov    0xf0612b60,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 60 2b 61 f0       	mov    %eax,0xf0612b60
f0101ed4:	a1 60 2b 61 f0       	mov    0xf0612b60,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 bf 18 12 f0       	push   $0xf01218bf
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 4c d2 01 00       	call   f011f162 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 d7 24 12 f0       	push   $0xf01224d7
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 24 4a 5f f0       	mov    0xf05f4a24,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 f0 24 12 f0       	push   $0xf01224f0
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 41 25 12 f0       	push   $0xf0122541
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 18 4a 5f f0       	mov    0xf05f4a18,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 5c 25 12 f0       	push   $0xf012255c
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 24 4a 5f f0       	mov    0xf05f4a24,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 8c 25 12 f0       	push   $0xf012258c
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 41 25 12 f0       	push   $0xf0122541
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 18 4a 5f f0       	mov    0xf05f4a18,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 b6 25 12 f0       	push   $0xf01225b6
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 20 4a 5f f0       	mov    0xf05f4a20,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 20 4a 5f f0       	mov    %eax,0xf05f4a20
f010203b:	a1 20 4a 5f f0       	mov    0xf05f4a20,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 c0 25 12 f0       	push   $0xf01225c0
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 18 4a 5f f0       	mov    0xf05f4a18,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 23 26 12 f0       	push   $0xf0122623
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 2c 26 12 f0       	push   $0xf012262c
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 20 4a 5f f0       	mov    0xf05f4a20,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 20 4a 5f f0       	mov    %eax,0xf05f4a20
f010218b:	a1 20 4a 5f f0       	mov    0xf05f4a20,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 c5 17 f0       	add    $0xf017c548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 18 4a 5f f0       	mov    0xf05f4a18,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 34 26 12 f0       	push   $0xf0122634
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 41 25 12 f0       	push   $0xf0122541
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 1c 4a 5f f0       	mov    %eax,0xf05f4a1c
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 18 4a 5f f0       	mov    %eax,0xf05f4a18
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 24 4a 5f f0       	mov    0xf05f4a24,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 24 4a 5f f0       	mov    %eax,0xf05f4a24

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 20 4a 5f f0       	mov    0xf05f4a20,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 20 4a 5f f0       	mov    %eax,0xf05f4a20
f0102292:	a1 20 4a 5f f0       	mov    0xf05f4a20,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 7b c9 01 00       	call   f011ec59 <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c c5 17 f0       	add    $0xf017c54c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c c5 17 f0       	add    $0xf017c54c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 18 4a 5f f0    	mov    0xf05f4a18,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 c5 17 f0       	add    $0xf017c550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 c5 17 f0       	add    $0xf017c550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 18 4a 5f f0    	mov    0xf05f4a18,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f010238d:	a3 1c 4a 5f f0       	mov    %eax,0xf05f4a1c
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f01023a3:	a3 18 4a 5f f0       	mov    %eax,0xf05f4a18
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 c5 17 f0       	add    $0xf017c554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 24 4a 5f f0       	mov    0xf05f4a24,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 24 4a 5f f0       	mov    %eax,0xf05f4a24
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 18 4a 5f f0    	mov    0xf05f4a18,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 c5 17 f0       	add    $0xf017c550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 c5 17 f0       	add    $0xf017c550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 18 4a 5f f0    	mov    0xf05f4a18,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f010248c:	a3 1c 4a 5f f0       	mov    %eax,0xf05f4a1c
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f01024a2:	a3 18 4a 5f f0       	mov    %eax,0xf05f4a18
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 c5 17 f0       	add    $0xf017c554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 24 4a 5f f0       	mov    0xf05f4a24,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 24 4a 5f f0       	mov    %eax,0xf05f4a24
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 48 c9 17 f0       	mov    0xf017c948,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 58 48 5f f0 00 	movl   $0x0,0xf05f4858
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 58 48 5f f0 01 	movl   $0x1,0xf05f4858
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 58 48 5f f0 02 	movl   $0x2,0xf05f4858
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 58 48 5f f0 03 	movl   $0x3,0xf05f4858
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 58 48 5f f0 04 	movl   $0x4,0xf05f4858
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 a4 47 5f f0 01 	movl   $0x1,0xf05f47a4
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 a4 47 5f f0 02 	movl   $0x2,0xf05f47a4
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 a4 47 5f f0 03 	movl   $0x3,0xf05f47a4
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 a4 47 5f f0 04 	movl   $0x4,0xf05f47a4
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 a4 47 5f f0       	mov    0xf05f47a4,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 a4 47 5f f0       	mov    0xf05f47a4,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 a4 47 5f f0       	mov    0xf05f47a4,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 a4 47 5f f0       	mov    0xf05f47a4,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 54 26 12 f0       	push   $0xf0122654
f0102662:	6a 56                	push   $0x56
f0102664:	68 7c 26 12 f0       	push   $0xf012267c
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 c0 47 5f f0    	mov    0xf05f47c0,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 c5 17 f0       	add    $0xf017c544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 ff 2e 12 f0       	push   $0xf0122eff
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 48 c9 17 f0       	mov    0xf017c948,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 08 2f 12 f0       	push   $0xf0122f08
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d e0 cc 17 f0    	mov    0xf017cce0,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d e0 cc 17 f0    	mov    0xf017cce0,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 1d 2f 12 f0       	push   $0xf0122f1d
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 e4 cc 17 f0       	mov    0xf017cce4,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 39 2f 12 f0       	push   $0xf0122f39
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 54 2f 12 f0       	push   $0xf0122f54
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 79 14 12 00       	mov    $0x121479,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 79 14 12 f0       	push   $0xf0121479
f010278e:	68 90 2f 12 f0       	push   $0xf0122f90
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 70 b5 5c 00       	mov    $0x5cb570,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 70 b5 5c f0       	push   $0xf05cb570
f01027a9:	68 cc 2f 12 f0       	push   $0xf0122fcc
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 70 74 61 00       	mov    $0x617470,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 70 74 61 f0       	push   $0xf0617470
f01027c4:	68 14 30 12 f0       	push   $0xf0123014
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 70 74 61 f0       	mov    $0xf0617470,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 50 30 12 f0       	push   $0xf0123050
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 83 c6 01 00       	call   f011eead <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 42 c6 01 00       	call   f011eead <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 d2 83 00 00       	call   f010ac5b <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 0c c6 01 00       	call   f011eead <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 7c 30 12 f0       	push   $0xf012307c
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 86 c5 01 00       	call   f011eead <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 03 c2 01 00       	call   f011eb4d <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 08 c5 01 00       	call   f011eead <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 a6 30 12 f0       	push   $0xf01230a6
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 bc c4 01 00       	call   f011eead <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 4c 82 00 00       	call   f010ac5b <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 86 c4 01 00       	call   f011eead <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 a6 30 12 f0       	push   $0xf01230a6
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 c0 30 12 f0       	push   $0xf01230c0
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 f5 c3 01 00       	call   f011eead <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 ea 30 12 f0       	push   $0xf01230ea
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 ed 30 12 f0       	push   $0xf01230ed
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 98 c3 01 00       	call   f011eead <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 28 81 00 00       	call   f010ac5b <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 62 c3 01 00       	call   f011eead <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 47 c3 01 00       	call   f011eead <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 ef 30 12 f0       	push   $0xf01230ef
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 ab c2 01 00       	call   f011eead <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 3b 80 00 00       	call   f010ac5b <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 64 c2 01 00       	call   f011eead <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 00 64 00 00       	call   f0109085 <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 15 63 00 00       	call   f0108fa6 <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 e0 55 00 00       	call   f010829b <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 00 31 12 f0       	push   $0xf0123100
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 6f c1 01 00       	call   f011eead <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 ff 7e 00 00       	call   f010ac5b <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 28 c1 01 00       	call   f011eead <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 b0 53 00 00       	call   f0108147 <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 2a 31 12 f0       	push   $0xf012312a
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 3c 58 00 00       	call   f0108614 <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 44 31 12 f0       	push   $0xf0123144
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 ad 57 00 00       	call   f0108614 <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 71 5a 00 00       	call   f01088f6 <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 88 31 12 f0       	push   $0xf0123188
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 70 49 5f f0       	mov    0xf05f4970,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 e0 31 12 f0       	push   $0xf01231e0
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ef9:	83 f8 04             	cmp    $0x4,%eax
f0102efc:	0f 84 94 00 00 00    	je     f0102f96 <CreateEnv+0xc2>
f0102f02:	83 f8 05             	cmp    $0x5,%eax
f0102f05:	74 0e                	je     f0102f15 <CreateEnv+0x41>
f0102f07:	83 f8 03             	cmp    $0x3,%eax
f0102f0a:	0f 84 ec 00 00 00    	je     f0102ffc <CreateEnv+0x128>
f0102f10:	e9 2f 01 00 00       	jmp    f0103044 <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f15:	83 ec 0c             	sub    $0xc,%esp
f0102f18:	6a 02                	push   $0x2
f0102f1a:	e8 0c b8 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f0102f1f:	83 c4 10             	add    $0x10,%esp
f0102f22:	85 c0                	test   %eax,%eax
f0102f24:	75 1a                	jne    f0102f40 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f26:	83 ec 0c             	sub    $0xc,%esp
f0102f29:	68 1c 32 12 f0       	push   $0xf012321c
f0102f2e:	e8 58 e0 ff ff       	call   f0100f8b <cprintf>
f0102f33:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f3b:	e9 ff 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f43:	83 c0 10             	add    $0x10,%eax
f0102f46:	8b 00                	mov    (%eax),%eax
f0102f48:	83 ec 04             	sub    $0x4,%esp
f0102f4b:	6a 0a                	push   $0xa
f0102f4d:	6a 00                	push   $0x0
f0102f4f:	50                   	push   %eax
f0102f50:	e8 58 bf 01 00       	call   f011eead <strtol>
f0102f55:	83 c4 10             	add    $0x10,%esp
f0102f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5e:	83 c0 0c             	add    $0xc,%eax
f0102f61:	8b 00                	mov    (%eax),%eax
f0102f63:	83 ec 04             	sub    $0x4,%esp
f0102f66:	6a 0a                	push   $0xa
f0102f68:	6a 00                	push   $0x0
f0102f6a:	50                   	push   %eax
f0102f6b:	e8 3d bf 01 00       	call   f011eead <strtol>
f0102f70:	83 c4 10             	add    $0x10,%esp
f0102f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 08             	add    $0x8,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 22 bf 01 00       	call   f011eead <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102f91:	e9 c8 00 00 00       	jmp    f010305e <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f96:	83 ec 0c             	sub    $0xc,%esp
f0102f99:	6a 02                	push   $0x2
f0102f9b:	e8 8b b7 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f0102fa0:	83 c4 10             	add    $0x10,%esp
f0102fa3:	85 c0                	test   %eax,%eax
f0102fa5:	75 1d                	jne    f0102fc4 <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faa:	83 c0 0c             	add    $0xc,%eax
f0102fad:	8b 00                	mov    (%eax),%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	6a 0a                	push   $0xa
f0102fb4:	6a 00                	push   $0x0
f0102fb6:	50                   	push   %eax
f0102fb7:	e8 f1 be 01 00       	call   f011eead <strtol>
f0102fbc:	83 c4 10             	add    $0x10,%esp
f0102fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102fc2:	eb 1b                	jmp    f0102fdf <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fc7:	83 c0 0c             	add    $0xc,%eax
f0102fca:	8b 00                	mov    (%eax),%eax
f0102fcc:	83 ec 04             	sub    $0x4,%esp
f0102fcf:	6a 0a                	push   $0xa
f0102fd1:	6a 00                	push   $0x0
f0102fd3:	50                   	push   %eax
f0102fd4:	e8 d4 be 01 00       	call   f011eead <strtol>
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe2:	83 c0 08             	add    $0x8,%eax
f0102fe5:	8b 00                	mov    (%eax),%eax
f0102fe7:	83 ec 04             	sub    $0x4,%esp
f0102fea:	6a 0a                	push   $0xa
f0102fec:	6a 00                	push   $0x0
f0102fee:	50                   	push   %eax
f0102fef:	e8 b9 be 01 00       	call   f011eead <strtol>
f0102ff4:	83 c4 10             	add    $0x10,%esp
f0102ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102ffa:	eb 62                	jmp    f010305e <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ffc:	83 ec 0c             	sub    $0xc,%esp
f0102fff:	6a 02                	push   $0x2
f0103001:	e8 25 b7 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f0103006:	83 c4 10             	add    $0x10,%esp
f0103009:	85 c0                	test   %eax,%eax
f010300b:	74 1a                	je     f0103027 <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f010300d:	83 ec 0c             	sub    $0xc,%esp
f0103010:	68 c8 32 12 f0       	push   $0xf01232c8
f0103015:	e8 71 df ff ff       	call   f0100f8b <cprintf>
f010301a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f010301d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103022:	e9 18 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103027:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302a:	83 c0 08             	add    $0x8,%eax
f010302d:	8b 00                	mov    (%eax),%eax
f010302f:	83 ec 04             	sub    $0x4,%esp
f0103032:	6a 0a                	push   $0xa
f0103034:	6a 00                	push   $0x0
f0103036:	50                   	push   %eax
f0103037:	e8 71 be 01 00       	call   f011eead <strtol>
f010303c:	83 c4 10             	add    $0x10,%esp
f010303f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103042:	eb 1a                	jmp    f010305e <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 58 33 12 f0       	push   $0xf0123358
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 e1 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	6a 02                	push   $0x2
f0103063:	e8 c3 b6 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f0103068:	83 c4 10             	add    $0x10,%esp
f010306b:	85 c0                	test   %eax,%eax
f010306d:	74 23                	je     f0103092 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f010306f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103072:	48                   	dec    %eax
f0103073:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103076:	73 1a                	jae    f0103092 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103078:	83 ec 0c             	sub    $0xc,%esp
f010307b:	68 f0 33 12 f0       	push   $0xf01233f0
f0103080:	e8 06 df ff ff       	call   f0100f8b <cprintf>
f0103085:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103088:	b8 00 00 00 00       	mov    $0x0,%eax
f010308d:	e9 ad 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103092:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f0103096:	76 19                	jbe    f01030b1 <CreateEnv+0x1dd>
f0103098:	68 48 34 12 f0       	push   $0xf0123448
f010309d:	68 8d 34 12 f0       	push   $0xf012348d
f01030a2:	68 a4 01 00 00       	push   $0x1a4
f01030a7:	68 a2 34 12 f0       	push   $0xf01234a2
f01030ac:	e8 88 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030b1:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030b5:	76 19                	jbe    f01030d0 <CreateEnv+0x1fc>
f01030b7:	68 48 34 12 f0       	push   $0xf0123448
f01030bc:	68 8d 34 12 f0       	push   $0xf012348d
f01030c1:	68 c0 01 00 00       	push   $0x1c0
f01030c6:	68 a2 34 12 f0       	push   $0xf01234a2
f01030cb:	e8 69 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f01030d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030d3:	83 c0 04             	add    $0x4,%eax
f01030d6:	8b 00                	mov    (%eax),%eax
f01030d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01030db:	ff 75 f0             	pushl  -0x10(%ebp)
f01030de:	ff 75 f4             	pushl  -0xc(%ebp)
f01030e1:	50                   	push   %eax
f01030e2:	e8 a6 70 00 00       	call   f010a18d <env_create>
f01030e7:	83 c4 10             	add    $0x10,%esp
f01030ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f01030ed:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f01030f1:	74 49                	je     f010313c <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f01030f3:	83 ec 08             	sub    $0x8,%esp
f01030f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01030f9:	68 b6 34 12 f0       	push   $0xf01234b6
f01030fe:	e8 88 de ff ff       	call   f0100f8b <cprintf>
f0103103:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103106:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010310a:	7c 06                	jl     f0103112 <CreateEnv+0x23e>
f010310c:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103110:	7e 19                	jle    f010312b <CreateEnv+0x257>
f0103112:	68 c8 34 12 f0       	push   $0xf01234c8
f0103117:	68 8d 34 12 f0       	push   $0xf012348d
f010311c:	68 c5 01 00 00       	push   $0x1c5
f0103121:	68 a2 34 12 f0       	push   $0xf01234a2
f0103126:	e8 0e d2 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010312b:	83 ec 08             	sub    $0x8,%esp
f010312e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103131:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103134:	e8 eb 34 00 00       	call   f0106624 <env_set_nice>
f0103139:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f010313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010313f:	c9                   	leave  
f0103140:	c3                   	ret    

f0103141 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103141:	55                   	push   %ebp
f0103142:	89 e5                	mov    %esp,%ebp
f0103144:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103147:	83 ec 08             	sub    $0x8,%esp
f010314a:	ff 75 0c             	pushl  0xc(%ebp)
f010314d:	ff 75 08             	pushl  0x8(%ebp)
f0103150:	e8 7f fd ff ff       	call   f0102ed4 <CreateEnv>
f0103155:	83 c4 10             	add    $0x10,%esp
f0103158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f010315b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010315f:	75 07                	jne    f0103168 <command_run_program+0x27>
f0103161:	b8 00 00 00 00       	mov    $0x0,%eax
f0103166:	eb 46                	jmp    f01031ae <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010316b:	8b 40 10             	mov    0x10(%eax),%eax
f010316e:	83 ec 08             	sub    $0x8,%esp
f0103171:	50                   	push   %eax
f0103172:	68 f8 34 12 f0       	push   $0xf01234f8
f0103177:	e8 0f de ff ff       	call   f0100f8b <cprintf>
f010317c:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f010317f:	83 ec 0c             	sub    $0xc,%esp
f0103182:	ff 75 f4             	pushl  -0xc(%ebp)
f0103185:	e8 30 25 00 00       	call   f01056ba <sched_new_env>
f010318a:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010318d:	c7 05 70 49 5f f0 00 	movl   $0x0,0xf05f4970
f0103194:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010319a:	8b 40 10             	mov    0x10(%eax),%eax
f010319d:	83 ec 0c             	sub    $0xc,%esp
f01031a0:	50                   	push   %eax
f01031a1:	e8 6a 25 00 00       	call   f0105710 <sched_run_env>
f01031a6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ae:	c9                   	leave  
f01031af:	c3                   	ret    

f01031b0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b9:	83 c0 04             	add    $0x4,%eax
f01031bc:	8b 00                	mov    (%eax),%eax
f01031be:	83 ec 04             	sub    $0x4,%esp
f01031c1:	6a 0a                	push   $0xa
f01031c3:	6a 00                	push   $0x0
f01031c5:	50                   	push   %eax
f01031c6:	e8 e2 bc 01 00       	call   f011eead <strtol>
f01031cb:	83 c4 10             	add    $0x10,%esp
f01031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f01031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 79 28 00 00       	call   f0105a56 <sched_kill_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ed:	83 ec 08             	sub    $0x8,%esp
f01031f0:	ff 75 0c             	pushl  0xc(%ebp)
f01031f3:	ff 75 08             	pushl  0x8(%ebp)
f01031f6:	e8 d9 fc ff ff       	call   f0102ed4 <CreateEnv>
f01031fb:	83 c4 10             	add    $0x10,%esp
f01031fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103205:	75 07                	jne    f010320e <commnad_load_env+0x27>
		return 0 ;
f0103207:	b8 00 00 00 00       	mov    $0x0,%eax
f010320c:	eb 2a                	jmp    f0103238 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010320e:	83 ec 0c             	sub    $0xc,%esp
f0103211:	ff 75 f4             	pushl  -0xc(%ebp)
f0103214:	e8 a1 24 00 00       	call   f01056ba <sched_new_env>
f0103219:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010321c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321f:	8b 40 10             	mov    0x10(%eax),%eax
f0103222:	83 ec 08             	sub    $0x8,%esp
f0103225:	50                   	push   %eax
f0103226:	68 f8 34 12 f0       	push   $0xf01234f8
f010322b:	e8 5b dd ff ff       	call   f0100f8b <cprintf>
f0103230:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103233:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103238:	c9                   	leave  
f0103239:	c3                   	ret    

f010323a <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f010323a:	55                   	push   %ebp
f010323b:	89 e5                	mov    %esp,%ebp
f010323d:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103240:	c7 05 70 49 5f f0 00 	movl   $0x0,0xf05f4970
f0103247:	00 00 00 
	sched_run_all();
f010324a:	e8 c4 2d 00 00       	call   f0106013 <sched_run_all>

	return 0 ;
f010324f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103254:	c9                   	leave  
f0103255:	c3                   	ret    

f0103256 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103256:	55                   	push   %ebp
f0103257:	89 e5                	mov    %esp,%ebp
f0103259:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f010325c:	e8 91 2b 00 00       	call   f0105df2 <sched_print_all>

	return 0 ;
f0103261:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103266:	c9                   	leave  
f0103267:	c3                   	ret    

f0103268 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103268:	55                   	push   %ebp
f0103269:	89 e5                	mov    %esp,%ebp
f010326b:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f010326e:	e8 35 2e 00 00       	call   f01060a8 <sched_kill_all>

	return 0 ;
f0103273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103278:	c9                   	leave  
f0103279:	c3                   	ret    

f010327a <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f010327a:	55                   	push   %ebp
f010327b:	89 e5                	mov    %esp,%ebp
f010327d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103280:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103284:	7f 1a                	jg     f01032a0 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103286:	83 ec 0c             	sub    $0xc,%esp
f0103289:	68 10 35 12 f0       	push   $0xf0123510
f010328e:	e8 f8 dc ff ff       	call   f0100f8b <cprintf>
f0103293:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103296:	b8 00 00 00 00       	mov    $0x0,%eax
f010329b:	e9 83 00 00 00       	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032a3:	83 c0 04             	add    $0x4,%eax
f01032a6:	8b 00                	mov    (%eax),%eax
f01032a8:	83 ec 04             	sub    $0x4,%esp
f01032ab:	6a 0a                	push   $0xa
f01032ad:	6a 00                	push   $0x0
f01032af:	50                   	push   %eax
f01032b0:	e8 f8 bb 01 00       	call   f011eead <strtol>
f01032b5:	83 c4 10             	add    $0x10,%esp
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032bb:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032bf:	75 20                	jne    f01032e1 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032c1:	83 ec 0c             	sub    $0xc,%esp
f01032c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01032c7:	e8 d4 b3 00 00       	call   f010e6a0 <setPageReplacmentAlgorithmLRU>
f01032cc:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f01032cf:	83 ec 0c             	sub    $0xc,%esp
f01032d2:	68 70 35 12 f0       	push   $0xf0123570
f01032d7:	e8 af dc ff ff       	call   f0100f8b <cprintf>
f01032dc:	83 c4 10             	add    $0x10,%esp
f01032df:	eb 3d                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f01032e1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01032e5:	75 20                	jne    f0103307 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032e7:	83 ec 0c             	sub    $0xc,%esp
f01032ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01032ed:	e8 ae b3 00 00       	call   f010e6a0 <setPageReplacmentAlgorithmLRU>
f01032f2:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01032f5:	83 ec 0c             	sub    $0xc,%esp
f01032f8:	68 b4 35 12 f0       	push   $0xf01235b4
f01032fd:	e8 89 dc ff ff       	call   f0100f8b <cprintf>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	eb 17                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103307:	83 ec 0c             	sub    $0xc,%esp
f010330a:	68 f4 35 12 f0       	push   $0xf01235f4
f010330f:	e8 77 dc ff ff       	call   f0100f8b <cprintf>
f0103314:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103317:	b8 00 00 00 00       	mov    $0x0,%eax
f010331c:	eb 05                	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f010332b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010332e:	83 c0 04             	add    $0x4,%eax
f0103331:	8b 00                	mov    (%eax),%eax
f0103333:	83 ec 04             	sub    $0x4,%esp
f0103336:	6a 0a                	push   $0xa
f0103338:	6a 00                	push   $0x0
f010333a:	50                   	push   %eax
f010333b:	e8 6d bb 01 00       	call   f011eead <strtol>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103346:	83 ec 0c             	sub    $0xc,%esp
f0103349:	ff 75 f4             	pushl  -0xc(%ebp)
f010334c:	e8 c2 b3 00 00       	call   f010e713 <setPageReplacmentAlgorithmNchanceCLOCK>
f0103351:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103354:	83 ec 0c             	sub    $0xc,%esp
f0103357:	68 48 36 12 f0       	push   $0xf0123648
f010335c:	e8 2a dc ff ff       	call   f0100f8b <cprintf>
f0103361:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103364:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103369:	c9                   	leave  
f010336a:	c3                   	ret    

f010336b <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010336b:	55                   	push   %ebp
f010336c:	89 e5                	mov    %esp,%ebp
f010336e:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103371:	e8 5d b3 00 00       	call   f010e6d3 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103376:	83 ec 0c             	sub    $0xc,%esp
f0103379:	68 7c 36 12 f0       	push   $0xf012367c
f010337e:	e8 08 dc ff ff       	call   f0100f8b <cprintf>
f0103383:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010338b:	c9                   	leave  
f010338c:	c3                   	ret    

f010338d <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010338d:	55                   	push   %ebp
f010338e:	89 e5                	mov    %esp,%ebp
f0103390:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103393:	e8 4b b3 00 00       	call   f010e6e3 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103398:	83 ec 0c             	sub    $0xc,%esp
f010339b:	68 a8 36 12 f0       	push   $0xf01236a8
f01033a0:	e8 e6 db ff ff       	call   f0100f8b <cprintf>
f01033a5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033ad:	c9                   	leave  
f01033ae:	c3                   	ret    

f01033af <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033af:	55                   	push   %ebp
f01033b0:	89 e5                	mov    %esp,%ebp
f01033b2:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033b5:	e8 39 b3 00 00       	call   f010e6f3 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033ba:	83 ec 0c             	sub    $0xc,%esp
f01033bd:	68 d0 36 12 f0       	push   $0xf01236d0
f01033c2:	e8 c4 db ff ff       	call   f0100f8b <cprintf>
f01033c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033cf:	c9                   	leave  
f01033d0:	c3                   	ret    

f01033d1 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01033d1:	55                   	push   %ebp
f01033d2:	89 e5                	mov    %esp,%ebp
f01033d4:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01033d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033da:	83 c0 04             	add    $0x4,%eax
f01033dd:	8b 00                	mov    (%eax),%eax
f01033df:	83 ec 04             	sub    $0x4,%esp
f01033e2:	6a 0a                	push   $0xa
f01033e4:	6a 00                	push   $0x0
f01033e6:	50                   	push   %eax
f01033e7:	e8 c1 ba 01 00       	call   f011eead <strtol>
f01033ec:	83 c4 10             	add    $0x10,%esp
f01033ef:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01033f2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033f6:	83 ec 0c             	sub    $0xc,%esp
f01033f9:	50                   	push   %eax
f01033fa:	e8 3d 35 00 00       	call   f010693c <sched_init_RR>
f01033ff:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103402:	a1 84 46 5f f0       	mov    0xf05f4684,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 04 37 12 f0       	push   $0xf0123704
f0103415:	e8 71 db ff ff       	call   f0100f8b <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103422:	c9                   	leave  
f0103423:	c3                   	ret    

f0103424 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103424:	55                   	push   %ebp
f0103425:	89 e5                	mov    %esp,%ebp
f0103427:	53                   	push   %ebx
f0103428:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010342e:	83 c0 04             	add    $0x4,%eax
f0103431:	8b 00                	mov    (%eax),%eax
f0103433:	83 ec 04             	sub    $0x4,%esp
f0103436:	6a 0a                	push   $0xa
f0103438:	6a 00                	push   $0x0
f010343a:	50                   	push   %eax
f010343b:	e8 6d ba 01 00       	call   f011eead <strtol>
f0103440:	83 c4 10             	add    $0x10,%esp
f0103443:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103446:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010344d:	eb 2e                	jmp    f010347d <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f010344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103452:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103458:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010345f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103462:	01 d0                	add    %edx,%eax
f0103464:	8b 00                	mov    (%eax),%eax
f0103466:	83 ec 04             	sub    $0x4,%esp
f0103469:	6a 0a                	push   $0xa
f010346b:	6a 00                	push   $0x0
f010346d:	50                   	push   %eax
f010346e:	e8 3a ba 01 00       	call   f011eead <strtol>
f0103473:	83 c4 10             	add    $0x10,%esp
f0103476:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347a:	ff 45 f4             	incl   -0xc(%ebp)
f010347d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103480:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103483:	7c ca                	jl     f010344f <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103485:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103489:	83 ec 08             	sub    $0x8,%esp
f010348c:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f010348f:	52                   	push   %edx
f0103490:	50                   	push   %eax
f0103491:	e8 54 35 00 00       	call   f01069ea <sched_init_MLFQ>
f0103496:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103499:	83 ec 0c             	sub    $0xc,%esp
f010349c:	68 3c 37 12 f0       	push   $0xf012373c
f01034a1:	e8 e5 da ff ff       	call   f0100f8b <cprintf>
f01034a6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034b0:	eb 24                	jmp    f01034d6 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034b2:	8b 15 84 46 5f f0    	mov    0xf05f4684,%edx
f01034b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034bb:	01 d0                	add    %edx,%eax
f01034bd:	8a 00                	mov    (%eax),%al
f01034bf:	0f b6 c0             	movzbl %al,%eax
f01034c2:	83 ec 08             	sub    $0x8,%esp
f01034c5:	50                   	push   %eax
f01034c6:	68 69 37 12 f0       	push   $0xf0123769
f01034cb:	e8 bb da ff ff       	call   f0100f8b <cprintf>
f01034d0:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034d3:	ff 45 f0             	incl   -0x10(%ebp)
f01034d6:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f01034db:	0f b6 c0             	movzbl %al,%eax
f01034de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034e1:	7f cf                	jg     f01034b2 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01034e3:	83 ec 0c             	sub    $0xc,%esp
f01034e6:	68 ed 30 12 f0       	push   $0xf01230ed
f01034eb:	e8 9b da ff ff       	call   f0100f8b <cprintf>
f01034f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01034fb:	c9                   	leave  
f01034fc:	c3                   	ret    

f01034fd <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 0a                	push   $0xa
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 95 b9 01 00       	call   f011eead <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f010351e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103521:	83 c0 08             	add    $0x8,%eax
f0103524:	8b 00                	mov    (%eax),%eax
f0103526:	83 ec 04             	sub    $0x4,%esp
f0103529:	6a 0a                	push   $0xa
f010352b:	6a 00                	push   $0x0
f010352d:	50                   	push   %eax
f010352e:	e8 7a b9 01 00       	call   f011eead <strtol>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103539:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010353d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103541:	83 ec 08             	sub    $0x8,%esp
f0103544:	52                   	push   %edx
f0103545:	50                   	push   %eax
f0103546:	e8 c7 34 00 00       	call   f0106a12 <sched_init_BSD>
f010354b:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f010354e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103552:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103556:	83 ec 04             	sub    $0x4,%esp
f0103559:	52                   	push   %edx
f010355a:	50                   	push   %eax
f010355b:	68 70 37 12 f0       	push   $0xf0123770
f0103560:	e8 26 da ff ff       	call   f0100f8b <cprintf>
f0103565:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103568:	83 ec 0c             	sub    $0xc,%esp
f010356b:	68 ed 30 12 f0       	push   $0xf01230ed
f0103570:	e8 16 da ff ff       	call   f0100f8b <cprintf>
f0103575:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103578:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010357d:	c9                   	leave  
f010357e:	c3                   	ret    

f010357f <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f010357f:	55                   	push   %ebp
f0103580:	89 e5                	mov    %esp,%ebp
f0103582:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103585:	e8 0b 31 00 00       	call   f0106695 <isSchedMethodMLFQ>
f010358a:	85 c0                	test   %eax,%eax
f010358c:	74 5c                	je     f01035ea <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010358e:	83 ec 0c             	sub    $0xc,%esp
f0103591:	68 ac 37 12 f0       	push   $0xf01237ac
f0103596:	e8 f0 d9 ff ff       	call   f0100f8b <cprintf>
f010359b:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010359e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035a5:	eb 24                	jmp    f01035cb <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035a7:	8b 15 84 46 5f f0    	mov    0xf05f4684,%edx
f01035ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035b0:	01 d0                	add    %edx,%eax
f01035b2:	8a 00                	mov    (%eax),%al
f01035b4:	0f b6 c0             	movzbl %al,%eax
f01035b7:	83 ec 08             	sub    $0x8,%esp
f01035ba:	50                   	push   %eax
f01035bb:	68 69 37 12 f0       	push   $0xf0123769
f01035c0:	e8 c6 d9 ff ff       	call   f0100f8b <cprintf>
f01035c5:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035c8:	ff 45 f4             	incl   -0xc(%ebp)
f01035cb:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f01035d0:	0f b6 c0             	movzbl %al,%eax
f01035d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01035d6:	7f cf                	jg     f01035a7 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f01035d8:	83 ec 0c             	sub    $0xc,%esp
f01035db:	68 ed 30 12 f0       	push   $0xf01230ed
f01035e0:	e8 a6 d9 ff ff       	call   f0100f8b <cprintf>
f01035e5:	83 c4 10             	add    $0x10,%esp
f01035e8:	eb 65                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f01035ea:	e8 8c 30 00 00       	call   f010667b <isSchedMethodRR>
f01035ef:	85 c0                	test   %eax,%eax
f01035f1:	74 1d                	je     f0103610 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f01035f3:	a1 84 46 5f f0       	mov    0xf05f4684,%eax
f01035f8:	8a 00                	mov    (%eax),%al
f01035fa:	0f b6 c0             	movzbl %al,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	50                   	push   %eax
f0103601:	68 e0 37 12 f0       	push   $0xf01237e0
f0103606:	e8 80 d9 ff ff       	call   f0100f8b <cprintf>
f010360b:	83 c4 10             	add    $0x10,%esp
f010360e:	eb 3f                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103610:	e8 9b 30 00 00       	call   f01066b0 <isSchedMethodBSD>
f0103615:	85 c0                	test   %eax,%eax
f0103617:	74 26                	je     f010363f <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103619:	a1 84 46 5f f0       	mov    0xf05f4684,%eax
f010361e:	8a 00                	mov    (%eax),%al
f0103620:	0f b6 d0             	movzbl %al,%edx
f0103623:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f0103628:	0f b6 c0             	movzbl %al,%eax
f010362b:	83 ec 04             	sub    $0x4,%esp
f010362e:	52                   	push   %edx
f010362f:	50                   	push   %eax
f0103630:	68 70 37 12 f0       	push   $0xf0123770
f0103635:	e8 51 d9 ff ff       	call   f0100f8b <cprintf>
f010363a:	83 c4 10             	add    $0x10,%esp
f010363d:	eb 10                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f010363f:	83 ec 0c             	sub    $0xc,%esp
f0103642:	68 1c 38 12 f0       	push   $0xf012381c
f0103647:	e8 3f d9 ff ff       	call   f0100f8b <cprintf>
f010364c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010364f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103654:	c9                   	leave  
f0103655:	c3                   	ret    

f0103656 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f0103656:	55                   	push   %ebp
f0103657:	89 e5                	mov    %esp,%ebp
f0103659:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f010365c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010365f:	83 c0 04             	add    $0x4,%eax
f0103662:	8b 00                	mov    (%eax),%eax
f0103664:	83 ec 04             	sub    $0x4,%esp
f0103667:	6a 0a                	push   $0xa
f0103669:	6a 00                	push   $0x0
f010366b:	50                   	push   %eax
f010366c:	e8 3c b8 01 00       	call   f011eead <strtol>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010367a:	0f b6 c0             	movzbl %al,%eax
f010367d:	83 ec 0c             	sub    $0xc,%esp
f0103680:	50                   	push   %eax
f0103681:	e8 1b a6 01 00       	call   f011dca1 <chksch>
f0103686:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010368d:	75 12                	jne    f01036a1 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	68 44 38 12 f0       	push   $0xf0123844
f0103697:	e8 ef d8 ff ff       	call   f0100f8b <cprintf>
f010369c:	83 c4 10             	add    $0x10,%esp
f010369f:	eb 16                	jmp    f01036b7 <command_sch_test+0x61>
	else if (status == 1)
f01036a1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036a5:	75 10                	jne    f01036b7 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036a7:	83 ec 0c             	sub    $0xc,%esp
f01036aa:	68 6c 38 12 f0       	push   $0xf012386c
f01036af:	e8 d7 d8 ff ff       	call   f0100f8b <cprintf>
f01036b4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036bc:	c9                   	leave  
f01036bd:	c3                   	ret    

f01036be <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036be:	55                   	push   %ebp
f01036bf:	89 e5                	mov    %esp,%ebp
f01036c1:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036c4:	e8 78 b0 00 00       	call   f010e741 <isPageReplacmentAlgorithmCLOCK>
f01036c9:	85 c0                	test   %eax,%eax
f01036cb:	74 15                	je     f01036e2 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f01036cd:	83 ec 0c             	sub    $0xc,%esp
f01036d0:	68 90 38 12 f0       	push   $0xf0123890
f01036d5:	e8 b1 d8 ff ff       	call   f0100f8b <cprintf>
f01036da:	83 c4 10             	add    $0x10,%esp
f01036dd:	e9 8c 00 00 00       	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	6a 01                	push   $0x1
f01036e7:	e8 3f b0 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f01036ec:	83 c4 10             	add    $0x10,%esp
f01036ef:	85 c0                	test   %eax,%eax
f01036f1:	74 12                	je     f0103705 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f01036f3:	83 ec 0c             	sub    $0xc,%esp
f01036f6:	68 b8 38 12 f0       	push   $0xf01238b8
f01036fb:	e8 8b d8 ff ff       	call   f0100f8b <cprintf>
f0103700:	83 c4 10             	add    $0x10,%esp
f0103703:	eb 69                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103705:	83 ec 0c             	sub    $0xc,%esp
f0103708:	6a 02                	push   $0x2
f010370a:	e8 1c b0 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f010370f:	83 c4 10             	add    $0x10,%esp
f0103712:	85 c0                	test   %eax,%eax
f0103714:	74 12                	je     f0103728 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103716:	83 ec 0c             	sub    $0xc,%esp
f0103719:	68 f8 38 12 f0       	push   $0xf01238f8
f010371e:	e8 68 d8 ff ff       	call   f0100f8b <cprintf>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	eb 46                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103728:	e8 2f b0 00 00       	call   f010e75c <isPageReplacmentAlgorithmFIFO>
f010372d:	85 c0                	test   %eax,%eax
f010372f:	74 12                	je     f0103743 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103731:	83 ec 0c             	sub    $0xc,%esp
f0103734:	68 34 39 12 f0       	push   $0xf0123934
f0103739:	e8 4d d8 ff ff       	call   f0100f8b <cprintf>
f010373e:	83 c4 10             	add    $0x10,%esp
f0103741:	eb 2b                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103743:	e8 2f b0 00 00       	call   f010e777 <isPageReplacmentAlgorithmModifiedCLOCK>
f0103748:	85 c0                	test   %eax,%eax
f010374a:	74 12                	je     f010375e <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010374c:	83 ec 0c             	sub    $0xc,%esp
f010374f:	68 58 39 12 f0       	push   $0xf0123958
f0103754:	e8 32 d8 ff ff       	call   f0100f8b <cprintf>
f0103759:	83 c4 10             	add    $0x10,%esp
f010375c:	eb 10                	jmp    f010376e <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f010375e:	83 ec 0c             	sub    $0xc,%esp
f0103761:	68 88 39 12 f0       	push   $0xf0123988
f0103766:	e8 20 d8 ff ff       	call   f0100f8b <cprintf>
f010376b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010376e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103773:	c9                   	leave  
f0103774:	c3                   	ret    

f0103775 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103775:	55                   	push   %ebp
f0103776:	89 e5                	mov    %esp,%ebp
f0103778:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010377b:	e8 2f ee ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103780:	83 ec 0c             	sub    $0xc,%esp
f0103783:	68 b4 39 12 f0       	push   $0xf01239b4
f0103788:	e8 fe d7 ff ff       	call   f0100f8b <cprintf>
f010378d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103795:	c9                   	leave  
f0103796:	c3                   	ret    

f0103797 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103797:	55                   	push   %ebp
f0103798:	89 e5                	mov    %esp,%ebp
f010379a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010379d:	e8 1d ee ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037a2:	83 ec 0c             	sub    $0xc,%esp
f01037a5:	68 e4 39 12 f0       	push   $0xf01239e4
f01037aa:	e8 dc d7 ff ff       	call   f0100f8b <cprintf>
f01037af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037b7:	c9                   	leave  
f01037b8:	c3                   	ret    

f01037b9 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037b9:	55                   	push   %ebp
f01037ba:	89 e5                	mov    %esp,%ebp
f01037bc:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037bf:	e8 0b ee ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037c4:	83 ec 0c             	sub    $0xc,%esp
f01037c7:	68 14 3a 12 f0       	push   $0xf0123a14
f01037cc:	e8 ba d7 ff ff       	call   f0100f8b <cprintf>
f01037d1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037d9:	c9                   	leave  
f01037da:	c3                   	ret    

f01037db <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01037db:	55                   	push   %ebp
f01037dc:	89 e5                	mov    %esp,%ebp
f01037de:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01037e1:	e8 f9 ed ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01037e6:	83 ec 0c             	sub    $0xc,%esp
f01037e9:	68 44 3a 12 f0       	push   $0xf0123a44
f01037ee:	e8 98 d7 ff ff       	call   f0100f8b <cprintf>
f01037f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037fb:	c9                   	leave  
f01037fc:	c3                   	ret    

f01037fd <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01037fd:	55                   	push   %ebp
f01037fe:	89 e5                	mov    %esp,%ebp
f0103800:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103803:	e8 e7 ed ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 74 3a 12 f0       	push   $0xf0123a74
f0103814:	e8 72 d7 ff ff       	call   f0100f8b <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 61                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010381e:	e8 e1 ed ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 a0 3a 12 f0       	push   $0xf0123aa0
f010382f:	e8 57 d7 ff ff       	call   f0100f8b <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 46                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103839:	e8 db ed ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f010383e:	84 c0                	test   %al,%al
f0103840:	74 12                	je     f0103854 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103842:	83 ec 0c             	sub    $0xc,%esp
f0103845:	68 cc 3a 12 f0       	push   $0xf0123acc
f010384a:	e8 3c d7 ff ff       	call   f0100f8b <cprintf>
f010384f:	83 c4 10             	add    $0x10,%esp
f0103852:	eb 2b                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103854:	e8 d5 ed ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103859:	84 c0                	test   %al,%al
f010385b:	74 12                	je     f010386f <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f010385d:	83 ec 0c             	sub    $0xc,%esp
f0103860:	68 f8 3a 12 f0       	push   $0xf0123af8
f0103865:	e8 21 d7 ff ff       	call   f0100f8b <cprintf>
f010386a:	83 c4 10             	add    $0x10,%esp
f010386d:	eb 10                	jmp    f010387f <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f010386f:	83 ec 0c             	sub    $0xc,%esp
f0103872:	68 24 3b 12 f0       	push   $0xf0123b24
f0103877:	e8 0f d7 ff ff       	call   f0100f8b <cprintf>
f010387c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010387f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103884:	c9                   	leave  
f0103885:	c3                   	ret    

f0103886 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103886:	55                   	push   %ebp
f0103887:	89 e5                	mov    %esp,%ebp
f0103889:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f010388c:	e8 66 ec ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 50 3b 12 f0       	push   $0xf0123b50
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038a6:	c9                   	leave  
f01038a7:	c3                   	ret    

f01038a8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038a8:	55                   	push   %ebp
f01038a9:	89 e5                	mov    %esp,%ebp
f01038ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038ae:	e8 54 ec ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038b3:	83 ec 0c             	sub    $0xc,%esp
f01038b6:	68 50 3b 12 f0       	push   $0xf0123b50
f01038bb:	e8 cb d6 ff ff       	call   f0100f8b <cprintf>
f01038c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038c8:	c9                   	leave  
f01038c9:	c3                   	ret    

f01038ca <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01038ca:	55                   	push   %ebp
f01038cb:	89 e5                	mov    %esp,%ebp
f01038cd:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f01038d0:	e8 42 ec ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 84 3b 12 f0       	push   $0xf0123b84
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ea:	c9                   	leave  
f01038eb:	c3                   	ret    

f01038ec <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01038ec:	55                   	push   %ebp
f01038ed:	89 e5                	mov    %esp,%ebp
f01038ef:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f01038f2:	e8 30 ec ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f01038f7:	83 ec 0c             	sub    $0xc,%esp
f01038fa:	68 b4 3b 12 f0       	push   $0xf0123bb4
f01038ff:	e8 87 d6 ff ff       	call   f0100f8b <cprintf>
f0103904:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103907:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390c:	c9                   	leave  
f010390d:	c3                   	ret    

f010390e <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010390e:	55                   	push   %ebp
f010390f:	89 e5                	mov    %esp,%ebp
f0103911:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103914:	e8 1e ec ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103919:	83 ec 0c             	sub    $0xc,%esp
f010391c:	68 e4 3b 12 f0       	push   $0xf0123be4
f0103921:	e8 65 d6 ff ff       	call   f0100f8b <cprintf>
f0103926:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103929:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392e:	c9                   	leave  
f010392f:	c3                   	ret    

f0103930 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103930:	55                   	push   %ebp
f0103931:	89 e5                	mov    %esp,%ebp
f0103933:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103936:	e8 0c ec ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f010393b:	84 c0                	test   %al,%al
f010393d:	74 12                	je     f0103951 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 18 3c 12 f0       	push   $0xf0123c18
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 7c                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103951:	e8 05 ec ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103956:	84 c0                	test   %al,%al
f0103958:	74 12                	je     f010396c <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010395a:	83 ec 0c             	sub    $0xc,%esp
f010395d:	68 54 3c 12 f0       	push   $0xf0123c54
f0103962:	e8 24 d6 ff ff       	call   f0100f8b <cprintf>
f0103967:	83 c4 10             	add    $0x10,%esp
f010396a:	eb 61                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f010396c:	e8 ff eb ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103971:	84 c0                	test   %al,%al
f0103973:	74 12                	je     f0103987 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103975:	83 ec 0c             	sub    $0xc,%esp
f0103978:	68 84 3c 12 f0       	push   $0xf0123c84
f010397d:	e8 09 d6 ff ff       	call   f0100f8b <cprintf>
f0103982:	83 c4 10             	add    $0x10,%esp
f0103985:	eb 46                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103987:	e8 f9 eb ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f010398c:	84 c0                	test   %al,%al
f010398e:	74 12                	je     f01039a2 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103990:	83 ec 0c             	sub    $0xc,%esp
f0103993:	68 b0 3c 12 f0       	push   $0xf0123cb0
f0103998:	e8 ee d5 ff ff       	call   f0100f8b <cprintf>
f010399d:	83 c4 10             	add    $0x10,%esp
f01039a0:	eb 2b                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039a2:	e8 f3 eb ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f01039a7:	84 c0                	test   %al,%al
f01039a9:	74 12                	je     f01039bd <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039ab:	83 ec 0c             	sub    $0xc,%esp
f01039ae:	68 dc 3c 12 f0       	push   $0xf0123cdc
f01039b3:	e8 d3 d5 ff ff       	call   f0100f8b <cprintf>
f01039b8:	83 c4 10             	add    $0x10,%esp
f01039bb:	eb 10                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	68 0c 3d 12 f0       	push   $0xf0123d0c
f01039c5:	e8 c1 d5 ff ff       	call   f0100f8b <cprintf>
f01039ca:	83 c4 10             	add    $0x10,%esp

	return 0;
f01039cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039d2:	c9                   	leave  
f01039d3:	c3                   	ret    

f01039d4 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f01039d4:	55                   	push   %ebp
f01039d5:	89 e5                	mov    %esp,%ebp
f01039d7:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039da:	e8 0f ae 00 00       	call   f010e7ee <isBufferingEnabled>
f01039df:	84 c0                	test   %al,%al
f01039e1:	75 12                	jne    f01039f5 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01039e3:	83 ec 0c             	sub    $0xc,%esp
f01039e6:	68 3c 3d 12 f0       	push   $0xf0123d3c
f01039eb:	e8 9b d5 ff ff       	call   f0100f8b <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
f01039f3:	eb 1d                	jmp    f0103a12 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f01039f5:	83 ec 0c             	sub    $0xc,%esp
f01039f8:	6a 00                	push   $0x0
f01039fa:	e8 c9 ad 00 00       	call   f010e7c8 <enableModifiedBuffer>
f01039ff:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a02:	83 ec 0c             	sub    $0xc,%esp
f0103a05:	68 78 3d 12 f0       	push   $0xf0123d78
f0103a0a:	e8 7c d5 ff ff       	call   f0100f8b <cprintf>
f0103a0f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a17:	c9                   	leave  
f0103a18:	c3                   	ret    

f0103a19 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a19:	55                   	push   %ebp
f0103a1a:	89 e5                	mov    %esp,%ebp
f0103a1c:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a1f:	e8 ca ad 00 00       	call   f010e7ee <isBufferingEnabled>
f0103a24:	84 c0                	test   %al,%al
f0103a26:	75 12                	jne    f0103a3a <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a28:	83 ec 0c             	sub    $0xc,%esp
f0103a2b:	68 3c 3d 12 f0       	push   $0xf0123d3c
f0103a30:	e8 56 d5 ff ff       	call   f0100f8b <cprintf>
f0103a35:	83 c4 10             	add    $0x10,%esp
f0103a38:	eb 1d                	jmp    f0103a57 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a3a:	83 ec 0c             	sub    $0xc,%esp
f0103a3d:	6a 01                	push   $0x1
f0103a3f:	e8 84 ad 00 00       	call   f010e7c8 <enableModifiedBuffer>
f0103a44:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a47:	83 ec 0c             	sub    $0xc,%esp
f0103a4a:	68 9c 3d 12 f0       	push   $0xf0123d9c
f0103a4f:	e8 37 d5 ff ff       	call   f0100f8b <cprintf>
f0103a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a57:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a5c:	c9                   	leave  
f0103a5d:	c3                   	ret    

f0103a5e <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a5e:	55                   	push   %ebp
f0103a5f:	89 e5                	mov    %esp,%ebp
f0103a61:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	6a 00                	push   $0x0
f0103a69:	e8 72 ad 00 00       	call   f010e7e0 <enableBuffering>
f0103a6e:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 00                	push   $0x0
f0103a76:	e8 4d ad 00 00       	call   f010e7c8 <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 bc 3d 12 f0       	push   $0xf0123dbc
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 01                	push   $0x1
f0103aa0:	e8 3b ad 00 00       	call   f010e7e0 <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 01                	push   $0x1
f0103aad:	e8 16 ad 00 00       	call   f010e7c8 <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ab5:	e8 4c ad 00 00       	call   f010e806 <getModifiedBufferLength>
f0103aba:	85 c0                	test   %eax,%eax
f0103abc:	75 59                	jne    f0103b17 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103abe:	83 ec 0c             	sub    $0xc,%esp
f0103ac1:	68 d8 3d 12 f0       	push   $0xf0123dd8
f0103ac6:	e8 c0 d4 ff ff       	call   f0100f8b <cprintf>
f0103acb:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103ace:	83 ec 08             	sub    $0x8,%esp
f0103ad1:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ad4:	50                   	push   %eax
f0103ad5:	68 08 3e 12 f0       	push   $0xf0123e08
f0103ada:	e8 66 ae 01 00       	call   f011e945 <readline>
f0103adf:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103ae2:	83 ec 04             	sub    $0x4,%esp
f0103ae5:	6a 0a                	push   $0xa
f0103ae7:	6a 00                	push   $0x0
f0103ae9:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103aec:	50                   	push   %eax
f0103aed:	e8 bb b3 01 00       	call   f011eead <strtol>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	50                   	push   %eax
f0103af9:	e8 fa ac 00 00       	call   f010e7f8 <setModifiedBufferLength>
f0103afe:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b01:	e8 00 ad 00 00       	call   f010e806 <getModifiedBufferLength>
f0103b06:	83 ec 08             	sub    $0x8,%esp
f0103b09:	50                   	push   %eax
f0103b0a:	68 34 3e 12 f0       	push   $0xf0123e34
f0103b0f:	e8 77 d4 ff ff       	call   f0100f8b <cprintf>
f0103b14:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b17:	83 ec 0c             	sub    $0xc,%esp
f0103b1a:	68 59 3e 12 f0       	push   $0xf0123e59
f0103b1f:	e8 67 d4 ff ff       	call   f0100f8b <cprintf>
f0103b24:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b2c:	c9                   	leave  
f0103b2d:	c3                   	ret    

f0103b2e <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b2e:	55                   	push   %ebp
f0103b2f:	89 e5                	mov    %esp,%ebp
f0103b31:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b34:	e8 b5 ac 00 00       	call   f010e7ee <isBufferingEnabled>
f0103b39:	84 c0                	test   %al,%al
f0103b3b:	75 12                	jne    f0103b4f <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b3d:	83 ec 0c             	sub    $0xc,%esp
f0103b40:	68 74 3e 12 f0       	push   $0xf0123e74
f0103b45:	e8 41 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	eb 19                	jmp    f0103b68 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b4f:	e8 82 ac 00 00       	call   f010e7d6 <isModifiedBufferEnabled>
f0103b54:	84 c0                	test   %al,%al
f0103b56:	75 10                	jne    f0103b68 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b58:	83 ec 0c             	sub    $0xc,%esp
f0103b5b:	68 c4 3e 12 f0       	push   $0xf0123ec4
f0103b60:	e8 26 d4 ff ff       	call   f0100f8b <cprintf>
f0103b65:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b6b:	83 c0 04             	add    $0x4,%eax
f0103b6e:	8b 00                	mov    (%eax),%eax
f0103b70:	83 ec 04             	sub    $0x4,%esp
f0103b73:	6a 0a                	push   $0xa
f0103b75:	6a 00                	push   $0x0
f0103b77:	50                   	push   %eax
f0103b78:	e8 30 b3 01 00       	call   f011eead <strtol>
f0103b7d:	83 c4 10             	add    $0x10,%esp
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	50                   	push   %eax
f0103b84:	e8 6f ac 00 00       	call   f010e7f8 <setModifiedBufferLength>
f0103b89:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b8c:	e8 75 ac 00 00       	call   f010e806 <getModifiedBufferLength>
f0103b91:	83 ec 08             	sub    $0x8,%esp
f0103b94:	50                   	push   %eax
f0103b95:	68 34 3e 12 f0       	push   $0xf0123e34
f0103b9a:	e8 ec d3 ff ff       	call   f0100f8b <cprintf>
f0103b9f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ba2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba7:	c9                   	leave  
f0103ba8:	c3                   	ret    

f0103ba9 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103ba9:	55                   	push   %ebp
f0103baa:	89 e5                	mov    %esp,%ebp
f0103bac:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103baf:	e8 3a ac 00 00       	call   f010e7ee <isBufferingEnabled>
f0103bb4:	84 c0                	test   %al,%al
f0103bb6:	75 12                	jne    f0103bca <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	68 74 3e 12 f0       	push   $0xf0123e74
f0103bc0:	e8 c6 d3 ff ff       	call   f0100f8b <cprintf>
f0103bc5:	83 c4 10             	add    $0x10,%esp
f0103bc8:	eb 19                	jmp    f0103be3 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103bca:	e8 07 ac 00 00       	call   f010e7d6 <isModifiedBufferEnabled>
f0103bcf:	84 c0                	test   %al,%al
f0103bd1:	75 10                	jne    f0103be3 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	68 c4 3e 12 f0       	push   $0xf0123ec4
f0103bdb:	e8 ab d3 ff ff       	call   f0100f8b <cprintf>
f0103be0:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103be3:	e8 1e ac 00 00       	call   f010e806 <getModifiedBufferLength>
f0103be8:	83 ec 08             	sub    $0x8,%esp
f0103beb:	50                   	push   %eax
f0103bec:	68 0a 3f 12 f0       	push   $0xf0123f0a
f0103bf1:	e8 95 d3 ff ff       	call   f0100f8b <cprintf>
f0103bf6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bfe:	c9                   	leave  
f0103bff:	c3                   	ret    

f0103c00 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c00:	55                   	push   %ebp
f0103c01:	89 e5                	mov    %esp,%ebp
f0103c03:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c06:	83 ec 08             	sub    $0x8,%esp
f0103c09:	ff 75 0c             	pushl  0xc(%ebp)
f0103c0c:	ff 75 08             	pushl  0x8(%ebp)
f0103c0f:	e8 5f b5 00 00       	call   f010f173 <tst_handler>
f0103c14:	83 c4 10             	add    $0x10,%esp
}
f0103c17:	c9                   	leave  
f0103c18:	c3                   	ret    

f0103c19 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c19:	55                   	push   %ebp
f0103c1a:	89 e5                	mov    %esp,%ebp
f0103c1c:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c22:	05 00 14 00 00       	add    $0x1400,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c2d:	83 ec 04             	sub    $0x4,%esp
f0103c30:	6a 08                	push   $0x8
f0103c32:	ff 75 0c             	pushl  0xc(%ebp)
f0103c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c38:	e8 f8 b6 01 00       	call   f011f335 <ide_read>
f0103c3d:	83 c4 10             	add    $0x10,%esp
f0103c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c46:	c9                   	leave  
f0103c47:	c3                   	ret    

f0103c48 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c48:	55                   	push   %ebp
f0103c49:	89 e5                	mov    %esp,%ebp
f0103c4b:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c51:	05 00 14 00 00       	add    $0x1400,%eax
f0103c56:	c1 e0 03             	shl    $0x3,%eax
f0103c59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c5c:	83 ec 04             	sub    $0x4,%esp
f0103c5f:	6a 08                	push   $0x8
f0103c61:	ff 75 0c             	pushl  0xc(%ebp)
f0103c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c67:	e8 09 b8 01 00       	call   f011f475 <ide_write>
f0103c6c:	83 c4 10             	add    $0x10,%esp
f0103c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103c72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103c76:	74 14                	je     f0103c8c <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103c78:	83 ec 04             	sub    $0x4,%esp
f0103c7b:	68 28 3f 12 f0       	push   $0xf0123f28
f0103c80:	6a 2f                	push   $0x2f
f0103c82:	68 3f 3f 12 f0       	push   $0xf0123f3f
f0103c87:	e8 ad c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c8f:	c9                   	leave  
f0103c90:	c3                   	ret    

f0103c91 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103c91:	55                   	push   %ebp
f0103c92:	89 e5                	mov    %esp,%ebp
f0103c94:	53                   	push   %ebx
f0103c95:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103c98:	c7 05 80 49 5f f0 00 	movl   $0x0,0xf05f4980
f0103c9f:	00 00 00 
f0103ca2:	c7 05 84 49 5f f0 00 	movl   $0x0,0xf05f4984
f0103ca9:	00 00 00 
f0103cac:	c7 05 8c 49 5f f0 00 	movl   $0x0,0xf05f498c
f0103cb3:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cbd:	e9 e8 00 00 00       	jmp    f0103daa <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cc2:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ccb:	89 d0                	mov    %edx,%eax
f0103ccd:	01 c0                	add    %eax,%eax
f0103ccf:	01 d0                	add    %edx,%eax
f0103cd1:	c1 e0 03             	shl    $0x3,%eax
f0103cd4:	01 c8                	add    %ecx,%eax
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	50                   	push   %eax
f0103cda:	e8 4d 44 00 00       	call   f010812c <initialize_frame_info>
f0103cdf:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ce2:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ceb:	89 d0                	mov    %edx,%eax
f0103ced:	01 c0                	add    %eax,%eax
f0103cef:	01 d0                	add    %edx,%eax
f0103cf1:	c1 e0 03             	shl    $0x3,%eax
f0103cf4:	01 c8                	add    %ecx,%eax
f0103cf6:	85 c0                	test   %eax,%eax
f0103cf8:	75 14                	jne    f0103d0e <initialize_disk_page_file+0x7d>
f0103cfa:	83 ec 04             	sub    $0x4,%esp
f0103cfd:	68 5c 3f 12 f0       	push   $0xf0123f5c
f0103d02:	6a 56                	push   $0x56
f0103d04:	68 3f 3f 12 f0       	push   $0xf0123f3f
f0103d09:	e8 2b c6 ff ff       	call   f0100339 <_panic>
f0103d0e:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103d14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d17:	89 d0                	mov    %edx,%eax
f0103d19:	01 c0                	add    %eax,%eax
f0103d1b:	01 d0                	add    %edx,%eax
f0103d1d:	c1 e0 03             	shl    $0x3,%eax
f0103d20:	01 c8                	add    %ecx,%eax
f0103d22:	8b 15 80 49 5f f0    	mov    0xf05f4980,%edx
f0103d28:	89 10                	mov    %edx,(%eax)
f0103d2a:	8b 00                	mov    (%eax),%eax
f0103d2c:	85 c0                	test   %eax,%eax
f0103d2e:	74 1f                	je     f0103d4f <initialize_disk_page_file+0xbe>
f0103d30:	8b 15 80 49 5f f0    	mov    0xf05f4980,%edx
f0103d36:	8b 1d 80 40 5f f0    	mov    0xf05f4080,%ebx
f0103d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103d3f:	89 c8                	mov    %ecx,%eax
f0103d41:	01 c0                	add    %eax,%eax
f0103d43:	01 c8                	add    %ecx,%eax
f0103d45:	c1 e0 03             	shl    $0x3,%eax
f0103d48:	01 d8                	add    %ebx,%eax
f0103d4a:	89 42 04             	mov    %eax,0x4(%edx)
f0103d4d:	eb 19                	jmp    f0103d68 <initialize_disk_page_file+0xd7>
f0103d4f:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d58:	89 d0                	mov    %edx,%eax
f0103d5a:	01 c0                	add    %eax,%eax
f0103d5c:	01 d0                	add    %edx,%eax
f0103d5e:	c1 e0 03             	shl    $0x3,%eax
f0103d61:	01 c8                	add    %ecx,%eax
f0103d63:	a3 84 49 5f f0       	mov    %eax,0xf05f4984
f0103d68:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d71:	89 d0                	mov    %edx,%eax
f0103d73:	01 c0                	add    %eax,%eax
f0103d75:	01 d0                	add    %edx,%eax
f0103d77:	c1 e0 03             	shl    $0x3,%eax
f0103d7a:	01 c8                	add    %ecx,%eax
f0103d7c:	a3 80 49 5f f0       	mov    %eax,0xf05f4980
f0103d81:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103d87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8a:	89 d0                	mov    %edx,%eax
f0103d8c:	01 c0                	add    %eax,%eax
f0103d8e:	01 d0                	add    %edx,%eax
f0103d90:	c1 e0 03             	shl    $0x3,%eax
f0103d93:	01 c8                	add    %ecx,%eax
f0103d95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d9c:	a1 8c 49 5f f0       	mov    0xf05f498c,%eax
f0103da1:	40                   	inc    %eax
f0103da2:	a3 8c 49 5f f0       	mov    %eax,0xf05f498c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103da7:	ff 45 f4             	incl   -0xc(%ebp)
f0103daa:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103db1:	0f 8e 0b ff ff ff    	jle    f0103cc2 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103db7:	90                   	nop
f0103db8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103dbb:	c9                   	leave  
f0103dbc:	c3                   	ret    

f0103dbd <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103dbd:	55                   	push   %ebp
f0103dbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103dc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc3:	8b 15 80 40 5f f0    	mov    0xf05f4080,%edx
f0103dc9:	29 d0                	sub    %edx,%eax
f0103dcb:	c1 f8 03             	sar    $0x3,%eax
f0103dce:	89 c2                	mov    %eax,%edx
f0103dd0:	89 d0                	mov    %edx,%eax
f0103dd2:	c1 e0 02             	shl    $0x2,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 d0                	add    %edx,%eax
f0103ddc:	c1 e0 02             	shl    $0x2,%eax
f0103ddf:	01 d0                	add    %edx,%eax
f0103de1:	89 c1                	mov    %eax,%ecx
f0103de3:	c1 e1 08             	shl    $0x8,%ecx
f0103de6:	01 c8                	add    %ecx,%eax
f0103de8:	89 c1                	mov    %eax,%ecx
f0103dea:	c1 e1 10             	shl    $0x10,%ecx
f0103ded:	01 c8                	add    %ecx,%eax
f0103def:	01 c0                	add    %eax,%eax
f0103df1:	01 d0                	add    %edx,%eax
}
f0103df3:	5d                   	pop    %ebp
f0103df4:	c3                   	ret    

f0103df5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e02:	83 ec 0c             	sub    $0xc,%esp
f0103e05:	68 90 49 5f f0       	push   $0xf05f4990
f0103e0a:	e8 7d ad 00 00       	call   f010eb8c <acquire_spinlock>
f0103e0f:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e12:	a1 80 49 5f f0       	mov    0xf05f4980,%eax
f0103e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e1e:	75 0c                	jne    f0103e2c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e20:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e27:	e9 a2 00 00 00       	jmp    f0103ece <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e30:	75 14                	jne    f0103e46 <allocate_disk_frame+0x51>
f0103e32:	83 ec 04             	sub    $0x4,%esp
f0103e35:	68 7f 3f 12 f0       	push   $0xf0123f7f
f0103e3a:	6a 7b                	push   $0x7b
f0103e3c:	68 3f 3f 12 f0       	push   $0xf0123f3f
f0103e41:	e8 f3 c4 ff ff       	call   f0100339 <_panic>
f0103e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e49:	8b 00                	mov    (%eax),%eax
f0103e4b:	85 c0                	test   %eax,%eax
f0103e4d:	74 10                	je     f0103e5f <allocate_disk_frame+0x6a>
f0103e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e52:	8b 00                	mov    (%eax),%eax
f0103e54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e57:	8b 52 04             	mov    0x4(%edx),%edx
f0103e5a:	89 50 04             	mov    %edx,0x4(%eax)
f0103e5d:	eb 0b                	jmp    f0103e6a <allocate_disk_frame+0x75>
f0103e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e62:	8b 40 04             	mov    0x4(%eax),%eax
f0103e65:	a3 84 49 5f f0       	mov    %eax,0xf05f4984
f0103e6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e6d:	8b 40 04             	mov    0x4(%eax),%eax
f0103e70:	85 c0                	test   %eax,%eax
f0103e72:	74 0f                	je     f0103e83 <allocate_disk_frame+0x8e>
f0103e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e77:	8b 40 04             	mov    0x4(%eax),%eax
f0103e7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e7d:	8b 12                	mov    (%edx),%edx
f0103e7f:	89 10                	mov    %edx,(%eax)
f0103e81:	eb 0a                	jmp    f0103e8d <allocate_disk_frame+0x98>
f0103e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e86:	8b 00                	mov    (%eax),%eax
f0103e88:	a3 80 49 5f f0       	mov    %eax,0xf05f4980
f0103e8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea0:	a1 8c 49 5f f0       	mov    0xf05f498c,%eax
f0103ea5:	48                   	dec    %eax
f0103ea6:	a3 8c 49 5f f0       	mov    %eax,0xf05f498c
			initialize_frame_info(ptr_frame_info);
f0103eab:	83 ec 0c             	sub    $0xc,%esp
f0103eae:	ff 75 f0             	pushl  -0x10(%ebp)
f0103eb1:	e8 76 42 00 00       	call   f010812c <initialize_frame_info>
f0103eb6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103eb9:	83 ec 0c             	sub    $0xc,%esp
f0103ebc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103ebf:	e8 f9 fe ff ff       	call   f0103dbd <to_disk_frame_number>
f0103ec4:	83 c4 10             	add    $0x10,%esp
f0103ec7:	89 c2                	mov    %eax,%edx
f0103ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ecc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ece:	83 ec 0c             	sub    $0xc,%esp
f0103ed1:	68 90 49 5f f0       	push   $0xf05f4990
f0103ed6:	e8 38 ad 00 00       	call   f010ec13 <release_spinlock>
f0103edb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103ee1:	c9                   	leave  
f0103ee2:	c3                   	ret    

f0103ee3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103ee3:	55                   	push   %ebp
f0103ee4:	89 e5                	mov    %esp,%ebp
f0103ee6:	53                   	push   %ebx
f0103ee7:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103eee:	0f 84 ea 00 00 00    	je     f0103fde <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ef4:	83 ec 0c             	sub    $0xc,%esp
f0103ef7:	68 90 49 5f f0       	push   $0xf05f4990
f0103efc:	e8 8b ac 00 00       	call   f010eb8c <acquire_spinlock>
f0103f01:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f04:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103f0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f0d:	89 d0                	mov    %edx,%eax
f0103f0f:	01 c0                	add    %eax,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	85 c0                	test   %eax,%eax
f0103f1a:	75 17                	jne    f0103f33 <free_disk_frame+0x50>
f0103f1c:	83 ec 04             	sub    $0x4,%esp
f0103f1f:	68 5c 3f 12 f0       	push   $0xf0123f5c
f0103f24:	68 8e 00 00 00       	push   $0x8e
f0103f29:	68 3f 3f 12 f0       	push   $0xf0123f3f
f0103f2e:	e8 06 c4 ff ff       	call   f0100339 <_panic>
f0103f33:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103f39:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f3c:	89 d0                	mov    %edx,%eax
f0103f3e:	01 c0                	add    %eax,%eax
f0103f40:	01 d0                	add    %edx,%eax
f0103f42:	c1 e0 03             	shl    $0x3,%eax
f0103f45:	01 c8                	add    %ecx,%eax
f0103f47:	8b 15 80 49 5f f0    	mov    0xf05f4980,%edx
f0103f4d:	89 10                	mov    %edx,(%eax)
f0103f4f:	8b 00                	mov    (%eax),%eax
f0103f51:	85 c0                	test   %eax,%eax
f0103f53:	74 1f                	je     f0103f74 <free_disk_frame+0x91>
f0103f55:	8b 15 80 49 5f f0    	mov    0xf05f4980,%edx
f0103f5b:	8b 1d 80 40 5f f0    	mov    0xf05f4080,%ebx
f0103f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f64:	89 c8                	mov    %ecx,%eax
f0103f66:	01 c0                	add    %eax,%eax
f0103f68:	01 c8                	add    %ecx,%eax
f0103f6a:	c1 e0 03             	shl    $0x3,%eax
f0103f6d:	01 d8                	add    %ebx,%eax
f0103f6f:	89 42 04             	mov    %eax,0x4(%edx)
f0103f72:	eb 19                	jmp    f0103f8d <free_disk_frame+0xaa>
f0103f74:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7d:	89 d0                	mov    %edx,%eax
f0103f7f:	01 c0                	add    %eax,%eax
f0103f81:	01 d0                	add    %edx,%eax
f0103f83:	c1 e0 03             	shl    $0x3,%eax
f0103f86:	01 c8                	add    %ecx,%eax
f0103f88:	a3 84 49 5f f0       	mov    %eax,0xf05f4984
f0103f8d:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103f93:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f96:	89 d0                	mov    %edx,%eax
f0103f98:	01 c0                	add    %eax,%eax
f0103f9a:	01 d0                	add    %edx,%eax
f0103f9c:	c1 e0 03             	shl    $0x3,%eax
f0103f9f:	01 c8                	add    %ecx,%eax
f0103fa1:	a3 80 49 5f f0       	mov    %eax,0xf05f4980
f0103fa6:	8b 0d 80 40 5f f0    	mov    0xf05f4080,%ecx
f0103fac:	8b 55 08             	mov    0x8(%ebp),%edx
f0103faf:	89 d0                	mov    %edx,%eax
f0103fb1:	01 c0                	add    %eax,%eax
f0103fb3:	01 d0                	add    %edx,%eax
f0103fb5:	c1 e0 03             	shl    $0x3,%eax
f0103fb8:	01 c8                	add    %ecx,%eax
f0103fba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103fc1:	a1 8c 49 5f f0       	mov    0xf05f498c,%eax
f0103fc6:	40                   	inc    %eax
f0103fc7:	a3 8c 49 5f f0       	mov    %eax,0xf05f498c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103fcc:	83 ec 0c             	sub    $0xc,%esp
f0103fcf:	68 90 49 5f f0       	push   $0xf05f4990
f0103fd4:	e8 3a ac 00 00       	call   f010ec13 <release_spinlock>
f0103fd9:	83 c4 10             	add    $0x10,%esp
f0103fdc:	eb 01                	jmp    f0103fdf <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103fde:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103fdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fe2:	c9                   	leave  
f0103fe3:	c3                   	ret    

f0103fe4 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103fe4:	55                   	push   %ebp
f0103fe5:	89 e5                	mov    %esp,%ebp
f0103fe7:	53                   	push   %ebx
f0103fe8:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fee:	c1 e8 16             	shr    $0x16,%eax
f0103ff1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ffb:	01 d0                	add    %edx,%eax
f0103ffd:	8b 00                	mov    (%eax),%eax
f0103fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104002:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104009:	77 1d                	ja     f0104028 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010400b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104013:	83 ec 0c             	sub    $0xc,%esp
f0104016:	50                   	push   %eax
f0104017:	e8 69 50 00 00       	call   f0109085 <kheap_virtual_address>
f010401c:	83 c4 10             	add    $0x10,%esp
f010401f:	89 c2                	mov    %eax,%edx
f0104021:	8b 45 14             	mov    0x14(%ebp),%eax
f0104024:	89 10                	mov    %edx,(%eax)
f0104026:	eb 44                	jmp    f010406c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010402b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104030:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104036:	c1 e8 0c             	shr    $0xc,%eax
f0104039:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010403c:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f0104041:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104044:	72 17                	jb     f010405d <get_disk_page_table+0x79>
f0104046:	ff 75 f0             	pushl  -0x10(%ebp)
f0104049:	68 a0 3f 12 f0       	push   $0xf0123fa0
f010404e:	68 9d 00 00 00       	push   $0x9d
f0104053:	68 3f 3f 12 f0       	push   $0xf0123f3f
f0104058:	e8 dc c2 ff ff       	call   f0100339 <_panic>
f010405d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104060:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104065:	89 c2                	mov    %eax,%edx
f0104067:	8b 45 14             	mov    0x14(%ebp),%eax
f010406a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104070:	0f 85 80 00 00 00    	jne    f01040f6 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104076:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010407a:	74 6a                	je     f01040e6 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010407c:	83 ec 0c             	sub    $0xc,%esp
f010407f:	68 00 10 00 00       	push   $0x1000
f0104084:	e8 07 4d 00 00       	call   f0108d90 <kmalloc>
f0104089:	83 c4 10             	add    $0x10,%esp
f010408c:	89 c2                	mov    %eax,%edx
f010408e:	8b 45 14             	mov    0x14(%ebp),%eax
f0104091:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104093:	8b 45 14             	mov    0x14(%ebp),%eax
f0104096:	8b 00                	mov    (%eax),%eax
f0104098:	85 c0                	test   %eax,%eax
f010409a:	75 07                	jne    f01040a3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010409c:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01040a1:	eb 58                	jmp    f01040fb <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01040a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040a6:	c1 e8 16             	shr    $0x16,%eax
f01040a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01040b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01040b6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040b9:	8b 00                	mov    (%eax),%eax
f01040bb:	83 ec 0c             	sub    $0xc,%esp
f01040be:	50                   	push   %eax
f01040bf:	e8 90 4f 00 00       	call   f0109054 <kheap_physical_address>
f01040c4:	83 c4 10             	add    $0x10,%esp
f01040c7:	83 c8 01             	or     $0x1,%eax
f01040ca:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01040cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01040cf:	8b 00                	mov    (%eax),%eax
f01040d1:	83 ec 04             	sub    $0x4,%esp
f01040d4:	68 00 10 00 00       	push   $0x1000
f01040d9:	6a 00                	push   $0x0
f01040db:	50                   	push   %eax
f01040dc:	e8 5a ac 01 00       	call   f011ed3b <memset>
f01040e1:	83 c4 10             	add    $0x10,%esp
f01040e4:	eb 10                	jmp    f01040f6 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01040e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01040ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01040f4:	eb 05                	jmp    f01040fb <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01040f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01040fe:	c9                   	leave  
f01040ff:	c3                   	ret    

f0104100 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104100:	55                   	push   %ebp
f0104101:	89 e5                	mov    %esp,%ebp
f0104103:	83 ec 28             	sub    $0x28,%esp
f0104106:	8b 45 10             	mov    0x10(%ebp),%eax
f0104109:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010410c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104110:	74 72                	je     f0104184 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104112:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411c:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104121:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104124:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104127:	ba 00 00 00 00       	mov    $0x0,%edx
f010412c:	f7 75 f4             	divl   -0xc(%ebp)
f010412f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104132:	29 d0                	sub    %edx,%eax
f0104134:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104137:	73 2f                	jae    f0104168 <pf_add_empty_env_page+0x68>
f0104139:	8b 45 08             	mov    0x8(%ebp),%eax
f010413c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010413f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104144:	29 d0                	sub    %edx,%eax
f0104146:	c1 e0 0c             	shl    $0xc,%eax
f0104149:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010414e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104151:	76 15                	jbe    f0104168 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8b 80 a8 05 00 00    	mov    0x5a8(%eax),%eax
f010415c:	8d 50 01             	lea    0x1(%eax),%edx
f010415f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104162:	89 90 a8 05 00 00    	mov    %edx,0x5a8(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104168:	a1 5c 48 5f f0       	mov    0xf05f485c,%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	50                   	push   %eax
f0104171:	ff 75 0c             	pushl  0xc(%ebp)
f0104174:	ff 75 08             	pushl  0x8(%ebp)
f0104177:	e8 b2 00 00 00       	call   f010422e <pf_add_env_page>
f010417c:	83 c4 10             	add    $0x10,%esp
f010417f:	e9 a8 00 00 00       	jmp    f010422c <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104184:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010418b:	76 19                	jbe    f01041a6 <pf_add_empty_env_page+0xa6>
f010418d:	68 d0 3f 12 f0       	push   $0xf0123fd0
f0104192:	68 f6 3f 12 f0       	push   $0xf0123ff6
f0104197:	68 dc 00 00 00       	push   $0xdc
f010419c:	68 3f 3f 12 f0       	push   $0xf0123f3f
f01041a1:	e8 93 c1 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01041a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a9:	83 c0 74             	add    $0x74,%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	ff 75 08             	pushl  0x8(%ebp)
f01041b3:	e8 95 05 00 00       	call   f010474d <get_disk_page_directory>
f01041b8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01041bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01041be:	8b 40 74             	mov    0x74(%eax),%eax
f01041c1:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01041c4:	52                   	push   %edx
f01041c5:	6a 01                	push   $0x1
f01041c7:	ff 75 0c             	pushl  0xc(%ebp)
f01041ca:	50                   	push   %eax
f01041cb:	e8 14 fe ff ff       	call   f0103fe4 <get_disk_page_table>
f01041d0:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041d6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041d9:	c1 ea 0c             	shr    $0xc,%edx
f01041dc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e2:	c1 e2 02             	shl    $0x2,%edx
f01041e5:	01 d0                	add    %edx,%eax
f01041e7:	8b 00                	mov    (%eax),%eax
f01041e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01041ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01041ef:	85 c0                	test   %eax,%eax
f01041f1:	75 34                	jne    f0104227 <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041f3:	83 ec 0c             	sub    $0xc,%esp
f01041f6:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01041f9:	50                   	push   %eax
f01041fa:	e8 f6 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01041ff:	83 c4 10             	add    $0x10,%esp
f0104202:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104205:	75 07                	jne    f010420e <pf_add_empty_env_page+0x10e>
f0104207:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010420c:	eb 1e                	jmp    f010422c <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f010420e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104211:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104214:	c1 ea 0c             	shr    $0xc,%edx
f0104217:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010421d:	c1 e2 02             	shl    $0x2,%edx
f0104220:	01 c2                	add    %eax,%edx
f0104222:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104225:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f0104227:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010422c:	c9                   	leave  
f010422d:	c3                   	ret    

f010422e <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f010422e:	55                   	push   %ebp
f010422f:	89 e5                	mov    %esp,%ebp
f0104231:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104234:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010423b:	76 19                	jbe    f0104256 <pf_add_env_page+0x28>
f010423d:	68 d0 3f 12 f0       	push   $0xf0123fd0
f0104242:	68 f6 3f 12 f0       	push   $0xf0123ff6
f0104247:	68 f1 00 00 00       	push   $0xf1
f010424c:	68 3f 3f 12 f0       	push   $0xf0123f3f
f0104251:	e8 e3 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104256:	8b 45 08             	mov    0x8(%ebp),%eax
f0104259:	83 c0 74             	add    $0x74,%eax
f010425c:	83 ec 08             	sub    $0x8,%esp
f010425f:	50                   	push   %eax
f0104260:	ff 75 08             	pushl  0x8(%ebp)
f0104263:	e8 e5 04 00 00       	call   f010474d <get_disk_page_directory>
f0104268:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010426b:	8b 45 08             	mov    0x8(%ebp),%eax
f010426e:	8b 40 74             	mov    0x74(%eax),%eax
f0104271:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0104274:	52                   	push   %edx
f0104275:	6a 01                	push   $0x1
f0104277:	ff 75 0c             	pushl  0xc(%ebp)
f010427a:	50                   	push   %eax
f010427b:	e8 64 fd ff ff       	call   f0103fe4 <get_disk_page_table>
f0104280:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104283:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104286:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104289:	c1 ea 0c             	shr    $0xc,%edx
f010428c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104292:	c1 e2 02             	shl    $0x2,%edx
f0104295:	01 d0                	add    %edx,%eax
f0104297:	8b 00                	mov    (%eax),%eax
f0104299:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f010429c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010429f:	85 c0                	test   %eax,%eax
f01042a1:	75 34                	jne    f01042d7 <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01042a3:	83 ec 0c             	sub    $0xc,%esp
f01042a6:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01042a9:	50                   	push   %eax
f01042aa:	e8 46 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01042af:	83 c4 10             	add    $0x10,%esp
f01042b2:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042b5:	75 07                	jne    f01042be <pf_add_env_page+0x90>
f01042b7:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042bc:	eb 31                	jmp    f01042ef <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042c1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042c4:	c1 ea 0c             	shr    $0xc,%edx
f01042c7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042cd:	c1 e2 02             	shl    $0x2,%edx
f01042d0:	01 c2                	add    %eax,%edx
f01042d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042d5:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01042d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042da:	83 ec 08             	sub    $0x8,%esp
f01042dd:	ff 75 10             	pushl  0x10(%ebp)
f01042e0:	50                   	push   %eax
f01042e1:	e8 62 f9 ff ff       	call   f0103c48 <write_disk_page>
f01042e6:	83 c4 10             	add    $0x10,%esp
f01042e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01042ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01042ef:	c9                   	leave  
f01042f0:	c3                   	ret    

f01042f1 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01042f1:	55                   	push   %ebp
f01042f2:	89 e5                	mov    %esp,%ebp
f01042f4:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01042f7:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01042fe:	76 19                	jbe    f0104319 <pf_update_env_page+0x28>
f0104300:	68 d0 3f 12 f0       	push   $0xf0123fd0
f0104305:	68 f6 3f 12 f0       	push   $0xf0123ff6
f010430a:	68 13 01 00 00       	push   $0x113
f010430f:	68 3f 3f 12 f0       	push   $0xf0123f3f
f0104314:	e8 20 c0 ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104319:	8b 45 08             	mov    0x8(%ebp),%eax
f010431c:	83 c0 74             	add    $0x74,%eax
f010431f:	83 ec 08             	sub    $0x8,%esp
f0104322:	50                   	push   %eax
f0104323:	ff 75 08             	pushl  0x8(%ebp)
f0104326:	e8 22 04 00 00       	call   f010474d <get_disk_page_directory>
f010432b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010432e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104331:	8b 40 74             	mov    0x74(%eax),%eax
f0104334:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104337:	52                   	push   %edx
f0104338:	6a 00                	push   $0x0
f010433a:	ff 75 0c             	pushl  0xc(%ebp)
f010433d:	50                   	push   %eax
f010433e:	e8 a1 fc ff ff       	call   f0103fe4 <get_disk_page_table>
f0104343:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0104346:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104349:	85 c0                	test   %eax,%eax
f010434b:	74 29                	je     f0104376 <pf_update_env_page+0x85>
f010434d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104350:	85 c0                	test   %eax,%eax
f0104352:	0f 84 c5 00 00 00    	je     f010441d <pf_update_env_page+0x12c>
f0104358:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010435b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010435e:	c1 ea 0c             	shr    $0xc,%edx
f0104361:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104367:	c1 e2 02             	shl    $0x2,%edx
f010436a:	01 d0                	add    %edx,%eax
f010436c:	8b 00                	mov    (%eax),%eax
f010436e:	85 c0                	test   %eax,%eax
f0104370:	0f 85 a7 00 00 00    	jne    f010441d <pf_update_env_page+0x12c>
	{

		uint32 VA = (uint32)virtual_address ;
f0104376:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104379:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f010437c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010437f:	85 c0                	test   %eax,%eax
f0104381:	79 09                	jns    f010438c <pf_update_env_page+0x9b>
f0104383:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f010438a:	76 30                	jbe    f01043bc <pf_update_env_page+0xcb>
f010438c:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0104393:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104396:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010439b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010439e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043a1:	ba 00 00 00 00       	mov    $0x0,%edx
f01043a6:	f7 75 f0             	divl   -0x10(%ebp)
f01043a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043ac:	29 d0                	sub    %edx,%eax
f01043ae:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01043b1:	77 53                	ja     f0104406 <pf_update_env_page+0x115>
f01043b3:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01043ba:	77 4a                	ja     f0104406 <pf_update_env_page+0x115>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01043bc:	83 ec 04             	sub    $0x4,%esp
f01043bf:	6a 00                	push   $0x0
f01043c1:	ff 75 f4             	pushl  -0xc(%ebp)
f01043c4:	ff 75 08             	pushl  0x8(%ebp)
f01043c7:	e8 34 fd ff ff       	call   f0104100 <pf_add_empty_env_page>
f01043cc:	83 c4 10             	add    $0x10,%esp
f01043cf:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01043d2:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01043d6:	75 17                	jne    f01043ef <pf_update_env_page+0xfe>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01043d8:	83 ec 04             	sub    $0x4,%esp
f01043db:	68 0c 40 12 f0       	push   $0xf012400c
f01043e0:	68 43 01 00 00       	push   $0x143
f01043e5:	68 3f 3f 12 f0       	push   $0xf0123f3f
f01043ea:	e8 4a bf ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01043ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01043f2:	8b 80 a8 05 00 00    	mov    0x5a8(%eax),%eax
f01043f8:	8d 50 01             	lea    0x1(%eax),%edx
f01043fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01043fe:	89 90 a8 05 00 00    	mov    %edx,0x5a8(%eax)
f0104404:	eb 17                	jmp    f010441d <pf_update_env_page+0x12c>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f0104406:	83 ec 04             	sub    $0x4,%esp
f0104409:	68 58 40 12 f0       	push   $0xf0124058
f010440e:	68 4c 01 00 00       	push   $0x14c
f0104413:	68 3f 3f 12 f0       	push   $0xf0123f3f
f0104418:	e8 1c bf ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010441d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104420:	8b 40 74             	mov    0x74(%eax),%eax
f0104423:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104426:	52                   	push   %edx
f0104427:	6a 00                	push   $0x0
f0104429:	ff 75 0c             	pushl  0xc(%ebp)
f010442c:	50                   	push   %eax
f010442d:	e8 b2 fb ff ff       	call   f0103fe4 <get_disk_page_table>
f0104432:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104435:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104438:	8b 55 0c             	mov    0xc(%ebp),%edx
f010443b:	c1 ea 0c             	shr    $0xc,%edx
f010443e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104444:	c1 e2 02             	shl    $0x2,%edx
f0104447:	01 d0                	add    %edx,%eax
f0104449:	8b 00                	mov    (%eax),%eax
f010444b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f010444e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104451:	8b 40 64             	mov    0x64(%eax),%eax
f0104454:	6a 00                	push   $0x0
f0104456:	68 00 00 80 ef       	push   $0xef800000
f010445b:	ff 75 10             	pushl  0x10(%ebp)
f010445e:	50                   	push   %eax
f010445f:	e8 b0 41 00 00       	call   f0108614 <map_frame>
f0104464:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f0104467:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f010446e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104471:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104476:	83 ec 08             	sub    $0x8,%esp
f0104479:	50                   	push   %eax
f010447a:	ff 75 e4             	pushl  -0x1c(%ebp)
f010447d:	e8 c6 f7 ff ff       	call   f0103c48 <write_disk_page>
f0104482:	83 c4 10             	add    $0x10,%esp
f0104485:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104488:	8b 45 10             	mov    0x10(%ebp),%eax
f010448b:	8b 40 08             	mov    0x8(%eax),%eax
f010448e:	40                   	inc    %eax
f010448f:	8b 55 10             	mov    0x10(%ebp),%edx
f0104492:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f0104496:	8b 45 08             	mov    0x8(%ebp),%eax
f0104499:	8b 40 64             	mov    0x64(%eax),%eax
f010449c:	83 ec 08             	sub    $0x8,%esp
f010449f:	68 00 00 80 ef       	push   $0xef800000
f01044a4:	50                   	push   %eax
f01044a5:	e8 ca 42 00 00       	call   f0108774 <unmap_frame>
f01044aa:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01044ad:	8b 45 10             	mov    0x10(%ebp),%eax
f01044b0:	8b 40 08             	mov    0x8(%eax),%eax
f01044b3:	48                   	dec    %eax
f01044b4:	8b 55 10             	mov    0x10(%ebp),%edx
f01044b7:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01044bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01044be:	8b 80 a4 05 00 00    	mov    0x5a4(%eax),%eax
f01044c4:	8d 50 01             	lea    0x1(%eax),%edx
f01044c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ca:	89 90 a4 05 00 00    	mov    %edx,0x5a4(%eax)
	//======================

	return ret;
f01044d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01044d3:	c9                   	leave  
f01044d4:	c3                   	ret    

f01044d5 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01044d5:	55                   	push   %ebp
f01044d6:	89 e5                	mov    %esp,%ebp
f01044d8:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01044db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01044e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044e4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044e9:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01044ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ef:	8b 40 74             	mov    0x74(%eax),%eax
f01044f2:	85 c0                	test   %eax,%eax
f01044f4:	75 0a                	jne    f0104500 <pf_read_env_page+0x2b>
f01044f6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01044fb:	e9 90 00 00 00       	jmp    f0104590 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f0104500:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104503:	8b 45 08             	mov    0x8(%ebp),%eax
f0104506:	8b 40 74             	mov    0x74(%eax),%eax
f0104509:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010450c:	51                   	push   %ecx
f010450d:	6a 00                	push   $0x0
f010450f:	52                   	push   %edx
f0104510:	50                   	push   %eax
f0104511:	e8 ce fa ff ff       	call   f0103fe4 <get_disk_page_table>
f0104516:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104519:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010451c:	85 c0                	test   %eax,%eax
f010451e:	75 07                	jne    f0104527 <pf_read_env_page+0x52>
f0104520:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104525:	eb 69                	jmp    f0104590 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104527:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010452d:	c1 ea 0c             	shr    $0xc,%edx
f0104530:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104536:	c1 e2 02             	shl    $0x2,%edx
f0104539:	01 d0                	add    %edx,%eax
f010453b:	8b 00                	mov    (%eax),%eax
f010453d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104540:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104544:	75 07                	jne    f010454d <pf_read_env_page+0x78>
f0104546:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010454b:	eb 43                	jmp    f0104590 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010454d:	83 ec 08             	sub    $0x8,%esp
f0104550:	ff 75 0c             	pushl  0xc(%ebp)
f0104553:	ff 75 f0             	pushl  -0x10(%ebp)
f0104556:	e8 be f6 ff ff       	call   f0103c19 <read_disk_page>
f010455b:	83 c4 10             	add    $0x10,%esp
f010455e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104561:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104564:	8b 45 08             	mov    0x8(%ebp),%eax
f0104567:	8b 40 64             	mov    0x64(%eax),%eax
f010456a:	6a 40                	push   $0x40
f010456c:	6a 00                	push   $0x0
f010456e:	52                   	push   %edx
f010456f:	50                   	push   %eax
f0104570:	e8 3b 4b 00 00       	call   f01090b0 <pt_set_page_permissions>
f0104575:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f0104578:	8b 45 08             	mov    0x8(%ebp),%eax
f010457b:	8b 80 a0 05 00 00    	mov    0x5a0(%eax),%eax
f0104581:	8d 50 01             	lea    0x1(%eax),%edx
f0104584:	8b 45 08             	mov    0x8(%ebp),%eax
f0104587:	89 90 a0 05 00 00    	mov    %edx,0x5a0(%eax)
	//======================

	return disk_read_error;
f010458d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104590:	c9                   	leave  
f0104591:	c3                   	ret    

f0104592 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0104592:	55                   	push   %ebp
f0104593:	89 e5                	mov    %esp,%ebp
f0104595:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104598:	8b 45 08             	mov    0x8(%ebp),%eax
f010459b:	8b 40 74             	mov    0x74(%eax),%eax
f010459e:	85 c0                	test   %eax,%eax
f01045a0:	74 62                	je     f0104604 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01045a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01045a5:	8b 40 74             	mov    0x74(%eax),%eax
f01045a8:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01045ab:	52                   	push   %edx
f01045ac:	6a 00                	push   $0x0
f01045ae:	ff 75 0c             	pushl  0xc(%ebp)
f01045b1:	50                   	push   %eax
f01045b2:	e8 2d fa ff ff       	call   f0103fe4 <get_disk_page_table>
f01045b7:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01045ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045bd:	85 c0                	test   %eax,%eax
f01045bf:	74 46                	je     f0104607 <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045c4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045c7:	c1 ea 0c             	shr    $0xc,%edx
f01045ca:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045d0:	c1 e2 02             	shl    $0x2,%edx
f01045d3:	01 d0                	add    %edx,%eax
f01045d5:	8b 00                	mov    (%eax),%eax
f01045d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01045da:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045dd:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045e0:	c1 ea 0c             	shr    $0xc,%edx
f01045e3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045e9:	c1 e2 02             	shl    $0x2,%edx
f01045ec:	01 d0                	add    %edx,%eax
f01045ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01045f4:	83 ec 0c             	sub    $0xc,%esp
f01045f7:	ff 75 f4             	pushl  -0xc(%ebp)
f01045fa:	e8 e4 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f01045ff:	83 c4 10             	add    $0x10,%esp
f0104602:	eb 04                	jmp    f0104608 <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104604:	90                   	nop
f0104605:	eb 01                	jmp    f0104608 <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f0104607:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104608:	c9                   	leave  
f0104609:	c3                   	ret    

f010460a <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f010460a:	55                   	push   %ebp
f010460b:	89 e5                	mov    %esp,%ebp
f010460d:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104610:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104617:	e9 b8 00 00 00       	jmp    f01046d4 <pf_free_env+0xca>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f010461c:	8b 45 08             	mov    0x8(%ebp),%eax
f010461f:	8b 40 74             	mov    0x74(%eax),%eax
f0104622:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104625:	c1 e2 02             	shl    $0x2,%edx
f0104628:	01 d0                	add    %edx,%eax
f010462a:	8b 00                	mov    (%eax),%eax
f010462c:	83 e0 01             	and    $0x1,%eax
f010462f:	85 c0                	test   %eax,%eax
f0104631:	0f 84 99 00 00 00    	je     f01046d0 <pf_free_env+0xc6>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104637:	8b 45 08             	mov    0x8(%ebp),%eax
f010463a:	8b 40 74             	mov    0x74(%eax),%eax
f010463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104640:	c1 e2 02             	shl    $0x2,%edx
f0104643:	01 d0                	add    %edx,%eax
f0104645:	8b 00                	mov    (%eax),%eax
f0104647:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010464c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010464f:	83 ec 0c             	sub    $0xc,%esp
f0104652:	ff 75 ec             	pushl  -0x14(%ebp)
f0104655:	e8 2b 4a 00 00       	call   f0109085 <kheap_virtual_address>
f010465a:	83 c4 10             	add    $0x10,%esp
f010465d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0104660:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104667:	eb 3a                	jmp    f01046a3 <pf_free_env+0x99>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104669:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010466c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104673:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104676:	01 d0                	add    %edx,%eax
f0104678:	8b 00                	mov    (%eax),%eax
f010467a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010467d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104680:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104687:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010468a:	01 d0                	add    %edx,%eax
f010468c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f0104692:	83 ec 0c             	sub    $0xc,%esp
f0104695:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104698:	e8 46 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f010469d:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01046a0:	ff 45 f0             	incl   -0x10(%ebp)
f01046a3:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01046aa:	76 bd                	jbe    f0104669 <pf_free_env+0x5f>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01046ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01046af:	8b 40 74             	mov    0x74(%eax),%eax
f01046b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046b5:	c1 e2 02             	shl    $0x2,%edx
f01046b8:	01 d0                	add    %edx,%eax
f01046ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01046c0:	83 ec 0c             	sub    $0xc,%esp
f01046c3:	ff 75 e8             	pushl  -0x18(%ebp)
f01046c6:	e8 db 48 00 00       	call   f0108fa6 <kfree>
f01046cb:	83 c4 10             	add    $0x10,%esp
f01046ce:	eb 01                	jmp    f01046d1 <pf_free_env+0xc7>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01046d0:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046d1:	ff 45 f4             	incl   -0xc(%ebp)
f01046d4:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01046db:	0f 86 3b ff ff ff    	jbe    f010461c <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f01046e1:	8b 45 08             	mov    0x8(%ebp),%eax
f01046e4:	8b 40 74             	mov    0x74(%eax),%eax
f01046e7:	83 ec 0c             	sub    $0xc,%esp
f01046ea:	50                   	push   %eax
f01046eb:	e8 b6 48 00 00       	call   f0108fa6 <kfree>
f01046f0:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f01046f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01046f6:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f01046fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0104700:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104707:	8b 45 08             	mov    0x8(%ebp),%eax
f010470a:	8b 40 7c             	mov    0x7c(%eax),%eax
f010470d:	85 c0                	test   %eax,%eax
f010470f:	74 39                	je     f010474a <pf_free_env+0x140>
		return;
	__pf_remove_env_all_tables(ptr_env);
f0104711:	83 ec 0c             	sub    $0xc,%esp
f0104714:	ff 75 08             	pushl  0x8(%ebp)
f0104717:	e8 f1 02 00 00       	call   f0104a0d <__pf_remove_env_all_tables>
f010471c:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010471f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104722:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104725:	83 ec 0c             	sub    $0xc,%esp
f0104728:	50                   	push   %eax
f0104729:	e8 78 48 00 00       	call   f0108fa6 <kfree>
f010472e:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104731:	8b 45 08             	mov    0x8(%ebp),%eax
f0104734:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f010473b:	8b 45 08             	mov    0x8(%ebp),%eax
f010473e:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104745:	00 00 00 
f0104748:	eb 01                	jmp    f010474b <pf_free_env+0x141>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010474a:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010474b:	c9                   	leave  
f010474c:	c3                   	ret    

f010474d <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f010474d:	55                   	push   %ebp
f010474e:	89 e5                	mov    %esp,%ebp
f0104750:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104753:	8b 45 08             	mov    0x8(%ebp),%eax
f0104756:	8b 50 74             	mov    0x74(%eax),%edx
f0104759:	8b 45 0c             	mov    0xc(%ebp),%eax
f010475c:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f010475e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104761:	8b 00                	mov    (%eax),%eax
f0104763:	85 c0                	test   %eax,%eax
f0104765:	75 58                	jne    f01047bf <get_disk_page_directory+0x72>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f0104767:	83 ec 0c             	sub    $0xc,%esp
f010476a:	68 00 10 00 00       	push   $0x1000
f010476f:	e8 1c 46 00 00       	call   f0108d90 <kmalloc>
f0104774:	83 c4 10             	add    $0x10,%esp
f0104777:	89 c2                	mov    %eax,%edx
f0104779:	8b 45 0c             	mov    0xc(%ebp),%eax
f010477c:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f010477e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104781:	8b 00                	mov    (%eax),%eax
f0104783:	85 c0                	test   %eax,%eax
f0104785:	75 07                	jne    f010478e <get_disk_page_directory+0x41>
			{
				return E_NO_VM;
f0104787:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010478c:	eb 36                	jmp    f01047c4 <get_disk_page_directory+0x77>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f010478e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104791:	8b 00                	mov    (%eax),%eax
f0104793:	83 ec 0c             	sub    $0xc,%esp
f0104796:	50                   	push   %eax
f0104797:	e8 b8 48 00 00       	call   f0109054 <kheap_physical_address>
f010479c:	83 c4 10             	add    $0x10,%esp
f010479f:	89 c2                	mov    %eax,%edx
f01047a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01047a4:	89 50 78             	mov    %edx,0x78(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01047a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047aa:	8b 00                	mov    (%eax),%eax
f01047ac:	83 ec 04             	sub    $0x4,%esp
f01047af:	68 00 10 00 00       	push   $0x1000
f01047b4:	6a 00                	push   $0x0
f01047b6:	50                   	push   %eax
f01047b7:	e8 7f a5 01 00       	call   f011ed3b <memset>
f01047bc:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01047bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047c4:	c9                   	leave  
f01047c5:	c3                   	ret    

f01047c6 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01047c6:	55                   	push   %ebp
f01047c7:	89 e5                	mov    %esp,%ebp
f01047c9:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f01047cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f01047d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01047da:	eb 78                	jmp    f0104854 <pf_calculate_allocated_pages+0x8e>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f01047dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01047df:	8b 40 74             	mov    0x74(%eax),%eax
f01047e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01047e5:	c1 e2 02             	shl    $0x2,%edx
f01047e8:	01 d0                	add    %edx,%eax
f01047ea:	8b 00                	mov    (%eax),%eax
f01047ec:	83 e0 01             	and    $0x1,%eax
f01047ef:	85 c0                	test   %eax,%eax
f01047f1:	74 5d                	je     f0104850 <pf_calculate_allocated_pages+0x8a>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f01047f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01047f6:	8b 40 74             	mov    0x74(%eax),%eax
f01047f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01047fc:	c1 e2 02             	shl    $0x2,%edx
f01047ff:	01 d0                	add    %edx,%eax
f0104801:	8b 00                	mov    (%eax),%eax
f0104803:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104808:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010480b:	83 ec 0c             	sub    $0xc,%esp
f010480e:	ff 75 e8             	pushl  -0x18(%ebp)
f0104811:	e8 6f 48 00 00       	call   f0109085 <kheap_virtual_address>
f0104816:	83 c4 10             	add    $0x10,%esp
f0104819:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010481c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104823:	eb 20                	jmp    f0104845 <pf_calculate_allocated_pages+0x7f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104825:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104828:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010482f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104832:	01 d0                	add    %edx,%eax
f0104834:	8b 00                	mov    (%eax),%eax
f0104836:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104839:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010483d:	74 03                	je     f0104842 <pf_calculate_allocated_pages+0x7c>
				counter ++;
f010483f:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104842:	ff 45 ec             	incl   -0x14(%ebp)
f0104845:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010484c:	76 d7                	jbe    f0104825 <pf_calculate_allocated_pages+0x5f>
f010484e:	eb 01                	jmp    f0104851 <pf_calculate_allocated_pages+0x8b>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0104850:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104851:	ff 45 f4             	incl   -0xc(%ebp)
f0104854:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010485b:	0f 86 7b ff ff ff    	jbe    f01047dc <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0104861:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104864:	c9                   	leave  
f0104865:	c3                   	ret    

f0104866 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104866:	55                   	push   %ebp
f0104867:	89 e5                	mov    %esp,%ebp
f0104869:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f010486c:	83 ec 0c             	sub    $0xc,%esp
f010486f:	68 90 49 5f f0       	push   $0xf05f4990
f0104874:	e8 13 a3 00 00       	call   f010eb8c <acquire_spinlock>
f0104879:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f010487c:	a1 8c 49 5f f0       	mov    0xf05f498c,%eax
f0104881:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0104884:	83 ec 0c             	sub    $0xc,%esp
f0104887:	68 90 49 5f f0       	push   $0xf05f4990
f010488c:	e8 82 a3 00 00       	call   f010ec13 <release_spinlock>
f0104891:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0104894:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0104897:	c9                   	leave  
f0104898:	c3                   	ret    

f0104899 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104899:	55                   	push   %ebp
f010489a:	89 e5                	mov    %esp,%ebp
f010489c:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f010489f:	8b 45 08             	mov    0x8(%ebp),%eax
f01048a2:	8b 50 7c             	mov    0x7c(%eax),%edx
f01048a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048a8:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01048aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ad:	8b 00                	mov    (%eax),%eax
f01048af:	85 c0                	test   %eax,%eax
f01048b1:	75 5b                	jne    f010490e <get_disk_table_directory+0x75>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f01048b3:	83 ec 0c             	sub    $0xc,%esp
f01048b6:	68 00 10 00 00       	push   $0x1000
f01048bb:	e8 d0 44 00 00       	call   f0108d90 <kmalloc>
f01048c0:	83 c4 10             	add    $0x10,%esp
f01048c3:	89 c2                	mov    %eax,%edx
f01048c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048c8:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f01048ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048cd:	8b 00                	mov    (%eax),%eax
f01048cf:	85 c0                	test   %eax,%eax
f01048d1:	75 07                	jne    f01048da <get_disk_table_directory+0x41>
			{
				return E_NO_VM;
f01048d3:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01048d8:	eb 39                	jmp    f0104913 <get_disk_table_directory+0x7a>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f01048da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048dd:	8b 00                	mov    (%eax),%eax
f01048df:	83 ec 0c             	sub    $0xc,%esp
f01048e2:	50                   	push   %eax
f01048e3:	e8 6c 47 00 00       	call   f0109054 <kheap_physical_address>
f01048e8:	83 c4 10             	add    $0x10,%esp
f01048eb:	89 c2                	mov    %eax,%edx
f01048ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01048f0:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f01048f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048f9:	8b 00                	mov    (%eax),%eax
f01048fb:	83 ec 04             	sub    $0x4,%esp
f01048fe:	68 00 10 00 00       	push   $0x1000
f0104903:	6a 00                	push   $0x0
f0104905:	50                   	push   %eax
f0104906:	e8 30 a4 01 00       	call   f011ed3b <memset>
f010490b:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f010490e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104913:	c9                   	leave  
f0104914:	c3                   	ret    

f0104915 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104915:	55                   	push   %ebp
f0104916:	89 e5                	mov    %esp,%ebp
f0104918:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010491b:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104922:	76 19                	jbe    f010493d <__pf_write_env_table+0x28>
f0104924:	68 d0 3f 12 f0       	push   $0xf0123fd0
f0104929:	68 f6 3f 12 f0       	push   $0xf0123ff6
f010492e:	68 91 02 00 00       	push   $0x291
f0104933:	68 3f 3f 12 f0       	push   $0xf0123f3f
f0104938:	e8 fc b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010493d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104940:	83 c0 7c             	add    $0x7c,%eax
f0104943:	83 ec 08             	sub    $0x8,%esp
f0104946:	50                   	push   %eax
f0104947:	ff 75 08             	pushl  0x8(%ebp)
f010494a:	e8 4a ff ff ff       	call   f0104899 <get_disk_table_directory>
f010494f:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104952:	8b 45 08             	mov    0x8(%ebp),%eax
f0104955:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104958:	8b 55 0c             	mov    0xc(%ebp),%edx
f010495b:	c1 ea 16             	shr    $0x16,%edx
f010495e:	c1 e2 02             	shl    $0x2,%edx
f0104961:	01 d0                	add    %edx,%eax
f0104963:	8b 00                	mov    (%eax),%eax
f0104965:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0104968:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010496b:	85 c0                	test   %eax,%eax
f010496d:	75 31                	jne    f01049a0 <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010496f:	83 ec 0c             	sub    $0xc,%esp
f0104972:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0104975:	50                   	push   %eax
f0104976:	e8 7a f4 ff ff       	call   f0103df5 <allocate_disk_frame>
f010497b:	83 c4 10             	add    $0x10,%esp
f010497e:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104981:	75 07                	jne    f010498a <__pf_write_env_table+0x75>
f0104983:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104988:	eb 2e                	jmp    f01049b8 <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f010498a:	8b 45 08             	mov    0x8(%ebp),%eax
f010498d:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104990:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104993:	c1 ea 16             	shr    $0x16,%edx
f0104996:	c1 e2 02             	shl    $0x2,%edx
f0104999:	01 c2                	add    %eax,%edx
f010499b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010499e:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049a3:	83 ec 08             	sub    $0x8,%esp
f01049a6:	ff 75 10             	pushl  0x10(%ebp)
f01049a9:	50                   	push   %eax
f01049aa:	e8 99 f2 ff ff       	call   f0103c48 <write_disk_page>
f01049af:	83 c4 10             	add    $0x10,%esp
f01049b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01049b8:	c9                   	leave  
f01049b9:	c3                   	ret    

f01049ba <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01049ba:	55                   	push   %ebp
f01049bb:	89 e5                	mov    %esp,%ebp
f01049bd:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01049c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01049c3:	8b 40 7c             	mov    0x7c(%eax),%eax
f01049c6:	85 c0                	test   %eax,%eax
f01049c8:	75 07                	jne    f01049d1 <__pf_read_env_table+0x17>
f01049ca:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01049cf:	eb 3a                	jmp    f0104a0b <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f01049d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d4:	8b 40 7c             	mov    0x7c(%eax),%eax
f01049d7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049da:	c1 ea 16             	shr    $0x16,%edx
f01049dd:	c1 e2 02             	shl    $0x2,%edx
f01049e0:	01 d0                	add    %edx,%eax
f01049e2:	8b 00                	mov    (%eax),%eax
f01049e4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01049e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01049eb:	75 07                	jne    f01049f4 <__pf_read_env_table+0x3a>
f01049ed:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01049f2:	eb 17                	jmp    f0104a0b <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f01049f4:	83 ec 08             	sub    $0x8,%esp
f01049f7:	ff 75 10             	pushl  0x10(%ebp)
f01049fa:	ff 75 f4             	pushl  -0xc(%ebp)
f01049fd:	e8 17 f2 ff ff       	call   f0103c19 <read_disk_page>
f0104a02:	83 c4 10             	add    $0x10,%esp
f0104a05:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a08:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a0b:	c9                   	leave  
f0104a0c:	c3                   	ret    

f0104a0d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a0d:	55                   	push   %ebp
f0104a0e:	89 e5                	mov    %esp,%ebp
f0104a10:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a13:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a16:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a19:	85 c0                	test   %eax,%eax
f0104a1b:	74 4c                	je     f0104a69 <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a24:	eb 38                	jmp    f0104a5e <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a26:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a29:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a2f:	c1 e2 02             	shl    $0x2,%edx
f0104a32:	01 d0                	add    %edx,%eax
f0104a34:	8b 00                	mov    (%eax),%eax
f0104a36:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a39:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a3c:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a42:	c1 e2 02             	shl    $0x2,%edx
f0104a45:	01 d0                	add    %edx,%eax
f0104a47:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104a4d:	83 ec 0c             	sub    $0xc,%esp
f0104a50:	ff 75 f0             	pushl  -0x10(%ebp)
f0104a53:	e8 8b f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104a58:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a5b:	ff 45 f4             	incl   -0xc(%ebp)
f0104a5e:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104a65:	76 bf                	jbe    f0104a26 <__pf_remove_env_all_tables+0x19>
f0104a67:	eb 01                	jmp    f0104a6a <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a69:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104a6a:	c9                   	leave  
f0104a6b:	c3                   	ret    

f0104a6c <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104a6c:	55                   	push   %ebp
f0104a6d:	89 e5                	mov    %esp,%ebp
f0104a6f:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104a72:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104a76:	75 10                	jne    f0104a88 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104a78:	83 ec 0c             	sub    $0xc,%esp
f0104a7b:	68 d4 40 12 f0       	push   $0xf01240d4
f0104a80:	e8 06 c5 ff ff       	call   f0100f8b <cprintf>
f0104a85:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a88:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a8b:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a8e:	85 c0                	test   %eax,%eax
f0104a90:	74 3d                	je     f0104acf <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a95:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a98:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a9b:	c1 ea 16             	shr    $0x16,%edx
f0104a9e:	c1 e2 02             	shl    $0x2,%edx
f0104aa1:	01 d0                	add    %edx,%eax
f0104aa3:	8b 00                	mov    (%eax),%eax
f0104aa5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104aa8:	8b 45 08             	mov    0x8(%ebp),%eax
f0104aab:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104aae:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104ab1:	c1 ea 16             	shr    $0x16,%edx
f0104ab4:	c1 e2 02             	shl    $0x2,%edx
f0104ab7:	01 d0                	add    %edx,%eax
f0104ab9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104abf:	83 ec 0c             	sub    $0xc,%esp
f0104ac2:	ff 75 f4             	pushl  -0xc(%ebp)
f0104ac5:	e8 19 f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104aca:	83 c4 10             	add    $0x10,%esp
f0104acd:	eb 01                	jmp    f0104ad0 <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104acf:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104ad0:	c9                   	leave  
f0104ad1:	c3                   	ret    

f0104ad2 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104ad2:	55                   	push   %ebp
f0104ad3:	89 e5                	mov    %esp,%ebp
f0104ad5:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104ad8:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104adf:	eb 1f                	jmp    f0104b00 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104ae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ae4:	83 ec 04             	sub    $0x4,%esp
f0104ae7:	6a 08                	push   $0x8
f0104ae9:	ff 75 08             	pushl  0x8(%ebp)
f0104aec:	50                   	push   %eax
f0104aed:	e8 83 a9 01 00       	call   f011f475 <ide_write>
f0104af2:	83 c4 10             	add    $0x10,%esp
f0104af5:	85 c0                	test   %eax,%eax
f0104af7:	75 12                	jne    f0104b0b <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104af9:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b00:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b07:	7e d8                	jle    f0104ae1 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b09:	eb 01                	jmp    f0104b0c <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b0b:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b0c:	90                   	nop
f0104b0d:	c9                   	leave  
f0104b0e:	c3                   	ret    

f0104b0f <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b0f:	55                   	push   %ebp
  pushl %eax
f0104b10:	50                   	push   %eax
  pushl %ebx
f0104b11:	53                   	push   %ebx
  pushl %ecx
f0104b12:	51                   	push   %ecx
  pushl %edx
f0104b13:	52                   	push   %edx
  pushl %esi
f0104b14:	56                   	push   %esi
  pushl %edi
f0104b15:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b16:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b1a:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b1e:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b20:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b22:	5f                   	pop    %edi
  popl %esi
f0104b23:	5e                   	pop    %esi
  popl %edx
f0104b24:	5a                   	pop    %edx
  popl %ecx
f0104b25:	59                   	pop    %ecx
  popl %ebx
f0104b26:	5b                   	pop    %ebx
  popl %eax
f0104b27:	58                   	pop    %eax
  popl %ebp
f0104b28:	5d                   	pop    %ebp
  ret
f0104b29:	c3                   	ret    

f0104b2a <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b2a:	55                   	push   %ebp
f0104b2b:	89 e5                	mov    %esp,%ebp
f0104b2d:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b30:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b33:	0f b6 c0             	movzbl %al,%eax
f0104b36:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b3d:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104b40:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104b43:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104b46:	ee                   	out    %al,(%dx)
f0104b47:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104b4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104b51:	89 c2                	mov    %eax,%edx
f0104b53:	ec                   	in     (%dx),%al
f0104b54:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104b57:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104b5a:	0f b6 c0             	movzbl %al,%eax
}
f0104b5d:	c9                   	leave  
f0104b5e:	c3                   	ret    

f0104b5f <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104b5f:	55                   	push   %ebp
f0104b60:	89 e5                	mov    %esp,%ebp
f0104b62:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b65:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b68:	0f b6 c0             	movzbl %al,%eax
f0104b6b:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b72:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104b75:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104b78:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104b7b:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104b7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b7f:	0f b6 c0             	movzbl %al,%eax
f0104b82:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104b89:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104b8c:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104b8f:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104b92:	ee                   	out    %al,(%dx)
}
f0104b93:	90                   	nop
f0104b94:	c9                   	leave  
f0104b95:	c3                   	ret    

f0104b96 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104b96:	55                   	push   %ebp
f0104b97:	89 e5                	mov    %esp,%ebp
f0104b99:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104b9c:	c7 05 68 49 5f f0 00 	movl   $0x0,0xf05f4968
f0104ba3:	00 00 00 
f0104ba6:	c7 05 6c 49 5f f0 00 	movl   $0x0,0xf05f496c
f0104bad:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104bb0:	83 ec 08             	sub    $0x8,%esp
f0104bb3:	68 54 6b 10 f0       	push   $0xf0106b54
f0104bb8:	6a 00                	push   $0x0
f0104bba:	e8 dd 87 00 00       	call   f010d39c <irq_install_handler>
f0104bbf:	83 c4 10             	add    $0x10,%esp
}
f0104bc2:	90                   	nop
f0104bc3:	c9                   	leave  
f0104bc4:	c3                   	ret    

f0104bc5 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104bc5:	55                   	push   %ebp
f0104bc6:	89 e5                	mov    %esp,%ebp
f0104bc8:	53                   	push   %ebx
f0104bc9:	83 ec 24             	sub    $0x24,%esp
f0104bcc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bcf:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104bd2:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104bd9:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104bdd:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104be0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104be3:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104be4:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104be8:	77 48                	ja     f0104c32 <kclock_start+0x6d>
f0104bea:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104bf1:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104bf5:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104bf8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104bfb:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104bfc:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c00:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c05:	99                   	cltd   
f0104c06:	f7 fb                	idiv   %ebx
f0104c08:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c0e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c12:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c17:	99                   	cltd   
f0104c18:	f7 fb                	idiv   %ebx
f0104c1a:	89 c3                	mov    %eax,%ebx
f0104c1c:	89 c8                	mov    %ecx,%eax
f0104c1e:	99                   	cltd   
f0104c1f:	f7 fb                	idiv   %ebx
f0104c21:	0f b7 c0             	movzwl %ax,%eax
f0104c24:	83 ec 0c             	sub    $0xc,%esp
f0104c27:	50                   	push   %eax
f0104c28:	e8 b3 01 00 00       	call   f0104de0 <kclock_write_cnt0_LSB_first>
f0104c2d:	83 c4 10             	add    $0x10,%esp
f0104c30:	eb 13                	jmp    f0104c45 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c32:	6a 35                	push   $0x35
f0104c34:	68 f8 40 12 f0       	push   $0xf01240f8
f0104c39:	6a 41                	push   $0x41
f0104c3b:	68 54 41 12 f0       	push   $0xf0124154
f0104c40:	e8 f4 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104c45:	83 ec 0c             	sub    $0xc,%esp
f0104c48:	6a 00                	push   $0x0
f0104c4a:	e8 3a 23 00 00       	call   f0106f89 <irq_clear_mask>
f0104c4f:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104c52:	90                   	nop
f0104c53:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104c56:	c9                   	leave  
f0104c57:	c3                   	ret    

f0104c58 <kclock_stop>:

void
kclock_stop(void)
{
f0104c58:	55                   	push   %ebp
f0104c59:	89 e5                	mov    %esp,%ebp
f0104c5b:	83 ec 18             	sub    $0x18,%esp
f0104c5e:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c65:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104c69:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104c6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c6f:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104c70:	83 ec 0c             	sub    $0xc,%esp
f0104c73:	6a 00                	push   $0x0
f0104c75:	e8 9a 22 00 00       	call   f0106f14 <irq_set_mask>
f0104c7a:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104c7d:	90                   	nop
f0104c7e:	c9                   	leave  
f0104c7f:	c3                   	ret    

f0104c80 <kclock_resume>:

void
kclock_resume(void)
{
f0104c80:	55                   	push   %ebp
f0104c81:	89 e5                	mov    %esp,%ebp
f0104c83:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104c86:	e8 f5 01 00 00       	call   f0104e80 <kclock_read_cnt0_latch>
f0104c8b:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104c8f:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104c94:	77 06                	ja     f0104c9c <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104c96:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104c9c:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104ca0:	83 e0 01             	and    $0x1,%eax
f0104ca3:	66 85 c0             	test   %ax,%ax
f0104ca6:	74 09                	je     f0104cb1 <kclock_resume+0x31>
		cnt0++;
f0104ca8:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104cac:	40                   	inc    %eax
f0104cad:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104cb1:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104cb8:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104cbc:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104cbf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104cc2:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104cc3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104cc7:	83 ec 0c             	sub    $0xc,%esp
f0104cca:	50                   	push   %eax
f0104ccb:	e8 10 01 00 00       	call   f0104de0 <kclock_write_cnt0_LSB_first>
f0104cd0:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104cd3:	83 ec 0c             	sub    $0xc,%esp
f0104cd6:	6a 00                	push   $0x0
f0104cd8:	e8 ac 22 00 00       	call   f0106f89 <irq_clear_mask>
f0104cdd:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104ce0:	90                   	nop
f0104ce1:	c9                   	leave  
f0104ce2:	c3                   	ret    

f0104ce3 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104ce3:	55                   	push   %ebp
f0104ce4:	89 e5                	mov    %esp,%ebp
f0104ce6:	83 ec 28             	sub    $0x28,%esp
f0104ce9:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cec:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104cef:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cf6:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104cfa:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104cfd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d00:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d01:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d05:	83 ec 0c             	sub    $0xc,%esp
f0104d08:	50                   	push   %eax
f0104d09:	e8 d2 00 00 00       	call   f0104de0 <kclock_write_cnt0_LSB_first>
f0104d0e:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d11:	83 ec 0c             	sub    $0xc,%esp
f0104d14:	6a 00                	push   $0x0
f0104d16:	e8 6e 22 00 00       	call   f0106f89 <irq_clear_mask>
f0104d1b:	83 c4 10             	add    $0x10,%esp
}
f0104d1e:	90                   	nop
f0104d1f:	c9                   	leave  
f0104d20:	c3                   	ret    

f0104d21 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d21:	55                   	push   %ebp
f0104d22:	89 e5                	mov    %esp,%ebp
f0104d24:	56                   	push   %esi
f0104d25:	53                   	push   %ebx
f0104d26:	83 ec 20             	sub    $0x20,%esp
f0104d29:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d2c:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d2f:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d33:	0f 87 8a 00 00 00    	ja     f0104dc3 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d39:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d3d:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104d42:	99                   	cltd   
f0104d43:	f7 fe                	idiv   %esi
f0104d45:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104d4b:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104d4f:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104d54:	99                   	cltd   
f0104d55:	f7 fb                	idiv   %ebx
f0104d57:	89 c6                	mov    %eax,%esi
f0104d59:	89 c8                	mov    %ecx,%eax
f0104d5b:	99                   	cltd   
f0104d5c:	f7 fe                	idiv   %esi
f0104d5e:	89 c3                	mov    %eax,%ebx
f0104d60:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104d64:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104d69:	99                   	cltd   
f0104d6a:	f7 f9                	idiv   %ecx
f0104d6c:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104d72:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d76:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104d7b:	99                   	cltd   
f0104d7c:	f7 fe                	idiv   %esi
f0104d7e:	89 c6                	mov    %eax,%esi
f0104d80:	89 c8                	mov    %ecx,%eax
f0104d82:	99                   	cltd   
f0104d83:	f7 fe                	idiv   %esi
f0104d85:	25 01 00 00 80       	and    $0x80000001,%eax
f0104d8a:	85 c0                	test   %eax,%eax
f0104d8c:	79 05                	jns    f0104d93 <kclock_set_quantum+0x72>
f0104d8e:	48                   	dec    %eax
f0104d8f:	83 c8 fe             	or     $0xfffffffe,%eax
f0104d92:	40                   	inc    %eax
f0104d93:	01 d8                	add    %ebx,%eax
f0104d95:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104d98:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d9f:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104da3:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104da6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104da9:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104daa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104dad:	0f b7 c0             	movzwl %ax,%eax
f0104db0:	83 ec 0c             	sub    $0xc,%esp
f0104db3:	50                   	push   %eax
f0104db4:	e8 27 00 00 00       	call   f0104de0 <kclock_write_cnt0_LSB_first>
f0104db9:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104dbc:	e8 97 fe ff ff       	call   f0104c58 <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104dc1:	eb 16                	jmp    f0104dd9 <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104dc3:	6a 35                	push   $0x35
f0104dc5:	68 f8 40 12 f0       	push   $0xf01240f8
f0104dca:	68 ea 00 00 00       	push   $0xea
f0104dcf:	68 54 41 12 f0       	push   $0xf0124154
f0104dd4:	e8 60 b5 ff ff       	call   f0100339 <_panic>
	}
}
f0104dd9:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104ddc:	5b                   	pop    %ebx
f0104ddd:	5e                   	pop    %esi
f0104dde:	5d                   	pop    %ebp
f0104ddf:	c3                   	ret    

f0104de0 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104de0:	55                   	push   %ebp
f0104de1:	89 e5                	mov    %esp,%ebp
f0104de3:	83 ec 28             	sub    $0x28,%esp
f0104de6:	8b 45 08             	mov    0x8(%ebp),%eax
f0104de9:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104ded:	e8 72 23 00 00       	call   f0107164 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104df2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104df5:	0f b6 c0             	movzbl %al,%eax
f0104df8:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104dff:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e02:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e05:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e08:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e0c:	66 c1 e8 08          	shr    $0x8,%ax
f0104e10:	0f b6 c0             	movzbl %al,%eax
f0104e13:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e1a:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e1d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e20:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e23:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e24:	e8 8d 23 00 00       	call   f01071b6 <popcli>

}
f0104e29:	90                   	nop
f0104e2a:	c9                   	leave  
f0104e2b:	c3                   	ret    

f0104e2c <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e2c:	55                   	push   %ebp
f0104e2d:	89 e5                	mov    %esp,%ebp
f0104e2f:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e32:	e8 2d 23 00 00       	call   f0107164 <pushcli>
f0104e37:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e41:	89 c2                	mov    %eax,%edx
f0104e43:	ec                   	in     (%dx),%al
f0104e44:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104e47:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104e4a:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104e4d:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e54:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104e57:	89 c2                	mov    %eax,%edx
f0104e59:	ec                   	in     (%dx),%al
f0104e5a:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104e5d:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104e60:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104e63:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104e67:	c1 e0 08             	shl    $0x8,%eax
f0104e6a:	89 c2                	mov    %eax,%edx
f0104e6c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104e70:	09 d0                	or     %edx,%eax
f0104e72:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104e76:	e8 3b 23 00 00       	call   f01071b6 <popcli>
	return cnt0 ;
f0104e7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104e7e:	c9                   	leave  
f0104e7f:	c3                   	ret    

f0104e80 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104e80:	55                   	push   %ebp
f0104e81:	89 e5                	mov    %esp,%ebp
f0104e83:	83 ec 30             	sub    $0x30,%esp
f0104e86:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104e8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104e90:	89 c2                	mov    %eax,%edx
f0104e92:	ec                   	in     (%dx),%al
f0104e93:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104e96:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104e99:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104e9c:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104ea3:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ea7:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104eaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104ead:	ee                   	out    %al,(%dx)
f0104eae:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104eb8:	89 c2                	mov    %eax,%edx
f0104eba:	ec                   	in     (%dx),%al
f0104ebb:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104ebe:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104ec1:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104ec4:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ecb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104ece:	89 c2                	mov    %eax,%edx
f0104ed0:	ec                   	in     (%dx),%al
f0104ed1:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104ed4:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104ed7:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104eda:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104ede:	c1 e0 08             	shl    $0x8,%eax
f0104ee1:	89 c2                	mov    %eax,%edx
f0104ee3:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104ee7:	09 d0                	or     %edx,%eax
f0104ee9:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104eed:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104ef1:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104ef8:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104efb:	8a 45 df             	mov    -0x21(%ebp),%al
f0104efe:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f01:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f02:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f05:	c9                   	leave  
f0104f06:	c3                   	ret    

f0104f07 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f07:	55                   	push   %ebp
f0104f08:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f0a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f0e:	74 1d                	je     f0104f2d <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f10:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f13:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f19:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f1c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f23:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f26:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f2d:	90                   	nop
f0104f2e:	5d                   	pop    %ebp
f0104f2f:	c3                   	ret    

f0104f30 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f30:	55                   	push   %ebp
f0104f31:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f33:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f37:	74 08                	je     f0104f41 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f39:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f3c:	8b 40 0c             	mov    0xc(%eax),%eax
f0104f3f:	eb 05                	jmp    f0104f46 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104f41:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104f46:	5d                   	pop    %ebp
f0104f47:	c3                   	ret    

f0104f48 <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104f48:	55                   	push   %ebp
f0104f49:	89 e5                	mov    %esp,%ebp
f0104f4b:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104f4e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f52:	75 16                	jne    f0104f6a <enqueue+0x22>
f0104f54:	68 68 41 12 f0       	push   $0xf0124168
f0104f59:	68 76 41 12 f0       	push   $0xf0124176
f0104f5e:	6a 34                	push   $0x34
f0104f60:	68 8b 41 12 f0       	push   $0xf012418b
f0104f65:	e8 cf b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f0104f6a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104f6e:	74 66                	je     f0104fd6 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104f70:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104f74:	75 14                	jne    f0104f8a <enqueue+0x42>
f0104f76:	83 ec 04             	sub    $0x4,%esp
f0104f79:	68 a4 41 12 f0       	push   $0xf01241a4
f0104f7e:	6a 37                	push   $0x37
f0104f80:	68 8b 41 12 f0       	push   $0xf012418b
f0104f85:	e8 af b3 ff ff       	call   f0100339 <_panic>
f0104f8a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f8d:	8b 10                	mov    (%eax),%edx
f0104f8f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104f92:	89 50 08             	mov    %edx,0x8(%eax)
f0104f95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104f98:	8b 40 08             	mov    0x8(%eax),%eax
f0104f9b:	85 c0                	test   %eax,%eax
f0104f9d:	74 0d                	je     f0104fac <enqueue+0x64>
f0104f9f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fa2:	8b 00                	mov    (%eax),%eax
f0104fa4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fa7:	89 50 0c             	mov    %edx,0xc(%eax)
f0104faa:	eb 09                	jmp    f0104fb5 <enqueue+0x6d>
f0104fac:	8b 45 08             	mov    0x8(%ebp),%eax
f0104faf:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fb2:	89 50 04             	mov    %edx,0x4(%eax)
f0104fb5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fb8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104fbb:	89 10                	mov    %edx,(%eax)
f0104fbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104fc0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104fc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fca:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fcd:	8d 50 01             	lea    0x1(%eax),%edx
f0104fd0:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fd3:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0104fd6:	90                   	nop
f0104fd7:	c9                   	leave  
f0104fd8:	c3                   	ret    

f0104fd9 <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0104fd9:	55                   	push   %ebp
f0104fda:	89 e5                	mov    %esp,%ebp
f0104fdc:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0104fdf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fe3:	75 0a                	jne    f0104fef <dequeue+0x16>
f0104fe5:	b8 00 00 00 00       	mov    $0x0,%eax
f0104fea:	e9 a0 00 00 00       	jmp    f010508f <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0104fef:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ff2:	8b 40 04             	mov    0x4(%eax),%eax
f0104ff5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0104ff8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104ffc:	0f 84 8a 00 00 00    	je     f010508c <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105002:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105006:	75 14                	jne    f010501c <dequeue+0x43>
f0105008:	83 ec 04             	sub    $0x4,%esp
f010500b:	68 c7 41 12 f0       	push   $0xf01241c7
f0105010:	6a 44                	push   $0x44
f0105012:	68 8b 41 12 f0       	push   $0xf012418b
f0105017:	e8 1d b3 ff ff       	call   f0100339 <_panic>
f010501c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010501f:	8b 40 08             	mov    0x8(%eax),%eax
f0105022:	85 c0                	test   %eax,%eax
f0105024:	74 11                	je     f0105037 <dequeue+0x5e>
f0105026:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105029:	8b 40 08             	mov    0x8(%eax),%eax
f010502c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010502f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105032:	89 50 0c             	mov    %edx,0xc(%eax)
f0105035:	eb 0c                	jmp    f0105043 <dequeue+0x6a>
f0105037:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010503a:	8b 50 0c             	mov    0xc(%eax),%edx
f010503d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105040:	89 50 04             	mov    %edx,0x4(%eax)
f0105043:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105046:	8b 40 0c             	mov    0xc(%eax),%eax
f0105049:	85 c0                	test   %eax,%eax
f010504b:	74 11                	je     f010505e <dequeue+0x85>
f010504d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105050:	8b 40 0c             	mov    0xc(%eax),%eax
f0105053:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105056:	8b 52 08             	mov    0x8(%edx),%edx
f0105059:	89 50 08             	mov    %edx,0x8(%eax)
f010505c:	eb 0b                	jmp    f0105069 <dequeue+0x90>
f010505e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105061:	8b 50 08             	mov    0x8(%eax),%edx
f0105064:	8b 45 08             	mov    0x8(%ebp),%eax
f0105067:	89 10                	mov    %edx,(%eax)
f0105069:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010506c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105073:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105076:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010507d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105080:	8b 40 0c             	mov    0xc(%eax),%eax
f0105083:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105086:	8b 45 08             	mov    0x8(%ebp),%eax
f0105089:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f010508c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010508f:	c9                   	leave  
f0105090:	c3                   	ret    

f0105091 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0105091:	55                   	push   %ebp
f0105092:	89 e5                	mov    %esp,%ebp
f0105094:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0105097:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010509b:	75 16                	jne    f01050b3 <remove_from_queue+0x22>
f010509d:	68 68 41 12 f0       	push   $0xf0124168
f01050a2:	68 76 41 12 f0       	push   $0xf0124176
f01050a7:	6a 4e                	push   $0x4e
f01050a9:	68 8b 41 12 f0       	push   $0xf012418b
f01050ae:	e8 86 b2 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f01050b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01050b7:	0f 84 8a 00 00 00    	je     f0105147 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f01050bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01050c1:	75 14                	jne    f01050d7 <remove_from_queue+0x46>
f01050c3:	83 ec 04             	sub    $0x4,%esp
f01050c6:	68 c7 41 12 f0       	push   $0xf01241c7
f01050cb:	6a 52                	push   $0x52
f01050cd:	68 8b 41 12 f0       	push   $0xf012418b
f01050d2:	e8 62 b2 ff ff       	call   f0100339 <_panic>
f01050d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050da:	8b 40 08             	mov    0x8(%eax),%eax
f01050dd:	85 c0                	test   %eax,%eax
f01050df:	74 11                	je     f01050f2 <remove_from_queue+0x61>
f01050e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050e4:	8b 40 08             	mov    0x8(%eax),%eax
f01050e7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01050ea:	8b 52 0c             	mov    0xc(%edx),%edx
f01050ed:	89 50 0c             	mov    %edx,0xc(%eax)
f01050f0:	eb 0c                	jmp    f01050fe <remove_from_queue+0x6d>
f01050f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050f5:	8b 50 0c             	mov    0xc(%eax),%edx
f01050f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01050fb:	89 50 04             	mov    %edx,0x4(%eax)
f01050fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105101:	8b 40 0c             	mov    0xc(%eax),%eax
f0105104:	85 c0                	test   %eax,%eax
f0105106:	74 11                	je     f0105119 <remove_from_queue+0x88>
f0105108:	8b 45 0c             	mov    0xc(%ebp),%eax
f010510b:	8b 40 0c             	mov    0xc(%eax),%eax
f010510e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105111:	8b 52 08             	mov    0x8(%edx),%edx
f0105114:	89 50 08             	mov    %edx,0x8(%eax)
f0105117:	eb 0b                	jmp    f0105124 <remove_from_queue+0x93>
f0105119:	8b 45 0c             	mov    0xc(%ebp),%eax
f010511c:	8b 50 08             	mov    0x8(%eax),%edx
f010511f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105122:	89 10                	mov    %edx,(%eax)
f0105124:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105127:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010512e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105131:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105138:	8b 45 08             	mov    0x8(%ebp),%eax
f010513b:	8b 40 0c             	mov    0xc(%eax),%eax
f010513e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105141:	8b 45 08             	mov    0x8(%ebp),%eax
f0105144:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105147:	90                   	nop
f0105148:	c9                   	leave  
f0105149:	c3                   	ret    

f010514a <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010514a:	55                   	push   %ebp
f010514b:	89 e5                	mov    %esp,%ebp
f010514d:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f0105150:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105154:	75 07                	jne    f010515d <find_env_in_queue+0x13>
f0105156:	b8 00 00 00 00       	mov    $0x0,%eax
f010515b:	eb 58                	jmp    f01051b5 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f010515d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0105164:	8b 45 08             	mov    0x8(%ebp),%eax
f0105167:	8b 00                	mov    (%eax),%eax
f0105169:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010516c:	eb 19                	jmp    f0105187 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f010516e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105171:	8b 40 10             	mov    0x10(%eax),%eax
f0105174:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105177:	75 05                	jne    f010517e <find_env_in_queue+0x34>
		{
			return ptr_env;
f0105179:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010517c:	eb 37                	jmp    f01051b5 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f010517e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105181:	8b 40 08             	mov    0x8(%eax),%eax
f0105184:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0105187:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010518b:	74 08                	je     f0105195 <find_env_in_queue+0x4b>
f010518d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105190:	8b 40 08             	mov    0x8(%eax),%eax
f0105193:	eb 05                	jmp    f010519a <find_env_in_queue+0x50>
f0105195:	b8 00 00 00 00       	mov    $0x0,%eax
f010519a:	8b 55 08             	mov    0x8(%ebp),%edx
f010519d:	89 42 08             	mov    %eax,0x8(%edx)
f01051a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a3:	8b 40 08             	mov    0x8(%eax),%eax
f01051a6:	85 c0                	test   %eax,%eax
f01051a8:	75 c4                	jne    f010516e <find_env_in_queue+0x24>
f01051aa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051ae:	75 be                	jne    f010516e <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f01051b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01051b5:	c9                   	leave  
f01051b6:	c3                   	ret    

f01051b7 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f01051b7:	55                   	push   %ebp
f01051b8:	89 e5                	mov    %esp,%ebp
f01051ba:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f01051bd:	83 ec 0c             	sub    $0xc,%esp
f01051c0:	68 c0 42 5f f0       	push   $0xf05f42c0
f01051c5:	e8 c2 99 00 00       	call   f010eb8c <acquire_spinlock>
f01051ca:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f01051cd:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01051d2:	85 c0                	test   %eax,%eax
f01051d4:	74 11                	je     f01051e7 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f01051d6:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01051db:	83 ec 0c             	sub    $0xc,%esp
f01051de:	50                   	push   %eax
f01051df:	e8 c2 3d 00 00       	call   f0108fa6 <kfree>
f01051e4:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f01051e7:	a1 84 46 5f f0       	mov    0xf05f4684,%eax
f01051ec:	85 c0                	test   %eax,%eax
f01051ee:	74 11                	je     f0105201 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f01051f0:	a1 84 46 5f f0       	mov    0xf05f4684,%eax
f01051f5:	83 ec 0c             	sub    $0xc,%esp
f01051f8:	50                   	push   %eax
f01051f9:	e8 a8 3d 00 00       	call   f0108fa6 <kfree>
f01051fe:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105201:	83 ec 0c             	sub    $0xc,%esp
f0105204:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105209:	e8 05 9a 00 00       	call   f010ec13 <release_spinlock>
f010520e:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105211:	90                   	nop
f0105212:	c9                   	leave  
f0105213:	c3                   	ret    

f0105214 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105214:	55                   	push   %ebp
f0105215:	89 e5                	mov    %esp,%ebp
f0105217:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010521a:	83 ec 0c             	sub    $0xc,%esp
f010521d:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105222:	e8 7e 9b 00 00       	call   f010eda5 <holding_spinlock>
f0105227:	83 c4 10             	add    $0x10,%esp
f010522a:	85 c0                	test   %eax,%eax
f010522c:	75 17                	jne    f0105245 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010522e:	83 ec 04             	sub    $0x4,%esp
f0105231:	68 e8 41 12 f0       	push   $0xf01241e8
f0105236:	68 85 00 00 00       	push   $0x85
f010523b:	68 8b 41 12 f0       	push   $0xf012418b
f0105240:	e8 f4 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105245:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105249:	75 19                	jne    f0105264 <sched_insert_ready0+0x50>
f010524b:	68 29 42 12 f0       	push   $0xf0124229
f0105250:	68 76 41 12 f0       	push   $0xf0124176
f0105255:	68 88 00 00 00       	push   $0x88
f010525a:	68 8b 41 12 f0       	push   $0xf012418b
f010525f:	e8 d5 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0105264:	8b 45 08             	mov    0x8(%ebp),%eax
f0105267:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f010526e:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105273:	83 ec 08             	sub    $0x8,%esp
f0105276:	ff 75 08             	pushl  0x8(%ebp)
f0105279:	50                   	push   %eax
f010527a:	e8 c9 fc ff ff       	call   f0104f48 <enqueue>
f010527f:	83 c4 10             	add    $0x10,%esp
	}
}
f0105282:	90                   	nop
f0105283:	c9                   	leave  
f0105284:	c3                   	ret    

f0105285 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0105285:	55                   	push   %ebp
f0105286:	89 e5                	mov    %esp,%ebp
f0105288:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010528b:	83 ec 0c             	sub    $0xc,%esp
f010528e:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105293:	e8 0d 9b 00 00       	call   f010eda5 <holding_spinlock>
f0105298:	83 c4 10             	add    $0x10,%esp
f010529b:	85 c0                	test   %eax,%eax
f010529d:	75 17                	jne    f01052b6 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010529f:	83 ec 04             	sub    $0x4,%esp
f01052a2:	68 e8 41 12 f0       	push   $0xf01241e8
f01052a7:	68 97 00 00 00       	push   $0x97
f01052ac:	68 8b 41 12 f0       	push   $0xf012418b
f01052b1:	e8 83 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f01052b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ba:	74 0b                	je     f01052c7 <sched_remove_ready+0x42>
f01052bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01052bf:	8b 40 18             	mov    0x18(%eax),%eax
f01052c2:	83 f8 01             	cmp    $0x1,%eax
f01052c5:	74 19                	je     f01052e0 <sched_remove_ready+0x5b>
f01052c7:	68 38 42 12 f0       	push   $0xf0124238
f01052cc:	68 76 41 12 f0       	push   $0xf0124176
f01052d1:	68 9a 00 00 00       	push   $0x9a
f01052d6:	68 8b 41 12 f0       	push   $0xf012418b
f01052db:	e8 59 b0 ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01052e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01052e7:	e9 e4 00 00 00       	jmp    f01053d0 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01052ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01052ef:	8b 40 10             	mov    0x10(%eax),%eax
f01052f2:	89 c2                	mov    %eax,%edx
f01052f4:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01052f9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01052fc:	c1 e1 04             	shl    $0x4,%ecx
f01052ff:	01 c8                	add    %ecx,%eax
f0105301:	83 ec 08             	sub    $0x8,%esp
f0105304:	52                   	push   %edx
f0105305:	50                   	push   %eax
f0105306:	e8 3f fe ff ff       	call   f010514a <find_env_in_queue>
f010530b:	83 c4 10             	add    $0x10,%esp
f010530e:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105311:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105315:	0f 84 b2 00 00 00    	je     f01053cd <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010531b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010531f:	75 17                	jne    f0105338 <sched_remove_ready+0xb3>
f0105321:	83 ec 04             	sub    $0x4,%esp
f0105324:	68 c7 41 12 f0       	push   $0xf01241c7
f0105329:	68 a1 00 00 00       	push   $0xa1
f010532e:	68 8b 41 12 f0       	push   $0xf012418b
f0105333:	e8 01 b0 ff ff       	call   f0100339 <_panic>
f0105338:	8b 45 08             	mov    0x8(%ebp),%eax
f010533b:	8b 40 08             	mov    0x8(%eax),%eax
f010533e:	85 c0                	test   %eax,%eax
f0105340:	74 11                	je     f0105353 <sched_remove_ready+0xce>
f0105342:	8b 45 08             	mov    0x8(%ebp),%eax
f0105345:	8b 40 08             	mov    0x8(%eax),%eax
f0105348:	8b 55 08             	mov    0x8(%ebp),%edx
f010534b:	8b 52 0c             	mov    0xc(%edx),%edx
f010534e:	89 50 0c             	mov    %edx,0xc(%eax)
f0105351:	eb 16                	jmp    f0105369 <sched_remove_ready+0xe4>
f0105353:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105358:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010535b:	c1 e2 04             	shl    $0x4,%edx
f010535e:	01 c2                	add    %eax,%edx
f0105360:	8b 45 08             	mov    0x8(%ebp),%eax
f0105363:	8b 40 0c             	mov    0xc(%eax),%eax
f0105366:	89 42 04             	mov    %eax,0x4(%edx)
f0105369:	8b 45 08             	mov    0x8(%ebp),%eax
f010536c:	8b 40 0c             	mov    0xc(%eax),%eax
f010536f:	85 c0                	test   %eax,%eax
f0105371:	74 11                	je     f0105384 <sched_remove_ready+0xff>
f0105373:	8b 45 08             	mov    0x8(%ebp),%eax
f0105376:	8b 40 0c             	mov    0xc(%eax),%eax
f0105379:	8b 55 08             	mov    0x8(%ebp),%edx
f010537c:	8b 52 08             	mov    0x8(%edx),%edx
f010537f:	89 50 08             	mov    %edx,0x8(%eax)
f0105382:	eb 15                	jmp    f0105399 <sched_remove_ready+0x114>
f0105384:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105389:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010538c:	c1 e2 04             	shl    $0x4,%edx
f010538f:	01 c2                	add    %eax,%edx
f0105391:	8b 45 08             	mov    0x8(%ebp),%eax
f0105394:	8b 40 08             	mov    0x8(%eax),%eax
f0105397:	89 02                	mov    %eax,(%edx)
f0105399:	8b 45 08             	mov    0x8(%ebp),%eax
f010539c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01053a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01053ad:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01053b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053b5:	c1 e2 04             	shl    $0x4,%edx
f01053b8:	01 d0                	add    %edx,%eax
f01053ba:	8b 50 0c             	mov    0xc(%eax),%edx
f01053bd:	4a                   	dec    %edx
f01053be:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f01053c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c4:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f01053cb:	eb 14                	jmp    f01053e1 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01053cd:	ff 45 f4             	incl   -0xc(%ebp)
f01053d0:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f01053d5:	0f b6 c0             	movzbl %al,%eax
f01053d8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01053db:	0f 8f 0b ff ff ff    	jg     f01052ec <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01053e1:	c9                   	leave  
f01053e2:	c3                   	ret    

f01053e3 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01053e3:	55                   	push   %ebp
f01053e4:	89 e5                	mov    %esp,%ebp
f01053e6:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01053e9:	83 ec 0c             	sub    $0xc,%esp
f01053ec:	68 c0 42 5f f0       	push   $0xf05f42c0
f01053f1:	e8 af 99 00 00       	call   f010eda5 <holding_spinlock>
f01053f6:	83 c4 10             	add    $0x10,%esp
f01053f9:	85 c0                	test   %eax,%eax
f01053fb:	75 17                	jne    f0105414 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01053fd:	83 ec 04             	sub    $0x4,%esp
f0105400:	68 e8 41 12 f0       	push   $0xf01241e8
f0105405:	68 b0 00 00 00       	push   $0xb0
f010540a:	68 8b 41 12 f0       	push   $0xf012418b
f010540f:	e8 25 af ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105414:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105418:	75 19                	jne    f0105433 <sched_insert_new+0x50>
f010541a:	68 29 42 12 f0       	push   $0xf0124229
f010541f:	68 76 41 12 f0       	push   $0xf0124176
f0105424:	68 b3 00 00 00       	push   $0xb3
f0105429:	68 8b 41 12 f0       	push   $0xf012418b
f010542e:	e8 06 af ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105433:	8b 45 08             	mov    0x8(%ebp),%eax
f0105436:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010543d:	83 ec 08             	sub    $0x8,%esp
f0105440:	ff 75 08             	pushl  0x8(%ebp)
f0105443:	68 30 43 5f f0       	push   $0xf05f4330
f0105448:	e8 fb fa ff ff       	call   f0104f48 <enqueue>
f010544d:	83 c4 10             	add    $0x10,%esp
	}
}
f0105450:	90                   	nop
f0105451:	c9                   	leave  
f0105452:	c3                   	ret    

f0105453 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0105453:	55                   	push   %ebp
f0105454:	89 e5                	mov    %esp,%ebp
f0105456:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105459:	83 ec 0c             	sub    $0xc,%esp
f010545c:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105461:	e8 3f 99 00 00       	call   f010eda5 <holding_spinlock>
f0105466:	83 c4 10             	add    $0x10,%esp
f0105469:	85 c0                	test   %eax,%eax
f010546b:	75 17                	jne    f0105484 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010546d:	83 ec 04             	sub    $0x4,%esp
f0105470:	68 e8 41 12 f0       	push   $0xf01241e8
f0105475:	68 c1 00 00 00       	push   $0xc1
f010547a:	68 8b 41 12 f0       	push   $0xf012418b
f010547f:	e8 b5 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0105484:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105488:	74 0b                	je     f0105495 <sched_remove_new+0x42>
f010548a:	8b 45 08             	mov    0x8(%ebp),%eax
f010548d:	8b 40 18             	mov    0x18(%eax),%eax
f0105490:	83 f8 04             	cmp    $0x4,%eax
f0105493:	74 19                	je     f01054ae <sched_remove_new+0x5b>
f0105495:	68 64 42 12 f0       	push   $0xf0124264
f010549a:	68 76 41 12 f0       	push   $0xf0124176
f010549f:	68 c4 00 00 00       	push   $0xc4
f01054a4:	68 8b 41 12 f0       	push   $0xf012418b
f01054a9:	e8 8b ae ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f01054ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054b2:	75 17                	jne    f01054cb <sched_remove_new+0x78>
f01054b4:	83 ec 04             	sub    $0x4,%esp
f01054b7:	68 c7 41 12 f0       	push   $0xf01241c7
f01054bc:	68 c6 00 00 00       	push   $0xc6
f01054c1:	68 8b 41 12 f0       	push   $0xf012418b
f01054c6:	e8 6e ae ff ff       	call   f0100339 <_panic>
f01054cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01054ce:	8b 40 08             	mov    0x8(%eax),%eax
f01054d1:	85 c0                	test   %eax,%eax
f01054d3:	74 11                	je     f01054e6 <sched_remove_new+0x93>
f01054d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01054d8:	8b 40 08             	mov    0x8(%eax),%eax
f01054db:	8b 55 08             	mov    0x8(%ebp),%edx
f01054de:	8b 52 0c             	mov    0xc(%edx),%edx
f01054e1:	89 50 0c             	mov    %edx,0xc(%eax)
f01054e4:	eb 0b                	jmp    f01054f1 <sched_remove_new+0x9e>
f01054e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01054e9:	8b 40 0c             	mov    0xc(%eax),%eax
f01054ec:	a3 34 43 5f f0       	mov    %eax,0xf05f4334
f01054f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01054f4:	8b 40 0c             	mov    0xc(%eax),%eax
f01054f7:	85 c0                	test   %eax,%eax
f01054f9:	74 11                	je     f010550c <sched_remove_new+0xb9>
f01054fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01054fe:	8b 40 0c             	mov    0xc(%eax),%eax
f0105501:	8b 55 08             	mov    0x8(%ebp),%edx
f0105504:	8b 52 08             	mov    0x8(%edx),%edx
f0105507:	89 50 08             	mov    %edx,0x8(%eax)
f010550a:	eb 0b                	jmp    f0105517 <sched_remove_new+0xc4>
f010550c:	8b 45 08             	mov    0x8(%ebp),%eax
f010550f:	8b 40 08             	mov    0x8(%eax),%eax
f0105512:	a3 30 43 5f f0       	mov    %eax,0xf05f4330
f0105517:	8b 45 08             	mov    0x8(%ebp),%eax
f010551a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105521:	8b 45 08             	mov    0x8(%ebp),%eax
f0105524:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010552b:	a1 3c 43 5f f0       	mov    0xf05f433c,%eax
f0105530:	48                   	dec    %eax
f0105531:	a3 3c 43 5f f0       	mov    %eax,0xf05f433c
		env->env_status = ENV_UNKNOWN;
f0105536:	8b 45 08             	mov    0x8(%ebp),%eax
f0105539:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105540:	90                   	nop
f0105541:	c9                   	leave  
f0105542:	c3                   	ret    

f0105543 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0105543:	55                   	push   %ebp
f0105544:	89 e5                	mov    %esp,%ebp
f0105546:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105549:	83 ec 0c             	sub    $0xc,%esp
f010554c:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105551:	e8 4f 98 00 00       	call   f010eda5 <holding_spinlock>
f0105556:	83 c4 10             	add    $0x10,%esp
f0105559:	85 c0                	test   %eax,%eax
f010555b:	75 17                	jne    f0105574 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010555d:	83 ec 04             	sub    $0x4,%esp
f0105560:	68 e8 41 12 f0       	push   $0xf01241e8
f0105565:	68 d2 00 00 00       	push   $0xd2
f010556a:	68 8b 41 12 f0       	push   $0xf012418b
f010556f:	e8 c5 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105574:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105578:	75 19                	jne    f0105593 <sched_insert_exit+0x50>
f010557a:	68 29 42 12 f0       	push   $0xf0124229
f010557f:	68 76 41 12 f0       	push   $0xf0124176
f0105584:	68 d5 00 00 00       	push   $0xd5
f0105589:	68 8b 41 12 f0       	push   $0xf012418b
f010558e:	e8 a6 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0105593:	e8 56 92 00 00       	call   f010e7ee <isBufferingEnabled>
f0105598:	84 c0                	test   %al,%al
f010559a:	74 0e                	je     f01055aa <sched_insert_exit+0x67>
f010559c:	83 ec 0c             	sub    $0xc,%esp
f010559f:	ff 75 08             	pushl  0x8(%ebp)
f01055a2:	e8 de 67 00 00       	call   f010bd85 <cleanup_buffers>
f01055a7:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f01055aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01055ad:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f01055b4:	83 ec 08             	sub    $0x8,%esp
f01055b7:	ff 75 08             	pushl  0x8(%ebp)
f01055ba:	68 40 43 5f f0       	push   $0xf05f4340
f01055bf:	e8 84 f9 ff ff       	call   f0104f48 <enqueue>
f01055c4:	83 c4 10             	add    $0x10,%esp
	}
}
f01055c7:	90                   	nop
f01055c8:	c9                   	leave  
f01055c9:	c3                   	ret    

f01055ca <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f01055ca:	55                   	push   %ebp
f01055cb:	89 e5                	mov    %esp,%ebp
f01055cd:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055d0:	83 ec 0c             	sub    $0xc,%esp
f01055d3:	68 c0 42 5f f0       	push   $0xf05f42c0
f01055d8:	e8 c8 97 00 00       	call   f010eda5 <holding_spinlock>
f01055dd:	83 c4 10             	add    $0x10,%esp
f01055e0:	85 c0                	test   %eax,%eax
f01055e2:	75 17                	jne    f01055fb <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055e4:	83 ec 04             	sub    $0x4,%esp
f01055e7:	68 e8 41 12 f0       	push   $0xf01241e8
f01055ec:	68 e3 00 00 00       	push   $0xe3
f01055f1:	68 8b 41 12 f0       	push   $0xf012418b
f01055f6:	e8 3e ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01055fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055ff:	74 0b                	je     f010560c <sched_remove_exit+0x42>
f0105601:	8b 45 08             	mov    0x8(%ebp),%eax
f0105604:	8b 40 18             	mov    0x18(%eax),%eax
f0105607:	83 f8 05             	cmp    $0x5,%eax
f010560a:	74 19                	je     f0105625 <sched_remove_exit+0x5b>
f010560c:	68 90 42 12 f0       	push   $0xf0124290
f0105611:	68 76 41 12 f0       	push   $0xf0124176
f0105616:	68 e6 00 00 00       	push   $0xe6
f010561b:	68 8b 41 12 f0       	push   $0xf012418b
f0105620:	e8 14 ad ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105625:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105629:	75 17                	jne    f0105642 <sched_remove_exit+0x78>
f010562b:	83 ec 04             	sub    $0x4,%esp
f010562e:	68 c7 41 12 f0       	push   $0xf01241c7
f0105633:	68 e8 00 00 00       	push   $0xe8
f0105638:	68 8b 41 12 f0       	push   $0xf012418b
f010563d:	e8 f7 ac ff ff       	call   f0100339 <_panic>
f0105642:	8b 45 08             	mov    0x8(%ebp),%eax
f0105645:	8b 40 08             	mov    0x8(%eax),%eax
f0105648:	85 c0                	test   %eax,%eax
f010564a:	74 11                	je     f010565d <sched_remove_exit+0x93>
f010564c:	8b 45 08             	mov    0x8(%ebp),%eax
f010564f:	8b 40 08             	mov    0x8(%eax),%eax
f0105652:	8b 55 08             	mov    0x8(%ebp),%edx
f0105655:	8b 52 0c             	mov    0xc(%edx),%edx
f0105658:	89 50 0c             	mov    %edx,0xc(%eax)
f010565b:	eb 0b                	jmp    f0105668 <sched_remove_exit+0x9e>
f010565d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105660:	8b 40 0c             	mov    0xc(%eax),%eax
f0105663:	a3 44 43 5f f0       	mov    %eax,0xf05f4344
f0105668:	8b 45 08             	mov    0x8(%ebp),%eax
f010566b:	8b 40 0c             	mov    0xc(%eax),%eax
f010566e:	85 c0                	test   %eax,%eax
f0105670:	74 11                	je     f0105683 <sched_remove_exit+0xb9>
f0105672:	8b 45 08             	mov    0x8(%ebp),%eax
f0105675:	8b 40 0c             	mov    0xc(%eax),%eax
f0105678:	8b 55 08             	mov    0x8(%ebp),%edx
f010567b:	8b 52 08             	mov    0x8(%edx),%edx
f010567e:	89 50 08             	mov    %edx,0x8(%eax)
f0105681:	eb 0b                	jmp    f010568e <sched_remove_exit+0xc4>
f0105683:	8b 45 08             	mov    0x8(%ebp),%eax
f0105686:	8b 40 08             	mov    0x8(%eax),%eax
f0105689:	a3 40 43 5f f0       	mov    %eax,0xf05f4340
f010568e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105691:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105698:	8b 45 08             	mov    0x8(%ebp),%eax
f010569b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01056a2:	a1 4c 43 5f f0       	mov    0xf05f434c,%eax
f01056a7:	48                   	dec    %eax
f01056a8:	a3 4c 43 5f f0       	mov    %eax,0xf05f434c
		env->env_status = ENV_UNKNOWN;
f01056ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b0:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01056b7:	90                   	nop
f01056b8:	c9                   	leave  
f01056b9:	c3                   	ret    

f01056ba <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f01056ba:	55                   	push   %ebp
f01056bb:	89 e5                	mov    %esp,%ebp
f01056bd:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01056c0:	83 ec 0c             	sub    $0xc,%esp
f01056c3:	68 c0 42 5f f0       	push   $0xf05f42c0
f01056c8:	e8 bf 94 00 00       	call   f010eb8c <acquire_spinlock>
f01056cd:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f01056d0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01056d4:	75 19                	jne    f01056ef <sched_new_env+0x35>
f01056d6:	68 bb 42 12 f0       	push   $0xf01242bb
f01056db:	68 76 41 12 f0       	push   $0xf0124176
f01056e0:	68 f6 00 00 00       	push   $0xf6
f01056e5:	68 8b 41 12 f0       	push   $0xf012418b
f01056ea:	e8 4a ac ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f01056ef:	83 ec 0c             	sub    $0xc,%esp
f01056f2:	ff 75 08             	pushl  0x8(%ebp)
f01056f5:	e8 e9 fc ff ff       	call   f01053e3 <sched_insert_new>
f01056fa:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01056fd:	83 ec 0c             	sub    $0xc,%esp
f0105700:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105705:	e8 09 95 00 00       	call   f010ec13 <release_spinlock>
f010570a:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f010570d:	90                   	nop
f010570e:	c9                   	leave  
f010570f:	c3                   	ret    

f0105710 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105710:	55                   	push   %ebp
f0105711:	89 e5                	mov    %esp,%ebp
f0105713:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105716:	83 ec 0c             	sub    $0xc,%esp
f0105719:	68 c0 42 5f f0       	push   $0xf05f42c0
f010571e:	e8 69 94 00 00       	call   f010eb8c <acquire_spinlock>
f0105723:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105726:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010572d:	a1 30 43 5f f0       	mov    0xf05f4330,%eax
f0105732:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105735:	eb 53                	jmp    f010578a <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105737:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010573a:	8b 40 10             	mov    0x10(%eax),%eax
f010573d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105740:	75 40                	jne    f0105782 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0105742:	83 ec 0c             	sub    $0xc,%esp
f0105745:	ff 75 f4             	pushl  -0xc(%ebp)
f0105748:	e8 06 fd ff ff       	call   f0105453 <sched_remove_new>
f010574d:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f0105750:	83 ec 0c             	sub    $0xc,%esp
f0105753:	ff 75 f4             	pushl  -0xc(%ebp)
f0105756:	e8 b9 fa ff ff       	call   f0105214 <sched_insert_ready0>
f010575b:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f010575e:	e8 3e 19 00 00       	call   f01070a1 <mycpu>
f0105763:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105769:	85 c0                	test   %eax,%eax
f010576b:	75 46                	jne    f01057b3 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010576d:	83 ec 0c             	sub    $0xc,%esp
f0105770:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105775:	e8 99 94 00 00       	call   f010ec13 <release_spinlock>
f010577a:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f010577d:	e8 ad 0f 00 00       	call   f010672f <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105782:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f0105787:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010578a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010578e:	74 08                	je     f0105798 <sched_run_env+0x88>
f0105790:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105793:	8b 40 08             	mov    0x8(%eax),%eax
f0105796:	eb 05                	jmp    f010579d <sched_run_env+0x8d>
f0105798:	b8 00 00 00 00       	mov    $0x0,%eax
f010579d:	a3 38 43 5f f0       	mov    %eax,0xf05f4338
f01057a2:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f01057a7:	85 c0                	test   %eax,%eax
f01057a9:	75 8c                	jne    f0105737 <sched_run_env+0x27>
f01057ab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057af:	75 86                	jne    f0105737 <sched_run_env+0x27>
f01057b1:	eb 01                	jmp    f01057b4 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f01057b3:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057b4:	83 ec 0c             	sub    $0xc,%esp
f01057b7:	68 c0 42 5f f0       	push   $0xf05f42c0
f01057bc:	e8 52 94 00 00       	call   f010ec13 <release_spinlock>
f01057c1:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f01057c4:	90                   	nop
f01057c5:	c9                   	leave  
f01057c6:	c3                   	ret    

f01057c7 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f01057c7:	55                   	push   %ebp
f01057c8:	89 e5                	mov    %esp,%ebp
f01057ca:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f01057cd:	83 ec 0c             	sub    $0xc,%esp
f01057d0:	68 c0 42 5f f0       	push   $0xf05f42c0
f01057d5:	e8 cb 95 00 00       	call   f010eda5 <holding_spinlock>
f01057da:	83 c4 10             	add    $0x10,%esp
f01057dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01057e0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01057e4:	75 10                	jne    f01057f6 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f01057e6:	83 ec 0c             	sub    $0xc,%esp
f01057e9:	68 c0 42 5f f0       	push   $0xf05f42c0
f01057ee:	e8 99 93 00 00       	call   f010eb8c <acquire_spinlock>
f01057f3:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01057f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01057fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105804:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105808:	75 59                	jne    f0105863 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010580a:	a1 30 43 5f f0       	mov    0xf05f4330,%eax
f010580f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105812:	eb 28                	jmp    f010583c <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105814:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105817:	8b 40 10             	mov    0x10(%eax),%eax
f010581a:	3b 45 08             	cmp    0x8(%ebp),%eax
f010581d:	75 15                	jne    f0105834 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f010581f:	83 ec 0c             	sub    $0xc,%esp
f0105822:	ff 75 f4             	pushl  -0xc(%ebp)
f0105825:	e8 29 fc ff ff       	call   f0105453 <sched_remove_new>
f010582a:	83 c4 10             	add    $0x10,%esp
				found = 1;
f010582d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105834:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f0105839:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010583c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105840:	74 08                	je     f010584a <sched_exit_env+0x83>
f0105842:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105845:	8b 40 08             	mov    0x8(%eax),%eax
f0105848:	eb 05                	jmp    f010584f <sched_exit_env+0x88>
f010584a:	b8 00 00 00 00       	mov    $0x0,%eax
f010584f:	a3 38 43 5f f0       	mov    %eax,0xf05f4338
f0105854:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f0105859:	85 c0                	test   %eax,%eax
f010585b:	75 b7                	jne    f0105814 <sched_exit_env+0x4d>
f010585d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105861:	75 b1                	jne    f0105814 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0105863:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105867:	0f 85 67 01 00 00    	jne    f01059d4 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010586d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105874:	e9 47 01 00 00       	jmp    f01059c0 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105879:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f010587e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105881:	c1 e2 04             	shl    $0x4,%edx
f0105884:	01 d0                	add    %edx,%eax
f0105886:	8b 00                	mov    (%eax),%eax
f0105888:	85 c0                	test   %eax,%eax
f010588a:	0f 84 27 01 00 00    	je     f01059b7 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f0105890:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105897:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f010589c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010589f:	c1 e2 04             	shl    $0x4,%edx
f01058a2:	01 d0                	add    %edx,%eax
f01058a4:	8b 00                	mov    (%eax),%eax
f01058a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01058a9:	e9 d1 00 00 00       	jmp    f010597f <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f01058ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058b1:	8b 40 10             	mov    0x10(%eax),%eax
f01058b4:	3b 45 08             	cmp    0x8(%ebp),%eax
f01058b7:	0f 85 af 00 00 00    	jne    f010596c <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01058bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058c1:	75 17                	jne    f01058da <sched_exit_env+0x113>
f01058c3:	83 ec 04             	sub    $0x4,%esp
f01058c6:	68 c7 41 12 f0       	push   $0xf01241c7
f01058cb:	68 44 01 00 00       	push   $0x144
f01058d0:	68 8b 41 12 f0       	push   $0xf012418b
f01058d5:	e8 5f aa ff ff       	call   f0100339 <_panic>
f01058da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058dd:	8b 40 08             	mov    0x8(%eax),%eax
f01058e0:	85 c0                	test   %eax,%eax
f01058e2:	74 11                	je     f01058f5 <sched_exit_env+0x12e>
f01058e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058e7:	8b 40 08             	mov    0x8(%eax),%eax
f01058ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058ed:	8b 52 0c             	mov    0xc(%edx),%edx
f01058f0:	89 50 0c             	mov    %edx,0xc(%eax)
f01058f3:	eb 16                	jmp    f010590b <sched_exit_env+0x144>
f01058f5:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01058fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058fd:	c1 e2 04             	shl    $0x4,%edx
f0105900:	01 c2                	add    %eax,%edx
f0105902:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105905:	8b 40 0c             	mov    0xc(%eax),%eax
f0105908:	89 42 04             	mov    %eax,0x4(%edx)
f010590b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010590e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105911:	85 c0                	test   %eax,%eax
f0105913:	74 11                	je     f0105926 <sched_exit_env+0x15f>
f0105915:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105918:	8b 40 0c             	mov    0xc(%eax),%eax
f010591b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010591e:	8b 52 08             	mov    0x8(%edx),%edx
f0105921:	89 50 08             	mov    %edx,0x8(%eax)
f0105924:	eb 15                	jmp    f010593b <sched_exit_env+0x174>
f0105926:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f010592b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010592e:	c1 e2 04             	shl    $0x4,%edx
f0105931:	01 c2                	add    %eax,%edx
f0105933:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105936:	8b 40 08             	mov    0x8(%eax),%eax
f0105939:	89 02                	mov    %eax,(%edx)
f010593b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010593e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105945:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105948:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010594f:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105954:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105957:	c1 e2 04             	shl    $0x4,%edx
f010595a:	01 d0                	add    %edx,%eax
f010595c:	8b 50 0c             	mov    0xc(%eax),%edx
f010595f:	4a                   	dec    %edx
f0105960:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105963:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f010596a:	eb 4b                	jmp    f01059b7 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010596c:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105971:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105974:	c1 e2 04             	shl    $0x4,%edx
f0105977:	01 d0                	add    %edx,%eax
f0105979:	8b 40 08             	mov    0x8(%eax),%eax
f010597c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010597f:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105984:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105987:	c1 e2 04             	shl    $0x4,%edx
f010598a:	01 d0                	add    %edx,%eax
f010598c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105990:	74 08                	je     f010599a <sched_exit_env+0x1d3>
f0105992:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105995:	8b 52 08             	mov    0x8(%edx),%edx
f0105998:	eb 05                	jmp    f010599f <sched_exit_env+0x1d8>
f010599a:	ba 00 00 00 00       	mov    $0x0,%edx
f010599f:	89 50 08             	mov    %edx,0x8(%eax)
f01059a2:	8b 40 08             	mov    0x8(%eax),%eax
f01059a5:	85 c0                	test   %eax,%eax
f01059a7:	0f 85 01 ff ff ff    	jne    f01058ae <sched_exit_env+0xe7>
f01059ad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059b1:	0f 85 f7 fe ff ff    	jne    f01058ae <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01059b7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059bb:	75 16                	jne    f01059d3 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01059bd:	ff 45 ec             	incl   -0x14(%ebp)
f01059c0:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f01059c5:	0f b6 c0             	movzbl %al,%eax
f01059c8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01059cb:	0f 8f a8 fe ff ff    	jg     f0105879 <sched_exit_env+0xb2>
f01059d1:	eb 01                	jmp    f01059d4 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01059d3:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f01059d4:	e8 32 52 00 00       	call   f010ac0b <get_cpu_proc>
f01059d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01059dc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01059e0:	75 19                	jne    f01059fb <sched_exit_env+0x234>
f01059e2:	68 c3 42 12 f0       	push   $0xf01242c3
f01059e7:	68 76 41 12 f0       	push   $0xf0124176
f01059ec:	68 4e 01 00 00       	push   $0x14e
f01059f1:	68 8b 41 12 f0       	push   $0xf012418b
f01059f6:	e8 3e a9 ff ff       	call   f0100339 <_panic>
	if (!found)
f01059fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059ff:	75 18                	jne    f0105a19 <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105a01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a04:	8b 40 10             	mov    0x10(%eax),%eax
f0105a07:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a0a:	75 0d                	jne    f0105a19 <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105a0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a12:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a1d:	74 1e                	je     f0105a3d <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105a1f:	83 ec 0c             	sub    $0xc,%esp
f0105a22:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a25:	e8 19 fb ff ff       	call   f0105543 <sched_insert_exit>
f0105a2a:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a30:	8b 40 10             	mov    0x10(%eax),%eax
f0105a33:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a36:	75 05                	jne    f0105a3d <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a38:	e8 47 53 00 00       	call   f010ad84 <sched>
		}
	}
	if (!lock_already_held)
f0105a3d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105a41:	75 10                	jne    f0105a53 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105a43:	83 ec 0c             	sub    $0xc,%esp
f0105a46:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105a4b:	e8 c3 91 00 00       	call   f010ec13 <release_spinlock>
f0105a50:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105a53:	90                   	nop
f0105a54:	c9                   	leave  
f0105a55:	c3                   	ret    

f0105a56 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105a56:	55                   	push   %ebp
f0105a57:	89 e5                	mov    %esp,%ebp
f0105a59:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a5c:	83 ec 0c             	sub    $0xc,%esp
f0105a5f:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105a64:	e8 23 91 00 00       	call   f010eb8c <acquire_spinlock>
f0105a69:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105a6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105a73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105a7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a7e:	75 79                	jne    f0105af9 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105a80:	a1 30 43 5f f0       	mov    0xf05f4330,%eax
f0105a85:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a88:	eb 48                	jmp    f0105ad2 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105a8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a8d:	8b 40 10             	mov    0x10(%eax),%eax
f0105a90:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a93:	75 35                	jne    f0105aca <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105a95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a98:	8d 50 20             	lea    0x20(%eax),%edx
f0105a9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a9e:	8b 40 10             	mov    0x10(%eax),%eax
f0105aa1:	83 ec 04             	sub    $0x4,%esp
f0105aa4:	52                   	push   %edx
f0105aa5:	50                   	push   %eax
f0105aa6:	68 d4 42 12 f0       	push   $0xf01242d4
f0105aab:	e8 db b4 ff ff       	call   f0100f8b <cprintf>
f0105ab0:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105ab3:	83 ec 0c             	sub    $0xc,%esp
f0105ab6:	ff 75 f4             	pushl  -0xc(%ebp)
f0105ab9:	e8 95 f9 ff ff       	call   f0105453 <sched_remove_new>
f0105abe:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105ac1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105ac8:	eb 2f                	jmp    f0105af9 <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105aca:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f0105acf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ad2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ad6:	74 08                	je     f0105ae0 <sched_kill_env+0x8a>
f0105ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105adb:	8b 40 08             	mov    0x8(%eax),%eax
f0105ade:	eb 05                	jmp    f0105ae5 <sched_kill_env+0x8f>
f0105ae0:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ae5:	a3 38 43 5f f0       	mov    %eax,0xf05f4338
f0105aea:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f0105aef:	85 c0                	test   %eax,%eax
f0105af1:	75 97                	jne    f0105a8a <sched_kill_env+0x34>
f0105af3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105af7:	75 91                	jne    f0105a8a <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105af9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105afd:	0f 85 85 01 00 00    	jne    f0105c88 <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b0a:	e9 65 01 00 00       	jmp    f0105c74 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b0f:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105b14:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b17:	c1 e2 04             	shl    $0x4,%edx
f0105b1a:	01 d0                	add    %edx,%eax
f0105b1c:	8b 00                	mov    (%eax),%eax
f0105b1e:	85 c0                	test   %eax,%eax
f0105b20:	0f 84 45 01 00 00    	je     f0105c6b <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105b26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b2d:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105b32:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b35:	c1 e2 04             	shl    $0x4,%edx
f0105b38:	01 d0                	add    %edx,%eax
f0105b3a:	8b 00                	mov    (%eax),%eax
f0105b3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b3f:	e9 ef 00 00 00       	jmp    f0105c33 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b47:	8b 40 10             	mov    0x10(%eax),%eax
f0105b4a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b4d:	0f 85 cd 00 00 00    	jne    f0105c20 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105b53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b56:	8d 50 20             	lea    0x20(%eax),%edx
f0105b59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b5c:	8b 40 10             	mov    0x10(%eax),%eax
f0105b5f:	ff 75 ec             	pushl  -0x14(%ebp)
f0105b62:	52                   	push   %edx
f0105b63:	50                   	push   %eax
f0105b64:	68 fc 42 12 f0       	push   $0xf01242fc
f0105b69:	e8 1d b4 ff ff       	call   f0100f8b <cprintf>
f0105b6e:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105b71:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b75:	75 17                	jne    f0105b8e <sched_kill_env+0x138>
f0105b77:	83 ec 04             	sub    $0x4,%esp
f0105b7a:	68 c7 41 12 f0       	push   $0xf01241c7
f0105b7f:	68 91 01 00 00       	push   $0x191
f0105b84:	68 8b 41 12 f0       	push   $0xf012418b
f0105b89:	e8 ab a7 ff ff       	call   f0100339 <_panic>
f0105b8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b91:	8b 40 08             	mov    0x8(%eax),%eax
f0105b94:	85 c0                	test   %eax,%eax
f0105b96:	74 11                	je     f0105ba9 <sched_kill_env+0x153>
f0105b98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b9b:	8b 40 08             	mov    0x8(%eax),%eax
f0105b9e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105ba1:	8b 52 0c             	mov    0xc(%edx),%edx
f0105ba4:	89 50 0c             	mov    %edx,0xc(%eax)
f0105ba7:	eb 16                	jmp    f0105bbf <sched_kill_env+0x169>
f0105ba9:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105bae:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bb1:	c1 e2 04             	shl    $0x4,%edx
f0105bb4:	01 c2                	add    %eax,%edx
f0105bb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb9:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bbc:	89 42 04             	mov    %eax,0x4(%edx)
f0105bbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bc2:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bc5:	85 c0                	test   %eax,%eax
f0105bc7:	74 11                	je     f0105bda <sched_kill_env+0x184>
f0105bc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bcc:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bcf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bd2:	8b 52 08             	mov    0x8(%edx),%edx
f0105bd5:	89 50 08             	mov    %edx,0x8(%eax)
f0105bd8:	eb 15                	jmp    f0105bef <sched_kill_env+0x199>
f0105bda:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105bdf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105be2:	c1 e2 04             	shl    $0x4,%edx
f0105be5:	01 c2                	add    %eax,%edx
f0105be7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bea:	8b 40 08             	mov    0x8(%eax),%eax
f0105bed:	89 02                	mov    %eax,(%edx)
f0105bef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105bf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bfc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c03:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105c08:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c0b:	c1 e2 04             	shl    $0x4,%edx
f0105c0e:	01 d0                	add    %edx,%eax
f0105c10:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c13:	4a                   	dec    %edx
f0105c14:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c17:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c1e:	eb 4b                	jmp    f0105c6b <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c20:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105c25:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c28:	c1 e2 04             	shl    $0x4,%edx
f0105c2b:	01 d0                	add    %edx,%eax
f0105c2d:	8b 40 08             	mov    0x8(%eax),%eax
f0105c30:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c33:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105c38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c3b:	c1 e2 04             	shl    $0x4,%edx
f0105c3e:	01 d0                	add    %edx,%eax
f0105c40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c44:	74 08                	je     f0105c4e <sched_kill_env+0x1f8>
f0105c46:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c49:	8b 52 08             	mov    0x8(%edx),%edx
f0105c4c:	eb 05                	jmp    f0105c53 <sched_kill_env+0x1fd>
f0105c4e:	ba 00 00 00 00       	mov    $0x0,%edx
f0105c53:	89 50 08             	mov    %edx,0x8(%eax)
f0105c56:	8b 40 08             	mov    0x8(%eax),%eax
f0105c59:	85 c0                	test   %eax,%eax
f0105c5b:	0f 85 e3 fe ff ff    	jne    f0105b44 <sched_kill_env+0xee>
f0105c61:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c65:	0f 85 d9 fe ff ff    	jne    f0105b44 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105c6b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c6f:	75 16                	jne    f0105c87 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105c71:	ff 45 ec             	incl   -0x14(%ebp)
f0105c74:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f0105c79:	0f b6 c0             	movzbl %al,%eax
f0105c7c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105c7f:	0f 8f 8a fe ff ff    	jg     f0105b0f <sched_kill_env+0xb9>
f0105c85:	eb 01                	jmp    f0105c88 <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105c87:	90                   	nop
		}
	}
	if (!found)
f0105c88:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c8c:	0f 85 80 00 00 00    	jne    f0105d12 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105c92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105c99:	a1 40 43 5f f0       	mov    0xf05f4340,%eax
f0105c9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ca1:	eb 48                	jmp    f0105ceb <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105ca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ca6:	8b 40 10             	mov    0x10(%eax),%eax
f0105ca9:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105cac:	75 35                	jne    f0105ce3 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105cae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cb1:	8d 50 20             	lea    0x20(%eax),%edx
f0105cb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cb7:	8b 40 10             	mov    0x10(%eax),%eax
f0105cba:	83 ec 04             	sub    $0x4,%esp
f0105cbd:	52                   	push   %edx
f0105cbe:	50                   	push   %eax
f0105cbf:	68 28 43 12 f0       	push   $0xf0124328
f0105cc4:	e8 c2 b2 ff ff       	call   f0100f8b <cprintf>
f0105cc9:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105ccc:	83 ec 0c             	sub    $0xc,%esp
f0105ccf:	ff 75 f4             	pushl  -0xc(%ebp)
f0105cd2:	e8 f3 f8 ff ff       	call   f01055ca <sched_remove_exit>
f0105cd7:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105cda:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105ce1:	eb 2f                	jmp    f0105d12 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ce3:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f0105ce8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ceb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cef:	74 08                	je     f0105cf9 <sched_kill_env+0x2a3>
f0105cf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cf4:	8b 40 08             	mov    0x8(%eax),%eax
f0105cf7:	eb 05                	jmp    f0105cfe <sched_kill_env+0x2a8>
f0105cf9:	b8 00 00 00 00       	mov    $0x0,%eax
f0105cfe:	a3 48 43 5f f0       	mov    %eax,0xf05f4348
f0105d03:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f0105d08:	85 c0                	test   %eax,%eax
f0105d0a:	75 97                	jne    f0105ca3 <sched_kill_env+0x24d>
f0105d0c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d10:	75 91                	jne    f0105ca3 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d12:	83 ec 0c             	sub    $0xc,%esp
f0105d15:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105d1a:	e8 f4 8e 00 00       	call   f010ec13 <release_spinlock>
f0105d1f:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d22:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d26:	74 23                	je     f0105d4b <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105d28:	83 ec 0c             	sub    $0xc,%esp
f0105d2b:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d2e:	e8 90 4e 00 00       	call   f010abc3 <env_free>
f0105d33:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d36:	83 ec 0c             	sub    $0xc,%esp
f0105d39:	68 4e 43 12 f0       	push   $0xf012434e
f0105d3e:	e8 48 b2 ff ff       	call   f0100f8b <cprintf>
f0105d43:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105d46:	e9 a4 00 00 00       	jmp    f0105def <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105d4b:	e8 bb 4e 00 00       	call   f010ac0b <get_cpu_proc>
f0105d50:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105d53:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105d57:	75 19                	jne    f0105d72 <sched_kill_env+0x31c>
f0105d59:	68 c3 42 12 f0       	push   $0xf01242c3
f0105d5e:	68 76 41 12 f0       	push   $0xf0124176
f0105d63:	68 b3 01 00 00       	push   $0x1b3
f0105d68:	68 8b 41 12 f0       	push   $0xf012418b
f0105d6d:	e8 c7 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105d72:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105d75:	8b 40 10             	mov    0x10(%eax),%eax
f0105d78:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d7b:	75 72                	jne    f0105def <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105d7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105d83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d86:	8b 40 18             	mov    0x18(%eax),%eax
f0105d89:	83 f8 02             	cmp    $0x2,%eax
f0105d8c:	74 19                	je     f0105da7 <sched_kill_env+0x351>
f0105d8e:	68 54 43 12 f0       	push   $0xf0124354
f0105d93:	68 76 41 12 f0       	push   $0xf0124176
f0105d98:	68 b8 01 00 00       	push   $0x1b8
f0105d9d:	68 8b 41 12 f0       	push   $0xf012418b
f0105da2:	e8 92 a5 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105da7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105daa:	8d 50 20             	lea    0x20(%eax),%edx
f0105dad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105db0:	8b 40 10             	mov    0x10(%eax),%eax
f0105db3:	83 ec 04             	sub    $0x4,%esp
f0105db6:	52                   	push   %edx
f0105db7:	50                   	push   %eax
f0105db8:	68 78 43 12 f0       	push   $0xf0124378
f0105dbd:	e8 c9 b1 ff ff       	call   f0100f8b <cprintf>
f0105dc2:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105dc5:	83 ec 0c             	sub    $0xc,%esp
f0105dc8:	ff 75 f4             	pushl  -0xc(%ebp)
f0105dcb:	e8 f3 4d 00 00       	call   f010abc3 <env_free>
f0105dd0:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105dd3:	83 ec 0c             	sub    $0xc,%esp
f0105dd6:	68 4e 43 12 f0       	push   $0xf012434e
f0105ddb:	e8 ab b1 ff ff       	call   f0100f8b <cprintf>
f0105de0:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105de3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105dea:	e8 95 4f 00 00       	call   f010ad84 <sched>
		}
	}

}
f0105def:	90                   	nop
f0105df0:	c9                   	leave  
f0105df1:	c3                   	ret    

f0105df2 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105df2:	55                   	push   %ebp
f0105df3:	89 e5                	mov    %esp,%ebp
f0105df5:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105df8:	83 ec 0c             	sub    $0xc,%esp
f0105dfb:	68 c0 42 5f f0       	push   $0xf05f42c0
f0105e00:	e8 87 8d 00 00       	call   f010eb8c <acquire_spinlock>
f0105e05:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e08:	a1 30 43 5f f0       	mov    0xf05f4330,%eax
f0105e0d:	85 c0                	test   %eax,%eax
f0105e0f:	74 69                	je     f0105e7a <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e11:	83 ec 0c             	sub    $0xc,%esp
f0105e14:	68 a4 43 12 f0       	push   $0xf01243a4
f0105e19:	e8 6d b1 ff ff       	call   f0100f8b <cprintf>
f0105e1e:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e21:	a1 30 43 5f f0       	mov    0xf05f4330,%eax
f0105e26:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e29:	eb 26                	jmp    f0105e51 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e2e:	8d 50 20             	lea    0x20(%eax),%edx
f0105e31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e34:	8b 40 10             	mov    0x10(%eax),%eax
f0105e37:	83 ec 04             	sub    $0x4,%esp
f0105e3a:	52                   	push   %edx
f0105e3b:	50                   	push   %eax
f0105e3c:	68 c6 43 12 f0       	push   $0xf01243c6
f0105e41:	e8 45 b1 ff ff       	call   f0100f8b <cprintf>
f0105e46:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e49:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f0105e4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e51:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e55:	74 08                	je     f0105e5f <sched_print_all+0x6d>
f0105e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e5a:	8b 40 08             	mov    0x8(%eax),%eax
f0105e5d:	eb 05                	jmp    f0105e64 <sched_print_all+0x72>
f0105e5f:	b8 00 00 00 00       	mov    $0x0,%eax
f0105e64:	a3 38 43 5f f0       	mov    %eax,0xf05f4338
f0105e69:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f0105e6e:	85 c0                	test   %eax,%eax
f0105e70:	75 b9                	jne    f0105e2b <sched_print_all+0x39>
f0105e72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e76:	75 b3                	jne    f0105e2b <sched_print_all+0x39>
f0105e78:	eb 10                	jmp    f0105e8a <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105e7a:	83 ec 0c             	sub    $0xc,%esp
f0105e7d:	68 d0 43 12 f0       	push   $0xf01243d0
f0105e82:	e8 04 b1 ff ff       	call   f0100f8b <cprintf>
f0105e87:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105e8a:	83 ec 0c             	sub    $0xc,%esp
f0105e8d:	68 ec 43 12 f0       	push   $0xf01243ec
f0105e92:	e8 f4 b0 ff ff       	call   f0100f8b <cprintf>
f0105e97:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105e9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105ea1:	e9 c7 00 00 00       	jmp    f0105f6d <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105ea6:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105eab:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105eae:	c1 e2 04             	shl    $0x4,%edx
f0105eb1:	01 d0                	add    %edx,%eax
f0105eb3:	8b 00                	mov    (%eax),%eax
f0105eb5:	85 c0                	test   %eax,%eax
f0105eb7:	0f 84 8a 00 00 00    	je     f0105f47 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105ebd:	83 ec 08             	sub    $0x8,%esp
f0105ec0:	ff 75 f0             	pushl  -0x10(%ebp)
f0105ec3:	68 20 44 12 f0       	push   $0xf0124420
f0105ec8:	e8 be b0 ff ff       	call   f0100f8b <cprintf>
f0105ecd:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105ed0:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105ed5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105ed8:	c1 e2 04             	shl    $0x4,%edx
f0105edb:	01 d0                	add    %edx,%eax
f0105edd:	8b 00                	mov    (%eax),%eax
f0105edf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ee2:	eb 31                	jmp    f0105f15 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105ee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ee7:	8d 50 20             	lea    0x20(%eax),%edx
f0105eea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105eed:	8b 40 10             	mov    0x10(%eax),%eax
f0105ef0:	83 ec 04             	sub    $0x4,%esp
f0105ef3:	52                   	push   %edx
f0105ef4:	50                   	push   %eax
f0105ef5:	68 c6 43 12 f0       	push   $0xf01243c6
f0105efa:	e8 8c b0 ff ff       	call   f0100f8b <cprintf>
f0105eff:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f02:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105f07:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f0a:	c1 e2 04             	shl    $0x4,%edx
f0105f0d:	01 d0                	add    %edx,%eax
f0105f0f:	8b 40 08             	mov    0x8(%eax),%eax
f0105f12:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f15:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0105f1a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f1d:	c1 e2 04             	shl    $0x4,%edx
f0105f20:	01 d0                	add    %edx,%eax
f0105f22:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f26:	74 08                	je     f0105f30 <sched_print_all+0x13e>
f0105f28:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f2b:	8b 52 08             	mov    0x8(%edx),%edx
f0105f2e:	eb 05                	jmp    f0105f35 <sched_print_all+0x143>
f0105f30:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f35:	89 50 08             	mov    %edx,0x8(%eax)
f0105f38:	8b 40 08             	mov    0x8(%eax),%eax
f0105f3b:	85 c0                	test   %eax,%eax
f0105f3d:	75 a5                	jne    f0105ee4 <sched_print_all+0xf2>
f0105f3f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f43:	75 9f                	jne    f0105ee4 <sched_print_all+0xf2>
f0105f45:	eb 13                	jmp    f0105f5a <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105f47:	83 ec 08             	sub    $0x8,%esp
f0105f4a:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f4d:	68 48 44 12 f0       	push   $0xf0124448
f0105f52:	e8 34 b0 ff ff       	call   f0100f8b <cprintf>
f0105f57:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105f5a:	83 ec 0c             	sub    $0xc,%esp
f0105f5d:	68 ec 43 12 f0       	push   $0xf01243ec
f0105f62:	e8 24 b0 ff ff       	call   f0100f8b <cprintf>
f0105f67:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105f6a:	ff 45 f0             	incl   -0x10(%ebp)
f0105f6d:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f0105f72:	0f b6 c0             	movzbl %al,%eax
f0105f75:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105f78:	0f 8f 28 ff ff ff    	jg     f0105ea6 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105f7e:	a1 40 43 5f f0       	mov    0xf05f4340,%eax
f0105f83:	85 c0                	test   %eax,%eax
f0105f85:	74 69                	je     f0105ff0 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105f87:	83 ec 0c             	sub    $0xc,%esp
f0105f8a:	68 6c 44 12 f0       	push   $0xf012446c
f0105f8f:	e8 f7 af ff ff       	call   f0100f8b <cprintf>
f0105f94:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105f97:	a1 40 43 5f f0       	mov    0xf05f4340,%eax
f0105f9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f9f:	eb 26                	jmp    f0105fc7 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105fa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fa4:	8d 50 20             	lea    0x20(%eax),%edx
f0105fa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105faa:	8b 40 10             	mov    0x10(%eax),%eax
f0105fad:	83 ec 04             	sub    $0x4,%esp
f0105fb0:	52                   	push   %edx
f0105fb1:	50                   	push   %eax
f0105fb2:	68 c6 43 12 f0       	push   $0xf01243c6
f0105fb7:	e8 cf af ff ff       	call   f0100f8b <cprintf>
f0105fbc:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105fbf:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f0105fc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fc7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fcb:	74 08                	je     f0105fd5 <sched_print_all+0x1e3>
f0105fcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fd0:	8b 40 08             	mov    0x8(%eax),%eax
f0105fd3:	eb 05                	jmp    f0105fda <sched_print_all+0x1e8>
f0105fd5:	b8 00 00 00 00       	mov    $0x0,%eax
f0105fda:	a3 48 43 5f f0       	mov    %eax,0xf05f4348
f0105fdf:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f0105fe4:	85 c0                	test   %eax,%eax
f0105fe6:	75 b9                	jne    f0105fa1 <sched_print_all+0x1af>
f0105fe8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fec:	75 b3                	jne    f0105fa1 <sched_print_all+0x1af>
f0105fee:	eb 10                	jmp    f0106000 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0105ff0:	83 ec 0c             	sub    $0xc,%esp
f0105ff3:	68 8e 44 12 f0       	push   $0xf012448e
f0105ff8:	e8 8e af ff ff       	call   f0100f8b <cprintf>
f0105ffd:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106000:	83 ec 0c             	sub    $0xc,%esp
f0106003:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106008:	e8 06 8c 00 00       	call   f010ec13 <release_spinlock>
f010600d:	83 c4 10             	add    $0x10,%esp
}
f0106010:	90                   	nop
f0106011:	c9                   	leave  
f0106012:	c3                   	ret    

f0106013 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106013:	55                   	push   %ebp
f0106014:	89 e5                	mov    %esp,%ebp
f0106016:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106019:	83 ec 0c             	sub    $0xc,%esp
f010601c:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106021:	e8 66 8b 00 00       	call   f010eb8c <acquire_spinlock>
f0106026:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106029:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106030:	a1 3c 43 5f f0       	mov    0xf05f433c,%eax
f0106035:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f0106038:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010603f:	eb 24                	jmp    f0106065 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0106041:	83 ec 0c             	sub    $0xc,%esp
f0106044:	68 30 43 5f f0       	push   $0xf05f4330
f0106049:	e8 8b ef ff ff       	call   f0104fd9 <dequeue>
f010604e:	83 c4 10             	add    $0x10,%esp
f0106051:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f0106054:	83 ec 0c             	sub    $0xc,%esp
f0106057:	ff 75 f0             	pushl  -0x10(%ebp)
f010605a:	e8 b5 f1 ff ff       	call   f0105214 <sched_insert_ready0>
f010605f:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0106062:	ff 45 f4             	incl   -0xc(%ebp)
f0106065:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106068:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010606b:	7c d4                	jl     f0106041 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010606d:	83 ec 0c             	sub    $0xc,%esp
f0106070:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106075:	e8 99 8b 00 00       	call   f010ec13 <release_spinlock>
f010607a:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f010607d:	e8 1f 10 00 00       	call   f01070a1 <mycpu>
f0106082:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0106088:	85 c0                	test   %eax,%eax
f010608a:	75 05                	jne    f0106091 <sched_run_all+0x7e>
		fos_scheduler();
f010608c:	e8 9e 06 00 00       	call   f010672f <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f0106091:	83 ec 04             	sub    $0x4,%esp
f0106094:	68 ac 44 12 f0       	push   $0xf01244ac
f0106099:	68 15 02 00 00       	push   $0x215
f010609e:	68 8b 41 12 f0       	push   $0xf012418b
f01060a3:	e8 91 a2 ff ff       	call   f0100339 <_panic>

f01060a8 <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f01060a8:	55                   	push   %ebp
f01060a9:	89 e5                	mov    %esp,%ebp
f01060ab:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060ae:	83 ec 0c             	sub    $0xc,%esp
f01060b1:	68 c0 42 5f f0       	push   $0xf05f42c0
f01060b6:	e8 d1 8a 00 00       	call   f010eb8c <acquire_spinlock>
f01060bb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01060be:	a1 30 43 5f f0       	mov    0xf05f4330,%eax
f01060c3:	85 c0                	test   %eax,%eax
f01060c5:	0f 84 95 00 00 00    	je     f0106160 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f01060cb:	83 ec 0c             	sub    $0xc,%esp
f01060ce:	68 e8 44 12 f0       	push   $0xf01244e8
f01060d3:	e8 b3 ae ff ff       	call   f0100f8b <cprintf>
f01060d8:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01060db:	a1 30 43 5f f0       	mov    0xf05f4330,%eax
f01060e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01060e3:	eb 52                	jmp    f0106137 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01060e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060e8:	8d 50 20             	lea    0x20(%eax),%edx
f01060eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ee:	8b 40 10             	mov    0x10(%eax),%eax
f01060f1:	83 ec 04             	sub    $0x4,%esp
f01060f4:	52                   	push   %edx
f01060f5:	50                   	push   %eax
f01060f6:	68 14 45 12 f0       	push   $0xf0124514
f01060fb:	e8 8b ae ff ff       	call   f0100f8b <cprintf>
f0106100:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106103:	83 ec 0c             	sub    $0xc,%esp
f0106106:	ff 75 f4             	pushl  -0xc(%ebp)
f0106109:	e8 45 f3 ff ff       	call   f0105453 <sched_remove_new>
f010610e:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106111:	83 ec 0c             	sub    $0xc,%esp
f0106114:	ff 75 f4             	pushl  -0xc(%ebp)
f0106117:	e8 a7 4a 00 00       	call   f010abc3 <env_free>
f010611c:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f010611f:	83 ec 0c             	sub    $0xc,%esp
f0106122:	68 4e 43 12 f0       	push   $0xf012434e
f0106127:	e8 5f ae ff ff       	call   f0100f8b <cprintf>
f010612c:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010612f:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f0106134:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106137:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010613b:	74 08                	je     f0106145 <sched_kill_all+0x9d>
f010613d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106140:	8b 40 08             	mov    0x8(%eax),%eax
f0106143:	eb 05                	jmp    f010614a <sched_kill_all+0xa2>
f0106145:	b8 00 00 00 00       	mov    $0x0,%eax
f010614a:	a3 38 43 5f f0       	mov    %eax,0xf05f4338
f010614f:	a1 38 43 5f f0       	mov    0xf05f4338,%eax
f0106154:	85 c0                	test   %eax,%eax
f0106156:	75 8d                	jne    f01060e5 <sched_kill_all+0x3d>
f0106158:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010615c:	75 87                	jne    f01060e5 <sched_kill_all+0x3d>
f010615e:	eb 10                	jmp    f0106170 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0106160:	83 ec 0c             	sub    $0xc,%esp
f0106163:	68 27 45 12 f0       	push   $0xf0124527
f0106168:	e8 1e ae ff ff       	call   f0100f8b <cprintf>
f010616d:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106170:	83 ec 0c             	sub    $0xc,%esp
f0106173:	68 ec 43 12 f0       	push   $0xf01243ec
f0106178:	e8 0e ae ff ff       	call   f0100f8b <cprintf>
f010617d:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106180:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106187:	e9 96 01 00 00       	jmp    f0106322 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010618c:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0106191:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106194:	c1 e2 04             	shl    $0x4,%edx
f0106197:	01 d0                	add    %edx,%eax
f0106199:	8b 00                	mov    (%eax),%eax
f010619b:	85 c0                	test   %eax,%eax
f010619d:	0f 84 59 01 00 00    	je     f01062fc <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f01061a3:	83 ec 08             	sub    $0x8,%esp
f01061a6:	ff 75 f0             	pushl  -0x10(%ebp)
f01061a9:	68 44 45 12 f0       	push   $0xf0124544
f01061ae:	e8 d8 ad ff ff       	call   f0100f8b <cprintf>
f01061b3:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01061b6:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01061bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061be:	c1 e2 04             	shl    $0x4,%edx
f01061c1:	01 d0                	add    %edx,%eax
f01061c3:	8b 00                	mov    (%eax),%eax
f01061c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061c8:	e9 f5 00 00 00       	jmp    f01062c2 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01061cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061d0:	8d 50 20             	lea    0x20(%eax),%edx
f01061d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061d6:	8b 40 10             	mov    0x10(%eax),%eax
f01061d9:	83 ec 04             	sub    $0x4,%esp
f01061dc:	52                   	push   %edx
f01061dd:	50                   	push   %eax
f01061de:	68 14 45 12 f0       	push   $0xf0124514
f01061e3:	e8 a3 ad ff ff       	call   f0100f8b <cprintf>
f01061e8:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01061eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061ef:	75 17                	jne    f0106208 <sched_kill_all+0x160>
f01061f1:	83 ec 04             	sub    $0x4,%esp
f01061f4:	68 c7 41 12 f0       	push   $0xf01241c7
f01061f9:	68 37 02 00 00       	push   $0x237
f01061fe:	68 8b 41 12 f0       	push   $0xf012418b
f0106203:	e8 31 a1 ff ff       	call   f0100339 <_panic>
f0106208:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010620b:	8b 40 08             	mov    0x8(%eax),%eax
f010620e:	85 c0                	test   %eax,%eax
f0106210:	74 11                	je     f0106223 <sched_kill_all+0x17b>
f0106212:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106215:	8b 40 08             	mov    0x8(%eax),%eax
f0106218:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010621b:	8b 52 0c             	mov    0xc(%edx),%edx
f010621e:	89 50 0c             	mov    %edx,0xc(%eax)
f0106221:	eb 16                	jmp    f0106239 <sched_kill_all+0x191>
f0106223:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0106228:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010622b:	c1 e2 04             	shl    $0x4,%edx
f010622e:	01 c2                	add    %eax,%edx
f0106230:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106233:	8b 40 0c             	mov    0xc(%eax),%eax
f0106236:	89 42 04             	mov    %eax,0x4(%edx)
f0106239:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010623c:	8b 40 0c             	mov    0xc(%eax),%eax
f010623f:	85 c0                	test   %eax,%eax
f0106241:	74 11                	je     f0106254 <sched_kill_all+0x1ac>
f0106243:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106246:	8b 40 0c             	mov    0xc(%eax),%eax
f0106249:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010624c:	8b 52 08             	mov    0x8(%edx),%edx
f010624f:	89 50 08             	mov    %edx,0x8(%eax)
f0106252:	eb 15                	jmp    f0106269 <sched_kill_all+0x1c1>
f0106254:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0106259:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010625c:	c1 e2 04             	shl    $0x4,%edx
f010625f:	01 c2                	add    %eax,%edx
f0106261:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106264:	8b 40 08             	mov    0x8(%eax),%eax
f0106267:	89 02                	mov    %eax,(%edx)
f0106269:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106273:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106276:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010627d:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0106282:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106285:	c1 e2 04             	shl    $0x4,%edx
f0106288:	01 d0                	add    %edx,%eax
f010628a:	8b 50 0c             	mov    0xc(%eax),%edx
f010628d:	4a                   	dec    %edx
f010628e:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f0106291:	83 ec 0c             	sub    $0xc,%esp
f0106294:	ff 75 f4             	pushl  -0xc(%ebp)
f0106297:	e8 27 49 00 00       	call   f010abc3 <env_free>
f010629c:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f010629f:	83 ec 0c             	sub    $0xc,%esp
f01062a2:	68 4e 43 12 f0       	push   $0xf012434e
f01062a7:	e8 df ac ff ff       	call   f0100f8b <cprintf>
f01062ac:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01062af:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01062b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062b7:	c1 e2 04             	shl    $0x4,%edx
f01062ba:	01 d0                	add    %edx,%eax
f01062bc:	8b 40 08             	mov    0x8(%eax),%eax
f01062bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01062c2:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01062c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062ca:	c1 e2 04             	shl    $0x4,%edx
f01062cd:	01 d0                	add    %edx,%eax
f01062cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062d3:	74 08                	je     f01062dd <sched_kill_all+0x235>
f01062d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062d8:	8b 52 08             	mov    0x8(%edx),%edx
f01062db:	eb 05                	jmp    f01062e2 <sched_kill_all+0x23a>
f01062dd:	ba 00 00 00 00       	mov    $0x0,%edx
f01062e2:	89 50 08             	mov    %edx,0x8(%eax)
f01062e5:	8b 40 08             	mov    0x8(%eax),%eax
f01062e8:	85 c0                	test   %eax,%eax
f01062ea:	0f 85 dd fe ff ff    	jne    f01061cd <sched_kill_all+0x125>
f01062f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062f4:	0f 85 d3 fe ff ff    	jne    f01061cd <sched_kill_all+0x125>
f01062fa:	eb 13                	jmp    f010630f <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01062fc:	83 ec 08             	sub    $0x8,%esp
f01062ff:	ff 75 f0             	pushl  -0x10(%ebp)
f0106302:	68 48 44 12 f0       	push   $0xf0124448
f0106307:	e8 7f ac ff ff       	call   f0100f8b <cprintf>
f010630c:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f010630f:	83 ec 0c             	sub    $0xc,%esp
f0106312:	68 ec 43 12 f0       	push   $0xf01243ec
f0106317:	e8 6f ac ff ff       	call   f0100f8b <cprintf>
f010631c:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010631f:	ff 45 f0             	incl   -0x10(%ebp)
f0106322:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f0106327:	0f b6 c0             	movzbl %al,%eax
f010632a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010632d:	0f 8f 59 fe ff ff    	jg     f010618c <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106333:	a1 40 43 5f f0       	mov    0xf05f4340,%eax
f0106338:	85 c0                	test   %eax,%eax
f010633a:	0f 84 95 00 00 00    	je     f01063d5 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f0106340:	83 ec 0c             	sub    $0xc,%esp
f0106343:	68 78 45 12 f0       	push   $0xf0124578
f0106348:	e8 3e ac ff ff       	call   f0100f8b <cprintf>
f010634d:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106350:	a1 40 43 5f f0       	mov    0xf05f4340,%eax
f0106355:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106358:	eb 52                	jmp    f01063ac <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010635a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010635d:	8d 50 20             	lea    0x20(%eax),%edx
f0106360:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106363:	8b 40 10             	mov    0x10(%eax),%eax
f0106366:	83 ec 04             	sub    $0x4,%esp
f0106369:	52                   	push   %edx
f010636a:	50                   	push   %eax
f010636b:	68 14 45 12 f0       	push   $0xf0124514
f0106370:	e8 16 ac ff ff       	call   f0100f8b <cprintf>
f0106375:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f0106378:	83 ec 0c             	sub    $0xc,%esp
f010637b:	ff 75 f4             	pushl  -0xc(%ebp)
f010637e:	e8 47 f2 ff ff       	call   f01055ca <sched_remove_exit>
f0106383:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106386:	83 ec 0c             	sub    $0xc,%esp
f0106389:	ff 75 f4             	pushl  -0xc(%ebp)
f010638c:	e8 32 48 00 00       	call   f010abc3 <env_free>
f0106391:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106394:	83 ec 0c             	sub    $0xc,%esp
f0106397:	68 4e 43 12 f0       	push   $0xf012434e
f010639c:	e8 ea ab ff ff       	call   f0100f8b <cprintf>
f01063a1:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063a4:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f01063a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01063b0:	74 08                	je     f01063ba <sched_kill_all+0x312>
f01063b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063b5:	8b 40 08             	mov    0x8(%eax),%eax
f01063b8:	eb 05                	jmp    f01063bf <sched_kill_all+0x317>
f01063ba:	b8 00 00 00 00       	mov    $0x0,%eax
f01063bf:	a3 48 43 5f f0       	mov    %eax,0xf05f4348
f01063c4:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f01063c9:	85 c0                	test   %eax,%eax
f01063cb:	75 8d                	jne    f010635a <sched_kill_all+0x2b2>
f01063cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01063d1:	75 87                	jne    f010635a <sched_kill_all+0x2b2>
f01063d3:	eb 10                	jmp    f01063e5 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01063d5:	83 ec 0c             	sub    $0xc,%esp
f01063d8:	68 8e 44 12 f0       	push   $0xf012448e
f01063dd:	e8 a9 ab ff ff       	call   f0100f8b <cprintf>
f01063e2:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01063e5:	e8 21 48 00 00       	call   f010ac0b <get_cpu_proc>
f01063ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01063ed:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01063f1:	74 6b                	je     f010645e <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01063f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01063f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01063f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063fc:	8b 40 18             	mov    0x18(%eax),%eax
f01063ff:	83 f8 02             	cmp    $0x2,%eax
f0106402:	74 19                	je     f010641d <sched_kill_all+0x375>
f0106404:	68 54 43 12 f0       	push   $0xf0124354
f0106409:	68 76 41 12 f0       	push   $0xf0124176
f010640e:	68 57 02 00 00       	push   $0x257
f0106413:	68 8b 41 12 f0       	push   $0xf012418b
f0106418:	e8 1c 9f ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010641d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106420:	8d 50 20             	lea    0x20(%eax),%edx
f0106423:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106426:	8b 40 10             	mov    0x10(%eax),%eax
f0106429:	83 ec 04             	sub    $0x4,%esp
f010642c:	52                   	push   %edx
f010642d:	50                   	push   %eax
f010642e:	68 78 43 12 f0       	push   $0xf0124378
f0106433:	e8 53 ab ff ff       	call   f0100f8b <cprintf>
f0106438:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010643b:	83 ec 0c             	sub    $0xc,%esp
f010643e:	ff 75 f4             	pushl  -0xc(%ebp)
f0106441:	e8 7d 47 00 00       	call   f010abc3 <env_free>
f0106446:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0106449:	83 ec 0c             	sub    $0xc,%esp
f010644c:	68 4e 43 12 f0       	push   $0xf012434e
f0106451:	e8 35 ab ff ff       	call   f0100f8b <cprintf>
f0106456:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f0106459:	e8 26 49 00 00       	call   f010ad84 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010645e:	83 ec 0c             	sub    $0xc,%esp
f0106461:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106466:	e8 a8 87 00 00       	call   f010ec13 <release_spinlock>
f010646b:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f010646e:	e8 4f b9 ff ff       	call   f0101dc2 <get_into_prompt>

f0106473 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0106473:	55                   	push   %ebp
f0106474:	89 e5                	mov    %esp,%ebp
f0106476:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106479:	83 ec 0c             	sub    $0xc,%esp
f010647c:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106481:	e8 06 87 00 00       	call   f010eb8c <acquire_spinlock>
f0106486:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106489:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106490:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106497:	e9 37 01 00 00       	jmp    f01065d3 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010649c:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01064a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01064a4:	c1 e2 04             	shl    $0x4,%edx
f01064a7:	01 d0                	add    %edx,%eax
f01064a9:	8b 00                	mov    (%eax),%eax
f01064ab:	85 c0                	test   %eax,%eax
f01064ad:	0f 84 1d 01 00 00    	je     f01065d0 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f01064b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01064ba:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01064bf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01064c2:	c1 e2 04             	shl    $0x4,%edx
f01064c5:	01 d0                	add    %edx,%eax
f01064c7:	8b 00                	mov    (%eax),%eax
f01064c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01064cc:	e9 c7 00 00 00       	jmp    f0106598 <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01064d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01064d5:	75 17                	jne    f01064ee <sched_exit_all_ready_envs+0x7b>
f01064d7:	83 ec 04             	sub    $0x4,%esp
f01064da:	68 c7 41 12 f0       	push   $0xf01241c7
f01064df:	68 79 02 00 00       	push   $0x279
f01064e4:	68 8b 41 12 f0       	push   $0xf012418b
f01064e9:	e8 4b 9e ff ff       	call   f0100339 <_panic>
f01064ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064f1:	8b 40 08             	mov    0x8(%eax),%eax
f01064f4:	85 c0                	test   %eax,%eax
f01064f6:	74 11                	je     f0106509 <sched_exit_all_ready_envs+0x96>
f01064f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064fb:	8b 40 08             	mov    0x8(%eax),%eax
f01064fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106501:	8b 52 0c             	mov    0xc(%edx),%edx
f0106504:	89 50 0c             	mov    %edx,0xc(%eax)
f0106507:	eb 16                	jmp    f010651f <sched_exit_all_ready_envs+0xac>
f0106509:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f010650e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106511:	c1 e2 04             	shl    $0x4,%edx
f0106514:	01 c2                	add    %eax,%edx
f0106516:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106519:	8b 40 0c             	mov    0xc(%eax),%eax
f010651c:	89 42 04             	mov    %eax,0x4(%edx)
f010651f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106522:	8b 40 0c             	mov    0xc(%eax),%eax
f0106525:	85 c0                	test   %eax,%eax
f0106527:	74 11                	je     f010653a <sched_exit_all_ready_envs+0xc7>
f0106529:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010652c:	8b 40 0c             	mov    0xc(%eax),%eax
f010652f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106532:	8b 52 08             	mov    0x8(%edx),%edx
f0106535:	89 50 08             	mov    %edx,0x8(%eax)
f0106538:	eb 15                	jmp    f010654f <sched_exit_all_ready_envs+0xdc>
f010653a:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f010653f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106542:	c1 e2 04             	shl    $0x4,%edx
f0106545:	01 c2                	add    %eax,%edx
f0106547:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010654a:	8b 40 08             	mov    0x8(%eax),%eax
f010654d:	89 02                	mov    %eax,(%edx)
f010654f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106552:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106559:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106563:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0106568:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010656b:	c1 e2 04             	shl    $0x4,%edx
f010656e:	01 d0                	add    %edx,%eax
f0106570:	8b 50 0c             	mov    0xc(%eax),%edx
f0106573:	4a                   	dec    %edx
f0106574:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f0106577:	83 ec 0c             	sub    $0xc,%esp
f010657a:	ff 75 f4             	pushl  -0xc(%ebp)
f010657d:	e8 c1 ef ff ff       	call   f0105543 <sched_insert_exit>
f0106582:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106585:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f010658a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010658d:	c1 e2 04             	shl    $0x4,%edx
f0106590:	01 d0                	add    %edx,%eax
f0106592:	8b 40 08             	mov    0x8(%eax),%eax
f0106595:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106598:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f010659d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a0:	c1 e2 04             	shl    $0x4,%edx
f01065a3:	01 d0                	add    %edx,%eax
f01065a5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065a9:	74 08                	je     f01065b3 <sched_exit_all_ready_envs+0x140>
f01065ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01065ae:	8b 52 08             	mov    0x8(%edx),%edx
f01065b1:	eb 05                	jmp    f01065b8 <sched_exit_all_ready_envs+0x145>
f01065b3:	ba 00 00 00 00       	mov    $0x0,%edx
f01065b8:	89 50 08             	mov    %edx,0x8(%eax)
f01065bb:	8b 40 08             	mov    0x8(%eax),%eax
f01065be:	85 c0                	test   %eax,%eax
f01065c0:	0f 85 0b ff ff ff    	jne    f01064d1 <sched_exit_all_ready_envs+0x5e>
f01065c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065ca:	0f 85 01 ff ff ff    	jne    f01064d1 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01065d0:	ff 45 f0             	incl   -0x10(%ebp)
f01065d3:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f01065d8:	0f b6 c0             	movzbl %al,%eax
f01065db:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01065de:	0f 8f b8 fe ff ff    	jg     f010649c <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01065e4:	83 ec 0c             	sub    $0xc,%esp
f01065e7:	68 c0 42 5f f0       	push   $0xf05f42c0
f01065ec:	e8 22 86 00 00       	call   f010ec13 <release_spinlock>
f01065f1:	83 c4 10             	add    $0x10,%esp
}
f01065f4:	90                   	nop
f01065f5:	c9                   	leave  
f01065f6:	c3                   	ret    

f01065f7 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01065f7:	55                   	push   %ebp
f01065f8:	89 e5                	mov    %esp,%ebp
	return ticks;
f01065fa:	a1 68 49 5f f0       	mov    0xf05f4968,%eax
f01065ff:	8b 15 6c 49 5f f0    	mov    0xf05f496c,%edx
}
f0106605:	5d                   	pop    %ebp
f0106606:	c3                   	ret    

f0106607 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f0106607:	55                   	push   %ebp
f0106608:	89 e5                	mov    %esp,%ebp
f010660a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010660d:	83 ec 04             	sub    $0x4,%esp
f0106610:	68 a4 45 12 f0       	push   $0xf01245a4
f0106615:	68 8c 02 00 00       	push   $0x28c
f010661a:	68 8b 41 12 f0       	push   $0xf012418b
f010661f:	e8 15 9d ff ff       	call   f0100339 <_panic>

f0106624 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106624:	55                   	push   %ebp
f0106625:	89 e5                	mov    %esp,%ebp
f0106627:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010662a:	83 ec 04             	sub    $0x4,%esp
f010662d:	68 a4 45 12 f0       	push   $0xf01245a4
f0106632:	68 94 02 00 00       	push   $0x294
f0106637:	68 8b 41 12 f0       	push   $0xf012418b
f010663c:	e8 f8 9c ff ff       	call   f0100339 <_panic>

f0106641 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f0106641:	55                   	push   %ebp
f0106642:	89 e5                	mov    %esp,%ebp
f0106644:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106647:	83 ec 04             	sub    $0x4,%esp
f010664a:	68 a4 45 12 f0       	push   $0xf01245a4
f010664f:	68 9c 02 00 00       	push   $0x29c
f0106654:	68 8b 41 12 f0       	push   $0xf012418b
f0106659:	e8 db 9c ff ff       	call   f0100339 <_panic>

f010665e <get_load_average>:
}
int get_load_average()
{
f010665e:	55                   	push   %ebp
f010665f:	89 e5                	mov    %esp,%ebp
f0106661:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106664:	83 ec 04             	sub    $0x4,%esp
f0106667:	68 a4 45 12 f0       	push   $0xf01245a4
f010666c:	68 a4 02 00 00       	push   $0x2a4
f0106671:	68 8b 41 12 f0       	push   $0xf012418b
f0106676:	e8 be 9c ff ff       	call   f0100339 <_panic>

f010667b <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f010667b:	55                   	push   %ebp
f010667c:	89 e5                	mov    %esp,%ebp
f010667e:	a1 b4 47 5f f0       	mov    0xf05f47b4,%eax
f0106683:	85 c0                	test   %eax,%eax
f0106685:	75 07                	jne    f010668e <isSchedMethodRR+0x13>
f0106687:	b8 01 00 00 00       	mov    $0x1,%eax
f010668c:	eb 05                	jmp    f0106693 <isSchedMethodRR+0x18>
f010668e:	b8 00 00 00 00       	mov    $0x0,%eax
f0106693:	5d                   	pop    %ebp
f0106694:	c3                   	ret    

f0106695 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f0106695:	55                   	push   %ebp
f0106696:	89 e5                	mov    %esp,%ebp
f0106698:	a1 b4 47 5f f0       	mov    0xf05f47b4,%eax
f010669d:	83 f8 01             	cmp    $0x1,%eax
f01066a0:	75 07                	jne    f01066a9 <isSchedMethodMLFQ+0x14>
f01066a2:	b8 01 00 00 00       	mov    $0x1,%eax
f01066a7:	eb 05                	jmp    f01066ae <isSchedMethodMLFQ+0x19>
f01066a9:	b8 00 00 00 00       	mov    $0x0,%eax
f01066ae:	5d                   	pop    %ebp
f01066af:	c3                   	ret    

f01066b0 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f01066b0:	55                   	push   %ebp
f01066b1:	89 e5                	mov    %esp,%ebp
f01066b3:	a1 b4 47 5f f0       	mov    0xf05f47b4,%eax
f01066b8:	83 f8 02             	cmp    $0x2,%eax
f01066bb:	75 07                	jne    f01066c4 <isSchedMethodBSD+0x14>
f01066bd:	b8 01 00 00 00       	mov    $0x1,%eax
f01066c2:	eb 05                	jmp    f01066c9 <isSchedMethodBSD+0x19>
f01066c4:	b8 00 00 00 00       	mov    $0x0,%eax
f01066c9:	5d                   	pop    %ebp
f01066ca:	c3                   	ret    

f01066cb <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f01066cb:	55                   	push   %ebp
f01066cc:	89 e5                	mov    %esp,%ebp
f01066ce:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f01066d1:	c7 05 98 44 5f f0 00 	movl   $0x0,0xf05f4498
f01066d8:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f01066db:	83 ec 0c             	sub    $0xc,%esp
f01066de:	6a 0a                	push   $0xa
f01066e0:	e8 57 02 00 00       	call   f010693c <sched_init_RR>
f01066e5:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f01066e8:	83 ec 0c             	sub    $0xc,%esp
f01066eb:	68 30 43 5f f0       	push   $0xf05f4330
f01066f0:	e8 12 e8 ff ff       	call   f0104f07 <init_queue>
f01066f5:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f01066f8:	83 ec 0c             	sub    $0xc,%esp
f01066fb:	68 40 43 5f f0       	push   $0xf05f4340
f0106700:	e8 02 e8 ff ff       	call   f0104f07 <init_queue>
f0106705:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0106708:	e8 94 09 00 00       	call   f01070a1 <mycpu>
f010670d:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106714:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106717:	83 ec 08             	sub    $0x8,%esp
f010671a:	68 b8 45 12 f0       	push   $0xf01245b8
f010671f:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106724:	e8 32 84 00 00       	call   f010eb5b <init_spinlock>
f0106729:	83 c4 10             	add    $0x10,%esp
}
f010672c:	90                   	nop
f010672d:	c9                   	leave  
f010672e:	c3                   	ret    

f010672f <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f010672f:	55                   	push   %ebp
f0106730:	89 e5                	mov    %esp,%ebp
f0106732:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106735:	9c                   	pushf  
f0106736:	58                   	pop    %eax
f0106737:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f010673a:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f010673d:	25 00 02 00 00       	and    $0x200,%eax
f0106742:	85 c0                	test   %eax,%eax
f0106744:	74 14                	je     f010675a <fos_scheduler+0x2b>
		panic("fos_scheduler: called while the interrupt is enabled!");
f0106746:	83 ec 04             	sub    $0x4,%esp
f0106749:	68 cc 45 12 f0       	push   $0xf01245cc
f010674e:	6a 37                	push   $0x37
f0106750:	68 02 46 12 f0       	push   $0xf0124602
f0106755:	e8 df 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f010675a:	e8 42 09 00 00       	call   f01070a1 <mycpu>
f010675f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f0106762:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106765:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010676c:	00 00 00 

	chk1();
f010676f:	e8 95 75 01 00       	call   f011dd09 <chk1>
	c->scheduler_status = SCH_STARTED;
f0106774:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106777:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f010677e:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106781:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f0106788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010678f:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106790:	83 ec 0c             	sub    $0xc,%esp
f0106793:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106798:	e8 ef 83 00 00       	call   f010eb8c <acquire_spinlock>
f010679d:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f01067a0:	a1 b4 47 5f f0       	mov    0xf05f47b4,%eax
f01067a5:	8b 04 85 4c c9 17 f0 	mov    -0xfe836b4(,%eax,4),%eax
f01067ac:	ff d0                	call   *%eax
f01067ae:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f01067b1:	e8 55 44 00 00       	call   f010ac0b <get_cpu_proc>
f01067b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f01067b9:	83 ec 0c             	sub    $0xc,%esp
f01067bc:	ff 75 e8             	pushl  -0x18(%ebp)
f01067bf:	e8 70 44 00 00       	call   f010ac34 <set_cpu_proc>
f01067c4:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f01067c7:	83 ec 0c             	sub    $0xc,%esp
f01067ca:	ff 75 e8             	pushl  -0x18(%ebp)
f01067cd:	e8 3d 75 01 00       	call   f011dd0f <chk2>
f01067d2:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f01067d5:	83 ec 0c             	sub    $0xc,%esp
f01067d8:	ff 75 e0             	pushl  -0x20(%ebp)
f01067db:	e8 54 44 00 00       	call   f010ac34 <set_cpu_proc>
f01067e0:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f01067e3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01067e7:	0f 84 d6 00 00 00    	je     f01068c3 <fos_scheduler+0x194>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f01067ed:	83 ec 0c             	sub    $0xc,%esp
f01067f0:	ff 75 e8             	pushl  -0x18(%ebp)
f01067f3:	e8 3c 44 00 00       	call   f010ac34 <set_cpu_proc>
f01067f8:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f01067fb:	83 ec 0c             	sub    $0xc,%esp
f01067fe:	ff 75 e8             	pushl  -0x18(%ebp)
f0106801:	e8 a1 46 00 00       	call   f010aea7 <switchuvm>
f0106806:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f0106809:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010680c:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106813:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106816:	8b 40 04             	mov    0x4(%eax),%eax
f0106819:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010681c:	83 c2 04             	add    $0x4,%edx
f010681f:	83 ec 08             	sub    $0x8,%esp
f0106822:	50                   	push   %eax
f0106823:	52                   	push   %edx
f0106824:	e8 e6 e2 ff ff       	call   f0104b0f <context_switch>
f0106829:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010682c:	9c                   	pushf  
f010682d:	58                   	pop    %eax
f010682e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106831:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106834:	25 00 02 00 00       	and    $0x200,%eax
f0106839:	85 c0                	test   %eax,%eax
f010683b:	74 14                	je     f0106851 <fos_scheduler+0x122>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f010683d:	83 ec 04             	sub    $0x4,%esp
f0106840:	68 14 46 12 f0       	push   $0xf0124614
f0106845:	6a 74                	push   $0x74
f0106847:	68 02 46 12 f0       	push   $0xf0124602
f010684c:	e8 e8 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f0106851:	e8 02 e4 ff ff       	call   f0104c58 <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f0106856:	e8 b0 43 00 00       	call   f010ac0b <get_cpu_proc>
f010685b:	89 c2                	mov    %eax,%edx
f010685d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106860:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106866:	39 c2                	cmp    %eax,%edx
f0106868:	74 16                	je     f0106880 <fos_scheduler+0x151>
f010686a:	68 4b 46 12 f0       	push   $0xf012464b
f010686f:	68 65 46 12 f0       	push   $0xf0124665
f0106874:	6a 7d                	push   $0x7d
f0106876:	68 02 46 12 f0       	push   $0xf0124602
f010687b:	e8 b9 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f0106880:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106883:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106889:	8b 40 18             	mov    0x18(%eax),%eax
f010688c:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f010688f:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106893:	75 16                	jne    f01068ab <fos_scheduler+0x17c>
f0106895:	68 7a 46 12 f0       	push   $0xf012467a
f010689a:	68 65 46 12 f0       	push   $0xf0124665
f010689f:	6a 7f                	push   $0x7f
f01068a1:	68 02 46 12 f0       	push   $0xf0124602
f01068a6:	e8 8e 9a ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f01068ab:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f01068af:	74 12                	je     f01068c3 <fos_scheduler+0x194>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f01068b1:	e8 da 45 00 00       	call   f010ae90 <switchkvm>
					set_cpu_proc(NULL);
f01068b6:	83 ec 0c             	sub    $0xc,%esp
f01068b9:	6a 00                	push   $0x0
f01068bb:	e8 74 43 00 00       	call   f010ac34 <set_cpu_proc>
f01068c0:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f01068c3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01068c7:	0f 85 d3 fe ff ff    	jne    f01067a0 <fos_scheduler+0x71>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f01068cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f01068d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01068db:	eb 36                	jmp    f0106913 <fos_scheduler+0x1e4>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f01068dd:	8b 0d d0 b7 5c f0    	mov    0xf05cb7d0,%ecx
f01068e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01068e6:	89 d0                	mov    %edx,%eax
f01068e8:	c1 e0 02             	shl    $0x2,%eax
f01068eb:	01 d0                	add    %edx,%eax
f01068ed:	01 c0                	add    %eax,%eax
f01068ef:	01 d0                	add    %edx,%eax
f01068f1:	c1 e0 02             	shl    $0x2,%eax
f01068f4:	01 d0                	add    %edx,%eax
f01068f6:	01 c0                	add    %eax,%eax
f01068f8:	01 d0                	add    %edx,%eax
f01068fa:	c1 e0 04             	shl    $0x4,%eax
f01068fd:	01 c8                	add    %ecx,%eax
f01068ff:	8b 40 18             	mov    0x18(%eax),%eax
f0106902:	83 f8 03             	cmp    $0x3,%eax
f0106905:	75 09                	jne    f0106910 <fos_scheduler+0x1e1>
			{
				is_any_blocked = 1;
f0106907:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010690e:	eb 0d                	jmp    f010691d <fos_scheduler+0x1ee>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0106910:	ff 45 f0             	incl   -0x10(%ebp)
f0106913:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106916:	3d cf 02 00 00       	cmp    $0x2cf,%eax
f010691b:	76 c0                	jbe    f01068dd <fos_scheduler+0x1ae>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f010691d:	83 ec 0c             	sub    $0xc,%esp
f0106920:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106925:	e8 e9 82 00 00       	call   f010ec13 <release_spinlock>
f010692a:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f010692d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106931:	0f 8f 58 fe ff ff    	jg     f010678f <fos_scheduler+0x60>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f0106937:	e8 86 b4 ff ff       	call   f0101dc2 <get_into_prompt>

f010693c <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f010693c:	55                   	push   %ebp
f010693d:	89 e5                	mov    %esp,%ebp
f010693f:	83 ec 28             	sub    $0x28,%esp
f0106942:	8b 45 08             	mov    0x8(%ebp),%eax
f0106945:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f0106948:	c6 05 04 4a 5f f0 01 	movb   $0x1,0xf05f4a04
#if USE_KHEAP
	sched_delete_ready_queues();
f010694f:	e8 63 e8 ff ff       	call   f01051b7 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f0106954:	83 ec 0c             	sub    $0xc,%esp
f0106957:	6a 10                	push   $0x10
f0106959:	e8 32 24 00 00       	call   f0108d90 <kmalloc>
f010695e:	83 c4 10             	add    $0x10,%esp
f0106961:	a3 50 43 5f f0       	mov    %eax,0xf05f4350
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0106966:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f010696b:	0f b6 c0             	movzbl %al,%eax
f010696e:	83 ec 0c             	sub    $0xc,%esp
f0106971:	50                   	push   %eax
f0106972:	e8 19 24 00 00       	call   f0108d90 <kmalloc>
f0106977:	83 c4 10             	add    $0x10,%esp
f010697a:	a3 84 46 5f f0       	mov    %eax,0xf05f4684
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f010697f:	a1 84 46 5f f0       	mov    0xf05f4684,%eax
f0106984:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0106987:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0106989:	a1 84 46 5f f0       	mov    0xf05f4684,%eax
f010698e:	8a 00                	mov    (%eax),%al
f0106990:	0f b6 c0             	movzbl %al,%eax
f0106993:	83 ec 0c             	sub    $0xc,%esp
f0106996:	50                   	push   %eax
f0106997:	e8 85 e3 ff ff       	call   f0104d21 <kclock_set_quantum>
f010699c:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f010699f:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f01069a4:	83 ec 0c             	sub    $0xc,%esp
f01069a7:	50                   	push   %eax
f01069a8:	e8 5a e5 ff ff       	call   f0104f07 <init_queue>
f01069ad:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f01069b0:	e8 cb e4 ff ff       	call   f0104e80 <kclock_read_cnt0_latch>
f01069b5:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f01069b9:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f01069bd:	83 ec 08             	sub    $0x8,%esp
f01069c0:	50                   	push   %eax
f01069c1:	68 90 46 12 f0       	push   $0xf0124690
f01069c6:	e8 c0 a5 ff ff       	call   f0100f8b <cprintf>
f01069cb:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f01069ce:	e8 ce 06 00 00       	call   f01070a1 <mycpu>
f01069d3:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f01069da:	00 00 00 
	scheduler_method = SCH_RR;
f01069dd:	c7 05 b4 47 5f f0 00 	movl   $0x0,0xf05f47b4
f01069e4:	00 00 00 
	//=========================================
	//=========================================
}
f01069e7:	90                   	nop
f01069e8:	c9                   	leave  
f01069e9:	c3                   	ret    

f01069ea <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f01069ea:	55                   	push   %ebp
f01069eb:	89 e5                	mov    %esp,%ebp
f01069ed:	83 ec 18             	sub    $0x18,%esp
f01069f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01069f3:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f01069f6:	e8 bc e7 ff ff       	call   f01051b7 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01069fb:	83 ec 04             	sub    $0x4,%esp
f01069fe:	68 b8 46 12 f0       	push   $0xf01246b8
f0106a03:	68 ce 00 00 00       	push   $0xce
f0106a08:	68 02 46 12 f0       	push   $0xf0124602
f0106a0d:	e8 27 99 ff ff       	call   f0100339 <_panic>

f0106a12 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a12:	55                   	push   %ebp
f0106a13:	89 e5                	mov    %esp,%ebp
f0106a15:	83 ec 18             	sub    $0x18,%esp
f0106a18:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a1e:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a21:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a24:	83 ec 04             	sub    $0x4,%esp
f0106a27:	68 b8 46 12 f0       	push   $0xf01246b8
f0106a2c:	68 e4 00 00 00       	push   $0xe4
f0106a31:	68 02 46 12 f0       	push   $0xf0124602
f0106a36:	e8 fe 98 ff ff       	call   f0100339 <_panic>

f0106a3b <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106a3b:	55                   	push   %ebp
f0106a3c:	89 e5                	mov    %esp,%ebp
f0106a3e:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106a41:	83 ec 0c             	sub    $0xc,%esp
f0106a44:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106a49:	e8 57 83 00 00       	call   f010eda5 <holding_spinlock>
f0106a4e:	83 c4 10             	add    $0x10,%esp
f0106a51:	85 c0                	test   %eax,%eax
f0106a53:	75 17                	jne    f0106a6c <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106a55:	83 ec 04             	sub    $0x4,%esp
f0106a58:	68 cc 46 12 f0       	push   $0xf01246cc
f0106a5d:	68 fe 00 00 00       	push   $0xfe
f0106a62:	68 02 46 12 f0       	push   $0xf0124602
f0106a67:	e8 cd 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106a6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106a73:	e8 93 41 00 00       	call   f010ac0b <get_cpu_proc>
f0106a78:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106a7f:	74 14                	je     f0106a95 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106a81:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0106a86:	83 ec 08             	sub    $0x8,%esp
f0106a89:	ff 75 f0             	pushl  -0x10(%ebp)
f0106a8c:	50                   	push   %eax
f0106a8d:	e8 b6 e4 ff ff       	call   f0104f48 <enqueue>
f0106a92:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106a95:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f0106a9a:	83 ec 0c             	sub    $0xc,%esp
f0106a9d:	50                   	push   %eax
f0106a9e:	e8 36 e5 ff ff       	call   f0104fd9 <dequeue>
f0106aa3:	83 c4 10             	add    $0x10,%esp
f0106aa6:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106aa9:	a1 84 46 5f f0       	mov    0xf05f4684,%eax
f0106aae:	8a 00                	mov    (%eax),%al
f0106ab0:	0f b6 c0             	movzbl %al,%eax
f0106ab3:	83 ec 0c             	sub    $0xc,%esp
f0106ab6:	50                   	push   %eax
f0106ab7:	e8 65 e2 ff ff       	call   f0104d21 <kclock_set_quantum>
f0106abc:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106ac2:	c9                   	leave  
f0106ac3:	c3                   	ret    

f0106ac4 <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106ac4:	55                   	push   %ebp
f0106ac5:	89 e5                	mov    %esp,%ebp
f0106ac7:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aca:	83 ec 0c             	sub    $0xc,%esp
f0106acd:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106ad2:	e8 ce 82 00 00       	call   f010eda5 <holding_spinlock>
f0106ad7:	83 c4 10             	add    $0x10,%esp
f0106ada:	85 c0                	test   %eax,%eax
f0106adc:	75 17                	jne    f0106af5 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106ade:	83 ec 04             	sub    $0x4,%esp
f0106ae1:	68 18 47 12 f0       	push   $0xf0124718
f0106ae6:	68 1d 01 00 00       	push   $0x11d
f0106aeb:	68 02 46 12 f0       	push   $0xf0124602
f0106af0:	e8 44 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106af5:	83 ec 04             	sub    $0x4,%esp
f0106af8:	68 b8 46 12 f0       	push   $0xf01246b8
f0106afd:	68 23 01 00 00       	push   $0x123
f0106b02:	68 02 46 12 f0       	push   $0xf0124602
f0106b07:	e8 2d 98 ff ff       	call   f0100339 <_panic>

f0106b0c <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b0c:	55                   	push   %ebp
f0106b0d:	89 e5                	mov    %esp,%ebp
f0106b0f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b12:	83 ec 0c             	sub    $0xc,%esp
f0106b15:	68 c0 42 5f f0       	push   $0xf05f42c0
f0106b1a:	e8 86 82 00 00       	call   f010eda5 <holding_spinlock>
f0106b1f:	83 c4 10             	add    $0x10,%esp
f0106b22:	85 c0                	test   %eax,%eax
f0106b24:	75 17                	jne    f0106b3d <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b26:	83 ec 04             	sub    $0x4,%esp
f0106b29:	68 68 47 12 f0       	push   $0xf0124768
f0106b2e:	68 2e 01 00 00       	push   $0x12e
f0106b33:	68 02 46 12 f0       	push   $0xf0124602
f0106b38:	e8 fc 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b3d:	83 ec 04             	sub    $0x4,%esp
f0106b40:	68 b8 46 12 f0       	push   $0xf01246b8
f0106b45:	68 34 01 00 00       	push   $0x134
f0106b4a:	68 02 46 12 f0       	push   $0xf0124602
f0106b4f:	e8 e5 97 ff ff       	call   f0100339 <_panic>

f0106b54 <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106b54:	55                   	push   %ebp
f0106b55:	89 e5                	mov    %esp,%ebp
f0106b57:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106b5a:	e8 51 fb ff ff       	call   f01066b0 <isSchedMethodBSD>
f0106b5f:	85 c0                	test   %eax,%eax
f0106b61:	74 17                	je     f0106b7a <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106b63:	83 ec 04             	sub    $0x4,%esp
f0106b66:	68 b8 46 12 f0       	push   $0xf01246b8
f0106b6b:	68 43 01 00 00       	push   $0x143
f0106b70:	68 02 46 12 f0       	push   $0xf0124602
f0106b75:	e8 bf 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106b7a:	a1 68 49 5f f0       	mov    0xf05f4968,%eax
f0106b7f:	8b 15 6c 49 5f f0    	mov    0xf05f496c,%edx
f0106b85:	83 c0 01             	add    $0x1,%eax
f0106b88:	83 d2 00             	adc    $0x0,%edx
f0106b8b:	a3 68 49 5f f0       	mov    %eax,0xf05f4968
f0106b90:	89 15 6c 49 5f f0    	mov    %edx,0xf05f496c
	struct Env* p = get_cpu_proc();
f0106b96:	e8 70 40 00 00       	call   f010ac0b <get_cpu_proc>
f0106b9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106b9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ba2:	74 30                	je     f0106bd4 <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ba7:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0106bad:	8d 50 01             	lea    0x1(%eax),%edx
f0106bb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bb3:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106bb9:	83 ec 0c             	sub    $0xc,%esp
f0106bbc:	6a 01                	push   $0x1
f0106bbe:	e8 68 7b 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f0106bc3:	83 c4 10             	add    $0x10,%esp
f0106bc6:	85 c0                	test   %eax,%eax
f0106bc8:	74 05                	je     f0106bcf <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106bca:	e8 08 00 00 00       	call   f0106bd7 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106bcf:	e8 51 41 00 00       	call   f010ad25 <yield>
	}
	/*****************************************/
}
f0106bd4:	90                   	nop
f0106bd5:	c9                   	leave  
f0106bd6:	c3                   	ret    

f0106bd7 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106bd7:	55                   	push   %ebp
f0106bd8:	89 e5                	mov    %esp,%ebp
f0106bda:	53                   	push   %ebx
f0106bdb:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106bde:	e8 28 40 00 00       	call   f010ac0b <get_cpu_proc>
f0106be3:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106be6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106bea:	0f 84 a1 01 00 00    	je     f0106d91 <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106bf0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106bf3:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0106bf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106bfc:	eb 78                	jmp    f0106c76 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106bfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c01:	8b 00                	mov    (%eax),%eax
f0106c03:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c06:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c09:	8b 40 64             	mov    0x64(%eax),%eax
f0106c0c:	83 ec 08             	sub    $0x8,%esp
f0106c0f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c12:	50                   	push   %eax
f0106c13:	e8 5c 25 00 00       	call   f0109174 <pt_get_page_permissions>
f0106c18:	83 c4 10             	add    $0x10,%esp
f0106c1b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c21:	8b 40 08             	mov    0x8(%eax),%eax
f0106c24:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106c27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c2a:	83 e0 20             	and    $0x20,%eax
f0106c2d:	85 c0                	test   %eax,%eax
f0106c2f:	74 2b                	je     f0106c5c <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c31:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c34:	c1 e8 02             	shr    $0x2,%eax
f0106c37:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106c3c:	89 c2                	mov    %eax,%edx
f0106c3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c41:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106c44:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c47:	8b 40 64             	mov    0x64(%eax),%eax
f0106c4a:	6a 20                	push   $0x20
f0106c4c:	6a 00                	push   $0x0
f0106c4e:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c51:	50                   	push   %eax
f0106c52:	e8 59 24 00 00       	call   f01090b0 <pt_set_page_permissions>
f0106c57:	83 c4 10             	add    $0x10,%esp
f0106c5a:	eb 0e                	jmp    f0106c6a <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106c5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c5f:	c1 e8 02             	shr    $0x2,%eax
f0106c62:	89 c2                	mov    %eax,%edx
f0106c64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c67:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c6d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0106c73:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c76:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c7a:	74 08                	je     f0106c84 <update_WS_time_stamps+0xad>
f0106c7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c7f:	8b 40 10             	mov    0x10(%eax),%eax
f0106c82:	eb 05                	jmp    f0106c89 <update_WS_time_stamps+0xb2>
f0106c84:	b8 00 00 00 00       	mov    $0x0,%eax
f0106c89:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106c8c:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0106c92:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c95:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0106c9b:	85 c0                	test   %eax,%eax
f0106c9d:	0f 85 5b ff ff ff    	jne    f0106bfe <update_WS_time_stamps+0x27>
f0106ca3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ca7:	0f 85 51 ff ff ff    	jne    f0106bfe <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106cad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106cb4:	e9 ce 00 00 00       	jmp    f0106d87 <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106cb9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106cbc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106cbf:	89 d0                	mov    %edx,%eax
f0106cc1:	01 c0                	add    %eax,%eax
f0106cc3:	01 d0                	add    %edx,%eax
f0106cc5:	c1 e0 03             	shl    $0x3,%eax
f0106cc8:	01 c8                	add    %ecx,%eax
f0106cca:	05 a4 00 00 00       	add    $0xa4,%eax
f0106ccf:	8a 00                	mov    (%eax),%al
f0106cd1:	3c 01                	cmp    $0x1,%al
f0106cd3:	0f 84 ab 00 00 00    	je     f0106d84 <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106cd9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106cdc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106cdf:	89 d0                	mov    %edx,%eax
f0106ce1:	01 c0                	add    %eax,%eax
f0106ce3:	01 d0                	add    %edx,%eax
f0106ce5:	c1 e0 03             	shl    $0x3,%eax
f0106ce8:	01 c8                	add    %ecx,%eax
f0106cea:	05 a0 00 00 00       	add    $0xa0,%eax
f0106cef:	8b 00                	mov    (%eax),%eax
f0106cf1:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106cf4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106cf7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106cfa:	89 d0                	mov    %edx,%eax
f0106cfc:	01 c0                	add    %eax,%eax
f0106cfe:	01 d0                	add    %edx,%eax
f0106d00:	c1 e0 03             	shl    $0x3,%eax
f0106d03:	01 c8                	add    %ecx,%eax
f0106d05:	05 a8 00 00 00       	add    $0xa8,%eax
f0106d0a:	8b 00                	mov    (%eax),%eax
f0106d0c:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d12:	8b 40 64             	mov    0x64(%eax),%eax
f0106d15:	83 ec 08             	sub    $0x8,%esp
f0106d18:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d1b:	50                   	push   %eax
f0106d1c:	e8 2f 25 00 00       	call   f0109250 <pd_is_table_used>
f0106d21:	83 c4 10             	add    $0x10,%esp
f0106d24:	85 c0                	test   %eax,%eax
f0106d26:	74 3c                	je     f0106d64 <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d28:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d2b:	c1 e8 02             	shr    $0x2,%eax
f0106d2e:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d33:	89 c1                	mov    %eax,%ecx
f0106d35:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106d38:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d3b:	89 d0                	mov    %edx,%eax
f0106d3d:	01 c0                	add    %eax,%eax
f0106d3f:	01 d0                	add    %edx,%eax
f0106d41:	c1 e0 03             	shl    $0x3,%eax
f0106d44:	01 d8                	add    %ebx,%eax
f0106d46:	05 a8 00 00 00       	add    $0xa8,%eax
f0106d4b:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106d4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d50:	8b 40 64             	mov    0x64(%eax),%eax
f0106d53:	83 ec 08             	sub    $0x8,%esp
f0106d56:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d59:	50                   	push   %eax
f0106d5a:	e8 15 25 00 00       	call   f0109274 <pd_set_table_unused>
f0106d5f:	83 c4 10             	add    $0x10,%esp
f0106d62:	eb 20                	jmp    f0106d84 <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106d64:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d67:	c1 e8 02             	shr    $0x2,%eax
f0106d6a:	89 c1                	mov    %eax,%ecx
f0106d6c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106d6f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d72:	89 d0                	mov    %edx,%eax
f0106d74:	01 c0                	add    %eax,%eax
f0106d76:	01 d0                	add    %edx,%eax
f0106d78:	c1 e0 03             	shl    $0x3,%eax
f0106d7b:	01 d8                	add    %ebx,%eax
f0106d7d:	05 a8 00 00 00       	add    $0xa8,%eax
f0106d82:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d84:	ff 45 f0             	incl   -0x10(%ebp)
f0106d87:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106d8b:	0f 8e 28 ff ff ff    	jle    f0106cb9 <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106d91:	90                   	nop
f0106d92:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106d95:	c9                   	leave  
f0106d96:	c3                   	ret    

f0106d97 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106d97:	55                   	push   %ebp
f0106d98:	89 e5                	mov    %esp,%ebp
f0106d9a:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106d9d:	c7 05 cc b7 5c f0 01 	movl   $0x1,0xf05cb7cc
f0106da4:	00 00 00 
f0106da7:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106dae:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106db2:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106db5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106db8:	ee                   	out    %al,(%dx)
f0106db9:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106dc0:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106dc4:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106dc7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106dca:	ee                   	out    %al,(%dx)
f0106dcb:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106dd2:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106dd6:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106dd9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106ddc:	ee                   	out    %al,(%dx)
f0106ddd:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106de4:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106de8:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106deb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106dee:	ee                   	out    %al,(%dx)
f0106def:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106df6:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106dfa:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106dfd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e00:	ee                   	out    %al,(%dx)
f0106e01:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e08:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e0c:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e0f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e12:	ee                   	out    %al,(%dx)
f0106e13:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e1a:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e1e:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e21:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e24:	ee                   	out    %al,(%dx)
f0106e25:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e2c:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e30:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e33:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106e36:	ee                   	out    %al,(%dx)
f0106e37:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106e3e:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106e42:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106e45:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106e48:	ee                   	out    %al,(%dx)
f0106e49:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106e50:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106e54:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106e57:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106e5a:	ee                   	out    %al,(%dx)
f0106e5b:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106e62:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106e66:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106e69:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106e6c:	ee                   	out    %al,(%dx)
f0106e6d:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106e74:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106e78:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106e7b:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106e7e:	ee                   	out    %al,(%dx)
f0106e7f:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106e86:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106e8a:	8a 45 be             	mov    -0x42(%ebp),%al
f0106e8d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106e90:	ee                   	out    %al,(%dx)
f0106e91:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106e98:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106e9c:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106e9f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106ea2:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106ea3:	66 a1 58 c9 17 f0    	mov    0xf017c958,%ax
f0106ea9:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106ead:	74 15                	je     f0106ec4 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106eaf:	66 a1 58 c9 17 f0    	mov    0xf017c958,%ax
f0106eb5:	0f b7 c0             	movzwl %ax,%eax
f0106eb8:	83 ec 0c             	sub    $0xc,%esp
f0106ebb:	50                   	push   %eax
f0106ebc:	e8 06 00 00 00       	call   f0106ec7 <irq_setmask_8259A>
f0106ec1:	83 c4 10             	add    $0x10,%esp
}
f0106ec4:	90                   	nop
f0106ec5:	c9                   	leave  
f0106ec6:	c3                   	ret    

f0106ec7 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106ec7:	55                   	push   %ebp
f0106ec8:	89 e5                	mov    %esp,%ebp
f0106eca:	83 ec 14             	sub    $0x14,%esp
f0106ecd:	8b 45 08             	mov    0x8(%ebp),%eax
f0106ed0:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106ed4:	a1 cc b7 5c f0       	mov    0xf05cb7cc,%eax
f0106ed9:	85 c0                	test   %eax,%eax
f0106edb:	74 34                	je     f0106f11 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106ee0:	0f b6 c0             	movzbl %al,%eax
f0106ee3:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106eea:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106eed:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106ef0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106ef3:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106ef4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106ef7:	66 c1 e8 08          	shr    $0x8,%ax
f0106efb:	0f b6 c0             	movzbl %al,%eax
f0106efe:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f05:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f08:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f0b:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f0e:	ee                   	out    %al,(%dx)
f0106f0f:	eb 01                	jmp    f0106f12 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f11:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f12:	c9                   	leave  
f0106f13:	c3                   	ret    

f0106f14 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f14:	55                   	push   %ebp
f0106f15:	89 e5                	mov    %esp,%ebp
f0106f17:	53                   	push   %ebx
f0106f18:	83 ec 14             	sub    $0x14,%esp
f0106f1b:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f1e:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f21:	a1 cc b7 5c f0       	mov    0xf05cb7cc,%eax
f0106f26:	85 c0                	test   %eax,%eax
f0106f28:	74 58                	je     f0106f82 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f2a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f2e:	77 08                	ja     f0106f38 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f30:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106f36:	eb 0a                	jmp    f0106f42 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106f38:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106f3e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106f42:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106f46:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106f49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f4c:	89 c2                	mov    %eax,%edx
f0106f4e:	ec                   	in     (%dx),%al
f0106f4f:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106f52:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106f55:	88 c2                	mov    %al,%dl
f0106f57:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106f5b:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106f60:	88 c1                	mov    %al,%cl
f0106f62:	d3 e3                	shl    %cl,%ebx
f0106f64:	89 d8                	mov    %ebx,%eax
f0106f66:	09 d0                	or     %edx,%eax
f0106f68:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106f6b:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106f6f:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106f73:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106f76:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106f79:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106f7f:	ee                   	out    %al,(%dx)
f0106f80:	eb 01                	jmp    f0106f83 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106f82:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106f83:	83 c4 14             	add    $0x14,%esp
f0106f86:	5b                   	pop    %ebx
f0106f87:	5d                   	pop    %ebp
f0106f88:	c3                   	ret    

f0106f89 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106f89:	55                   	push   %ebp
f0106f8a:	89 e5                	mov    %esp,%ebp
f0106f8c:	53                   	push   %ebx
f0106f8d:	83 ec 14             	sub    $0x14,%esp
f0106f90:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f93:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f96:	a1 cc b7 5c f0       	mov    0xf05cb7cc,%eax
f0106f9b:	85 c0                	test   %eax,%eax
f0106f9d:	74 5a                	je     f0106ff9 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f9f:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106fa3:	77 08                	ja     f0106fad <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0106fa5:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fab:	eb 0a                	jmp    f0106fb7 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fad:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fb3:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0106fb7:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fbb:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fc1:	89 c2                	mov    %eax,%edx
f0106fc3:	ec                   	in     (%dx),%al
f0106fc4:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fc7:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fca:	88 c2                	mov    %al,%dl
f0106fcc:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fd0:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fd5:	88 c1                	mov    %al,%cl
f0106fd7:	d3 e3                	shl    %cl,%ebx
f0106fd9:	89 d8                	mov    %ebx,%eax
f0106fdb:	f7 d0                	not    %eax
f0106fdd:	21 d0                	and    %edx,%eax
f0106fdf:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fe2:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fe6:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fea:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fed:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106ff0:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106ff3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ff6:	ee                   	out    %al,(%dx)
f0106ff7:	eb 01                	jmp    f0106ffa <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106ff9:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0106ffa:	83 c4 14             	add    $0x14,%esp
f0106ffd:	5b                   	pop    %ebx
f0106ffe:	5d                   	pop    %ebp
f0106fff:	c3                   	ret    

f0107000 <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107000:	55                   	push   %ebp
f0107001:	89 e5                	mov    %esp,%ebp
f0107003:	53                   	push   %ebx
f0107004:	83 ec 14             	sub    $0x14,%esp
f0107007:	8b 45 08             	mov    0x8(%ebp),%eax
f010700a:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f010700d:	a1 cc b7 5c f0       	mov    0xf05cb7cc,%eax
f0107012:	85 c0                	test   %eax,%eax
f0107014:	75 07                	jne    f010701d <irq_get_mask+0x1d>
		return -1;
f0107016:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010701b:	eb 45                	jmp    f0107062 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010701d:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107021:	77 08                	ja     f010702b <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0107023:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107029:	eb 0a                	jmp    f0107035 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f010702b:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107031:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0107035:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107039:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010703c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010703f:	89 c2                	mov    %eax,%edx
f0107041:	ec                   	in     (%dx),%al
f0107042:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f0107045:	8a 45 f3             	mov    -0xd(%ebp),%al
f0107048:	88 c2                	mov    %al,%dl
f010704a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010704e:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107053:	88 c1                	mov    %al,%cl
f0107055:	d3 e3                	shl    %cl,%ebx
f0107057:	89 d8                	mov    %ebx,%eax
f0107059:	21 d0                	and    %edx,%eax
f010705b:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f010705e:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f0107062:	83 c4 14             	add    $0x14,%esp
f0107065:	5b                   	pop    %ebx
f0107066:	5d                   	pop    %ebp
f0107067:	c3                   	ret    

f0107068 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f0107068:	55                   	push   %ebp
f0107069:	89 e5                	mov    %esp,%ebp
f010706b:	83 ec 14             	sub    $0x14,%esp
f010706e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107071:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f0107074:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f0107078:	76 12                	jbe    f010708c <pic_sendEOI+0x24>
f010707a:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0107081:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107085:	8a 45 f7             	mov    -0x9(%ebp),%al
f0107088:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010708b:	ee                   	out    %al,(%dx)
f010708c:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0107093:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107097:	8a 45 f6             	mov    -0xa(%ebp),%al
f010709a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010709d:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f010709e:	90                   	nop
f010709f:	c9                   	leave  
f01070a0:	c3                   	ret    

f01070a1 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f01070a1:	55                   	push   %ebp
f01070a2:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f01070a4:	b8 a0 44 5f f0       	mov    $0xf05f44a0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f01070a9:	5d                   	pop    %ebp
f01070aa:	c3                   	ret    

f01070ab <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f01070ab:	55                   	push   %ebp
f01070ac:	89 e5                	mov    %esp,%ebp
f01070ae:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f01070b1:	e8 eb ff ff ff       	call   f01070a1 <mycpu>
f01070b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f01070b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070bc:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01070c3:	00 00 00 
  c->ncli = 0;
f01070c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070c9:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f01070d0:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01070d3:	9c                   	pushf  
f01070d4:	58                   	pop    %eax
f01070d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f01070d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f01070db:	25 00 02 00 00       	and    $0x200,%eax
f01070e0:	85 c0                	test   %eax,%eax
f01070e2:	0f 95 c0             	setne  %al
f01070e5:	0f b6 d0             	movzbl %al,%edx
f01070e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070eb:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f01070f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070f4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f01070fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070fe:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107105:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107108:	8b 45 08             	mov    0x8(%ebp),%eax
f010710b:	40                   	inc    %eax
f010710c:	c1 e0 0f             	shl    $0xf,%eax
f010710f:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107114:	29 c2                	sub    %eax,%edx
f0107116:	89 d0                	mov    %edx,%eax
f0107118:	89 c2                	mov    %eax,%edx
f010711a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010711d:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f0107120:	e8 18 01 00 00       	call   f010723d <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107125:	e8 a9 50 00 00       	call   f010c1d3 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f010712a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010712d:	83 c0 0c             	add    $0xc,%eax
f0107130:	83 ec 04             	sub    $0x4,%esp
f0107133:	6a 68                	push   $0x68
f0107135:	6a 00                	push   $0x0
f0107137:	50                   	push   %eax
f0107138:	e8 fe 7b 01 00       	call   f011ed3b <memset>
f010713d:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f0107140:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107143:	05 a4 00 00 00       	add    $0xa4,%eax
f0107148:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010714b:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f0107152:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107155:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107158:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010715b:	f0 87 02             	lock xchg %eax,(%edx)
f010715e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f0107161:	90                   	nop
f0107162:	c9                   	leave  
f0107163:	c3                   	ret    

f0107164 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f0107164:	55                   	push   %ebp
f0107165:	89 e5                	mov    %esp,%ebp
f0107167:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010716a:	9c                   	pushf  
f010716b:	58                   	pop    %eax
f010716c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f010716f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f0107172:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0107175:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f0107176:	e8 26 ff ff ff       	call   f01070a1 <mycpu>
f010717b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f010717e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107181:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107187:	85 c0                	test   %eax,%eax
f0107189:	75 13                	jne    f010719e <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f010718b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010718e:	25 00 02 00 00       	and    $0x200,%eax
f0107193:	89 c2                	mov    %eax,%edx
f0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107198:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f010719e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071a1:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071a7:	8d 50 01             	lea    0x1(%eax),%edx
f01071aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ad:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f01071b3:	90                   	nop
f01071b4:	c9                   	leave  
f01071b5:	c3                   	ret    

f01071b6 <popcli>:

void popcli(void)
{
f01071b6:	55                   	push   %ebp
f01071b7:	89 e5                	mov    %esp,%ebp
f01071b9:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071bc:	9c                   	pushf  
f01071bd:	58                   	pop    %eax
f01071be:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f01071c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f01071c4:	25 00 02 00 00       	and    $0x200,%eax
f01071c9:	85 c0                	test   %eax,%eax
f01071cb:	74 14                	je     f01071e1 <popcli+0x2b>
    panic("popcli - interruptible");
f01071cd:	83 ec 04             	sub    $0x4,%esp
f01071d0:	68 b5 47 12 f0       	push   $0xf01247b5
f01071d5:	6a 5e                	push   $0x5e
f01071d7:	68 cc 47 12 f0       	push   $0xf01247cc
f01071dc:	e8 58 91 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f01071e1:	e8 bb fe ff ff       	call   f01070a1 <mycpu>
f01071e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f01071e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ec:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071f2:	8d 50 ff             	lea    -0x1(%eax),%edx
f01071f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071f8:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f01071fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107201:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107207:	85 c0                	test   %eax,%eax
f0107209:	79 14                	jns    f010721f <popcli+0x69>
    panic("popcli");
f010720b:	83 ec 04             	sub    $0x4,%esp
f010720e:	68 db 47 12 f0       	push   $0xf01247db
f0107213:	6a 61                	push   $0x61
f0107215:	68 cc 47 12 f0       	push   $0xf01247cc
f010721a:	e8 1a 91 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f010721f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107222:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107228:	85 c0                	test   %eax,%eax
f010722a:	75 0e                	jne    f010723a <popcli+0x84>
f010722c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010722f:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0107235:	85 c0                	test   %eax,%eax
f0107237:	74 01                	je     f010723a <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0107239:	fb                   	sti    
    sti();
}
f010723a:	90                   	nop
f010723b:	c9                   	leave  
f010723c:	c3                   	ret    

f010723d <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f010723d:	55                   	push   %ebp
f010723e:	89 e5                	mov    %esp,%ebp
f0107240:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f0107243:	e8 1c ff ff ff       	call   f0107164 <pushcli>

	c = mycpu();
f0107248:	e8 54 fe ff ff       	call   f01070a1 <mycpu>
f010724d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f0107250:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107253:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f010725a:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f0107261:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107264:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f010726a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726d:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f0107273:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107276:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f010727d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107280:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107286:	83 e2 f0             	and    $0xfffffff0,%edx
f0107289:	83 ca 0a             	or     $0xa,%edx
f010728c:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107295:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010729b:	83 ca 10             	or     $0x10,%edx
f010729e:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072a7:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072ad:	83 e2 9f             	and    $0xffffff9f,%edx
f01072b0:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072b9:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072bf:	83 ca 80             	or     $0xffffff80,%edx
f01072c2:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072cb:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01072d1:	83 ca 0f             	or     $0xf,%edx
f01072d4:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01072da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072dd:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01072e3:	83 e2 ef             	and    $0xffffffef,%edx
f01072e6:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01072ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072ef:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01072f5:	83 e2 df             	and    $0xffffffdf,%edx
f01072f8:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01072fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107301:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107307:	83 ca 40             	or     $0x40,%edx
f010730a:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107310:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107313:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107319:	83 ca 80             	or     $0xffffff80,%edx
f010731c:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107322:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107325:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f010732c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010732f:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0107336:	ff ff 
f0107338:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010733b:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f0107342:	00 00 
f0107344:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107347:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f010734e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107351:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107357:	83 e2 f0             	and    $0xfffffff0,%edx
f010735a:	83 ca 02             	or     $0x2,%edx
f010735d:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107363:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107366:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010736c:	83 ca 10             	or     $0x10,%edx
f010736f:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107375:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107378:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010737e:	83 e2 9f             	and    $0xffffff9f,%edx
f0107381:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107387:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010738a:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107390:	83 ca 80             	or     $0xffffff80,%edx
f0107393:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107399:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010739c:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073a2:	83 ca 0f             	or     $0xf,%edx
f01073a5:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073ae:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073b4:	83 e2 ef             	and    $0xffffffef,%edx
f01073b7:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073c0:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073c6:	83 e2 df             	and    $0xffffffdf,%edx
f01073c9:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d2:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073d8:	83 ca 40             	or     $0x40,%edx
f01073db:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e4:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01073ea:	83 ca 80             	or     $0xffffff80,%edx
f01073ed:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01073f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f6:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f01073fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107400:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107407:	ff ff 
f0107409:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010740c:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f0107413:	00 00 
f0107415:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107418:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010741f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107422:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107428:	83 e2 f0             	and    $0xfffffff0,%edx
f010742b:	83 ca 0a             	or     $0xa,%edx
f010742e:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107434:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107437:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010743d:	83 ca 10             	or     $0x10,%edx
f0107440:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107446:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107449:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010744f:	83 ca 60             	or     $0x60,%edx
f0107452:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107458:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010745b:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107461:	83 ca 80             	or     $0xffffff80,%edx
f0107464:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010746a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010746d:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107473:	83 ca 0f             	or     $0xf,%edx
f0107476:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010747c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010747f:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107485:	83 e2 ef             	and    $0xffffffef,%edx
f0107488:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010748e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107491:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107497:	83 e2 df             	and    $0xffffffdf,%edx
f010749a:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a3:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074a9:	83 ca 40             	or     $0x40,%edx
f01074ac:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b5:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074bb:	83 ca 80             	or     $0xffffff80,%edx
f01074be:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c7:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f01074ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d1:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f01074d8:	ff ff 
f01074da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074dd:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f01074e4:	00 00 
f01074e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074e9:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f01074f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074f3:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01074f9:	83 e2 f0             	and    $0xfffffff0,%edx
f01074fc:	83 ca 02             	or     $0x2,%edx
f01074ff:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107505:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107508:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010750e:	83 ca 10             	or     $0x10,%edx
f0107511:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107517:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010751a:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107520:	83 ca 60             	or     $0x60,%edx
f0107523:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107529:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010752c:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107532:	83 ca 80             	or     $0xffffff80,%edx
f0107535:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f010753b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753e:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107544:	83 ca 0f             	or     $0xf,%edx
f0107547:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010754d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107550:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107556:	83 e2 ef             	and    $0xffffffef,%edx
f0107559:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010755f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107562:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107568:	83 e2 df             	and    $0xffffffdf,%edx
f010756b:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107571:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107574:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f010757a:	83 ca 40             	or     $0x40,%edx
f010757d:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107583:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107586:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f010758c:	83 ca 80             	or     $0xffffff80,%edx
f010758f:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107595:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107598:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010759f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a2:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f01075a9:	00 00 00 
f01075ac:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f01075b3:	00 00 00 

	popcli();	//enable interrupt
f01075b6:	e8 fb fb ff ff       	call   f01071b6 <popcli>


}
f01075bb:	90                   	nop
f01075bc:	c9                   	leave  
f01075bd:	c3                   	ret    

f01075be <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f01075be:	55                   	push   %ebp
f01075bf:	89 e5                	mov    %esp,%ebp
f01075c1:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f01075c4:	83 ec 08             	sub    $0x8,%esp
f01075c7:	68 00 10 00 00       	push   $0x1000
f01075cc:	68 00 10 00 00       	push   $0x1000
f01075d1:	e8 42 02 00 00       	call   f0107818 <boot_allocate_space>
f01075d6:	83 c4 10             	add    $0x10,%esp
f01075d9:	a3 7c 49 5f f0       	mov    %eax,0xf05f497c
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f01075de:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f01075e3:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01075e6:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f01075ed:	77 14                	ja     f0107603 <initialize_kernel_VM+0x45>
f01075ef:	ff 75 e0             	pushl  -0x20(%ebp)
f01075f2:	68 e4 47 12 f0       	push   $0xf01247e4
f01075f7:	6a 57                	push   $0x57
f01075f9:	68 18 48 12 f0       	push   $0xf0124818
f01075fe:	e8 36 8d ff ff       	call   f0100339 <_panic>
f0107603:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107606:	05 00 00 00 10       	add    $0x10000000,%eax
f010760b:	a3 a4 4a 5f f0       	mov    %eax,0xf05f4aa4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f0107610:	c7 45 dc 00 40 17 f0 	movl   $0xf0174000,-0x24(%ebp)
f0107617:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f010761e:	77 14                	ja     f0107634 <initialize_kernel_VM+0x76>
f0107620:	ff 75 dc             	pushl  -0x24(%ebp)
f0107623:	68 e4 47 12 f0       	push   $0xf01247e4
f0107628:	6a 63                	push   $0x63
f010762a:	68 18 48 12 f0       	push   $0xf0124818
f010762f:	e8 05 8d ff ff       	call   f0100339 <_panic>
f0107634:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107637:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f010763d:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0107642:	83 ec 0c             	sub    $0xc,%esp
f0107645:	6a 02                	push   $0x2
f0107647:	52                   	push   %edx
f0107648:	68 00 80 00 00       	push   $0x8000
f010764d:	68 00 80 bf ef       	push   $0xefbf8000
f0107652:	50                   	push   %eax
f0107653:	e8 34 02 00 00       	call   f010788c <boot_map_range>
f0107658:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f010765b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107662:	eb 24                	jmp    f0107688 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f0107664:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107667:	40                   	inc    %eax
f0107668:	c1 e0 0f             	shl    $0xf,%eax
f010766b:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107670:	29 c2                	sub    %eax,%edx
f0107672:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0107677:	6a 01                	push   $0x1
f0107679:	6a 00                	push   $0x0
f010767b:	52                   	push   %edx
f010767c:	50                   	push   %eax
f010767d:	e8 2e 1a 00 00       	call   f01090b0 <pt_set_page_permissions>
f0107682:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0107685:	ff 45 f4             	incl   -0xc(%ebp)
f0107688:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010768c:	7e d6                	jle    f0107664 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f010768e:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107695:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f010769c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f01076a3:	eb 25                	jmp    f01076ca <initialize_kernel_VM+0x10c>
	{
		++nTables;
f01076a5:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f01076a8:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01076ab:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f01076b0:	83 ec 04             	sub    $0x4,%esp
f01076b3:	6a 01                	push   $0x1
f01076b5:	52                   	push   %edx
f01076b6:	50                   	push   %eax
f01076b7:	e8 44 02 00 00       	call   f0107900 <boot_get_page_table>
f01076bc:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f01076bf:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f01076c6:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f01076ca:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01076ce:	72 d5                	jb     f01076a5 <initialize_kernel_VM+0xe7>
f01076d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01076d4:	77 06                	ja     f01076dc <initialize_kernel_VM+0x11e>
f01076d6:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f01076da:	76 c9                	jbe    f01076a5 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f01076dc:	8b 15 58 45 5f f0    	mov    0xf05f4558,%edx
f01076e2:	89 d0                	mov    %edx,%eax
f01076e4:	01 c0                	add    %eax,%eax
f01076e6:	01 d0                	add    %edx,%eax
f01076e8:	c1 e0 03             	shl    $0x3,%eax
f01076eb:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f01076ee:	83 ec 08             	sub    $0x8,%esp
f01076f1:	68 00 10 00 00       	push   $0x1000
f01076f6:	ff 75 d8             	pushl  -0x28(%ebp)
f01076f9:	e8 1a 01 00 00       	call   f0107818 <boot_allocate_space>
f01076fe:	83 c4 10             	add    $0x10,%esp
f0107701:	a3 c0 47 5f f0       	mov    %eax,0xf05f47c0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107706:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f010770d:	83 ec 08             	sub    $0x8,%esp
f0107710:	68 00 10 00 00       	push   $0x1000
f0107715:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107718:	e8 fb 00 00 00       	call   f0107818 <boot_allocate_space>
f010771d:	83 c4 10             	add    $0x10,%esp
f0107720:	a3 80 40 5f f0       	mov    %eax,0xf05f4080
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107725:	e8 05 05 00 00       	call   f0107c2f <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f010772a:	83 ec 0c             	sub    $0xc,%esp
f010772d:	68 d0 02 00 00       	push   $0x2d0
f0107732:	e8 74 59 01 00       	call   f011d0ab <nearest_pow2_ceil>
f0107737:	83 c4 10             	add    $0x10,%esp
f010773a:	83 ec 04             	sub    $0x4,%esp
f010773d:	50                   	push   %eax
f010773e:	68 d0 02 00 00       	push   $0x2d0
f0107743:	68 38 48 12 f0       	push   $0xf0124838
f0107748:	e8 3e 98 ff ff       	call   f0100f8b <cprintf>
f010774d:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f0107750:	c7 45 d0 00 ff 0f 00 	movl   $0xfff00,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0107757:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010775a:	83 ec 08             	sub    $0x8,%esp
f010775d:	68 00 10 00 00       	push   $0x1000
f0107762:	50                   	push   %eax
f0107763:	e8 b0 00 00 00       	call   f0107818 <boot_allocate_space>
f0107768:	83 c4 10             	add    $0x10,%esp
f010776b:	a3 d0 b7 5c f0       	mov    %eax,0xf05cb7d0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f0107770:	a1 d0 b7 5c f0       	mov    0xf05cb7d0,%eax
f0107775:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0107778:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f010777f:	77 17                	ja     f0107798 <initialize_kernel_VM+0x1da>
f0107781:	ff 75 cc             	pushl  -0x34(%ebp)
f0107784:	68 e4 47 12 f0       	push   $0xf01247e4
f0107789:	68 b1 00 00 00       	push   $0xb1
f010778e:	68 18 48 12 f0       	push   $0xf0124818
f0107793:	e8 a1 8b ff ff       	call   f0100339 <_panic>
f0107798:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010779b:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01077a1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01077a4:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f01077a9:	83 ec 0c             	sub    $0xc,%esp
f01077ac:	6a 04                	push   $0x4
f01077ae:	51                   	push   %ecx
f01077af:	52                   	push   %edx
f01077b0:	68 00 00 c0 ee       	push   $0xeec00000
f01077b5:	50                   	push   %eax
f01077b6:	e8 d1 00 00 00       	call   f010788c <boot_map_range>
f01077bb:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f01077be:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f01077c3:	05 ec 0e 00 00       	add    $0xeec,%eax
f01077c8:	8b 15 7c 49 5f f0    	mov    0xf05f497c,%edx
f01077ce:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f01077d4:	8b 12                	mov    (%edx),%edx
f01077d6:	83 ca 05             	or     $0x5,%edx
f01077d9:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f01077db:	a1 78 49 5f f0       	mov    0xf05f4978,%eax
f01077e0:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01077e6:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f01077eb:	83 ec 0c             	sub    $0xc,%esp
f01077ee:	6a 02                	push   $0x2
f01077f0:	6a 00                	push   $0x0
f01077f2:	52                   	push   %edx
f01077f3:	68 00 00 00 f0       	push   $0xf0000000
f01077f8:	50                   	push   %eax
f01077f9:	e8 8e 00 00 00       	call   f010788c <boot_map_range>
f01077fe:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0107801:	e8 78 68 01 00       	call   f011e07e <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107806:	c7 05 90 44 5f f0 19 	movl   $0x19,0xf05f4490
f010780d:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f0107810:	e8 e6 02 00 00       	call   f0107afb <turn_on_paging>
}
f0107815:	90                   	nop
f0107816:	c9                   	leave  
f0107817:	c3                   	ret    

f0107818 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107818:	55                   	push   %ebp
f0107819:	89 e5                	mov    %esp,%ebp
f010781b:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f010781e:	a1 78 49 5f f0       	mov    0xf05f4978,%eax
f0107823:	85 c0                	test   %eax,%eax
f0107825:	75 0a                	jne    f0107831 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107827:	c7 05 78 49 5f f0 70 	movl   $0xf0617470,0xf05f4978
f010782e:	74 61 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0107831:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107834:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107837:	a1 78 49 5f f0       	mov    0xf05f4978,%eax
f010783c:	89 c2                	mov    %eax,%edx
f010783e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107841:	01 d0                	add    %edx,%eax
f0107843:	48                   	dec    %eax
f0107844:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107847:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010784a:	ba 00 00 00 00       	mov    $0x0,%edx
f010784f:	f7 75 f4             	divl   -0xc(%ebp)
f0107852:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107855:	29 d0                	sub    %edx,%eax
f0107857:	a3 78 49 5f f0       	mov    %eax,0xf05f4978

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f010785c:	a1 78 49 5f f0       	mov    0xf05f4978,%eax
f0107861:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0107864:	8b 15 78 49 5f f0    	mov    0xf05f4978,%edx
f010786a:	8b 45 08             	mov    0x8(%ebp),%eax
f010786d:	01 d0                	add    %edx,%eax
f010786f:	a3 78 49 5f f0       	mov    %eax,0xf05f4978

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0107874:	83 ec 04             	sub    $0x4,%esp
f0107877:	ff 75 08             	pushl  0x8(%ebp)
f010787a:	6a 00                	push   $0x0
f010787c:	ff 75 ec             	pushl  -0x14(%ebp)
f010787f:	e8 b7 74 01 00       	call   f011ed3b <memset>
f0107884:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0107887:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f010788a:	c9                   	leave  
f010788b:	c3                   	ret    

f010788c <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f010788c:	55                   	push   %ebp
f010788d:	89 e5                	mov    %esp,%ebp
f010788f:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f0107892:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107899:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01078a0:	eb 53                	jmp    f01078f5 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f01078a2:	83 ec 04             	sub    $0x4,%esp
f01078a5:	6a 01                	push   $0x1
f01078a7:	ff 75 0c             	pushl  0xc(%ebp)
f01078aa:	ff 75 08             	pushl  0x8(%ebp)
f01078ad:	e8 4e 00 00 00       	call   f0107900 <boot_get_page_table>
f01078b2:	83 c4 10             	add    $0x10,%esp
f01078b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f01078b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01078bb:	c1 e8 0c             	shr    $0xc,%eax
f01078be:	25 ff 03 00 00       	and    $0x3ff,%eax
f01078c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f01078c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01078c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01078d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078d3:	01 c2                	add    %eax,%edx
f01078d5:	8b 45 18             	mov    0x18(%ebp),%eax
f01078d8:	0b 45 14             	or     0x14(%ebp),%eax
f01078db:	83 c8 01             	or     $0x1,%eax
f01078de:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f01078e0:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f01078e7:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f01078ee:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f01078f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078f8:	3b 45 10             	cmp    0x10(%ebp),%eax
f01078fb:	72 a5                	jb     f01078a2 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f01078fd:	90                   	nop
f01078fe:	c9                   	leave  
f01078ff:	c3                   	ret    

f0107900 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0107900:	55                   	push   %ebp
f0107901:	89 e5                	mov    %esp,%ebp
f0107903:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107906:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107909:	c1 e8 16             	shr    $0x16,%eax
f010790c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010790f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107912:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107919:	8b 45 08             	mov    0x8(%ebp),%eax
f010791c:	01 d0                	add    %edx,%eax
f010791e:	8b 00                	mov    (%eax),%eax
f0107920:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0107923:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107926:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010792b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f010792e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107931:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0107934:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107937:	c1 e8 0c             	shr    $0xc,%eax
f010793a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010793d:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f0107942:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0107945:	72 17                	jb     f010795e <boot_get_page_table+0x5e>
f0107947:	ff 75 e8             	pushl  -0x18(%ebp)
f010794a:	68 60 48 12 f0       	push   $0xf0124860
f010794f:	68 33 01 00 00       	push   $0x133
f0107954:	68 18 48 12 f0       	push   $0xf0124818
f0107959:	e8 db 89 ff ff       	call   f0100339 <_panic>
f010795e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107961:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0107966:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0107969:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010796d:	75 72                	jne    f01079e1 <boot_get_page_table+0xe1>
	{
		if (create)
f010796f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0107973:	74 65                	je     f01079da <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0107975:	83 ec 08             	sub    $0x8,%esp
f0107978:	68 00 10 00 00       	push   $0x1000
f010797d:	68 00 10 00 00       	push   $0x1000
f0107982:	e8 91 fe ff ff       	call   f0107818 <boot_allocate_space>
f0107987:	83 c4 10             	add    $0x10,%esp
f010798a:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f010798d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107990:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107993:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f010799a:	77 17                	ja     f01079b3 <boot_get_page_table+0xb3>
f010799c:	ff 75 dc             	pushl  -0x24(%ebp)
f010799f:	68 e4 47 12 f0       	push   $0xf01247e4
f01079a4:	68 39 01 00 00       	push   $0x139
f01079a9:	68 18 48 12 f0       	push   $0xf0124818
f01079ae:	e8 86 89 ff ff       	call   f0100339 <_panic>
f01079b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01079b6:	05 00 00 00 10       	add    $0x10000000,%eax
f01079bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f01079be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079c1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01079c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01079cb:	01 d0                	add    %edx,%eax
f01079cd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01079d0:	83 ca 03             	or     $0x3,%edx
f01079d3:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f01079d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079d8:	eb 0a                	jmp    f01079e4 <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f01079da:	b8 00 00 00 00       	mov    $0x0,%eax
f01079df:	eb 03                	jmp    f01079e4 <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f01079e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f01079e4:	c9                   	leave  
f01079e5:	c3                   	ret    

f01079e6 <nvram_read>:


int nvram_read(int r)
{
f01079e6:	55                   	push   %ebp
f01079e7:	89 e5                	mov    %esp,%ebp
f01079e9:	53                   	push   %ebx
f01079ea:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f01079ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01079f0:	83 ec 0c             	sub    $0xc,%esp
f01079f3:	50                   	push   %eax
f01079f4:	e8 31 d1 ff ff       	call   f0104b2a <mc146818_read>
f01079f9:	83 c4 10             	add    $0x10,%esp
f01079fc:	89 c3                	mov    %eax,%ebx
f01079fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a01:	40                   	inc    %eax
f0107a02:	83 ec 0c             	sub    $0xc,%esp
f0107a05:	50                   	push   %eax
f0107a06:	e8 1f d1 ff ff       	call   f0104b2a <mc146818_read>
f0107a0b:	83 c4 10             	add    $0x10,%esp
f0107a0e:	c1 e0 08             	shl    $0x8,%eax
f0107a11:	09 d8                	or     %ebx,%eax
}
f0107a13:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a16:	c9                   	leave  
f0107a17:	c3                   	ret    

f0107a18 <detect_memory>:

void detect_memory()
{
f0107a18:	55                   	push   %ebp
f0107a19:	89 e5                	mov    %esp,%ebp
f0107a1b:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a1e:	83 ec 0c             	sub    $0xc,%esp
f0107a21:	6a 15                	push   $0x15
f0107a23:	e8 be ff ff ff       	call   f01079e6 <nvram_read>
f0107a28:	83 c4 10             	add    $0x10,%esp
f0107a2b:	c1 e0 0a             	shl    $0xa,%eax
f0107a2e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a31:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a34:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a39:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107a3c:	83 ec 0c             	sub    $0xc,%esp
f0107a3f:	6a 17                	push   $0x17
f0107a41:	e8 a0 ff ff ff       	call   f01079e6 <nvram_read>
f0107a46:	83 c4 10             	add    $0x10,%esp
f0107a49:	c1 e0 0a             	shl    $0xa,%eax
f0107a4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107a4f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107a52:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a57:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107a5a:	83 ec 0c             	sub    $0xc,%esp
f0107a5d:	6a 34                	push   $0x34
f0107a5f:	e8 82 ff ff ff       	call   f01079e6 <nvram_read>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	c1 e0 10             	shl    $0x10,%eax
f0107a6a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107a6d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a70:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107a75:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107a78:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107a7c:	74 18                	je     f0107a96 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107a7e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a81:	05 00 00 00 01       	add    $0x1000000,%eax
f0107a86:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107a89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a8c:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107a91:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107a94:	eb 19                	jmp    f0107aaf <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107a96:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107a9a:	74 0d                	je     f0107aa9 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107a9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107a9f:	05 00 00 10 00       	add    $0x100000,%eax
f0107aa4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107aa7:	eb 06                	jmp    f0107aaf <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107aa9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107aac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107aaf:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107ab6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ab9:	c1 e8 0c             	shr    $0xc,%eax
f0107abc:	a3 58 45 5f f0       	mov    %eax,0xf05f4558

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107ac1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ac4:	c1 e8 0a             	shr    $0xa,%eax
f0107ac7:	83 ec 08             	sub    $0x8,%esp
f0107aca:	50                   	push   %eax
f0107acb:	68 90 48 12 f0       	push   $0xf0124890
f0107ad0:	e8 b6 94 ff ff       	call   f0100f8b <cprintf>
f0107ad5:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107ad8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107adb:	c1 e8 0a             	shr    $0xa,%eax
f0107ade:	89 c2                	mov    %eax,%edx
f0107ae0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107ae3:	c1 e8 0a             	shr    $0xa,%eax
f0107ae6:	83 ec 04             	sub    $0x4,%esp
f0107ae9:	52                   	push   %edx
f0107aea:	50                   	push   %eax
f0107aeb:	68 b3 48 12 f0       	push   $0xf01248b3
f0107af0:	e8 96 94 ff ff       	call   f0100f8b <cprintf>
f0107af5:	83 c4 10             	add    $0x10,%esp
}
f0107af8:	90                   	nop
f0107af9:	c9                   	leave  
f0107afa:	c3                   	ret    

f0107afb <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107afb:	55                   	push   %ebp
f0107afc:	89 e5                	mov    %esp,%ebp
f0107afe:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b01:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b0f:	eb 24                	jmp    f0107b35 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b11:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0107b16:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b19:	c1 e2 02             	shl    $0x2,%edx
f0107b1c:	01 c2                	add    %eax,%edx
f0107b1e:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0107b23:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b26:	c1 e1 02             	shl    $0x2,%ecx
f0107b29:	01 c8                	add    %ecx,%eax
f0107b2b:	8b 00                	mov    (%eax),%eax
f0107b2d:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b2f:	ff 45 f4             	incl   -0xc(%ebp)
f0107b32:	ff 45 f0             	incl   -0x10(%ebp)
f0107b35:	a1 78 49 5f f0       	mov    0xf05f4978,%eax
f0107b3a:	c1 e8 16             	shr    $0x16,%eax
f0107b3d:	89 c2                	mov    %eax,%edx
f0107b3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b42:	39 c2                	cmp    %eax,%edx
f0107b44:	77 cb                	ja     f0107b11 <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107b46:	a1 a4 4a 5f f0       	mov    0xf05f4aa4,%eax
f0107b4b:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107b4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107b51:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107b54:	0f 20 c0             	mov    %cr0,%eax
f0107b57:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107b5a:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107b5d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107b60:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107b67:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107b6b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107b6e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107b71:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107b74:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107b77:	e8 e8 f5 ff ff       	call   f0107164 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107b7c:	e8 20 f5 ff ff       	call   f01070a1 <mycpu>
f0107b81:	83 c0 74             	add    $0x74,%eax
f0107b84:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107b87:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107b8e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107b91:	48                   	dec    %eax
f0107b92:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107b96:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107b99:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107b9d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107ba0:	c1 e8 10             	shr    $0x10,%eax
f0107ba3:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107ba7:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107baa:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107bad:	e8 04 f6 ff ff       	call   f01071b6 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107bb2:	b8 23 00 00 00       	mov    $0x23,%eax
f0107bb7:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107bb9:	b8 23 00 00 00       	mov    $0x23,%eax
f0107bbe:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107bc0:	b8 10 00 00 00       	mov    $0x10,%eax
f0107bc5:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107bc7:	b8 10 00 00 00       	mov    $0x10,%eax
f0107bcc:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107bce:	b8 10 00 00 00       	mov    $0x10,%eax
f0107bd3:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107bd5:	ea dc 7b 10 f0 08 00 	ljmp   $0x8,$0xf0107bdc
	asm volatile("lldt %%ax" :: "a" (0));
f0107bdc:	b8 00 00 00 00       	mov    $0x0,%eax
f0107be1:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107be4:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107beb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107bf2:	eb 19                	jmp    f0107c0d <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107bf4:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0107bf9:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107bfc:	c1 e2 02             	shl    $0x2,%edx
f0107bff:	01 d0                	add    %edx,%eax
f0107c01:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c07:	ff 45 ec             	incl   -0x14(%ebp)
f0107c0a:	ff 45 e8             	incl   -0x18(%ebp)
f0107c0d:	a1 78 49 5f f0       	mov    0xf05f4978,%eax
f0107c12:	c1 e8 16             	shr    $0x16,%eax
f0107c15:	89 c2                	mov    %eax,%edx
f0107c17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c1a:	39 c2                	cmp    %eax,%edx
f0107c1c:	77 d6                	ja     f0107bf4 <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c1e:	a1 a4 4a 5f f0       	mov    0xf05f4aa4,%eax
f0107c23:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c29:	0f 22 d8             	mov    %eax,%cr3

}
f0107c2c:	90                   	nop
f0107c2d:	c9                   	leave  
f0107c2e:	c3                   	ret    

f0107c2f <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c2f:	55                   	push   %ebp
f0107c30:	89 e5                	mov    %esp,%ebp
f0107c32:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107c35:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0107c3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107c3d:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107c44:	77 17                	ja     f0107c5d <setup_listing_to_all_page_tables_entries+0x2e>
f0107c46:	ff 75 f4             	pushl  -0xc(%ebp)
f0107c49:	68 e4 47 12 f0       	push   $0xf01247e4
f0107c4e:	68 cf 01 00 00       	push   $0x1cf
f0107c53:	68 18 48 12 f0       	push   $0xf0124818
f0107c58:	e8 dc 86 ff ff       	call   f0100339 <_panic>
f0107c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c60:	05 00 00 00 10       	add    $0x10000000,%eax
f0107c65:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107c68:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0107c6d:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107c72:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107c75:	83 ca 03             	or     $0x3,%edx
f0107c78:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107c7a:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0107c7f:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107c85:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0107c8a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107c8d:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107c94:	77 17                	ja     f0107cad <setup_listing_to_all_page_tables_entries+0x7e>
f0107c96:	ff 75 ec             	pushl  -0x14(%ebp)
f0107c99:	68 e4 47 12 f0       	push   $0xf01247e4
f0107c9e:	68 d4 01 00 00       	push   $0x1d4
f0107ca3:	68 18 48 12 f0       	push   $0xf0124818
f0107ca8:	e8 8c 86 ff ff       	call   f0100339 <_panic>
f0107cad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107cb0:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cb5:	83 c8 05             	or     $0x5,%eax
f0107cb8:	89 02                	mov    %eax,(%edx)

}
f0107cba:	90                   	nop
f0107cbb:	c9                   	leave  
f0107cbc:	c3                   	ret    

f0107cbd <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107cbd:	55                   	push   %ebp
f0107cbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107cc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0107cc3:	8b 15 c0 47 5f f0    	mov    0xf05f47c0,%edx
f0107cc9:	29 d0                	sub    %edx,%eax
f0107ccb:	c1 f8 03             	sar    $0x3,%eax
f0107cce:	89 c2                	mov    %eax,%edx
f0107cd0:	89 d0                	mov    %edx,%eax
f0107cd2:	c1 e0 02             	shl    $0x2,%eax
f0107cd5:	01 d0                	add    %edx,%eax
f0107cd7:	c1 e0 02             	shl    $0x2,%eax
f0107cda:	01 d0                	add    %edx,%eax
f0107cdc:	c1 e0 02             	shl    $0x2,%eax
f0107cdf:	01 d0                	add    %edx,%eax
f0107ce1:	89 c1                	mov    %eax,%ecx
f0107ce3:	c1 e1 08             	shl    $0x8,%ecx
f0107ce6:	01 c8                	add    %ecx,%eax
f0107ce8:	89 c1                	mov    %eax,%ecx
f0107cea:	c1 e1 10             	shl    $0x10,%ecx
f0107ced:	01 c8                	add    %ecx,%eax
f0107cef:	01 c0                	add    %eax,%eax
f0107cf1:	01 d0                	add    %edx,%eax
}
f0107cf3:	5d                   	pop    %ebp
f0107cf4:	c3                   	ret    

f0107cf5 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107cf5:	55                   	push   %ebp
f0107cf6:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107cf8:	ff 75 08             	pushl  0x8(%ebp)
f0107cfb:	e8 bd ff ff ff       	call   f0107cbd <to_frame_number>
f0107d00:	83 c4 04             	add    $0x4,%esp
f0107d03:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d06:	c9                   	leave  
f0107d07:	c3                   	ret    

f0107d08 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d08:	55                   	push   %ebp
f0107d09:	89 e5                	mov    %esp,%ebp
f0107d0b:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d0e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d11:	c1 e8 0c             	shr    $0xc,%eax
f0107d14:	89 c2                	mov    %eax,%edx
f0107d16:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f0107d1b:	39 c2                	cmp    %eax,%edx
f0107d1d:	72 14                	jb     f0107d33 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d1f:	83 ec 04             	sub    $0x4,%esp
f0107d22:	68 d0 48 12 f0       	push   $0xf01248d0
f0107d27:	6a 56                	push   $0x56
f0107d29:	68 f5 48 12 f0       	push   $0xf01248f5
f0107d2e:	e8 06 86 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107d33:	8b 15 c0 47 5f f0    	mov    0xf05f47c0,%edx
f0107d39:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d3c:	c1 e8 0c             	shr    $0xc,%eax
f0107d3f:	89 c1                	mov    %eax,%ecx
f0107d41:	89 c8                	mov    %ecx,%eax
f0107d43:	01 c0                	add    %eax,%eax
f0107d45:	01 c8                	add    %ecx,%eax
f0107d47:	c1 e0 03             	shl    $0x3,%eax
f0107d4a:	01 d0                	add    %edx,%eax
}
f0107d4c:	c9                   	leave  
f0107d4d:	c3                   	ret    

f0107d4e <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107d4e:	55                   	push   %ebp
f0107d4f:	89 e5                	mov    %esp,%ebp
f0107d51:	83 ec 10             	sub    $0x10,%esp
f0107d54:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107d57:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107d5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107d5d:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107d60:	90                   	nop
f0107d61:	c9                   	leave  
f0107d62:	c3                   	ret    

f0107d63 <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107d63:	55                   	push   %ebp
f0107d64:	89 e5                	mov    %esp,%ebp
f0107d66:	53                   	push   %ebx
f0107d67:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107d6a:	c7 05 60 43 5f f0 00 	movl   $0x0,0xf05f4360
f0107d71:	00 00 00 
f0107d74:	c7 05 64 43 5f f0 00 	movl   $0x0,0xf05f4364
f0107d7b:	00 00 00 
f0107d7e:	c7 05 6c 43 5f f0 00 	movl   $0x0,0xf05f436c
f0107d85:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107d88:	c7 05 70 43 5f f0 00 	movl   $0x0,0xf05f4370
f0107d8f:	00 00 00 
f0107d92:	c7 05 74 43 5f f0 00 	movl   $0x0,0xf05f4374
f0107d99:	00 00 00 
f0107d9c:	c7 05 7c 43 5f f0 00 	movl   $0x0,0xf05f437c
f0107da3:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107da6:	83 ec 08             	sub    $0x8,%esp
f0107da9:	68 0f 49 12 f0       	push   $0xf012490f
f0107dae:	68 80 43 5f f0       	push   $0xf05f4380
f0107db3:	e8 a3 6d 00 00       	call   f010eb5b <init_spinlock>
f0107db8:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107dbb:	a1 c0 47 5f f0       	mov    0xf05f47c0,%eax
f0107dc0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107dc6:	a1 c0 47 5f f0       	mov    0xf05f47c0,%eax
f0107dcb:	83 c0 18             	add    $0x18,%eax
f0107dce:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107dd4:	a1 c0 47 5f f0       	mov    0xf05f47c0,%eax
f0107dd9:	83 c0 30             	add    $0x30,%eax
f0107ddc:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107de2:	c7 05 5c 48 5f f0 00 	movl   $0xf0001000,0xf05f485c
f0107de9:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107dec:	c7 05 0c 4a 5f f0 00 	movl   $0xf0002000,0xf05f4a0c
f0107df3:	20 00 f0 
	i =0;
f0107df6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107dfd:	eb 1f                	jmp    f0107e1e <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107dff:	8b 15 5c 48 5f f0    	mov    0xf05f485c,%edx
f0107e05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e08:	01 d0                	add    %edx,%eax
f0107e0a:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e0d:	8b 15 0c 4a 5f f0    	mov    0xf05f4a0c,%edx
f0107e13:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e16:	01 d0                	add    %edx,%eax
f0107e18:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e1b:	ff 45 f4             	incl   -0xc(%ebp)
f0107e1e:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e25:	7e d8                	jle    f0107dff <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e27:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e31:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107e36:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107e39:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107e3c:	ba 00 00 00 00       	mov    $0x0,%edx
f0107e41:	f7 75 f0             	divl   -0x10(%ebp)
f0107e44:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107e47:	29 d0                	sub    %edx,%eax
f0107e49:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107e4c:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107e53:	e9 e8 00 00 00       	jmp    f0107f40 <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107e58:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f0107e5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e61:	89 d0                	mov    %edx,%eax
f0107e63:	01 c0                	add    %eax,%eax
f0107e65:	01 d0                	add    %edx,%eax
f0107e67:	c1 e0 03             	shl    $0x3,%eax
f0107e6a:	01 c8                	add    %ecx,%eax
f0107e6c:	83 ec 0c             	sub    $0xc,%esp
f0107e6f:	50                   	push   %eax
f0107e70:	e8 b7 02 00 00       	call   f010812c <initialize_frame_info>
f0107e75:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107e78:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f0107e7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e81:	89 d0                	mov    %edx,%eax
f0107e83:	01 c0                	add    %eax,%eax
f0107e85:	01 d0                	add    %edx,%eax
f0107e87:	c1 e0 03             	shl    $0x3,%eax
f0107e8a:	01 c8                	add    %ecx,%eax
f0107e8c:	85 c0                	test   %eax,%eax
f0107e8e:	75 14                	jne    f0107ea4 <initialize_paging+0x141>
f0107e90:	83 ec 04             	sub    $0x4,%esp
f0107e93:	68 20 49 12 f0       	push   $0xf0124920
f0107e98:	6a 60                	push   $0x60
f0107e9a:	68 43 49 12 f0       	push   $0xf0124943
f0107e9f:	e8 95 84 ff ff       	call   f0100339 <_panic>
f0107ea4:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f0107eaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ead:	89 d0                	mov    %edx,%eax
f0107eaf:	01 c0                	add    %eax,%eax
f0107eb1:	01 d0                	add    %edx,%eax
f0107eb3:	c1 e0 03             	shl    $0x3,%eax
f0107eb6:	01 c8                	add    %ecx,%eax
f0107eb8:	8b 15 60 43 5f f0    	mov    0xf05f4360,%edx
f0107ebe:	89 10                	mov    %edx,(%eax)
f0107ec0:	8b 00                	mov    (%eax),%eax
f0107ec2:	85 c0                	test   %eax,%eax
f0107ec4:	74 1f                	je     f0107ee5 <initialize_paging+0x182>
f0107ec6:	8b 15 60 43 5f f0    	mov    0xf05f4360,%edx
f0107ecc:	8b 1d c0 47 5f f0    	mov    0xf05f47c0,%ebx
f0107ed2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107ed5:	89 c8                	mov    %ecx,%eax
f0107ed7:	01 c0                	add    %eax,%eax
f0107ed9:	01 c8                	add    %ecx,%eax
f0107edb:	c1 e0 03             	shl    $0x3,%eax
f0107ede:	01 d8                	add    %ebx,%eax
f0107ee0:	89 42 04             	mov    %eax,0x4(%edx)
f0107ee3:	eb 19                	jmp    f0107efe <initialize_paging+0x19b>
f0107ee5:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f0107eeb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eee:	89 d0                	mov    %edx,%eax
f0107ef0:	01 c0                	add    %eax,%eax
f0107ef2:	01 d0                	add    %edx,%eax
f0107ef4:	c1 e0 03             	shl    $0x3,%eax
f0107ef7:	01 c8                	add    %ecx,%eax
f0107ef9:	a3 64 43 5f f0       	mov    %eax,0xf05f4364
f0107efe:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f0107f04:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f07:	89 d0                	mov    %edx,%eax
f0107f09:	01 c0                	add    %eax,%eax
f0107f0b:	01 d0                	add    %edx,%eax
f0107f0d:	c1 e0 03             	shl    $0x3,%eax
f0107f10:	01 c8                	add    %ecx,%eax
f0107f12:	a3 60 43 5f f0       	mov    %eax,0xf05f4360
f0107f17:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f0107f1d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f20:	89 d0                	mov    %edx,%eax
f0107f22:	01 c0                	add    %eax,%eax
f0107f24:	01 d0                	add    %edx,%eax
f0107f26:	c1 e0 03             	shl    $0x3,%eax
f0107f29:	01 c8                	add    %ecx,%eax
f0107f2b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f32:	a1 6c 43 5f f0       	mov    0xf05f436c,%eax
f0107f37:	40                   	inc    %eax
f0107f38:	a3 6c 43 5f f0       	mov    %eax,0xf05f436c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107f3d:	ff 45 f4             	incl   -0xc(%ebp)
f0107f40:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107f43:	85 c0                	test   %eax,%eax
f0107f45:	79 05                	jns    f0107f4c <initialize_paging+0x1e9>
f0107f47:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107f4c:	c1 f8 0c             	sar    $0xc,%eax
f0107f4f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107f52:	0f 8f 00 ff ff ff    	jg     f0107e58 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107f58:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107f5f:	eb 1d                	jmp    f0107f7e <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107f61:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f0107f67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f6a:	89 d0                	mov    %edx,%eax
f0107f6c:	01 c0                	add    %eax,%eax
f0107f6e:	01 d0                	add    %edx,%eax
f0107f70:	c1 e0 03             	shl    $0x3,%eax
f0107f73:	01 c8                	add    %ecx,%eax
f0107f75:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107f7b:	ff 45 f4             	incl   -0xc(%ebp)
f0107f7e:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107f85:	7e da                	jle    f0107f61 <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107f87:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107f8e:	a1 78 49 5f f0       	mov    0xf05f4978,%eax
f0107f93:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107f96:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107f9d:	77 14                	ja     f0107fb3 <initialize_paging+0x250>
f0107f9f:	ff 75 e0             	pushl  -0x20(%ebp)
f0107fa2:	68 60 49 12 f0       	push   $0xf0124960
f0107fa7:	6a 68                	push   $0x68
f0107fa9:	68 43 49 12 f0       	push   $0xf0124943
f0107fae:	e8 86 83 ff ff       	call   f0100339 <_panic>
f0107fb3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107fb6:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107fbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107fbf:	01 d0                	add    %edx,%eax
f0107fc1:	48                   	dec    %eax
f0107fc2:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107fc5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107fc8:	ba 00 00 00 00       	mov    $0x0,%edx
f0107fcd:	f7 75 e4             	divl   -0x1c(%ebp)
f0107fd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107fd3:	29 d0                	sub    %edx,%eax
f0107fd5:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0107fd8:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0107fdf:	eb 1d                	jmp    f0107ffe <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f0107fe1:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f0107fe7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fea:	89 d0                	mov    %edx,%eax
f0107fec:	01 c0                	add    %eax,%eax
f0107fee:	01 d0                	add    %edx,%eax
f0107ff0:	c1 e0 03             	shl    $0x3,%eax
f0107ff3:	01 c8                	add    %ecx,%eax
f0107ff5:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0107ffb:	ff 45 f4             	incl   -0xc(%ebp)
f0107ffe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108001:	85 c0                	test   %eax,%eax
f0108003:	79 05                	jns    f010800a <initialize_paging+0x2a7>
f0108005:	05 ff 0f 00 00       	add    $0xfff,%eax
f010800a:	c1 f8 0c             	sar    $0xc,%eax
f010800d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108010:	7f cf                	jg     f0107fe1 <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108012:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108015:	85 c0                	test   %eax,%eax
f0108017:	79 05                	jns    f010801e <initialize_paging+0x2bb>
f0108019:	05 ff 0f 00 00       	add    $0xfff,%eax
f010801e:	c1 f8 0c             	sar    $0xc,%eax
f0108021:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108024:	e9 e8 00 00 00       	jmp    f0108111 <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108029:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f010802f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108032:	89 d0                	mov    %edx,%eax
f0108034:	01 c0                	add    %eax,%eax
f0108036:	01 d0                	add    %edx,%eax
f0108038:	c1 e0 03             	shl    $0x3,%eax
f010803b:	01 c8                	add    %ecx,%eax
f010803d:	83 ec 0c             	sub    $0xc,%esp
f0108040:	50                   	push   %eax
f0108041:	e8 e6 00 00 00       	call   f010812c <initialize_frame_info>
f0108046:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0108049:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f010804f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108052:	89 d0                	mov    %edx,%eax
f0108054:	01 c0                	add    %eax,%eax
f0108056:	01 d0                	add    %edx,%eax
f0108058:	c1 e0 03             	shl    $0x3,%eax
f010805b:	01 c8                	add    %ecx,%eax
f010805d:	85 c0                	test   %eax,%eax
f010805f:	75 14                	jne    f0108075 <initialize_paging+0x312>
f0108061:	83 ec 04             	sub    $0x4,%esp
f0108064:	68 20 49 12 f0       	push   $0xf0124920
f0108069:	6a 74                	push   $0x74
f010806b:	68 43 49 12 f0       	push   $0xf0124943
f0108070:	e8 c4 82 ff ff       	call   f0100339 <_panic>
f0108075:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f010807b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010807e:	89 d0                	mov    %edx,%eax
f0108080:	01 c0                	add    %eax,%eax
f0108082:	01 d0                	add    %edx,%eax
f0108084:	c1 e0 03             	shl    $0x3,%eax
f0108087:	01 c8                	add    %ecx,%eax
f0108089:	8b 15 60 43 5f f0    	mov    0xf05f4360,%edx
f010808f:	89 10                	mov    %edx,(%eax)
f0108091:	8b 00                	mov    (%eax),%eax
f0108093:	85 c0                	test   %eax,%eax
f0108095:	74 1f                	je     f01080b6 <initialize_paging+0x353>
f0108097:	8b 15 60 43 5f f0    	mov    0xf05f4360,%edx
f010809d:	8b 1d c0 47 5f f0    	mov    0xf05f47c0,%ebx
f01080a3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01080a6:	89 c8                	mov    %ecx,%eax
f01080a8:	01 c0                	add    %eax,%eax
f01080aa:	01 c8                	add    %ecx,%eax
f01080ac:	c1 e0 03             	shl    $0x3,%eax
f01080af:	01 d8                	add    %ebx,%eax
f01080b1:	89 42 04             	mov    %eax,0x4(%edx)
f01080b4:	eb 19                	jmp    f01080cf <initialize_paging+0x36c>
f01080b6:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f01080bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bf:	89 d0                	mov    %edx,%eax
f01080c1:	01 c0                	add    %eax,%eax
f01080c3:	01 d0                	add    %edx,%eax
f01080c5:	c1 e0 03             	shl    $0x3,%eax
f01080c8:	01 c8                	add    %ecx,%eax
f01080ca:	a3 64 43 5f f0       	mov    %eax,0xf05f4364
f01080cf:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f01080d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080d8:	89 d0                	mov    %edx,%eax
f01080da:	01 c0                	add    %eax,%eax
f01080dc:	01 d0                	add    %edx,%eax
f01080de:	c1 e0 03             	shl    $0x3,%eax
f01080e1:	01 c8                	add    %ecx,%eax
f01080e3:	a3 60 43 5f f0       	mov    %eax,0xf05f4360
f01080e8:	8b 0d c0 47 5f f0    	mov    0xf05f47c0,%ecx
f01080ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080f1:	89 d0                	mov    %edx,%eax
f01080f3:	01 c0                	add    %eax,%eax
f01080f5:	01 d0                	add    %edx,%eax
f01080f7:	c1 e0 03             	shl    $0x3,%eax
f01080fa:	01 c8                	add    %ecx,%eax
f01080fc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108103:	a1 6c 43 5f f0       	mov    0xf05f436c,%eax
f0108108:	40                   	inc    %eax
f0108109:	a3 6c 43 5f f0       	mov    %eax,0xf05f436c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010810e:	ff 45 f4             	incl   -0xc(%ebp)
f0108111:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108114:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f0108119:	39 c2                	cmp    %eax,%edx
f010811b:	0f 82 08 ff ff ff    	jb     f0108029 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f0108121:	e8 6b bb ff ff       	call   f0103c91 <initialize_disk_page_file>
}
f0108126:	90                   	nop
f0108127:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010812a:	c9                   	leave  
f010812b:	c3                   	ret    

f010812c <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f010812c:	55                   	push   %ebp
f010812d:	89 e5                	mov    %esp,%ebp
f010812f:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f0108132:	83 ec 04             	sub    $0x4,%esp
f0108135:	6a 18                	push   $0x18
f0108137:	6a 00                	push   $0x0
f0108139:	ff 75 08             	pushl  0x8(%ebp)
f010813c:	e8 fa 6b 01 00       	call   f011ed3b <memset>
f0108141:	83 c4 10             	add    $0x10,%esp
}
f0108144:	90                   	nop
f0108145:	c9                   	leave  
f0108146:	c3                   	ret    

f0108147 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f0108147:	55                   	push   %ebp
f0108148:	89 e5                	mov    %esp,%ebp
f010814a:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010814d:	83 ec 0c             	sub    $0xc,%esp
f0108150:	68 80 43 5f f0       	push   $0xf05f4380
f0108155:	e8 4b 6c 00 00       	call   f010eda5 <holding_spinlock>
f010815a:	83 c4 10             	add    $0x10,%esp
f010815d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0108160:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108164:	75 10                	jne    f0108176 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108166:	83 ec 0c             	sub    $0xc,%esp
f0108169:	68 80 43 5f f0       	push   $0xf05f4380
f010816e:	e8 19 6a 00 00       	call   f010eb8c <acquire_spinlock>
f0108173:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f0108176:	8b 15 60 43 5f f0    	mov    0xf05f4360,%edx
f010817c:	8b 45 08             	mov    0x8(%ebp),%eax
f010817f:	89 10                	mov    %edx,(%eax)
	int c = 0;
f0108181:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f0108188:	8b 45 08             	mov    0x8(%ebp),%eax
f010818b:	8b 00                	mov    (%eax),%eax
f010818d:	85 c0                	test   %eax,%eax
f010818f:	75 17                	jne    f01081a8 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f0108191:	83 ec 04             	sub    $0x4,%esp
f0108194:	68 94 49 12 f0       	push   $0xf0124994
f0108199:	68 a2 00 00 00       	push   $0xa2
f010819e:	68 43 49 12 f0       	push   $0xf0124943
f01081a3:	e8 91 81 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f01081a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ab:	8b 00                	mov    (%eax),%eax
f01081ad:	85 c0                	test   %eax,%eax
f01081af:	75 17                	jne    f01081c8 <allocate_frame+0x81>
f01081b1:	83 ec 04             	sub    $0x4,%esp
f01081b4:	68 e1 49 12 f0       	push   $0xf01249e1
f01081b9:	68 a8 00 00 00       	push   $0xa8
f01081be:	68 43 49 12 f0       	push   $0xf0124943
f01081c3:	e8 71 81 ff ff       	call   f0100339 <_panic>
f01081c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01081cb:	8b 00                	mov    (%eax),%eax
f01081cd:	8b 00                	mov    (%eax),%eax
f01081cf:	85 c0                	test   %eax,%eax
f01081d1:	74 14                	je     f01081e7 <allocate_frame+0xa0>
f01081d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081d6:	8b 00                	mov    (%eax),%eax
f01081d8:	8b 00                	mov    (%eax),%eax
f01081da:	8b 55 08             	mov    0x8(%ebp),%edx
f01081dd:	8b 12                	mov    (%edx),%edx
f01081df:	8b 52 04             	mov    0x4(%edx),%edx
f01081e2:	89 50 04             	mov    %edx,0x4(%eax)
f01081e5:	eb 0d                	jmp    f01081f4 <allocate_frame+0xad>
f01081e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ea:	8b 00                	mov    (%eax),%eax
f01081ec:	8b 40 04             	mov    0x4(%eax),%eax
f01081ef:	a3 64 43 5f f0       	mov    %eax,0xf05f4364
f01081f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f7:	8b 00                	mov    (%eax),%eax
f01081f9:	8b 40 04             	mov    0x4(%eax),%eax
f01081fc:	85 c0                	test   %eax,%eax
f01081fe:	74 13                	je     f0108213 <allocate_frame+0xcc>
f0108200:	8b 45 08             	mov    0x8(%ebp),%eax
f0108203:	8b 00                	mov    (%eax),%eax
f0108205:	8b 40 04             	mov    0x4(%eax),%eax
f0108208:	8b 55 08             	mov    0x8(%ebp),%edx
f010820b:	8b 12                	mov    (%edx),%edx
f010820d:	8b 12                	mov    (%edx),%edx
f010820f:	89 10                	mov    %edx,(%eax)
f0108211:	eb 0c                	jmp    f010821f <allocate_frame+0xd8>
f0108213:	8b 45 08             	mov    0x8(%ebp),%eax
f0108216:	8b 00                	mov    (%eax),%eax
f0108218:	8b 00                	mov    (%eax),%eax
f010821a:	a3 60 43 5f f0       	mov    %eax,0xf05f4360
f010821f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108222:	8b 00                	mov    (%eax),%eax
f0108224:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010822a:	8b 45 08             	mov    0x8(%ebp),%eax
f010822d:	8b 00                	mov    (%eax),%eax
f010822f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108236:	a1 6c 43 5f f0       	mov    0xf05f436c,%eax
f010823b:	48                   	dec    %eax
f010823c:	a3 6c 43 5f f0       	mov    %eax,0xf05f436c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f0108241:	8b 45 08             	mov    0x8(%ebp),%eax
f0108244:	8b 00                	mov    (%eax),%eax
f0108246:	8a 40 14             	mov    0x14(%eax),%al
f0108249:	84 c0                	test   %al,%al
f010824b:	74 20                	je     f010826d <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f010824d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108250:	8b 00                	mov    (%eax),%eax
f0108252:	8b 50 10             	mov    0x10(%eax),%edx
f0108255:	8b 45 08             	mov    0x8(%ebp),%eax
f0108258:	8b 00                	mov    (%eax),%eax
f010825a:	8b 40 0c             	mov    0xc(%eax),%eax
f010825d:	8b 40 64             	mov    0x64(%eax),%eax
f0108260:	83 ec 08             	sub    $0x8,%esp
f0108263:	52                   	push   %edx
f0108264:	50                   	push   %eax
f0108265:	e8 53 0f 00 00       	call   f01091bd <pt_clear_page_table_entry>
f010826a:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f010826d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108270:	8b 00                	mov    (%eax),%eax
f0108272:	83 ec 0c             	sub    $0xc,%esp
f0108275:	50                   	push   %eax
f0108276:	e8 b1 fe ff ff       	call   f010812c <initialize_frame_info>
f010827b:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f010827e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108282:	75 10                	jne    f0108294 <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108284:	83 ec 0c             	sub    $0xc,%esp
f0108287:	68 80 43 5f f0       	push   $0xf05f4380
f010828c:	e8 82 69 00 00       	call   f010ec13 <release_spinlock>
f0108291:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f0108294:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108299:	c9                   	leave  
f010829a:	c3                   	ret    

f010829b <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f010829b:	55                   	push   %ebp
f010829c:	89 e5                	mov    %esp,%ebp
f010829e:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01082a1:	83 ec 0c             	sub    $0xc,%esp
f01082a4:	68 80 43 5f f0       	push   $0xf05f4380
f01082a9:	e8 f7 6a 00 00       	call   f010eda5 <holding_spinlock>
f01082ae:	83 c4 10             	add    $0x10,%esp
f01082b1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01082b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082b8:	75 10                	jne    f01082ca <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01082ba:	83 ec 0c             	sub    $0xc,%esp
f01082bd:	68 80 43 5f f0       	push   $0xf05f4380
f01082c2:	e8 c5 68 00 00       	call   f010eb8c <acquire_spinlock>
f01082c7:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f01082ca:	83 ec 0c             	sub    $0xc,%esp
f01082cd:	ff 75 08             	pushl  0x8(%ebp)
f01082d0:	e8 57 fe ff ff       	call   f010812c <initialize_frame_info>
f01082d5:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f01082d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01082dc:	75 17                	jne    f01082f5 <free_frame+0x5a>
f01082de:	83 ec 04             	sub    $0x4,%esp
f01082e1:	68 20 49 12 f0       	push   $0xf0124920
f01082e6:	68 cf 00 00 00       	push   $0xcf
f01082eb:	68 43 49 12 f0       	push   $0xf0124943
f01082f0:	e8 44 80 ff ff       	call   f0100339 <_panic>
f01082f5:	8b 15 60 43 5f f0    	mov    0xf05f4360,%edx
f01082fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01082fe:	89 10                	mov    %edx,(%eax)
f0108300:	8b 45 08             	mov    0x8(%ebp),%eax
f0108303:	8b 00                	mov    (%eax),%eax
f0108305:	85 c0                	test   %eax,%eax
f0108307:	74 0d                	je     f0108316 <free_frame+0x7b>
f0108309:	a1 60 43 5f f0       	mov    0xf05f4360,%eax
f010830e:	8b 55 08             	mov    0x8(%ebp),%edx
f0108311:	89 50 04             	mov    %edx,0x4(%eax)
f0108314:	eb 08                	jmp    f010831e <free_frame+0x83>
f0108316:	8b 45 08             	mov    0x8(%ebp),%eax
f0108319:	a3 64 43 5f f0       	mov    %eax,0xf05f4364
f010831e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108321:	a3 60 43 5f f0       	mov    %eax,0xf05f4360
f0108326:	8b 45 08             	mov    0x8(%ebp),%eax
f0108329:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108330:	a1 6c 43 5f f0       	mov    0xf05f436c,%eax
f0108335:	40                   	inc    %eax
f0108336:	a3 6c 43 5f f0       	mov    %eax,0xf05f436c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f010833b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010833f:	75 10                	jne    f0108351 <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108341:	83 ec 0c             	sub    $0xc,%esp
f0108344:	68 80 43 5f f0       	push   $0xf05f4380
f0108349:	e8 c5 68 00 00       	call   f010ec13 <release_spinlock>
f010834e:	83 c4 10             	add    $0x10,%esp
	}
}
f0108351:	90                   	nop
f0108352:	c9                   	leave  
f0108353:	c3                   	ret    

f0108354 <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f0108354:	55                   	push   %ebp
f0108355:	89 e5                	mov    %esp,%ebp
f0108357:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f010835a:	8b 45 08             	mov    0x8(%ebp),%eax
f010835d:	8b 40 08             	mov    0x8(%eax),%eax
f0108360:	48                   	dec    %eax
f0108361:	8b 55 08             	mov    0x8(%ebp),%edx
f0108364:	66 89 42 08          	mov    %ax,0x8(%edx)
f0108368:	8b 45 08             	mov    0x8(%ebp),%eax
f010836b:	8b 40 08             	mov    0x8(%eax),%eax
f010836e:	66 85 c0             	test   %ax,%ax
f0108371:	75 0e                	jne    f0108381 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0108373:	83 ec 0c             	sub    $0xc,%esp
f0108376:	ff 75 08             	pushl  0x8(%ebp)
f0108379:	e8 1d ff ff ff       	call   f010829b <free_frame>
f010837e:	83 c4 10             	add    $0x10,%esp
}
f0108381:	90                   	nop
f0108382:	c9                   	leave  
f0108383:	c3                   	ret    

f0108384 <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108384:	55                   	push   %ebp
f0108385:	89 e5                	mov    %esp,%ebp
f0108387:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f010838a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010838d:	c1 e8 16             	shr    $0x16,%eax
f0108390:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108397:	8b 45 08             	mov    0x8(%ebp),%eax
f010839a:	01 d0                	add    %edx,%eax
f010839c:	8b 00                	mov    (%eax),%eax
f010839e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f01083a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083a4:	83 e0 01             	and    $0x1,%eax
f01083a7:	85 c0                	test   %eax,%eax
f01083a9:	74 74                	je     f010841f <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01083ab:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01083b2:	77 1d                	ja     f01083d1 <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01083b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01083bc:	83 ec 0c             	sub    $0xc,%esp
f01083bf:	50                   	push   %eax
f01083c0:	e8 c0 0c 00 00       	call   f0109085 <kheap_virtual_address>
f01083c5:	83 c4 10             	add    $0x10,%esp
f01083c8:	89 c2                	mov    %eax,%edx
f01083ca:	8b 45 10             	mov    0x10(%ebp),%eax
f01083cd:	89 10                	mov    %edx,(%eax)
f01083cf:	eb 44                	jmp    f0108415 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01083d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083d4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01083d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01083dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01083df:	c1 e8 0c             	shr    $0xc,%eax
f01083e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01083e5:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f01083ea:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01083ed:	72 17                	jb     f0108406 <get_page_table+0x82>
f01083ef:	ff 75 f0             	pushl  -0x10(%ebp)
f01083f2:	68 00 4a 12 f0       	push   $0xf0124a00
f01083f7:	68 fb 00 00 00       	push   $0xfb
f01083fc:	68 43 49 12 f0       	push   $0xf0124943
f0108401:	e8 33 7f ff ff       	call   f0100339 <_panic>
f0108406:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108409:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010840e:	89 c2                	mov    %eax,%edx
f0108410:	8b 45 10             	mov    0x10(%ebp),%eax
f0108413:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108415:	b8 00 00 00 00       	mov    $0x0,%eax
f010841a:	e9 b9 00 00 00       	jmp    f01084d8 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010841f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108423:	0f 84 a1 00 00 00    	je     f01084ca <get_page_table+0x146>
f0108429:	8b 45 0c             	mov    0xc(%ebp),%eax
f010842c:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010842f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108432:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0108435:	83 ec 0c             	sub    $0xc,%esp
f0108438:	6a 00                	push   $0x0
f010843a:	e8 d1 63 00 00       	call   f010e810 <fault_handler>
f010843f:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108442:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108445:	c1 e8 16             	shr    $0x16,%eax
f0108448:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010844f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108452:	01 d0                	add    %edx,%eax
f0108454:	8b 00                	mov    (%eax),%eax
f0108456:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108459:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108460:	77 1d                	ja     f010847f <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108462:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108465:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010846a:	83 ec 0c             	sub    $0xc,%esp
f010846d:	50                   	push   %eax
f010846e:	e8 12 0c 00 00       	call   f0109085 <kheap_virtual_address>
f0108473:	83 c4 10             	add    $0x10,%esp
f0108476:	89 c2                	mov    %eax,%edx
f0108478:	8b 45 10             	mov    0x10(%ebp),%eax
f010847b:	89 10                	mov    %edx,(%eax)
f010847d:	eb 44                	jmp    f01084c3 <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010847f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108482:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108487:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010848a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010848d:	c1 e8 0c             	shr    $0xc,%eax
f0108490:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108493:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f0108498:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010849b:	72 17                	jb     f01084b4 <get_page_table+0x130>
f010849d:	ff 75 e8             	pushl  -0x18(%ebp)
f01084a0:	68 00 4a 12 f0       	push   $0xf0124a00
f01084a5:	68 13 01 00 00       	push   $0x113
f01084aa:	68 43 49 12 f0       	push   $0xf0124943
f01084af:	e8 85 7e ff ff       	call   f0100339 <_panic>
f01084b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084b7:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01084bc:	89 c2                	mov    %eax,%edx
f01084be:	8b 45 10             	mov    0x10(%ebp),%eax
f01084c1:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f01084c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01084c8:	eb 0e                	jmp    f01084d8 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f01084ca:	8b 45 10             	mov    0x10(%ebp),%eax
f01084cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f01084d3:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f01084d8:	c9                   	leave  
f01084d9:	c3                   	ret    

f01084da <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f01084da:	55                   	push   %ebp
f01084db:	89 e5                	mov    %esp,%ebp
f01084dd:	53                   	push   %ebx
f01084de:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f01084e1:	83 ec 0c             	sub    $0xc,%esp
f01084e4:	68 00 10 00 00       	push   $0x1000
f01084e9:	e8 a2 08 00 00       	call   f0108d90 <kmalloc>
f01084ee:	83 c4 10             	add    $0x10,%esp
f01084f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f01084f4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01084f8:	75 17                	jne    f0108511 <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f01084fa:	83 ec 04             	sub    $0x4,%esp
f01084fd:	68 2f 4a 12 f0       	push   $0xf0124a2f
f0108502:	68 33 01 00 00       	push   $0x133
f0108507:	68 43 49 12 f0       	push   $0xf0124943
f010850c:	e8 28 7e ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f0108511:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108514:	c1 e8 16             	shr    $0x16,%eax
f0108517:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010851e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108521:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f0108524:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108527:	83 ec 0c             	sub    $0xc,%esp
f010852a:	50                   	push   %eax
f010852b:	e8 24 0b 00 00       	call   f0109054 <kheap_physical_address>
f0108530:	83 c4 10             	add    $0x10,%esp
f0108533:	83 c8 07             	or     $0x7,%eax
f0108536:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f0108538:	83 ec 04             	sub    $0x4,%esp
f010853b:	68 00 10 00 00       	push   $0x1000
f0108540:	6a 00                	push   $0x0
f0108542:	ff 75 f4             	pushl  -0xc(%ebp)
f0108545:	e8 f1 67 01 00       	call   f011ed3b <memset>
f010854a:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010854d:	0f 20 d8             	mov    %cr3,%eax
f0108550:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108553:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108556:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f0108559:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010855c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010855f:	c9                   	leave  
f0108560:	c3                   	ret    

f0108561 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108561:	55                   	push   %ebp
f0108562:	89 e5                	mov    %esp,%ebp
f0108564:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0108567:	83 ec 0c             	sub    $0xc,%esp
f010856a:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010856d:	50                   	push   %eax
f010856e:	e8 d4 fb ff ff       	call   f0108147 <allocate_frame>
f0108573:	83 c4 10             	add    $0x10,%esp
f0108576:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f0108579:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010857c:	83 ec 0c             	sub    $0xc,%esp
f010857f:	50                   	push   %eax
f0108580:	e8 70 f7 ff ff       	call   f0107cf5 <to_physical_address>
f0108585:	83 c4 10             	add    $0x10,%esp
f0108588:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f010858b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010858e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108591:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108594:	c1 e8 0c             	shr    $0xc,%eax
f0108597:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010859a:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f010859f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f01085a2:	72 17                	jb     f01085bb <__static_cpt+0x5a>
f01085a4:	ff 75 ec             	pushl  -0x14(%ebp)
f01085a7:	68 00 4a 12 f0       	push   $0xf0124a00
f01085ac:	68 4e 01 00 00       	push   $0x14e
f01085b1:	68 43 49 12 f0       	push   $0xf0124943
f01085b6:	e8 7e 7d ff ff       	call   f0100339 <_panic>
f01085bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01085be:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01085c3:	89 c2                	mov    %eax,%edx
f01085c5:	8b 45 10             	mov    0x10(%ebp),%eax
f01085c8:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f01085ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085cd:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f01085d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01085d6:	c1 e8 16             	shr    $0x16,%eax
f01085d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01085e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01085e3:	01 d0                	add    %edx,%eax
f01085e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01085e8:	83 ca 07             	or     $0x7,%edx
f01085eb:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f01085ed:	8b 45 10             	mov    0x10(%ebp),%eax
f01085f0:	8b 00                	mov    (%eax),%eax
f01085f2:	83 ec 04             	sub    $0x4,%esp
f01085f5:	68 00 10 00 00       	push   $0x1000
f01085fa:	6a 00                	push   $0x0
f01085fc:	50                   	push   %eax
f01085fd:	e8 39 67 01 00       	call   f011ed3b <memset>
f0108602:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108605:	0f 20 d8             	mov    %cr3,%eax
f0108608:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010860b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010860e:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0108611:	90                   	nop
f0108612:	c9                   	leave  
f0108613:	c3                   	ret    

f0108614 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108614:	55                   	push   %ebp
f0108615:	89 e5                	mov    %esp,%ebp
f0108617:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f010861a:	ff 75 0c             	pushl  0xc(%ebp)
f010861d:	e8 d3 f6 ff ff       	call   f0107cf5 <to_physical_address>
f0108622:	83 c4 04             	add    $0x4,%esp
f0108625:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108628:	83 ec 04             	sub    $0x4,%esp
f010862b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f010862e:	50                   	push   %eax
f010862f:	ff 75 10             	pushl  0x10(%ebp)
f0108632:	ff 75 08             	pushl  0x8(%ebp)
f0108635:	e8 4a fd ff ff       	call   f0108384 <get_page_table>
f010863a:	83 c4 10             	add    $0x10,%esp
f010863d:	83 f8 01             	cmp    $0x1,%eax
f0108640:	75 1b                	jne    f010865d <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f0108642:	83 ec 08             	sub    $0x8,%esp
f0108645:	ff 75 10             	pushl  0x10(%ebp)
f0108648:	ff 75 08             	pushl  0x8(%ebp)
f010864b:	e8 8a fe ff ff       	call   f01084da <create_page_table>
f0108650:	83 c4 10             	add    $0x10,%esp
f0108653:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f0108656:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f010865d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108660:	8b 55 10             	mov    0x10(%ebp),%edx
f0108663:	c1 ea 0c             	shr    $0xc,%edx
f0108666:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010866c:	c1 e2 02             	shl    $0x2,%edx
f010866f:	01 d0                	add    %edx,%eax
f0108671:	8b 00                	mov    (%eax),%eax
f0108673:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108676:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108679:	83 e0 01             	and    $0x1,%eax
f010867c:	85 c0                	test   %eax,%eax
f010867e:	74 25                	je     f01086a5 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0108680:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108683:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108688:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010868b:	75 07                	jne    f0108694 <map_frame+0x80>
			return 0;
f010868d:	b8 00 00 00 00       	mov    $0x0,%eax
f0108692:	eb 68                	jmp    f01086fc <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0108694:	83 ec 08             	sub    $0x8,%esp
f0108697:	ff 75 10             	pushl  0x10(%ebp)
f010869a:	ff 75 08             	pushl  0x8(%ebp)
f010869d:	e8 d2 00 00 00       	call   f0108774 <unmap_frame>
f01086a2:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f01086a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01086a8:	8b 40 08             	mov    0x8(%eax),%eax
f01086ab:	40                   	inc    %eax
f01086ac:	8b 55 0c             	mov    0xc(%ebp),%edx
f01086af:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f01086b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086b6:	8b 55 10             	mov    0x10(%ebp),%edx
f01086b9:	c1 ea 0c             	shr    $0xc,%edx
f01086bc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086c2:	c1 e2 02             	shl    $0x2,%edx
f01086c5:	01 d0                	add    %edx,%eax
f01086c7:	8b 00                	mov    (%eax),%eax
f01086c9:	25 00 0e 00 00       	and    $0xe00,%eax
f01086ce:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f01086d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086d4:	8b 55 10             	mov    0x10(%ebp),%edx
f01086d7:	c1 ea 0c             	shr    $0xc,%edx
f01086da:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086e0:	c1 e2 02             	shl    $0x2,%edx
f01086e3:	01 c2                	add    %eax,%edx
f01086e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086e8:	0b 45 e8             	or     -0x18(%ebp),%eax
f01086eb:	89 c1                	mov    %eax,%ecx
f01086ed:	8b 45 14             	mov    0x14(%ebp),%eax
f01086f0:	09 c8                	or     %ecx,%eax
f01086f2:	83 c8 01             	or     $0x1,%eax
f01086f5:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f01086f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01086fc:	c9                   	leave  
f01086fd:	c3                   	ret    

f01086fe <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f01086fe:	55                   	push   %ebp
f01086ff:	89 e5                	mov    %esp,%ebp
f0108701:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f0108704:	83 ec 04             	sub    $0x4,%esp
f0108707:	ff 75 10             	pushl  0x10(%ebp)
f010870a:	ff 75 0c             	pushl  0xc(%ebp)
f010870d:	ff 75 08             	pushl  0x8(%ebp)
f0108710:	e8 6f fc ff ff       	call   f0108384 <get_page_table>
f0108715:	83 c4 10             	add    $0x10,%esp
f0108718:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f010871b:	8b 45 10             	mov    0x10(%ebp),%eax
f010871e:	8b 00                	mov    (%eax),%eax
f0108720:	85 c0                	test   %eax,%eax
f0108722:	74 49                	je     f010876d <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f0108724:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108727:	c1 e8 0c             	shr    $0xc,%eax
f010872a:	25 ff 03 00 00       	and    $0x3ff,%eax
f010872f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0108732:	8b 45 10             	mov    0x10(%ebp),%eax
f0108735:	8b 00                	mov    (%eax),%eax
f0108737:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010873a:	c1 e2 02             	shl    $0x2,%edx
f010873d:	01 d0                	add    %edx,%eax
f010873f:	8b 00                	mov    (%eax),%eax
f0108741:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f0108744:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108747:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010874c:	85 c0                	test   %eax,%eax
f010874e:	74 16                	je     f0108766 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f0108750:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108753:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108758:	83 ec 0c             	sub    $0xc,%esp
f010875b:	50                   	push   %eax
f010875c:	e8 a7 f5 ff ff       	call   f0107d08 <to_frame_info>
f0108761:	83 c4 10             	add    $0x10,%esp
f0108764:	eb 0c                	jmp    f0108772 <get_frame_info+0x74>
		}
		return 0;
f0108766:	b8 00 00 00 00       	mov    $0x0,%eax
f010876b:	eb 05                	jmp    f0108772 <get_frame_info+0x74>
	}
	return 0;
f010876d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108772:	c9                   	leave  
f0108773:	c3                   	ret    

f0108774 <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0108774:	55                   	push   %ebp
f0108775:	89 e5                	mov    %esp,%ebp
f0108777:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f010877a:	83 ec 04             	sub    $0x4,%esp
f010877d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0108780:	50                   	push   %eax
f0108781:	ff 75 0c             	pushl  0xc(%ebp)
f0108784:	ff 75 08             	pushl  0x8(%ebp)
f0108787:	e8 72 ff ff ff       	call   f01086fe <get_frame_info>
f010878c:	83 c4 10             	add    $0x10,%esp
f010878f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f0108792:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108796:	74 7d                	je     f0108815 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108798:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010879b:	8a 40 14             	mov    0x14(%eax),%al
f010879e:	84 c0                	test   %al,%al
f01087a0:	74 1c                	je     f01087be <unmap_frame+0x4a>
f01087a2:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01087a9:	77 13                	ja     f01087be <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f01087ab:	83 ec 08             	sub    $0x8,%esp
f01087ae:	ff 75 0c             	pushl  0xc(%ebp)
f01087b1:	68 4c 4a 12 f0       	push   $0xf0124a4c
f01087b6:	e8 d0 87 ff ff       	call   f0100f8b <cprintf>
f01087bb:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f01087be:	83 ec 0c             	sub    $0xc,%esp
f01087c1:	ff 75 f4             	pushl  -0xc(%ebp)
f01087c4:	e8 8b fb ff ff       	call   f0108354 <decrement_references>
f01087c9:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f01087cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087cf:	8b 55 0c             	mov    0xc(%ebp),%edx
f01087d2:	c1 ea 0c             	shr    $0xc,%edx
f01087d5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01087db:	c1 e2 02             	shl    $0x2,%edx
f01087de:	01 d0                	add    %edx,%eax
f01087e0:	8b 00                	mov    (%eax),%eax
f01087e2:	25 00 0e 00 00       	and    $0xe00,%eax
f01087e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f01087ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087ed:	8b 55 0c             	mov    0xc(%ebp),%edx
f01087f0:	c1 ea 0c             	shr    $0xc,%edx
f01087f3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01087f9:	c1 e2 02             	shl    $0x2,%edx
f01087fc:	01 c2                	add    %eax,%edx
f01087fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108801:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f0108803:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108806:	83 ec 08             	sub    $0x8,%esp
f0108809:	50                   	push   %eax
f010880a:	ff 75 08             	pushl  0x8(%ebp)
f010880d:	e8 3c f5 ff ff       	call   f0107d4e <tlb_invalidate>
f0108812:	83 c4 10             	add    $0x10,%esp
	}
}
f0108815:	90                   	nop
f0108816:	c9                   	leave  
f0108817:	c3                   	ret    

f0108818 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108818:	55                   	push   %ebp
f0108819:	89 e5                	mov    %esp,%ebp
f010881b:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f010881e:	ff 75 0c             	pushl  0xc(%ebp)
f0108821:	e8 cf f4 ff ff       	call   f0107cf5 <to_physical_address>
f0108826:	83 c4 04             	add    $0x4,%esp
f0108829:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f010882c:	8b 45 10             	mov    0x10(%ebp),%eax
f010882f:	c1 e8 16             	shr    $0x16,%eax
f0108832:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108839:	8b 45 08             	mov    0x8(%ebp),%eax
f010883c:	01 d0                	add    %edx,%eax
f010883e:	8b 00                	mov    (%eax),%eax
f0108840:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108843:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010884a:	77 19                	ja     f0108865 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010884c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010884f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108854:	83 ec 0c             	sub    $0xc,%esp
f0108857:	50                   	push   %eax
f0108858:	e8 28 08 00 00       	call   f0109085 <kheap_virtual_address>
f010885d:	83 c4 10             	add    $0x10,%esp
f0108860:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108863:	eb 40                	jmp    f01088a5 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108865:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108868:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010886d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108870:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108873:	c1 e8 0c             	shr    $0xc,%eax
f0108876:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108879:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f010887e:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108881:	72 17                	jb     f010889a <loadtime_map_frame+0x82>
f0108883:	ff 75 e8             	pushl  -0x18(%ebp)
f0108886:	68 00 4a 12 f0       	push   $0xf0124a00
f010888b:	68 fa 01 00 00       	push   $0x1fa
f0108890:	68 43 49 12 f0       	push   $0xf0124943
f0108895:	e8 9f 7a ff ff       	call   f0100339 <_panic>
f010889a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010889d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01088a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f01088a5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01088a9:	75 14                	jne    f01088bf <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f01088ab:	83 ec 08             	sub    $0x8,%esp
f01088ae:	ff 75 10             	pushl  0x10(%ebp)
f01088b1:	ff 75 08             	pushl  0x8(%ebp)
f01088b4:	e8 21 fc ff ff       	call   f01084da <create_page_table>
f01088b9:	83 c4 10             	add    $0x10,%esp
f01088bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f01088bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01088c2:	8b 40 08             	mov    0x8(%eax),%eax
f01088c5:	40                   	inc    %eax
f01088c6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01088c9:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f01088cd:	8b 45 10             	mov    0x10(%ebp),%eax
f01088d0:	c1 e8 0c             	shr    $0xc,%eax
f01088d3:	25 ff 03 00 00       	and    $0x3ff,%eax
f01088d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088e2:	01 c2                	add    %eax,%edx
f01088e4:	8b 45 14             	mov    0x14(%ebp),%eax
f01088e7:	0b 45 f0             	or     -0x10(%ebp),%eax
f01088ea:	83 c8 01             	or     $0x1,%eax
f01088ed:	89 02                	mov    %eax,(%edx)

	return 0;
f01088ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01088f4:	c9                   	leave  
f01088f5:	c3                   	ret    

f01088f6 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f01088f6:	55                   	push   %ebp
f01088f7:	89 e5                	mov    %esp,%ebp
f01088f9:	57                   	push   %edi
f01088fa:	56                   	push   %esi
f01088fb:	53                   	push   %ebx
f01088fc:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f01088ff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108906:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f010890d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f0108914:	83 ec 0c             	sub    $0xc,%esp
f0108917:	68 80 43 5f f0       	push   $0xf05f4380
f010891c:	e8 84 64 00 00       	call   f010eda5 <holding_spinlock>
f0108921:	83 c4 10             	add    $0x10,%esp
f0108924:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108927:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010892b:	75 10                	jne    f010893d <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f010892d:	83 ec 0c             	sub    $0xc,%esp
f0108930:	68 80 43 5f f0       	push   $0xf05f4380
f0108935:	e8 52 62 00 00       	call   f010eb8c <acquire_spinlock>
f010893a:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f010893d:	a1 60 43 5f f0       	mov    0xf05f4360,%eax
f0108942:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108945:	eb 1a                	jmp    f0108961 <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0108947:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010894a:	8a 40 14             	mov    0x14(%eax),%al
f010894d:	84 c0                	test   %al,%al
f010894f:	74 05                	je     f0108956 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f0108951:	ff 45 dc             	incl   -0x24(%ebp)
f0108954:	eb 03                	jmp    f0108959 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0108956:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108959:	a1 68 43 5f f0       	mov    0xf05f4368,%eax
f010895e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108961:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108965:	74 07                	je     f010896e <calculate_available_frames+0x78>
f0108967:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010896a:	8b 00                	mov    (%eax),%eax
f010896c:	eb 05                	jmp    f0108973 <calculate_available_frames+0x7d>
f010896e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108973:	a3 68 43 5f f0       	mov    %eax,0xf05f4368
f0108978:	a1 68 43 5f f0       	mov    0xf05f4368,%eax
f010897d:	85 c0                	test   %eax,%eax
f010897f:	75 c6                	jne    f0108947 <calculate_available_frames+0x51>
f0108981:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108985:	75 c0                	jne    f0108947 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0108987:	a1 7c 43 5f f0       	mov    0xf05f437c,%eax
f010898c:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f010898f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108993:	75 10                	jne    f01089a5 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108995:	83 ec 0c             	sub    $0xc,%esp
f0108998:	68 80 43 5f f0       	push   $0xf05f4380
f010899d:	e8 71 62 00 00       	call   f010ec13 <release_spinlock>
f01089a2:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f01089a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01089a8:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f01089ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01089ae:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f01089b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01089b4:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f01089b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01089ba:	89 c3                	mov    %eax,%ebx
f01089bc:	8d 45 c8             	lea    -0x38(%ebp),%eax
f01089bf:	ba 03 00 00 00       	mov    $0x3,%edx
f01089c4:	89 df                	mov    %ebx,%edi
f01089c6:	89 c6                	mov    %eax,%esi
f01089c8:	89 d1                	mov    %edx,%ecx
f01089ca:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f01089cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01089cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01089d2:	5b                   	pop    %ebx
f01089d3:	5e                   	pop    %esi
f01089d4:	5f                   	pop    %edi
f01089d5:	5d                   	pop    %ebp
f01089d6:	c2 04 00             	ret    $0x4

f01089d9 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f01089d9:	55                   	push   %ebp
f01089da:	89 e5                	mov    %esp,%ebp
f01089dc:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f01089df:	c7 05 20 42 5f f0 00 	movl   $0x0,0xf05f4220
f01089e6:	00 00 00 
f01089e9:	c7 05 24 42 5f f0 00 	movl   $0x0,0xf05f4224
f01089f0:	00 00 00 
f01089f3:	c7 05 2c 42 5f f0 00 	movl   $0x0,0xf05f422c
f01089fa:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f01089fd:	83 ec 08             	sub    $0x8,%esp
f0108a00:	68 7c 4a 12 f0       	push   $0xf0124a7c
f0108a05:	68 30 42 5f f0       	push   $0xf05f4230
f0108a0a:	e8 4c 61 00 00       	call   f010eb5b <init_spinlock>
f0108a0f:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108a12:	90                   	nop
f0108a13:	c9                   	leave  
f0108a14:	c3                   	ret    

f0108a15 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a15:	55                   	push   %ebp
f0108a16:	89 e5                	mov    %esp,%ebp
f0108a18:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a1b:	83 ec 08             	sub    $0x8,%esp
f0108a1e:	ff 75 0c             	pushl  0xc(%ebp)
f0108a21:	ff 75 08             	pushl  0x8(%ebp)
f0108a24:	e8 55 00 00 00       	call   f0108a7e <get_share>
f0108a29:	83 c4 10             	add    $0x10,%esp
f0108a2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a2f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a33:	75 07                	jne    f0108a3c <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108a35:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108a3a:	eb 06                	jmp    f0108a42 <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a3f:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108a42:	c9                   	leave  
f0108a43:	c3                   	ret    

f0108a44 <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108a44:	55                   	push   %ebp
f0108a45:	89 e5                	mov    %esp,%ebp
f0108a47:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_frames_storage is not implemented yet");
f0108a4a:	83 ec 04             	sub    $0x4,%esp
f0108a4d:	68 88 4a 12 f0       	push   $0xf0124a88
f0108a52:	6a 45                	push   $0x45
f0108a54:	68 b8 4a 12 f0       	push   $0xf0124ab8
f0108a59:	e8 db 78 ff ff       	call   f0100339 <_panic>

f0108a5e <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108a5e:	55                   	push   %ebp
f0108a5f:	89 e5                	mov    %esp,%ebp
f0108a61:	83 ec 18             	sub    $0x18,%esp
f0108a64:	8b 45 14             	mov    0x14(%ebp),%eax
f0108a67:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_share is not implemented yet");
f0108a6a:	83 ec 04             	sub    $0x4,%esp
f0108a6d:	68 dc 4a 12 f0       	push   $0xf0124adc
f0108a72:	6a 54                	push   $0x54
f0108a74:	68 b8 4a 12 f0       	push   $0xf0124ab8
f0108a79:	e8 bb 78 ff ff       	call   f0100339 <_panic>

f0108a7e <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108a7e:	55                   	push   %ebp
f0108a7f:	89 e5                	mov    %esp,%ebp
f0108a81:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("get_share is not implemented yet");
f0108a84:	83 ec 04             	sub    $0x4,%esp
f0108a87:	68 00 4b 12 f0       	push   $0xf0124b00
f0108a8c:	6a 64                	push   $0x64
f0108a8e:	68 b8 4a 12 f0       	push   $0xf0124ab8
f0108a93:	e8 a1 78 ff ff       	call   f0100339 <_panic>

f0108a98 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108a98:	55                   	push   %ebp
f0108a99:	89 e5                	mov    %esp,%ebp
f0108a9b:	83 ec 18             	sub    $0x18,%esp
f0108a9e:	8b 45 14             	mov    0x14(%ebp),%eax
f0108aa1:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("createSharedObject is not implemented yet");
f0108aa4:	83 ec 04             	sub    $0x4,%esp
f0108aa7:	68 24 4b 12 f0       	push   $0xf0124b24
f0108aac:	6a 70                	push   $0x70
f0108aae:	68 b8 4a 12 f0       	push   $0xf0124ab8
f0108ab3:	e8 81 78 ff ff       	call   f0100339 <_panic>

f0108ab8 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108ab8:	55                   	push   %ebp
f0108ab9:	89 e5                	mov    %esp,%ebp
f0108abb:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("getSharedObject is not implemented yet");
f0108abe:	83 ec 04             	sub    $0x4,%esp
f0108ac1:	68 50 4b 12 f0       	push   $0xf0124b50
f0108ac6:	6a 7e                	push   $0x7e
f0108ac8:	68 b8 4a 12 f0       	push   $0xf0124ab8
f0108acd:	e8 67 78 ff ff       	call   f0100339 <_panic>

f0108ad2 <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108ad2:	55                   	push   %ebp
f0108ad3:	89 e5                	mov    %esp,%ebp
f0108ad5:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f0108ad8:	83 ec 04             	sub    $0x4,%esp
f0108adb:	68 78 4b 12 f0       	push   $0xf0124b78
f0108ae0:	68 91 00 00 00       	push   $0x91
f0108ae5:	68 b8 4a 12 f0       	push   $0xf0124ab8
f0108aea:	e8 4a 78 ff ff       	call   f0100339 <_panic>

f0108aef <freeSharedObject>:
}
//========================
// [B2] Free Share Object:
//========================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108aef:	55                   	push   %ebp
f0108af0:	89 e5                	mov    %esp,%ebp
f0108af2:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f0108af5:	83 ec 04             	sub    $0x4,%esp
f0108af8:	68 9c 4b 12 f0       	push   $0xf0124b9c
f0108afd:	68 9c 00 00 00       	push   $0x9c
f0108b02:	68 b8 4a 12 f0       	push   $0xf0124ab8
f0108b07:	e8 2d 78 ff ff       	call   f0100339 <_panic>

f0108b0c <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0108b0c:	55                   	push   %ebp
f0108b0d:	89 e5                	mov    %esp,%ebp
f0108b0f:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f0108b14:	83 f8 01             	cmp    $0x1,%eax
f0108b17:	75 04                	jne    f0108b1d <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0108b19:	b0 01                	mov    $0x1,%al
f0108b1b:	eb 02                	jmp    f0108b1f <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0108b1d:	b0 00                	mov    $0x0,%al
f0108b1f:	5d                   	pop    %ebp
f0108b20:	c3                   	ret    

f0108b21 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0108b21:	55                   	push   %ebp
f0108b22:	89 e5                	mov    %esp,%ebp
f0108b24:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f0108b29:	83 f8 02             	cmp    $0x2,%eax
f0108b2c:	75 04                	jne    f0108b32 <isKHeapPlacementStrategyBESTFIT+0x11>
f0108b2e:	b0 01                	mov    $0x1,%al
f0108b30:	eb 02                	jmp    f0108b34 <isKHeapPlacementStrategyBESTFIT+0x13>
f0108b32:	b0 00                	mov    $0x0,%al
f0108b34:	5d                   	pop    %ebp
f0108b35:	c3                   	ret    

f0108b36 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108b36:	55                   	push   %ebp
f0108b37:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108b39:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b3c:	8b 15 c0 47 5f f0    	mov    0xf05f47c0,%edx
f0108b42:	29 d0                	sub    %edx,%eax
f0108b44:	c1 f8 03             	sar    $0x3,%eax
f0108b47:	89 c2                	mov    %eax,%edx
f0108b49:	89 d0                	mov    %edx,%eax
f0108b4b:	c1 e0 02             	shl    $0x2,%eax
f0108b4e:	01 d0                	add    %edx,%eax
f0108b50:	c1 e0 02             	shl    $0x2,%eax
f0108b53:	01 d0                	add    %edx,%eax
f0108b55:	c1 e0 02             	shl    $0x2,%eax
f0108b58:	01 d0                	add    %edx,%eax
f0108b5a:	89 c1                	mov    %eax,%ecx
f0108b5c:	c1 e1 08             	shl    $0x8,%ecx
f0108b5f:	01 c8                	add    %ecx,%eax
f0108b61:	89 c1                	mov    %eax,%ecx
f0108b63:	c1 e1 10             	shl    $0x10,%ecx
f0108b66:	01 c8                	add    %ecx,%eax
f0108b68:	01 c0                	add    %eax,%eax
f0108b6a:	01 d0                	add    %edx,%eax
}
f0108b6c:	5d                   	pop    %ebp
f0108b6d:	c3                   	ret    

f0108b6e <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0108b6e:	55                   	push   %ebp
f0108b6f:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0108b71:	ff 75 08             	pushl  0x8(%ebp)
f0108b74:	e8 bd ff ff ff       	call   f0108b36 <to_frame_number>
f0108b79:	83 c4 04             	add    $0x4,%esp
f0108b7c:	c1 e0 0c             	shl    $0xc,%eax
}
f0108b7f:	c9                   	leave  
f0108b80:	c3                   	ret    

f0108b81 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0108b81:	55                   	push   %ebp
f0108b82:	89 e5                	mov    %esp,%ebp
f0108b84:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0108b87:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b8a:	c1 e8 0c             	shr    $0xc,%eax
f0108b8d:	89 c2                	mov    %eax,%edx
f0108b8f:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f0108b94:	39 c2                	cmp    %eax,%edx
f0108b96:	72 14                	jb     f0108bac <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0108b98:	83 ec 04             	sub    $0x4,%esp
f0108b9b:	68 c4 4b 12 f0       	push   $0xf0124bc4
f0108ba0:	6a 56                	push   $0x56
f0108ba2:	68 e9 4b 12 f0       	push   $0xf0124be9
f0108ba7:	e8 8d 77 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0108bac:	8b 15 c0 47 5f f0    	mov    0xf05f47c0,%edx
f0108bb2:	8b 45 08             	mov    0x8(%ebp),%eax
f0108bb5:	c1 e8 0c             	shr    $0xc,%eax
f0108bb8:	89 c1                	mov    %eax,%ecx
f0108bba:	89 c8                	mov    %ecx,%eax
f0108bbc:	01 c0                	add    %eax,%eax
f0108bbe:	01 c8                	add    %ecx,%eax
f0108bc0:	c1 e0 03             	shl    $0x3,%eax
f0108bc3:	01 d0                	add    %edx,%eax
}
f0108bc5:	c9                   	leave  
f0108bc6:	c3                   	ret    

f0108bc7 <initialize_kheap_dynamic_allocator>:
//Remember: call the initialize_dynamic_allocator(..) to complete the initialization
//Return:
//	On success: 0
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0108bc7:	55                   	push   %ebp
f0108bc8:	89 e5                	mov    %esp,%ebp
f0108bca:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f0108bcd:	8b 45 08             	mov    0x8(%ebp),%eax
f0108bd0:	a3 08 4a 5f f0       	mov    %eax,0xf05f4a08
	hard_limit = daLimit;
f0108bd5:	8b 45 10             	mov    0x10(%ebp),%eax
f0108bd8:	a3 54 48 5f f0       	mov    %eax,0xf05f4854
	brk = daStart + initSizeToAllocate;
f0108bdd:	8b 55 08             	mov    0x8(%ebp),%edx
f0108be0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108be3:	01 d0                	add    %edx,%eax
f0108be5:	a3 00 4a 5f f0       	mov    %eax,0xf05f4a00

	if(brk > daLimit) panic("exceeds Limit");
f0108bea:	a1 00 4a 5f f0       	mov    0xf05f4a00,%eax
f0108bef:	3b 45 10             	cmp    0x10(%ebp),%eax
f0108bf2:	76 14                	jbe    f0108c08 <initialize_kheap_dynamic_allocator+0x41>
f0108bf4:	83 ec 04             	sub    $0x4,%esp
f0108bf7:	68 03 4c 12 f0       	push   $0xf0124c03
f0108bfc:	6a 16                	push   $0x16
f0108bfe:	68 11 4c 12 f0       	push   $0xf0124c11
f0108c03:	e8 31 77 ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f0108c08:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f0108c0f:	8b 45 10             	mov    0x10(%ebp),%eax
f0108c12:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 /*struct FrameInfo * start_page_area = (struct FrameInfo*) (daLimit + PAGE_SIZE);
	 struct FrameInfo * end_page_area = (struct FrameInfo*) KERNEL_HEAP_MAX;*/

	 uint32 page_area_size = initSizeToAllocate;
f0108c15:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c18:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f0108c1b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108c1e:	c1 e8 0c             	shr    $0xc,%eax
f0108c21:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f0108c24:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108c2b:	eb 54                	jmp    f0108c81 <initialize_kheap_dynamic_allocator+0xba>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f0108c2d:	83 ec 0c             	sub    $0xc,%esp
f0108c30:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0108c33:	50                   	push   %eax
f0108c34:	e8 0e f5 ff ff       	call   f0108147 <allocate_frame>
f0108c39:	83 c4 10             	add    $0x10,%esp
f0108c3c:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f0108c3f:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f0108c43:	74 28                	je     f0108c6d <initialize_kheap_dynamic_allocator+0xa6>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_USER|PERM_WRITEABLE);
f0108c45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c48:	c1 e0 0c             	shl    $0xc,%eax
f0108c4b:	89 c2                	mov    %eax,%edx
f0108c4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c50:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0108c53:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0108c56:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0108c5b:	6a 06                	push   $0x6
f0108c5d:	51                   	push   %ecx
f0108c5e:	52                   	push   %edx
f0108c5f:	50                   	push   %eax
f0108c60:	e8 af f9 ff ff       	call   f0108614 <map_frame>
f0108c65:	83 c4 10             	add    $0x10,%esp

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0108c68:	ff 45 f4             	incl   -0xc(%ebp)
f0108c6b:	eb 14                	jmp    f0108c81 <initialize_kheap_dynamic_allocator+0xba>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_USER|PERM_WRITEABLE);
		}
		else
		{
			panic("No Memory");
f0108c6d:	83 ec 04             	sub    $0x4,%esp
f0108c70:	68 22 4c 12 f0       	push   $0xf0124c22
f0108c75:	6a 2c                	push   $0x2c
f0108c77:	68 11 4c 12 f0       	push   $0xf0124c11
f0108c7c:	e8 b8 76 ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0108c81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c84:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0108c87:	72 a4                	jb     f0108c2d <initialize_kheap_dynamic_allocator+0x66>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f0108c89:	83 ec 08             	sub    $0x8,%esp
f0108c8c:	ff 75 0c             	pushl  0xc(%ebp)
f0108c8f:	ff 75 08             	pushl  0x8(%ebp)
f0108c92:	e8 85 6a 01 00       	call   f011f71c <initialize_dynamic_allocator>
f0108c97:	83 c4 10             	add    $0x10,%esp

	return 0;
f0108c9a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c9f:	c9                   	leave  
f0108ca0:	c3                   	ret    

f0108ca1 <sbrk>:

void* sbrk(int numOfPages)
{
f0108ca1:	55                   	push   %ebp
f0108ca2:	89 e5                	mov    %esp,%ebp
f0108ca4:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f0108ca7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108cab:	0f 8e 99 00 00 00    	jle    f0108d4a <sbrk+0xa9>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f0108cb1:	8b 45 08             	mov    0x8(%ebp),%eax
f0108cb4:	c1 e0 0c             	shl    $0xc,%eax
f0108cb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f0108cba:	a1 00 4a 5f f0       	mov    0xf05f4a00,%eax
f0108cbf:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f0108cc2:	8b 15 00 4a 5f f0    	mov    0xf05f4a00,%edx
f0108cc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ccb:	01 c2                	add    %eax,%edx
f0108ccd:	a1 54 48 5f f0       	mov    0xf05f4854,%eax
f0108cd2:	39 c2                	cmp    %eax,%edx
f0108cd4:	76 07                	jbe    f0108cdd <sbrk+0x3c>
f0108cd6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108cdb:	eb 7f                	jmp    f0108d5c <sbrk+0xbb>

		for(int i=0;i<numOfPages;i++)
f0108cdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108ce4:	eb 47                	jmp    f0108d2d <sbrk+0x8c>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f0108ce6:	83 ec 0c             	sub    $0xc,%esp
f0108ce9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108cec:	50                   	push   %eax
f0108ced:	e8 55 f4 ff ff       	call   f0108147 <allocate_frame>
f0108cf2:	83 c4 10             	add    $0x10,%esp
f0108cf5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f0108cf8:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0108cfc:	74 28                	je     f0108d26 <sbrk+0x85>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_USER|PERM_WRITEABLE);
f0108cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d01:	c1 e0 0c             	shl    $0xc,%eax
f0108d04:	89 c2                	mov    %eax,%edx
f0108d06:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d09:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0108d0c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108d0f:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0108d14:	6a 06                	push   $0x6
f0108d16:	51                   	push   %ecx
f0108d17:	52                   	push   %edx
f0108d18:	50                   	push   %eax
f0108d19:	e8 f6 f8 ff ff       	call   f0108614 <map_frame>
f0108d1e:	83 c4 10             	add    $0x10,%esp
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0108d21:	ff 45 f4             	incl   -0xc(%ebp)
f0108d24:	eb 07                	jmp    f0108d2d <sbrk+0x8c>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_USER|PERM_WRITEABLE);
			}
			else
			{
				return (void *)-1;
f0108d26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108d2b:	eb 2f                	jmp    f0108d5c <sbrk+0xbb>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0108d2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d30:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108d33:	7c b1                	jl     f0108ce6 <sbrk+0x45>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f0108d35:	8b 15 00 4a 5f f0    	mov    0xf05f4a00,%edx
f0108d3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d3e:	01 d0                	add    %edx,%eax
f0108d40:	a3 00 4a 5f f0       	mov    %eax,0xf05f4a00
		return (void *)prev_brk;
f0108d45:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d48:	eb 12                	jmp    f0108d5c <sbrk+0xbb>

	}
	else if(numOfPages == 0)
f0108d4a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108d4e:	75 07                	jne    f0108d57 <sbrk+0xb6>
	{
		return (void *) brk;
f0108d50:	a1 00 4a 5f f0       	mov    0xf05f4a00,%eax
f0108d55:	eb 05                	jmp    f0108d5c <sbrk+0xbb>
	}

	//panic("can't be negative");
	return (void *)-1;
f0108d57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0108d5c:	c9                   	leave  
f0108d5d:	c3                   	ret    

f0108d5e <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator

bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f0108d5e:	55                   	push   %ebp
f0108d5f:	89 e5                	mov    %esp,%ebp
f0108d61:	83 ec 18             	sub    $0x18,%esp

	uint32 page_permissions = pt_get_page_permissions(ptr_page_directory, virtual_address);
f0108d64:	83 ec 08             	sub    $0x8,%esp
f0108d67:	ff 75 0c             	pushl  0xc(%ebp)
f0108d6a:	ff 75 08             	pushl  0x8(%ebp)
f0108d6d:	e8 02 04 00 00       	call   f0109174 <pt_get_page_permissions>
f0108d72:	83 c4 10             	add    $0x10,%esp
f0108d75:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("page_permissions : %d \n",page_permissions & PERM_PRESENT);
	if ((page_permissions & PERM_PRESENT) == PERM_PRESENT)
f0108d78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d7b:	83 e0 01             	and    $0x1,%eax
f0108d7e:	85 c0                	test   %eax,%eax
f0108d80:	74 07                	je     f0108d89 <isPageAllocated+0x2b>
    {
    	return 1;
f0108d82:	b8 01 00 00 00       	mov    $0x1,%eax
f0108d87:	eb 05                	jmp    f0108d8e <isPageAllocated+0x30>
    }
    return 0;
f0108d89:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0108d8e:	c9                   	leave  
f0108d8f:	c3                   	ret    

f0108d90 <kmalloc>:


void *kmalloc(unsigned int size)
{
f0108d90:	55                   	push   %ebp
f0108d91:	89 e5                	mov    %esp,%ebp
f0108d93:	83 ec 58             	sub    $0x58,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108d96:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f0108d9d:	8b 55 08             	mov    0x8(%ebp),%edx
f0108da0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108da3:	01 d0                	add    %edx,%eax
f0108da5:	48                   	dec    %eax
f0108da6:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0108da9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108dac:	ba 00 00 00 00       	mov    $0x0,%edx
f0108db1:	f7 75 dc             	divl   -0x24(%ebp)
f0108db4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108db7:	29 d0                	sub    %edx,%eax
f0108db9:	c1 e8 0c             	shr    $0xc,%eax
f0108dbc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f0108dbf:	c7 45 d0 00 10 00 00 	movl   $0x1000,-0x30(%ebp)
f0108dc6:	a1 54 48 5f f0       	mov    0xf05f4854,%eax
f0108dcb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0108dce:	29 c2                	sub    %eax,%edx
f0108dd0:	89 d0                	mov    %edx,%eax
f0108dd2:	48                   	dec    %eax
f0108dd3:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0108dd6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0108dd9:	ba 00 00 00 00       	mov    $0x0,%edx
f0108dde:	f7 75 d0             	divl   -0x30(%ebp)
f0108de1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0108de4:	29 d0                	sub    %edx,%eax
f0108de6:	c1 e8 0c             	shr    $0xc,%eax
f0108de9:	89 45 c8             	mov    %eax,-0x38(%ebp)

	void *ptr = NULL;
f0108dec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0108df3:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0108dfa:	77 3c                	ja     f0108e38 <kmalloc+0xa8>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f0108dfc:	e8 0b fd ff ff       	call   f0108b0c <isKHeapPlacementStrategyFIRSTFIT>
f0108e01:	84 c0                	test   %al,%al
f0108e03:	74 13                	je     f0108e18 <kmalloc+0x88>
			return alloc_block_FF(size);
f0108e05:	83 ec 0c             	sub    $0xc,%esp
f0108e08:	ff 75 08             	pushl  0x8(%ebp)
f0108e0b:	e8 54 6b 01 00       	call   f011f964 <alloc_block_FF>
f0108e10:	83 c4 10             	add    $0x10,%esp
f0108e13:	e9 8c 01 00 00       	jmp    f0108fa4 <kmalloc+0x214>
		else if (isKHeapPlacementStrategyBESTFIT())
f0108e18:	e8 04 fd ff ff       	call   f0108b21 <isKHeapPlacementStrategyBESTFIT>
f0108e1d:	84 c0                	test   %al,%al
f0108e1f:	0f 84 7c 01 00 00    	je     f0108fa1 <kmalloc+0x211>
			return alloc_block_BF(size);
f0108e25:	83 ec 0c             	sub    $0xc,%esp
f0108e28:	ff 75 08             	pushl  0x8(%ebp)
f0108e2b:	e8 f0 6f 01 00       	call   f011fe20 <alloc_block_BF>
f0108e30:	83 c4 10             	add    $0x10,%esp
f0108e33:	e9 6c 01 00 00       	jmp    f0108fa4 <kmalloc+0x214>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f0108e38:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0108e3b:	48                   	dec    %eax
f0108e3c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0108e3f:	0f 86 55 01 00 00    	jbe    f0108f9a <kmalloc+0x20a>
	{
		// required pages?
		uint32 no_of_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108e45:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0108e4c:	8b 55 08             	mov    0x8(%ebp),%edx
f0108e4f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0108e52:	01 d0                	add    %edx,%eax
f0108e54:	48                   	dec    %eax
f0108e55:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0108e58:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0108e5b:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e60:	f7 75 c4             	divl   -0x3c(%ebp)
f0108e63:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0108e66:	29 d0                	sub    %edx,%eax
f0108e68:	c1 e8 0c             	shr    $0xc,%eax
f0108e6b:	89 45 bc             	mov    %eax,-0x44(%ebp)

		uint32 i = hard_limit + (uint32)PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f0108e6e:	a1 54 48 5f f0       	mov    0xf05f4854,%eax
f0108e73:	05 00 10 00 00       	add    $0x1000,%eax
f0108e78:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f0108e7b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f0108e82:	e9 86 00 00 00       	jmp    f0108f0d <kmalloc+0x17d>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f0108e87:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0108e8c:	83 ec 08             	sub    $0x8,%esp
f0108e8f:	ff 75 f0             	pushl  -0x10(%ebp)
f0108e92:	50                   	push   %eax
f0108e93:	e8 c6 fe ff ff       	call   f0108d5e <isPageAllocated>
f0108e98:	83 c4 10             	add    $0x10,%esp
f0108e9b:	85 c0                	test   %eax,%eax
f0108e9d:	75 61                	jne    f0108f00 <kmalloc+0x170>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f0108e9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ea2:	05 00 10 00 00       	add    $0x1000,%eax
f0108ea7:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f0108eaa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < no_of_pages - 1)
f0108eb1:	eb 3d                	jmp    f0108ef0 <kmalloc+0x160>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) return NULL;
f0108eb3:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f0108eba:	76 0a                	jbe    f0108ec6 <kmalloc+0x136>
f0108ebc:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ec1:	e9 de 00 00 00       	jmp    f0108fa4 <kmalloc+0x214>
					if (isPageAllocated(ptr_page_directory, j))
f0108ec6:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0108ecb:	83 ec 08             	sub    $0x8,%esp
f0108ece:	ff 75 e8             	pushl  -0x18(%ebp)
f0108ed1:	50                   	push   %eax
f0108ed2:	e8 87 fe ff ff       	call   f0108d5e <isPageAllocated>
f0108ed7:	83 c4 10             	add    $0x10,%esp
f0108eda:	85 c0                	test   %eax,%eax
f0108edc:	74 08                	je     f0108ee6 <kmalloc+0x156>
					{

						i = j;
f0108ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ee1:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f0108ee4:	eb 1a                	jmp    f0108f00 <kmalloc+0x170>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f0108ee6:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f0108eed:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < no_of_pages - 1)
f0108ef0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0108ef3:	48                   	dec    %eax
f0108ef4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0108ef7:	77 ba                	ja     f0108eb3 <kmalloc+0x123>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f0108ef9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f0108f00:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108f04:	75 16                	jne    f0108f1c <kmalloc+0x18c>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f0108f06:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
		// required pages?
		uint32 no_of_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

		uint32 i = hard_limit + (uint32)PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f0108f0d:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f0108f14:	0f 86 6d ff ff ff    	jbe    f0108e87 <kmalloc+0xf7>
f0108f1a:	eb 01                	jmp    f0108f1d <kmalloc+0x18d>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f0108f1c:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
f0108f1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108f21:	75 07                	jne    f0108f2a <kmalloc+0x19a>
f0108f23:	b8 00 00 00 00       	mov    $0x0,%eax
f0108f28:	eb 7a                	jmp    f0108fa4 <kmalloc+0x214>
		for (int k = 0; k < no_of_pages; k++)
f0108f2a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0108f31:	eb 57                	jmp    f0108f8a <kmalloc+0x1fa>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f0108f33:	83 ec 0c             	sub    $0xc,%esp
f0108f36:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0108f39:	50                   	push   %eax
f0108f3a:	e8 08 f2 ff ff       	call   f0108147 <allocate_frame>
f0108f3f:	83 c4 10             	add    $0x10,%esp
f0108f42:	89 45 b8             	mov    %eax,-0x48(%ebp)
			//map_frame(ptr_page_directory, ptr_frame_info, i + k * 1024, PERM_USER|PERM_WRITEABLE); REPLACED BY
			if (ret != E_NO_MEM)
f0108f45:	83 7d b8 fc          	cmpl   $0xfffffffc,-0x48(%ebp)
f0108f49:	74 28                	je     f0108f73 <kmalloc+0x1e3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE, PERM_PRESENT | PERM_WRITEABLE); // a3raf el page mnen
f0108f4b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108f4e:	c1 e0 0c             	shl    $0xc,%eax
f0108f51:	89 c2                	mov    %eax,%edx
f0108f53:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f56:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0108f59:	8b 55 b4             	mov    -0x4c(%ebp),%edx
f0108f5c:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0108f61:	6a 03                	push   $0x3
f0108f63:	51                   	push   %ecx
f0108f64:	52                   	push   %edx
f0108f65:	50                   	push   %eax
f0108f66:	e8 a9 f6 ff ff       	call   f0108614 <map_frame>
f0108f6b:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < no_of_pages; k++)
f0108f6e:	ff 45 e0             	incl   -0x20(%ebp)
f0108f71:	eb 17                	jmp    f0108f8a <kmalloc+0x1fa>
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE, PERM_PRESENT | PERM_WRITEABLE); // a3raf el page mnen

			}
			else
			{
				panic("No Memory");
f0108f73:	83 ec 04             	sub    $0x4,%esp
f0108f76:	68 22 4c 12 f0       	push   $0xf0124c22
f0108f7b:	68 bd 00 00 00       	push   $0xbd
f0108f80:	68 11 4c 12 f0       	push   $0xf0124c11
f0108f85:	e8 af 73 ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < no_of_pages; k++)
f0108f8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108f8d:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0108f90:	72 a1                	jb     f0108f33 <kmalloc+0x1a3>
			else
			{
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f0108f92:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f95:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f98:	eb 07                	jmp    f0108fa1 <kmalloc+0x211>

	}
	else
	{

		return NULL;
f0108f9a:	b8 00 00 00 00       	mov    $0x0,%eax
f0108f9f:	eb 03                	jmp    f0108fa4 <kmalloc+0x214>
	}
	return ptr;
f0108fa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108fa4:	c9                   	leave  
f0108fa5:	c3                   	ret    

f0108fa6 <kfree>:

void kfree(void *va)
{
f0108fa6:	55                   	push   %ebp
f0108fa7:	89 e5                	mov    %esp,%ebp
f0108fa9:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + 4096;
f0108fac:	a1 54 48 5f f0       	mov    0xf05f4854,%eax
f0108fb1:	05 00 10 00 00       	add    $0x1000,%eax
f0108fb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((uint32)va < hard_limit){
f0108fb9:	8b 55 08             	mov    0x8(%ebp),%edx
f0108fbc:	a1 54 48 5f f0       	mov    0xf05f4854,%eax
f0108fc1:	39 c2                	cmp    %eax,%edx
f0108fc3:	73 10                	jae    f0108fd5 <kfree+0x2f>
        free_block(va);
f0108fc5:	83 ec 0c             	sub    $0xc,%esp
f0108fc8:	ff 75 08             	pushl  0x8(%ebp)
f0108fcb:	e8 58 78 01 00       	call   f0120828 <free_block>
f0108fd0:	83 c4 10             	add    $0x10,%esp
        }
    }else{
        panic("kfree: The virtual Address is invalid");
    }

}
f0108fd3:	eb 7c                	jmp    f0109051 <kfree+0xab>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + 4096;
    if((uint32)va < hard_limit){
        free_block(va);
    }else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0108fd5:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fd8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108fdb:	72 5c                	jb     f0109039 <kfree+0x93>
f0108fdd:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fe0:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0108fe5:	77 52                	ja     f0109039 <kfree+0x93>
        void* ptr_page_table = NULL;
f0108fe7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, (uint32)va, ptr_page_table);
f0108fee:	8b 55 08             	mov    0x8(%ebp),%edx
f0108ff1:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0108ff6:	83 ec 04             	sub    $0x4,%esp
f0108ff9:	ff 75 f0             	pushl  -0x10(%ebp)
f0108ffc:	52                   	push   %edx
f0108ffd:	50                   	push   %eax
f0108ffe:	e8 fb f6 ff ff       	call   f01086fe <get_frame_info>
f0109003:	83 c4 10             	add    $0x10,%esp
f0109006:	89 45 ec             	mov    %eax,-0x14(%ebp)
        unmap_frame(ptr_page_directory, (uint32)va);
f0109009:	8b 55 08             	mov    0x8(%ebp),%edx
f010900c:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0109011:	83 ec 08             	sub    $0x8,%esp
f0109014:	52                   	push   %edx
f0109015:	50                   	push   %eax
f0109016:	e8 59 f7 ff ff       	call   f0108774 <unmap_frame>
f010901b:	83 c4 10             	add    $0x10,%esp
        if(ptr_frame_info->references == 0){
f010901e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109021:	8b 40 08             	mov    0x8(%eax),%eax
f0109024:	66 85 c0             	test   %ax,%ax
f0109027:	75 27                	jne    f0109050 <kfree+0xaa>
            free_frame(ptr_frame_info);
f0109029:	83 ec 0c             	sub    $0xc,%esp
f010902c:	ff 75 ec             	pushl  -0x14(%ebp)
f010902f:	e8 67 f2 ff ff       	call   f010829b <free_frame>
f0109034:	83 c4 10             	add    $0x10,%esp
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + 4096;
    if((uint32)va < hard_limit){
        free_block(va);
    }else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109037:	eb 17                	jmp    f0109050 <kfree+0xaa>
        unmap_frame(ptr_page_directory, (uint32)va);
        if(ptr_frame_info->references == 0){
            free_frame(ptr_frame_info);
        }
    }else{
        panic("kfree: The virtual Address is invalid");
f0109039:	83 ec 04             	sub    $0x4,%esp
f010903c:	68 2c 4c 12 f0       	push   $0xf0124c2c
f0109041:	68 de 00 00 00       	push   $0xde
f0109046:	68 11 4c 12 f0       	push   $0xf0124c11
f010904b:	e8 e9 72 ff ff       	call   f0100339 <_panic>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + 4096;
    if((uint32)va < hard_limit){
        free_block(va);
    }else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109050:	90                   	nop
        }
    }else{
        panic("kfree: The virtual Address is invalid");
    }

}
f0109051:	90                   	nop
f0109052:	c9                   	leave  
f0109053:	c3                   	ret    

f0109054 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0109054:	55                   	push   %ebp
f0109055:	89 e5                	mov    %esp,%ebp
f0109057:	83 ec 18             	sub    $0x18,%esp
	//return the physical address corresponding to given virtual_address
	//refer to the project presentation and documentation for details

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	uint32 * ptr_page_table;
	struct FrameInfo * frame_va = get_frame_info(ptr_page_directory,virtual_address,&ptr_page_table);
f010905a:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f010905f:	83 ec 04             	sub    $0x4,%esp
f0109062:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0109065:	52                   	push   %edx
f0109066:	ff 75 08             	pushl  0x8(%ebp)
f0109069:	50                   	push   %eax
f010906a:	e8 8f f6 ff ff       	call   f01086fe <get_frame_info>
f010906f:	83 c4 10             	add    $0x10,%esp
f0109072:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return to_physical_address(frame_va);
f0109075:	83 ec 0c             	sub    $0xc,%esp
f0109078:	ff 75 f4             	pushl  -0xc(%ebp)
f010907b:	e8 ee fa ff ff       	call   f0108b6e <to_physical_address>
f0109080:	83 c4 10             	add    $0x10,%esp

}
f0109083:	c9                   	leave  
f0109084:	c3                   	ret    

f0109085 <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0109085:	55                   	push   %ebp
f0109086:	89 e5                	mov    %esp,%ebp
f0109088:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #06] [1] KERNEL HEAP - kheap_virtual_address
	// Write your code here, remove the panic and write your code
	//panic("kheap_virtual_address() is not implemented yet...!!");

	struct FrameInfo * frame_va = to_frame_info(physical_address);
f010908b:	83 ec 0c             	sub    $0xc,%esp
f010908e:	ff 75 08             	pushl  0x8(%ebp)
f0109091:	e8 eb fa ff ff       	call   f0108b81 <to_frame_info>
f0109096:	83 c4 10             	add    $0x10,%esp
f0109099:	89 45 f4             	mov    %eax,-0xc(%ebp)

	return physical_address - KERNEL_BASE;
f010909c:	8b 45 08             	mov    0x8(%ebp),%eax
f010909f:	05 00 00 00 10       	add    $0x10000000,%eax

	//return the virtual address corresponding to given physical_address
	//refer to the project presentation and documentation for details

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
}
f01090a4:	c9                   	leave  
f01090a5:	c3                   	ret    

f01090a6 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f01090a6:	55                   	push   %ebp
f01090a7:	89 e5                	mov    %esp,%ebp
	//TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	// Write your code here, remove the panic and write your code
	return NULL;
f01090a9:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f01090ae:	5d                   	pop    %ebp
f01090af:	c3                   	ret    

f01090b0 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f01090b0:	55                   	push   %ebp
f01090b1:	89 e5                	mov    %esp,%ebp
f01090b3:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01090b6:	83 ec 04             	sub    $0x4,%esp
f01090b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01090bc:	50                   	push   %eax
f01090bd:	ff 75 0c             	pushl  0xc(%ebp)
f01090c0:	ff 75 08             	pushl  0x8(%ebp)
f01090c3:	e8 bc f2 ff ff       	call   f0108384 <get_page_table>
f01090c8:	83 c4 10             	add    $0x10,%esp
f01090cb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f01090ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090d1:	85 c0                	test   %eax,%eax
f01090d3:	74 64                	je     f0109139 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f01090d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090d8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01090db:	c1 ea 0c             	shr    $0xc,%edx
f01090de:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01090e4:	c1 e2 02             	shl    $0x2,%edx
f01090e7:	01 c2                	add    %eax,%edx
f01090e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01090ef:	c1 e9 0c             	shr    $0xc,%ecx
f01090f2:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f01090f8:	c1 e1 02             	shl    $0x2,%ecx
f01090fb:	01 c8                	add    %ecx,%eax
f01090fd:	8b 00                	mov    (%eax),%eax
f01090ff:	0b 45 10             	or     0x10(%ebp),%eax
f0109102:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109104:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109107:	8b 55 0c             	mov    0xc(%ebp),%edx
f010910a:	c1 ea 0c             	shr    $0xc,%edx
f010910d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109113:	c1 e2 02             	shl    $0x2,%edx
f0109116:	01 d0                	add    %edx,%eax
f0109118:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010911b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010911e:	c1 e9 0c             	shr    $0xc,%ecx
f0109121:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109127:	c1 e1 02             	shl    $0x2,%ecx
f010912a:	01 ca                	add    %ecx,%edx
f010912c:	8b 12                	mov    (%edx),%edx
f010912e:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109131:	f7 d1                	not    %ecx
f0109133:	21 ca                	and    %ecx,%edx
f0109135:	89 10                	mov    %edx,(%eax)
f0109137:	eb 27                	jmp    f0109160 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109139:	83 ec 08             	sub    $0x8,%esp
f010913c:	ff 75 0c             	pushl  0xc(%ebp)
f010913f:	68 54 4c 12 f0       	push   $0xf0124c54
f0109144:	e8 42 7e ff ff       	call   f0100f8b <cprintf>
f0109149:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010914c:	83 ec 04             	sub    $0x4,%esp
f010914f:	68 7c 4c 12 f0       	push   $0xf0124c7c
f0109154:	6a 1c                	push   $0x1c
f0109156:	68 f0 4c 12 f0       	push   $0xf0124cf0
f010915b:	e8 d9 71 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109160:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109163:	83 ec 08             	sub    $0x8,%esp
f0109166:	50                   	push   %eax
f0109167:	6a 00                	push   $0x0
f0109169:	e8 e0 eb ff ff       	call   f0107d4e <tlb_invalidate>
f010916e:	83 c4 10             	add    $0x10,%esp
}
f0109171:	90                   	nop
f0109172:	c9                   	leave  
f0109173:	c3                   	ret    

f0109174 <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f0109174:	55                   	push   %ebp
f0109175:	89 e5                	mov    %esp,%ebp
f0109177:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010917a:	83 ec 04             	sub    $0x4,%esp
f010917d:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109180:	50                   	push   %eax
f0109181:	ff 75 0c             	pushl  0xc(%ebp)
f0109184:	ff 75 08             	pushl  0x8(%ebp)
f0109187:	e8 f8 f1 ff ff       	call   f0108384 <get_page_table>
f010918c:	83 c4 10             	add    $0x10,%esp
f010918f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0109192:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109195:	85 c0                	test   %eax,%eax
f0109197:	74 1d                	je     f01091b6 <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0109199:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010919c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010919f:	c1 ea 0c             	shr    $0xc,%edx
f01091a2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01091a8:	c1 e2 02             	shl    $0x2,%edx
f01091ab:	01 d0                	add    %edx,%eax
f01091ad:	8b 00                	mov    (%eax),%eax
f01091af:	25 ff 0f 00 00       	and    $0xfff,%eax
f01091b4:	eb 05                	jmp    f01091bb <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f01091b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f01091bb:	c9                   	leave  
f01091bc:	c3                   	ret    

f01091bd <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f01091bd:	55                   	push   %ebp
f01091be:	89 e5                	mov    %esp,%ebp
f01091c0:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01091c3:	83 ec 04             	sub    $0x4,%esp
f01091c6:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01091c9:	50                   	push   %eax
f01091ca:	ff 75 0c             	pushl  0xc(%ebp)
f01091cd:	ff 75 08             	pushl  0x8(%ebp)
f01091d0:	e8 af f1 ff ff       	call   f0108384 <get_page_table>
f01091d5:	83 c4 10             	add    $0x10,%esp
f01091d8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f01091db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091de:	85 c0                	test   %eax,%eax
f01091e0:	74 46                	je     f0109228 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f01091e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091e5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01091e8:	c1 ea 0c             	shr    $0xc,%edx
f01091eb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01091f1:	c1 e2 02             	shl    $0x2,%edx
f01091f4:	01 d0                	add    %edx,%eax
f01091f6:	8b 00                	mov    (%eax),%eax
f01091f8:	83 ec 04             	sub    $0x4,%esp
f01091fb:	50                   	push   %eax
f01091fc:	ff 75 0c             	pushl  0xc(%ebp)
f01091ff:	68 0c 4d 12 f0       	push   $0xf0124d0c
f0109204:	e8 82 7d ff ff       	call   f0100f8b <cprintf>
f0109209:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f010920c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010920f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109212:	c1 ea 0c             	shr    $0xc,%edx
f0109215:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010921b:	c1 e2 02             	shl    $0x2,%edx
f010921e:	01 d0                	add    %edx,%eax
f0109220:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109226:	eb 14                	jmp    f010923c <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109228:	83 ec 04             	sub    $0x4,%esp
f010922b:	68 34 4d 12 f0       	push   $0xf0124d34
f0109230:	6a 47                	push   $0x47
f0109232:	68 f0 4c 12 f0       	push   $0xf0124cf0
f0109237:	e8 fd 70 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010923c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010923f:	83 ec 08             	sub    $0x8,%esp
f0109242:	50                   	push   %eax
f0109243:	6a 00                	push   $0x0
f0109245:	e8 04 eb ff ff       	call   f0107d4e <tlb_invalidate>
f010924a:	83 c4 10             	add    $0x10,%esp
}
f010924d:	90                   	nop
f010924e:	c9                   	leave  
f010924f:	c3                   	ret    

f0109250 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0109250:	55                   	push   %ebp
f0109251:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0109253:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109256:	c1 e8 16             	shr    $0x16,%eax
f0109259:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109260:	8b 45 08             	mov    0x8(%ebp),%eax
f0109263:	01 d0                	add    %edx,%eax
f0109265:	8b 00                	mov    (%eax),%eax
f0109267:	83 e0 20             	and    $0x20,%eax
f010926a:	85 c0                	test   %eax,%eax
f010926c:	0f 95 c0             	setne  %al
f010926f:	0f b6 c0             	movzbl %al,%eax
}
f0109272:	5d                   	pop    %ebp
f0109273:	c3                   	ret    

f0109274 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f0109274:	55                   	push   %ebp
f0109275:	89 e5                	mov    %esp,%ebp
f0109277:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f010927a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010927d:	c1 e8 16             	shr    $0x16,%eax
f0109280:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109287:	8b 45 08             	mov    0x8(%ebp),%eax
f010928a:	01 d0                	add    %edx,%eax
f010928c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010928f:	c1 ea 16             	shr    $0x16,%edx
f0109292:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0109299:	8b 55 08             	mov    0x8(%ebp),%edx
f010929c:	01 ca                	add    %ecx,%edx
f010929e:	8b 12                	mov    (%edx),%edx
f01092a0:	83 e2 df             	and    $0xffffffdf,%edx
f01092a3:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01092a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092a8:	83 ec 08             	sub    $0x8,%esp
f01092ab:	50                   	push   %eax
f01092ac:	6a 00                	push   $0x0
f01092ae:	e8 9b ea ff ff       	call   f0107d4e <tlb_invalidate>
f01092b3:	83 c4 10             	add    $0x10,%esp
}
f01092b6:	90                   	nop
f01092b7:	c9                   	leave  
f01092b8:	c3                   	ret    

f01092b9 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f01092b9:	55                   	push   %ebp
f01092ba:	89 e5                	mov    %esp,%ebp
f01092bc:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f01092bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092c2:	c1 e8 16             	shr    $0x16,%eax
f01092c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01092cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01092cf:	01 d0                	add    %edx,%eax
f01092d1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01092d7:	0f 20 d8             	mov    %cr3,%eax
f01092da:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01092dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01092e0:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01092e3:	90                   	nop
f01092e4:	c9                   	leave  
f01092e5:	c3                   	ret    

f01092e6 <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f01092e6:	55                   	push   %ebp
f01092e7:	89 e5                	mov    %esp,%ebp
f01092e9:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("env_page_ws_list_create_element is not implemented yet");
f01092ec:	83 ec 04             	sub    $0x4,%esp
f01092ef:	68 ac 4d 12 f0       	push   $0xf0124dac
f01092f4:	6a 16                	push   $0x16
f01092f6:	68 e4 4d 12 f0       	push   $0xf0124de4
f01092fb:	e8 39 70 ff ff       	call   f0100339 <_panic>

f0109300 <env_page_ws_invalidate>:
	//Your Code is Here...

}
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109300:	55                   	push   %ebp
f0109301:	89 e5                	mov    %esp,%ebp
f0109303:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109306:	83 ec 0c             	sub    $0xc,%esp
f0109309:	6a 02                	push   $0x2
f010930b:	e8 1b 54 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f0109310:	83 c4 10             	add    $0x10,%esp
f0109313:	85 c0                	test   %eax,%eax
f0109315:	0f 84 e5 03 00 00    	je     f0109700 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f010931b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f0109322:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109329:	8b 45 08             	mov    0x8(%ebp),%eax
f010932c:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f0109332:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109335:	e9 3b 02 00 00       	jmp    f0109575 <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010933a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010933d:	8b 00                	mov    (%eax),%eax
f010933f:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109342:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109345:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010934a:	89 c2                	mov    %eax,%edx
f010934c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010934f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109352:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109355:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010935a:	39 c2                	cmp    %eax,%edx
f010935c:	0f 85 07 02 00 00    	jne    f0109569 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f0109362:	8b 45 08             	mov    0x8(%ebp),%eax
f0109365:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010936b:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010936e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109371:	8b 10                	mov    (%eax),%edx
f0109373:	8b 45 08             	mov    0x8(%ebp),%eax
f0109376:	8b 40 64             	mov    0x64(%eax),%eax
f0109379:	83 ec 08             	sub    $0x8,%esp
f010937c:	52                   	push   %edx
f010937d:	50                   	push   %eax
f010937e:	e8 f1 f3 ff ff       	call   f0108774 <unmap_frame>
f0109383:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f0109386:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010938a:	75 14                	jne    f01093a0 <env_page_ws_invalidate+0xa0>
f010938c:	83 ec 04             	sub    $0x4,%esp
f010938f:	68 03 4e 12 f0       	push   $0xf0124e03
f0109394:	6a 27                	push   $0x27
f0109396:	68 e4 4d 12 f0       	push   $0xf0124de4
f010939b:	e8 99 6f ff ff       	call   f0100339 <_panic>
f01093a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093a3:	8b 40 10             	mov    0x10(%eax),%eax
f01093a6:	85 c0                	test   %eax,%eax
f01093a8:	74 11                	je     f01093bb <env_page_ws_invalidate+0xbb>
f01093aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093ad:	8b 40 10             	mov    0x10(%eax),%eax
f01093b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01093b3:	8b 52 14             	mov    0x14(%edx),%edx
f01093b6:	89 50 14             	mov    %edx,0x14(%eax)
f01093b9:	eb 0f                	jmp    f01093ca <env_page_ws_invalidate+0xca>
f01093bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093be:	8b 50 14             	mov    0x14(%eax),%edx
f01093c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01093c4:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f01093ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093cd:	8b 40 14             	mov    0x14(%eax),%eax
f01093d0:	85 c0                	test   %eax,%eax
f01093d2:	74 11                	je     f01093e5 <env_page_ws_invalidate+0xe5>
f01093d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093d7:	8b 40 14             	mov    0x14(%eax),%eax
f01093da:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01093dd:	8b 52 10             	mov    0x10(%edx),%edx
f01093e0:	89 50 10             	mov    %edx,0x10(%eax)
f01093e3:	eb 0f                	jmp    f01093f4 <env_page_ws_invalidate+0xf4>
f01093e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093e8:	8b 50 10             	mov    0x10(%eax),%edx
f01093eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01093ee:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f01093f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093f7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01093fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109401:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109408:	8b 45 08             	mov    0x8(%ebp),%eax
f010940b:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109411:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109414:	8b 45 08             	mov    0x8(%ebp),%eax
f0109417:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010941d:	83 ec 0c             	sub    $0xc,%esp
f0109420:	ff 75 f0             	pushl  -0x10(%ebp)
f0109423:	e8 7e fb ff ff       	call   f0108fa6 <kfree>
f0109428:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010942b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010942f:	0f 84 2b 01 00 00    	je     f0109560 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f0109435:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0109439:	75 14                	jne    f010944f <env_page_ws_invalidate+0x14f>
f010943b:	83 ec 04             	sub    $0x4,%esp
f010943e:	68 03 4e 12 f0       	push   $0xf0124e03
f0109443:	6a 2d                	push   $0x2d
f0109445:	68 e4 4d 12 f0       	push   $0xf0124de4
f010944a:	e8 ea 6e ff ff       	call   f0100339 <_panic>
f010944f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109452:	8b 40 10             	mov    0x10(%eax),%eax
f0109455:	85 c0                	test   %eax,%eax
f0109457:	74 11                	je     f010946a <env_page_ws_invalidate+0x16a>
f0109459:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010945c:	8b 40 10             	mov    0x10(%eax),%eax
f010945f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109462:	8b 52 14             	mov    0x14(%edx),%edx
f0109465:	89 50 14             	mov    %edx,0x14(%eax)
f0109468:	eb 0f                	jmp    f0109479 <env_page_ws_invalidate+0x179>
f010946a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010946d:	8b 50 14             	mov    0x14(%eax),%edx
f0109470:	8b 45 08             	mov    0x8(%ebp),%eax
f0109473:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f0109479:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010947c:	8b 40 14             	mov    0x14(%eax),%eax
f010947f:	85 c0                	test   %eax,%eax
f0109481:	74 11                	je     f0109494 <env_page_ws_invalidate+0x194>
f0109483:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109486:	8b 40 14             	mov    0x14(%eax),%eax
f0109489:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010948c:	8b 52 10             	mov    0x10(%edx),%edx
f010948f:	89 50 10             	mov    %edx,0x10(%eax)
f0109492:	eb 0f                	jmp    f01094a3 <env_page_ws_invalidate+0x1a3>
f0109494:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109497:	8b 50 10             	mov    0x10(%eax),%edx
f010949a:	8b 45 08             	mov    0x8(%ebp),%eax
f010949d:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f01094a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094a6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01094ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094b0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01094b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01094ba:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01094c0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01094c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01094c6:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f01094cc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01094d0:	75 14                	jne    f01094e6 <env_page_ws_invalidate+0x1e6>
f01094d2:	83 ec 04             	sub    $0x4,%esp
f01094d5:	68 24 4e 12 f0       	push   $0xf0124e24
f01094da:	6a 2e                	push   $0x2e
f01094dc:	68 e4 4d 12 f0       	push   $0xf0124de4
f01094e1:	e8 53 6e ff ff       	call   f0100339 <_panic>
f01094e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01094e9:	8b 90 58 05 00 00    	mov    0x558(%eax),%edx
f01094ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094f2:	89 50 14             	mov    %edx,0x14(%eax)
f01094f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094f8:	8b 40 14             	mov    0x14(%eax),%eax
f01094fb:	85 c0                	test   %eax,%eax
f01094fd:	74 11                	je     f0109510 <env_page_ws_invalidate+0x210>
f01094ff:	8b 45 08             	mov    0x8(%ebp),%eax
f0109502:	8b 80 58 05 00 00    	mov    0x558(%eax),%eax
f0109508:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010950b:	89 50 10             	mov    %edx,0x10(%eax)
f010950e:	eb 0c                	jmp    f010951c <env_page_ws_invalidate+0x21c>
f0109510:	8b 45 08             	mov    0x8(%ebp),%eax
f0109513:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109516:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f010951c:	8b 45 08             	mov    0x8(%ebp),%eax
f010951f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109522:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f0109528:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010952b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109532:	8b 45 08             	mov    0x8(%ebp),%eax
f0109535:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010953b:	8d 50 01             	lea    0x1(%eax),%edx
f010953e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109541:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f0109547:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010954a:	8b 10                	mov    (%eax),%edx
f010954c:	8b 45 08             	mov    0x8(%ebp),%eax
f010954f:	8b 40 64             	mov    0x64(%eax),%eax
f0109552:	6a 00                	push   $0x0
f0109554:	6a 01                	push   $0x1
f0109556:	52                   	push   %edx
f0109557:	50                   	push   %eax
f0109558:	e8 53 fb ff ff       	call   f01090b0 <pt_set_page_permissions>
f010955d:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f0109560:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0109567:	eb 43                	jmp    f01095ac <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109569:	8b 45 08             	mov    0x8(%ebp),%eax
f010956c:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f0109572:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109575:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109579:	74 08                	je     f0109583 <env_page_ws_invalidate+0x283>
f010957b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010957e:	8b 40 10             	mov    0x10(%eax),%eax
f0109581:	eb 05                	jmp    f0109588 <env_page_ws_invalidate+0x288>
f0109583:	b8 00 00 00 00       	mov    $0x0,%eax
f0109588:	8b 55 08             	mov    0x8(%ebp),%edx
f010958b:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f0109591:	8b 45 08             	mov    0x8(%ebp),%eax
f0109594:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010959a:	85 c0                	test   %eax,%eax
f010959c:	0f 85 98 fd ff ff    	jne    f010933a <env_page_ws_invalidate+0x3a>
f01095a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01095a6:	0f 85 8e fd ff ff    	jne    f010933a <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f01095ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01095b0:	0f 85 a4 02 00 00    	jne    f010985a <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f01095b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f01095bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01095c0:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f01095c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01095c9:	e9 f6 00 00 00       	jmp    f01096c4 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f01095ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095d1:	8b 00                	mov    (%eax),%eax
f01095d3:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01095d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01095d9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01095de:	89 c2                	mov    %eax,%edx
f01095e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095e3:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01095e6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01095e9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01095ee:	39 c2                	cmp    %eax,%edx
f01095f0:	0f 85 c2 00 00 00    	jne    f01096b8 <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f01095f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095f9:	8b 10                	mov    (%eax),%edx
f01095fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01095fe:	8b 40 64             	mov    0x64(%eax),%eax
f0109601:	83 ec 08             	sub    $0x8,%esp
f0109604:	52                   	push   %edx
f0109605:	50                   	push   %eax
f0109606:	e8 69 f1 ff ff       	call   f0108774 <unmap_frame>
f010960b:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010960e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109612:	75 14                	jne    f0109628 <env_page_ws_invalidate+0x328>
f0109614:	83 ec 04             	sub    $0x4,%esp
f0109617:	68 03 4e 12 f0       	push   $0xf0124e03
f010961c:	6a 3e                	push   $0x3e
f010961e:	68 e4 4d 12 f0       	push   $0xf0124de4
f0109623:	e8 11 6d ff ff       	call   f0100339 <_panic>
f0109628:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010962b:	8b 40 10             	mov    0x10(%eax),%eax
f010962e:	85 c0                	test   %eax,%eax
f0109630:	74 11                	je     f0109643 <env_page_ws_invalidate+0x343>
f0109632:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109635:	8b 40 10             	mov    0x10(%eax),%eax
f0109638:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010963b:	8b 52 14             	mov    0x14(%edx),%edx
f010963e:	89 50 14             	mov    %edx,0x14(%eax)
f0109641:	eb 0f                	jmp    f0109652 <env_page_ws_invalidate+0x352>
f0109643:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109646:	8b 50 14             	mov    0x14(%eax),%edx
f0109649:	8b 45 08             	mov    0x8(%ebp),%eax
f010964c:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f0109652:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109655:	8b 40 14             	mov    0x14(%eax),%eax
f0109658:	85 c0                	test   %eax,%eax
f010965a:	74 11                	je     f010966d <env_page_ws_invalidate+0x36d>
f010965c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010965f:	8b 40 14             	mov    0x14(%eax),%eax
f0109662:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109665:	8b 52 10             	mov    0x10(%edx),%edx
f0109668:	89 50 10             	mov    %edx,0x10(%eax)
f010966b:	eb 0f                	jmp    f010967c <env_page_ws_invalidate+0x37c>
f010966d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109670:	8b 50 10             	mov    0x10(%eax),%edx
f0109673:	8b 45 08             	mov    0x8(%ebp),%eax
f0109676:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010967c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010967f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109686:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109689:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109690:	8b 45 08             	mov    0x8(%ebp),%eax
f0109693:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109699:	8d 50 ff             	lea    -0x1(%eax),%edx
f010969c:	8b 45 08             	mov    0x8(%ebp),%eax
f010969f:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)

					kfree(ptr_WS_element);
f01096a5:	83 ec 0c             	sub    $0xc,%esp
f01096a8:	ff 75 f0             	pushl  -0x10(%ebp)
f01096ab:	e8 f6 f8 ff ff       	call   f0108fa6 <kfree>
f01096b0:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f01096b3:	e9 a2 01 00 00       	jmp    f010985a <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f01096b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01096bb:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f01096c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01096c4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01096c8:	74 08                	je     f01096d2 <env_page_ws_invalidate+0x3d2>
f01096ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096cd:	8b 40 10             	mov    0x10(%eax),%eax
f01096d0:	eb 05                	jmp    f01096d7 <env_page_ws_invalidate+0x3d7>
f01096d2:	b8 00 00 00 00       	mov    $0x0,%eax
f01096d7:	8b 55 08             	mov    0x8(%ebp),%edx
f01096da:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f01096e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01096e3:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f01096e9:	85 c0                	test   %eax,%eax
f01096eb:	0f 85 dd fe ff ff    	jne    f01095ce <env_page_ws_invalidate+0x2ce>
f01096f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01096f5:	0f 85 d3 fe ff ff    	jne    f01095ce <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f01096fb:	e9 5a 01 00 00       	jmp    f010985a <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109700:	8b 45 08             	mov    0x8(%ebp),%eax
f0109703:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0109709:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010970c:	e9 10 01 00 00       	jmp    f0109821 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109711:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109714:	8b 00                	mov    (%eax),%eax
f0109716:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109719:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010971c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109721:	89 c2                	mov    %eax,%edx
f0109723:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109726:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109729:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010972c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109731:	39 c2                	cmp    %eax,%edx
f0109733:	0f 85 dc 00 00 00    	jne    f0109815 <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f0109739:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010973c:	8b 10                	mov    (%eax),%edx
f010973e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109741:	8b 40 64             	mov    0x64(%eax),%eax
f0109744:	83 ec 08             	sub    $0x8,%esp
f0109747:	52                   	push   %edx
f0109748:	50                   	push   %eax
f0109749:	e8 26 f0 ff ff       	call   f0108774 <unmap_frame>
f010974e:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f0109751:	8b 45 08             	mov    0x8(%ebp),%eax
f0109754:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010975a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010975d:	75 0f                	jne    f010976e <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010975f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109762:	8b 50 10             	mov    0x10(%eax),%edx
f0109765:	8b 45 08             	mov    0x8(%ebp),%eax
f0109768:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010976e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109772:	75 14                	jne    f0109788 <env_page_ws_invalidate+0x488>
f0109774:	83 ec 04             	sub    $0x4,%esp
f0109777:	68 03 4e 12 f0       	push   $0xf0124e03
f010977c:	6a 54                	push   $0x54
f010977e:	68 e4 4d 12 f0       	push   $0xf0124de4
f0109783:	e8 b1 6b ff ff       	call   f0100339 <_panic>
f0109788:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010978b:	8b 40 10             	mov    0x10(%eax),%eax
f010978e:	85 c0                	test   %eax,%eax
f0109790:	74 11                	je     f01097a3 <env_page_ws_invalidate+0x4a3>
f0109792:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109795:	8b 40 10             	mov    0x10(%eax),%eax
f0109798:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010979b:	8b 52 14             	mov    0x14(%edx),%edx
f010979e:	89 50 14             	mov    %edx,0x14(%eax)
f01097a1:	eb 0f                	jmp    f01097b2 <env_page_ws_invalidate+0x4b2>
f01097a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097a6:	8b 50 14             	mov    0x14(%eax),%edx
f01097a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01097ac:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f01097b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097b5:	8b 40 14             	mov    0x14(%eax),%eax
f01097b8:	85 c0                	test   %eax,%eax
f01097ba:	74 11                	je     f01097cd <env_page_ws_invalidate+0x4cd>
f01097bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097bf:	8b 40 14             	mov    0x14(%eax),%eax
f01097c2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01097c5:	8b 52 10             	mov    0x10(%edx),%edx
f01097c8:	89 50 10             	mov    %edx,0x10(%eax)
f01097cb:	eb 0f                	jmp    f01097dc <env_page_ws_invalidate+0x4dc>
f01097cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097d0:	8b 50 10             	mov    0x10(%eax),%edx
f01097d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01097d6:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f01097dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097df:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01097e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097e9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01097f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01097f3:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01097f9:	8d 50 ff             	lea    -0x1(%eax),%edx
f01097fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01097ff:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

				kfree(wse);
f0109805:	83 ec 0c             	sub    $0xc,%esp
f0109808:	ff 75 ec             	pushl  -0x14(%ebp)
f010980b:	e8 96 f7 ff ff       	call   f0108fa6 <kfree>
f0109810:	83 c4 10             	add    $0x10,%esp

				break;
f0109813:	eb 45                	jmp    f010985a <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109815:	8b 45 08             	mov    0x8(%ebp),%eax
f0109818:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010981e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109821:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109825:	74 08                	je     f010982f <env_page_ws_invalidate+0x52f>
f0109827:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010982a:	8b 40 10             	mov    0x10(%eax),%eax
f010982d:	eb 05                	jmp    f0109834 <env_page_ws_invalidate+0x534>
f010982f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109834:	8b 55 08             	mov    0x8(%ebp),%edx
f0109837:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010983d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109840:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0109846:	85 c0                	test   %eax,%eax
f0109848:	0f 85 c3 fe ff ff    	jne    f0109711 <env_page_ws_invalidate+0x411>
f010984e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109852:	0f 85 b9 fe ff ff    	jne    f0109711 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f0109858:	eb 00                	jmp    f010985a <env_page_ws_invalidate+0x55a>
f010985a:	90                   	nop
f010985b:	c9                   	leave  
f010985c:	c3                   	ret    

f010985d <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010985d:	55                   	push   %ebp
f010985e:	89 e5                	mov    %esp,%ebp
f0109860:	53                   	push   %ebx
f0109861:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109864:	83 ec 0c             	sub    $0xc,%esp
f0109867:	6a 02                	push   $0x2
f0109869:	e8 bd 4e 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f010986e:	83 c4 10             	add    $0x10,%esp
f0109871:	85 c0                	test   %eax,%eax
f0109873:	0f 84 fe 00 00 00    	je     f0109977 <env_page_ws_print+0x11a>
	{
		int i = 0;
f0109879:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f0109880:	83 ec 0c             	sub    $0xc,%esp
f0109883:	68 47 4e 12 f0       	push   $0xf0124e47
f0109888:	e8 fe 76 ff ff       	call   f0100f8b <cprintf>
f010988d:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109890:	8b 45 08             	mov    0x8(%ebp),%eax
f0109893:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f0109899:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010989c:	eb 2c                	jmp    f01098ca <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010989e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098a1:	8b 10                	mov    (%eax),%edx
f01098a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01098a6:	8d 48 01             	lea    0x1(%eax),%ecx
f01098a9:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f01098ac:	83 ec 04             	sub    $0x4,%esp
f01098af:	52                   	push   %edx
f01098b0:	50                   	push   %eax
f01098b1:	68 61 4e 12 f0       	push   $0xf0124e61
f01098b6:	e8 d0 76 ff ff       	call   f0100f8b <cprintf>
f01098bb:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f01098be:	8b 45 08             	mov    0x8(%ebp),%eax
f01098c1:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f01098c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01098ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01098ce:	74 08                	je     f01098d8 <env_page_ws_print+0x7b>
f01098d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098d3:	8b 40 10             	mov    0x10(%eax),%eax
f01098d6:	eb 05                	jmp    f01098dd <env_page_ws_print+0x80>
f01098d8:	b8 00 00 00 00       	mov    $0x0,%eax
f01098dd:	8b 55 08             	mov    0x8(%ebp),%edx
f01098e0:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f01098e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01098e9:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f01098ef:	85 c0                	test   %eax,%eax
f01098f1:	75 ab                	jne    f010989e <env_page_ws_print+0x41>
f01098f3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01098f7:	75 a5                	jne    f010989e <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f01098f9:	83 ec 0c             	sub    $0xc,%esp
f01098fc:	68 69 4e 12 f0       	push   $0xf0124e69
f0109901:	e8 85 76 ff ff       	call   f0100f8b <cprintf>
f0109906:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109909:	8b 45 08             	mov    0x8(%ebp),%eax
f010990c:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f0109912:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109915:	eb 2c                	jmp    f0109943 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109917:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010991a:	8b 10                	mov    (%eax),%edx
f010991c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010991f:	8d 48 01             	lea    0x1(%eax),%ecx
f0109922:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109925:	83 ec 04             	sub    $0x4,%esp
f0109928:	52                   	push   %edx
f0109929:	50                   	push   %eax
f010992a:	68 61 4e 12 f0       	push   $0xf0124e61
f010992f:	e8 57 76 ff ff       	call   f0100f8b <cprintf>
f0109934:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109937:	8b 45 08             	mov    0x8(%ebp),%eax
f010993a:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0109940:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109943:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109947:	74 08                	je     f0109951 <env_page_ws_print+0xf4>
f0109949:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010994c:	8b 40 10             	mov    0x10(%eax),%eax
f010994f:	eb 05                	jmp    f0109956 <env_page_ws_print+0xf9>
f0109951:	b8 00 00 00 00       	mov    $0x0,%eax
f0109956:	8b 55 08             	mov    0x8(%ebp),%edx
f0109959:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f010995f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109962:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0109968:	85 c0                	test   %eax,%eax
f010996a:	75 ab                	jne    f0109917 <env_page_ws_print+0xba>
f010996c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109970:	75 a5                	jne    f0109917 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f0109972:	e9 5a 01 00 00       	jmp    f0109ad1 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f0109977:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010997e:	83 ec 0c             	sub    $0xc,%esp
f0109981:	68 84 4e 12 f0       	push   $0xf0124e84
f0109986:	e8 00 76 ff ff       	call   f0100f8b <cprintf>
f010998b:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010998e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109995:	8b 45 08             	mov    0x8(%ebp),%eax
f0109998:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010999e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01099a1:	e9 d1 00 00 00       	jmp    f0109a77 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f01099a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01099a9:	8b 00                	mov    (%eax),%eax
f01099ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f01099ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01099b1:	8b 40 08             	mov    0x8(%eax),%eax
f01099b4:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f01099b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01099ba:	8b 40 64             	mov    0x64(%eax),%eax
f01099bd:	83 ec 08             	sub    $0x8,%esp
f01099c0:	ff 75 e4             	pushl  -0x1c(%ebp)
f01099c3:	50                   	push   %eax
f01099c4:	e8 ab f7 ff ff       	call   f0109174 <pt_get_page_permissions>
f01099c9:	83 c4 10             	add    $0x10,%esp
f01099cc:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f01099cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01099d2:	83 e0 40             	and    $0x40,%eax
f01099d5:	85 c0                	test   %eax,%eax
f01099d7:	0f 95 c0             	setne  %al
f01099da:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f01099dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01099e0:	83 e0 20             	and    $0x20,%eax
f01099e3:	85 c0                	test   %eax,%eax
f01099e5:	0f 95 c0             	setne  %al
f01099e8:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f01099eb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01099ee:	25 00 02 00 00       	and    $0x200,%eax
f01099f3:	85 c0                	test   %eax,%eax
f01099f5:	0f 95 c0             	setne  %al
f01099f8:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f01099fb:	83 ec 04             	sub    $0x4,%esp
f01099fe:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109a01:	ff 75 ec             	pushl  -0x14(%ebp)
f0109a04:	68 8e 4e 12 f0       	push   $0xf0124e8e
f0109a09:	e8 7d 75 ff ff       	call   f0100f8b <cprintf>
f0109a0e:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f0109a11:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109a14:	8b 58 0c             	mov    0xc(%eax),%ebx
f0109a17:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f0109a1b:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f0109a1f:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f0109a23:	83 ec 08             	sub    $0x8,%esp
f0109a26:	53                   	push   %ebx
f0109a27:	ff 75 e0             	pushl  -0x20(%ebp)
f0109a2a:	51                   	push   %ecx
f0109a2b:	52                   	push   %edx
f0109a2c:	50                   	push   %eax
f0109a2d:	68 98 4e 12 f0       	push   $0xf0124e98
f0109a32:	e8 54 75 ff ff       	call   f0100f8b <cprintf>
f0109a37:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f0109a3a:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a3d:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f0109a43:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109a46:	75 10                	jne    f0109a58 <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f0109a48:	83 ec 0c             	sub    $0xc,%esp
f0109a4b:	68 df 4e 12 f0       	push   $0xf0124edf
f0109a50:	e8 36 75 ff ff       	call   f0100f8b <cprintf>
f0109a55:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109a58:	83 ec 0c             	sub    $0xc,%esp
f0109a5b:	68 e4 4e 12 f0       	push   $0xf0124ee4
f0109a60:	e8 26 75 ff ff       	call   f0100f8b <cprintf>
f0109a65:	83 c4 10             	add    $0x10,%esp
			i++;
f0109a68:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109a6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a6e:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0109a74:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109a77:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109a7b:	74 08                	je     f0109a85 <env_page_ws_print+0x228>
f0109a7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109a80:	8b 40 10             	mov    0x10(%eax),%eax
f0109a83:	eb 05                	jmp    f0109a8a <env_page_ws_print+0x22d>
f0109a85:	b8 00 00 00 00       	mov    $0x0,%eax
f0109a8a:	8b 55 08             	mov    0x8(%ebp),%edx
f0109a8d:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0109a93:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a96:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0109a9c:	85 c0                	test   %eax,%eax
f0109a9e:	0f 85 02 ff ff ff    	jne    f01099a6 <env_page_ws_print+0x149>
f0109aa4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109aa8:	0f 85 f8 fe ff ff    	jne    f01099a6 <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f0109aae:	eb 13                	jmp    f0109ac3 <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f0109ab0:	83 ec 0c             	sub    $0xc,%esp
f0109ab3:	68 e6 4e 12 f0       	push   $0xf0124ee6
f0109ab8:	e8 ce 74 ff ff       	call   f0100f8b <cprintf>
f0109abd:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f0109ac0:	ff 45 ec             	incl   -0x14(%ebp)
f0109ac3:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ac6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0109acc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109acf:	77 df                	ja     f0109ab0 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f0109ad1:	90                   	nop
f0109ad2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109ad5:	c9                   	leave  
f0109ad6:	c3                   	ret    

f0109ad7 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f0109ad7:	55                   	push   %ebp
f0109ad8:	89 e5                	mov    %esp,%ebp
f0109ada:	53                   	push   %ebx
f0109adb:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f0109ade:	83 ec 0c             	sub    $0xc,%esp
f0109ae1:	68 f8 4e 12 f0       	push   $0xf0124ef8
f0109ae6:	e8 a0 74 ff ff       	call   f0100f8b <cprintf>
f0109aeb:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f0109aee:	83 ec 0c             	sub    $0xc,%esp
f0109af1:	68 2d 4f 12 f0       	push   $0xf0124f2d
f0109af6:	e8 90 74 ff ff       	call   f0100f8b <cprintf>
f0109afb:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f0109afe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109b05:	e9 16 01 00 00       	jmp    f0109c20 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f0109b0a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109b0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109b10:	89 d0                	mov    %edx,%eax
f0109b12:	01 c0                	add    %eax,%eax
f0109b14:	01 d0                	add    %edx,%eax
f0109b16:	c1 e0 03             	shl    $0x3,%eax
f0109b19:	01 c8                	add    %ecx,%eax
f0109b1b:	05 a4 00 00 00       	add    $0xa4,%eax
f0109b20:	8a 00                	mov    (%eax),%al
f0109b22:	84 c0                	test   %al,%al
f0109b24:	74 43                	je     f0109b69 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f0109b26:	83 ec 0c             	sub    $0xc,%esp
f0109b29:	68 38 4f 12 f0       	push   $0xf0124f38
f0109b2e:	e8 58 74 ff ff       	call   f0100f8b <cprintf>
f0109b33:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f0109b36:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b39:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f0109b3f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109b42:	75 10                	jne    f0109b54 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f0109b44:	83 ec 0c             	sub    $0xc,%esp
f0109b47:	68 47 4f 12 f0       	push   $0xf0124f47
f0109b4c:	e8 3a 74 ff ff       	call   f0100f8b <cprintf>
f0109b51:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109b54:	83 ec 0c             	sub    $0xc,%esp
f0109b57:	68 e4 4e 12 f0       	push   $0xf0124ee4
f0109b5c:	e8 2a 74 ff ff       	call   f0100f8b <cprintf>
f0109b61:	83 c4 10             	add    $0x10,%esp
			continue;
f0109b64:	e9 b4 00 00 00       	jmp    f0109c1d <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f0109b69:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109b6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109b6f:	89 d0                	mov    %edx,%eax
f0109b71:	01 c0                	add    %eax,%eax
f0109b73:	01 d0                	add    %edx,%eax
f0109b75:	c1 e0 03             	shl    $0x3,%eax
f0109b78:	01 c8                	add    %ecx,%eax
f0109b7a:	05 a0 00 00 00       	add    $0xa0,%eax
f0109b7f:	8b 00                	mov    (%eax),%eax
f0109b81:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f0109b84:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109b87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109b8a:	89 d0                	mov    %edx,%eax
f0109b8c:	01 c0                	add    %eax,%eax
f0109b8e:	01 d0                	add    %edx,%eax
f0109b90:	c1 e0 03             	shl    $0x3,%eax
f0109b93:	01 c8                	add    %ecx,%eax
f0109b95:	05 a0 00 00 00       	add    $0xa0,%eax
f0109b9a:	8b 00                	mov    (%eax),%eax
f0109b9c:	83 ec 04             	sub    $0x4,%esp
f0109b9f:	50                   	push   %eax
f0109ba0:	ff 75 f4             	pushl  -0xc(%ebp)
f0109ba3:	68 4d 4f 12 f0       	push   $0xf0124f4d
f0109ba8:	e8 de 73 ff ff       	call   f0100f8b <cprintf>
f0109bad:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f0109bb0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109bb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109bb6:	89 d0                	mov    %edx,%eax
f0109bb8:	01 c0                	add    %eax,%eax
f0109bba:	01 d0                	add    %edx,%eax
f0109bbc:	c1 e0 03             	shl    $0x3,%eax
f0109bbf:	01 c8                	add    %ecx,%eax
f0109bc1:	05 a8 00 00 00       	add    $0xa8,%eax
f0109bc6:	8b 18                	mov    (%eax),%ebx
f0109bc8:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bcb:	8b 40 64             	mov    0x64(%eax),%eax
f0109bce:	83 ec 08             	sub    $0x8,%esp
f0109bd1:	ff 75 f0             	pushl  -0x10(%ebp)
f0109bd4:	50                   	push   %eax
f0109bd5:	e8 76 f6 ff ff       	call   f0109250 <pd_is_table_used>
f0109bda:	83 c4 10             	add    $0x10,%esp
f0109bdd:	83 ec 04             	sub    $0x4,%esp
f0109be0:	53                   	push   %ebx
f0109be1:	50                   	push   %eax
f0109be2:	68 64 4f 12 f0       	push   $0xf0124f64
f0109be7:	e8 9f 73 ff ff       	call   f0100f8b <cprintf>
f0109bec:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f0109bef:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bf2:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f0109bf8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109bfb:	75 10                	jne    f0109c0d <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f0109bfd:	83 ec 0c             	sub    $0xc,%esp
f0109c00:	68 df 4e 12 f0       	push   $0xf0124edf
f0109c05:	e8 81 73 ff ff       	call   f0100f8b <cprintf>
f0109c0a:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f0109c0d:	83 ec 0c             	sub    $0xc,%esp
f0109c10:	68 e4 4e 12 f0       	push   $0xf0124ee4
f0109c15:	e8 71 73 ff ff       	call   f0100f8b <cprintf>
f0109c1a:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f0109c1d:	ff 45 f4             	incl   -0xc(%ebp)
f0109c20:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0109c24:	0f 86 e0 fe ff ff    	jbe    f0109b0a <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f0109c2a:	90                   	nop
f0109c2b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109c2e:	c9                   	leave  
f0109c2f:	c3                   	ret    

f0109c30 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f0109c30:	55                   	push   %ebp
f0109c31:	89 e5                	mov    %esp,%ebp
f0109c33:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0109c36:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0109c3d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f0109c44:	eb 22                	jmp    f0109c68 <env_table_ws_get_size+0x38>
f0109c46:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109c49:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0109c4c:	89 d0                	mov    %edx,%eax
f0109c4e:	01 c0                	add    %eax,%eax
f0109c50:	01 d0                	add    %edx,%eax
f0109c52:	c1 e0 03             	shl    $0x3,%eax
f0109c55:	01 c8                	add    %ecx,%eax
f0109c57:	05 a4 00 00 00       	add    $0xa4,%eax
f0109c5c:	8a 00                	mov    (%eax),%al
f0109c5e:	84 c0                	test   %al,%al
f0109c60:	75 03                	jne    f0109c65 <env_table_ws_get_size+0x35>
f0109c62:	ff 45 f8             	incl   -0x8(%ebp)
f0109c65:	ff 45 fc             	incl   -0x4(%ebp)
f0109c68:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f0109c6c:	7e d8                	jle    f0109c46 <env_table_ws_get_size+0x16>
	return counter;
f0109c6e:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0109c71:	c9                   	leave  
f0109c72:	c3                   	ret    

f0109c73 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109c73:	55                   	push   %ebp
f0109c74:	89 e5                	mov    %esp,%ebp
f0109c76:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0109c79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f0109c80:	eb 4e                	jmp    f0109cd0 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f0109c82:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109c85:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109c88:	89 d0                	mov    %edx,%eax
f0109c8a:	01 c0                	add    %eax,%eax
f0109c8c:	01 d0                	add    %edx,%eax
f0109c8e:	c1 e0 03             	shl    $0x3,%eax
f0109c91:	01 c8                	add    %ecx,%eax
f0109c93:	05 a0 00 00 00       	add    $0xa0,%eax
f0109c98:	8b 00                	mov    (%eax),%eax
f0109c9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109c9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ca0:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109ca5:	89 c2                	mov    %eax,%edx
f0109ca7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109caa:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109cad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109cb0:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109cb5:	39 c2                	cmp    %eax,%edx
f0109cb7:	75 14                	jne    f0109ccd <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f0109cb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109cbc:	83 ec 08             	sub    $0x8,%esp
f0109cbf:	50                   	push   %eax
f0109cc0:	ff 75 08             	pushl  0x8(%ebp)
f0109cc3:	e8 bc 00 00 00       	call   f0109d84 <env_table_ws_clear_entry>
f0109cc8:	83 c4 10             	add    $0x10,%esp
			break;
f0109ccb:	eb 09                	jmp    f0109cd6 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f0109ccd:	ff 45 f4             	incl   -0xc(%ebp)
f0109cd0:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0109cd4:	7e ac                	jle    f0109c82 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f0109cd6:	90                   	nop
f0109cd7:	c9                   	leave  
f0109cd8:	c3                   	ret    

f0109cd9 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f0109cd9:	55                   	push   %ebp
f0109cda:	89 e5                	mov    %esp,%ebp
f0109cdc:	53                   	push   %ebx
f0109cdd:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109ce0:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109ce4:	76 19                	jbe    f0109cff <env_table_ws_set_entry+0x26>
f0109ce6:	68 88 4f 12 f0       	push   $0xf0124f88
f0109ceb:	68 b9 4f 12 f0       	push   $0xf0124fb9
f0109cf0:	68 37 01 00 00       	push   $0x137
f0109cf5:	68 e4 4d 12 f0       	push   $0xf0124de4
f0109cfa:	e8 3a 66 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f0109cff:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0109d06:	76 19                	jbe    f0109d21 <env_table_ws_set_entry+0x48>
f0109d08:	68 d0 4f 12 f0       	push   $0xf0124fd0
f0109d0d:	68 b9 4f 12 f0       	push   $0xf0124fb9
f0109d12:	68 38 01 00 00       	push   $0x138
f0109d17:	68 e4 4d 12 f0       	push   $0xf0124de4
f0109d1c:	e8 18 66 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f0109d21:	8b 45 10             	mov    0x10(%ebp),%eax
f0109d24:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109d27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109d2a:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109d2f:	89 c1                	mov    %eax,%ecx
f0109d31:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109d34:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d37:	89 d0                	mov    %edx,%eax
f0109d39:	01 c0                	add    %eax,%eax
f0109d3b:	01 d0                	add    %edx,%eax
f0109d3d:	c1 e0 03             	shl    $0x3,%eax
f0109d40:	01 d8                	add    %ebx,%eax
f0109d42:	05 a0 00 00 00       	add    $0xa0,%eax
f0109d47:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f0109d49:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109d4c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d4f:	89 d0                	mov    %edx,%eax
f0109d51:	01 c0                	add    %eax,%eax
f0109d53:	01 d0                	add    %edx,%eax
f0109d55:	c1 e0 03             	shl    $0x3,%eax
f0109d58:	01 c8                	add    %ecx,%eax
f0109d5a:	05 a4 00 00 00       	add    $0xa4,%eax
f0109d5f:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f0109d62:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109d65:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d68:	89 d0                	mov    %edx,%eax
f0109d6a:	01 c0                	add    %eax,%eax
f0109d6c:	01 d0                	add    %edx,%eax
f0109d6e:	c1 e0 03             	shl    $0x3,%eax
f0109d71:	01 c8                	add    %ecx,%eax
f0109d73:	05 a8 00 00 00       	add    $0xa8,%eax
f0109d78:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f0109d7e:	90                   	nop
}
f0109d7f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109d82:	c9                   	leave  
f0109d83:	c3                   	ret    

f0109d84 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0109d84:	55                   	push   %ebp
f0109d85:	89 e5                	mov    %esp,%ebp
f0109d87:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109d8a:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109d8e:	76 19                	jbe    f0109da9 <env_table_ws_clear_entry+0x25>
f0109d90:	68 88 4f 12 f0       	push   $0xf0124f88
f0109d95:	68 b9 4f 12 f0       	push   $0xf0124fb9
f0109d9a:	68 43 01 00 00       	push   $0x143
f0109d9f:	68 e4 4d 12 f0       	push   $0xf0124de4
f0109da4:	e8 90 65 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f0109da9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109dac:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109daf:	89 d0                	mov    %edx,%eax
f0109db1:	01 c0                	add    %eax,%eax
f0109db3:	01 d0                	add    %edx,%eax
f0109db5:	c1 e0 03             	shl    $0x3,%eax
f0109db8:	01 c8                	add    %ecx,%eax
f0109dba:	05 a0 00 00 00       	add    $0xa0,%eax
f0109dbf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f0109dc5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109dc8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109dcb:	89 d0                	mov    %edx,%eax
f0109dcd:	01 c0                	add    %eax,%eax
f0109dcf:	01 d0                	add    %edx,%eax
f0109dd1:	c1 e0 03             	shl    $0x3,%eax
f0109dd4:	01 c8                	add    %ecx,%eax
f0109dd6:	05 a4 00 00 00       	add    $0xa4,%eax
f0109ddb:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f0109dde:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109de1:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109de4:	89 d0                	mov    %edx,%eax
f0109de6:	01 c0                	add    %eax,%eax
f0109de8:	01 d0                	add    %edx,%eax
f0109dea:	c1 e0 03             	shl    $0x3,%eax
f0109ded:	01 c8                	add    %ecx,%eax
f0109def:	05 a8 00 00 00       	add    $0xa8,%eax
f0109df4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f0109dfa:	90                   	nop
f0109dfb:	c9                   	leave  
f0109dfc:	c3                   	ret    

f0109dfd <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f0109dfd:	55                   	push   %ebp
f0109dfe:	89 e5                	mov    %esp,%ebp
f0109e00:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109e03:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109e07:	76 19                	jbe    f0109e22 <env_table_ws_get_virtual_address+0x25>
f0109e09:	68 88 4f 12 f0       	push   $0xf0124f88
f0109e0e:	68 b9 4f 12 f0       	push   $0xf0124fb9
f0109e13:	68 4b 01 00 00       	push   $0x14b
f0109e18:	68 e4 4d 12 f0       	push   $0xf0124de4
f0109e1d:	e8 17 65 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f0109e22:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109e25:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e28:	89 d0                	mov    %edx,%eax
f0109e2a:	01 c0                	add    %eax,%eax
f0109e2c:	01 d0                	add    %edx,%eax
f0109e2e:	c1 e0 03             	shl    $0x3,%eax
f0109e31:	01 c8                	add    %ecx,%eax
f0109e33:	05 a0 00 00 00       	add    $0xa0,%eax
f0109e38:	8b 00                	mov    (%eax),%eax
f0109e3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109e3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109e40:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f0109e45:	c9                   	leave  
f0109e46:	c3                   	ret    

f0109e47 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0109e47:	55                   	push   %ebp
f0109e48:	89 e5                	mov    %esp,%ebp
f0109e4a:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109e4d:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109e51:	76 19                	jbe    f0109e6c <env_table_ws_get_time_stamp+0x25>
f0109e53:	68 88 4f 12 f0       	push   $0xf0124f88
f0109e58:	68 b9 4f 12 f0       	push   $0xf0124fb9
f0109e5d:	68 52 01 00 00       	push   $0x152
f0109e62:	68 e4 4d 12 f0       	push   $0xf0124de4
f0109e67:	e8 cd 64 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f0109e6c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109e6f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e72:	89 d0                	mov    %edx,%eax
f0109e74:	01 c0                	add    %eax,%eax
f0109e76:	01 d0                	add    %edx,%eax
f0109e78:	c1 e0 03             	shl    $0x3,%eax
f0109e7b:	01 c8                	add    %ecx,%eax
f0109e7d:	05 a8 00 00 00       	add    $0xa8,%eax
f0109e82:	8b 00                	mov    (%eax),%eax
}
f0109e84:	c9                   	leave  
f0109e85:	c3                   	ret    

f0109e86 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0109e86:	55                   	push   %ebp
f0109e87:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f0109e89:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109e8c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e8f:	89 d0                	mov    %edx,%eax
f0109e91:	01 c0                	add    %eax,%eax
f0109e93:	01 d0                	add    %edx,%eax
f0109e95:	c1 e0 03             	shl    $0x3,%eax
f0109e98:	01 c8                	add    %ecx,%eax
f0109e9a:	05 a4 00 00 00       	add    $0xa4,%eax
f0109e9f:	8a 00                	mov    (%eax),%al
f0109ea1:	0f b6 c0             	movzbl %al,%eax
}
f0109ea4:	5d                   	pop    %ebp
f0109ea5:	c3                   	ret    

f0109ea6 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f0109ea6:	55                   	push   %ebp
f0109ea7:	89 e5                	mov    %esp,%ebp
f0109ea9:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f0109eac:	83 ec 04             	sub    $0x4,%esp
f0109eaf:	68 03 50 12 f0       	push   $0xf0125003
f0109eb4:	68 62 01 00 00       	push   $0x162
f0109eb9:	68 e4 4d 12 f0       	push   $0xf0124de4
f0109ebe:	e8 76 64 ff ff       	call   f0100339 <_panic>

f0109ec3 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f0109ec3:	55                   	push   %ebp
f0109ec4:	89 e5                	mov    %esp,%ebp
f0109ec6:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f0109ec9:	83 ec 04             	sub    $0x4,%esp
f0109ecc:	68 03 50 12 f0       	push   $0xf0125003
f0109ed1:	68 67 01 00 00       	push   $0x167
f0109ed6:	68 e4 4d 12 f0       	push   $0xf0124de4
f0109edb:	e8 59 64 ff ff       	call   f0100339 <_panic>

f0109ee0 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f0109ee0:	55                   	push   %ebp
f0109ee1:	89 e5                	mov    %esp,%ebp
f0109ee3:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f0109ee6:	83 ec 04             	sub    $0x4,%esp
f0109ee9:	68 14 50 12 f0       	push   $0xf0125014
f0109eee:	6a 21                	push   $0x21
f0109ef0:	68 42 50 12 f0       	push   $0xf0125042
f0109ef5:	e8 3f 64 ff ff       	call   f0100339 <_panic>

f0109efa <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f0109efa:	55                   	push   %ebp
f0109efb:	89 e5                	mov    %esp,%ebp
f0109efd:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f0109f00:	83 ec 04             	sub    $0x4,%esp
f0109f03:	68 60 50 12 f0       	push   $0xf0125060
f0109f08:	6a 34                	push   $0x34
f0109f0a:	68 42 50 12 f0       	push   $0xf0125042
f0109f0f:	e8 25 64 ff ff       	call   f0100339 <_panic>

f0109f14 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f0109f14:	55                   	push   %ebp
f0109f15:	89 e5                	mov    %esp,%ebp
f0109f17:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f0109f1a:	83 ec 04             	sub    $0x4,%esp
f0109f1d:	68 90 50 12 f0       	push   $0xf0125090
f0109f22:	6a 44                	push   $0x44
f0109f24:	68 42 50 12 f0       	push   $0xf0125042
f0109f29:	e8 0b 64 ff ff       	call   f0100339 <_panic>

f0109f2e <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f0109f2e:	55                   	push   %ebp
f0109f2f:	89 e5                	mov    %esp,%ebp
f0109f31:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f0109f34:	83 ec 04             	sub    $0x4,%esp
f0109f37:	68 bc 50 12 f0       	push   $0xf01250bc
f0109f3c:	6a 52                	push   $0x52
f0109f3e:	68 42 50 12 f0       	push   $0xf0125042
f0109f43:	e8 f1 63 ff ff       	call   f0100339 <_panic>

f0109f48 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f0109f48:	55                   	push   %ebp
f0109f49:	89 e5                	mov    %esp,%ebp
f0109f4b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f0109f4e:	83 ec 04             	sub    $0x4,%esp
f0109f51:	68 ec 50 12 f0       	push   $0xf01250ec
f0109f56:	6a 5c                	push   $0x5c
f0109f58:	68 42 50 12 f0       	push   $0xf0125042
f0109f5d:	e8 d7 63 ff ff       	call   f0100339 <_panic>

f0109f62 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f0109f62:	55                   	push   %ebp
f0109f63:	89 e5                	mov    %esp,%ebp
f0109f65:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f0109f68:	83 ec 04             	sub    $0x4,%esp
f0109f6b:	68 24 51 12 f0       	push   $0xf0125124
f0109f70:	6a 69                	push   $0x69
f0109f72:	68 42 50 12 f0       	push   $0xf0125042
f0109f77:	e8 bd 63 ff ff       	call   f0100339 <_panic>

f0109f7c <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f0109f7c:	55                   	push   %ebp
f0109f7d:	89 e5                	mov    %esp,%ebp
	 */

	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
	return (void*)-1 ;
f0109f7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit


}
f0109f84:	5d                   	pop    %ebp
f0109f85:	c3                   	ret    

f0109f86 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109f86:	55                   	push   %ebp
f0109f87:	89 e5                	mov    %esp,%ebp
f0109f89:	83 ec 08             	sub    $0x8,%esp
//	return;
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
	panic("allocate_user_mem() is not implemented yet...!!");
f0109f8c:	83 ec 04             	sub    $0x4,%esp
f0109f8f:	68 5c 51 12 f0       	push   $0xf012515c
f0109f94:	68 a2 00 00 00       	push   $0xa2
f0109f99:	68 42 50 12 f0       	push   $0xf0125042
f0109f9e:	e8 96 63 ff ff       	call   f0100339 <_panic>

f0109fa3 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109fa3:	55                   	push   %ebp
f0109fa4:	89 e5                	mov    %esp,%ebp
f0109fa6:	83 ec 08             	sub    $0x8,%esp
//	return;
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
	panic("free_user_mem() is not implemented yet...!!");
f0109fa9:	83 ec 04             	sub    $0x4,%esp
f0109fac:	68 8c 51 12 f0       	push   $0xf012518c
f0109fb1:	68 b2 00 00 00       	push   $0xb2
f0109fb6:	68 42 50 12 f0       	push   $0xf0125042
f0109fbb:	e8 79 63 ff ff       	call   f0100339 <_panic>

f0109fc0 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109fc0:	55                   	push   %ebp
f0109fc1:	89 e5                	mov    %esp,%ebp
f0109fc3:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f0109fc6:	83 ec 04             	sub    $0x4,%esp
f0109fc9:	68 b8 51 12 f0       	push   $0xf01251b8
f0109fce:	68 be 00 00 00       	push   $0xbe
f0109fd3:	68 42 50 12 f0       	push   $0xf0125042
f0109fd8:	e8 5c 63 ff ff       	call   f0100339 <_panic>

f0109fdd <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f0109fdd:	55                   	push   %ebp
f0109fde:	89 e5                	mov    %esp,%ebp
f0109fe0:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f0109fe3:	83 ec 04             	sub    $0x4,%esp
f0109fe6:	68 f8 51 12 f0       	push   $0xf01251f8
f0109feb:	68 c8 00 00 00       	push   $0xc8
f0109ff0:	68 42 50 12 f0       	push   $0xf0125042
f0109ff5:	e8 3f 63 ff ff       	call   f0100339 <_panic>

f0109ffa <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f0109ffa:	55                   	push   %ebp
f0109ffb:	89 e5                	mov    %esp,%ebp
f0109ffd:	53                   	push   %ebx
f0109ffe:	83 ec 14             	sub    $0x14,%esp
	int iEnv = NENV-1;
f010a001:	c7 45 f4 cf 02 00 00 	movl   $0x2cf,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010a008:	e9 70 01 00 00       	jmp    f010a17d <env_init+0x183>
	{
		envs[iEnv].env_status = ENV_FREE;
f010a00d:	8b 0d d0 b7 5c f0    	mov    0xf05cb7d0,%ecx
f010a013:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a016:	89 d0                	mov    %edx,%eax
f010a018:	c1 e0 02             	shl    $0x2,%eax
f010a01b:	01 d0                	add    %edx,%eax
f010a01d:	01 c0                	add    %eax,%eax
f010a01f:	01 d0                	add    %edx,%eax
f010a021:	c1 e0 02             	shl    $0x2,%eax
f010a024:	01 d0                	add    %edx,%eax
f010a026:	01 c0                	add    %eax,%eax
f010a028:	01 d0                	add    %edx,%eax
f010a02a:	c1 e0 04             	shl    $0x4,%eax
f010a02d:	01 c8                	add    %ecx,%eax
f010a02f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010a036:	8b 0d d0 b7 5c f0    	mov    0xf05cb7d0,%ecx
f010a03c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a03f:	89 d0                	mov    %edx,%eax
f010a041:	c1 e0 02             	shl    $0x2,%eax
f010a044:	01 d0                	add    %edx,%eax
f010a046:	01 c0                	add    %eax,%eax
f010a048:	01 d0                	add    %edx,%eax
f010a04a:	c1 e0 02             	shl    $0x2,%eax
f010a04d:	01 d0                	add    %edx,%eax
f010a04f:	01 c0                	add    %eax,%eax
f010a051:	01 d0                	add    %edx,%eax
f010a053:	c1 e0 04             	shl    $0x4,%eax
f010a056:	01 c8                	add    %ecx,%eax
f010a058:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010a05f:	8b 0d d0 b7 5c f0    	mov    0xf05cb7d0,%ecx
f010a065:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a068:	89 d0                	mov    %edx,%eax
f010a06a:	c1 e0 02             	shl    $0x2,%eax
f010a06d:	01 d0                	add    %edx,%eax
f010a06f:	01 c0                	add    %eax,%eax
f010a071:	01 d0                	add    %edx,%eax
f010a073:	c1 e0 02             	shl    $0x2,%eax
f010a076:	01 d0                	add    %edx,%eax
f010a078:	01 c0                	add    %eax,%eax
f010a07a:	01 d0                	add    %edx,%eax
f010a07c:	c1 e0 04             	shl    $0x4,%eax
f010a07f:	01 c8                	add    %ecx,%eax
f010a081:	85 c0                	test   %eax,%eax
f010a083:	75 14                	jne    f010a099 <env_init+0x9f>
f010a085:	83 ec 04             	sub    $0x4,%esp
f010a088:	68 24 52 12 f0       	push   $0xf0125224
f010a08d:	6a 64                	push   $0x64
f010a08f:	68 47 52 12 f0       	push   $0xf0125247
f010a094:	e8 a0 62 ff ff       	call   f0100339 <_panic>
f010a099:	8b 0d d0 b7 5c f0    	mov    0xf05cb7d0,%ecx
f010a09f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a0a2:	89 d0                	mov    %edx,%eax
f010a0a4:	c1 e0 02             	shl    $0x2,%eax
f010a0a7:	01 d0                	add    %edx,%eax
f010a0a9:	01 c0                	add    %eax,%eax
f010a0ab:	01 d0                	add    %edx,%eax
f010a0ad:	c1 e0 02             	shl    $0x2,%eax
f010a0b0:	01 d0                	add    %edx,%eax
f010a0b2:	01 c0                	add    %eax,%eax
f010a0b4:	01 d0                	add    %edx,%eax
f010a0b6:	c1 e0 04             	shl    $0x4,%eax
f010a0b9:	01 c8                	add    %ecx,%eax
f010a0bb:	8b 15 d4 b7 5c f0    	mov    0xf05cb7d4,%edx
f010a0c1:	89 50 08             	mov    %edx,0x8(%eax)
f010a0c4:	8b 40 08             	mov    0x8(%eax),%eax
f010a0c7:	85 c0                	test   %eax,%eax
f010a0c9:	74 2d                	je     f010a0f8 <env_init+0xfe>
f010a0cb:	8b 0d d4 b7 5c f0    	mov    0xf05cb7d4,%ecx
f010a0d1:	8b 1d d0 b7 5c f0    	mov    0xf05cb7d0,%ebx
f010a0d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a0da:	89 d0                	mov    %edx,%eax
f010a0dc:	c1 e0 02             	shl    $0x2,%eax
f010a0df:	01 d0                	add    %edx,%eax
f010a0e1:	01 c0                	add    %eax,%eax
f010a0e3:	01 d0                	add    %edx,%eax
f010a0e5:	c1 e0 02             	shl    $0x2,%eax
f010a0e8:	01 d0                	add    %edx,%eax
f010a0ea:	01 c0                	add    %eax,%eax
f010a0ec:	01 d0                	add    %edx,%eax
f010a0ee:	c1 e0 04             	shl    $0x4,%eax
f010a0f1:	01 d8                	add    %ebx,%eax
f010a0f3:	89 41 0c             	mov    %eax,0xc(%ecx)
f010a0f6:	eb 27                	jmp    f010a11f <env_init+0x125>
f010a0f8:	8b 0d d0 b7 5c f0    	mov    0xf05cb7d0,%ecx
f010a0fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a101:	89 d0                	mov    %edx,%eax
f010a103:	c1 e0 02             	shl    $0x2,%eax
f010a106:	01 d0                	add    %edx,%eax
f010a108:	01 c0                	add    %eax,%eax
f010a10a:	01 d0                	add    %edx,%eax
f010a10c:	c1 e0 02             	shl    $0x2,%eax
f010a10f:	01 d0                	add    %edx,%eax
f010a111:	01 c0                	add    %eax,%eax
f010a113:	01 d0                	add    %edx,%eax
f010a115:	c1 e0 04             	shl    $0x4,%eax
f010a118:	01 c8                	add    %ecx,%eax
f010a11a:	a3 d8 b7 5c f0       	mov    %eax,0xf05cb7d8
f010a11f:	8b 0d d0 b7 5c f0    	mov    0xf05cb7d0,%ecx
f010a125:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a128:	89 d0                	mov    %edx,%eax
f010a12a:	c1 e0 02             	shl    $0x2,%eax
f010a12d:	01 d0                	add    %edx,%eax
f010a12f:	01 c0                	add    %eax,%eax
f010a131:	01 d0                	add    %edx,%eax
f010a133:	c1 e0 02             	shl    $0x2,%eax
f010a136:	01 d0                	add    %edx,%eax
f010a138:	01 c0                	add    %eax,%eax
f010a13a:	01 d0                	add    %edx,%eax
f010a13c:	c1 e0 04             	shl    $0x4,%eax
f010a13f:	01 c8                	add    %ecx,%eax
f010a141:	a3 d4 b7 5c f0       	mov    %eax,0xf05cb7d4
f010a146:	8b 0d d0 b7 5c f0    	mov    0xf05cb7d0,%ecx
f010a14c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a14f:	89 d0                	mov    %edx,%eax
f010a151:	c1 e0 02             	shl    $0x2,%eax
f010a154:	01 d0                	add    %edx,%eax
f010a156:	01 c0                	add    %eax,%eax
f010a158:	01 d0                	add    %edx,%eax
f010a15a:	c1 e0 02             	shl    $0x2,%eax
f010a15d:	01 d0                	add    %edx,%eax
f010a15f:	01 c0                	add    %eax,%eax
f010a161:	01 d0                	add    %edx,%eax
f010a163:	c1 e0 04             	shl    $0x4,%eax
f010a166:	01 c8                	add    %ecx,%eax
f010a168:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010a16f:	a1 e0 b7 5c f0       	mov    0xf05cb7e0,%eax
f010a174:	40                   	inc    %eax
f010a175:	a3 e0 b7 5c f0       	mov    %eax,0xf05cb7e0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010a17a:	ff 4d f4             	decl   -0xc(%ebp)
f010a17d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a181:	0f 89 86 fe ff ff    	jns    f010a00d <env_init+0x13>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010a187:	90                   	nop
f010a188:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a18b:	c9                   	leave  
f010a18c:	c3                   	ret    

f010a18d <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010a18d:	55                   	push   %ebp
f010a18e:	89 e5                	mov    %esp,%ebp
f010a190:	57                   	push   %edi
f010a191:	56                   	push   %esi
f010a192:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010a198:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010a19f:	83 ec 0c             	sub    $0xc,%esp
f010a1a2:	ff 75 08             	pushl  0x8(%ebp)
f010a1a5:	e8 b0 1d 00 00       	call   f010bf5a <get_user_program_info>
f010a1aa:	83 c4 10             	add    $0x10,%esp
f010a1ad:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010a1b0:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010a1b4:	75 0a                	jne    f010a1c0 <env_create+0x33>
	{
		return NULL;
f010a1b6:	b8 00 00 00 00       	mov    $0x0,%eax
f010a1bb:	e9 aa 09 00 00       	jmp    f010ab6a <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010a1c0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a1c3:	8b 40 08             	mov    0x8(%eax),%eax
f010a1c6:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010a1c9:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010a1d0:	00 00 00 
	if(allocate_environment(&e) < 0)
f010a1d3:	83 ec 0c             	sub    $0xc,%esp
f010a1d6:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010a1dc:	50                   	push   %eax
f010a1dd:	e8 8e 0e 00 00       	call   f010b070 <allocate_environment>
f010a1e2:	83 c4 10             	add    $0x10,%esp
f010a1e5:	85 c0                	test   %eax,%eax
f010a1e7:	79 0a                	jns    f010a1f3 <env_create+0x66>
	{
		return NULL;
f010a1e9:	b8 00 00 00 00       	mov    $0x0,%eax
f010a1ee:	e9 77 09 00 00       	jmp    f010ab6a <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010a1f3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a1f6:	8b 00                	mov    (%eax),%eax
f010a1f8:	83 ec 0c             	sub    $0xc,%esp
f010a1fb:	50                   	push   %eax
f010a1fc:	e8 4c 49 01 00       	call   f011eb4d <strlen>
f010a201:	83 c4 10             	add    $0x10,%esp
f010a204:	83 f8 3f             	cmp    $0x3f,%eax
f010a207:	7f 1d                	jg     f010a226 <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010a209:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a20c:	8b 00                	mov    (%eax),%eax
f010a20e:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a214:	83 c2 20             	add    $0x20,%edx
f010a217:	83 ec 08             	sub    $0x8,%esp
f010a21a:	50                   	push   %eax
f010a21b:	52                   	push   %edx
f010a21c:	e8 7b 49 01 00       	call   f011eb9c <strcpy>
f010a221:	83 c4 10             	add    $0x10,%esp
f010a224:	eb 1d                	jmp    f010a243 <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010a226:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a229:	8b 00                	mov    (%eax),%eax
f010a22b:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a231:	83 c2 20             	add    $0x20,%edx
f010a234:	83 ec 04             	sub    $0x4,%esp
f010a237:	6a 3f                	push   $0x3f
f010a239:	50                   	push   %eax
f010a23a:	52                   	push   %edx
f010a23b:	e8 8a 49 01 00       	call   f011ebca <strncpy>
f010a240:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010a243:	e8 f4 13 00 00       	call   f010b63c <create_user_directory>
f010a248:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010a24b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a24e:	83 ec 0c             	sub    $0xc,%esp
f010a251:	50                   	push   %eax
f010a252:	e8 fd ed ff ff       	call   f0109054 <kheap_physical_address>
f010a257:	83 c4 10             	add    $0x10,%esp
f010a25a:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010a25d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a263:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a266:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a26c:	83 ec 0c             	sub    $0xc,%esp
f010a26f:	6a 02                	push   $0x2
f010a271:	e8 b5 44 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f010a276:	83 c4 10             	add    $0x10,%esp
f010a279:	85 c0                	test   %eax,%eax
f010a27b:	74 21                	je     f010a29e <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010a27d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a283:	8b 55 10             	mov    0x10(%ebp),%edx
f010a286:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010a28c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a292:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a295:	2b 55 10             	sub    0x10(%ebp),%edx
f010a298:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010a29e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010a2a2:	75 12                	jne    f010a2b6 <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010a2a4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a2aa:	c7 80 80 05 00 00 0a 	movl   $0xa,0x580(%eax)
f010a2b1:	00 00 00 
f010a2b4:	eb 0f                	jmp    f010a2c5 <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010a2b6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a2bc:	8b 55 14             	mov    0x14(%ebp),%edx
f010a2bf:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010a2c5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a2cb:	83 ec 04             	sub    $0x4,%esp
f010a2ce:	ff 75 bc             	pushl  -0x44(%ebp)
f010a2d1:	ff 75 c0             	pushl  -0x40(%ebp)
f010a2d4:	50                   	push   %eax
f010a2d5:	e8 dd 13 00 00       	call   f010b6b7 <initialize_environment>
f010a2da:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010a2dd:	e8 82 ce ff ff       	call   f0107164 <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010a2e2:	0f 20 d8             	mov    %cr3,%eax
f010a2e5:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010a2e8:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010a2eb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010a2ee:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a2f4:	8b 40 68             	mov    0x68(%eax),%eax
f010a2f7:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010a2fd:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010a303:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010a306:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010a30d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010a314:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a31a:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010a320:	48                   	dec    %eax
f010a321:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010a324:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010a32b:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010a32e:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010a334:	83 ec 08             	sub    $0x8,%esp
f010a337:	ff 75 c8             	pushl  -0x38(%ebp)
f010a33a:	50                   	push   %eax
f010a33b:	e8 2c 19 00 00       	call   f010bc6c <PROGRAM_SEGMENT_FIRST>
f010a340:	83 c4 0c             	add    $0xc,%esp
f010a343:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010a349:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010a34f:	b9 05 00 00 00       	mov    $0x5,%ecx
f010a354:	89 c7                	mov    %eax,%edi
f010a356:	89 d6                	mov    %edx,%esi
f010a358:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010a35a:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010a360:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a363:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a366:	8b 40 10             	mov    0x10(%eax),%eax
f010a369:	83 f8 ff             	cmp    $0xffffffff,%eax
f010a36c:	75 07                	jne    f010a375 <env_create+0x1e8>
f010a36e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010a375:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a378:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a37b:	e9 fa 02 00 00       	jmp    f010a67a <env_create+0x4ed>
		{
			segment_counter++;
f010a380:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010a383:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010a38a:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010a38d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a393:	83 ec 0c             	sub    $0xc,%esp
f010a396:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010a39c:	52                   	push   %edx
f010a39d:	ff 75 ec             	pushl  -0x14(%ebp)
f010a3a0:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010a3a6:	52                   	push   %edx
f010a3a7:	ff 75 f4             	pushl  -0xc(%ebp)
f010a3aa:	50                   	push   %eax
f010a3ab:	e8 7e 0d 00 00       	call   f010b12e <program_segment_alloc_map_copy_workingset>
f010a3b0:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010a3b3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a3b9:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010a3bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a3bf:	8b 00                	mov    (%eax),%eax
f010a3c1:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010a3c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a3c7:	8b 40 0c             	mov    0xc(%eax),%eax
f010a3ca:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010a3cd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a3d0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010a3d3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010a3d6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a3db:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010a3de:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010a3e5:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010a3e8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010a3eb:	01 d0                	add    %edx,%eax
f010a3ed:	48                   	dec    %eax
f010a3ee:	89 45 98             	mov    %eax,-0x68(%ebp)
f010a3f1:	8b 45 98             	mov    -0x68(%ebp),%eax
f010a3f4:	ba 00 00 00 00       	mov    $0x0,%edx
f010a3f9:	f7 75 9c             	divl   -0x64(%ebp)
f010a3fc:	8b 45 98             	mov    -0x68(%ebp),%eax
f010a3ff:	29 d0                	sub    %edx,%eax
f010a401:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010a404:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a407:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010a40a:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010a40d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010a410:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010a413:	8b 15 0c 4a 5f f0    	mov    0xf05f4a0c,%edx
f010a419:	8b 45 90             	mov    -0x70(%ebp),%eax
f010a41c:	01 d0                	add    %edx,%eax
f010a41e:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010a421:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010a425:	74 73                	je     f010a49a <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010a427:	a1 0c 4a 5f f0       	mov    0xf05f4a0c,%eax
f010a42c:	83 ec 04             	sub    $0x4,%esp
f010a42f:	68 00 10 00 00       	push   $0x1000
f010a434:	6a 00                	push   $0x0
f010a436:	50                   	push   %eax
f010a437:	e8 ff 48 01 00       	call   f011ed3b <memset>
f010a43c:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010a43f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a442:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a445:	eb 13                	jmp    f010a45a <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010a447:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a44a:	8a 10                	mov    (%eax),%dl
f010a44c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a44f:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010a451:	ff 45 dc             	incl   -0x24(%ebp)
f010a454:	ff 45 e4             	incl   -0x1c(%ebp)
f010a457:	ff 45 e0             	incl   -0x20(%ebp)
f010a45a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a45d:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010a460:	72 e5                	jb     f010a447 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010a462:	8b 15 0c 4a 5f f0    	mov    0xf05f4a0c,%edx
f010a468:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a46e:	83 ec 04             	sub    $0x4,%esp
f010a471:	52                   	push   %edx
f010a472:	ff 75 a0             	pushl  -0x60(%ebp)
f010a475:	50                   	push   %eax
f010a476:	e8 b3 9d ff ff       	call   f010422e <pf_add_env_page>
f010a47b:	83 c4 10             	add    $0x10,%esp
f010a47e:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a481:	75 17                	jne    f010a49a <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a483:	83 ec 04             	sub    $0x4,%esp
f010a486:	68 64 52 12 f0       	push   $0xf0125264
f010a48b:	68 f4 00 00 00       	push   $0xf4
f010a490:	68 47 52 12 f0       	push   $0xf0125247
f010a495:	e8 9f 5e ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010a49a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a49d:	8b 50 04             	mov    0x4(%eax),%edx
f010a4a0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a4a3:	01 d0                	add    %edx,%eax
f010a4a5:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010a4a8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010a4ab:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a4b0:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010a4b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4b6:	8b 50 04             	mov    0x4(%eax),%edx
f010a4b9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a4bc:	01 d0                	add    %edx,%eax
f010a4be:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010a4c1:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010a4c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a4c7:	eb 43                	jmp    f010a50c <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010a4c9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010a4cc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a4d2:	83 ec 04             	sub    $0x4,%esp
f010a4d5:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a4d8:	52                   	push   %edx
f010a4d9:	50                   	push   %eax
f010a4da:	e8 4f 9d ff ff       	call   f010422e <pf_add_env_page>
f010a4df:	83 c4 10             	add    $0x10,%esp
f010a4e2:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a4e5:	75 17                	jne    f010a4fe <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a4e7:	83 ec 04             	sub    $0x4,%esp
f010a4ea:	68 64 52 12 f0       	push   $0xf0125264
f010a4ef:	68 01 01 00 00       	push   $0x101
f010a4f4:	68 47 52 12 f0       	push   $0xf0125247
f010a4f9:	e8 3b 5e ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010a4fe:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010a505:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010a50c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a50f:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010a512:	72 b5                	jb     f010a4c9 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010a514:	a1 0c 4a 5f f0       	mov    0xf05f4a0c,%eax
f010a519:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010a51c:	83 ec 04             	sub    $0x4,%esp
f010a51f:	68 00 10 00 00       	push   $0x1000
f010a524:	6a 00                	push   $0x0
f010a526:	ff 75 e0             	pushl  -0x20(%ebp)
f010a529:	e8 0d 48 01 00       	call   f011ed3b <memset>
f010a52e:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010a531:	8b 45 88             	mov    -0x78(%ebp),%eax
f010a534:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a537:	eb 13                	jmp    f010a54c <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010a539:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a53c:	8a 10                	mov    (%eax),%dl
f010a53e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a541:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010a543:	ff 45 dc             	incl   -0x24(%ebp)
f010a546:	ff 45 e4             	incl   -0x1c(%ebp)
f010a549:	ff 45 e0             	incl   -0x20(%ebp)
f010a54c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a54f:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010a552:	72 e5                	jb     f010a539 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010a554:	8b 15 0c 4a 5f f0    	mov    0xf05f4a0c,%edx
f010a55a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a560:	83 ec 04             	sub    $0x4,%esp
f010a563:	52                   	push   %edx
f010a564:	ff 75 88             	pushl  -0x78(%ebp)
f010a567:	50                   	push   %eax
f010a568:	e8 c1 9c ff ff       	call   f010422e <pf_add_env_page>
f010a56d:	83 c4 10             	add    $0x10,%esp
f010a570:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a573:	75 17                	jne    f010a58c <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a575:	83 ec 04             	sub    $0x4,%esp
f010a578:	68 64 52 12 f0       	push   $0xf0125264
f010a57d:	68 10 01 00 00       	push   $0x110
f010a582:	68 47 52 12 f0       	push   $0xf0125247
f010a587:	e8 ad 5d ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010a58c:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010a593:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a596:	8b 50 04             	mov    0x4(%eax),%edx
f010a599:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a59c:	01 c2                	add    %eax,%edx
f010a59e:	8b 45 80             	mov    -0x80(%ebp),%eax
f010a5a1:	01 d0                	add    %edx,%eax
f010a5a3:	48                   	dec    %eax
f010a5a4:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010a5aa:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010a5b0:	ba 00 00 00 00       	mov    $0x0,%edx
f010a5b5:	f7 75 80             	divl   -0x80(%ebp)
f010a5b8:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010a5be:	29 d0                	sub    %edx,%eax
f010a5c0:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010a5c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5c6:	8b 50 08             	mov    0x8(%eax),%edx
f010a5c9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a5cc:	01 d0                	add    %edx,%eax
f010a5ce:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010a5d1:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010a5d7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010a5de:	eb 41                	jmp    f010a621 <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010a5e0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a5e6:	83 ec 04             	sub    $0x4,%esp
f010a5e9:	6a 01                	push   $0x1
f010a5eb:	ff 75 d8             	pushl  -0x28(%ebp)
f010a5ee:	50                   	push   %eax
f010a5ef:	e8 0c 9b ff ff       	call   f0104100 <pf_add_empty_env_page>
f010a5f4:	83 c4 10             	add    $0x10,%esp
f010a5f7:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a5fa:	75 17                	jne    f010a613 <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a5fc:	83 ec 04             	sub    $0x4,%esp
f010a5ff:	68 64 52 12 f0       	push   $0xf0125264
f010a604:	68 1d 01 00 00       	push   $0x11d
f010a609:	68 47 52 12 f0       	push   $0xf0125247
f010a60e:	e8 26 5d ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010a613:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010a61a:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010a621:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010a628:	10 00 00 
f010a62b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010a631:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010a637:	01 d0                	add    %edx,%eax
f010a639:	48                   	dec    %eax
f010a63a:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010a640:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010a646:	ba 00 00 00 00       	mov    $0x0,%edx
f010a64b:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010a651:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010a657:	29 d0                	sub    %edx,%eax
f010a659:	89 c2                	mov    %eax,%edx
f010a65b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a65e:	39 c2                	cmp    %eax,%edx
f010a660:	0f 87 7a ff ff ff    	ja     f010a5e0 <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010a666:	83 ec 08             	sub    $0x8,%esp
f010a669:	ff 75 c8             	pushl  -0x38(%ebp)
f010a66c:	ff 75 f4             	pushl  -0xc(%ebp)
f010a66f:	e8 ed 14 00 00       	call   f010bb61 <PROGRAM_SEGMENT_NEXT>
f010a674:	83 c4 10             	add    $0x10,%esp
f010a677:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a67a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a67e:	0f 85 fc fc ff ff    	jne    f010a380 <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a684:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a68a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010a690:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a693:	eb 77                	jmp    f010a70c <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010a695:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a698:	8b 00                	mov    (%eax),%eax
f010a69a:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010a6a0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a6a6:	8b 40 64             	mov    0x64(%eax),%eax
f010a6a9:	83 ec 04             	sub    $0x4,%esp
f010a6ac:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010a6b2:	52                   	push   %edx
f010a6b3:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010a6b9:	50                   	push   %eax
f010a6ba:	e8 c5 dc ff ff       	call   f0108384 <get_page_table>
f010a6bf:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010a6c2:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010a6c8:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010a6ce:	c1 ea 0c             	shr    $0xc,%edx
f010a6d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a6d7:	c1 e2 02             	shl    $0x2,%edx
f010a6da:	01 d0                	add    %edx,%eax
f010a6dc:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010a6e2:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010a6e8:	c1 e9 0c             	shr    $0xc,%ecx
f010a6eb:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010a6f1:	c1 e1 02             	shl    $0x2,%ecx
f010a6f4:	01 ca                	add    %ecx,%edx
f010a6f6:	8b 12                	mov    (%edx),%edx
f010a6f8:	83 e2 bf             	and    $0xffffffbf,%edx
f010a6fb:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a6fd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a703:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a709:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a70c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a712:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a716:	74 08                	je     f010a720 <env_create+0x593>
f010a718:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a71b:	8b 52 10             	mov    0x10(%edx),%edx
f010a71e:	eb 05                	jmp    f010a725 <env_create+0x598>
f010a720:	ba 00 00 00 00       	mov    $0x0,%edx
f010a725:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010a72b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a731:	85 c0                	test   %eax,%eax
f010a733:	0f 85 5c ff ff ff    	jne    f010a695 <env_create+0x508>
f010a739:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a73d:	0f 85 52 ff ff ff    	jne    f010a695 <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010a743:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a746:	8b 50 08             	mov    0x8(%eax),%edx
f010a749:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a74f:	83 ec 08             	sub    $0x8,%esp
f010a752:	52                   	push   %edx
f010a753:	50                   	push   %eax
f010a754:	e8 c8 13 00 00       	call   f010bb21 <set_environment_entry_point>
f010a759:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010a75c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a762:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010a769:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010a770:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010a773:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a77a:	e9 42 03 00 00       	jmp    f010aac1 <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010a77f:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010a786:	00 00 00 
			allocate_frame(&pp);
f010a789:	83 ec 0c             	sub    $0xc,%esp
f010a78c:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010a792:	50                   	push   %eax
f010a793:	e8 af d9 ff ff       	call   f0108147 <allocate_frame>
f010a798:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010a79b:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010a7a1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a7a7:	8b 40 64             	mov    0x64(%eax),%eax
f010a7aa:	6a 06                	push   $0x6
f010a7ac:	ff 75 d0             	pushl  -0x30(%ebp)
f010a7af:	52                   	push   %edx
f010a7b0:	50                   	push   %eax
f010a7b1:	e8 62 e0 ff ff       	call   f0108818 <loadtime_map_frame>
f010a7b6:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010a7b9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a7bc:	83 ec 04             	sub    $0x4,%esp
f010a7bf:	68 00 10 00 00       	push   $0x1000
f010a7c4:	6a 00                	push   $0x0
f010a7c6:	50                   	push   %eax
f010a7c7:	e8 6f 45 01 00       	call   f011ed3b <memset>
f010a7cc:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010a7cf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a7d5:	83 ec 08             	sub    $0x8,%esp
f010a7d8:	ff 75 d0             	pushl  -0x30(%ebp)
f010a7db:	50                   	push   %eax
f010a7dc:	e8 05 eb ff ff       	call   f01092e6 <env_page_ws_list_create_element>
f010a7e1:	83 c4 10             	add    $0x10,%esp
f010a7e4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010a7e7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a7eb:	75 17                	jne    f010a804 <env_create+0x677>
f010a7ed:	83 ec 04             	sub    $0x4,%esp
f010a7f0:	68 ac 52 12 f0       	push   $0xf01252ac
f010a7f5:	68 5c 01 00 00       	push   $0x15c
f010a7fa:	68 47 52 12 f0       	push   $0xf0125247
f010a7ff:	e8 35 5b ff ff       	call   f0100339 <_panic>
f010a804:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a80a:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010a810:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a813:	89 50 14             	mov    %edx,0x14(%eax)
f010a816:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a819:	8b 40 14             	mov    0x14(%eax),%eax
f010a81c:	85 c0                	test   %eax,%eax
f010a81e:	74 14                	je     f010a834 <env_create+0x6a7>
f010a820:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a826:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010a82c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a82f:	89 50 10             	mov    %edx,0x10(%eax)
f010a832:	eb 0f                	jmp    f010a843 <env_create+0x6b6>
f010a834:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a83a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a83d:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010a843:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a849:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a84c:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010a852:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a855:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a85c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a862:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010a868:	42                   	inc    %edx
f010a869:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010a86f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a875:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010a87b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a881:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010a887:	39 c2                	cmp    %eax,%edx
f010a889:	75 1a                	jne    f010a8a5 <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010a88b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a891:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a897:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
f010a89d:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a8a3:	eb 10                	jmp    f010a8b5 <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010a8a5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a8ab:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010a8b2:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a8b5:	83 ec 0c             	sub    $0xc,%esp
f010a8b8:	6a 02                	push   $0x2
f010a8ba:	e8 6c 3e 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f010a8bf:	83 c4 10             	add    $0x10,%esp
f010a8c2:	85 c0                	test   %eax,%eax
f010a8c4:	0f 84 d3 01 00 00    	je     f010aa9d <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010a8ca:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a8ce:	75 17                	jne    f010a8e7 <env_create+0x75a>
f010a8d0:	83 ec 04             	sub    $0x4,%esp
f010a8d3:	68 cf 52 12 f0       	push   $0xf01252cf
f010a8d8:	68 69 01 00 00       	push   $0x169
f010a8dd:	68 47 52 12 f0       	push   $0xf0125247
f010a8e2:	e8 52 5a ff ff       	call   f0100339 <_panic>
f010a8e7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a8ea:	8b 40 10             	mov    0x10(%eax),%eax
f010a8ed:	85 c0                	test   %eax,%eax
f010a8ef:	74 11                	je     f010a902 <env_create+0x775>
f010a8f1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a8f4:	8b 40 10             	mov    0x10(%eax),%eax
f010a8f7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a8fa:	8b 52 14             	mov    0x14(%edx),%edx
f010a8fd:	89 50 14             	mov    %edx,0x14(%eax)
f010a900:	eb 12                	jmp    f010a914 <env_create+0x787>
f010a902:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a908:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a90b:	8b 52 14             	mov    0x14(%edx),%edx
f010a90e:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010a914:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a917:	8b 40 14             	mov    0x14(%eax),%eax
f010a91a:	85 c0                	test   %eax,%eax
f010a91c:	74 11                	je     f010a92f <env_create+0x7a2>
f010a91e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a921:	8b 40 14             	mov    0x14(%eax),%eax
f010a924:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a927:	8b 52 10             	mov    0x10(%edx),%edx
f010a92a:	89 50 10             	mov    %edx,0x10(%eax)
f010a92d:	eb 12                	jmp    f010a941 <env_create+0x7b4>
f010a92f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a935:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a938:	8b 52 10             	mov    0x10(%edx),%edx
f010a93b:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010a941:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a944:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a94b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a94e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a955:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a95b:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010a961:	4a                   	dec    %edx
f010a962:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010a968:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a96e:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010a974:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a97a:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a980:	39 c2                	cmp    %eax,%edx
f010a982:	0f 83 8d 00 00 00    	jae    f010aa15 <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010a988:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a98c:	75 17                	jne    f010a9a5 <env_create+0x818>
f010a98e:	83 ec 04             	sub    $0x4,%esp
f010a991:	68 24 52 12 f0       	push   $0xf0125224
f010a996:	68 6e 01 00 00       	push   $0x16e
f010a99b:	68 47 52 12 f0       	push   $0xf0125247
f010a9a0:	e8 94 59 ff ff       	call   f0100339 <_panic>
f010a9a5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9ab:	8b 90 54 05 00 00    	mov    0x554(%eax),%edx
f010a9b1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a9b4:	89 50 10             	mov    %edx,0x10(%eax)
f010a9b7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a9ba:	8b 40 10             	mov    0x10(%eax),%eax
f010a9bd:	85 c0                	test   %eax,%eax
f010a9bf:	74 14                	je     f010a9d5 <env_create+0x848>
f010a9c1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9c7:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010a9cd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a9d0:	89 50 14             	mov    %edx,0x14(%eax)
f010a9d3:	eb 0f                	jmp    f010a9e4 <env_create+0x857>
f010a9d5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9db:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a9de:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f010a9e4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9ea:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a9ed:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f010a9f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a9f6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a9fd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa03:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010aa09:	42                   	inc    %edx
f010aa0a:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010aa10:	e9 88 00 00 00       	jmp    f010aa9d <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010aa15:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010aa19:	75 17                	jne    f010aa32 <env_create+0x8a5>
f010aa1b:	83 ec 04             	sub    $0x4,%esp
f010aa1e:	68 24 52 12 f0       	push   $0xf0125224
f010aa23:	68 72 01 00 00       	push   $0x172
f010aa28:	68 47 52 12 f0       	push   $0xf0125247
f010aa2d:	e8 07 59 ff ff       	call   f0100339 <_panic>
f010aa32:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa38:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010aa3e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aa41:	89 50 10             	mov    %edx,0x10(%eax)
f010aa44:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aa47:	8b 40 10             	mov    0x10(%eax),%eax
f010aa4a:	85 c0                	test   %eax,%eax
f010aa4c:	74 14                	je     f010aa62 <env_create+0x8d5>
f010aa4e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa54:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010aa5a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aa5d:	89 50 14             	mov    %edx,0x14(%eax)
f010aa60:	eb 0f                	jmp    f010aa71 <env_create+0x8e4>
f010aa62:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa68:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aa6b:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010aa71:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa77:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aa7a:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010aa80:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aa83:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010aa8a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa90:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010aa96:	42                   	inc    %edx
f010aa97:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010aa9d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aaa3:	83 ec 04             	sub    $0x4,%esp
f010aaa6:	6a 01                	push   $0x1
f010aaa8:	ff 75 d0             	pushl  -0x30(%ebp)
f010aaab:	50                   	push   %eax
f010aaac:	e8 4f 96 ff ff       	call   f0104100 <pf_add_empty_env_page>
f010aab1:	83 c4 10             	add    $0x10,%esp
f010aab4:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010aaba:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010aac1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010aac4:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010aaca:	0f 83 af fc ff ff    	jae    f010a77f <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010aad0:	83 ec 0c             	sub    $0xc,%esp
f010aad3:	6a 02                	push   $0x2
f010aad5:	e8 51 3c 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f010aada:	83 c4 10             	add    $0x10,%esp
f010aadd:	85 c0                	test   %eax,%eax
f010aadf:	74 72                	je     f010ab53 <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010aae1:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010aae8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aaee:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010aaf4:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010aaf7:	eb 2b                	jmp    f010ab24 <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010aaf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010aafc:	8b 10                	mov    (%eax),%edx
f010aafe:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab04:	8b 40 64             	mov    0x64(%eax),%eax
f010ab07:	6a 01                	push   $0x1
f010ab09:	6a 00                	push   $0x0
f010ab0b:	52                   	push   %edx
f010ab0c:	50                   	push   %eax
f010ab0d:	e8 9e e5 ff ff       	call   f01090b0 <pt_set_page_permissions>
f010ab12:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010ab15:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab1b:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010ab21:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010ab24:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab2a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010ab2e:	74 08                	je     f010ab38 <env_create+0x9ab>
f010ab30:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ab33:	8b 52 10             	mov    0x10(%edx),%edx
f010ab36:	eb 05                	jmp    f010ab3d <env_create+0x9b0>
f010ab38:	ba 00 00 00 00       	mov    $0x0,%edx
f010ab3d:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010ab43:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010ab49:	85 c0                	test   %eax,%eax
f010ab4b:	75 ac                	jne    f010aaf9 <env_create+0x96c>
f010ab4d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010ab51:	75 a6                	jne    f010aaf9 <env_create+0x96c>
f010ab53:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010ab56:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010ab59:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010ab5c:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010ab5f:	e8 52 c6 ff ff       	call   f01071b6 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010ab64:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010ab6a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010ab6d:	5e                   	pop    %esi
f010ab6e:	5f                   	pop    %edi
f010ab6f:	5d                   	pop    %ebp
f010ab70:	c3                   	ret    

f010ab71 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010ab71:	55                   	push   %ebp
f010ab72:	89 e5                	mov    %esp,%ebp
f010ab74:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010ab77:	83 ec 0c             	sub    $0xc,%esp
f010ab7a:	68 c0 42 5f f0       	push   $0xf05f42c0
f010ab7f:	e8 8f 40 00 00       	call   f010ec13 <release_spinlock>
f010ab84:	83 c4 10             	add    $0x10,%esp

	if (first)
f010ab87:	a1 60 c9 17 f0       	mov    0xf017c960,%eax
f010ab8c:	85 c0                	test   %eax,%eax
f010ab8e:	74 30                	je     f010abc0 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010ab90:	e8 76 00 00 00       	call   f010ac0b <get_cpu_proc>
f010ab95:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010ab98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab9b:	8b 40 10             	mov    0x10(%eax),%eax
f010ab9e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aba1:	83 c2 20             	add    $0x20,%edx
f010aba4:	83 ec 04             	sub    $0x4,%esp
f010aba7:	50                   	push   %eax
f010aba8:	52                   	push   %edx
f010aba9:	68 ed 52 12 f0       	push   $0xf01252ed
f010abae:	e8 d8 63 ff ff       	call   f0100f8b <cprintf>
f010abb3:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010abb6:	c7 05 60 c9 17 f0 00 	movl   $0x0,0xf017c960
f010abbd:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010abc0:	90                   	nop
f010abc1:	c9                   	leave  
f010abc2:	c3                   	ret    

f010abc3 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010abc3:	55                   	push   %ebp
f010abc4:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010abc6:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010abc7:	5d                   	pop    %ebp
f010abc8:	c3                   	ret    

f010abc9 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010abc9:	55                   	push   %ebp
f010abca:	89 e5                	mov    %esp,%ebp
f010abcc:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010abcf:	e8 37 00 00 00       	call   f010ac0b <get_cpu_proc>
f010abd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010abd7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010abdb:	75 19                	jne    f010abf6 <env_exit+0x2d>
f010abdd:	68 03 53 12 f0       	push   $0xf0125303
f010abe2:	68 13 53 12 f0       	push   $0xf0125313
f010abe7:	68 ec 01 00 00       	push   $0x1ec
f010abec:	68 47 52 12 f0       	push   $0xf0125247
f010abf1:	e8 43 57 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010abf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abf9:	8b 40 10             	mov    0x10(%eax),%eax
f010abfc:	83 ec 0c             	sub    $0xc,%esp
f010abff:	50                   	push   %eax
f010ac00:	e8 c2 ab ff ff       	call   f01057c7 <sched_exit_env>
f010ac05:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010ac08:	90                   	nop
f010ac09:	c9                   	leave  
f010ac0a:	c3                   	ret    

f010ac0b <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010ac0b:	55                   	push   %ebp
f010ac0c:	89 e5                	mov    %esp,%ebp
f010ac0e:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010ac11:	e8 4e c5 ff ff       	call   f0107164 <pushcli>
	c = mycpu();
f010ac16:	e8 86 c4 ff ff       	call   f01070a1 <mycpu>
f010ac1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010ac1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac21:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010ac27:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010ac2a:	e8 87 c5 ff ff       	call   f01071b6 <popcli>
	return p;
f010ac2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010ac32:	c9                   	leave  
f010ac33:	c3                   	ret    

f010ac34 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010ac34:	55                   	push   %ebp
f010ac35:	89 e5                	mov    %esp,%ebp
f010ac37:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010ac3a:	e8 25 c5 ff ff       	call   f0107164 <pushcli>
	c = mycpu();
f010ac3f:	e8 5d c4 ff ff       	call   f01070a1 <mycpu>
f010ac44:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010ac47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac4a:	8b 55 08             	mov    0x8(%ebp),%edx
f010ac4d:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010ac53:	e8 5e c5 ff ff       	call   f01071b6 <popcli>
}
f010ac58:	90                   	nop
f010ac59:	c9                   	leave  
f010ac5a:	c3                   	ret    

f010ac5b <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010ac5b:	55                   	push   %ebp
f010ac5c:	89 e5                	mov    %esp,%ebp
f010ac5e:	53                   	push   %ebx
f010ac5f:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010ac62:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ac66:	75 16                	jne    f010ac7e <envid2env+0x23>
		*env_store = get_cpu_proc();
f010ac68:	e8 9e ff ff ff       	call   f010ac0b <get_cpu_proc>
f010ac6d:	89 c2                	mov    %eax,%edx
f010ac6f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ac72:	89 10                	mov    %edx,(%eax)
		return 0;
f010ac74:	b8 00 00 00 00       	mov    $0x0,%eax
f010ac79:	e9 a2 00 00 00       	jmp    f010ad20 <envid2env+0xc5>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010ac7e:	8b 1d d0 b7 5c f0    	mov    0xf05cb7d0,%ebx
f010ac84:	83 ec 0c             	sub    $0xc,%esp
f010ac87:	68 d0 02 00 00       	push   $0x2d0
f010ac8c:	e8 1a 24 01 00       	call   f011d0ab <nearest_pow2_ceil>
f010ac91:	83 c4 10             	add    $0x10,%esp
f010ac94:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ac97:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac9a:	21 c2                	and    %eax,%edx
f010ac9c:	89 d0                	mov    %edx,%eax
f010ac9e:	c1 e0 02             	shl    $0x2,%eax
f010aca1:	01 d0                	add    %edx,%eax
f010aca3:	01 c0                	add    %eax,%eax
f010aca5:	01 d0                	add    %edx,%eax
f010aca7:	c1 e0 02             	shl    $0x2,%eax
f010acaa:	01 d0                	add    %edx,%eax
f010acac:	01 c0                	add    %eax,%eax
f010acae:	01 d0                	add    %edx,%eax
f010acb0:	c1 e0 04             	shl    $0x4,%eax
f010acb3:	01 d8                	add    %ebx,%eax
f010acb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010acb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acbb:	8b 40 18             	mov    0x18(%eax),%eax
f010acbe:	85 c0                	test   %eax,%eax
f010acc0:	74 0b                	je     f010accd <envid2env+0x72>
f010acc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acc5:	8b 40 10             	mov    0x10(%eax),%eax
f010acc8:	3b 45 08             	cmp    0x8(%ebp),%eax
f010accb:	74 10                	je     f010acdd <envid2env+0x82>
		*env_store = 0;
f010accd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acd0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010acd6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010acdb:	eb 43                	jmp    f010ad20 <envid2env+0xc5>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010acdd:	e8 29 ff ff ff       	call   f010ac0b <get_cpu_proc>
f010ace2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010ace5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010ace9:	74 28                	je     f010ad13 <envid2env+0xb8>
f010aceb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acee:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010acf1:	74 20                	je     f010ad13 <envid2env+0xb8>
f010acf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acf6:	8b 50 14             	mov    0x14(%eax),%edx
f010acf9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010acfc:	8b 40 10             	mov    0x10(%eax),%eax
f010acff:	39 c2                	cmp    %eax,%edx
f010ad01:	74 10                	je     f010ad13 <envid2env+0xb8>
		*env_store = 0;
f010ad03:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad06:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010ad0c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010ad11:	eb 0d                	jmp    f010ad20 <envid2env+0xc5>
	}

	*env_store = e;
f010ad13:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad16:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad19:	89 10                	mov    %edx,(%eax)
	return 0;
f010ad1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ad20:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ad23:	c9                   	leave  
f010ad24:	c3                   	ret    

f010ad25 <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010ad25:	55                   	push   %ebp
f010ad26:	89 e5                	mov    %esp,%ebp
f010ad28:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010ad2b:	83 ec 0c             	sub    $0xc,%esp
f010ad2e:	68 c0 42 5f f0       	push   $0xf05f42c0
f010ad33:	e8 54 3e 00 00       	call   f010eb8c <acquire_spinlock>
f010ad38:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010ad3b:	e8 cb fe ff ff       	call   f010ac0b <get_cpu_proc>
f010ad40:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010ad43:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ad47:	75 19                	jne    f010ad62 <yield+0x3d>
f010ad49:	68 28 53 12 f0       	push   $0xf0125328
f010ad4e:	68 13 53 12 f0       	push   $0xf0125313
f010ad53:	68 4b 02 00 00       	push   $0x24b
f010ad58:	68 47 52 12 f0       	push   $0xf0125247
f010ad5d:	e8 d7 55 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010ad62:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad65:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010ad6c:	e8 13 00 00 00       	call   f010ad84 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010ad71:	83 ec 0c             	sub    $0xc,%esp
f010ad74:	68 c0 42 5f f0       	push   $0xf05f42c0
f010ad79:	e8 95 3e 00 00       	call   f010ec13 <release_spinlock>
f010ad7e:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010ad81:	90                   	nop
f010ad82:	c9                   	leave  
f010ad83:	c3                   	ret    

f010ad84 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010ad84:	55                   	push   %ebp
f010ad85:	89 e5                	mov    %esp,%ebp
f010ad87:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010ad8a:	e8 7c fe ff ff       	call   f010ac0b <get_cpu_proc>
f010ad8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010ad92:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ad96:	75 19                	jne    f010adb1 <sched+0x2d>
f010ad98:	68 28 53 12 f0       	push   $0xf0125328
f010ad9d:	68 13 53 12 f0       	push   $0xf0125313
f010ada2:	68 5f 02 00 00       	push   $0x25f
f010ada7:	68 47 52 12 f0       	push   $0xf0125247
f010adac:	e8 88 55 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010adb1:	83 ec 0c             	sub    $0xc,%esp
f010adb4:	68 c0 42 5f f0       	push   $0xf05f42c0
f010adb9:	e8 e7 3f 00 00       	call   f010eda5 <holding_spinlock>
f010adbe:	83 c4 10             	add    $0x10,%esp
f010adc1:	85 c0                	test   %eax,%eax
f010adc3:	75 17                	jne    f010addc <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010adc5:	83 ec 04             	sub    $0x4,%esp
f010adc8:	68 34 53 12 f0       	push   $0xf0125334
f010adcd:	68 63 02 00 00       	push   $0x263
f010add2:	68 47 52 12 f0       	push   $0xf0125247
f010add7:	e8 5d 55 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010addc:	e8 c0 c2 ff ff       	call   f01070a1 <mycpu>
f010ade1:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010ade7:	83 f8 01             	cmp    $0x1,%eax
f010adea:	74 20                	je     f010ae0c <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010adec:	e8 b0 c2 ff ff       	call   f01070a1 <mycpu>
f010adf1:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010adf7:	50                   	push   %eax
f010adf8:	68 76 53 12 f0       	push   $0xf0125376
f010adfd:	68 66 02 00 00       	push   $0x266
f010ae02:	68 47 52 12 f0       	push   $0xf0125247
f010ae07:	e8 2d 55 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010ae0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae0f:	8b 40 18             	mov    0x18(%eax),%eax
f010ae12:	83 f8 02             	cmp    $0x2,%eax
f010ae15:	75 17                	jne    f010ae2e <sched+0xaa>
		panic("sched a running process");
f010ae17:	83 ec 04             	sub    $0x4,%esp
f010ae1a:	68 8d 53 12 f0       	push   $0xf012538d
f010ae1f:	68 69 02 00 00       	push   $0x269
f010ae24:	68 47 52 12 f0       	push   $0xf0125247
f010ae29:	e8 0b 55 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010ae2e:	9c                   	pushf  
f010ae2f:	58                   	pop    %eax
f010ae30:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010ae33:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010ae36:	25 00 02 00 00       	and    $0x200,%eax
f010ae3b:	85 c0                	test   %eax,%eax
f010ae3d:	74 17                	je     f010ae56 <sched+0xd2>
		panic("sched is interruptible!");
f010ae3f:	83 ec 04             	sub    $0x4,%esp
f010ae42:	68 a5 53 12 f0       	push   $0xf01253a5
f010ae47:	68 6b 02 00 00       	push   $0x26b
f010ae4c:	68 47 52 12 f0       	push   $0xf0125247
f010ae51:	e8 e3 54 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010ae56:	e8 46 c2 ff ff       	call   f01070a1 <mycpu>
f010ae5b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010ae61:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010ae64:	e8 38 c2 ff ff       	call   f01070a1 <mycpu>
f010ae69:	8b 40 04             	mov    0x4(%eax),%eax
f010ae6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae6f:	83 c2 04             	add    $0x4,%edx
f010ae72:	83 ec 08             	sub    $0x8,%esp
f010ae75:	50                   	push   %eax
f010ae76:	52                   	push   %edx
f010ae77:	e8 93 9c ff ff       	call   f0104b0f <context_switch>
f010ae7c:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010ae7f:	e8 1d c2 ff ff       	call   f01070a1 <mycpu>
f010ae84:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ae87:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010ae8d:	90                   	nop
f010ae8e:	c9                   	leave  
f010ae8f:	c3                   	ret    

f010ae90 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010ae90:	55                   	push   %ebp
f010ae91:	89 e5                	mov    %esp,%ebp
f010ae93:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010ae96:	a1 a4 4a 5f f0       	mov    0xf05f4aa4,%eax
f010ae9b:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010ae9e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010aea1:	0f 22 d8             	mov    %eax,%cr3
}
f010aea4:	90                   	nop
f010aea5:	c9                   	leave  
f010aea6:	c3                   	ret    

f010aea7 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010aea7:	55                   	push   %ebp
f010aea8:	89 e5                	mov    %esp,%ebp
f010aeaa:	53                   	push   %ebx
f010aeab:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010aeae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010aeb2:	75 17                	jne    f010aecb <switchuvm+0x24>
		panic("switchuvm: no process");
f010aeb4:	83 ec 04             	sub    $0x4,%esp
f010aeb7:	68 bd 53 12 f0       	push   $0xf01253bd
f010aebc:	68 80 02 00 00       	push   $0x280
f010aec1:	68 47 52 12 f0       	push   $0xf0125247
f010aec6:	e8 6e 54 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010aecb:	8b 45 08             	mov    0x8(%ebp),%eax
f010aece:	8b 40 70             	mov    0x70(%eax),%eax
f010aed1:	85 c0                	test   %eax,%eax
f010aed3:	75 17                	jne    f010aeec <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010aed5:	83 ec 04             	sub    $0x4,%esp
f010aed8:	68 d3 53 12 f0       	push   $0xf01253d3
f010aedd:	68 82 02 00 00       	push   $0x282
f010aee2:	68 47 52 12 f0       	push   $0xf0125247
f010aee7:	e8 4d 54 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010aeec:	8b 45 08             	mov    0x8(%ebp),%eax
f010aeef:	8b 40 64             	mov    0x64(%eax),%eax
f010aef2:	85 c0                	test   %eax,%eax
f010aef4:	75 17                	jne    f010af0d <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010aef6:	83 ec 04             	sub    $0x4,%esp
f010aef9:	68 e8 53 12 f0       	push   $0xf01253e8
f010aefe:	68 84 02 00 00       	push   $0x284
f010af03:	68 47 52 12 f0       	push   $0xf0125247
f010af08:	e8 2c 54 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010af0d:	e8 52 c2 ff ff       	call   f0107164 <pushcli>
	struct cpu* c = mycpu();
f010af12:	e8 8a c1 ff ff       	call   f01070a1 <mycpu>
f010af17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010af1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af1d:	8b 55 08             	mov    0x8(%ebp),%edx
f010af20:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010af26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af29:	83 c0 0c             	add    $0xc,%eax
f010af2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af2f:	83 c2 0c             	add    $0xc,%edx
f010af32:	c1 ea 10             	shr    $0x10,%edx
f010af35:	88 d3                	mov    %dl,%bl
f010af37:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af3a:	83 c2 0c             	add    $0xc,%edx
f010af3d:	c1 ea 18             	shr    $0x18,%edx
f010af40:	88 d1                	mov    %dl,%cl
f010af42:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af45:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010af4c:	68 00 
f010af4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af51:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010af58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af5b:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010af61:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af64:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010af6a:	83 e2 f0             	and    $0xfffffff0,%edx
f010af6d:	83 ca 09             	or     $0x9,%edx
f010af70:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010af76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af79:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010af7f:	83 ca 10             	or     $0x10,%edx
f010af82:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010af88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af8b:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010af91:	83 e2 9f             	and    $0xffffff9f,%edx
f010af94:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010af9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af9d:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010afa3:	83 ca 80             	or     $0xffffff80,%edx
f010afa6:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010afac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afaf:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010afb5:	83 e2 f0             	and    $0xfffffff0,%edx
f010afb8:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010afbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afc1:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010afc7:	83 e2 ef             	and    $0xffffffef,%edx
f010afca:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010afd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afd3:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010afd9:	83 e2 df             	and    $0xffffffdf,%edx
f010afdc:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010afe2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afe5:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010afeb:	83 ca 40             	or     $0x40,%edx
f010afee:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010aff4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aff7:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010affd:	83 e2 7f             	and    $0x7f,%edx
f010b000:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b006:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b009:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010b00f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b012:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b018:	83 e2 ef             	and    $0xffffffef,%edx
f010b01b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010b021:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b024:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b02a:	8b 40 70             	mov    0x70(%eax),%eax
f010b02d:	05 00 80 00 00       	add    $0x8000,%eax
f010b032:	89 c2                	mov    %eax,%edx
f010b034:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b037:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010b03a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b03d:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010b043:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010b049:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010b04d:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010b050:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b053:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b059:	8b 40 68             	mov    0x68(%eax),%eax
f010b05c:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b05f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b062:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010b065:	e8 4c c1 ff ff       	call   f01071b6 <popcli>
}
f010b06a:	90                   	nop
f010b06b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b06e:	c9                   	leave  
f010b06f:	c3                   	ret    

f010b070 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010b070:	55                   	push   %ebp
f010b071:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010b073:	8b 15 d4 b7 5c f0    	mov    0xf05cb7d4,%edx
f010b079:	8b 45 08             	mov    0x8(%ebp),%eax
f010b07c:	89 10                	mov    %edx,(%eax)
f010b07e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b081:	8b 00                	mov    (%eax),%eax
f010b083:	85 c0                	test   %eax,%eax
f010b085:	75 07                	jne    f010b08e <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010b087:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010b08c:	eb 11                	jmp    f010b09f <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010b08e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b091:	8b 00                	mov    (%eax),%eax
f010b093:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010b09a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b09f:	5d                   	pop    %ebp
f010b0a0:	c3                   	ret    

f010b0a1 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010b0a1:	55                   	push   %ebp
f010b0a2:	89 e5                	mov    %esp,%ebp
f010b0a4:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010b0a7:	83 ec 04             	sub    $0x4,%esp
f010b0aa:	68 b0 05 00 00       	push   $0x5b0
f010b0af:	6a 00                	push   $0x0
f010b0b1:	ff 75 08             	pushl  0x8(%ebp)
f010b0b4:	e8 82 3c 01 00       	call   f011ed3b <memset>
f010b0b9:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010b0bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0bf:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010b0c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b0ca:	75 17                	jne    f010b0e3 <free_environment+0x42>
f010b0cc:	83 ec 04             	sub    $0x4,%esp
f010b0cf:	68 24 52 12 f0       	push   $0xf0125224
f010b0d4:	68 bf 02 00 00       	push   $0x2bf
f010b0d9:	68 47 52 12 f0       	push   $0xf0125247
f010b0de:	e8 56 52 ff ff       	call   f0100339 <_panic>
f010b0e3:	8b 15 d4 b7 5c f0    	mov    0xf05cb7d4,%edx
f010b0e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0ec:	89 50 08             	mov    %edx,0x8(%eax)
f010b0ef:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0f2:	8b 40 08             	mov    0x8(%eax),%eax
f010b0f5:	85 c0                	test   %eax,%eax
f010b0f7:	74 0d                	je     f010b106 <free_environment+0x65>
f010b0f9:	a1 d4 b7 5c f0       	mov    0xf05cb7d4,%eax
f010b0fe:	8b 55 08             	mov    0x8(%ebp),%edx
f010b101:	89 50 0c             	mov    %edx,0xc(%eax)
f010b104:	eb 08                	jmp    f010b10e <free_environment+0x6d>
f010b106:	8b 45 08             	mov    0x8(%ebp),%eax
f010b109:	a3 d8 b7 5c f0       	mov    %eax,0xf05cb7d8
f010b10e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b111:	a3 d4 b7 5c f0       	mov    %eax,0xf05cb7d4
f010b116:	8b 45 08             	mov    0x8(%ebp),%eax
f010b119:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b120:	a1 e0 b7 5c f0       	mov    0xf05cb7e0,%eax
f010b125:	40                   	inc    %eax
f010b126:	a3 e0 b7 5c f0       	mov    %eax,0xf05cb7e0
}
f010b12b:	90                   	nop
f010b12c:	c9                   	leave  
f010b12d:	c3                   	ret    

f010b12e <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010b12e:	55                   	push   %ebp
f010b12f:	89 e5                	mov    %esp,%ebp
f010b131:	53                   	push   %ebx
f010b132:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010b135:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b138:	8b 40 0c             	mov    0xc(%eax),%eax
f010b13b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010b13e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b141:	8b 40 08             	mov    0x8(%eax),%eax
f010b144:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010b147:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010b14e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010b151:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b154:	01 c2                	add    %eax,%edx
f010b156:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b159:	01 d0                	add    %edx,%eax
f010b15b:	48                   	dec    %eax
f010b15c:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b15f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b162:	ba 00 00 00 00       	mov    $0x0,%edx
f010b167:	f7 75 dc             	divl   -0x24(%ebp)
f010b16a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b16d:	29 d0                	sub    %edx,%eax
f010b16f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010b172:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b175:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010b178:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b17b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b180:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010b183:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010b18a:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010b191:	8b 45 10             	mov    0x10(%ebp),%eax
f010b194:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010b19a:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010b1a1:	0f 85 f5 03 00 00    	jne    f010b59c <program_segment_alloc_map_copy_workingset+0x46e>
f010b1a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1aa:	83 c0 20             	add    $0x20,%eax
f010b1ad:	83 ec 08             	sub    $0x8,%esp
f010b1b0:	68 fc 53 12 f0       	push   $0xf01253fc
f010b1b5:	50                   	push   %eax
f010b1b6:	e8 9e 3a 01 00       	call   f011ec59 <strcmp>
f010b1bb:	83 c4 10             	add    $0x10,%esp
f010b1be:	85 c0                	test   %eax,%eax
f010b1c0:	0f 84 d6 03 00 00    	je     f010b59c <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010b1c6:	8b 45 14             	mov    0x14(%ebp),%eax
f010b1c9:	83 f8 06             	cmp    $0x6,%eax
f010b1cc:	76 05                	jbe    f010b1d3 <program_segment_alloc_map_copy_workingset+0xa5>
f010b1ce:	b8 06 00 00 00       	mov    $0x6,%eax
f010b1d3:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b1d6:	e9 c1 03 00 00       	jmp    f010b59c <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010b1db:	83 ec 0c             	sub    $0xc,%esp
f010b1de:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010b1e1:	50                   	push   %eax
f010b1e2:	e8 60 cf ff ff       	call   f0108147 <allocate_frame>
f010b1e7:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010b1ea:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010b1ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1f0:	8b 40 64             	mov    0x64(%eax),%eax
f010b1f3:	6a 06                	push   $0x6
f010b1f5:	ff 75 f4             	pushl  -0xc(%ebp)
f010b1f8:	52                   	push   %edx
f010b1f9:	50                   	push   %eax
f010b1fa:	e8 19 d6 ff ff       	call   f0108818 <loadtime_map_frame>
f010b1ff:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010b202:	83 ec 08             	sub    $0x8,%esp
f010b205:	ff 75 f4             	pushl  -0xc(%ebp)
f010b208:	ff 75 08             	pushl  0x8(%ebp)
f010b20b:	e8 d6 e0 ff ff       	call   f01092e6 <env_page_ws_list_create_element>
f010b210:	83 c4 10             	add    $0x10,%esp
f010b213:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010b216:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b219:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b220:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b224:	75 17                	jne    f010b23d <program_segment_alloc_map_copy_workingset+0x10f>
f010b226:	83 ec 04             	sub    $0x4,%esp
f010b229:	68 ac 52 12 f0       	push   $0xf01252ac
f010b22e:	68 e9 02 00 00       	push   $0x2e9
f010b233:	68 47 52 12 f0       	push   $0xf0125247
f010b238:	e8 fc 50 ff ff       	call   f0100339 <_panic>
f010b23d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b240:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010b246:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b249:	89 50 14             	mov    %edx,0x14(%eax)
f010b24c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b24f:	8b 40 14             	mov    0x14(%eax),%eax
f010b252:	85 c0                	test   %eax,%eax
f010b254:	74 11                	je     f010b267 <program_segment_alloc_map_copy_workingset+0x139>
f010b256:	8b 45 08             	mov    0x8(%ebp),%eax
f010b259:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010b25f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b262:	89 50 10             	mov    %edx,0x10(%eax)
f010b265:	eb 0c                	jmp    f010b273 <program_segment_alloc_map_copy_workingset+0x145>
f010b267:	8b 45 08             	mov    0x8(%ebp),%eax
f010b26a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b26d:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b273:	8b 45 08             	mov    0x8(%ebp),%eax
f010b276:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b279:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b27f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b282:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b289:	8b 45 08             	mov    0x8(%ebp),%eax
f010b28c:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b292:	8d 50 01             	lea    0x1(%eax),%edx
f010b295:	8b 45 08             	mov    0x8(%ebp),%eax
f010b298:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b29e:	83 ec 0c             	sub    $0xc,%esp
f010b2a1:	6a 02                	push   $0x2
f010b2a3:	e8 83 34 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f010b2a8:	83 c4 10             	add    $0x10,%esp
f010b2ab:	85 c0                	test   %eax,%eax
f010b2ad:	0f 84 b3 01 00 00    	je     f010b466 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010b2b3:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b2b7:	75 17                	jne    f010b2d0 <program_segment_alloc_map_copy_workingset+0x1a2>
f010b2b9:	83 ec 04             	sub    $0x4,%esp
f010b2bc:	68 cf 52 12 f0       	push   $0xf01252cf
f010b2c1:	68 f5 02 00 00       	push   $0x2f5
f010b2c6:	68 47 52 12 f0       	push   $0xf0125247
f010b2cb:	e8 69 50 ff ff       	call   f0100339 <_panic>
f010b2d0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b2d3:	8b 40 10             	mov    0x10(%eax),%eax
f010b2d6:	85 c0                	test   %eax,%eax
f010b2d8:	74 11                	je     f010b2eb <program_segment_alloc_map_copy_workingset+0x1bd>
f010b2da:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b2dd:	8b 40 10             	mov    0x10(%eax),%eax
f010b2e0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b2e3:	8b 52 14             	mov    0x14(%edx),%edx
f010b2e6:	89 50 14             	mov    %edx,0x14(%eax)
f010b2e9:	eb 0f                	jmp    f010b2fa <program_segment_alloc_map_copy_workingset+0x1cc>
f010b2eb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b2ee:	8b 50 14             	mov    0x14(%eax),%edx
f010b2f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2f4:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b2fa:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b2fd:	8b 40 14             	mov    0x14(%eax),%eax
f010b300:	85 c0                	test   %eax,%eax
f010b302:	74 11                	je     f010b315 <program_segment_alloc_map_copy_workingset+0x1e7>
f010b304:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b307:	8b 40 14             	mov    0x14(%eax),%eax
f010b30a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b30d:	8b 52 10             	mov    0x10(%edx),%edx
f010b310:	89 50 10             	mov    %edx,0x10(%eax)
f010b313:	eb 0f                	jmp    f010b324 <program_segment_alloc_map_copy_workingset+0x1f6>
f010b315:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b318:	8b 50 10             	mov    0x10(%eax),%edx
f010b31b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b31e:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b324:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b327:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b32e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b331:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b338:	8b 45 08             	mov    0x8(%ebp),%eax
f010b33b:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b341:	8d 50 ff             	lea    -0x1(%eax),%edx
f010b344:	8b 45 08             	mov    0x8(%ebp),%eax
f010b347:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010b34d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b350:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b356:	8b 45 08             	mov    0x8(%ebp),%eax
f010b359:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010b35f:	48                   	dec    %eax
f010b360:	39 c2                	cmp    %eax,%edx
f010b362:	0f 83 80 00 00 00    	jae    f010b3e8 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b368:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b36c:	75 17                	jne    f010b385 <program_segment_alloc_map_copy_workingset+0x257>
f010b36e:	83 ec 04             	sub    $0x4,%esp
f010b371:	68 24 52 12 f0       	push   $0xf0125224
f010b376:	68 f9 02 00 00       	push   $0x2f9
f010b37b:	68 47 52 12 f0       	push   $0xf0125247
f010b380:	e8 b4 4f ff ff       	call   f0100339 <_panic>
f010b385:	8b 45 08             	mov    0x8(%ebp),%eax
f010b388:	8b 90 54 05 00 00    	mov    0x554(%eax),%edx
f010b38e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b391:	89 50 10             	mov    %edx,0x10(%eax)
f010b394:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b397:	8b 40 10             	mov    0x10(%eax),%eax
f010b39a:	85 c0                	test   %eax,%eax
f010b39c:	74 11                	je     f010b3af <program_segment_alloc_map_copy_workingset+0x281>
f010b39e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3a1:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010b3a7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b3aa:	89 50 14             	mov    %edx,0x14(%eax)
f010b3ad:	eb 0c                	jmp    f010b3bb <program_segment_alloc_map_copy_workingset+0x28d>
f010b3af:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3b2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b3b5:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f010b3bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3be:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b3c1:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f010b3c7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b3ca:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b3d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3d4:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b3da:	8d 50 01             	lea    0x1(%eax),%edx
f010b3dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3e0:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b3e6:	eb 7e                	jmp    f010b466 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b3e8:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b3ec:	75 17                	jne    f010b405 <program_segment_alloc_map_copy_workingset+0x2d7>
f010b3ee:	83 ec 04             	sub    $0x4,%esp
f010b3f1:	68 24 52 12 f0       	push   $0xf0125224
f010b3f6:	68 fe 02 00 00       	push   $0x2fe
f010b3fb:	68 47 52 12 f0       	push   $0xf0125247
f010b400:	e8 34 4f ff ff       	call   f0100339 <_panic>
f010b405:	8b 45 08             	mov    0x8(%ebp),%eax
f010b408:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010b40e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b411:	89 50 10             	mov    %edx,0x10(%eax)
f010b414:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b417:	8b 40 10             	mov    0x10(%eax),%eax
f010b41a:	85 c0                	test   %eax,%eax
f010b41c:	74 11                	je     f010b42f <program_segment_alloc_map_copy_workingset+0x301>
f010b41e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b421:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010b427:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b42a:	89 50 14             	mov    %edx,0x14(%eax)
f010b42d:	eb 0c                	jmp    f010b43b <program_segment_alloc_map_copy_workingset+0x30d>
f010b42f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b432:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b435:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010b43b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b43e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b441:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b447:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b44a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b451:	8b 45 08             	mov    0x8(%ebp),%eax
f010b454:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b45a:	8d 50 01             	lea    0x1(%eax),%edx
f010b45d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b460:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b466:	8b 45 08             	mov    0x8(%ebp),%eax
f010b469:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b46f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b472:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010b478:	39 c2                	cmp    %eax,%edx
f010b47a:	75 14                	jne    f010b490 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b47c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b47f:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f010b485:	8b 45 08             	mov    0x8(%ebp),%eax
f010b488:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b48e:	eb 0d                	jmp    f010b49d <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010b490:	8b 45 08             	mov    0x8(%ebp),%eax
f010b493:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010b49a:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010b49d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4a0:	c1 e8 16             	shr    $0x16,%eax
f010b4a3:	89 c2                	mov    %eax,%edx
f010b4a5:	8b 45 18             	mov    0x18(%ebp),%eax
f010b4a8:	8b 00                	mov    (%eax),%eax
f010b4aa:	39 c2                	cmp    %eax,%edx
f010b4ac:	0f 84 d3 00 00 00    	je     f010b585 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010b4b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4b5:	8b 90 50 05 00 00    	mov    0x550(%eax),%edx
f010b4bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4be:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010b4c1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b4c4:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010b4c9:	89 c1                	mov    %eax,%ecx
f010b4cb:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b4ce:	89 d0                	mov    %edx,%eax
f010b4d0:	01 c0                	add    %eax,%eax
f010b4d2:	01 d0                	add    %edx,%eax
f010b4d4:	c1 e0 03             	shl    $0x3,%eax
f010b4d7:	01 d8                	add    %ebx,%eax
f010b4d9:	05 a0 00 00 00       	add    $0xa0,%eax
f010b4de:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010b4e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4e3:	8b 90 50 05 00 00    	mov    0x550(%eax),%edx
f010b4e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b4ec:	89 d0                	mov    %edx,%eax
f010b4ee:	01 c0                	add    %eax,%eax
f010b4f0:	01 d0                	add    %edx,%eax
f010b4f2:	c1 e0 03             	shl    $0x3,%eax
f010b4f5:	01 c8                	add    %ecx,%eax
f010b4f7:	05 a4 00 00 00       	add    $0xa4,%eax
f010b4fc:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010b4ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010b502:	8b 90 50 05 00 00    	mov    0x550(%eax),%edx
f010b508:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b50b:	89 d0                	mov    %edx,%eax
f010b50d:	01 c0                	add    %eax,%eax
f010b50f:	01 d0                	add    %edx,%eax
f010b511:	c1 e0 03             	shl    $0x3,%eax
f010b514:	01 c8                	add    %ecx,%eax
f010b516:	05 a8 00 00 00       	add    $0xa8,%eax
f010b51b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010b521:	8b 45 08             	mov    0x8(%ebp),%eax
f010b524:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f010b52a:	8d 50 01             	lea    0x1(%eax),%edx
f010b52d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b530:	89 90 50 05 00 00    	mov    %edx,0x550(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010b536:	8b 45 08             	mov    0x8(%ebp),%eax
f010b539:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f010b53f:	b9 32 00 00 00       	mov    $0x32,%ecx
f010b544:	ba 00 00 00 00       	mov    $0x0,%edx
f010b549:	f7 f1                	div    %ecx
f010b54b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b54e:	89 90 50 05 00 00    	mov    %edx,0x550(%eax)
			if (e->table_last_WS_index == 0)
f010b554:	8b 45 08             	mov    0x8(%ebp),%eax
f010b557:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f010b55d:	85 c0                	test   %eax,%eax
f010b55f:	75 17                	jne    f010b578 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010b561:	83 ec 04             	sub    $0x4,%esp
f010b564:	68 00 54 12 f0       	push   $0xf0125400
f010b569:	68 26 03 00 00       	push   $0x326
f010b56e:	68 47 52 12 f0       	push   $0xf0125247
f010b573:	e8 c1 4d ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010b578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b57b:	c1 e8 16             	shr    $0x16,%eax
f010b57e:	89 c2                	mov    %eax,%edx
f010b580:	8b 45 18             	mov    0x18(%ebp),%eax
f010b583:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010b585:	8b 45 10             	mov    0x10(%ebp),%eax
f010b588:	8b 00                	mov    (%eax),%eax
f010b58a:	8d 50 01             	lea    0x1(%eax),%edx
f010b58d:	8b 45 10             	mov    0x10(%ebp),%eax
f010b590:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b592:	ff 45 f0             	incl   -0x10(%ebp)
f010b595:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010b59c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b59f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010b5a2:	73 0c                	jae    f010b5b0 <program_segment_alloc_map_copy_workingset+0x482>
f010b5a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b5a7:	3b 45 14             	cmp    0x14(%ebp),%eax
f010b5aa:	0f 82 2b fc ff ff    	jb     f010b1db <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010b5b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b5b3:	8b 00                	mov    (%eax),%eax
f010b5b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010b5b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b5bb:	8b 40 0c             	mov    0xc(%eax),%eax
f010b5be:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b5c1:	eb 10                	jmp    f010b5d3 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010b5c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b5c6:	8a 10                	mov    (%eax),%dl
f010b5c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b5cb:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010b5cd:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010b5d0:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b5d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b5d6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b5d9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b5dc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b5e1:	89 c2                	mov    %eax,%edx
f010b5e3:	8b 45 10             	mov    0x10(%ebp),%eax
f010b5e6:	8b 00                	mov    (%eax),%eax
f010b5e8:	c1 e0 0c             	shl    $0xc,%eax
f010b5eb:	01 c2                	add    %eax,%edx
f010b5ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b5f0:	39 c2                	cmp    %eax,%edx
f010b5f2:	76 1d                	jbe    f010b611 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010b5f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b5f7:	8b 50 04             	mov    0x4(%eax),%edx
f010b5fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b5fd:	01 c2                	add    %eax,%edx
f010b5ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b602:	39 c2                	cmp    %eax,%edx
f010b604:	77 bd                	ja     f010b5c3 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b606:	eb 09                	jmp    f010b611 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010b608:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b60b:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010b60e:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b611:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b614:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010b617:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b61a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b61f:	89 c2                	mov    %eax,%edx
f010b621:	8b 45 10             	mov    0x10(%ebp),%eax
f010b624:	8b 00                	mov    (%eax),%eax
f010b626:	c1 e0 0c             	shl    $0xc,%eax
f010b629:	01 c2                	add    %eax,%edx
f010b62b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b62e:	39 c2                	cmp    %eax,%edx
f010b630:	77 d6                	ja     f010b608 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010b632:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b637:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b63a:	c9                   	leave  
f010b63b:	c3                   	ret    

f010b63c <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010b63c:	55                   	push   %ebp
f010b63d:	89 e5                	mov    %esp,%ebp
f010b63f:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010b642:	83 ec 0c             	sub    $0xc,%esp
f010b645:	68 00 10 00 00       	push   $0x1000
f010b64a:	e8 41 d7 ff ff       	call   f0108d90 <kmalloc>
f010b64f:	83 c4 10             	add    $0x10,%esp
f010b652:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010b655:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b659:	75 17                	jne    f010b672 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010b65b:	83 ec 04             	sub    $0x4,%esp
f010b65e:	68 a3 54 12 f0       	push   $0xf01254a3
f010b663:	68 56 03 00 00       	push   $0x356
f010b668:	68 47 52 12 f0       	push   $0xf0125247
f010b66d:	e8 c7 4c ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010b672:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010b675:	c9                   	leave  
f010b676:	c3                   	ret    

f010b677 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010b677:	55                   	push   %ebp
f010b678:	89 e5                	mov    %esp,%ebp
f010b67a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - create_user_kern_stack
	// Write your code here, remove the panic and write your code
	panic("create_user_kern_stack() is not implemented yet...!!");
f010b67d:	83 ec 04             	sub    $0x4,%esp
f010b680:	68 c0 54 12 f0       	push   $0xf01254c0
f010b685:	68 66 03 00 00       	push   $0x366
f010b68a:	68 47 52 12 f0       	push   $0xf0125247
f010b68f:	e8 a5 4c ff ff       	call   f0100339 <_panic>

f010b694 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010b694:	55                   	push   %ebp
f010b695:	89 e5                	mov    %esp,%ebp
f010b697:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010b69a:	83 ec 04             	sub    $0x4,%esp
f010b69d:	68 f8 54 12 f0       	push   $0xf01254f8
f010b6a2:	68 81 03 00 00       	push   $0x381
f010b6a7:	68 47 52 12 f0       	push   $0xf0125247
f010b6ac:	e8 88 4c ff ff       	call   f0100339 <_panic>

f010b6b1 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010b6b1:	55                   	push   %ebp
f010b6b2:	89 e5                	mov    %esp,%ebp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
}
f010b6b4:	90                   	nop
f010b6b5:	5d                   	pop    %ebp
f010b6b6:	c3                   	ret    

f010b6b7 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010b6b7:	55                   	push   %ebp
f010b6b8:	89 e5                	mov    %esp,%ebp
f010b6ba:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010b6bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6c0:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b6c3:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010b6c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6c9:	8b 55 10             	mov    0x10(%ebp),%edx
f010b6cc:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b6cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b6d6:	eb 17                	jmp    f010b6ef <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010b6d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6db:	8b 40 64             	mov    0x64(%eax),%eax
f010b6de:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b6e1:	c1 e2 02             	shl    $0x2,%edx
f010b6e4:	01 d0                	add    %edx,%eax
f010b6e6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b6ec:	ff 45 f4             	incl   -0xc(%ebp)
f010b6ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6f2:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010b6f7:	76 df                	jbe    f010b6d8 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b6f9:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010b700:	eb 22                	jmp    f010b724 <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010b702:	8b 45 08             	mov    0x8(%ebp),%eax
f010b705:	8b 40 64             	mov    0x64(%eax),%eax
f010b708:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b70b:	c1 e2 02             	shl    $0x2,%edx
f010b70e:	01 c2                	add    %eax,%edx
f010b710:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f010b715:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010b718:	c1 e1 02             	shl    $0x2,%ecx
f010b71b:	01 c8                	add    %ecx,%eax
f010b71d:	8b 00                	mov    (%eax),%eax
f010b71f:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b721:	ff 45 f4             	incl   -0xc(%ebp)
f010b724:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010b72b:	7e d5                	jle    f010b702 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010b72d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b730:	8b 40 64             	mov    0x64(%eax),%eax
f010b733:	83 ec 0c             	sub    $0xc,%esp
f010b736:	50                   	push   %eax
f010b737:	e8 3b ff ff ff       	call   f010b677 <create_user_kern_stack>
f010b73c:	83 c4 10             	add    $0x10,%esp
f010b73f:	89 c2                	mov    %eax,%edx
f010b741:	8b 45 08             	mov    0x8(%ebp),%eax
f010b744:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010b747:	8b 45 08             	mov    0x8(%ebp),%eax
f010b74a:	8b 40 70             	mov    0x70(%eax),%eax
f010b74d:	05 00 80 00 00       	add    $0x8000,%eax
f010b752:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010b755:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010b759:	8b 45 08             	mov    0x8(%ebp),%eax
f010b75c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b75f:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010b761:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010b765:	ba 88 d7 10 f0       	mov    $0xf010d788,%edx
f010b76a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b76d:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010b76f:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010b773:	8b 45 08             	mov    0x8(%ebp),%eax
f010b776:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b779:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010b77c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b77f:	8b 40 04             	mov    0x4(%eax),%eax
f010b782:	83 ec 04             	sub    $0x4,%esp
f010b785:	6a 20                	push   $0x20
f010b787:	6a 00                	push   $0x0
f010b789:	50                   	push   %eax
f010b78a:	e8 ac 35 01 00       	call   f011ed3b <memset>
f010b78f:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010b792:	8b 45 08             	mov    0x8(%ebp),%eax
f010b795:	8b 40 04             	mov    0x4(%eax),%eax
f010b798:	ba 71 ab 10 f0       	mov    $0xf010ab71,%edx
f010b79d:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010b7a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7a3:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010b7aa:	00 00 00 
f010b7ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7b0:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010b7b7:	00 00 00 
f010b7ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7bd:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010b7c4:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b7c7:	83 ec 0c             	sub    $0xc,%esp
f010b7ca:	6a 02                	push   $0x2
f010b7cc:	e8 5a 2f 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f010b7d1:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b7d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b7db:	eb 54                	jmp    f010b831 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010b7dd:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b7e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b7e3:	89 d0                	mov    %edx,%eax
f010b7e5:	01 c0                	add    %eax,%eax
f010b7e7:	01 d0                	add    %edx,%eax
f010b7e9:	c1 e0 03             	shl    $0x3,%eax
f010b7ec:	01 c8                	add    %ecx,%eax
f010b7ee:	05 a0 00 00 00       	add    $0xa0,%eax
f010b7f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010b7f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b7fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b7ff:	89 d0                	mov    %edx,%eax
f010b801:	01 c0                	add    %eax,%eax
f010b803:	01 d0                	add    %edx,%eax
f010b805:	c1 e0 03             	shl    $0x3,%eax
f010b808:	01 c8                	add    %ecx,%eax
f010b80a:	05 a4 00 00 00       	add    $0xa4,%eax
f010b80f:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010b812:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b815:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b818:	89 d0                	mov    %edx,%eax
f010b81a:	01 c0                	add    %eax,%eax
f010b81c:	01 d0                	add    %edx,%eax
f010b81e:	c1 e0 03             	shl    $0x3,%eax
f010b821:	01 c8                	add    %ecx,%eax
f010b823:	05 a8 00 00 00       	add    $0xa8,%eax
f010b828:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b82e:	ff 45 f4             	incl   -0xc(%ebp)
f010b831:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010b835:	7e a6                	jle    f010b7dd <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010b837:	8b 45 08             	mov    0x8(%ebp),%eax
f010b83a:	c7 80 50 05 00 00 00 	movl   $0x0,0x550(%eax)
f010b841:	00 00 00 

	e->pageFaultsCounter=0;
f010b844:	8b 45 08             	mov    0x8(%ebp),%eax
f010b847:	c7 80 84 05 00 00 00 	movl   $0x0,0x584(%eax)
f010b84e:	00 00 00 
	e->tableFaultsCounter=0;
f010b851:	8b 45 08             	mov    0x8(%ebp),%eax
f010b854:	c7 80 88 05 00 00 00 	movl   $0x0,0x588(%eax)
f010b85b:	00 00 00 

	e->freeingFullWSCounter = 0;
f010b85e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b861:	c7 80 8c 05 00 00 00 	movl   $0x0,0x58c(%eax)
f010b868:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010b86b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b86e:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010b875:	00 00 00 

	e->nModifiedPages=0;
f010b878:	8b 45 08             	mov    0x8(%ebp),%eax
f010b87b:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010b882:	00 00 00 
	e->nNotModifiedPages=0;
f010b885:	8b 45 08             	mov    0x8(%ebp),%eax
f010b888:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010b88f:	00 00 00 
	e->nClocks = 0;
f010b892:	8b 45 08             	mov    0x8(%ebp),%eax
f010b895:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010b89c:	00 00 00 

	//2020
	e->nPageIn = 0;
f010b89f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8a2:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010b8a9:	00 00 00 
	e->nPageOut = 0;
f010b8ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8af:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010b8b6:	00 00 00 
	e->nNewPageAdded = 0;
f010b8b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8bc:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010b8c3:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010b8c6:	83 ec 04             	sub    $0x4,%esp
f010b8c9:	68 00 00 00 82       	push   $0x82000000
f010b8ce:	68 00 00 00 80       	push   $0x80000000
f010b8d3:	ff 75 08             	pushl  0x8(%ebp)
f010b8d6:	e8 d6 fd ff ff       	call   f010b6b1 <initialize_uheap_dynamic_allocator>
f010b8db:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010b8de:	83 ec 0c             	sub    $0xc,%esp
f010b8e1:	ff 75 08             	pushl  0x8(%ebp)
f010b8e4:	e8 06 00 00 00       	call   f010b8ef <complete_environment_initialization>
f010b8e9:	83 c4 10             	add    $0x10,%esp
}
f010b8ec:	90                   	nop
f010b8ed:	c9                   	leave  
f010b8ee:	c3                   	ret    

f010b8ef <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010b8ef:	55                   	push   %ebp
f010b8f0:	89 e5                	mov    %esp,%ebp
f010b8f2:	53                   	push   %ebx
f010b8f3:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010b8f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8f9:	8b 40 64             	mov    0x64(%eax),%eax
f010b8fc:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010b902:	8b 45 08             	mov    0x8(%ebp),%eax
f010b905:	8b 40 68             	mov    0x68(%eax),%eax
f010b908:	83 c8 03             	or     $0x3,%eax
f010b90b:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010b90d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b910:	8b 40 64             	mov    0x64(%eax),%eax
f010b913:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010b919:	8b 45 08             	mov    0x8(%ebp),%eax
f010b91c:	8b 40 68             	mov    0x68(%eax),%eax
f010b91f:	83 c8 05             	or     $0x5,%eax
f010b922:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010b924:	8b 45 08             	mov    0x8(%ebp),%eax
f010b927:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010b92e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b931:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010b938:	8b 45 08             	mov    0x8(%ebp),%eax
f010b93b:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010b942:	8b 45 08             	mov    0x8(%ebp),%eax
f010b945:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010b94c:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010b94f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b952:	8b 58 10             	mov    0x10(%eax),%ebx
f010b955:	83 ec 0c             	sub    $0xc,%esp
f010b958:	68 d0 02 00 00       	push   $0x2d0
f010b95d:	e8 7e 17 01 00       	call   f011d0e0 <log2_ceil>
f010b962:	83 c4 10             	add    $0x10,%esp
f010b965:	ba 01 00 00 00       	mov    $0x1,%edx
f010b96a:	88 c1                	mov    %al,%cl
f010b96c:	d3 e2                	shl    %cl,%edx
f010b96e:	89 d0                	mov    %edx,%eax
f010b970:	01 d8                	add    %ebx,%eax
f010b972:	89 c3                	mov    %eax,%ebx
f010b974:	83 ec 0c             	sub    $0xc,%esp
f010b977:	68 d0 02 00 00       	push   $0x2d0
f010b97c:	e8 2a 17 01 00       	call   f011d0ab <nearest_pow2_ceil>
f010b981:	83 c4 10             	add    $0x10,%esp
f010b984:	f7 d8                	neg    %eax
f010b986:	21 d8                	and    %ebx,%eax
f010b988:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010b98b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b98f:	7f 1e                	jg     f010b9af <complete_environment_initialization+0xc0>
		generation = 1 << ENVGENSHIFT;
f010b991:	83 ec 0c             	sub    $0xc,%esp
f010b994:	68 d0 02 00 00       	push   $0x2d0
f010b999:	e8 42 17 01 00       	call   f011d0e0 <log2_ceil>
f010b99e:	83 c4 10             	add    $0x10,%esp
f010b9a1:	ba 01 00 00 00       	mov    $0x1,%edx
f010b9a6:	88 c1                	mov    %al,%cl
f010b9a8:	d3 e2                	shl    %cl,%edx
f010b9aa:	89 d0                	mov    %edx,%eax
f010b9ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010b9af:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9b2:	8b 15 d0 b7 5c f0    	mov    0xf05cb7d0,%edx
f010b9b8:	29 d0                	sub    %edx,%eax
f010b9ba:	c1 f8 04             	sar    $0x4,%eax
f010b9bd:	89 c2                	mov    %eax,%edx
f010b9bf:	89 d0                	mov    %edx,%eax
f010b9c1:	c1 e0 09             	shl    $0x9,%eax
f010b9c4:	29 d0                	sub    %edx,%eax
f010b9c6:	c1 e0 03             	shl    $0x3,%eax
f010b9c9:	01 d0                	add    %edx,%eax
f010b9cb:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010b9d2:	01 c8                	add    %ecx,%eax
f010b9d4:	c1 e0 03             	shl    $0x3,%eax
f010b9d7:	01 d0                	add    %edx,%eax
f010b9d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b9e0:	01 d0                	add    %edx,%eax
f010b9e2:	89 c2                	mov    %eax,%edx
f010b9e4:	c1 e2 09             	shl    $0x9,%edx
f010b9e7:	01 d0                	add    %edx,%eax
f010b9e9:	f7 d8                	neg    %eax
f010b9eb:	0b 45 f4             	or     -0xc(%ebp),%eax
f010b9ee:	89 c2                	mov    %eax,%edx
f010b9f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9f3:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010b9f6:	e8 10 f2 ff ff       	call   f010ac0b <get_cpu_proc>
f010b9fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010b9fe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ba02:	75 0c                	jne    f010ba10 <complete_environment_initialization+0x121>
		e->env_parent_id = 0;//no parent;
f010ba04:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba07:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010ba0e:	eb 0c                	jmp    f010ba1c <complete_environment_initialization+0x12d>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010ba10:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ba13:	8b 50 10             	mov    0x10(%eax),%edx
f010ba16:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba19:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010ba1c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba1f:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010ba26:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba29:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010ba30:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010ba33:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba36:	8b 00                	mov    (%eax),%eax
f010ba38:	83 ec 04             	sub    $0x4,%esp
f010ba3b:	6a 44                	push   $0x44
f010ba3d:	6a 00                	push   $0x0
f010ba3f:	50                   	push   %eax
f010ba40:	e8 f6 32 01 00       	call   f011ed3b <memset>
f010ba45:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010ba48:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba4b:	8b 00                	mov    (%eax),%eax
f010ba4d:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010ba53:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba56:	8b 00                	mov    (%eax),%eax
f010ba58:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010ba5e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba61:	8b 00                	mov    (%eax),%eax
f010ba63:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010ba69:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba6c:	8b 00                	mov    (%eax),%eax
f010ba6e:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010ba75:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba78:	8b 00                	mov    (%eax),%eax
f010ba7a:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010ba80:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba83:	8b 00                	mov    (%eax),%eax
f010ba85:	8b 55 08             	mov    0x8(%ebp),%edx
f010ba88:	8b 12                	mov    (%edx),%edx
f010ba8a:	8b 52 38             	mov    0x38(%edx),%edx
f010ba8d:	80 ce 02             	or     $0x2,%dh
f010ba90:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010ba93:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ba97:	75 17                	jne    f010bab0 <complete_environment_initialization+0x1c1>
f010ba99:	83 ec 04             	sub    $0x4,%esp
f010ba9c:	68 cf 52 12 f0       	push   $0xf01252cf
f010baa1:	68 55 04 00 00       	push   $0x455
f010baa6:	68 47 52 12 f0       	push   $0xf0125247
f010baab:	e8 89 48 ff ff       	call   f0100339 <_panic>
f010bab0:	8b 45 08             	mov    0x8(%ebp),%eax
f010bab3:	8b 40 08             	mov    0x8(%eax),%eax
f010bab6:	85 c0                	test   %eax,%eax
f010bab8:	74 11                	je     f010bacb <complete_environment_initialization+0x1dc>
f010baba:	8b 45 08             	mov    0x8(%ebp),%eax
f010babd:	8b 40 08             	mov    0x8(%eax),%eax
f010bac0:	8b 55 08             	mov    0x8(%ebp),%edx
f010bac3:	8b 52 0c             	mov    0xc(%edx),%edx
f010bac6:	89 50 0c             	mov    %edx,0xc(%eax)
f010bac9:	eb 0b                	jmp    f010bad6 <complete_environment_initialization+0x1e7>
f010bacb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bace:	8b 40 0c             	mov    0xc(%eax),%eax
f010bad1:	a3 d8 b7 5c f0       	mov    %eax,0xf05cb7d8
f010bad6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bad9:	8b 40 0c             	mov    0xc(%eax),%eax
f010badc:	85 c0                	test   %eax,%eax
f010bade:	74 11                	je     f010baf1 <complete_environment_initialization+0x202>
f010bae0:	8b 45 08             	mov    0x8(%ebp),%eax
f010bae3:	8b 40 0c             	mov    0xc(%eax),%eax
f010bae6:	8b 55 08             	mov    0x8(%ebp),%edx
f010bae9:	8b 52 08             	mov    0x8(%edx),%edx
f010baec:	89 50 08             	mov    %edx,0x8(%eax)
f010baef:	eb 0b                	jmp    f010bafc <complete_environment_initialization+0x20d>
f010baf1:	8b 45 08             	mov    0x8(%ebp),%eax
f010baf4:	8b 40 08             	mov    0x8(%eax),%eax
f010baf7:	a3 d4 b7 5c f0       	mov    %eax,0xf05cb7d4
f010bafc:	8b 45 08             	mov    0x8(%ebp),%eax
f010baff:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010bb06:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb09:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010bb10:	a1 e0 b7 5c f0       	mov    0xf05cb7e0,%eax
f010bb15:	48                   	dec    %eax
f010bb16:	a3 e0 b7 5c f0       	mov    %eax,0xf05cb7e0
	return ;
f010bb1b:	90                   	nop
}
f010bb1c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bb1f:	c9                   	leave  
f010bb20:	c3                   	ret    

f010bb21 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010bb21:	55                   	push   %ebp
f010bb22:	89 e5                	mov    %esp,%ebp
f010bb24:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bb27:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bb2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb30:	8b 00                	mov    (%eax),%eax
f010bb32:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bb37:	74 17                	je     f010bb50 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010bb39:	83 ec 04             	sub    $0x4,%esp
f010bb3c:	68 2d 55 12 f0       	push   $0xf012552d
f010bb41:	68 61 04 00 00       	push   $0x461
f010bb46:	68 47 52 12 f0       	push   $0xf0125247
f010bb4b:	e8 e9 47 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010bb50:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb53:	8b 00                	mov    (%eax),%eax
f010bb55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb58:	8b 52 18             	mov    0x18(%edx),%edx
f010bb5b:	89 50 30             	mov    %edx,0x30(%eax)
}
f010bb5e:	90                   	nop
f010bb5f:	c9                   	leave  
f010bb60:	c3                   	ret    

f010bb61 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010bb61:	55                   	push   %ebp
f010bb62:	89 e5                	mov    %esp,%ebp
f010bb64:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010bb67:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb6a:	8b 40 10             	mov    0x10(%eax),%eax
f010bb6d:	8d 48 01             	lea    0x1(%eax),%ecx
f010bb70:	8b 55 08             	mov    0x8(%ebp),%edx
f010bb73:	89 4a 10             	mov    %ecx,0x10(%edx)
f010bb76:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bb79:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bb7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bb82:	8b 00                	mov    (%eax),%eax
f010bb84:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bb89:	74 17                	je     f010bba2 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010bb8b:	83 ec 04             	sub    $0x4,%esp
f010bb8e:	68 2d 55 12 f0       	push   $0xf012552d
f010bb93:	68 6f 04 00 00       	push   $0x46f
f010bb98:	68 47 52 12 f0       	push   $0xf0125247
f010bb9d:	e8 97 47 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010bba2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bba5:	8b 50 1c             	mov    0x1c(%eax),%edx
f010bba8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bbab:	01 d0                	add    %edx,%eax
f010bbad:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010bbb0:	eb 0f                	jmp    f010bbc1 <PROGRAM_SEGMENT_NEXT+0x60>
f010bbb2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbb5:	8b 40 10             	mov    0x10(%eax),%eax
f010bbb8:	8d 50 01             	lea    0x1(%eax),%edx
f010bbbb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbbe:	89 50 10             	mov    %edx,0x10(%eax)
f010bbc1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbc4:	8b 40 10             	mov    0x10(%eax),%eax
f010bbc7:	c1 e0 05             	shl    $0x5,%eax
f010bbca:	89 c2                	mov    %eax,%edx
f010bbcc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bbcf:	01 d0                	add    %edx,%eax
f010bbd1:	8b 00                	mov    (%eax),%eax
f010bbd3:	83 f8 01             	cmp    $0x1,%eax
f010bbd6:	74 13                	je     f010bbeb <PROGRAM_SEGMENT_NEXT+0x8a>
f010bbd8:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbdb:	8b 50 10             	mov    0x10(%eax),%edx
f010bbde:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bbe1:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bbe4:	0f b7 c0             	movzwl %ax,%eax
f010bbe7:	39 c2                	cmp    %eax,%edx
f010bbe9:	72 c7                	jb     f010bbb2 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010bbeb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbee:	8b 40 10             	mov    0x10(%eax),%eax
f010bbf1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010bbf4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bbf7:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bbfa:	0f b7 c0             	movzwl %ax,%eax
f010bbfd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010bc00:	7e 63                	jle    f010bc65 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010bc02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc05:	c1 e0 05             	shl    $0x5,%eax
f010bc08:	89 c2                	mov    %eax,%edx
f010bc0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc0d:	01 d0                	add    %edx,%eax
f010bc0f:	8b 50 04             	mov    0x4(%eax),%edx
f010bc12:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc15:	01 c2                	add    %eax,%edx
f010bc17:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc1a:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010bc1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc1f:	c1 e0 05             	shl    $0x5,%eax
f010bc22:	89 c2                	mov    %eax,%edx
f010bc24:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc27:	01 d0                	add    %edx,%eax
f010bc29:	8b 50 14             	mov    0x14(%eax),%edx
f010bc2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc2f:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010bc32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc35:	c1 e0 05             	shl    $0x5,%eax
f010bc38:	89 c2                	mov    %eax,%edx
f010bc3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc3d:	01 d0                	add    %edx,%eax
f010bc3f:	8b 50 10             	mov    0x10(%eax),%edx
f010bc42:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc45:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010bc48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc4b:	c1 e0 05             	shl    $0x5,%eax
f010bc4e:	89 c2                	mov    %eax,%edx
f010bc50:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc53:	01 d0                	add    %edx,%eax
f010bc55:	8b 40 08             	mov    0x8(%eax),%eax
f010bc58:	89 c2                	mov    %eax,%edx
f010bc5a:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc5d:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010bc60:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc63:	eb 05                	jmp    f010bc6a <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010bc65:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bc6a:	c9                   	leave  
f010bc6b:	c3                   	ret    

f010bc6c <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010bc6c:	55                   	push   %ebp
f010bc6d:	89 e5                	mov    %esp,%ebp
f010bc6f:	57                   	push   %edi
f010bc70:	56                   	push   %esi
f010bc71:	53                   	push   %ebx
f010bc72:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010bc75:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bc7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bc82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bc85:	8b 00                	mov    (%eax),%eax
f010bc87:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bc8c:	74 17                	je     f010bca5 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010bc8e:	83 ec 04             	sub    $0x4,%esp
f010bc91:	68 2d 55 12 f0       	push   $0xf012552d
f010bc96:	68 8b 04 00 00       	push   $0x48b
f010bc9b:	68 47 52 12 f0       	push   $0xf0125247
f010bca0:	e8 94 46 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010bca5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bca8:	8b 50 1c             	mov    0x1c(%eax),%edx
f010bcab:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bcae:	01 d0                	add    %edx,%eax
f010bcb0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010bcb3:	eb 07                	jmp    f010bcbc <PROGRAM_SEGMENT_FIRST+0x50>
f010bcb5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bcb8:	40                   	inc    %eax
f010bcb9:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bcbc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bcbf:	c1 e0 05             	shl    $0x5,%eax
f010bcc2:	89 c2                	mov    %eax,%edx
f010bcc4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bcc7:	01 d0                	add    %edx,%eax
f010bcc9:	8b 00                	mov    (%eax),%eax
f010bccb:	83 f8 01             	cmp    $0x1,%eax
f010bcce:	74 10                	je     f010bce0 <PROGRAM_SEGMENT_FIRST+0x74>
f010bcd0:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010bcd3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bcd6:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bcd9:	0f b7 c0             	movzwl %ax,%eax
f010bcdc:	39 c2                	cmp    %eax,%edx
f010bcde:	72 d5                	jb     f010bcb5 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010bce0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bce3:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010bce6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bce9:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bcec:	0f b7 c0             	movzwl %ax,%eax
f010bcef:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010bcf2:	7e 68                	jle    f010bd5c <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010bcf4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bcf7:	c1 e0 05             	shl    $0x5,%eax
f010bcfa:	89 c2                	mov    %eax,%edx
f010bcfc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bcff:	01 d0                	add    %edx,%eax
f010bd01:	8b 50 04             	mov    0x4(%eax),%edx
f010bd04:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd07:	01 d0                	add    %edx,%eax
f010bd09:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010bd0c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd0f:	c1 e0 05             	shl    $0x5,%eax
f010bd12:	89 c2                	mov    %eax,%edx
f010bd14:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd17:	01 d0                	add    %edx,%eax
f010bd19:	8b 40 14             	mov    0x14(%eax),%eax
f010bd1c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010bd1f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd22:	c1 e0 05             	shl    $0x5,%eax
f010bd25:	89 c2                	mov    %eax,%edx
f010bd27:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd2a:	01 d0                	add    %edx,%eax
f010bd2c:	8b 40 10             	mov    0x10(%eax),%eax
f010bd2f:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010bd32:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd35:	c1 e0 05             	shl    $0x5,%eax
f010bd38:	89 c2                	mov    %eax,%edx
f010bd3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd3d:	01 d0                	add    %edx,%eax
f010bd3f:	8b 40 08             	mov    0x8(%eax),%eax
f010bd42:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010bd45:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd48:	89 c3                	mov    %eax,%ebx
f010bd4a:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010bd4d:	ba 05 00 00 00       	mov    $0x5,%edx
f010bd52:	89 df                	mov    %ebx,%edi
f010bd54:	89 c6                	mov    %eax,%esi
f010bd56:	89 d1                	mov    %edx,%ecx
f010bd58:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010bd5a:	eb 1c                	jmp    f010bd78 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010bd5c:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010bd63:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd66:	89 c3                	mov    %eax,%ebx
f010bd68:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010bd6b:	ba 05 00 00 00       	mov    $0x5,%edx
f010bd70:	89 df                	mov    %ebx,%edi
f010bd72:	89 c6                	mov    %eax,%esi
f010bd74:	89 d1                	mov    %edx,%ecx
f010bd76:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010bd78:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd7b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010bd7e:	5b                   	pop    %ebx
f010bd7f:	5e                   	pop    %esi
f010bd80:	5f                   	pop    %edi
f010bd81:	5d                   	pop    %ebp
f010bd82:	c2 04 00             	ret    $0x4

f010bd85 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010bd85:	55                   	push   %ebp
f010bd86:	89 e5                	mov    %esp,%ebp
f010bd88:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010bd8b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010bd92:	83 ec 0c             	sub    $0xc,%esp
f010bd95:	68 80 43 5f f0       	push   $0xf05f4380
f010bd9a:	e8 ed 2d 00 00       	call   f010eb8c <acquire_spinlock>
f010bd9f:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010bda2:	a1 70 43 5f f0       	mov    0xf05f4370,%eax
f010bda7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010bdaa:	e9 c3 00 00 00       	jmp    f010be72 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010bdaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdb2:	8b 40 0c             	mov    0xc(%eax),%eax
f010bdb5:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bdb8:	0f 85 ac 00 00 00    	jne    f010be6a <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010bdbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdc1:	8b 50 10             	mov    0x10(%eax),%edx
f010bdc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdc7:	8b 40 0c             	mov    0xc(%eax),%eax
f010bdca:	8b 40 64             	mov    0x64(%eax),%eax
f010bdcd:	83 ec 08             	sub    $0x8,%esp
f010bdd0:	52                   	push   %edx
f010bdd1:	50                   	push   %eax
f010bdd2:	e8 e6 d3 ff ff       	call   f01091bd <pt_clear_page_table_entry>
f010bdd7:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010bdda:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bdde:	75 17                	jne    f010bdf7 <cleanup_buffers+0x72>
f010bde0:	83 ec 04             	sub    $0x4,%esp
f010bde3:	68 cf 52 12 f0       	push   $0xf01252cf
f010bde8:	68 b4 04 00 00       	push   $0x4b4
f010bded:	68 47 52 12 f0       	push   $0xf0125247
f010bdf2:	e8 42 45 ff ff       	call   f0100339 <_panic>
f010bdf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdfa:	8b 00                	mov    (%eax),%eax
f010bdfc:	85 c0                	test   %eax,%eax
f010bdfe:	74 10                	je     f010be10 <cleanup_buffers+0x8b>
f010be00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be03:	8b 00                	mov    (%eax),%eax
f010be05:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be08:	8b 52 04             	mov    0x4(%edx),%edx
f010be0b:	89 50 04             	mov    %edx,0x4(%eax)
f010be0e:	eb 0b                	jmp    f010be1b <cleanup_buffers+0x96>
f010be10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be13:	8b 40 04             	mov    0x4(%eax),%eax
f010be16:	a3 74 43 5f f0       	mov    %eax,0xf05f4374
f010be1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be1e:	8b 40 04             	mov    0x4(%eax),%eax
f010be21:	85 c0                	test   %eax,%eax
f010be23:	74 0f                	je     f010be34 <cleanup_buffers+0xaf>
f010be25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be28:	8b 40 04             	mov    0x4(%eax),%eax
f010be2b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be2e:	8b 12                	mov    (%edx),%edx
f010be30:	89 10                	mov    %edx,(%eax)
f010be32:	eb 0a                	jmp    f010be3e <cleanup_buffers+0xb9>
f010be34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be37:	8b 00                	mov    (%eax),%eax
f010be39:	a3 70 43 5f f0       	mov    %eax,0xf05f4370
f010be3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be41:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010be47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be4a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010be51:	a1 7c 43 5f f0       	mov    0xf05f437c,%eax
f010be56:	48                   	dec    %eax
f010be57:	a3 7c 43 5f f0       	mov    %eax,0xf05f437c

				free_frame(ptr_fi);
f010be5c:	83 ec 0c             	sub    $0xc,%esp
f010be5f:	ff 75 f4             	pushl  -0xc(%ebp)
f010be62:	e8 34 c4 ff ff       	call   f010829b <free_frame>
f010be67:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010be6a:	a1 78 43 5f f0       	mov    0xf05f4378,%eax
f010be6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010be72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be76:	74 07                	je     f010be7f <cleanup_buffers+0xfa>
f010be78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be7b:	8b 00                	mov    (%eax),%eax
f010be7d:	eb 05                	jmp    f010be84 <cleanup_buffers+0xff>
f010be7f:	b8 00 00 00 00       	mov    $0x0,%eax
f010be84:	a3 78 43 5f f0       	mov    %eax,0xf05f4378
f010be89:	a1 78 43 5f f0       	mov    0xf05f4378,%eax
f010be8e:	85 c0                	test   %eax,%eax
f010be90:	0f 85 19 ff ff ff    	jne    f010bdaf <cleanup_buffers+0x2a>
f010be96:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be9a:	0f 85 0f ff ff ff    	jne    f010bdaf <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010bea0:	83 ec 0c             	sub    $0xc,%esp
f010bea3:	68 80 43 5f f0       	push   $0xf05f4380
f010bea8:	e8 66 2d 00 00       	call   f010ec13 <release_spinlock>
f010bead:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010beb0:	90                   	nop
f010beb1:	c9                   	leave  
f010beb2:	c3                   	ret    

f010beb3 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010beb3:	55                   	push   %ebp
f010beb4:	89 e5                	mov    %esp,%ebp
f010beb6:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010beb9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010bebd:	7e 06                	jle    f010bec5 <set_program_priority+0x12>
f010bebf:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bec3:	7e 14                	jle    f010bed9 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010bec5:	83 ec 04             	sub    $0x4,%esp
f010bec8:	68 44 55 12 f0       	push   $0xf0125544
f010becd:	6a 10                	push   $0x10
f010becf:	68 68 55 12 f0       	push   $0xf0125568
f010bed4:	e8 60 44 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010bed9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bedd:	74 78                	je     f010bf57 <set_program_priority+0xa4>
		return;
	switch(priority)
f010bedf:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bee3:	77 56                	ja     f010bf3b <set_program_priority+0x88>
f010bee5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bee8:	c1 e0 02             	shl    $0x2,%eax
f010beeb:	05 a4 55 12 f0       	add    $0xf01255a4,%eax
f010bef0:	8b 00                	mov    (%eax),%eax
f010bef2:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010bef4:	83 ec 08             	sub    $0x8,%esp
f010bef7:	6a 01                	push   $0x1
f010bef9:	ff 75 08             	pushl  0x8(%ebp)
f010befc:	e8 c2 df ff ff       	call   f0109ec3 <half_WS_Size>
f010bf01:	83 c4 10             	add    $0x10,%esp
			break;
f010bf04:	eb 35                	jmp    f010bf3b <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010bf06:	83 ec 08             	sub    $0x8,%esp
f010bf09:	6a 00                	push   $0x0
f010bf0b:	ff 75 08             	pushl  0x8(%ebp)
f010bf0e:	e8 b0 df ff ff       	call   f0109ec3 <half_WS_Size>
f010bf13:	83 c4 10             	add    $0x10,%esp
			break;
f010bf16:	eb 23                	jmp    f010bf3b <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010bf18:	83 ec 08             	sub    $0x8,%esp
f010bf1b:	6a 01                	push   $0x1
f010bf1d:	ff 75 08             	pushl  0x8(%ebp)
f010bf20:	e8 81 df ff ff       	call   f0109ea6 <double_WS_Size>
f010bf25:	83 c4 10             	add    $0x10,%esp
			break;
f010bf28:	eb 11                	jmp    f010bf3b <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010bf2a:	83 ec 08             	sub    $0x8,%esp
f010bf2d:	6a 00                	push   $0x0
f010bf2f:	ff 75 08             	pushl  0x8(%ebp)
f010bf32:	e8 6f df ff ff       	call   f0109ea6 <double_WS_Size>
f010bf37:	83 c4 10             	add    $0x10,%esp
			break;
f010bf3a:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010bf3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf3e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010bf44:	83 ec 08             	sub    $0x8,%esp
f010bf47:	50                   	push   %eax
f010bf48:	68 85 55 12 f0       	push   $0xf0125585
f010bf4d:	e8 39 50 ff ff       	call   f0100f8b <cprintf>
f010bf52:	83 c4 10             	add    $0x10,%esp
f010bf55:	eb 01                	jmp    f010bf58 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010bf57:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010bf58:	c9                   	leave  
f010bf59:	c3                   	ret    

f010bf5a <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010bf5a:	55                   	push   %ebp
f010bf5b:	89 e5                	mov    %esp,%ebp
f010bf5d:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bf60:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bf67:	eb 29                	jmp    f010bf92 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010bf69:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf6c:	89 d0                	mov    %edx,%eax
f010bf6e:	01 c0                	add    %eax,%eax
f010bf70:	01 d0                	add    %edx,%eax
f010bf72:	c1 e0 02             	shl    $0x2,%eax
f010bf75:	05 80 c9 17 f0       	add    $0xf017c980,%eax
f010bf7a:	8b 00                	mov    (%eax),%eax
f010bf7c:	83 ec 08             	sub    $0x8,%esp
f010bf7f:	50                   	push   %eax
f010bf80:	ff 75 08             	pushl  0x8(%ebp)
f010bf83:	e8 d1 2c 01 00       	call   f011ec59 <strcmp>
f010bf88:	83 c4 10             	add    $0x10,%esp
f010bf8b:	85 c0                	test   %eax,%eax
f010bf8d:	74 0f                	je     f010bf9e <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bf8f:	ff 45 f4             	incl   -0xc(%ebp)
f010bf92:	a1 e4 cc 17 f0       	mov    0xf017cce4,%eax
f010bf97:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bf9a:	7c cd                	jl     f010bf69 <get_user_program_info+0xf>
f010bf9c:	eb 01                	jmp    f010bf9f <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010bf9e:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bf9f:	a1 e4 cc 17 f0       	mov    0xf017cce4,%eax
f010bfa4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bfa7:	75 1a                	jne    f010bfc3 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010bfa9:	83 ec 08             	sub    $0x8,%esp
f010bfac:	ff 75 08             	pushl  0x8(%ebp)
f010bfaf:	68 09 63 12 f0       	push   $0xf0126309
f010bfb4:	e8 d2 4f ff ff       	call   f0100f8b <cprintf>
f010bfb9:	83 c4 10             	add    $0x10,%esp
		return 0;
f010bfbc:	b8 00 00 00 00       	mov    $0x0,%eax
f010bfc1:	eb 11                	jmp    f010bfd4 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010bfc3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bfc6:	89 d0                	mov    %edx,%eax
f010bfc8:	01 c0                	add    %eax,%eax
f010bfca:	01 d0                	add    %edx,%eax
f010bfcc:	c1 e0 02             	shl    $0x2,%eax
f010bfcf:	05 80 c9 17 f0       	add    $0xf017c980,%eax
}
f010bfd4:	c9                   	leave  
f010bfd5:	c3                   	ret    

f010bfd6 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010bfd6:	55                   	push   %ebp
f010bfd7:	89 e5                	mov    %esp,%ebp
f010bfd9:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bfdc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bfe3:	eb 2d                	jmp    f010c012 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010bfe5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bfe8:	89 d0                	mov    %edx,%eax
f010bfea:	01 c0                	add    %eax,%eax
f010bfec:	01 d0                	add    %edx,%eax
f010bfee:	c1 e0 02             	shl    $0x2,%eax
f010bff1:	05 80 c9 17 f0       	add    $0xf017c980,%eax
f010bff6:	8b 00                	mov    (%eax),%eax
f010bff8:	8b 55 08             	mov    0x8(%ebp),%edx
f010bffb:	83 c2 20             	add    $0x20,%edx
f010bffe:	83 ec 08             	sub    $0x8,%esp
f010c001:	50                   	push   %eax
f010c002:	52                   	push   %edx
f010c003:	e8 51 2c 01 00       	call   f011ec59 <strcmp>
f010c008:	83 c4 10             	add    $0x10,%esp
f010c00b:	85 c0                	test   %eax,%eax
f010c00d:	74 0f                	je     f010c01e <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c00f:	ff 45 f4             	incl   -0xc(%ebp)
f010c012:	a1 e4 cc 17 f0       	mov    0xf017cce4,%eax
f010c017:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c01a:	7c c9                	jl     f010bfe5 <get_user_program_info_by_env+0xf>
f010c01c:	eb 01                	jmp    f010c01f <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010c01e:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010c01f:	a1 e4 cc 17 f0       	mov    0xf017cce4,%eax
f010c024:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c027:	75 17                	jne    f010c040 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010c029:	83 ec 0c             	sub    $0xc,%esp
f010c02c:	68 24 63 12 f0       	push   $0xf0126324
f010c031:	e8 55 4f ff ff       	call   f0100f8b <cprintf>
f010c036:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c039:	b8 00 00 00 00       	mov    $0x0,%eax
f010c03e:	eb 11                	jmp    f010c051 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010c040:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c043:	89 d0                	mov    %edx,%eax
f010c045:	01 c0                	add    %eax,%eax
f010c047:	01 d0                	add    %edx,%eax
f010c049:	c1 e0 02             	shl    $0x2,%eax
f010c04c:	05 80 c9 17 f0       	add    $0xf017c980,%eax
}
f010c051:	c9                   	leave  
f010c052:	c3                   	ret    

f010c053 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010c053:	55                   	push   %ebp
f010c054:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010c056:	8b 45 08             	mov    0x8(%ebp),%eax
f010c059:	83 f8 13             	cmp    $0x13,%eax
f010c05c:	77 0c                	ja     f010c06a <trapname+0x17>
		return excnames[trapno];
f010c05e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c061:	8b 04 85 00 67 12 f0 	mov    -0xfed9900(,%eax,4),%eax
f010c068:	eb 2c                	jmp    f010c096 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010c06a:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010c06e:	75 07                	jne    f010c077 <trapname+0x24>
		return "System call";
f010c070:	b8 40 63 12 f0       	mov    $0xf0126340,%eax
f010c075:	eb 1f                	jmp    f010c096 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010c077:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010c07b:	75 07                	jne    f010c084 <trapname+0x31>
		return "Clock Interrupt";
f010c07d:	b8 4c 63 12 f0       	mov    $0xf012634c,%eax
f010c082:	eb 12                	jmp    f010c096 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010c084:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010c088:	75 07                	jne    f010c091 <trapname+0x3e>
		return "Keyboard Interrupt";
f010c08a:	b8 5c 63 12 f0       	mov    $0xf012635c,%eax
f010c08f:	eb 05                	jmp    f010c096 <trapname+0x43>
	return "(unknown trap)";
f010c091:	b8 6f 63 12 f0       	mov    $0xf012636f,%eax
}
f010c096:	5d                   	pop    %ebp
f010c097:	c3                   	ret    

f010c098 <ts_init>:


void ts_init(void)
{
f010c098:	55                   	push   %ebp
f010c099:	89 e5                	mov    %esp,%ebp
f010c09b:	53                   	push   %ebx
f010c09c:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010c09f:	e8 c0 b0 ff ff       	call   f0107164 <pushcli>

	struct cpu* c = mycpu();
f010c0a4:	e8 f8 af ff ff       	call   f01070a1 <mycpu>
f010c0a9:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010c0ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0af:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c0b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0b9:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c0bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0c2:	83 c0 0c             	add    $0xc,%eax
f010c0c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0c8:	83 c2 0c             	add    $0xc,%edx
f010c0cb:	c1 ea 10             	shr    $0x10,%edx
f010c0ce:	88 d3                	mov    %dl,%bl
f010c0d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0d3:	83 c2 0c             	add    $0xc,%edx
f010c0d6:	c1 ea 18             	shr    $0x18,%edx
f010c0d9:	88 d1                	mov    %dl,%cl
f010c0db:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0de:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c0e5:	68 00 
f010c0e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0ea:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c0f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0f4:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c0fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0fd:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c103:	83 e2 f0             	and    $0xfffffff0,%edx
f010c106:	83 ca 09             	or     $0x9,%edx
f010c109:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c10f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c112:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c118:	83 ca 10             	or     $0x10,%edx
f010c11b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c121:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c124:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c12a:	83 e2 9f             	and    $0xffffff9f,%edx
f010c12d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c133:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c136:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c13c:	83 ca 80             	or     $0xffffff80,%edx
f010c13f:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c145:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c148:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c14e:	83 e2 f0             	and    $0xfffffff0,%edx
f010c151:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c157:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c15a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c160:	83 e2 ef             	and    $0xffffffef,%edx
f010c163:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c169:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c16c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c172:	83 e2 df             	and    $0xffffffdf,%edx
f010c175:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c17b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c17e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c184:	83 ca 40             	or     $0x40,%edx
f010c187:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c18d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c190:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c196:	83 e2 7f             	and    $0x7f,%edx
f010c199:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c19f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c1a2:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010c1a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c1ab:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c1b1:	83 e2 ef             	and    $0xffffffef,%edx
f010c1b4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010c1ba:	e8 f7 af ff ff       	call   f01071b6 <popcli>
f010c1bf:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010c1c5:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010c1c9:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010c1cc:	90                   	nop
f010c1cd:	83 c4 14             	add    $0x14,%esp
f010c1d0:	5b                   	pop    %ebx
f010c1d1:	5d                   	pop    %ebp
f010c1d2:	c3                   	ret    

f010c1d3 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010c1d3:	55                   	push   %ebp
f010c1d4:	89 e5                	mov    %esp,%ebp
f010c1d6:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010c1d9:	b8 82 d6 10 f0       	mov    $0xf010d682,%eax
f010c1de:	66 a3 40 b8 5c f0    	mov    %ax,0xf05cb840
f010c1e4:	66 c7 05 42 b8 5c f0 	movw   $0x8,0xf05cb842
f010c1eb:	08 00 
f010c1ed:	a0 44 b8 5c f0       	mov    0xf05cb844,%al
f010c1f2:	83 e0 e0             	and    $0xffffffe0,%eax
f010c1f5:	a2 44 b8 5c f0       	mov    %al,0xf05cb844
f010c1fa:	a0 44 b8 5c f0       	mov    0xf05cb844,%al
f010c1ff:	83 e0 1f             	and    $0x1f,%eax
f010c202:	a2 44 b8 5c f0       	mov    %al,0xf05cb844
f010c207:	a0 45 b8 5c f0       	mov    0xf05cb845,%al
f010c20c:	83 e0 f0             	and    $0xfffffff0,%eax
f010c20f:	83 c8 0e             	or     $0xe,%eax
f010c212:	a2 45 b8 5c f0       	mov    %al,0xf05cb845
f010c217:	a0 45 b8 5c f0       	mov    0xf05cb845,%al
f010c21c:	83 e0 ef             	and    $0xffffffef,%eax
f010c21f:	a2 45 b8 5c f0       	mov    %al,0xf05cb845
f010c224:	a0 45 b8 5c f0       	mov    0xf05cb845,%al
f010c229:	83 e0 9f             	and    $0xffffff9f,%eax
f010c22c:	a2 45 b8 5c f0       	mov    %al,0xf05cb845
f010c231:	a0 45 b8 5c f0       	mov    0xf05cb845,%al
f010c236:	83 c8 80             	or     $0xffffff80,%eax
f010c239:	a2 45 b8 5c f0       	mov    %al,0xf05cb845
f010c23e:	b8 82 d6 10 f0       	mov    $0xf010d682,%eax
f010c243:	c1 e8 10             	shr    $0x10,%eax
f010c246:	66 a3 46 b8 5c f0    	mov    %ax,0xf05cb846
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010c24c:	b8 8a d6 10 f0       	mov    $0xf010d68a,%eax
f010c251:	66 a3 70 b8 5c f0    	mov    %ax,0xf05cb870
f010c257:	66 c7 05 72 b8 5c f0 	movw   $0x8,0xf05cb872
f010c25e:	08 00 
f010c260:	a0 74 b8 5c f0       	mov    0xf05cb874,%al
f010c265:	83 e0 e0             	and    $0xffffffe0,%eax
f010c268:	a2 74 b8 5c f0       	mov    %al,0xf05cb874
f010c26d:	a0 74 b8 5c f0       	mov    0xf05cb874,%al
f010c272:	83 e0 1f             	and    $0x1f,%eax
f010c275:	a2 74 b8 5c f0       	mov    %al,0xf05cb874
f010c27a:	a0 75 b8 5c f0       	mov    0xf05cb875,%al
f010c27f:	83 e0 f0             	and    $0xfffffff0,%eax
f010c282:	83 c8 0e             	or     $0xe,%eax
f010c285:	a2 75 b8 5c f0       	mov    %al,0xf05cb875
f010c28a:	a0 75 b8 5c f0       	mov    0xf05cb875,%al
f010c28f:	83 e0 ef             	and    $0xffffffef,%eax
f010c292:	a2 75 b8 5c f0       	mov    %al,0xf05cb875
f010c297:	a0 75 b8 5c f0       	mov    0xf05cb875,%al
f010c29c:	83 e0 9f             	and    $0xffffff9f,%eax
f010c29f:	a2 75 b8 5c f0       	mov    %al,0xf05cb875
f010c2a4:	a0 75 b8 5c f0       	mov    0xf05cb875,%al
f010c2a9:	83 c8 80             	or     $0xffffff80,%eax
f010c2ac:	a2 75 b8 5c f0       	mov    %al,0xf05cb875
f010c2b1:	b8 8a d6 10 f0       	mov    $0xf010d68a,%eax
f010c2b6:	c1 e8 10             	shr    $0x10,%eax
f010c2b9:	66 a3 76 b8 5c f0    	mov    %ax,0xf05cb876
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010c2bf:	b8 92 d6 10 f0       	mov    $0xf010d692,%eax
f010c2c4:	66 a3 00 b9 5c f0    	mov    %ax,0xf05cb900
f010c2ca:	66 c7 05 02 b9 5c f0 	movw   $0x8,0xf05cb902
f010c2d1:	08 00 
f010c2d3:	a0 04 b9 5c f0       	mov    0xf05cb904,%al
f010c2d8:	83 e0 e0             	and    $0xffffffe0,%eax
f010c2db:	a2 04 b9 5c f0       	mov    %al,0xf05cb904
f010c2e0:	a0 04 b9 5c f0       	mov    0xf05cb904,%al
f010c2e5:	83 e0 1f             	and    $0x1f,%eax
f010c2e8:	a2 04 b9 5c f0       	mov    %al,0xf05cb904
f010c2ed:	a0 05 b9 5c f0       	mov    0xf05cb905,%al
f010c2f2:	83 e0 f0             	and    $0xfffffff0,%eax
f010c2f5:	83 c8 0e             	or     $0xe,%eax
f010c2f8:	a2 05 b9 5c f0       	mov    %al,0xf05cb905
f010c2fd:	a0 05 b9 5c f0       	mov    0xf05cb905,%al
f010c302:	83 e0 ef             	and    $0xffffffef,%eax
f010c305:	a2 05 b9 5c f0       	mov    %al,0xf05cb905
f010c30a:	a0 05 b9 5c f0       	mov    0xf05cb905,%al
f010c30f:	83 c8 60             	or     $0x60,%eax
f010c312:	a2 05 b9 5c f0       	mov    %al,0xf05cb905
f010c317:	a0 05 b9 5c f0       	mov    0xf05cb905,%al
f010c31c:	83 c8 80             	or     $0xffffff80,%eax
f010c31f:	a2 05 b9 5c f0       	mov    %al,0xf05cb905
f010c324:	b8 92 d6 10 f0       	mov    $0xf010d692,%eax
f010c329:	c1 e8 10             	shr    $0x10,%eax
f010c32c:	66 a3 06 b9 5c f0    	mov    %ax,0xf05cb906
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010c332:	b8 9c d6 10 f0       	mov    $0xf010d69c,%eax
f010c337:	66 a3 08 b9 5c f0    	mov    %ax,0xf05cb908
f010c33d:	66 c7 05 0a b9 5c f0 	movw   $0x8,0xf05cb90a
f010c344:	08 00 
f010c346:	a0 0c b9 5c f0       	mov    0xf05cb90c,%al
f010c34b:	83 e0 e0             	and    $0xffffffe0,%eax
f010c34e:	a2 0c b9 5c f0       	mov    %al,0xf05cb90c
f010c353:	a0 0c b9 5c f0       	mov    0xf05cb90c,%al
f010c358:	83 e0 1f             	and    $0x1f,%eax
f010c35b:	a2 0c b9 5c f0       	mov    %al,0xf05cb90c
f010c360:	a0 0d b9 5c f0       	mov    0xf05cb90d,%al
f010c365:	83 e0 f0             	and    $0xfffffff0,%eax
f010c368:	83 c8 0e             	or     $0xe,%eax
f010c36b:	a2 0d b9 5c f0       	mov    %al,0xf05cb90d
f010c370:	a0 0d b9 5c f0       	mov    0xf05cb90d,%al
f010c375:	83 e0 ef             	and    $0xffffffef,%eax
f010c378:	a2 0d b9 5c f0       	mov    %al,0xf05cb90d
f010c37d:	a0 0d b9 5c f0       	mov    0xf05cb90d,%al
f010c382:	83 c8 60             	or     $0x60,%eax
f010c385:	a2 0d b9 5c f0       	mov    %al,0xf05cb90d
f010c38a:	a0 0d b9 5c f0       	mov    0xf05cb90d,%al
f010c38f:	83 c8 80             	or     $0xffffff80,%eax
f010c392:	a2 0d b9 5c f0       	mov    %al,0xf05cb90d
f010c397:	b8 9c d6 10 f0       	mov    $0xf010d69c,%eax
f010c39c:	c1 e8 10             	shr    $0x10,%eax
f010c39f:	66 a3 0e b9 5c f0    	mov    %ax,0xf05cb90e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010c3a5:	b8 a6 d6 10 f0       	mov    $0xf010d6a6,%eax
f010c3aa:	66 a3 80 b9 5c f0    	mov    %ax,0xf05cb980
f010c3b0:	66 c7 05 82 b9 5c f0 	movw   $0x8,0xf05cb982
f010c3b7:	08 00 
f010c3b9:	a0 84 b9 5c f0       	mov    0xf05cb984,%al
f010c3be:	83 e0 e0             	and    $0xffffffe0,%eax
f010c3c1:	a2 84 b9 5c f0       	mov    %al,0xf05cb984
f010c3c6:	a0 84 b9 5c f0       	mov    0xf05cb984,%al
f010c3cb:	83 e0 1f             	and    $0x1f,%eax
f010c3ce:	a2 84 b9 5c f0       	mov    %al,0xf05cb984
f010c3d3:	a0 85 b9 5c f0       	mov    0xf05cb985,%al
f010c3d8:	83 e0 f0             	and    $0xfffffff0,%eax
f010c3db:	83 c8 0e             	or     $0xe,%eax
f010c3de:	a2 85 b9 5c f0       	mov    %al,0xf05cb985
f010c3e3:	a0 85 b9 5c f0       	mov    0xf05cb985,%al
f010c3e8:	83 e0 ef             	and    $0xffffffef,%eax
f010c3eb:	a2 85 b9 5c f0       	mov    %al,0xf05cb985
f010c3f0:	a0 85 b9 5c f0       	mov    0xf05cb985,%al
f010c3f5:	83 c8 60             	or     $0x60,%eax
f010c3f8:	a2 85 b9 5c f0       	mov    %al,0xf05cb985
f010c3fd:	a0 85 b9 5c f0       	mov    0xf05cb985,%al
f010c402:	83 c8 80             	or     $0xffffff80,%eax
f010c405:	a2 85 b9 5c f0       	mov    %al,0xf05cb985
f010c40a:	b8 a6 d6 10 f0       	mov    $0xf010d6a6,%eax
f010c40f:	c1 e8 10             	shr    $0x10,%eax
f010c412:	66 a3 86 b9 5c f0    	mov    %ax,0xf05cb986

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010c418:	b8 b0 d6 10 f0       	mov    $0xf010d6b0,%eax
f010c41d:	66 a3 00 b8 5c f0    	mov    %ax,0xf05cb800
f010c423:	66 c7 05 02 b8 5c f0 	movw   $0x8,0xf05cb802
f010c42a:	08 00 
f010c42c:	a0 04 b8 5c f0       	mov    0xf05cb804,%al
f010c431:	83 e0 e0             	and    $0xffffffe0,%eax
f010c434:	a2 04 b8 5c f0       	mov    %al,0xf05cb804
f010c439:	a0 04 b8 5c f0       	mov    0xf05cb804,%al
f010c43e:	83 e0 1f             	and    $0x1f,%eax
f010c441:	a2 04 b8 5c f0       	mov    %al,0xf05cb804
f010c446:	a0 05 b8 5c f0       	mov    0xf05cb805,%al
f010c44b:	83 e0 f0             	and    $0xfffffff0,%eax
f010c44e:	83 c8 0e             	or     $0xe,%eax
f010c451:	a2 05 b8 5c f0       	mov    %al,0xf05cb805
f010c456:	a0 05 b8 5c f0       	mov    0xf05cb805,%al
f010c45b:	83 e0 ef             	and    $0xffffffef,%eax
f010c45e:	a2 05 b8 5c f0       	mov    %al,0xf05cb805
f010c463:	a0 05 b8 5c f0       	mov    0xf05cb805,%al
f010c468:	83 c8 60             	or     $0x60,%eax
f010c46b:	a2 05 b8 5c f0       	mov    %al,0xf05cb805
f010c470:	a0 05 b8 5c f0       	mov    0xf05cb805,%al
f010c475:	83 c8 80             	or     $0xffffff80,%eax
f010c478:	a2 05 b8 5c f0       	mov    %al,0xf05cb805
f010c47d:	b8 b0 d6 10 f0       	mov    $0xf010d6b0,%eax
f010c482:	c1 e8 10             	shr    $0x10,%eax
f010c485:	66 a3 06 b8 5c f0    	mov    %ax,0xf05cb806
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010c48b:	b8 ba d6 10 f0       	mov    $0xf010d6ba,%eax
f010c490:	66 a3 08 b8 5c f0    	mov    %ax,0xf05cb808
f010c496:	66 c7 05 0a b8 5c f0 	movw   $0x8,0xf05cb80a
f010c49d:	08 00 
f010c49f:	a0 0c b8 5c f0       	mov    0xf05cb80c,%al
f010c4a4:	83 e0 e0             	and    $0xffffffe0,%eax
f010c4a7:	a2 0c b8 5c f0       	mov    %al,0xf05cb80c
f010c4ac:	a0 0c b8 5c f0       	mov    0xf05cb80c,%al
f010c4b1:	83 e0 1f             	and    $0x1f,%eax
f010c4b4:	a2 0c b8 5c f0       	mov    %al,0xf05cb80c
f010c4b9:	a0 0d b8 5c f0       	mov    0xf05cb80d,%al
f010c4be:	83 c8 0f             	or     $0xf,%eax
f010c4c1:	a2 0d b8 5c f0       	mov    %al,0xf05cb80d
f010c4c6:	a0 0d b8 5c f0       	mov    0xf05cb80d,%al
f010c4cb:	83 e0 ef             	and    $0xffffffef,%eax
f010c4ce:	a2 0d b8 5c f0       	mov    %al,0xf05cb80d
f010c4d3:	a0 0d b8 5c f0       	mov    0xf05cb80d,%al
f010c4d8:	83 c8 60             	or     $0x60,%eax
f010c4db:	a2 0d b8 5c f0       	mov    %al,0xf05cb80d
f010c4e0:	a0 0d b8 5c f0       	mov    0xf05cb80d,%al
f010c4e5:	83 c8 80             	or     $0xffffff80,%eax
f010c4e8:	a2 0d b8 5c f0       	mov    %al,0xf05cb80d
f010c4ed:	b8 ba d6 10 f0       	mov    $0xf010d6ba,%eax
f010c4f2:	c1 e8 10             	shr    $0x10,%eax
f010c4f5:	66 a3 0e b8 5c f0    	mov    %ax,0xf05cb80e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010c4fb:	b8 c4 d6 10 f0       	mov    $0xf010d6c4,%eax
f010c500:	66 a3 10 b8 5c f0    	mov    %ax,0xf05cb810
f010c506:	66 c7 05 12 b8 5c f0 	movw   $0x8,0xf05cb812
f010c50d:	08 00 
f010c50f:	a0 14 b8 5c f0       	mov    0xf05cb814,%al
f010c514:	83 e0 e0             	and    $0xffffffe0,%eax
f010c517:	a2 14 b8 5c f0       	mov    %al,0xf05cb814
f010c51c:	a0 14 b8 5c f0       	mov    0xf05cb814,%al
f010c521:	83 e0 1f             	and    $0x1f,%eax
f010c524:	a2 14 b8 5c f0       	mov    %al,0xf05cb814
f010c529:	a0 15 b8 5c f0       	mov    0xf05cb815,%al
f010c52e:	83 e0 f0             	and    $0xfffffff0,%eax
f010c531:	83 c8 0e             	or     $0xe,%eax
f010c534:	a2 15 b8 5c f0       	mov    %al,0xf05cb815
f010c539:	a0 15 b8 5c f0       	mov    0xf05cb815,%al
f010c53e:	83 e0 ef             	and    $0xffffffef,%eax
f010c541:	a2 15 b8 5c f0       	mov    %al,0xf05cb815
f010c546:	a0 15 b8 5c f0       	mov    0xf05cb815,%al
f010c54b:	83 c8 60             	or     $0x60,%eax
f010c54e:	a2 15 b8 5c f0       	mov    %al,0xf05cb815
f010c553:	a0 15 b8 5c f0       	mov    0xf05cb815,%al
f010c558:	83 c8 80             	or     $0xffffff80,%eax
f010c55b:	a2 15 b8 5c f0       	mov    %al,0xf05cb815
f010c560:	b8 c4 d6 10 f0       	mov    $0xf010d6c4,%eax
f010c565:	c1 e8 10             	shr    $0x10,%eax
f010c568:	66 a3 16 b8 5c f0    	mov    %ax,0xf05cb816
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010c56e:	b8 ce d6 10 f0       	mov    $0xf010d6ce,%eax
f010c573:	66 a3 18 b8 5c f0    	mov    %ax,0xf05cb818
f010c579:	66 c7 05 1a b8 5c f0 	movw   $0x8,0xf05cb81a
f010c580:	08 00 
f010c582:	a0 1c b8 5c f0       	mov    0xf05cb81c,%al
f010c587:	83 e0 e0             	and    $0xffffffe0,%eax
f010c58a:	a2 1c b8 5c f0       	mov    %al,0xf05cb81c
f010c58f:	a0 1c b8 5c f0       	mov    0xf05cb81c,%al
f010c594:	83 e0 1f             	and    $0x1f,%eax
f010c597:	a2 1c b8 5c f0       	mov    %al,0xf05cb81c
f010c59c:	a0 1d b8 5c f0       	mov    0xf05cb81d,%al
f010c5a1:	83 c8 0f             	or     $0xf,%eax
f010c5a4:	a2 1d b8 5c f0       	mov    %al,0xf05cb81d
f010c5a9:	a0 1d b8 5c f0       	mov    0xf05cb81d,%al
f010c5ae:	83 e0 ef             	and    $0xffffffef,%eax
f010c5b1:	a2 1d b8 5c f0       	mov    %al,0xf05cb81d
f010c5b6:	a0 1d b8 5c f0       	mov    0xf05cb81d,%al
f010c5bb:	83 c8 60             	or     $0x60,%eax
f010c5be:	a2 1d b8 5c f0       	mov    %al,0xf05cb81d
f010c5c3:	a0 1d b8 5c f0       	mov    0xf05cb81d,%al
f010c5c8:	83 c8 80             	or     $0xffffff80,%eax
f010c5cb:	a2 1d b8 5c f0       	mov    %al,0xf05cb81d
f010c5d0:	b8 ce d6 10 f0       	mov    $0xf010d6ce,%eax
f010c5d5:	c1 e8 10             	shr    $0x10,%eax
f010c5d8:	66 a3 1e b8 5c f0    	mov    %ax,0xf05cb81e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010c5de:	b8 d8 d6 10 f0       	mov    $0xf010d6d8,%eax
f010c5e3:	66 a3 20 b8 5c f0    	mov    %ax,0xf05cb820
f010c5e9:	66 c7 05 22 b8 5c f0 	movw   $0x8,0xf05cb822
f010c5f0:	08 00 
f010c5f2:	a0 24 b8 5c f0       	mov    0xf05cb824,%al
f010c5f7:	83 e0 e0             	and    $0xffffffe0,%eax
f010c5fa:	a2 24 b8 5c f0       	mov    %al,0xf05cb824
f010c5ff:	a0 24 b8 5c f0       	mov    0xf05cb824,%al
f010c604:	83 e0 1f             	and    $0x1f,%eax
f010c607:	a2 24 b8 5c f0       	mov    %al,0xf05cb824
f010c60c:	a0 25 b8 5c f0       	mov    0xf05cb825,%al
f010c611:	83 c8 0f             	or     $0xf,%eax
f010c614:	a2 25 b8 5c f0       	mov    %al,0xf05cb825
f010c619:	a0 25 b8 5c f0       	mov    0xf05cb825,%al
f010c61e:	83 e0 ef             	and    $0xffffffef,%eax
f010c621:	a2 25 b8 5c f0       	mov    %al,0xf05cb825
f010c626:	a0 25 b8 5c f0       	mov    0xf05cb825,%al
f010c62b:	83 c8 60             	or     $0x60,%eax
f010c62e:	a2 25 b8 5c f0       	mov    %al,0xf05cb825
f010c633:	a0 25 b8 5c f0       	mov    0xf05cb825,%al
f010c638:	83 c8 80             	or     $0xffffff80,%eax
f010c63b:	a2 25 b8 5c f0       	mov    %al,0xf05cb825
f010c640:	b8 d8 d6 10 f0       	mov    $0xf010d6d8,%eax
f010c645:	c1 e8 10             	shr    $0x10,%eax
f010c648:	66 a3 26 b8 5c f0    	mov    %ax,0xf05cb826
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010c64e:	b8 e2 d6 10 f0       	mov    $0xf010d6e2,%eax
f010c653:	66 a3 28 b8 5c f0    	mov    %ax,0xf05cb828
f010c659:	66 c7 05 2a b8 5c f0 	movw   $0x8,0xf05cb82a
f010c660:	08 00 
f010c662:	a0 2c b8 5c f0       	mov    0xf05cb82c,%al
f010c667:	83 e0 e0             	and    $0xffffffe0,%eax
f010c66a:	a2 2c b8 5c f0       	mov    %al,0xf05cb82c
f010c66f:	a0 2c b8 5c f0       	mov    0xf05cb82c,%al
f010c674:	83 e0 1f             	and    $0x1f,%eax
f010c677:	a2 2c b8 5c f0       	mov    %al,0xf05cb82c
f010c67c:	a0 2d b8 5c f0       	mov    0xf05cb82d,%al
f010c681:	83 e0 f0             	and    $0xfffffff0,%eax
f010c684:	83 c8 0e             	or     $0xe,%eax
f010c687:	a2 2d b8 5c f0       	mov    %al,0xf05cb82d
f010c68c:	a0 2d b8 5c f0       	mov    0xf05cb82d,%al
f010c691:	83 e0 ef             	and    $0xffffffef,%eax
f010c694:	a2 2d b8 5c f0       	mov    %al,0xf05cb82d
f010c699:	a0 2d b8 5c f0       	mov    0xf05cb82d,%al
f010c69e:	83 c8 60             	or     $0x60,%eax
f010c6a1:	a2 2d b8 5c f0       	mov    %al,0xf05cb82d
f010c6a6:	a0 2d b8 5c f0       	mov    0xf05cb82d,%al
f010c6ab:	83 c8 80             	or     $0xffffff80,%eax
f010c6ae:	a2 2d b8 5c f0       	mov    %al,0xf05cb82d
f010c6b3:	b8 e2 d6 10 f0       	mov    $0xf010d6e2,%eax
f010c6b8:	c1 e8 10             	shr    $0x10,%eax
f010c6bb:	66 a3 2e b8 5c f0    	mov    %ax,0xf05cb82e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010c6c1:	b8 ec d6 10 f0       	mov    $0xf010d6ec,%eax
f010c6c6:	66 a3 30 b8 5c f0    	mov    %ax,0xf05cb830
f010c6cc:	66 c7 05 32 b8 5c f0 	movw   $0x8,0xf05cb832
f010c6d3:	08 00 
f010c6d5:	a0 34 b8 5c f0       	mov    0xf05cb834,%al
f010c6da:	83 e0 e0             	and    $0xffffffe0,%eax
f010c6dd:	a2 34 b8 5c f0       	mov    %al,0xf05cb834
f010c6e2:	a0 34 b8 5c f0       	mov    0xf05cb834,%al
f010c6e7:	83 e0 1f             	and    $0x1f,%eax
f010c6ea:	a2 34 b8 5c f0       	mov    %al,0xf05cb834
f010c6ef:	a0 35 b8 5c f0       	mov    0xf05cb835,%al
f010c6f4:	83 e0 f0             	and    $0xfffffff0,%eax
f010c6f7:	83 c8 0e             	or     $0xe,%eax
f010c6fa:	a2 35 b8 5c f0       	mov    %al,0xf05cb835
f010c6ff:	a0 35 b8 5c f0       	mov    0xf05cb835,%al
f010c704:	83 e0 ef             	and    $0xffffffef,%eax
f010c707:	a2 35 b8 5c f0       	mov    %al,0xf05cb835
f010c70c:	a0 35 b8 5c f0       	mov    0xf05cb835,%al
f010c711:	83 c8 60             	or     $0x60,%eax
f010c714:	a2 35 b8 5c f0       	mov    %al,0xf05cb835
f010c719:	a0 35 b8 5c f0       	mov    0xf05cb835,%al
f010c71e:	83 c8 80             	or     $0xffffff80,%eax
f010c721:	a2 35 b8 5c f0       	mov    %al,0xf05cb835
f010c726:	b8 ec d6 10 f0       	mov    $0xf010d6ec,%eax
f010c72b:	c1 e8 10             	shr    $0x10,%eax
f010c72e:	66 a3 36 b8 5c f0    	mov    %ax,0xf05cb836
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010c734:	b8 f6 d6 10 f0       	mov    $0xf010d6f6,%eax
f010c739:	66 a3 38 b8 5c f0    	mov    %ax,0xf05cb838
f010c73f:	66 c7 05 3a b8 5c f0 	movw   $0x8,0xf05cb83a
f010c746:	08 00 
f010c748:	a0 3c b8 5c f0       	mov    0xf05cb83c,%al
f010c74d:	83 e0 e0             	and    $0xffffffe0,%eax
f010c750:	a2 3c b8 5c f0       	mov    %al,0xf05cb83c
f010c755:	a0 3c b8 5c f0       	mov    0xf05cb83c,%al
f010c75a:	83 e0 1f             	and    $0x1f,%eax
f010c75d:	a2 3c b8 5c f0       	mov    %al,0xf05cb83c
f010c762:	a0 3d b8 5c f0       	mov    0xf05cb83d,%al
f010c767:	83 e0 f0             	and    $0xfffffff0,%eax
f010c76a:	83 c8 0e             	or     $0xe,%eax
f010c76d:	a2 3d b8 5c f0       	mov    %al,0xf05cb83d
f010c772:	a0 3d b8 5c f0       	mov    0xf05cb83d,%al
f010c777:	83 e0 ef             	and    $0xffffffef,%eax
f010c77a:	a2 3d b8 5c f0       	mov    %al,0xf05cb83d
f010c77f:	a0 3d b8 5c f0       	mov    0xf05cb83d,%al
f010c784:	83 c8 60             	or     $0x60,%eax
f010c787:	a2 3d b8 5c f0       	mov    %al,0xf05cb83d
f010c78c:	a0 3d b8 5c f0       	mov    0xf05cb83d,%al
f010c791:	83 c8 80             	or     $0xffffff80,%eax
f010c794:	a2 3d b8 5c f0       	mov    %al,0xf05cb83d
f010c799:	b8 f6 d6 10 f0       	mov    $0xf010d6f6,%eax
f010c79e:	c1 e8 10             	shr    $0x10,%eax
f010c7a1:	66 a3 3e b8 5c f0    	mov    %ax,0xf05cb83e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010c7a7:	b8 fc d6 10 f0       	mov    $0xf010d6fc,%eax
f010c7ac:	66 a3 50 b8 5c f0    	mov    %ax,0xf05cb850
f010c7b2:	66 c7 05 52 b8 5c f0 	movw   $0x8,0xf05cb852
f010c7b9:	08 00 
f010c7bb:	a0 54 b8 5c f0       	mov    0xf05cb854,%al
f010c7c0:	83 e0 e0             	and    $0xffffffe0,%eax
f010c7c3:	a2 54 b8 5c f0       	mov    %al,0xf05cb854
f010c7c8:	a0 54 b8 5c f0       	mov    0xf05cb854,%al
f010c7cd:	83 e0 1f             	and    $0x1f,%eax
f010c7d0:	a2 54 b8 5c f0       	mov    %al,0xf05cb854
f010c7d5:	a0 55 b8 5c f0       	mov    0xf05cb855,%al
f010c7da:	83 e0 f0             	and    $0xfffffff0,%eax
f010c7dd:	83 c8 0e             	or     $0xe,%eax
f010c7e0:	a2 55 b8 5c f0       	mov    %al,0xf05cb855
f010c7e5:	a0 55 b8 5c f0       	mov    0xf05cb855,%al
f010c7ea:	83 e0 ef             	and    $0xffffffef,%eax
f010c7ed:	a2 55 b8 5c f0       	mov    %al,0xf05cb855
f010c7f2:	a0 55 b8 5c f0       	mov    0xf05cb855,%al
f010c7f7:	83 c8 60             	or     $0x60,%eax
f010c7fa:	a2 55 b8 5c f0       	mov    %al,0xf05cb855
f010c7ff:	a0 55 b8 5c f0       	mov    0xf05cb855,%al
f010c804:	83 c8 80             	or     $0xffffff80,%eax
f010c807:	a2 55 b8 5c f0       	mov    %al,0xf05cb855
f010c80c:	b8 fc d6 10 f0       	mov    $0xf010d6fc,%eax
f010c811:	c1 e8 10             	shr    $0x10,%eax
f010c814:	66 a3 56 b8 5c f0    	mov    %ax,0xf05cb856
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010c81a:	b8 00 d7 10 f0       	mov    $0xf010d700,%eax
f010c81f:	66 a3 58 b8 5c f0    	mov    %ax,0xf05cb858
f010c825:	66 c7 05 5a b8 5c f0 	movw   $0x8,0xf05cb85a
f010c82c:	08 00 
f010c82e:	a0 5c b8 5c f0       	mov    0xf05cb85c,%al
f010c833:	83 e0 e0             	and    $0xffffffe0,%eax
f010c836:	a2 5c b8 5c f0       	mov    %al,0xf05cb85c
f010c83b:	a0 5c b8 5c f0       	mov    0xf05cb85c,%al
f010c840:	83 e0 1f             	and    $0x1f,%eax
f010c843:	a2 5c b8 5c f0       	mov    %al,0xf05cb85c
f010c848:	a0 5d b8 5c f0       	mov    0xf05cb85d,%al
f010c84d:	83 e0 f0             	and    $0xfffffff0,%eax
f010c850:	83 c8 0e             	or     $0xe,%eax
f010c853:	a2 5d b8 5c f0       	mov    %al,0xf05cb85d
f010c858:	a0 5d b8 5c f0       	mov    0xf05cb85d,%al
f010c85d:	83 e0 ef             	and    $0xffffffef,%eax
f010c860:	a2 5d b8 5c f0       	mov    %al,0xf05cb85d
f010c865:	a0 5d b8 5c f0       	mov    0xf05cb85d,%al
f010c86a:	83 c8 60             	or     $0x60,%eax
f010c86d:	a2 5d b8 5c f0       	mov    %al,0xf05cb85d
f010c872:	a0 5d b8 5c f0       	mov    0xf05cb85d,%al
f010c877:	83 c8 80             	or     $0xffffff80,%eax
f010c87a:	a2 5d b8 5c f0       	mov    %al,0xf05cb85d
f010c87f:	b8 00 d7 10 f0       	mov    $0xf010d700,%eax
f010c884:	c1 e8 10             	shr    $0x10,%eax
f010c887:	66 a3 5e b8 5c f0    	mov    %ax,0xf05cb85e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010c88d:	b8 04 d7 10 f0       	mov    $0xf010d704,%eax
f010c892:	66 a3 60 b8 5c f0    	mov    %ax,0xf05cb860
f010c898:	66 c7 05 62 b8 5c f0 	movw   $0x8,0xf05cb862
f010c89f:	08 00 
f010c8a1:	a0 64 b8 5c f0       	mov    0xf05cb864,%al
f010c8a6:	83 e0 e0             	and    $0xffffffe0,%eax
f010c8a9:	a2 64 b8 5c f0       	mov    %al,0xf05cb864
f010c8ae:	a0 64 b8 5c f0       	mov    0xf05cb864,%al
f010c8b3:	83 e0 1f             	and    $0x1f,%eax
f010c8b6:	a2 64 b8 5c f0       	mov    %al,0xf05cb864
f010c8bb:	a0 65 b8 5c f0       	mov    0xf05cb865,%al
f010c8c0:	83 e0 f0             	and    $0xfffffff0,%eax
f010c8c3:	83 c8 0e             	or     $0xe,%eax
f010c8c6:	a2 65 b8 5c f0       	mov    %al,0xf05cb865
f010c8cb:	a0 65 b8 5c f0       	mov    0xf05cb865,%al
f010c8d0:	83 e0 ef             	and    $0xffffffef,%eax
f010c8d3:	a2 65 b8 5c f0       	mov    %al,0xf05cb865
f010c8d8:	a0 65 b8 5c f0       	mov    0xf05cb865,%al
f010c8dd:	83 c8 60             	or     $0x60,%eax
f010c8e0:	a2 65 b8 5c f0       	mov    %al,0xf05cb865
f010c8e5:	a0 65 b8 5c f0       	mov    0xf05cb865,%al
f010c8ea:	83 c8 80             	or     $0xffffff80,%eax
f010c8ed:	a2 65 b8 5c f0       	mov    %al,0xf05cb865
f010c8f2:	b8 04 d7 10 f0       	mov    $0xf010d704,%eax
f010c8f7:	c1 e8 10             	shr    $0x10,%eax
f010c8fa:	66 a3 66 b8 5c f0    	mov    %ax,0xf05cb866
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010c900:	b8 08 d7 10 f0       	mov    $0xf010d708,%eax
f010c905:	66 a3 68 b8 5c f0    	mov    %ax,0xf05cb868
f010c90b:	66 c7 05 6a b8 5c f0 	movw   $0x8,0xf05cb86a
f010c912:	08 00 
f010c914:	a0 6c b8 5c f0       	mov    0xf05cb86c,%al
f010c919:	83 e0 e0             	and    $0xffffffe0,%eax
f010c91c:	a2 6c b8 5c f0       	mov    %al,0xf05cb86c
f010c921:	a0 6c b8 5c f0       	mov    0xf05cb86c,%al
f010c926:	83 e0 1f             	and    $0x1f,%eax
f010c929:	a2 6c b8 5c f0       	mov    %al,0xf05cb86c
f010c92e:	a0 6d b8 5c f0       	mov    0xf05cb86d,%al
f010c933:	83 e0 f0             	and    $0xfffffff0,%eax
f010c936:	83 c8 0e             	or     $0xe,%eax
f010c939:	a2 6d b8 5c f0       	mov    %al,0xf05cb86d
f010c93e:	a0 6d b8 5c f0       	mov    0xf05cb86d,%al
f010c943:	83 e0 ef             	and    $0xffffffef,%eax
f010c946:	a2 6d b8 5c f0       	mov    %al,0xf05cb86d
f010c94b:	a0 6d b8 5c f0       	mov    0xf05cb86d,%al
f010c950:	83 c8 60             	or     $0x60,%eax
f010c953:	a2 6d b8 5c f0       	mov    %al,0xf05cb86d
f010c958:	a0 6d b8 5c f0       	mov    0xf05cb86d,%al
f010c95d:	83 c8 80             	or     $0xffffff80,%eax
f010c960:	a2 6d b8 5c f0       	mov    %al,0xf05cb86d
f010c965:	b8 08 d7 10 f0       	mov    $0xf010d708,%eax
f010c96a:	c1 e8 10             	shr    $0x10,%eax
f010c96d:	66 a3 6e b8 5c f0    	mov    %ax,0xf05cb86e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010c973:	b8 0c d7 10 f0       	mov    $0xf010d70c,%eax
f010c978:	66 a3 80 b8 5c f0    	mov    %ax,0xf05cb880
f010c97e:	66 c7 05 82 b8 5c f0 	movw   $0x8,0xf05cb882
f010c985:	08 00 
f010c987:	a0 84 b8 5c f0       	mov    0xf05cb884,%al
f010c98c:	83 e0 e0             	and    $0xffffffe0,%eax
f010c98f:	a2 84 b8 5c f0       	mov    %al,0xf05cb884
f010c994:	a0 84 b8 5c f0       	mov    0xf05cb884,%al
f010c999:	83 e0 1f             	and    $0x1f,%eax
f010c99c:	a2 84 b8 5c f0       	mov    %al,0xf05cb884
f010c9a1:	a0 85 b8 5c f0       	mov    0xf05cb885,%al
f010c9a6:	83 e0 f0             	and    $0xfffffff0,%eax
f010c9a9:	83 c8 0e             	or     $0xe,%eax
f010c9ac:	a2 85 b8 5c f0       	mov    %al,0xf05cb885
f010c9b1:	a0 85 b8 5c f0       	mov    0xf05cb885,%al
f010c9b6:	83 e0 ef             	and    $0xffffffef,%eax
f010c9b9:	a2 85 b8 5c f0       	mov    %al,0xf05cb885
f010c9be:	a0 85 b8 5c f0       	mov    0xf05cb885,%al
f010c9c3:	83 c8 60             	or     $0x60,%eax
f010c9c6:	a2 85 b8 5c f0       	mov    %al,0xf05cb885
f010c9cb:	a0 85 b8 5c f0       	mov    0xf05cb885,%al
f010c9d0:	83 c8 80             	or     $0xffffff80,%eax
f010c9d3:	a2 85 b8 5c f0       	mov    %al,0xf05cb885
f010c9d8:	b8 0c d7 10 f0       	mov    $0xf010d70c,%eax
f010c9dd:	c1 e8 10             	shr    $0x10,%eax
f010c9e0:	66 a3 86 b8 5c f0    	mov    %ax,0xf05cb886
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010c9e6:	b8 12 d7 10 f0       	mov    $0xf010d712,%eax
f010c9eb:	66 a3 88 b8 5c f0    	mov    %ax,0xf05cb888
f010c9f1:	66 c7 05 8a b8 5c f0 	movw   $0x8,0xf05cb88a
f010c9f8:	08 00 
f010c9fa:	a0 8c b8 5c f0       	mov    0xf05cb88c,%al
f010c9ff:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca02:	a2 8c b8 5c f0       	mov    %al,0xf05cb88c
f010ca07:	a0 8c b8 5c f0       	mov    0xf05cb88c,%al
f010ca0c:	83 e0 1f             	and    $0x1f,%eax
f010ca0f:	a2 8c b8 5c f0       	mov    %al,0xf05cb88c
f010ca14:	a0 8d b8 5c f0       	mov    0xf05cb88d,%al
f010ca19:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca1c:	83 c8 0e             	or     $0xe,%eax
f010ca1f:	a2 8d b8 5c f0       	mov    %al,0xf05cb88d
f010ca24:	a0 8d b8 5c f0       	mov    0xf05cb88d,%al
f010ca29:	83 e0 ef             	and    $0xffffffef,%eax
f010ca2c:	a2 8d b8 5c f0       	mov    %al,0xf05cb88d
f010ca31:	a0 8d b8 5c f0       	mov    0xf05cb88d,%al
f010ca36:	83 c8 60             	or     $0x60,%eax
f010ca39:	a2 8d b8 5c f0       	mov    %al,0xf05cb88d
f010ca3e:	a0 8d b8 5c f0       	mov    0xf05cb88d,%al
f010ca43:	83 c8 80             	or     $0xffffff80,%eax
f010ca46:	a2 8d b8 5c f0       	mov    %al,0xf05cb88d
f010ca4b:	b8 12 d7 10 f0       	mov    $0xf010d712,%eax
f010ca50:	c1 e8 10             	shr    $0x10,%eax
f010ca53:	66 a3 8e b8 5c f0    	mov    %ax,0xf05cb88e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010ca59:	b8 16 d7 10 f0       	mov    $0xf010d716,%eax
f010ca5e:	66 a3 90 b8 5c f0    	mov    %ax,0xf05cb890
f010ca64:	66 c7 05 92 b8 5c f0 	movw   $0x8,0xf05cb892
f010ca6b:	08 00 
f010ca6d:	a0 94 b8 5c f0       	mov    0xf05cb894,%al
f010ca72:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca75:	a2 94 b8 5c f0       	mov    %al,0xf05cb894
f010ca7a:	a0 94 b8 5c f0       	mov    0xf05cb894,%al
f010ca7f:	83 e0 1f             	and    $0x1f,%eax
f010ca82:	a2 94 b8 5c f0       	mov    %al,0xf05cb894
f010ca87:	a0 95 b8 5c f0       	mov    0xf05cb895,%al
f010ca8c:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca8f:	83 c8 0e             	or     $0xe,%eax
f010ca92:	a2 95 b8 5c f0       	mov    %al,0xf05cb895
f010ca97:	a0 95 b8 5c f0       	mov    0xf05cb895,%al
f010ca9c:	83 e0 ef             	and    $0xffffffef,%eax
f010ca9f:	a2 95 b8 5c f0       	mov    %al,0xf05cb895
f010caa4:	a0 95 b8 5c f0       	mov    0xf05cb895,%al
f010caa9:	83 c8 60             	or     $0x60,%eax
f010caac:	a2 95 b8 5c f0       	mov    %al,0xf05cb895
f010cab1:	a0 95 b8 5c f0       	mov    0xf05cb895,%al
f010cab6:	83 c8 80             	or     $0xffffff80,%eax
f010cab9:	a2 95 b8 5c f0       	mov    %al,0xf05cb895
f010cabe:	b8 16 d7 10 f0       	mov    $0xf010d716,%eax
f010cac3:	c1 e8 10             	shr    $0x10,%eax
f010cac6:	66 a3 96 b8 5c f0    	mov    %ax,0xf05cb896
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010cacc:	b8 1c d7 10 f0       	mov    $0xf010d71c,%eax
f010cad1:	66 a3 98 b8 5c f0    	mov    %ax,0xf05cb898
f010cad7:	66 c7 05 9a b8 5c f0 	movw   $0x8,0xf05cb89a
f010cade:	08 00 
f010cae0:	a0 9c b8 5c f0       	mov    0xf05cb89c,%al
f010cae5:	83 e0 e0             	and    $0xffffffe0,%eax
f010cae8:	a2 9c b8 5c f0       	mov    %al,0xf05cb89c
f010caed:	a0 9c b8 5c f0       	mov    0xf05cb89c,%al
f010caf2:	83 e0 1f             	and    $0x1f,%eax
f010caf5:	a2 9c b8 5c f0       	mov    %al,0xf05cb89c
f010cafa:	a0 9d b8 5c f0       	mov    0xf05cb89d,%al
f010caff:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb02:	83 c8 0e             	or     $0xe,%eax
f010cb05:	a2 9d b8 5c f0       	mov    %al,0xf05cb89d
f010cb0a:	a0 9d b8 5c f0       	mov    0xf05cb89d,%al
f010cb0f:	83 e0 ef             	and    $0xffffffef,%eax
f010cb12:	a2 9d b8 5c f0       	mov    %al,0xf05cb89d
f010cb17:	a0 9d b8 5c f0       	mov    0xf05cb89d,%al
f010cb1c:	83 c8 60             	or     $0x60,%eax
f010cb1f:	a2 9d b8 5c f0       	mov    %al,0xf05cb89d
f010cb24:	a0 9d b8 5c f0       	mov    0xf05cb89d,%al
f010cb29:	83 c8 80             	or     $0xffffff80,%eax
f010cb2c:	a2 9d b8 5c f0       	mov    %al,0xf05cb89d
f010cb31:	b8 1c d7 10 f0       	mov    $0xf010d71c,%eax
f010cb36:	c1 e8 10             	shr    $0x10,%eax
f010cb39:	66 a3 9e b8 5c f0    	mov    %ax,0xf05cb89e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010cb3f:	b8 22 d7 10 f0       	mov    $0xf010d722,%eax
f010cb44:	66 a3 10 b9 5c f0    	mov    %ax,0xf05cb910
f010cb4a:	66 c7 05 12 b9 5c f0 	movw   $0x8,0xf05cb912
f010cb51:	08 00 
f010cb53:	a0 14 b9 5c f0       	mov    0xf05cb914,%al
f010cb58:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb5b:	a2 14 b9 5c f0       	mov    %al,0xf05cb914
f010cb60:	a0 14 b9 5c f0       	mov    0xf05cb914,%al
f010cb65:	83 e0 1f             	and    $0x1f,%eax
f010cb68:	a2 14 b9 5c f0       	mov    %al,0xf05cb914
f010cb6d:	a0 15 b9 5c f0       	mov    0xf05cb915,%al
f010cb72:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb75:	83 c8 0e             	or     $0xe,%eax
f010cb78:	a2 15 b9 5c f0       	mov    %al,0xf05cb915
f010cb7d:	a0 15 b9 5c f0       	mov    0xf05cb915,%al
f010cb82:	83 e0 ef             	and    $0xffffffef,%eax
f010cb85:	a2 15 b9 5c f0       	mov    %al,0xf05cb915
f010cb8a:	a0 15 b9 5c f0       	mov    0xf05cb915,%al
f010cb8f:	83 c8 60             	or     $0x60,%eax
f010cb92:	a2 15 b9 5c f0       	mov    %al,0xf05cb915
f010cb97:	a0 15 b9 5c f0       	mov    0xf05cb915,%al
f010cb9c:	83 c8 80             	or     $0xffffff80,%eax
f010cb9f:	a2 15 b9 5c f0       	mov    %al,0xf05cb915
f010cba4:	b8 22 d7 10 f0       	mov    $0xf010d722,%eax
f010cba9:	c1 e8 10             	shr    $0x10,%eax
f010cbac:	66 a3 16 b9 5c f0    	mov    %ax,0xf05cb916
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010cbb2:	b8 28 d7 10 f0       	mov    $0xf010d728,%eax
f010cbb7:	66 a3 18 b9 5c f0    	mov    %ax,0xf05cb918
f010cbbd:	66 c7 05 1a b9 5c f0 	movw   $0x8,0xf05cb91a
f010cbc4:	08 00 
f010cbc6:	a0 1c b9 5c f0       	mov    0xf05cb91c,%al
f010cbcb:	83 e0 e0             	and    $0xffffffe0,%eax
f010cbce:	a2 1c b9 5c f0       	mov    %al,0xf05cb91c
f010cbd3:	a0 1c b9 5c f0       	mov    0xf05cb91c,%al
f010cbd8:	83 e0 1f             	and    $0x1f,%eax
f010cbdb:	a2 1c b9 5c f0       	mov    %al,0xf05cb91c
f010cbe0:	a0 1d b9 5c f0       	mov    0xf05cb91d,%al
f010cbe5:	83 e0 f0             	and    $0xfffffff0,%eax
f010cbe8:	83 c8 0e             	or     $0xe,%eax
f010cbeb:	a2 1d b9 5c f0       	mov    %al,0xf05cb91d
f010cbf0:	a0 1d b9 5c f0       	mov    0xf05cb91d,%al
f010cbf5:	83 e0 ef             	and    $0xffffffef,%eax
f010cbf8:	a2 1d b9 5c f0       	mov    %al,0xf05cb91d
f010cbfd:	a0 1d b9 5c f0       	mov    0xf05cb91d,%al
f010cc02:	83 c8 60             	or     $0x60,%eax
f010cc05:	a2 1d b9 5c f0       	mov    %al,0xf05cb91d
f010cc0a:	a0 1d b9 5c f0       	mov    0xf05cb91d,%al
f010cc0f:	83 c8 80             	or     $0xffffff80,%eax
f010cc12:	a2 1d b9 5c f0       	mov    %al,0xf05cb91d
f010cc17:	b8 28 d7 10 f0       	mov    $0xf010d728,%eax
f010cc1c:	c1 e8 10             	shr    $0x10,%eax
f010cc1f:	66 a3 1e b9 5c f0    	mov    %ax,0xf05cb91e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010cc25:	b8 2e d7 10 f0       	mov    $0xf010d72e,%eax
f010cc2a:	66 a3 20 b9 5c f0    	mov    %ax,0xf05cb920
f010cc30:	66 c7 05 22 b9 5c f0 	movw   $0x8,0xf05cb922
f010cc37:	08 00 
f010cc39:	a0 24 b9 5c f0       	mov    0xf05cb924,%al
f010cc3e:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc41:	a2 24 b9 5c f0       	mov    %al,0xf05cb924
f010cc46:	a0 24 b9 5c f0       	mov    0xf05cb924,%al
f010cc4b:	83 e0 1f             	and    $0x1f,%eax
f010cc4e:	a2 24 b9 5c f0       	mov    %al,0xf05cb924
f010cc53:	a0 25 b9 5c f0       	mov    0xf05cb925,%al
f010cc58:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc5b:	83 c8 0e             	or     $0xe,%eax
f010cc5e:	a2 25 b9 5c f0       	mov    %al,0xf05cb925
f010cc63:	a0 25 b9 5c f0       	mov    0xf05cb925,%al
f010cc68:	83 e0 ef             	and    $0xffffffef,%eax
f010cc6b:	a2 25 b9 5c f0       	mov    %al,0xf05cb925
f010cc70:	a0 25 b9 5c f0       	mov    0xf05cb925,%al
f010cc75:	83 c8 60             	or     $0x60,%eax
f010cc78:	a2 25 b9 5c f0       	mov    %al,0xf05cb925
f010cc7d:	a0 25 b9 5c f0       	mov    0xf05cb925,%al
f010cc82:	83 c8 80             	or     $0xffffff80,%eax
f010cc85:	a2 25 b9 5c f0       	mov    %al,0xf05cb925
f010cc8a:	b8 2e d7 10 f0       	mov    $0xf010d72e,%eax
f010cc8f:	c1 e8 10             	shr    $0x10,%eax
f010cc92:	66 a3 26 b9 5c f0    	mov    %ax,0xf05cb926
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010cc98:	b8 34 d7 10 f0       	mov    $0xf010d734,%eax
f010cc9d:	66 a3 28 b9 5c f0    	mov    %ax,0xf05cb928
f010cca3:	66 c7 05 2a b9 5c f0 	movw   $0x8,0xf05cb92a
f010ccaa:	08 00 
f010ccac:	a0 2c b9 5c f0       	mov    0xf05cb92c,%al
f010ccb1:	83 e0 e0             	and    $0xffffffe0,%eax
f010ccb4:	a2 2c b9 5c f0       	mov    %al,0xf05cb92c
f010ccb9:	a0 2c b9 5c f0       	mov    0xf05cb92c,%al
f010ccbe:	83 e0 1f             	and    $0x1f,%eax
f010ccc1:	a2 2c b9 5c f0       	mov    %al,0xf05cb92c
f010ccc6:	a0 2d b9 5c f0       	mov    0xf05cb92d,%al
f010cccb:	83 e0 f0             	and    $0xfffffff0,%eax
f010ccce:	83 c8 0e             	or     $0xe,%eax
f010ccd1:	a2 2d b9 5c f0       	mov    %al,0xf05cb92d
f010ccd6:	a0 2d b9 5c f0       	mov    0xf05cb92d,%al
f010ccdb:	83 e0 ef             	and    $0xffffffef,%eax
f010ccde:	a2 2d b9 5c f0       	mov    %al,0xf05cb92d
f010cce3:	a0 2d b9 5c f0       	mov    0xf05cb92d,%al
f010cce8:	83 c8 60             	or     $0x60,%eax
f010cceb:	a2 2d b9 5c f0       	mov    %al,0xf05cb92d
f010ccf0:	a0 2d b9 5c f0       	mov    0xf05cb92d,%al
f010ccf5:	83 c8 80             	or     $0xffffff80,%eax
f010ccf8:	a2 2d b9 5c f0       	mov    %al,0xf05cb92d
f010ccfd:	b8 34 d7 10 f0       	mov    $0xf010d734,%eax
f010cd02:	c1 e8 10             	shr    $0x10,%eax
f010cd05:	66 a3 2e b9 5c f0    	mov    %ax,0xf05cb92e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010cd0b:	b8 3a d7 10 f0       	mov    $0xf010d73a,%eax
f010cd10:	66 a3 30 b9 5c f0    	mov    %ax,0xf05cb930
f010cd16:	66 c7 05 32 b9 5c f0 	movw   $0x8,0xf05cb932
f010cd1d:	08 00 
f010cd1f:	a0 34 b9 5c f0       	mov    0xf05cb934,%al
f010cd24:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd27:	a2 34 b9 5c f0       	mov    %al,0xf05cb934
f010cd2c:	a0 34 b9 5c f0       	mov    0xf05cb934,%al
f010cd31:	83 e0 1f             	and    $0x1f,%eax
f010cd34:	a2 34 b9 5c f0       	mov    %al,0xf05cb934
f010cd39:	a0 35 b9 5c f0       	mov    0xf05cb935,%al
f010cd3e:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd41:	83 c8 0e             	or     $0xe,%eax
f010cd44:	a2 35 b9 5c f0       	mov    %al,0xf05cb935
f010cd49:	a0 35 b9 5c f0       	mov    0xf05cb935,%al
f010cd4e:	83 e0 ef             	and    $0xffffffef,%eax
f010cd51:	a2 35 b9 5c f0       	mov    %al,0xf05cb935
f010cd56:	a0 35 b9 5c f0       	mov    0xf05cb935,%al
f010cd5b:	83 c8 60             	or     $0x60,%eax
f010cd5e:	a2 35 b9 5c f0       	mov    %al,0xf05cb935
f010cd63:	a0 35 b9 5c f0       	mov    0xf05cb935,%al
f010cd68:	83 c8 80             	or     $0xffffff80,%eax
f010cd6b:	a2 35 b9 5c f0       	mov    %al,0xf05cb935
f010cd70:	b8 3a d7 10 f0       	mov    $0xf010d73a,%eax
f010cd75:	c1 e8 10             	shr    $0x10,%eax
f010cd78:	66 a3 36 b9 5c f0    	mov    %ax,0xf05cb936
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010cd7e:	b8 40 d7 10 f0       	mov    $0xf010d740,%eax
f010cd83:	66 a3 38 b9 5c f0    	mov    %ax,0xf05cb938
f010cd89:	66 c7 05 3a b9 5c f0 	movw   $0x8,0xf05cb93a
f010cd90:	08 00 
f010cd92:	a0 3c b9 5c f0       	mov    0xf05cb93c,%al
f010cd97:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd9a:	a2 3c b9 5c f0       	mov    %al,0xf05cb93c
f010cd9f:	a0 3c b9 5c f0       	mov    0xf05cb93c,%al
f010cda4:	83 e0 1f             	and    $0x1f,%eax
f010cda7:	a2 3c b9 5c f0       	mov    %al,0xf05cb93c
f010cdac:	a0 3d b9 5c f0       	mov    0xf05cb93d,%al
f010cdb1:	83 e0 f0             	and    $0xfffffff0,%eax
f010cdb4:	83 c8 0e             	or     $0xe,%eax
f010cdb7:	a2 3d b9 5c f0       	mov    %al,0xf05cb93d
f010cdbc:	a0 3d b9 5c f0       	mov    0xf05cb93d,%al
f010cdc1:	83 e0 ef             	and    $0xffffffef,%eax
f010cdc4:	a2 3d b9 5c f0       	mov    %al,0xf05cb93d
f010cdc9:	a0 3d b9 5c f0       	mov    0xf05cb93d,%al
f010cdce:	83 c8 60             	or     $0x60,%eax
f010cdd1:	a2 3d b9 5c f0       	mov    %al,0xf05cb93d
f010cdd6:	a0 3d b9 5c f0       	mov    0xf05cb93d,%al
f010cddb:	83 c8 80             	or     $0xffffff80,%eax
f010cdde:	a2 3d b9 5c f0       	mov    %al,0xf05cb93d
f010cde3:	b8 40 d7 10 f0       	mov    $0xf010d740,%eax
f010cde8:	c1 e8 10             	shr    $0x10,%eax
f010cdeb:	66 a3 3e b9 5c f0    	mov    %ax,0xf05cb93e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010cdf1:	b8 46 d7 10 f0       	mov    $0xf010d746,%eax
f010cdf6:	66 a3 40 b9 5c f0    	mov    %ax,0xf05cb940
f010cdfc:	66 c7 05 42 b9 5c f0 	movw   $0x8,0xf05cb942
f010ce03:	08 00 
f010ce05:	a0 44 b9 5c f0       	mov    0xf05cb944,%al
f010ce0a:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce0d:	a2 44 b9 5c f0       	mov    %al,0xf05cb944
f010ce12:	a0 44 b9 5c f0       	mov    0xf05cb944,%al
f010ce17:	83 e0 1f             	and    $0x1f,%eax
f010ce1a:	a2 44 b9 5c f0       	mov    %al,0xf05cb944
f010ce1f:	a0 45 b9 5c f0       	mov    0xf05cb945,%al
f010ce24:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce27:	83 c8 0e             	or     $0xe,%eax
f010ce2a:	a2 45 b9 5c f0       	mov    %al,0xf05cb945
f010ce2f:	a0 45 b9 5c f0       	mov    0xf05cb945,%al
f010ce34:	83 e0 ef             	and    $0xffffffef,%eax
f010ce37:	a2 45 b9 5c f0       	mov    %al,0xf05cb945
f010ce3c:	a0 45 b9 5c f0       	mov    0xf05cb945,%al
f010ce41:	83 c8 60             	or     $0x60,%eax
f010ce44:	a2 45 b9 5c f0       	mov    %al,0xf05cb945
f010ce49:	a0 45 b9 5c f0       	mov    0xf05cb945,%al
f010ce4e:	83 c8 80             	or     $0xffffff80,%eax
f010ce51:	a2 45 b9 5c f0       	mov    %al,0xf05cb945
f010ce56:	b8 46 d7 10 f0       	mov    $0xf010d746,%eax
f010ce5b:	c1 e8 10             	shr    $0x10,%eax
f010ce5e:	66 a3 46 b9 5c f0    	mov    %ax,0xf05cb946
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010ce64:	b8 4c d7 10 f0       	mov    $0xf010d74c,%eax
f010ce69:	66 a3 48 b9 5c f0    	mov    %ax,0xf05cb948
f010ce6f:	66 c7 05 4a b9 5c f0 	movw   $0x8,0xf05cb94a
f010ce76:	08 00 
f010ce78:	a0 4c b9 5c f0       	mov    0xf05cb94c,%al
f010ce7d:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce80:	a2 4c b9 5c f0       	mov    %al,0xf05cb94c
f010ce85:	a0 4c b9 5c f0       	mov    0xf05cb94c,%al
f010ce8a:	83 e0 1f             	and    $0x1f,%eax
f010ce8d:	a2 4c b9 5c f0       	mov    %al,0xf05cb94c
f010ce92:	a0 4d b9 5c f0       	mov    0xf05cb94d,%al
f010ce97:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce9a:	83 c8 0e             	or     $0xe,%eax
f010ce9d:	a2 4d b9 5c f0       	mov    %al,0xf05cb94d
f010cea2:	a0 4d b9 5c f0       	mov    0xf05cb94d,%al
f010cea7:	83 e0 ef             	and    $0xffffffef,%eax
f010ceaa:	a2 4d b9 5c f0       	mov    %al,0xf05cb94d
f010ceaf:	a0 4d b9 5c f0       	mov    0xf05cb94d,%al
f010ceb4:	83 c8 60             	or     $0x60,%eax
f010ceb7:	a2 4d b9 5c f0       	mov    %al,0xf05cb94d
f010cebc:	a0 4d b9 5c f0       	mov    0xf05cb94d,%al
f010cec1:	83 c8 80             	or     $0xffffff80,%eax
f010cec4:	a2 4d b9 5c f0       	mov    %al,0xf05cb94d
f010cec9:	b8 4c d7 10 f0       	mov    $0xf010d74c,%eax
f010cece:	c1 e8 10             	shr    $0x10,%eax
f010ced1:	66 a3 4e b9 5c f0    	mov    %ax,0xf05cb94e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010ced7:	b8 52 d7 10 f0       	mov    $0xf010d752,%eax
f010cedc:	66 a3 50 b9 5c f0    	mov    %ax,0xf05cb950
f010cee2:	66 c7 05 52 b9 5c f0 	movw   $0x8,0xf05cb952
f010cee9:	08 00 
f010ceeb:	a0 54 b9 5c f0       	mov    0xf05cb954,%al
f010cef0:	83 e0 e0             	and    $0xffffffe0,%eax
f010cef3:	a2 54 b9 5c f0       	mov    %al,0xf05cb954
f010cef8:	a0 54 b9 5c f0       	mov    0xf05cb954,%al
f010cefd:	83 e0 1f             	and    $0x1f,%eax
f010cf00:	a2 54 b9 5c f0       	mov    %al,0xf05cb954
f010cf05:	a0 55 b9 5c f0       	mov    0xf05cb955,%al
f010cf0a:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf0d:	83 c8 0e             	or     $0xe,%eax
f010cf10:	a2 55 b9 5c f0       	mov    %al,0xf05cb955
f010cf15:	a0 55 b9 5c f0       	mov    0xf05cb955,%al
f010cf1a:	83 e0 ef             	and    $0xffffffef,%eax
f010cf1d:	a2 55 b9 5c f0       	mov    %al,0xf05cb955
f010cf22:	a0 55 b9 5c f0       	mov    0xf05cb955,%al
f010cf27:	83 c8 60             	or     $0x60,%eax
f010cf2a:	a2 55 b9 5c f0       	mov    %al,0xf05cb955
f010cf2f:	a0 55 b9 5c f0       	mov    0xf05cb955,%al
f010cf34:	83 c8 80             	or     $0xffffff80,%eax
f010cf37:	a2 55 b9 5c f0       	mov    %al,0xf05cb955
f010cf3c:	b8 52 d7 10 f0       	mov    $0xf010d752,%eax
f010cf41:	c1 e8 10             	shr    $0x10,%eax
f010cf44:	66 a3 56 b9 5c f0    	mov    %ax,0xf05cb956
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010cf4a:	b8 58 d7 10 f0       	mov    $0xf010d758,%eax
f010cf4f:	66 a3 58 b9 5c f0    	mov    %ax,0xf05cb958
f010cf55:	66 c7 05 5a b9 5c f0 	movw   $0x8,0xf05cb95a
f010cf5c:	08 00 
f010cf5e:	a0 5c b9 5c f0       	mov    0xf05cb95c,%al
f010cf63:	83 e0 e0             	and    $0xffffffe0,%eax
f010cf66:	a2 5c b9 5c f0       	mov    %al,0xf05cb95c
f010cf6b:	a0 5c b9 5c f0       	mov    0xf05cb95c,%al
f010cf70:	83 e0 1f             	and    $0x1f,%eax
f010cf73:	a2 5c b9 5c f0       	mov    %al,0xf05cb95c
f010cf78:	a0 5d b9 5c f0       	mov    0xf05cb95d,%al
f010cf7d:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf80:	83 c8 0e             	or     $0xe,%eax
f010cf83:	a2 5d b9 5c f0       	mov    %al,0xf05cb95d
f010cf88:	a0 5d b9 5c f0       	mov    0xf05cb95d,%al
f010cf8d:	83 e0 ef             	and    $0xffffffef,%eax
f010cf90:	a2 5d b9 5c f0       	mov    %al,0xf05cb95d
f010cf95:	a0 5d b9 5c f0       	mov    0xf05cb95d,%al
f010cf9a:	83 c8 60             	or     $0x60,%eax
f010cf9d:	a2 5d b9 5c f0       	mov    %al,0xf05cb95d
f010cfa2:	a0 5d b9 5c f0       	mov    0xf05cb95d,%al
f010cfa7:	83 c8 80             	or     $0xffffff80,%eax
f010cfaa:	a2 5d b9 5c f0       	mov    %al,0xf05cb95d
f010cfaf:	b8 58 d7 10 f0       	mov    $0xf010d758,%eax
f010cfb4:	c1 e8 10             	shr    $0x10,%eax
f010cfb7:	66 a3 5e b9 5c f0    	mov    %ax,0xf05cb95e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010cfbd:	b8 5e d7 10 f0       	mov    $0xf010d75e,%eax
f010cfc2:	66 a3 60 b9 5c f0    	mov    %ax,0xf05cb960
f010cfc8:	66 c7 05 62 b9 5c f0 	movw   $0x8,0xf05cb962
f010cfcf:	08 00 
f010cfd1:	a0 64 b9 5c f0       	mov    0xf05cb964,%al
f010cfd6:	83 e0 e0             	and    $0xffffffe0,%eax
f010cfd9:	a2 64 b9 5c f0       	mov    %al,0xf05cb964
f010cfde:	a0 64 b9 5c f0       	mov    0xf05cb964,%al
f010cfe3:	83 e0 1f             	and    $0x1f,%eax
f010cfe6:	a2 64 b9 5c f0       	mov    %al,0xf05cb964
f010cfeb:	a0 65 b9 5c f0       	mov    0xf05cb965,%al
f010cff0:	83 e0 f0             	and    $0xfffffff0,%eax
f010cff3:	83 c8 0e             	or     $0xe,%eax
f010cff6:	a2 65 b9 5c f0       	mov    %al,0xf05cb965
f010cffb:	a0 65 b9 5c f0       	mov    0xf05cb965,%al
f010d000:	83 e0 ef             	and    $0xffffffef,%eax
f010d003:	a2 65 b9 5c f0       	mov    %al,0xf05cb965
f010d008:	a0 65 b9 5c f0       	mov    0xf05cb965,%al
f010d00d:	83 c8 60             	or     $0x60,%eax
f010d010:	a2 65 b9 5c f0       	mov    %al,0xf05cb965
f010d015:	a0 65 b9 5c f0       	mov    0xf05cb965,%al
f010d01a:	83 c8 80             	or     $0xffffff80,%eax
f010d01d:	a2 65 b9 5c f0       	mov    %al,0xf05cb965
f010d022:	b8 5e d7 10 f0       	mov    $0xf010d75e,%eax
f010d027:	c1 e8 10             	shr    $0x10,%eax
f010d02a:	66 a3 66 b9 5c f0    	mov    %ax,0xf05cb966
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010d030:	b8 64 d7 10 f0       	mov    $0xf010d764,%eax
f010d035:	66 a3 68 b9 5c f0    	mov    %ax,0xf05cb968
f010d03b:	66 c7 05 6a b9 5c f0 	movw   $0x8,0xf05cb96a
f010d042:	08 00 
f010d044:	a0 6c b9 5c f0       	mov    0xf05cb96c,%al
f010d049:	83 e0 e0             	and    $0xffffffe0,%eax
f010d04c:	a2 6c b9 5c f0       	mov    %al,0xf05cb96c
f010d051:	a0 6c b9 5c f0       	mov    0xf05cb96c,%al
f010d056:	83 e0 1f             	and    $0x1f,%eax
f010d059:	a2 6c b9 5c f0       	mov    %al,0xf05cb96c
f010d05e:	a0 6d b9 5c f0       	mov    0xf05cb96d,%al
f010d063:	83 e0 f0             	and    $0xfffffff0,%eax
f010d066:	83 c8 0e             	or     $0xe,%eax
f010d069:	a2 6d b9 5c f0       	mov    %al,0xf05cb96d
f010d06e:	a0 6d b9 5c f0       	mov    0xf05cb96d,%al
f010d073:	83 e0 ef             	and    $0xffffffef,%eax
f010d076:	a2 6d b9 5c f0       	mov    %al,0xf05cb96d
f010d07b:	a0 6d b9 5c f0       	mov    0xf05cb96d,%al
f010d080:	83 c8 60             	or     $0x60,%eax
f010d083:	a2 6d b9 5c f0       	mov    %al,0xf05cb96d
f010d088:	a0 6d b9 5c f0       	mov    0xf05cb96d,%al
f010d08d:	83 c8 80             	or     $0xffffff80,%eax
f010d090:	a2 6d b9 5c f0       	mov    %al,0xf05cb96d
f010d095:	b8 64 d7 10 f0       	mov    $0xf010d764,%eax
f010d09a:	c1 e8 10             	shr    $0x10,%eax
f010d09d:	66 a3 6e b9 5c f0    	mov    %ax,0xf05cb96e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010d0a3:	b8 6a d7 10 f0       	mov    $0xf010d76a,%eax
f010d0a8:	66 a3 70 b9 5c f0    	mov    %ax,0xf05cb970
f010d0ae:	66 c7 05 72 b9 5c f0 	movw   $0x8,0xf05cb972
f010d0b5:	08 00 
f010d0b7:	a0 74 b9 5c f0       	mov    0xf05cb974,%al
f010d0bc:	83 e0 e0             	and    $0xffffffe0,%eax
f010d0bf:	a2 74 b9 5c f0       	mov    %al,0xf05cb974
f010d0c4:	a0 74 b9 5c f0       	mov    0xf05cb974,%al
f010d0c9:	83 e0 1f             	and    $0x1f,%eax
f010d0cc:	a2 74 b9 5c f0       	mov    %al,0xf05cb974
f010d0d1:	a0 75 b9 5c f0       	mov    0xf05cb975,%al
f010d0d6:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0d9:	83 c8 0e             	or     $0xe,%eax
f010d0dc:	a2 75 b9 5c f0       	mov    %al,0xf05cb975
f010d0e1:	a0 75 b9 5c f0       	mov    0xf05cb975,%al
f010d0e6:	83 e0 ef             	and    $0xffffffef,%eax
f010d0e9:	a2 75 b9 5c f0       	mov    %al,0xf05cb975
f010d0ee:	a0 75 b9 5c f0       	mov    0xf05cb975,%al
f010d0f3:	83 c8 60             	or     $0x60,%eax
f010d0f6:	a2 75 b9 5c f0       	mov    %al,0xf05cb975
f010d0fb:	a0 75 b9 5c f0       	mov    0xf05cb975,%al
f010d100:	83 c8 80             	or     $0xffffff80,%eax
f010d103:	a2 75 b9 5c f0       	mov    %al,0xf05cb975
f010d108:	b8 6a d7 10 f0       	mov    $0xf010d76a,%eax
f010d10d:	c1 e8 10             	shr    $0x10,%eax
f010d110:	66 a3 76 b9 5c f0    	mov    %ax,0xf05cb976
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010d116:	b8 70 d7 10 f0       	mov    $0xf010d770,%eax
f010d11b:	66 a3 78 b9 5c f0    	mov    %ax,0xf05cb978
f010d121:	66 c7 05 7a b9 5c f0 	movw   $0x8,0xf05cb97a
f010d128:	08 00 
f010d12a:	a0 7c b9 5c f0       	mov    0xf05cb97c,%al
f010d12f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d132:	a2 7c b9 5c f0       	mov    %al,0xf05cb97c
f010d137:	a0 7c b9 5c f0       	mov    0xf05cb97c,%al
f010d13c:	83 e0 1f             	and    $0x1f,%eax
f010d13f:	a2 7c b9 5c f0       	mov    %al,0xf05cb97c
f010d144:	a0 7d b9 5c f0       	mov    0xf05cb97d,%al
f010d149:	83 e0 f0             	and    $0xfffffff0,%eax
f010d14c:	83 c8 0e             	or     $0xe,%eax
f010d14f:	a2 7d b9 5c f0       	mov    %al,0xf05cb97d
f010d154:	a0 7d b9 5c f0       	mov    0xf05cb97d,%al
f010d159:	83 e0 ef             	and    $0xffffffef,%eax
f010d15c:	a2 7d b9 5c f0       	mov    %al,0xf05cb97d
f010d161:	a0 7d b9 5c f0       	mov    0xf05cb97d,%al
f010d166:	83 c8 60             	or     $0x60,%eax
f010d169:	a2 7d b9 5c f0       	mov    %al,0xf05cb97d
f010d16e:	a0 7d b9 5c f0       	mov    0xf05cb97d,%al
f010d173:	83 c8 80             	or     $0xffffff80,%eax
f010d176:	a2 7d b9 5c f0       	mov    %al,0xf05cb97d
f010d17b:	b8 70 d7 10 f0       	mov    $0xf010d770,%eax
f010d180:	c1 e8 10             	shr    $0x10,%eax
f010d183:	66 a3 7e b9 5c f0    	mov    %ax,0xf05cb97e
f010d189:	c7 45 fc 00 b8 5c f0 	movl   $0xf05cb800,-0x4(%ebp)
f010d190:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010d197:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010d19a:	48                   	dec    %eax
f010d19b:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010d19f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d1a2:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010d1a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d1a9:	c1 e8 10             	shr    $0x10,%eax
f010d1ac:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010d1b0:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010d1b3:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010d1b6:	90                   	nop
f010d1b7:	c9                   	leave  
f010d1b8:	c3                   	ret    

f010d1b9 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010d1b9:	55                   	push   %ebp
f010d1ba:	89 e5                	mov    %esp,%ebp
f010d1bc:	53                   	push   %ebx
f010d1bd:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010d1c0:	83 ec 08             	sub    $0x8,%esp
f010d1c3:	ff 75 08             	pushl  0x8(%ebp)
f010d1c6:	68 7e 63 12 f0       	push   $0xf012637e
f010d1cb:	e8 bb 3d ff ff       	call   f0100f8b <cprintf>
f010d1d0:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010d1d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1d6:	83 ec 0c             	sub    $0xc,%esp
f010d1d9:	50                   	push   %eax
f010d1da:	e8 fd 00 00 00       	call   f010d2dc <print_regs>
f010d1df:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010d1e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1e5:	8b 40 20             	mov    0x20(%eax),%eax
f010d1e8:	0f b7 c0             	movzwl %ax,%eax
f010d1eb:	83 ec 08             	sub    $0x8,%esp
f010d1ee:	50                   	push   %eax
f010d1ef:	68 90 63 12 f0       	push   $0xf0126390
f010d1f4:	e8 92 3d ff ff       	call   f0100f8b <cprintf>
f010d1f9:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010d1fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1ff:	8b 40 24             	mov    0x24(%eax),%eax
f010d202:	0f b7 c0             	movzwl %ax,%eax
f010d205:	83 ec 08             	sub    $0x8,%esp
f010d208:	50                   	push   %eax
f010d209:	68 a3 63 12 f0       	push   $0xf01263a3
f010d20e:	e8 78 3d ff ff       	call   f0100f8b <cprintf>
f010d213:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010d216:	8b 45 08             	mov    0x8(%ebp),%eax
f010d219:	8b 58 28             	mov    0x28(%eax),%ebx
f010d21c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d21f:	8b 40 28             	mov    0x28(%eax),%eax
f010d222:	83 ec 0c             	sub    $0xc,%esp
f010d225:	50                   	push   %eax
f010d226:	e8 28 ee ff ff       	call   f010c053 <trapname>
f010d22b:	83 c4 10             	add    $0x10,%esp
f010d22e:	89 c2                	mov    %eax,%edx
f010d230:	8b 45 08             	mov    0x8(%ebp),%eax
f010d233:	8b 40 28             	mov    0x28(%eax),%eax
f010d236:	53                   	push   %ebx
f010d237:	52                   	push   %edx
f010d238:	50                   	push   %eax
f010d239:	68 b6 63 12 f0       	push   $0xf01263b6
f010d23e:	e8 48 3d ff ff       	call   f0100f8b <cprintf>
f010d243:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010d246:	8b 45 08             	mov    0x8(%ebp),%eax
f010d249:	8b 40 2c             	mov    0x2c(%eax),%eax
f010d24c:	83 ec 08             	sub    $0x8,%esp
f010d24f:	50                   	push   %eax
f010d250:	68 cd 63 12 f0       	push   $0xf01263cd
f010d255:	e8 31 3d ff ff       	call   f0100f8b <cprintf>
f010d25a:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010d25d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d260:	8b 40 30             	mov    0x30(%eax),%eax
f010d263:	83 ec 08             	sub    $0x8,%esp
f010d266:	50                   	push   %eax
f010d267:	68 dc 63 12 f0       	push   $0xf01263dc
f010d26c:	e8 1a 3d ff ff       	call   f0100f8b <cprintf>
f010d271:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010d274:	8b 45 08             	mov    0x8(%ebp),%eax
f010d277:	8b 40 34             	mov    0x34(%eax),%eax
f010d27a:	0f b7 c0             	movzwl %ax,%eax
f010d27d:	83 ec 08             	sub    $0x8,%esp
f010d280:	50                   	push   %eax
f010d281:	68 eb 63 12 f0       	push   $0xf01263eb
f010d286:	e8 00 3d ff ff       	call   f0100f8b <cprintf>
f010d28b:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010d28e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d291:	8b 40 38             	mov    0x38(%eax),%eax
f010d294:	83 ec 08             	sub    $0x8,%esp
f010d297:	50                   	push   %eax
f010d298:	68 fe 63 12 f0       	push   $0xf01263fe
f010d29d:	e8 e9 3c ff ff       	call   f0100f8b <cprintf>
f010d2a2:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010d2a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2a8:	8b 40 3c             	mov    0x3c(%eax),%eax
f010d2ab:	83 ec 08             	sub    $0x8,%esp
f010d2ae:	50                   	push   %eax
f010d2af:	68 0d 64 12 f0       	push   $0xf012640d
f010d2b4:	e8 d2 3c ff ff       	call   f0100f8b <cprintf>
f010d2b9:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010d2bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2bf:	8b 40 40             	mov    0x40(%eax),%eax
f010d2c2:	0f b7 c0             	movzwl %ax,%eax
f010d2c5:	83 ec 08             	sub    $0x8,%esp
f010d2c8:	50                   	push   %eax
f010d2c9:	68 1c 64 12 f0       	push   $0xf012641c
f010d2ce:	e8 b8 3c ff ff       	call   f0100f8b <cprintf>
f010d2d3:	83 c4 10             	add    $0x10,%esp
}
f010d2d6:	90                   	nop
f010d2d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010d2da:	c9                   	leave  
f010d2db:	c3                   	ret    

f010d2dc <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010d2dc:	55                   	push   %ebp
f010d2dd:	89 e5                	mov    %esp,%ebp
f010d2df:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010d2e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2e5:	8b 00                	mov    (%eax),%eax
f010d2e7:	83 ec 08             	sub    $0x8,%esp
f010d2ea:	50                   	push   %eax
f010d2eb:	68 2f 64 12 f0       	push   $0xf012642f
f010d2f0:	e8 96 3c ff ff       	call   f0100f8b <cprintf>
f010d2f5:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010d2f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2fb:	8b 40 04             	mov    0x4(%eax),%eax
f010d2fe:	83 ec 08             	sub    $0x8,%esp
f010d301:	50                   	push   %eax
f010d302:	68 3e 64 12 f0       	push   $0xf012643e
f010d307:	e8 7f 3c ff ff       	call   f0100f8b <cprintf>
f010d30c:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010d30f:	8b 45 08             	mov    0x8(%ebp),%eax
f010d312:	8b 40 08             	mov    0x8(%eax),%eax
f010d315:	83 ec 08             	sub    $0x8,%esp
f010d318:	50                   	push   %eax
f010d319:	68 4d 64 12 f0       	push   $0xf012644d
f010d31e:	e8 68 3c ff ff       	call   f0100f8b <cprintf>
f010d323:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010d326:	8b 45 08             	mov    0x8(%ebp),%eax
f010d329:	8b 40 0c             	mov    0xc(%eax),%eax
f010d32c:	83 ec 08             	sub    $0x8,%esp
f010d32f:	50                   	push   %eax
f010d330:	68 5c 64 12 f0       	push   $0xf012645c
f010d335:	e8 51 3c ff ff       	call   f0100f8b <cprintf>
f010d33a:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010d33d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d340:	8b 40 10             	mov    0x10(%eax),%eax
f010d343:	83 ec 08             	sub    $0x8,%esp
f010d346:	50                   	push   %eax
f010d347:	68 6b 64 12 f0       	push   $0xf012646b
f010d34c:	e8 3a 3c ff ff       	call   f0100f8b <cprintf>
f010d351:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010d354:	8b 45 08             	mov    0x8(%ebp),%eax
f010d357:	8b 40 14             	mov    0x14(%eax),%eax
f010d35a:	83 ec 08             	sub    $0x8,%esp
f010d35d:	50                   	push   %eax
f010d35e:	68 7a 64 12 f0       	push   $0xf012647a
f010d363:	e8 23 3c ff ff       	call   f0100f8b <cprintf>
f010d368:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010d36b:	8b 45 08             	mov    0x8(%ebp),%eax
f010d36e:	8b 40 18             	mov    0x18(%eax),%eax
f010d371:	83 ec 08             	sub    $0x8,%esp
f010d374:	50                   	push   %eax
f010d375:	68 89 64 12 f0       	push   $0xf0126489
f010d37a:	e8 0c 3c ff ff       	call   f0100f8b <cprintf>
f010d37f:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010d382:	8b 45 08             	mov    0x8(%ebp),%eax
f010d385:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d388:	83 ec 08             	sub    $0x8,%esp
f010d38b:	50                   	push   %eax
f010d38c:	68 98 64 12 f0       	push   $0xf0126498
f010d391:	e8 f5 3b ff ff       	call   f0100f8b <cprintf>
f010d396:	83 c4 10             	add    $0x10,%esp
}
f010d399:	90                   	nop
f010d39a:	c9                   	leave  
f010d39b:	c3                   	ret    

f010d39c <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010d39c:	55                   	push   %ebp
f010d39d:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010d39f:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3a2:	8b 55 0c             	mov    0xc(%ebp),%edx
f010d3a5:	89 14 85 00 c0 5c f0 	mov    %edx,-0xfa34000(,%eax,4)
}
f010d3ac:	90                   	nop
f010d3ad:	5d                   	pop    %ebp
f010d3ae:	c3                   	ret    

f010d3af <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010d3af:	55                   	push   %ebp
f010d3b0:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010d3b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3b5:	c7 04 85 00 c0 5c f0 	movl   $0x0,-0xfa34000(,%eax,4)
f010d3bc:	00 00 00 00 
}
f010d3c0:	90                   	nop
f010d3c1:	5d                   	pop    %ebp
f010d3c2:	c3                   	ret    

f010d3c3 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010d3c3:	55                   	push   %ebp
f010d3c4:	89 e5                	mov    %esp,%ebp
f010d3c6:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010d3c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3cc:	8b 40 28             	mov    0x28(%eax),%eax
f010d3cf:	83 e8 20             	sub    $0x20,%eax
f010d3d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010d3d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3d8:	8b 04 85 00 c0 5c f0 	mov    -0xfa34000(,%eax,4),%eax
f010d3df:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010d3e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d3e6:	74 0e                	je     f010d3f6 <irq_dispatch+0x33>
	{
		handler(tf);
f010d3e8:	83 ec 0c             	sub    $0xc,%esp
f010d3eb:	ff 75 08             	pushl  0x8(%ebp)
f010d3ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d3f1:	ff d0                	call   *%eax
f010d3f3:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010d3f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3f9:	0f b6 c0             	movzbl %al,%eax
f010d3fc:	83 ec 0c             	sub    $0xc,%esp
f010d3ff:	50                   	push   %eax
f010d400:	e8 63 9c ff ff       	call   f0107068 <pic_sendEOI>
f010d405:	83 c4 10             	add    $0x10,%esp
}
f010d408:	90                   	nop
f010d409:	c9                   	leave  
f010d40a:	c3                   	ret    

f010d40b <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010d40b:	55                   	push   %ebp
f010d40c:	89 e5                	mov    %esp,%ebp
f010d40e:	57                   	push   %edi
f010d40f:	56                   	push   %esi
f010d410:	53                   	push   %ebx
f010d411:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010d414:	8b 45 08             	mov    0x8(%ebp),%eax
f010d417:	8b 40 28             	mov    0x28(%eax),%eax
f010d41a:	83 f8 0e             	cmp    $0xe,%eax
f010d41d:	75 51                	jne    f010d470 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010d41f:	a0 40 c0 5c f0       	mov    0xf05cc040,%al
f010d424:	84 c0                	test   %al,%al
f010d426:	74 1f                	je     f010d447 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010d428:	8b 45 08             	mov    0x8(%ebp),%eax
f010d42b:	8b 40 30             	mov    0x30(%eax),%eax
f010d42e:	89 c2                	mov    %eax,%edx
f010d430:	a0 40 c0 5c f0       	mov    0xf05cc040,%al
f010d435:	0f b6 c0             	movzbl %al,%eax
f010d438:	01 d0                	add    %edx,%eax
f010d43a:	89 c2                	mov    %eax,%edx
f010d43c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d43f:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010d442:	e9 0c 01 00 00       	jmp    f010d553 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010d447:	83 ec 0c             	sub    $0xc,%esp
f010d44a:	6a 01                	push   $0x1
f010d44c:	e8 da 12 00 00       	call   f010e72b <isPageReplacmentAlgorithmLRU>
f010d451:	83 c4 10             	add    $0x10,%esp
f010d454:	85 c0                	test   %eax,%eax
f010d456:	74 05                	je     f010d45d <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010d458:	e8 7a 97 ff ff       	call   f0106bd7 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010d45d:	83 ec 0c             	sub    $0xc,%esp
f010d460:	ff 75 08             	pushl  0x8(%ebp)
f010d463:	e8 a8 13 00 00       	call   f010e810 <fault_handler>
f010d468:	83 c4 10             	add    $0x10,%esp
f010d46b:	e9 e3 00 00 00       	jmp    f010d553 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010d470:	8b 45 08             	mov    0x8(%ebp),%eax
f010d473:	8b 40 28             	mov    0x28(%eax),%eax
f010d476:	83 f8 30             	cmp    $0x30,%eax
f010d479:	75 6e                	jne    f010d4e9 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010d47b:	8b 45 08             	mov    0x8(%ebp),%eax
f010d47e:	8b 40 38             	mov    0x38(%eax),%eax
f010d481:	25 00 02 00 00       	and    $0x200,%eax
f010d486:	85 c0                	test   %eax,%eax
f010d488:	74 06                	je     f010d490 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010d48a:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010d48b:	e8 f0 77 ff ff       	call   f0104c80 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010d490:	8b 45 08             	mov    0x8(%ebp),%eax
f010d493:	8b 78 04             	mov    0x4(%eax),%edi
f010d496:	8b 45 08             	mov    0x8(%ebp),%eax
f010d499:	8b 30                	mov    (%eax),%esi
f010d49b:	8b 45 08             	mov    0x8(%ebp),%eax
f010d49e:	8b 58 10             	mov    0x10(%eax),%ebx
f010d4a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4a4:	8b 48 18             	mov    0x18(%eax),%ecx
f010d4a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4aa:	8b 50 14             	mov    0x14(%eax),%edx
f010d4ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4b0:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d4b3:	83 ec 08             	sub    $0x8,%esp
f010d4b6:	57                   	push   %edi
f010d4b7:	56                   	push   %esi
f010d4b8:	53                   	push   %ebx
f010d4b9:	51                   	push   %ecx
f010d4ba:	52                   	push   %edx
f010d4bb:	50                   	push   %eax
f010d4bc:	e8 91 09 00 00       	call   f010de52 <syscall>
f010d4c1:	83 c4 20             	add    $0x20,%esp
f010d4c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010d4c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4ca:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d4cd:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d4d0:	9c                   	pushf  
f010d4d1:	58                   	pop    %eax
f010d4d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010d4d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010d4d8:	25 00 02 00 00       	and    $0x200,%eax
f010d4dd:	85 c0                	test   %eax,%eax
f010d4df:	74 72                	je     f010d553 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010d4e1:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010d4e2:	e8 71 77 ff ff       	call   f0104c58 <kclock_stop>
f010d4e7:	eb 6a                	jmp    f010d553 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010d4e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4ec:	8b 40 28             	mov    0x28(%eax),%eax
f010d4ef:	83 f8 08             	cmp    $0x8,%eax
f010d4f2:	75 17                	jne    f010d50b <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010d4f4:	83 ec 04             	sub    $0x4,%esp
f010d4f7:	68 a7 64 12 f0       	push   $0xf01264a7
f010d4fc:	68 22 01 00 00       	push   $0x122
f010d501:	68 b6 64 12 f0       	push   $0xf01264b6
f010d506:	e8 2e 2e ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010d50b:	83 ec 0c             	sub    $0xc,%esp
f010d50e:	ff 75 08             	pushl  0x8(%ebp)
f010d511:	e8 a3 fc ff ff       	call   f010d1b9 <print_trapframe>
f010d516:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010d519:	8b 45 08             	mov    0x8(%ebp),%eax
f010d51c:	8b 40 34             	mov    0x34(%eax),%eax
f010d51f:	66 83 f8 08          	cmp    $0x8,%ax
f010d523:	75 17                	jne    f010d53c <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010d525:	83 ec 04             	sub    $0x4,%esp
f010d528:	68 c7 64 12 f0       	push   $0xf01264c7
f010d52d:	68 2a 01 00 00       	push   $0x12a
f010d532:	68 b6 64 12 f0       	push   $0xf01264b6
f010d537:	e8 fd 2d ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010d53c:	83 ec 04             	sub    $0x4,%esp
f010d53f:	68 e0 64 12 f0       	push   $0xf01264e0
f010d544:	68 2f 01 00 00       	push   $0x12f
f010d549:	68 b6 64 12 f0       	push   $0xf01264b6
f010d54e:	e8 e6 2d ff ff       	call   f0100339 <_panic>
		}
	}
}
f010d553:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010d556:	5b                   	pop    %ebx
f010d557:	5e                   	pop    %esi
f010d558:	5f                   	pop    %edi
f010d559:	5d                   	pop    %ebp
f010d55a:	c3                   	ret    

f010d55b <trap>:

void trap(struct Trapframe *tf)
{
f010d55b:	55                   	push   %ebp
f010d55c:	89 e5                	mov    %esp,%ebp
f010d55e:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010d561:	e8 f2 76 ff ff       	call   f0104c58 <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d566:	9c                   	pushf  
f010d567:	58                   	pop    %eax
f010d568:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010d56b:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010d56e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010d571:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d574:	25 00 02 00 00       	and    $0x200,%eax
f010d579:	85 c0                	test   %eax,%eax
f010d57b:	74 25                	je     f010d5a2 <trap+0x47>
	{
		print_trapframe(tf);
f010d57d:	83 ec 0c             	sub    $0xc,%esp
f010d580:	ff 75 08             	pushl  0x8(%ebp)
f010d583:	e8 31 fc ff ff       	call   f010d1b9 <print_trapframe>
f010d588:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010d58b:	83 ec 04             	sub    $0x4,%esp
f010d58e:	68 00 65 12 f0       	push   $0xf0126500
f010d593:	68 45 01 00 00       	push   $0x145
f010d598:	68 b6 64 12 f0       	push   $0xf01264b6
f010d59d:	e8 97 2d ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010d5a2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010d5a9:	e8 5d d6 ff ff       	call   f010ac0b <get_cpu_proc>
f010d5ae:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010d5b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010d5b4:	8b 40 34             	mov    0x34(%eax),%eax
f010d5b7:	0f b7 c0             	movzwl %ax,%eax
f010d5ba:	83 e0 03             	and    $0x3,%eax
f010d5bd:	83 f8 03             	cmp    $0x3,%eax
f010d5c0:	75 54                	jne    f010d616 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010d5c2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010d5c6:	74 0b                	je     f010d5d3 <trap+0x78>
f010d5c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d5cb:	8b 40 18             	mov    0x18(%eax),%eax
f010d5ce:	83 f8 02             	cmp    $0x2,%eax
f010d5d1:	74 19                	je     f010d5ec <trap+0x91>
f010d5d3:	68 44 65 12 f0       	push   $0xf0126544
f010d5d8:	68 72 65 12 f0       	push   $0xf0126572
f010d5dd:	68 4d 01 00 00       	push   $0x14d
f010d5e2:	68 b6 64 12 f0       	push   $0xf01264b6
f010d5e7:	e8 4d 2d ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010d5ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d5ef:	8b 00                	mov    (%eax),%eax
f010d5f1:	3b 45 08             	cmp    0x8(%ebp),%eax
f010d5f4:	74 19                	je     f010d60f <trap+0xb4>
f010d5f6:	68 87 65 12 f0       	push   $0xf0126587
f010d5fb:	68 72 65 12 f0       	push   $0xf0126572
f010d600:	68 4f 01 00 00       	push   $0x14f
f010d605:	68 b6 64 12 f0       	push   $0xf01264b6
f010d60a:	e8 2a 2d ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010d60f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010d616:	8b 45 08             	mov    0x8(%ebp),%eax
f010d619:	8b 40 28             	mov    0x28(%eax),%eax
f010d61c:	83 f8 1f             	cmp    $0x1f,%eax
f010d61f:	76 1b                	jbe    f010d63c <trap+0xe1>
f010d621:	8b 45 08             	mov    0x8(%ebp),%eax
f010d624:	8b 40 28             	mov    0x28(%eax),%eax
f010d627:	83 f8 2f             	cmp    $0x2f,%eax
f010d62a:	77 10                	ja     f010d63c <trap+0xe1>
	{
		irq_dispatch(tf);
f010d62c:	83 ec 0c             	sub    $0xc,%esp
f010d62f:	ff 75 08             	pushl  0x8(%ebp)
f010d632:	e8 8c fd ff ff       	call   f010d3c3 <irq_dispatch>
f010d637:	83 c4 10             	add    $0x10,%esp
f010d63a:	eb 0e                	jmp    f010d64a <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010d63c:	83 ec 0c             	sub    $0xc,%esp
f010d63f:	ff 75 08             	pushl  0x8(%ebp)
f010d642:	e8 c4 fd ff ff       	call   f010d40b <trap_dispatch>
f010d647:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d64a:	9c                   	pushf  
f010d64b:	58                   	pop    %eax
f010d64c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010d64f:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010d652:	25 00 02 00 00       	and    $0x200,%eax
f010d657:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010d65a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010d65e:	74 19                	je     f010d679 <trap+0x11e>
f010d660:	68 9d 65 12 f0       	push   $0xf012659d
f010d665:	68 72 65 12 f0       	push   $0xf0126572
f010d66a:	68 66 01 00 00       	push   $0x166
f010d66f:	68 b6 64 12 f0       	push   $0xf01264b6
f010d674:	e8 c0 2c ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010d679:	e8 02 76 ff ff       	call   f0104c80 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010d67e:	90                   	nop
f010d67f:	c9                   	leave  
f010d680:	c3                   	ret    
f010d681:	90                   	nop

f010d682 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010d682:	6a 08                	push   $0x8
f010d684:	e9 ed 00 00 00       	jmp    f010d776 <_alltraps>
f010d689:	90                   	nop

f010d68a <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010d68a:	6a 0e                	push   $0xe
f010d68c:	e9 e5 00 00 00       	jmp    f010d776 <_alltraps>
f010d691:	90                   	nop

f010d692 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010d692:	6a 00                	push   $0x0
f010d694:	6a 20                	push   $0x20
f010d696:	e9 db 00 00 00       	jmp    f010d776 <_alltraps>
f010d69b:	90                   	nop

f010d69c <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010d69c:	6a 00                	push   $0x0
f010d69e:	6a 21                	push   $0x21
f010d6a0:	e9 d1 00 00 00       	jmp    f010d776 <_alltraps>
f010d6a5:	90                   	nop

f010d6a6 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010d6a6:	6a 00                	push   $0x0
f010d6a8:	6a 30                	push   $0x30
f010d6aa:	e9 c7 00 00 00       	jmp    f010d776 <_alltraps>
f010d6af:	90                   	nop

f010d6b0 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010d6b0:	6a 00                	push   $0x0
f010d6b2:	6a 00                	push   $0x0
f010d6b4:	e9 bd 00 00 00       	jmp    f010d776 <_alltraps>
f010d6b9:	90                   	nop

f010d6ba <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010d6ba:	6a 00                	push   $0x0
f010d6bc:	6a 01                	push   $0x1
f010d6be:	e9 b3 00 00 00       	jmp    f010d776 <_alltraps>
f010d6c3:	90                   	nop

f010d6c4 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010d6c4:	6a 00                	push   $0x0
f010d6c6:	6a 02                	push   $0x2
f010d6c8:	e9 a9 00 00 00       	jmp    f010d776 <_alltraps>
f010d6cd:	90                   	nop

f010d6ce <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010d6ce:	6a 00                	push   $0x0
f010d6d0:	6a 03                	push   $0x3
f010d6d2:	e9 9f 00 00 00       	jmp    f010d776 <_alltraps>
f010d6d7:	90                   	nop

f010d6d8 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010d6d8:	6a 00                	push   $0x0
f010d6da:	6a 04                	push   $0x4
f010d6dc:	e9 95 00 00 00       	jmp    f010d776 <_alltraps>
f010d6e1:	90                   	nop

f010d6e2 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010d6e2:	6a 00                	push   $0x0
f010d6e4:	6a 05                	push   $0x5
f010d6e6:	e9 8b 00 00 00       	jmp    f010d776 <_alltraps>
f010d6eb:	90                   	nop

f010d6ec <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010d6ec:	6a 00                	push   $0x0
f010d6ee:	6a 06                	push   $0x6
f010d6f0:	e9 81 00 00 00       	jmp    f010d776 <_alltraps>
f010d6f5:	90                   	nop

f010d6f6 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010d6f6:	6a 00                	push   $0x0
f010d6f8:	6a 07                	push   $0x7
f010d6fa:	eb 7a                	jmp    f010d776 <_alltraps>

f010d6fc <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010d6fc:	6a 0a                	push   $0xa
f010d6fe:	eb 76                	jmp    f010d776 <_alltraps>

f010d700 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010d700:	6a 0b                	push   $0xb
f010d702:	eb 72                	jmp    f010d776 <_alltraps>

f010d704 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010d704:	6a 0c                	push   $0xc
f010d706:	eb 6e                	jmp    f010d776 <_alltraps>

f010d708 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010d708:	6a 0d                	push   $0xd
f010d70a:	eb 6a                	jmp    f010d776 <_alltraps>

f010d70c <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010d70c:	6a 00                	push   $0x0
f010d70e:	6a 10                	push   $0x10
f010d710:	eb 64                	jmp    f010d776 <_alltraps>

f010d712 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010d712:	6a 11                	push   $0x11
f010d714:	eb 60                	jmp    f010d776 <_alltraps>

f010d716 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010d716:	6a 00                	push   $0x0
f010d718:	6a 12                	push   $0x12
f010d71a:	eb 5a                	jmp    f010d776 <_alltraps>

f010d71c <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010d71c:	6a 00                	push   $0x0
f010d71e:	6a 13                	push   $0x13
f010d720:	eb 54                	jmp    f010d776 <_alltraps>

f010d722 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010d722:	6a 00                	push   $0x0
f010d724:	6a 22                	push   $0x22
f010d726:	eb 4e                	jmp    f010d776 <_alltraps>

f010d728 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010d728:	6a 00                	push   $0x0
f010d72a:	6a 23                	push   $0x23
f010d72c:	eb 48                	jmp    f010d776 <_alltraps>

f010d72e <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010d72e:	6a 00                	push   $0x0
f010d730:	6a 24                	push   $0x24
f010d732:	eb 42                	jmp    f010d776 <_alltraps>

f010d734 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010d734:	6a 00                	push   $0x0
f010d736:	6a 25                	push   $0x25
f010d738:	eb 3c                	jmp    f010d776 <_alltraps>

f010d73a <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010d73a:	6a 00                	push   $0x0
f010d73c:	6a 26                	push   $0x26
f010d73e:	eb 36                	jmp    f010d776 <_alltraps>

f010d740 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010d740:	6a 00                	push   $0x0
f010d742:	6a 27                	push   $0x27
f010d744:	eb 30                	jmp    f010d776 <_alltraps>

f010d746 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010d746:	6a 00                	push   $0x0
f010d748:	6a 28                	push   $0x28
f010d74a:	eb 2a                	jmp    f010d776 <_alltraps>

f010d74c <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010d74c:	6a 00                	push   $0x0
f010d74e:	6a 29                	push   $0x29
f010d750:	eb 24                	jmp    f010d776 <_alltraps>

f010d752 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010d752:	6a 00                	push   $0x0
f010d754:	6a 2a                	push   $0x2a
f010d756:	eb 1e                	jmp    f010d776 <_alltraps>

f010d758 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010d758:	6a 00                	push   $0x0
f010d75a:	6a 2b                	push   $0x2b
f010d75c:	eb 18                	jmp    f010d776 <_alltraps>

f010d75e <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010d75e:	6a 00                	push   $0x0
f010d760:	6a 2c                	push   $0x2c
f010d762:	eb 12                	jmp    f010d776 <_alltraps>

f010d764 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010d764:	6a 00                	push   $0x0
f010d766:	6a 2d                	push   $0x2d
f010d768:	eb 0c                	jmp    f010d776 <_alltraps>

f010d76a <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010d76a:	6a 00                	push   $0x0
f010d76c:	6a 2e                	push   $0x2e
f010d76e:	eb 06                	jmp    f010d776 <_alltraps>

f010d770 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010d770:	6a 00                	push   $0x0
f010d772:	6a 2f                	push   $0x2f
f010d774:	eb 00                	jmp    f010d776 <_alltraps>

f010d776 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010d776:	1e                   	push   %ds
push 	%es
f010d777:	06                   	push   %es
pushal
f010d778:	60                   	pusha  

mov 	$(GD_KD), %ax
f010d779:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010d77d:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010d77f:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010d781:	54                   	push   %esp
call 	trap
f010d782:	e8 d4 fd ff ff       	call   f010d55b <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010d787:	59                   	pop    %ecx

f010d788 <trapret>:
.globl trapret
trapret:
popal
f010d788:	61                   	popa   
pop 	%es
f010d789:	07                   	pop    %es
pop 	%ds
f010d78a:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010d78b:	83 c4 08             	add    $0x8,%esp
iret
f010d78e:	cf                   	iret   

f010d78f <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010d78f:	55                   	push   %ebp
f010d790:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010d792:	8b 45 08             	mov    0x8(%ebp),%eax
f010d795:	8b 15 c0 47 5f f0    	mov    0xf05f47c0,%edx
f010d79b:	29 d0                	sub    %edx,%eax
f010d79d:	c1 f8 03             	sar    $0x3,%eax
f010d7a0:	89 c2                	mov    %eax,%edx
f010d7a2:	89 d0                	mov    %edx,%eax
f010d7a4:	c1 e0 02             	shl    $0x2,%eax
f010d7a7:	01 d0                	add    %edx,%eax
f010d7a9:	c1 e0 02             	shl    $0x2,%eax
f010d7ac:	01 d0                	add    %edx,%eax
f010d7ae:	c1 e0 02             	shl    $0x2,%eax
f010d7b1:	01 d0                	add    %edx,%eax
f010d7b3:	89 c1                	mov    %eax,%ecx
f010d7b5:	c1 e1 08             	shl    $0x8,%ecx
f010d7b8:	01 c8                	add    %ecx,%eax
f010d7ba:	89 c1                	mov    %eax,%ecx
f010d7bc:	c1 e1 10             	shl    $0x10,%ecx
f010d7bf:	01 c8                	add    %ecx,%eax
f010d7c1:	01 c0                	add    %eax,%eax
f010d7c3:	01 d0                	add    %edx,%eax
}
f010d7c5:	5d                   	pop    %ebp
f010d7c6:	c3                   	ret    

f010d7c7 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010d7c7:	55                   	push   %ebp
f010d7c8:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010d7ca:	ff 75 08             	pushl  0x8(%ebp)
f010d7cd:	e8 bd ff ff ff       	call   f010d78f <to_frame_number>
f010d7d2:	83 c4 04             	add    $0x4,%esp
f010d7d5:	c1 e0 0c             	shl    $0xc,%eax
}
f010d7d8:	c9                   	leave  
f010d7d9:	c3                   	ret    

f010d7da <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010d7da:	55                   	push   %ebp
f010d7db:	89 e5                	mov    %esp,%ebp
f010d7dd:	83 ec 18             	sub    $0x18,%esp
f010d7e0:	8b 45 10             	mov    0x10(%ebp),%eax
f010d7e3:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010d7e6:	e8 79 99 ff ff       	call   f0107164 <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010d7eb:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010d7ef:	74 23                	je     f010d814 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010d7f1:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010d7f6:	8b 40 10             	mov    0x10(%eax),%eax
f010d7f9:	8b 15 84 2f 61 f0    	mov    0xf0612f84,%edx
f010d7ff:	83 c2 20             	add    $0x20,%edx
f010d802:	83 ec 04             	sub    $0x4,%esp
f010d805:	50                   	push   %eax
f010d806:	52                   	push   %edx
f010d807:	68 50 67 12 f0       	push   $0xf0126750
f010d80c:	e8 7a 37 ff ff       	call   f0100f8b <cprintf>
f010d811:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010d814:	83 ec 04             	sub    $0x4,%esp
f010d817:	ff 75 08             	pushl  0x8(%ebp)
f010d81a:	ff 75 0c             	pushl  0xc(%ebp)
f010d81d:	68 59 67 12 f0       	push   $0xf0126759
f010d822:	e8 64 37 ff ff       	call   f0100f8b <cprintf>
f010d827:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010d82a:	e8 87 99 ff ff       	call   f01071b6 <popcli>
}
f010d82f:	90                   	nop
f010d830:	c9                   	leave  
f010d831:	c3                   	ret    

f010d832 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010d832:	55                   	push   %ebp
f010d833:	89 e5                	mov    %esp,%ebp
f010d835:	83 ec 18             	sub    $0x18,%esp
f010d838:	8b 45 08             	mov    0x8(%ebp),%eax
f010d83b:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010d83e:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010d842:	83 ec 08             	sub    $0x8,%esp
f010d845:	50                   	push   %eax
f010d846:	68 5e 67 12 f0       	push   $0xf012675e
f010d84b:	e8 3b 37 ff ff       	call   f0100f8b <cprintf>
f010d850:	83 c4 10             	add    $0x10,%esp
}
f010d853:	90                   	nop
f010d854:	c9                   	leave  
f010d855:	c3                   	ret    

f010d856 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010d856:	55                   	push   %ebp
f010d857:	89 e5                	mov    %esp,%ebp
f010d859:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d85c:	9c                   	pushf  
f010d85d:	58                   	pop    %eax
f010d85e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010d861:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010d864:	25 00 02 00 00       	and    $0x200,%eax
f010d869:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010d86c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d870:	74 10                	je     f010d882 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010d872:	e8 4d 35 ff ff       	call   f0100dc4 <cons_getc2>
f010d877:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d87a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d87e:	74 f2                	je     f010d872 <sys_cgetc+0x1c>
f010d880:	eb 0e                	jmp    f010d890 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010d882:	e8 e2 34 ff ff       	call   f0100d69 <cons_getc>
f010d887:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d88a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d88e:	74 f2                	je     f010d882 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010d890:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d893:	c9                   	leave  
f010d894:	c3                   	ret    

f010d895 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010d895:	55                   	push   %ebp
f010d896:	89 e5                	mov    %esp,%ebp
f010d898:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010d89b:	e8 10 36 ff ff       	call   f0100eb0 <cons_lock>
}
f010d8a0:	90                   	nop
f010d8a1:	c9                   	leave  
f010d8a2:	c3                   	ret    

f010d8a3 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010d8a3:	55                   	push   %ebp
f010d8a4:	89 e5                	mov    %esp,%ebp
f010d8a6:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010d8a9:	e8 49 36 ff ff       	call   f0100ef7 <cons_unlock>
}
f010d8ae:	90                   	nop
f010d8af:	c9                   	leave  
f010d8b0:	c3                   	ret    

f010d8b1 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010d8b1:	55                   	push   %ebp
f010d8b2:	89 e5                	mov    %esp,%ebp
f010d8b4:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010d8b7:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010d8bc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010d8bf:	83 ec 0c             	sub    $0xc,%esp
f010d8c2:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010d8c5:	50                   	push   %eax
f010d8c6:	e8 7c a8 ff ff       	call   f0108147 <allocate_frame>
f010d8cb:	83 c4 10             	add    $0x10,%esp
f010d8ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d8d1:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d8d5:	75 08                	jne    f010d8df <__sys_allocate_page+0x2e>
		return r ;
f010d8d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d8da:	e9 e9 00 00 00       	jmp    f010d9c8 <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010d8df:	8b 45 08             	mov    0x8(%ebp),%eax
f010d8e2:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010d8e7:	77 0c                	ja     f010d8f5 <__sys_allocate_page+0x44>
f010d8e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d8ec:	25 ff 0f 00 00       	and    $0xfff,%eax
f010d8f1:	85 c0                	test   %eax,%eax
f010d8f3:	74 0a                	je     f010d8ff <__sys_allocate_page+0x4e>
		return E_INVAL;
f010d8f5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d8fa:	e9 c9 00 00 00       	jmp    f010d9c8 <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010d8ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d902:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010d907:	83 f8 04             	cmp    $0x4,%eax
f010d90a:	74 0a                	je     f010d916 <__sys_allocate_page+0x65>
		return E_INVAL;
f010d90c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d911:	e9 b2 00 00 00       	jmp    f010d9c8 <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010d916:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d919:	83 ec 0c             	sub    $0xc,%esp
f010d91c:	50                   	push   %eax
f010d91d:	e8 a5 fe ff ff       	call   f010d7c7 <to_physical_address>
f010d922:	83 c4 10             	add    $0x10,%esp
f010d925:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010d928:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d92b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d92e:	8b 40 64             	mov    0x64(%eax),%eax
f010d931:	6a 02                	push   $0x2
f010d933:	68 00 00 80 ef       	push   $0xef800000
f010d938:	52                   	push   %edx
f010d939:	50                   	push   %eax
f010d93a:	e8 d5 ac ff ff       	call   f0108614 <map_frame>
f010d93f:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010d942:	83 ec 04             	sub    $0x4,%esp
f010d945:	68 00 10 00 00       	push   $0x1000
f010d94a:	6a 00                	push   $0x0
f010d94c:	68 00 00 80 ef       	push   $0xef800000
f010d951:	e8 e5 13 01 00       	call   f011ed3b <memset>
f010d956:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010d959:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d95c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d95f:	8b 40 08             	mov    0x8(%eax),%eax
f010d962:	40                   	inc    %eax
f010d963:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010d967:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d96a:	8b 40 64             	mov    0x64(%eax),%eax
f010d96d:	83 ec 08             	sub    $0x8,%esp
f010d970:	68 00 00 80 ef       	push   $0xef800000
f010d975:	50                   	push   %eax
f010d976:	e8 f9 ad ff ff       	call   f0108774 <unmap_frame>
f010d97b:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010d97e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d981:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d984:	8b 40 08             	mov    0x8(%eax),%eax
f010d987:	48                   	dec    %eax
f010d988:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010d98c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010d98f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d992:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d995:	8b 40 64             	mov    0x64(%eax),%eax
f010d998:	ff 75 0c             	pushl  0xc(%ebp)
f010d99b:	51                   	push   %ecx
f010d99c:	52                   	push   %edx
f010d99d:	50                   	push   %eax
f010d99e:	e8 71 ac ff ff       	call   f0108614 <map_frame>
f010d9a3:	83 c4 10             	add    $0x10,%esp
f010d9a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d9a9:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d9ad:	75 14                	jne    f010d9c3 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010d9af:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d9b2:	83 ec 0c             	sub    $0xc,%esp
f010d9b5:	50                   	push   %eax
f010d9b6:	e8 99 a9 ff ff       	call   f0108354 <decrement_references>
f010d9bb:	83 c4 10             	add    $0x10,%esp
		return r;
f010d9be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d9c1:	eb 05                	jmp    f010d9c8 <__sys_allocate_page+0x117>
	}
	return 0 ;
f010d9c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010d9c8:	c9                   	leave  
f010d9c9:	c3                   	ret    

f010d9ca <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010d9ca:	55                   	push   %ebp
f010d9cb:	89 e5                	mov    %esp,%ebp
f010d9cd:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010d9d0:	83 ec 04             	sub    $0x4,%esp
f010d9d3:	68 61 67 12 f0       	push   $0xf0126761
f010d9d8:	68 dc 00 00 00       	push   $0xdc
f010d9dd:	68 7f 67 12 f0       	push   $0xf012677f
f010d9e2:	e8 52 29 ff ff       	call   f0100339 <_panic>

f010d9e7 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010d9e7:	55                   	push   %ebp
f010d9e8:	89 e5                	mov    %esp,%ebp
f010d9ea:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010d9ed:	83 ec 04             	sub    $0x4,%esp
f010d9f0:	68 94 67 12 f0       	push   $0xf0126794
f010d9f5:	68 ed 00 00 00       	push   $0xed
f010d9fa:	68 7f 67 12 f0       	push   $0xf012677f
f010d9ff:	e8 35 29 ff ff       	call   f0100339 <_panic>

f010da04 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010da04:	55                   	push   %ebp
f010da05:	89 e5                	mov    %esp,%ebp
f010da07:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010da0a:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010da0f:	8b 40 64             	mov    0x64(%eax),%eax
f010da12:	83 ec 04             	sub    $0x4,%esp
f010da15:	ff 75 0c             	pushl  0xc(%ebp)
f010da18:	ff 75 08             	pushl  0x8(%ebp)
f010da1b:	50                   	push   %eax
f010da1c:	e8 41 c5 ff ff       	call   f0109f62 <calculate_required_frames>
f010da21:	83 c4 10             	add    $0x10,%esp
}
f010da24:	c9                   	leave  
f010da25:	c3                   	ret    

f010da26 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010da26:	55                   	push   %ebp
f010da27:	89 e5                	mov    %esp,%ebp
f010da29:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da2c:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da2f:	83 ec 0c             	sub    $0xc,%esp
f010da32:	50                   	push   %eax
f010da33:	e8 be ae ff ff       	call   f01088f6 <calculate_available_frames>
f010da38:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010da3b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010da3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da41:	01 d0                	add    %edx,%eax
}
f010da43:	c9                   	leave  
f010da44:	c3                   	ret    

f010da45 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010da45:	55                   	push   %ebp
f010da46:	89 e5                	mov    %esp,%ebp
f010da48:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da4b:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da4e:	83 ec 0c             	sub    $0xc,%esp
f010da51:	50                   	push   %eax
f010da52:	e8 9f ae ff ff       	call   f01088f6 <calculate_available_frames>
f010da57:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010da5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010da5d:	c9                   	leave  
f010da5e:	c3                   	ret    

f010da5f <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010da5f:	55                   	push   %ebp
f010da60:	89 e5                	mov    %esp,%ebp
f010da62:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da65:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da68:	83 ec 0c             	sub    $0xc,%esp
f010da6b:	50                   	push   %eax
f010da6c:	e8 85 ae ff ff       	call   f01088f6 <calculate_available_frames>
f010da71:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010da74:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010da77:	c9                   	leave  
f010da78:	c3                   	ret    

f010da79 <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010da79:	55                   	push   %ebp
f010da7a:	89 e5                	mov    %esp,%ebp
f010da7c:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010da7f:	83 ec 0c             	sub    $0xc,%esp
f010da82:	ff 75 08             	pushl  0x8(%ebp)
f010da85:	e8 5a fe 00 00       	call   f011d8e4 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010da8a:	83 c4 10             	add    $0x10,%esp
}
f010da8d:	c9                   	leave  
f010da8e:	c3                   	ret    

f010da8f <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010da8f:	55                   	push   %ebp
f010da90:	89 e5                	mov    %esp,%ebp
f010da92:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010da95:	e8 75 fd 00 00       	call   f011d80f <scarce_memory>
}
f010da9a:	90                   	nop
f010da9b:	c9                   	leave  
f010da9c:	c3                   	ret    

f010da9d <sys_clearFFL>:

void sys_clearFFL()
{
f010da9d:	55                   	push   %ebp
f010da9e:	89 e5                	mov    %esp,%ebp
f010daa0:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010daa3:	83 ec 0c             	sub    $0xc,%esp
f010daa6:	68 80 43 5f f0       	push   $0xf05f4380
f010daab:	e8 dc 10 00 00       	call   f010eb8c <acquire_spinlock>
f010dab0:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010dab3:	a1 6c 43 5f f0       	mov    0xf05f436c,%eax
f010dab8:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010dabb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010dac2:	eb 12                	jmp    f010dad6 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010dac4:	83 ec 0c             	sub    $0xc,%esp
f010dac7:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010daca:	50                   	push   %eax
f010dacb:	e8 77 a6 ff ff       	call   f0108147 <allocate_frame>
f010dad0:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010dad3:	ff 45 f4             	incl   -0xc(%ebp)
f010dad6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dad9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010dadc:	7c e6                	jl     f010dac4 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010dade:	83 ec 0c             	sub    $0xc,%esp
f010dae1:	68 80 43 5f f0       	push   $0xf05f4380
f010dae6:	e8 28 11 00 00       	call   f010ec13 <release_spinlock>
f010daeb:	83 c4 10             	add    $0x10,%esp
}
f010daee:	90                   	nop
f010daef:	c9                   	leave  
f010daf0:	c3                   	ret    

f010daf1 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010daf1:	55                   	push   %ebp
f010daf2:	89 e5                	mov    %esp,%ebp
f010daf4:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010daf7:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dafc:	83 ec 0c             	sub    $0xc,%esp
f010daff:	50                   	push   %eax
f010db00:	e8 c1 6c ff ff       	call   f01047c6 <pf_calculate_allocated_pages>
f010db05:	83 c4 10             	add    $0x10,%esp
}
f010db08:	c9                   	leave  
f010db09:	c3                   	ret    

f010db0a <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010db0a:	55                   	push   %ebp
f010db0b:	89 e5                	mov    %esp,%ebp
f010db0d:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010db10:	e8 d9 0c 00 00       	call   f010e7ee <isBufferingEnabled>
f010db15:	84 c0                	test   %al,%al
f010db17:	74 19                	je     f010db32 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010db19:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010db1e:	83 ec 04             	sub    $0x4,%esp
f010db21:	ff 75 0c             	pushl  0xc(%ebp)
f010db24:	ff 75 08             	pushl  0x8(%ebp)
f010db27:	50                   	push   %eax
f010db28:	e8 93 c4 ff ff       	call   f0109fc0 <__free_user_mem_with_buffering>
f010db2d:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010db30:	eb 18                	jmp    f010db4a <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010db32:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010db37:	83 ec 04             	sub    $0x4,%esp
f010db3a:	ff 75 0c             	pushl  0xc(%ebp)
f010db3d:	ff 75 08             	pushl  0x8(%ebp)
f010db40:	50                   	push   %eax
f010db41:	e8 5d c4 ff ff       	call   f0109fa3 <free_user_mem>
f010db46:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010db49:	90                   	nop
}
f010db4a:	c9                   	leave  
f010db4b:	c3                   	ret    

f010db4c <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010db4c:	55                   	push   %ebp
f010db4d:	89 e5                	mov    %esp,%ebp
f010db4f:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010db52:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010db56:	75 07                	jne    f010db5f <check_Param+0x13>
	{
		env_exit();
f010db58:	e8 6c d0 ff ff       	call   f010abc9 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010db5d:	eb 25                	jmp    f010db84 <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010db5f:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010db66:	77 07                	ja     f010db6f <check_Param+0x23>
f010db68:	8b 45 08             	mov    0x8(%ebp),%eax
f010db6b:	85 c0                	test   %eax,%eax
f010db6d:	78 07                	js     f010db76 <check_Param+0x2a>
	{
		env_exit();
f010db6f:	e8 55 d0 ff ff       	call   f010abc9 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010db74:	eb 0e                	jmp    f010db84 <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010db76:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010db7d:	76 05                	jbe    f010db84 <check_Param+0x38>
	{
		env_exit();
f010db7f:	e8 45 d0 ff ff       	call   f010abc9 <env_exit>
	}
}
f010db84:	90                   	nop
f010db85:	c9                   	leave  
f010db86:	c3                   	ret    

f010db87 <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010db87:	55                   	push   %ebp
f010db88:	89 e5                	mov    %esp,%ebp
f010db8a:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010db8d:	83 ec 0c             	sub    $0xc,%esp
f010db90:	ff 75 08             	pushl  0x8(%ebp)
f010db93:	e8 b4 ff ff ff       	call   f010db4c <check_Param>
f010db98:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010db9b:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dba0:	83 ec 04             	sub    $0x4,%esp
f010dba3:	ff 75 0c             	pushl  0xc(%ebp)
f010dba6:	ff 75 08             	pushl  0x8(%ebp)
f010dba9:	50                   	push   %eax
f010dbaa:	e8 d7 c3 ff ff       	call   f0109f86 <allocate_user_mem>
f010dbaf:	83 c4 10             	add    $0x10,%esp
	return;
f010dbb2:	90                   	nop
}
f010dbb3:	c9                   	leave  
f010dbb4:	c3                   	ret    

f010dbb5 <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010dbb5:	55                   	push   %ebp
f010dbb6:	89 e5                	mov    %esp,%ebp
f010dbb8:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010dbbb:	83 ec 0c             	sub    $0xc,%esp
f010dbbe:	ff 75 08             	pushl  0x8(%ebp)
f010dbc1:	e8 86 ff ff ff       	call   f010db4c <check_Param>
f010dbc6:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010dbc9:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dbce:	8b 40 64             	mov    0x64(%eax),%eax
f010dbd1:	ff 75 10             	pushl  0x10(%ebp)
f010dbd4:	ff 75 0c             	pushl  0xc(%ebp)
f010dbd7:	ff 75 08             	pushl  0x8(%ebp)
f010dbda:	50                   	push   %eax
f010dbdb:	e8 4e c3 ff ff       	call   f0109f2e <allocate_chunk>
f010dbe0:	83 c4 10             	add    $0x10,%esp
	return;
f010dbe3:	90                   	nop
}
f010dbe4:	c9                   	leave  
f010dbe5:	c3                   	ret    

f010dbe6 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010dbe6:	55                   	push   %ebp
f010dbe7:	89 e5                	mov    %esp,%ebp
f010dbe9:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010dbec:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dbf1:	ff 75 10             	pushl  0x10(%ebp)
f010dbf4:	ff 75 0c             	pushl  0xc(%ebp)
f010dbf7:	ff 75 08             	pushl  0x8(%ebp)
f010dbfa:	50                   	push   %eax
f010dbfb:	e8 dd c3 ff ff       	call   f0109fdd <move_user_mem>
f010dc00:	83 c4 10             	add    $0x10,%esp
	return;
f010dc03:	90                   	nop
}
f010dc04:	c9                   	leave  
f010dc05:	c3                   	ret    

f010dc06 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010dc06:	55                   	push   %ebp
f010dc07:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010dc09:	a1 a4 47 5f f0       	mov    0xf05f47a4,%eax
}
f010dc0e:	5d                   	pop    %ebp
f010dc0f:	c3                   	ret    

f010dc10 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010dc10:	55                   	push   %ebp
f010dc11:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010dc13:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc16:	a3 a4 47 5f f0       	mov    %eax,0xf05f47a4
}
f010dc1b:	90                   	nop
f010dc1c:	5d                   	pop    %ebp
f010dc1d:	c3                   	ret    

f010dc1e <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010dc1e:	55                   	push   %ebp
f010dc1f:	89 e5                	mov    %esp,%ebp
f010dc21:	83 ec 18             	sub    $0x18,%esp
f010dc24:	8b 45 10             	mov    0x10(%ebp),%eax
f010dc27:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010dc2a:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010dc2e:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dc33:	8b 40 10             	mov    0x10(%eax),%eax
f010dc36:	83 ec 0c             	sub    $0xc,%esp
f010dc39:	ff 75 14             	pushl  0x14(%ebp)
f010dc3c:	52                   	push   %edx
f010dc3d:	ff 75 0c             	pushl  0xc(%ebp)
f010dc40:	ff 75 08             	pushl  0x8(%ebp)
f010dc43:	50                   	push   %eax
f010dc44:	e8 4f ae ff ff       	call   f0108a98 <createSharedObject>
f010dc49:	83 c4 20             	add    $0x20,%esp
}
f010dc4c:	c9                   	leave  
f010dc4d:	c3                   	ret    

f010dc4e <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010dc4e:	55                   	push   %ebp
f010dc4f:	89 e5                	mov    %esp,%ebp
f010dc51:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010dc54:	83 ec 08             	sub    $0x8,%esp
f010dc57:	ff 75 0c             	pushl  0xc(%ebp)
f010dc5a:	ff 75 08             	pushl  0x8(%ebp)
f010dc5d:	e8 b3 ad ff ff       	call   f0108a15 <getSizeOfSharedObject>
f010dc62:	83 c4 10             	add    $0x10,%esp
}
f010dc65:	c9                   	leave  
f010dc66:	c3                   	ret    

f010dc67 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010dc67:	55                   	push   %ebp
f010dc68:	89 e5                	mov    %esp,%ebp
f010dc6a:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010dc6d:	83 ec 04             	sub    $0x4,%esp
f010dc70:	ff 75 10             	pushl  0x10(%ebp)
f010dc73:	ff 75 0c             	pushl  0xc(%ebp)
f010dc76:	ff 75 08             	pushl  0x8(%ebp)
f010dc79:	e8 3a ae ff ff       	call   f0108ab8 <getSharedObject>
f010dc7e:	83 c4 10             	add    $0x10,%esp
}
f010dc81:	c9                   	leave  
f010dc82:	c3                   	ret    

f010dc83 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010dc83:	55                   	push   %ebp
f010dc84:	89 e5                	mov    %esp,%ebp
f010dc86:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010dc89:	83 ec 08             	sub    $0x8,%esp
f010dc8c:	ff 75 0c             	pushl  0xc(%ebp)
f010dc8f:	ff 75 08             	pushl  0x8(%ebp)
f010dc92:	e8 58 ae ff ff       	call   f0108aef <freeSharedObject>
f010dc97:	83 c4 10             	add    $0x10,%esp
}
f010dc9a:	c9                   	leave  
f010dc9b:	c3                   	ret    

f010dc9c <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010dc9c:	55                   	push   %ebp
f010dc9d:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010dc9f:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dca4:	8b 40 10             	mov    0x10(%eax),%eax
}
f010dca7:	5d                   	pop    %ebp
f010dca8:	c3                   	ret    

f010dca9 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010dca9:	55                   	push   %ebp
f010dcaa:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010dcac:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dcb1:	89 c2                	mov    %eax,%edx
f010dcb3:	a1 d0 b7 5c f0       	mov    0xf05cb7d0,%eax
f010dcb8:	29 c2                	sub    %eax,%edx
f010dcba:	89 d0                	mov    %edx,%eax
f010dcbc:	c1 f8 04             	sar    $0x4,%eax
f010dcbf:	89 c2                	mov    %eax,%edx
f010dcc1:	89 d0                	mov    %edx,%eax
f010dcc3:	c1 e0 09             	shl    $0x9,%eax
f010dcc6:	29 d0                	sub    %edx,%eax
f010dcc8:	c1 e0 03             	shl    $0x3,%eax
f010dccb:	01 d0                	add    %edx,%eax
f010dccd:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010dcd4:	01 c8                	add    %ecx,%eax
f010dcd6:	c1 e0 03             	shl    $0x3,%eax
f010dcd9:	01 d0                	add    %edx,%eax
f010dcdb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010dce2:	01 d0                	add    %edx,%eax
f010dce4:	89 c2                	mov    %eax,%edx
f010dce6:	c1 e2 09             	shl    $0x9,%edx
f010dce9:	01 d0                	add    %edx,%eax
f010dceb:	f7 d8                	neg    %eax
}
f010dced:	5d                   	pop    %ebp
f010dcee:	c3                   	ret    

f010dcef <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010dcef:	55                   	push   %ebp
f010dcf0:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010dcf2:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dcf7:	8b 40 14             	mov    0x14(%eax),%eax
}
f010dcfa:	5d                   	pop    %ebp
f010dcfb:	c3                   	ret    

f010dcfc <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010dcfc:	55                   	push   %ebp
f010dcfd:	89 e5                	mov    %esp,%ebp
f010dcff:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010dd02:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010dd06:	75 0a                	jne    f010dd12 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010dd08:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dd0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010dd10:	eb 22                	jmp    f010dd34 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010dd12:	83 ec 04             	sub    $0x4,%esp
f010dd15:	6a 00                	push   $0x0
f010dd17:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010dd1a:	50                   	push   %eax
f010dd1b:	ff 75 08             	pushl  0x8(%ebp)
f010dd1e:	e8 38 cf ff ff       	call   f010ac5b <envid2env>
f010dd23:	83 c4 10             	add    $0x10,%esp
f010dd26:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010dd29:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010dd2d:	79 05                	jns    f010dd34 <sys_destroy_env+0x38>
	{
		return r;
f010dd2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dd32:	eb 5e                	jmp    f010dd92 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010dd34:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dd37:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dd3c:	39 c2                	cmp    %eax,%edx
f010dd3e:	75 1b                	jne    f010dd5b <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010dd40:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dd45:	8b 40 10             	mov    0x10(%eax),%eax
f010dd48:	83 ec 08             	sub    $0x8,%esp
f010dd4b:	50                   	push   %eax
f010dd4c:	68 b3 67 12 f0       	push   $0xf01267b3
f010dd51:	e8 35 32 ff ff       	call   f0100f8b <cprintf>
f010dd56:	83 c4 10             	add    $0x10,%esp
f010dd59:	eb 20                	jmp    f010dd7b <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010dd5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd5e:	8b 50 10             	mov    0x10(%eax),%edx
f010dd61:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010dd66:	8b 40 10             	mov    0x10(%eax),%eax
f010dd69:	83 ec 04             	sub    $0x4,%esp
f010dd6c:	52                   	push   %edx
f010dd6d:	50                   	push   %eax
f010dd6e:	68 ce 67 12 f0       	push   $0xf01267ce
f010dd73:	e8 13 32 ff ff       	call   f0100f8b <cprintf>
f010dd78:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010dd7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd7e:	8b 40 10             	mov    0x10(%eax),%eax
f010dd81:	83 ec 0c             	sub    $0xc,%esp
f010dd84:	50                   	push   %eax
f010dd85:	e8 cc 7c ff ff       	call   f0105a56 <sched_kill_env>
f010dd8a:	83 c4 10             	add    $0x10,%esp

	return 0;
f010dd8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010dd92:	c9                   	leave  
f010dd93:	c3                   	ret    

f010dd94 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010dd94:	55                   	push   %ebp
f010dd95:	89 e5                	mov    %esp,%ebp
f010dd97:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010dd9a:	e8 2a ce ff ff       	call   f010abc9 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010dd9f:	90                   	nop
f010dda0:	c9                   	leave  
f010dda1:	c3                   	ret    

f010dda2 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010dda2:	55                   	push   %ebp
f010dda3:	89 e5                	mov    %esp,%ebp
f010dda5:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010dda8:	ff 75 14             	pushl  0x14(%ebp)
f010ddab:	ff 75 10             	pushl  0x10(%ebp)
f010ddae:	ff 75 0c             	pushl  0xc(%ebp)
f010ddb1:	ff 75 08             	pushl  0x8(%ebp)
f010ddb4:	e8 d4 c3 ff ff       	call   f010a18d <env_create>
f010ddb9:	83 c4 10             	add    $0x10,%esp
f010ddbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010ddbf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ddc3:	75 07                	jne    f010ddcc <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010ddc5:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010ddca:	eb 14                	jmp    f010dde0 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010ddcc:	83 ec 0c             	sub    $0xc,%esp
f010ddcf:	ff 75 f4             	pushl  -0xc(%ebp)
f010ddd2:	e8 e3 78 ff ff       	call   f01056ba <sched_new_env>
f010ddd7:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ddda:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dddd:	8b 40 10             	mov    0x10(%eax),%eax
}
f010dde0:	c9                   	leave  
f010dde1:	c3                   	ret    

f010dde2 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010dde2:	55                   	push   %ebp
f010dde3:	89 e5                	mov    %esp,%ebp
f010dde5:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010dde8:	8b 45 08             	mov    0x8(%ebp),%eax
f010ddeb:	83 ec 0c             	sub    $0xc,%esp
f010ddee:	50                   	push   %eax
f010ddef:	e8 1c 79 ff ff       	call   f0105710 <sched_run_env>
f010ddf4:	83 c4 10             	add    $0x10,%esp
}
f010ddf7:	90                   	nop
f010ddf8:	c9                   	leave  
f010ddf9:	c3                   	ret    

f010ddfa <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010ddfa:	55                   	push   %ebp
f010ddfb:	89 e5                	mov    %esp,%ebp
f010ddfd:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010de00:	0f 31                	rdtsc  
f010de02:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010de05:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010de08:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010de0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010de0e:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010de11:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010de14:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010de17:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010de1a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010de1d:	89 01                	mov    %eax,(%ecx)
f010de1f:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010de22:	8b 45 08             	mov    0x8(%ebp),%eax
f010de25:	c9                   	leave  
f010de26:	c2 04 00             	ret    $0x4

f010de29 <sys_rcr2>:

uint32 sys_rcr2()
{
f010de29:	55                   	push   %ebp
f010de2a:	89 e5                	mov    %esp,%ebp
f010de2c:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010de2f:	0f 20 d0             	mov    %cr2,%eax
f010de32:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010de35:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010de38:	90                   	nop
}
f010de39:	c9                   	leave  
f010de3a:	c3                   	ret    

f010de3b <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010de3b:	55                   	push   %ebp
f010de3c:	89 e5                	mov    %esp,%ebp
f010de3e:	83 ec 04             	sub    $0x4,%esp
f010de41:	8b 45 08             	mov    0x8(%ebp),%eax
f010de44:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010de47:	8a 45 fc             	mov    -0x4(%ebp),%al
f010de4a:	a2 40 c0 5c f0       	mov    %al,0xf05cc040
}
f010de4f:	90                   	nop
f010de50:	c9                   	leave  
f010de51:	c3                   	ret    

f010de52 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010de52:	55                   	push   %ebp
f010de53:	89 e5                	mov    %esp,%ebp
f010de55:	56                   	push   %esi
f010de56:	53                   	push   %ebx
f010de57:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010de5a:	e8 ac cd ff ff       	call   f010ac0b <get_cpu_proc>
f010de5f:	a3 84 2f 61 f0       	mov    %eax,0xf0612f84
	assert(cur_env != NULL);
f010de64:	a1 84 2f 61 f0       	mov    0xf0612f84,%eax
f010de69:	85 c0                	test   %eax,%eax
f010de6b:	75 19                	jne    f010de86 <syscall+0x34>
f010de6d:	68 e6 67 12 f0       	push   $0xf01267e6
f010de72:	68 f6 67 12 f0       	push   $0xf01267f6
f010de77:	68 05 02 00 00       	push   $0x205
f010de7c:	68 7f 67 12 f0       	push   $0xf012677f
f010de81:	e8 b3 24 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010de86:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010de8a:	0f 87 06 04 00 00    	ja     f010e296 <syscall+0x444>
f010de90:	8b 45 08             	mov    0x8(%ebp),%eax
f010de93:	c1 e0 02             	shl    $0x2,%eax
f010de96:	05 0c 68 12 f0       	add    $0xf012680c,%eax
f010de9b:	8b 00                	mov    (%eax),%eax
f010de9d:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010de9f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dea2:	83 ec 0c             	sub    $0xc,%esp
f010dea5:	50                   	push   %eax
f010dea6:	e8 d1 c0 ff ff       	call   f0109f7c <sys_sbrk>
f010deab:	83 c4 10             	add    $0x10,%esp
f010deae:	e9 e8 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010deb3:	83 ec 08             	sub    $0x8,%esp
f010deb6:	ff 75 10             	pushl  0x10(%ebp)
f010deb9:	ff 75 0c             	pushl  0xc(%ebp)
f010debc:	e8 49 fc ff ff       	call   f010db0a <sys_free_user_mem>
f010dec1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dec4:	b8 00 00 00 00       	mov    $0x0,%eax
f010dec9:	e9 cd 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010dece:	83 ec 08             	sub    $0x8,%esp
f010ded1:	ff 75 10             	pushl  0x10(%ebp)
f010ded4:	ff 75 0c             	pushl  0xc(%ebp)
f010ded7:	e8 ab fc ff ff       	call   f010db87 <sys_allocate_user_mem>
f010dedc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dedf:	b8 00 00 00 00       	mov    $0x0,%eax
f010dee4:	e9 b2 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010dee9:	8b 45 14             	mov    0x14(%ebp),%eax
f010deec:	0f b6 d0             	movzbl %al,%edx
f010deef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010def2:	83 ec 04             	sub    $0x4,%esp
f010def5:	52                   	push   %edx
f010def6:	ff 75 10             	pushl  0x10(%ebp)
f010def9:	50                   	push   %eax
f010defa:	e8 db f8 ff ff       	call   f010d7da <sys_cputs>
f010deff:	83 c4 10             	add    $0x10,%esp
		return 0;
f010df02:	b8 00 00 00 00       	mov    $0x0,%eax
f010df07:	e9 8f 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010df0c:	e8 45 f9 ff ff       	call   f010d856 <sys_cgetc>
f010df11:	e9 85 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010df16:	e8 7a f9 ff ff       	call   f010d895 <sys_lock_cons>
		return 0;
f010df1b:	b8 00 00 00 00       	mov    $0x0,%eax
f010df20:	e9 76 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010df25:	e8 79 f9 ff ff       	call   f010d8a3 <sys_unlock_cons>
		return 0;
f010df2a:	b8 00 00 00 00       	mov    $0x0,%eax
f010df2f:	e9 67 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010df34:	83 ec 08             	sub    $0x8,%esp
f010df37:	ff 75 10             	pushl  0x10(%ebp)
f010df3a:	ff 75 0c             	pushl  0xc(%ebp)
f010df3d:	e8 c2 fa ff ff       	call   f010da04 <sys_calculate_required_frames>
f010df42:	83 c4 10             	add    $0x10,%esp
f010df45:	e9 51 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010df4a:	e8 d7 fa ff ff       	call   f010da26 <sys_calculate_free_frames>
f010df4f:	e9 47 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010df54:	e8 ec fa ff ff       	call   f010da45 <sys_calculate_modified_frames>
f010df59:	e9 3d 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010df5e:	e8 fc fa ff ff       	call   f010da5f <sys_calculate_notmod_frames>
f010df63:	e9 33 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010df68:	e8 84 fb ff ff       	call   f010daf1 <sys_pf_calculate_allocated_pages>
f010df6d:	e9 29 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010df72:	83 ec 0c             	sub    $0xc,%esp
f010df75:	ff 75 0c             	pushl  0xc(%ebp)
f010df78:	e8 fc fa ff ff       	call   f010da79 <sys_calculate_pages_tobe_removed_ready_exit>
f010df7d:	83 c4 10             	add    $0x10,%esp
f010df80:	e9 16 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010df85:	e8 05 fb ff ff       	call   f010da8f <sys_scarce_memory>
		return 0;
f010df8a:	b8 00 00 00 00       	mov    $0x0,%eax
f010df8f:	e9 07 03 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010df94:	83 ec 04             	sub    $0x4,%esp
f010df97:	ff 75 14             	pushl  0x14(%ebp)
f010df9a:	ff 75 10             	pushl  0x10(%ebp)
f010df9d:	ff 75 0c             	pushl  0xc(%ebp)
f010dfa0:	e8 10 fc ff ff       	call   f010dbb5 <sys_allocate_chunk>
f010dfa5:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dfa8:	b8 00 00 00 00       	mov    $0x0,%eax
f010dfad:	e9 e9 02 00 00       	jmp    f010e29b <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010dfb2:	8b 55 10             	mov    0x10(%ebp),%edx
f010dfb5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfb8:	83 ec 08             	sub    $0x8,%esp
f010dfbb:	52                   	push   %edx
f010dfbc:	50                   	push   %eax
f010dfbd:	e8 ef f8 ff ff       	call   f010d8b1 <__sys_allocate_page>
f010dfc2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dfc5:	b8 00 00 00 00       	mov    $0x0,%eax
f010dfca:	e9 cc 02 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010dfcf:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010dfd2:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010dfd5:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010dfd8:	8b 55 10             	mov    0x10(%ebp),%edx
f010dfdb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfde:	83 ec 0c             	sub    $0xc,%esp
f010dfe1:	56                   	push   %esi
f010dfe2:	53                   	push   %ebx
f010dfe3:	51                   	push   %ecx
f010dfe4:	52                   	push   %edx
f010dfe5:	50                   	push   %eax
f010dfe6:	e8 df f9 ff ff       	call   f010d9ca <__sys_map_frame>
f010dfeb:	83 c4 20             	add    $0x20,%esp
		return 0;
f010dfee:	b8 00 00 00 00       	mov    $0x0,%eax
f010dff3:	e9 a3 02 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010dff8:	8b 55 10             	mov    0x10(%ebp),%edx
f010dffb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dffe:	83 ec 08             	sub    $0x8,%esp
f010e001:	52                   	push   %edx
f010e002:	50                   	push   %eax
f010e003:	e8 df f9 ff ff       	call   f010d9e7 <__sys_unmap_frame>
f010e008:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e00b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e010:	e9 86 02 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010e015:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e018:	0f be c0             	movsbl %al,%eax
f010e01b:	83 ec 0c             	sub    $0xc,%esp
f010e01e:	50                   	push   %eax
f010e01f:	e8 0e f8 ff ff       	call   f010d832 <sys_cputc>
f010e024:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e027:	b8 00 00 00 00       	mov    $0x0,%eax
f010e02c:	e9 6a 02 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010e031:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e034:	0f be c0             	movsbl %al,%eax
f010e037:	83 ec 0c             	sub    $0xc,%esp
f010e03a:	50                   	push   %eax
f010e03b:	e8 5d fa ff ff       	call   f010da9d <sys_clearFFL>
f010e040:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e043:	b8 00 00 00 00       	mov    $0x0,%eax
f010e048:	e9 4e 02 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010e04d:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e050:	8b 45 14             	mov    0x14(%ebp),%eax
f010e053:	0f b6 d0             	movzbl %al,%edx
f010e056:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e059:	51                   	push   %ecx
f010e05a:	52                   	push   %edx
f010e05b:	ff 75 10             	pushl  0x10(%ebp)
f010e05e:	50                   	push   %eax
f010e05f:	e8 ba fb ff ff       	call   f010dc1e <sys_createSharedObject>
f010e064:	83 c4 10             	add    $0x10,%esp
f010e067:	e9 2f 02 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010e06c:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e06f:	8b 55 10             	mov    0x10(%ebp),%edx
f010e072:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e075:	83 ec 04             	sub    $0x4,%esp
f010e078:	51                   	push   %ecx
f010e079:	52                   	push   %edx
f010e07a:	50                   	push   %eax
f010e07b:	e8 e7 fb ff ff       	call   f010dc67 <sys_getSharedObject>
f010e080:	83 c4 10             	add    $0x10,%esp
f010e083:	e9 13 02 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010e088:	8b 55 10             	mov    0x10(%ebp),%edx
f010e08b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e08e:	83 ec 08             	sub    $0x8,%esp
f010e091:	52                   	push   %edx
f010e092:	50                   	push   %eax
f010e093:	e8 eb fb ff ff       	call   f010dc83 <sys_freeSharedObject>
f010e098:	83 c4 10             	add    $0x10,%esp
f010e09b:	e9 fb 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010e0a0:	8b 55 10             	mov    0x10(%ebp),%edx
f010e0a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0a6:	83 ec 08             	sub    $0x8,%esp
f010e0a9:	52                   	push   %edx
f010e0aa:	50                   	push   %eax
f010e0ab:	e8 9e fb ff ff       	call   f010dc4e <sys_getSizeOfSharedObject>
f010e0b0:	83 c4 10             	add    $0x10,%esp
f010e0b3:	e9 e3 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010e0b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0bb:	ff 75 18             	pushl  0x18(%ebp)
f010e0be:	ff 75 14             	pushl  0x14(%ebp)
f010e0c1:	ff 75 10             	pushl  0x10(%ebp)
f010e0c4:	50                   	push   %eax
f010e0c5:	e8 d8 fc ff ff       	call   f010dda2 <sys_create_env>
f010e0ca:	83 c4 10             	add    $0x10,%esp
f010e0cd:	e9 c9 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010e0d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0d5:	83 ec 0c             	sub    $0xc,%esp
f010e0d8:	50                   	push   %eax
f010e0d9:	e8 04 fd ff ff       	call   f010dde2 <sys_run_env>
f010e0de:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e0e1:	b8 00 00 00 00       	mov    $0x0,%eax
f010e0e6:	e9 b0 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010e0eb:	e8 b9 fb ff ff       	call   f010dca9 <sys_getenvindex>
f010e0f0:	e9 a6 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010e0f5:	e8 a2 fb ff ff       	call   f010dc9c <sys_getenvid>
f010e0fa:	e9 9c 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010e0ff:	e8 eb fb ff ff       	call   f010dcef <sys_getparentenvid>
f010e104:	e9 92 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010e109:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e10c:	83 ec 0c             	sub    $0xc,%esp
f010e10f:	50                   	push   %eax
f010e110:	e8 e7 fb ff ff       	call   f010dcfc <sys_destroy_env>
f010e115:	83 c4 10             	add    $0x10,%esp
f010e118:	e9 7e 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010e11d:	e8 72 fc ff ff       	call   f010dd94 <sys_exit_env>
		return 0;
f010e122:	b8 00 00 00 00       	mov    $0x0,%eax
f010e127:	e9 6f 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010e12c:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e12f:	83 ec 0c             	sub    $0xc,%esp
f010e132:	50                   	push   %eax
f010e133:	e8 c2 fc ff ff       	call   f010ddfa <sys_get_virtual_time>
f010e138:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010e13b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e13e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010e141:	8b 45 10             	mov    0x10(%ebp),%eax
f010e144:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010e147:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e14a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e14d:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010e14f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e152:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e155:	89 10                	mov    %edx,(%eax)
		return 0;
f010e157:	b8 00 00 00 00       	mov    $0x0,%eax
f010e15c:	e9 3a 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010e161:	83 ec 04             	sub    $0x4,%esp
f010e164:	ff 75 14             	pushl  0x14(%ebp)
f010e167:	ff 75 10             	pushl  0x10(%ebp)
f010e16a:	ff 75 0c             	pushl  0xc(%ebp)
f010e16d:	e8 74 fa ff ff       	call   f010dbe6 <sys_move_user_mem>
f010e172:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e175:	b8 00 00 00 00       	mov    $0x0,%eax
f010e17a:	e9 1c 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010e17f:	e8 a5 fc ff ff       	call   f010de29 <sys_rcr2>
f010e184:	e9 12 01 00 00       	jmp    f010e29b <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010e189:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e18c:	0f b6 c0             	movzbl %al,%eax
f010e18f:	83 ec 0c             	sub    $0xc,%esp
f010e192:	50                   	push   %eax
f010e193:	e8 a3 fc ff ff       	call   f010de3b <sys_bypassPageFault>
f010e198:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e19b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1a0:	e9 f6 00 00 00       	jmp    f010e29b <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010e1a5:	e8 19 ed 00 00       	call   f011cec3 <rsttst>
		return 0;
f010e1aa:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1af:	e9 e7 00 00 00       	jmp    f010e29b <syscall+0x449>
	case SYS_inctst:
		inctst();
f010e1b4:	e8 52 ed 00 00       	call   f011cf0b <inctst>
		return 0;
f010e1b9:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1be:	e9 d8 00 00 00       	jmp    f010e29b <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010e1c3:	83 ec 0c             	sub    $0xc,%esp
f010e1c6:	ff 75 0c             	pushl  0xc(%ebp)
f010e1c9:	e8 7f ee 00 00       	call   f011d04d <chktst>
f010e1ce:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e1d1:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1d6:	e9 c0 00 00 00       	jmp    f010e29b <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010e1db:	e8 5f ed 00 00       	call   f011cf3f <gettst>
f010e1e0:	e9 b6 00 00 00       	jmp    f010e29b <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010e1e5:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010e1e8:	8b 45 18             	mov    0x18(%ebp),%eax
f010e1eb:	0f be c0             	movsbl %al,%eax
f010e1ee:	83 ec 0c             	sub    $0xc,%esp
f010e1f1:	52                   	push   %edx
f010e1f2:	50                   	push   %eax
f010e1f3:	ff 75 14             	pushl  0x14(%ebp)
f010e1f6:	ff 75 10             	pushl  0x10(%ebp)
f010e1f9:	ff 75 0c             	pushl  0xc(%ebp)
f010e1fc:	e8 48 ed 00 00       	call   f011cf49 <tst>
f010e201:	83 c4 20             	add    $0x20,%esp
		return 0;
f010e204:	b8 00 00 00 00       	mov    $0x0,%eax
f010e209:	e9 8d 00 00 00       	jmp    f010e29b <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010e20e:	e8 f3 f9 ff ff       	call   f010dc06 <sys_get_heap_strategy>
f010e213:	e9 83 00 00 00       	jmp    f010e29b <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010e218:	83 ec 0c             	sub    $0xc,%esp
f010e21b:	ff 75 0c             	pushl  0xc(%ebp)
f010e21e:	e8 ed f9 ff ff       	call   f010dc10 <sys_set_uheap_strategy>
f010e223:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e226:	b8 00 00 00 00       	mov    $0x0,%eax
f010e22b:	eb 6e                	jmp    f010e29b <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010e22d:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010e230:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e233:	8b 55 10             	mov    0x10(%ebp),%edx
f010e236:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e239:	53                   	push   %ebx
f010e23a:	51                   	push   %ecx
f010e23b:	52                   	push   %edx
f010e23c:	50                   	push   %eax
f010e23d:	e8 c1 1b 00 00       	call   f010fe03 <sys_check_LRU_lists>
f010e242:	83 c4 10             	add    $0x10,%esp
f010e245:	eb 54                	jmp    f010e29b <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010e247:	8b 55 10             	mov    0x10(%ebp),%edx
f010e24a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e24d:	83 ec 08             	sub    $0x8,%esp
f010e250:	52                   	push   %edx
f010e251:	50                   	push   %eax
f010e252:	e8 6e 1d 00 00       	call   f010ffc5 <sys_check_LRU_lists_free>
f010e257:	83 c4 10             	add    $0x10,%esp
f010e25a:	eb 3f                	jmp    f010e29b <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010e25c:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e25f:	8b 55 10             	mov    0x10(%ebp),%edx
f010e262:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e265:	51                   	push   %ecx
f010e266:	ff 75 14             	pushl  0x14(%ebp)
f010e269:	52                   	push   %edx
f010e26a:	50                   	push   %eax
f010e26b:	e8 e2 1e 00 00       	call   f0110152 <sys_check_WS_list>
f010e270:	83 c4 10             	add    $0x10,%esp
f010e273:	eb 26                	jmp    f010e29b <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010e275:	8b 55 10             	mov    0x10(%ebp),%edx
f010e278:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e27b:	83 ec 08             	sub    $0x8,%esp
f010e27e:	52                   	push   %edx
f010e27f:	50                   	push   %eax
f010e280:	e8 c9 ef 00 00       	call   f011d24e <sys_utilities>
f010e285:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e288:	b8 00 00 00 00       	mov    $0x0,%eax
f010e28d:	eb 0c                	jmp    f010e29b <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010e28f:	b8 03 00 00 00       	mov    $0x3,%eax
f010e294:	eb 05                	jmp    f010e29b <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010e296:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010e29b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010e29e:	5b                   	pop    %ebx
f010e29f:	5e                   	pop    %esi
f010e2a0:	5d                   	pop    %ebp
f010e2a1:	c3                   	ret    

f010e2a2 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010e2a2:	55                   	push   %ebp
f010e2a3:	89 e5                	mov    %esp,%ebp
f010e2a5:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010e2a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e2ab:	8b 00                	mov    (%eax),%eax
f010e2ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e2b0:	8b 45 10             	mov    0x10(%ebp),%eax
f010e2b3:	8b 00                	mov    (%eax),%eax
f010e2b5:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e2b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010e2bf:	e9 ca 00 00 00       	jmp    f010e38e <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010e2c4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e2c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e2ca:	01 d0                	add    %edx,%eax
f010e2cc:	89 c2                	mov    %eax,%edx
f010e2ce:	c1 ea 1f             	shr    $0x1f,%edx
f010e2d1:	01 d0                	add    %edx,%eax
f010e2d3:	d1 f8                	sar    %eax
f010e2d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010e2d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e2db:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010e2de:	eb 03                	jmp    f010e2e3 <stab_binsearch+0x41>
			m--;
f010e2e0:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010e2e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e2e6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e2e9:	7c 1e                	jl     f010e309 <stab_binsearch+0x67>
f010e2eb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e2ee:	89 d0                	mov    %edx,%eax
f010e2f0:	01 c0                	add    %eax,%eax
f010e2f2:	01 d0                	add    %edx,%eax
f010e2f4:	c1 e0 02             	shl    $0x2,%eax
f010e2f7:	89 c2                	mov    %eax,%edx
f010e2f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2fc:	01 d0                	add    %edx,%eax
f010e2fe:	8a 40 04             	mov    0x4(%eax),%al
f010e301:	0f b6 c0             	movzbl %al,%eax
f010e304:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e307:	75 d7                	jne    f010e2e0 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010e309:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e30c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e30f:	7d 09                	jge    f010e31a <stab_binsearch+0x78>
			l = true_m + 1;
f010e311:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e314:	40                   	inc    %eax
f010e315:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010e318:	eb 74                	jmp    f010e38e <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010e31a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010e321:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e324:	89 d0                	mov    %edx,%eax
f010e326:	01 c0                	add    %eax,%eax
f010e328:	01 d0                	add    %edx,%eax
f010e32a:	c1 e0 02             	shl    $0x2,%eax
f010e32d:	89 c2                	mov    %eax,%edx
f010e32f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e332:	01 d0                	add    %edx,%eax
f010e334:	8b 40 08             	mov    0x8(%eax),%eax
f010e337:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e33a:	73 11                	jae    f010e34d <stab_binsearch+0xab>
			*region_left = m;
f010e33c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e33f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e342:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010e344:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e347:	40                   	inc    %eax
f010e348:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e34b:	eb 41                	jmp    f010e38e <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010e34d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e350:	89 d0                	mov    %edx,%eax
f010e352:	01 c0                	add    %eax,%eax
f010e354:	01 d0                	add    %edx,%eax
f010e356:	c1 e0 02             	shl    $0x2,%eax
f010e359:	89 c2                	mov    %eax,%edx
f010e35b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e35e:	01 d0                	add    %edx,%eax
f010e360:	8b 40 08             	mov    0x8(%eax),%eax
f010e363:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e366:	76 14                	jbe    f010e37c <stab_binsearch+0xda>
			*region_right = m - 1;
f010e368:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e36b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e36e:	8b 45 10             	mov    0x10(%ebp),%eax
f010e371:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010e373:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e376:	48                   	dec    %eax
f010e377:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e37a:	eb 12                	jmp    f010e38e <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010e37c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e37f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e382:	89 10                	mov    %edx,(%eax)
			l = m;
f010e384:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e387:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010e38a:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010e38e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e391:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010e394:	0f 8e 2a ff ff ff    	jle    f010e2c4 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010e39a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e39e:	75 0f                	jne    f010e3af <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010e3a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3a3:	8b 00                	mov    (%eax),%eax
f010e3a5:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e3a8:	8b 45 10             	mov    0x10(%ebp),%eax
f010e3ab:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010e3ad:	eb 3d                	jmp    f010e3ec <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e3af:	8b 45 10             	mov    0x10(%ebp),%eax
f010e3b2:	8b 00                	mov    (%eax),%eax
f010e3b4:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e3b7:	eb 03                	jmp    f010e3bc <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010e3b9:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010e3bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3bf:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e3c1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e3c4:	7d 1e                	jge    f010e3e4 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010e3c6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e3c9:	89 d0                	mov    %edx,%eax
f010e3cb:	01 c0                	add    %eax,%eax
f010e3cd:	01 d0                	add    %edx,%eax
f010e3cf:	c1 e0 02             	shl    $0x2,%eax
f010e3d2:	89 c2                	mov    %eax,%edx
f010e3d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3d7:	01 d0                	add    %edx,%eax
f010e3d9:	8a 40 04             	mov    0x4(%eax),%al
f010e3dc:	0f b6 c0             	movzbl %al,%eax
f010e3df:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e3e2:	75 d5                	jne    f010e3b9 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010e3e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3e7:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e3ea:	89 10                	mov    %edx,(%eax)
	}
}
f010e3ec:	90                   	nop
f010e3ed:	c9                   	leave  
f010e3ee:	c3                   	ret    

f010e3ef <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010e3ef:	55                   	push   %ebp
f010e3f0:	89 e5                	mov    %esp,%ebp
f010e3f2:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010e3f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3f8:	c7 00 c8 68 12 f0    	movl   $0xf01268c8,(%eax)
	info->eip_line = 0;
f010e3fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e401:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010e408:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e40b:	c7 40 08 c8 68 12 f0 	movl   $0xf01268c8,0x8(%eax)
	info->eip_fn_namelen = 9;
f010e412:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e415:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010e41c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e41f:	8b 55 08             	mov    0x8(%ebp),%edx
f010e422:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010e425:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e428:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010e42f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e432:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010e437:	76 1e                	jbe    f010e457 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010e439:	c7 45 f4 5c 06 13 f0 	movl   $0xf013065c,-0xc(%ebp)
		stab_end = __STAB_END__;
f010e440:	c7 45 f0 d8 26 16 f0 	movl   $0xf01626d8,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010e447:	c7 45 ec d9 26 16 f0 	movl   $0xf01626d9,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010e44e:	c7 45 e8 6c 3d 17 f0 	movl   $0xf0173d6c,-0x18(%ebp)
f010e455:	eb 2a                	jmp    f010e481 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010e457:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010e45e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e461:	8b 00                	mov    (%eax),%eax
f010e463:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010e466:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e469:	8b 40 04             	mov    0x4(%eax),%eax
f010e46c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010e46f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e472:	8b 40 08             	mov    0x8(%eax),%eax
f010e475:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010e478:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e47b:	8b 40 0c             	mov    0xc(%eax),%eax
f010e47e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010e481:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e484:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e487:	76 0a                	jbe    f010e493 <debuginfo_eip+0xa4>
f010e489:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e48c:	48                   	dec    %eax
f010e48d:	8a 00                	mov    (%eax),%al
f010e48f:	84 c0                	test   %al,%al
f010e491:	74 0a                	je     f010e49d <debuginfo_eip+0xae>
		return -1;
f010e493:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e498:	e9 01 02 00 00       	jmp    f010e69e <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010e49d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010e4a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e4a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e4aa:	29 c2                	sub    %eax,%edx
f010e4ac:	89 d0                	mov    %edx,%eax
f010e4ae:	c1 f8 02             	sar    $0x2,%eax
f010e4b1:	89 c2                	mov    %eax,%edx
f010e4b3:	89 d0                	mov    %edx,%eax
f010e4b5:	c1 e0 02             	shl    $0x2,%eax
f010e4b8:	01 d0                	add    %edx,%eax
f010e4ba:	c1 e0 02             	shl    $0x2,%eax
f010e4bd:	01 d0                	add    %edx,%eax
f010e4bf:	c1 e0 02             	shl    $0x2,%eax
f010e4c2:	01 d0                	add    %edx,%eax
f010e4c4:	89 c1                	mov    %eax,%ecx
f010e4c6:	c1 e1 08             	shl    $0x8,%ecx
f010e4c9:	01 c8                	add    %ecx,%eax
f010e4cb:	89 c1                	mov    %eax,%ecx
f010e4cd:	c1 e1 10             	shl    $0x10,%ecx
f010e4d0:	01 c8                	add    %ecx,%eax
f010e4d2:	01 c0                	add    %eax,%eax
f010e4d4:	01 d0                	add    %edx,%eax
f010e4d6:	48                   	dec    %eax
f010e4d7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010e4da:	ff 75 08             	pushl  0x8(%ebp)
f010e4dd:	6a 64                	push   $0x64
f010e4df:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010e4e2:	50                   	push   %eax
f010e4e3:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010e4e6:	50                   	push   %eax
f010e4e7:	ff 75 f4             	pushl  -0xc(%ebp)
f010e4ea:	e8 b3 fd ff ff       	call   f010e2a2 <stab_binsearch>
f010e4ef:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010e4f2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4f5:	85 c0                	test   %eax,%eax
f010e4f7:	75 0a                	jne    f010e503 <debuginfo_eip+0x114>
		return -1;
f010e4f9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e4fe:	e9 9b 01 00 00       	jmp    f010e69e <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010e503:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e506:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010e509:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e50c:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010e50f:	ff 75 08             	pushl  0x8(%ebp)
f010e512:	6a 24                	push   $0x24
f010e514:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010e517:	50                   	push   %eax
f010e518:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010e51b:	50                   	push   %eax
f010e51c:	ff 75 f4             	pushl  -0xc(%ebp)
f010e51f:	e8 7e fd ff ff       	call   f010e2a2 <stab_binsearch>
f010e524:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010e527:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010e52a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e52d:	39 c2                	cmp    %eax,%edx
f010e52f:	0f 8f 86 00 00 00    	jg     f010e5bb <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010e535:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e538:	89 c2                	mov    %eax,%edx
f010e53a:	89 d0                	mov    %edx,%eax
f010e53c:	01 c0                	add    %eax,%eax
f010e53e:	01 d0                	add    %edx,%eax
f010e540:	c1 e0 02             	shl    $0x2,%eax
f010e543:	89 c2                	mov    %eax,%edx
f010e545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e548:	01 d0                	add    %edx,%eax
f010e54a:	8b 00                	mov    (%eax),%eax
f010e54c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e54f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e552:	29 d1                	sub    %edx,%ecx
f010e554:	89 ca                	mov    %ecx,%edx
f010e556:	39 d0                	cmp    %edx,%eax
f010e558:	73 22                	jae    f010e57c <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010e55a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e55d:	89 c2                	mov    %eax,%edx
f010e55f:	89 d0                	mov    %edx,%eax
f010e561:	01 c0                	add    %eax,%eax
f010e563:	01 d0                	add    %edx,%eax
f010e565:	c1 e0 02             	shl    $0x2,%eax
f010e568:	89 c2                	mov    %eax,%edx
f010e56a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e56d:	01 d0                	add    %edx,%eax
f010e56f:	8b 10                	mov    (%eax),%edx
f010e571:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e574:	01 c2                	add    %eax,%edx
f010e576:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e579:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010e57c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e57f:	89 c2                	mov    %eax,%edx
f010e581:	89 d0                	mov    %edx,%eax
f010e583:	01 c0                	add    %eax,%eax
f010e585:	01 d0                	add    %edx,%eax
f010e587:	c1 e0 02             	shl    $0x2,%eax
f010e58a:	89 c2                	mov    %eax,%edx
f010e58c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e58f:	01 d0                	add    %edx,%eax
f010e591:	8b 50 08             	mov    0x8(%eax),%edx
f010e594:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e597:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010e59a:	8b 55 08             	mov    0x8(%ebp),%edx
f010e59d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5a0:	8b 40 10             	mov    0x10(%eax),%eax
f010e5a3:	29 c2                	sub    %eax,%edx
f010e5a5:	89 d0                	mov    %edx,%eax
f010e5a7:	c1 f8 02             	sar    $0x2,%eax
f010e5aa:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010e5ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e5b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010e5b3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e5b6:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010e5b9:	eb 15                	jmp    f010e5d0 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010e5bb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5be:	8b 55 08             	mov    0x8(%ebp),%edx
f010e5c1:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010e5c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010e5ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e5cd:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010e5d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5d3:	8b 40 08             	mov    0x8(%eax),%eax
f010e5d6:	83 ec 08             	sub    $0x8,%esp
f010e5d9:	6a 3a                	push   $0x3a
f010e5db:	50                   	push   %eax
f010e5dc:	e8 2e 07 01 00       	call   f011ed0f <strfind>
f010e5e1:	83 c4 10             	add    $0x10,%esp
f010e5e4:	89 c2                	mov    %eax,%edx
f010e5e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5e9:	8b 40 08             	mov    0x8(%eax),%eax
f010e5ec:	29 c2                	sub    %eax,%edx
f010e5ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5f1:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e5f4:	eb 03                	jmp    f010e5f9 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010e5f6:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e5f9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5fc:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e5ff:	7c 4e                	jl     f010e64f <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010e601:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e604:	89 d0                	mov    %edx,%eax
f010e606:	01 c0                	add    %eax,%eax
f010e608:	01 d0                	add    %edx,%eax
f010e60a:	c1 e0 02             	shl    $0x2,%eax
f010e60d:	89 c2                	mov    %eax,%edx
f010e60f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e612:	01 d0                	add    %edx,%eax
f010e614:	8a 40 04             	mov    0x4(%eax),%al
f010e617:	3c 84                	cmp    $0x84,%al
f010e619:	74 34                	je     f010e64f <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010e61b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e61e:	89 d0                	mov    %edx,%eax
f010e620:	01 c0                	add    %eax,%eax
f010e622:	01 d0                	add    %edx,%eax
f010e624:	c1 e0 02             	shl    $0x2,%eax
f010e627:	89 c2                	mov    %eax,%edx
f010e629:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e62c:	01 d0                	add    %edx,%eax
f010e62e:	8a 40 04             	mov    0x4(%eax),%al
f010e631:	3c 64                	cmp    $0x64,%al
f010e633:	75 c1                	jne    f010e5f6 <debuginfo_eip+0x207>
f010e635:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e638:	89 d0                	mov    %edx,%eax
f010e63a:	01 c0                	add    %eax,%eax
f010e63c:	01 d0                	add    %edx,%eax
f010e63e:	c1 e0 02             	shl    $0x2,%eax
f010e641:	89 c2                	mov    %eax,%edx
f010e643:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e646:	01 d0                	add    %edx,%eax
f010e648:	8b 40 08             	mov    0x8(%eax),%eax
f010e64b:	85 c0                	test   %eax,%eax
f010e64d:	74 a7                	je     f010e5f6 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010e64f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e652:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e655:	7c 42                	jl     f010e699 <debuginfo_eip+0x2aa>
f010e657:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e65a:	89 d0                	mov    %edx,%eax
f010e65c:	01 c0                	add    %eax,%eax
f010e65e:	01 d0                	add    %edx,%eax
f010e660:	c1 e0 02             	shl    $0x2,%eax
f010e663:	89 c2                	mov    %eax,%edx
f010e665:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e668:	01 d0                	add    %edx,%eax
f010e66a:	8b 00                	mov    (%eax),%eax
f010e66c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e66f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e672:	29 d1                	sub    %edx,%ecx
f010e674:	89 ca                	mov    %ecx,%edx
f010e676:	39 d0                	cmp    %edx,%eax
f010e678:	73 1f                	jae    f010e699 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010e67a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e67d:	89 d0                	mov    %edx,%eax
f010e67f:	01 c0                	add    %eax,%eax
f010e681:	01 d0                	add    %edx,%eax
f010e683:	c1 e0 02             	shl    $0x2,%eax
f010e686:	89 c2                	mov    %eax,%edx
f010e688:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e68b:	01 d0                	add    %edx,%eax
f010e68d:	8b 10                	mov    (%eax),%edx
f010e68f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e692:	01 c2                	add    %eax,%edx
f010e694:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e697:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010e699:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e69e:	c9                   	leave  
f010e69f:	c3                   	ret    

f010e6a0 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010e6a0:	55                   	push   %ebp
f010e6a1:	89 e5                	mov    %esp,%ebp
f010e6a3:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010e6a6:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010e6aa:	74 1c                	je     f010e6c8 <setPageReplacmentAlgorithmLRU+0x28>
f010e6ac:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010e6b0:	74 16                	je     f010e6c8 <setPageReplacmentAlgorithmLRU+0x28>
f010e6b2:	68 d4 68 12 f0       	push   $0xf01268d4
f010e6b7:	68 1e 69 12 f0       	push   $0xf012691e
f010e6bc:	6a 19                	push   $0x19
f010e6be:	68 33 69 12 f0       	push   $0xf0126933
f010e6c3:	e8 71 1c ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010e6c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6cb:	a3 10 4a 5f f0       	mov    %eax,0xf05f4a10
}
f010e6d0:	90                   	nop
f010e6d1:	c9                   	leave  
f010e6d2:	c3                   	ret    

f010e6d3 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010e6d3:	55                   	push   %ebp
f010e6d4:	89 e5                	mov    %esp,%ebp
f010e6d6:	c7 05 10 4a 5f f0 03 	movl   $0x3,0xf05f4a10
f010e6dd:	00 00 00 
f010e6e0:	90                   	nop
f010e6e1:	5d                   	pop    %ebp
f010e6e2:	c3                   	ret    

f010e6e3 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010e6e3:	55                   	push   %ebp
f010e6e4:	89 e5                	mov    %esp,%ebp
f010e6e6:	c7 05 10 4a 5f f0 04 	movl   $0x4,0xf05f4a10
f010e6ed:	00 00 00 
f010e6f0:	90                   	nop
f010e6f1:	5d                   	pop    %ebp
f010e6f2:	c3                   	ret    

f010e6f3 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010e6f3:	55                   	push   %ebp
f010e6f4:	89 e5                	mov    %esp,%ebp
f010e6f6:	c7 05 10 4a 5f f0 05 	movl   $0x5,0xf05f4a10
f010e6fd:	00 00 00 
f010e700:	90                   	nop
f010e701:	5d                   	pop    %ebp
f010e702:	c3                   	ret    

f010e703 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010e703:	55                   	push   %ebp
f010e704:	89 e5                	mov    %esp,%ebp
f010e706:	c7 05 10 4a 5f f0 07 	movl   $0x7,0xf05f4a10
f010e70d:	00 00 00 
f010e710:	90                   	nop
f010e711:	5d                   	pop    %ebp
f010e712:	c3                   	ret    

f010e713 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010e713:	55                   	push   %ebp
f010e714:	89 e5                	mov    %esp,%ebp
f010e716:	c7 05 10 4a 5f f0 06 	movl   $0x6,0xf05f4a10
f010e71d:	00 00 00 
f010e720:	8b 45 08             	mov    0x8(%ebp),%eax
f010e723:	a3 54 43 5f f0       	mov    %eax,0xf05f4354
f010e728:	90                   	nop
f010e729:	5d                   	pop    %ebp
f010e72a:	c3                   	ret    

f010e72b <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010e72b:	55                   	push   %ebp
f010e72c:	89 e5                	mov    %esp,%ebp
f010e72e:	8b 15 10 4a 5f f0    	mov    0xf05f4a10,%edx
f010e734:	8b 45 08             	mov    0x8(%ebp),%eax
f010e737:	39 c2                	cmp    %eax,%edx
f010e739:	0f 94 c0             	sete   %al
f010e73c:	0f b6 c0             	movzbl %al,%eax
f010e73f:	5d                   	pop    %ebp
f010e740:	c3                   	ret    

f010e741 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010e741:	55                   	push   %ebp
f010e742:	89 e5                	mov    %esp,%ebp
f010e744:	a1 10 4a 5f f0       	mov    0xf05f4a10,%eax
f010e749:	83 f8 03             	cmp    $0x3,%eax
f010e74c:	75 07                	jne    f010e755 <isPageReplacmentAlgorithmCLOCK+0x14>
f010e74e:	b8 01 00 00 00       	mov    $0x1,%eax
f010e753:	eb 05                	jmp    f010e75a <isPageReplacmentAlgorithmCLOCK+0x19>
f010e755:	b8 00 00 00 00       	mov    $0x0,%eax
f010e75a:	5d                   	pop    %ebp
f010e75b:	c3                   	ret    

f010e75c <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010e75c:	55                   	push   %ebp
f010e75d:	89 e5                	mov    %esp,%ebp
f010e75f:	a1 10 4a 5f f0       	mov    0xf05f4a10,%eax
f010e764:	83 f8 04             	cmp    $0x4,%eax
f010e767:	75 07                	jne    f010e770 <isPageReplacmentAlgorithmFIFO+0x14>
f010e769:	b8 01 00 00 00       	mov    $0x1,%eax
f010e76e:	eb 05                	jmp    f010e775 <isPageReplacmentAlgorithmFIFO+0x19>
f010e770:	b8 00 00 00 00       	mov    $0x0,%eax
f010e775:	5d                   	pop    %ebp
f010e776:	c3                   	ret    

f010e777 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010e777:	55                   	push   %ebp
f010e778:	89 e5                	mov    %esp,%ebp
f010e77a:	a1 10 4a 5f f0       	mov    0xf05f4a10,%eax
f010e77f:	83 f8 05             	cmp    $0x5,%eax
f010e782:	75 07                	jne    f010e78b <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010e784:	b8 01 00 00 00       	mov    $0x1,%eax
f010e789:	eb 05                	jmp    f010e790 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010e78b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e790:	5d                   	pop    %ebp
f010e791:	c3                   	ret    

f010e792 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010e792:	55                   	push   %ebp
f010e793:	89 e5                	mov    %esp,%ebp
f010e795:	a1 10 4a 5f f0       	mov    0xf05f4a10,%eax
f010e79a:	83 f8 07             	cmp    $0x7,%eax
f010e79d:	75 07                	jne    f010e7a6 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010e79f:	b8 01 00 00 00       	mov    $0x1,%eax
f010e7a4:	eb 05                	jmp    f010e7ab <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010e7a6:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7ab:	5d                   	pop    %ebp
f010e7ac:	c3                   	ret    

f010e7ad <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010e7ad:	55                   	push   %ebp
f010e7ae:	89 e5                	mov    %esp,%ebp
f010e7b0:	a1 10 4a 5f f0       	mov    0xf05f4a10,%eax
f010e7b5:	83 f8 06             	cmp    $0x6,%eax
f010e7b8:	75 07                	jne    f010e7c1 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010e7ba:	b8 01 00 00 00       	mov    $0x1,%eax
f010e7bf:	eb 05                	jmp    f010e7c6 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010e7c1:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7c6:	5d                   	pop    %ebp
f010e7c7:	c3                   	ret    

f010e7c8 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010e7c8:	55                   	push   %ebp
f010e7c9:	89 e5                	mov    %esp,%ebp
f010e7cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7ce:	a3 b8 47 5f f0       	mov    %eax,0xf05f47b8
f010e7d3:	90                   	nop
f010e7d4:	5d                   	pop    %ebp
f010e7d5:	c3                   	ret    

f010e7d6 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010e7d6:	55                   	push   %ebp
f010e7d7:	89 e5                	mov    %esp,%ebp
f010e7d9:	a1 b8 47 5f f0       	mov    0xf05f47b8,%eax
f010e7de:	5d                   	pop    %ebp
f010e7df:	c3                   	ret    

f010e7e0 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010e7e0:	55                   	push   %ebp
f010e7e1:	89 e5                	mov    %esp,%ebp
f010e7e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7e6:	a3 94 4a 5f f0       	mov    %eax,0xf05f4a94
f010e7eb:	90                   	nop
f010e7ec:	5d                   	pop    %ebp
f010e7ed:	c3                   	ret    

f010e7ee <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010e7ee:	55                   	push   %ebp
f010e7ef:	89 e5                	mov    %esp,%ebp
f010e7f1:	a1 94 4a 5f f0       	mov    0xf05f4a94,%eax
f010e7f6:	5d                   	pop    %ebp
f010e7f7:	c3                   	ret    

f010e7f8 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010e7f8:	55                   	push   %ebp
f010e7f9:	89 e5                	mov    %esp,%ebp
f010e7fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7fe:	a3 30 4b 5f f0       	mov    %eax,0xf05f4b30
f010e803:	90                   	nop
f010e804:	5d                   	pop    %ebp
f010e805:	c3                   	ret    

f010e806 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010e806:	55                   	push   %ebp
f010e807:	89 e5                	mov    %esp,%ebp
f010e809:	a1 30 4b 5f f0       	mov    0xf05f4b30,%eax
f010e80e:	5d                   	pop    %ebp
f010e80f:	c3                   	ret    

f010e810 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010e810:	55                   	push   %ebp
f010e811:	89 e5                	mov    %esp,%ebp
f010e813:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e816:	0f 20 d0             	mov    %cr2,%eax
f010e819:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010e81c:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010e81f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010e822:	e8 e4 c3 ff ff       	call   f010ac0b <get_cpu_proc>
f010e827:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010e82a:	a1 4c c0 5c f0       	mov    0xf05cc04c,%eax
f010e82f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e832:	75 50                	jne    f010e884 <fault_handler+0x74>
f010e834:	a1 58 c0 5c f0       	mov    0xf05cc058,%eax
f010e839:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010e83c:	75 46                	jne    f010e884 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010e83e:	a0 54 c0 5c f0       	mov    0xf05cc054,%al
f010e843:	40                   	inc    %eax
f010e844:	a2 54 c0 5c f0       	mov    %al,0xf05cc054
		if (num_repeated_fault == 3)
f010e849:	a0 54 c0 5c f0       	mov    0xf05cc054,%al
f010e84e:	3c 03                	cmp    $0x3,%al
f010e850:	75 4d                	jne    f010e89f <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010e852:	83 ec 0c             	sub    $0xc,%esp
f010e855:	ff 75 08             	pushl  0x8(%ebp)
f010e858:	e8 5c e9 ff ff       	call   f010d1b9 <print_trapframe>
f010e85d:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010e860:	8b 15 48 c0 5c f0    	mov    0xf05cc048,%edx
f010e866:	a1 50 c0 5c f0       	mov    0xf05cc050,%eax
f010e86b:	83 ec 08             	sub    $0x8,%esp
f010e86e:	ff 75 ec             	pushl  -0x14(%ebp)
f010e871:	52                   	push   %edx
f010e872:	50                   	push   %eax
f010e873:	68 50 69 12 f0       	push   $0xf0126950
f010e878:	6a 57                	push   $0x57
f010e87a:	68 33 69 12 f0       	push   $0xf0126933
f010e87f:	e8 b5 1a ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010e884:	a1 4c c0 5c f0       	mov    0xf05cc04c,%eax
f010e889:	a3 50 c0 5c f0       	mov    %eax,0xf05cc050
		before_last_eip = last_eip;
f010e88e:	a1 44 c0 5c f0       	mov    0xf05cc044,%eax
f010e893:	a3 48 c0 5c f0       	mov    %eax,0xf05cc048
		num_repeated_fault = 0;
f010e898:	c6 05 54 c0 5c f0 00 	movb   $0x0,0xf05cc054
	}
	last_eip = (uint32)tf->tf_eip;
f010e89f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8a2:	8b 40 30             	mov    0x30(%eax),%eax
f010e8a5:	a3 44 c0 5c f0       	mov    %eax,0xf05cc044
	last_fault_va = fault_va ;
f010e8aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e8ad:	a3 4c c0 5c f0       	mov    %eax,0xf05cc04c
	last_faulted_env = cur_env;
f010e8b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8b5:	a3 58 c0 5c f0       	mov    %eax,0xf05cc058
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010e8ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010e8c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8c4:	8b 40 34             	mov    0x34(%eax),%eax
f010e8c7:	0f b7 c0             	movzwl %ax,%eax
f010e8ca:	83 e0 03             	and    $0x3,%eax
f010e8cd:	83 f8 03             	cmp    $0x3,%eax
f010e8d0:	75 07                	jne    f010e8d9 <fault_handler+0xc9>
		userTrap = 1;
f010e8d2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010e8d9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e8dd:	0f 85 c2 00 00 00    	jne    f010e9a5 <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010e8e3:	e8 b9 87 ff ff       	call   f01070a1 <mycpu>
f010e8e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010e8eb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e8ef:	74 2f                	je     f010e920 <fault_handler+0x110>
f010e8f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8f4:	8b 40 70             	mov    0x70(%eax),%eax
f010e8f7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e8fa:	77 24                	ja     f010e920 <fault_handler+0x110>
f010e8fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8ff:	8b 40 70             	mov    0x70(%eax),%eax
f010e902:	05 00 10 00 00       	add    $0x1000,%eax
f010e907:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e90a:	76 14                	jbe    f010e920 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010e90c:	83 ec 04             	sub    $0x4,%esp
f010e90f:	68 c0 69 12 f0       	push   $0xf01269c0
f010e914:	6a 6e                	push   $0x6e
f010e916:	68 33 69 12 f0       	push   $0xf0126933
f010e91b:	e8 19 1a ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010e920:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e923:	8b 40 08             	mov    0x8(%eax),%eax
f010e926:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e929:	77 5d                	ja     f010e988 <fault_handler+0x178>
f010e92b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e92e:	8b 40 08             	mov    0x8(%eax),%eax
f010e931:	05 00 10 00 00       	add    $0x1000,%eax
f010e936:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e939:	76 4d                	jbe    f010e988 <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010e93b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e93e:	ba a0 44 5f f0       	mov    $0xf05f44a0,%edx
f010e943:	29 d0                	sub    %edx,%eax
f010e945:	c1 f8 03             	sar    $0x3,%eax
f010e948:	89 c2                	mov    %eax,%edx
f010e94a:	89 d0                	mov    %edx,%eax
f010e94c:	c1 e0 02             	shl    $0x2,%eax
f010e94f:	01 d0                	add    %edx,%eax
f010e951:	01 c0                	add    %eax,%eax
f010e953:	01 d0                	add    %edx,%eax
f010e955:	c1 e0 03             	shl    $0x3,%eax
f010e958:	01 d0                	add    %edx,%eax
f010e95a:	89 c1                	mov    %eax,%ecx
f010e95c:	c1 e1 0b             	shl    $0xb,%ecx
f010e95f:	01 c8                	add    %ecx,%eax
f010e961:	c1 e0 05             	shl    $0x5,%eax
f010e964:	01 d0                	add    %edx,%eax
f010e966:	c1 e0 02             	shl    $0x2,%eax
f010e969:	01 d0                	add    %edx,%eax
f010e96b:	01 c0                	add    %eax,%eax
f010e96d:	01 d0                	add    %edx,%eax
f010e96f:	c1 e0 03             	shl    $0x3,%eax
f010e972:	01 d0                	add    %edx,%eax
f010e974:	f7 d8                	neg    %eax
f010e976:	50                   	push   %eax
f010e977:	68 e8 69 12 f0       	push   $0xf01269e8
f010e97c:	6a 70                	push   $0x70
f010e97e:	68 33 69 12 f0       	push   $0xf0126933
f010e983:	e8 b1 19 ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010e988:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010e98f:	76 3a                	jbe    f010e9cb <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010e991:	83 ec 04             	sub    $0x4,%esp
f010e994:	68 1c 6a 12 f0       	push   $0xf0126a1c
f010e999:	6a 73                	push   $0x73
f010e99b:	68 33 69 12 f0       	push   $0xf0126933
f010e9a0:	e8 94 19 ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010e9a5:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010e9ac:	76 1d                	jbe    f010e9cb <fault_handler+0x1bb>
f010e9ae:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010e9b5:	77 14                	ja     f010e9cb <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010e9b7:	83 ec 04             	sub    $0x4,%esp
f010e9ba:	68 40 6a 12 f0       	push   $0xf0126a40
f010e9bf:	6a 7b                	push   $0x7b
f010e9c1:	68 33 69 12 f0       	push   $0xf0126933
f010e9c6:	e8 6e 19 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010e9cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e9ce:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010e9d1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e9d5:	75 25                	jne    f010e9fc <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010e9d7:	83 ec 0c             	sub    $0xc,%esp
f010e9da:	ff 75 08             	pushl  0x8(%ebp)
f010e9dd:	e8 d7 e7 ff ff       	call   f010d1b9 <print_trapframe>
f010e9e2:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010e9e5:	83 ec 04             	sub    $0x4,%esp
f010e9e8:	68 61 6a 12 f0       	push   $0xf0126a61
f010e9ed:	68 84 00 00 00       	push   $0x84
f010e9f2:	68 33 69 12 f0       	push   $0xf0126933
f010e9f7:	e8 3d 19 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010e9fc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e9ff:	8b 40 64             	mov    0x64(%eax),%eax
f010ea02:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ea05:	c1 ea 16             	shr    $0x16,%edx
f010ea08:	c1 e2 02             	shl    $0x2,%edx
f010ea0b:	01 d0                	add    %edx,%eax
f010ea0d:	8b 00                	mov    (%eax),%eax
f010ea0f:	83 e0 01             	and    $0x1,%eax
f010ea12:	85 c0                	test   %eax,%eax
f010ea14:	75 28                	jne    f010ea3e <fault_handler+0x22e>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010ea16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea19:	8b 80 88 05 00 00    	mov    0x588(%eax),%eax
f010ea1f:	8d 50 01             	lea    0x1(%eax),%edx
f010ea22:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea25:	89 90 88 05 00 00    	mov    %edx,0x588(%eax)

		table_fault_handler(faulted_env, fault_va);
f010ea2b:	83 ec 08             	sub    $0x8,%esp
f010ea2e:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea31:	ff 75 e0             	pushl  -0x20(%ebp)
f010ea34:	e8 8f 00 00 00       	call   f010eac8 <table_fault_handler>
f010ea39:	83 c4 10             	add    $0x10,%esp
f010ea3c:	eb 7b                	jmp    f010eab9 <fault_handler+0x2a9>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010ea3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea41:	8b 40 64             	mov    0x64(%eax),%eax
f010ea44:	83 ec 08             	sub    $0x8,%esp
f010ea47:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea4a:	50                   	push   %eax
f010ea4b:	e8 24 a7 ff ff       	call   f0109174 <pt_get_page_permissions>
f010ea50:	83 c4 10             	add    $0x10,%esp
f010ea53:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010ea56:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ea59:	83 e0 01             	and    $0x1,%eax
f010ea5c:	85 c0                	test   %eax,%eax
f010ea5e:	74 17                	je     f010ea77 <fault_handler+0x267>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010ea60:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea63:	68 78 6a 12 f0       	push   $0xf0126a78
f010ea68:	68 a1 00 00 00       	push   $0xa1
f010ea6d:	68 33 69 12 f0       	push   $0xf0126933
f010ea72:	e8 c2 18 ff ff       	call   f0100339 <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010ea77:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea7a:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010ea80:	8d 50 01             	lea    0x1(%eax),%edx
f010ea83:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea86:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010ea8c:	e8 5d fd ff ff       	call   f010e7ee <isBufferingEnabled>
f010ea91:	84 c0                	test   %al,%al
f010ea93:	74 13                	je     f010eaa8 <fault_handler+0x298>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010ea95:	83 ec 08             	sub    $0x8,%esp
f010ea98:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea9b:	ff 75 e0             	pushl  -0x20(%ebp)
f010ea9e:	e8 9b 00 00 00       	call   f010eb3e <__page_fault_handler_with_buffering>
f010eaa3:	83 c4 10             	add    $0x10,%esp
f010eaa6:	eb 11                	jmp    f010eab9 <fault_handler+0x2a9>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010eaa8:	83 ec 08             	sub    $0x8,%esp
f010eaab:	ff 75 ec             	pushl  -0x14(%ebp)
f010eaae:	ff 75 e0             	pushl  -0x20(%ebp)
f010eab1:	e8 33 00 00 00       	call   f010eae9 <page_fault_handler>
f010eab6:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010eab9:	0f 20 d8             	mov    %cr3,%eax
f010eabc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010eabf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eac2:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010eac5:	90                   	nop
f010eac6:	c9                   	leave  
f010eac7:	c3                   	ret    

f010eac8 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010eac8:	55                   	push   %ebp
f010eac9:	89 e5                	mov    %esp,%ebp
f010eacb:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010eace:	8b 45 08             	mov    0x8(%ebp),%eax
f010ead1:	8b 40 64             	mov    0x64(%eax),%eax
f010ead4:	83 ec 08             	sub    $0x8,%esp
f010ead7:	ff 75 0c             	pushl  0xc(%ebp)
f010eada:	50                   	push   %eax
f010eadb:	e8 fa 99 ff ff       	call   f01084da <create_page_table>
f010eae0:	83 c4 10             	add    $0x10,%esp
f010eae3:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010eae6:	90                   	nop
f010eae7:	c9                   	leave  
f010eae8:	c3                   	ret    

f010eae9 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010eae9:	55                   	push   %ebp
f010eaea:	89 e5                	mov    %esp,%ebp
f010eaec:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010eaef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010eaf6:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaf9:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010eaff:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010eb02:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb05:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010eb0b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010eb0e:	76 17                	jbe    f010eb27 <page_fault_handler+0x3e>
	{
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
f010eb10:	83 ec 04             	sub    $0x4,%esp
f010eb13:	68 bc 6a 12 f0       	push   $0xf0126abc
f010eb18:	68 e6 00 00 00       	push   $0xe6
f010eb1d:	68 33 69 12 f0       	push   $0xf0126933
f010eb22:	e8 12 18 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010eb27:	83 ec 04             	sub    $0x4,%esp
f010eb2a:	68 f8 6a 12 f0       	push   $0xf0126af8
f010eb2f:	68 f0 00 00 00       	push   $0xf0
f010eb34:	68 33 69 12 f0       	push   $0xf0126933
f010eb39:	e8 fb 17 ff ff       	call   f0100339 <_panic>

f010eb3e <__page_fault_handler_with_buffering>:
	}
}

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010eb3e:	55                   	push   %ebp
f010eb3f:	89 e5                	mov    %esp,%ebp
f010eb41:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010eb44:	83 ec 04             	sub    $0x4,%esp
f010eb47:	68 38 6b 12 f0       	push   $0xf0126b38
f010eb4c:	68 f8 00 00 00       	push   $0xf8
f010eb51:	68 33 69 12 f0       	push   $0xf0126933
f010eb56:	e8 de 17 ff ff       	call   f0100339 <_panic>

f010eb5b <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010eb5b:	55                   	push   %ebp
f010eb5c:	89 e5                	mov    %esp,%ebp
f010eb5e:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010eb61:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb64:	83 c0 04             	add    $0x4,%eax
f010eb67:	83 ec 08             	sub    $0x8,%esp
f010eb6a:	ff 75 0c             	pushl  0xc(%ebp)
f010eb6d:	50                   	push   %eax
f010eb6e:	e8 29 00 01 00       	call   f011eb9c <strcpy>
f010eb73:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010eb76:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb79:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010eb7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb82:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010eb89:	90                   	nop
f010eb8a:	c9                   	leave  
f010eb8b:	c3                   	ret    

f010eb8c <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010eb8c:	55                   	push   %ebp
f010eb8d:	89 e5                	mov    %esp,%ebp
f010eb8f:	53                   	push   %ebx
f010eb90:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010eb93:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb96:	83 ec 0c             	sub    $0xc,%esp
f010eb99:	50                   	push   %eax
f010eb9a:	e8 06 02 00 00       	call   f010eda5 <holding_spinlock>
f010eb9f:	83 c4 10             	add    $0x10,%esp
f010eba2:	85 c0                	test   %eax,%eax
f010eba4:	74 18                	je     f010ebbe <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010eba6:	8b 45 08             	mov    0x8(%ebp),%eax
f010eba9:	83 c0 04             	add    $0x4,%eax
f010ebac:	50                   	push   %eax
f010ebad:	68 7c 6b 12 f0       	push   $0xf0126b7c
f010ebb2:	6a 1f                	push   $0x1f
f010ebb4:	68 b9 6b 12 f0       	push   $0xf0126bb9
f010ebb9:	e8 7b 17 ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010ebbe:	e8 a1 85 ff ff       	call   f0107164 <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010ebc3:	90                   	nop
f010ebc4:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ebca:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010ebd1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ebd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ebd7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010ebda:	f0 87 02             	lock xchg %eax,(%edx)
f010ebdd:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010ebe0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ebe3:	85 c0                	test   %eax,%eax
f010ebe5:	75 dd                	jne    f010ebc4 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010ebe7:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010ebec:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ebef:	e8 ad 84 ff ff       	call   f01070a1 <mycpu>
f010ebf4:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010ebf7:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebfa:	83 c0 48             	add    $0x48,%eax
f010ebfd:	83 ec 08             	sub    $0x8,%esp
f010ec00:	50                   	push   %eax
f010ec01:	8d 45 08             	lea    0x8(%ebp),%eax
f010ec04:	50                   	push   %eax
f010ec05:	e8 74 00 00 00       	call   f010ec7e <getcallerpcs>
f010ec0a:	83 c4 10             	add    $0x10,%esp

}
f010ec0d:	90                   	nop
f010ec0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ec11:	c9                   	leave  
f010ec12:	c3                   	ret    

f010ec13 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010ec13:	55                   	push   %ebp
f010ec14:	89 e5                	mov    %esp,%ebp
f010ec16:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010ec19:	83 ec 0c             	sub    $0xc,%esp
f010ec1c:	ff 75 08             	pushl  0x8(%ebp)
f010ec1f:	e8 81 01 00 00       	call   f010eda5 <holding_spinlock>
f010ec24:	83 c4 10             	add    $0x10,%esp
f010ec27:	85 c0                	test   %eax,%eax
f010ec29:	75 26                	jne    f010ec51 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010ec2b:	83 ec 0c             	sub    $0xc,%esp
f010ec2e:	ff 75 08             	pushl  0x8(%ebp)
f010ec31:	e8 08 01 00 00       	call   f010ed3e <printcallstack>
f010ec36:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010ec39:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec3c:	83 c0 04             	add    $0x4,%eax
f010ec3f:	50                   	push   %eax
f010ec40:	68 d0 6b 12 f0       	push   $0xf0126bd0
f010ec45:	6a 3c                	push   $0x3c
f010ec47:	68 b9 6b 12 f0       	push   $0xf0126bb9
f010ec4c:	e8 e8 16 ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010ec51:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec54:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010ec5b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec5e:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010ec65:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010ec6a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec6d:	8b 55 08             	mov    0x8(%ebp),%edx
f010ec70:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010ec76:	e8 3b 85 ff ff       	call   f01071b6 <popcli>
}
f010ec7b:	90                   	nop
f010ec7c:	c9                   	leave  
f010ec7d:	c3                   	ret    

f010ec7e <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010ec7e:	55                   	push   %ebp
f010ec7f:	89 e5                	mov    %esp,%ebp
f010ec81:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010ec84:	e8 82 bf ff ff       	call   f010ac0b <get_cpu_proc>
f010ec89:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010ec8c:	e8 10 84 ff ff       	call   f01070a1 <mycpu>
f010ec91:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010ec94:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec97:	83 e8 08             	sub    $0x8,%eax
f010ec9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010ec9d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010eca4:	eb 67                	jmp    f010ed0d <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010eca6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ecaa:	74 67                	je     f010ed13 <getcallerpcs+0x95>
f010ecac:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010ecb3:	76 5e                	jbe    f010ed13 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010ecb5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ecb8:	8b 40 08             	mov    0x8(%eax),%eax
f010ecbb:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010ecc0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ecc3:	77 10                	ja     f010ecd5 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010ecc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ecc8:	8b 40 08             	mov    0x8(%eax),%eax
f010eccb:	05 00 90 00 00       	add    $0x9000,%eax
f010ecd0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ecd3:	77 3e                	ja     f010ed13 <getcallerpcs+0x95>
f010ecd5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ecd9:	74 10                	je     f010eceb <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010ecdb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ecde:	8b 40 70             	mov    0x70(%eax),%eax
f010ece1:	05 00 80 00 00       	add    $0x8000,%eax
f010ece6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ece9:	76 28                	jbe    f010ed13 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010eceb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ecee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ecf5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecf8:	01 c2                	add    %eax,%edx
f010ecfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ecfd:	8b 40 04             	mov    0x4(%eax),%eax
f010ed00:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010ed02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed05:	8b 00                	mov    (%eax),%eax
f010ed07:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010ed0a:	ff 45 f0             	incl   -0x10(%ebp)
f010ed0d:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ed11:	7e 93                	jle    f010eca6 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010ed13:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed16:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010ed19:	eb 18                	jmp    f010ed33 <getcallerpcs+0xb5>
		pcs[i] = 0;
f010ed1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed1e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ed25:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed28:	01 d0                	add    %edx,%eax
f010ed2a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010ed30:	ff 45 f0             	incl   -0x10(%ebp)
f010ed33:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ed37:	7e e2                	jle    f010ed1b <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010ed39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010ed3c:	c9                   	leave  
f010ed3d:	c3                   	ret    

f010ed3e <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010ed3e:	55                   	push   %ebp
f010ed3f:	89 e5                	mov    %esp,%ebp
f010ed41:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010ed44:	83 ec 0c             	sub    $0xc,%esp
f010ed47:	68 0e 6c 12 f0       	push   $0xf0126c0e
f010ed4c:	e8 3a 22 ff ff       	call   f0100f8b <cprintf>
f010ed51:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010ed54:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed57:	83 c0 48             	add    $0x48,%eax
f010ed5a:	83 ec 08             	sub    $0x8,%esp
f010ed5d:	50                   	push   %eax
f010ed5e:	8d 45 08             	lea    0x8(%ebp),%eax
f010ed61:	50                   	push   %eax
f010ed62:	e8 17 ff ff ff       	call   f010ec7e <getcallerpcs>
f010ed67:	83 c4 10             	add    $0x10,%esp
f010ed6a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010ed6d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ed74:	eb 24                	jmp    f010ed9a <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010ed76:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed79:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ed7c:	83 c2 10             	add    $0x10,%edx
f010ed7f:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010ed83:	83 ec 04             	sub    $0x4,%esp
f010ed86:	50                   	push   %eax
f010ed87:	ff 75 f4             	pushl  -0xc(%ebp)
f010ed8a:	68 1e 6c 12 f0       	push   $0xf0126c1e
f010ed8f:	e8 f7 21 ff ff       	call   f0100f8b <cprintf>
f010ed94:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010ed97:	ff 45 f4             	incl   -0xc(%ebp)
f010ed9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed9d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010eda0:	7c d4                	jl     f010ed76 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010eda2:	90                   	nop
f010eda3:	c9                   	leave  
f010eda4:	c3                   	ret    

f010eda5 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010eda5:	55                   	push   %ebp
f010eda6:	89 e5                	mov    %esp,%ebp
f010eda8:	53                   	push   %ebx
f010eda9:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010edac:	e8 b3 83 ff ff       	call   f0107164 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010edb1:	8b 45 08             	mov    0x8(%ebp),%eax
f010edb4:	8b 00                	mov    (%eax),%eax
f010edb6:	85 c0                	test   %eax,%eax
f010edb8:	74 16                	je     f010edd0 <holding_spinlock+0x2b>
f010edba:	8b 45 08             	mov    0x8(%ebp),%eax
f010edbd:	8b 58 44             	mov    0x44(%eax),%ebx
f010edc0:	e8 dc 82 ff ff       	call   f01070a1 <mycpu>
f010edc5:	39 c3                	cmp    %eax,%ebx
f010edc7:	75 07                	jne    f010edd0 <holding_spinlock+0x2b>
f010edc9:	b8 01 00 00 00       	mov    $0x1,%eax
f010edce:	eb 05                	jmp    f010edd5 <holding_spinlock+0x30>
f010edd0:	b8 00 00 00 00       	mov    $0x0,%eax
f010edd5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010edd8:	e8 d9 83 ff ff       	call   f01071b6 <popcli>
	return r;
f010eddd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ede0:	83 c4 14             	add    $0x14,%esp
f010ede3:	5b                   	pop    %ebx
f010ede4:	5d                   	pop    %ebp
f010ede5:	c3                   	ret    

f010ede6 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010ede6:	55                   	push   %ebp
f010ede7:	89 e5                	mov    %esp,%ebp
f010ede9:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f010edec:	8b 45 08             	mov    0x8(%ebp),%eax
f010edef:	83 c0 74             	add    $0x74,%eax
f010edf2:	83 ec 08             	sub    $0x8,%esp
f010edf5:	68 2d 6c 12 f0       	push   $0xf0126c2d
f010edfa:	50                   	push   %eax
f010edfb:	e8 4c 01 00 00       	call   f010ef4c <init_channel>
f010ee00:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010ee03:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee06:	83 c0 04             	add    $0x4,%eax
f010ee09:	83 ec 08             	sub    $0x8,%esp
f010ee0c:	68 40 6c 12 f0       	push   $0xf0126c40
f010ee11:	50                   	push   %eax
f010ee12:	e8 44 fd ff ff       	call   f010eb5b <init_spinlock>
f010ee17:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010ee1a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee1d:	05 c4 00 00 00       	add    $0xc4,%eax
f010ee22:	83 ec 08             	sub    $0x8,%esp
f010ee25:	ff 75 0c             	pushl  0xc(%ebp)
f010ee28:	50                   	push   %eax
f010ee29:	e8 6e fd 00 00       	call   f011eb9c <strcpy>
f010ee2e:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010ee31:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee34:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010ee3a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee3d:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010ee44:	00 00 00 
}
f010ee47:	90                   	nop
f010ee48:	c9                   	leave  
f010ee49:	c3                   	ret    

f010ee4a <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010ee4a:	55                   	push   %ebp
f010ee4b:	89 e5                	mov    %esp,%ebp
f010ee4d:	53                   	push   %ebx
f010ee4e:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010ee51:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee54:	83 c0 04             	add    $0x4,%eax
f010ee57:	83 ec 0c             	sub    $0xc,%esp
f010ee5a:	50                   	push   %eax
f010ee5b:	e8 2c fd ff ff       	call   f010eb8c <acquire_spinlock>
f010ee60:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010ee63:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee66:	8b 00                	mov    (%eax),%eax
f010ee68:	85 c0                	test   %eax,%eax
f010ee6a:	74 1c                	je     f010ee88 <holding_sleeplock+0x3e>
f010ee6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee6f:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010ee75:	e8 91 bd ff ff       	call   f010ac0b <get_cpu_proc>
f010ee7a:	8b 40 10             	mov    0x10(%eax),%eax
f010ee7d:	39 c3                	cmp    %eax,%ebx
f010ee7f:	75 07                	jne    f010ee88 <holding_sleeplock+0x3e>
f010ee81:	b8 01 00 00 00       	mov    $0x1,%eax
f010ee86:	eb 05                	jmp    f010ee8d <holding_sleeplock+0x43>
f010ee88:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010ee90:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee93:	83 c0 04             	add    $0x4,%eax
f010ee96:	83 ec 0c             	sub    $0xc,%esp
f010ee99:	50                   	push   %eax
f010ee9a:	e8 74 fd ff ff       	call   f010ec13 <release_spinlock>
f010ee9f:	83 c4 10             	add    $0x10,%esp
	return r;
f010eea2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010eea5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010eea8:	c9                   	leave  
f010eea9:	c3                   	ret    

f010eeaa <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010eeaa:	55                   	push   %ebp
f010eeab:	89 e5                	mov    %esp,%ebp
f010eead:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010eeb0:	8b 45 08             	mov    0x8(%ebp),%eax
f010eeb3:	83 c0 04             	add    $0x4,%eax
f010eeb6:	83 ec 0c             	sub    $0xc,%esp
f010eeb9:	50                   	push   %eax
f010eeba:	e8 cd fc ff ff       	call   f010eb8c <acquire_spinlock>
f010eebf:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f010eec2:	eb 19                	jmp    f010eedd <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f010eec4:	8b 45 08             	mov    0x8(%ebp),%eax
f010eec7:	8d 50 04             	lea    0x4(%eax),%edx
f010eeca:	8b 45 08             	mov    0x8(%ebp),%eax
f010eecd:	83 c0 74             	add    $0x74,%eax
f010eed0:	83 ec 08             	sub    $0x8,%esp
f010eed3:	52                   	push   %edx
f010eed4:	50                   	push   %eax
f010eed5:	e8 9f 00 00 00       	call   f010ef79 <sleep>
f010eeda:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f010eedd:	8b 45 08             	mov    0x8(%ebp),%eax
f010eee0:	8b 00                	mov    (%eax),%eax
f010eee2:	85 c0                	test   %eax,%eax
f010eee4:	75 de                	jne    f010eec4 <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f010eee6:	8b 45 08             	mov    0x8(%ebp),%eax
f010eee9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f010eeef:	8b 45 08             	mov    0x8(%ebp),%eax
f010eef2:	83 c0 04             	add    $0x4,%eax
f010eef5:	83 ec 0c             	sub    $0xc,%esp
f010eef8:	50                   	push   %eax
f010eef9:	e8 15 fd ff ff       	call   f010ec13 <release_spinlock>
f010eefe:	83 c4 10             	add    $0x10,%esp

}
f010ef01:	90                   	nop
f010ef02:	c9                   	leave  
f010ef03:	c3                   	ret    

f010ef04 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f010ef04:	55                   	push   %ebp
f010ef05:	89 e5                	mov    %esp,%ebp
f010ef07:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010ef0a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef0d:	83 c0 04             	add    $0x4,%eax
f010ef10:	83 ec 0c             	sub    $0xc,%esp
f010ef13:	50                   	push   %eax
f010ef14:	e8 73 fc ff ff       	call   f010eb8c <acquire_spinlock>
f010ef19:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f010ef1c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef1f:	83 c0 74             	add    $0x74,%eax
f010ef22:	83 ec 0c             	sub    $0xc,%esp
f010ef25:	50                   	push   %eax
f010ef26:	e8 3f 01 00 00       	call   f010f06a <wakeup_all>
f010ef2b:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f010ef2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef31:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f010ef37:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef3a:	83 c0 04             	add    $0x4,%eax
f010ef3d:	83 ec 0c             	sub    $0xc,%esp
f010ef40:	50                   	push   %eax
f010ef41:	e8 cd fc ff ff       	call   f010ec13 <release_spinlock>
f010ef46:	83 c4 10             	add    $0x10,%esp
}
f010ef49:	90                   	nop
f010ef4a:	c9                   	leave  
f010ef4b:	c3                   	ret    

f010ef4c <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010ef4c:	55                   	push   %ebp
f010ef4d:	89 e5                	mov    %esp,%ebp
f010ef4f:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010ef52:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef55:	83 c0 10             	add    $0x10,%eax
f010ef58:	83 ec 08             	sub    $0x8,%esp
f010ef5b:	ff 75 0c             	pushl  0xc(%ebp)
f010ef5e:	50                   	push   %eax
f010ef5f:	e8 38 fc 00 00       	call   f011eb9c <strcpy>
f010ef64:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010ef67:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef6a:	83 ec 0c             	sub    $0xc,%esp
f010ef6d:	50                   	push   %eax
f010ef6e:	e8 94 5f ff ff       	call   f0104f07 <init_queue>
f010ef73:	83 c4 10             	add    $0x10,%esp
}
f010ef76:	90                   	nop
f010ef77:	c9                   	leave  
f010ef78:	c3                   	ret    

f010ef79 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010ef79:	55                   	push   %ebp
f010ef7a:	89 e5                	mov    %esp,%ebp
f010ef7c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f010ef7f:	83 ec 0c             	sub    $0xc,%esp
f010ef82:	68 c0 42 5f f0       	push   $0xf05f42c0
f010ef87:	e8 00 fc ff ff       	call   f010eb8c <acquire_spinlock>
f010ef8c:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f010ef8f:	e8 77 bc ff ff       	call   f010ac0b <get_cpu_proc>
f010ef94:	89 c2                	mov    %eax,%edx
f010ef96:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef99:	83 ec 08             	sub    $0x8,%esp
f010ef9c:	52                   	push   %edx
f010ef9d:	50                   	push   %eax
f010ef9e:	e8 a5 5f ff ff       	call   f0104f48 <enqueue>
f010efa3:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f010efa6:	e8 60 bc ff ff       	call   f010ac0b <get_cpu_proc>
f010efab:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f010efb2:	83 ec 0c             	sub    $0xc,%esp
f010efb5:	ff 75 0c             	pushl  0xc(%ebp)
f010efb8:	e8 56 fc ff ff       	call   f010ec13 <release_spinlock>
f010efbd:	83 c4 10             	add    $0x10,%esp
	sched();
f010efc0:	e8 bf bd ff ff       	call   f010ad84 <sched>
	release_spinlock(&(ProcessQueues.qlock));
f010efc5:	83 ec 0c             	sub    $0xc,%esp
f010efc8:	68 c0 42 5f f0       	push   $0xf05f42c0
f010efcd:	e8 41 fc ff ff       	call   f010ec13 <release_spinlock>
f010efd2:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f010efd5:	83 ec 0c             	sub    $0xc,%esp
f010efd8:	ff 75 0c             	pushl  0xc(%ebp)
f010efdb:	e8 ac fb ff ff       	call   f010eb8c <acquire_spinlock>
f010efe0:	83 c4 10             	add    $0x10,%esp
}
f010efe3:	90                   	nop
f010efe4:	c9                   	leave  
f010efe5:	c3                   	ret    

f010efe6 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010efe6:	55                   	push   %ebp
f010efe7:	89 e5                	mov    %esp,%ebp
f010efe9:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f010efec:	8b 45 08             	mov    0x8(%ebp),%eax
f010efef:	83 ec 0c             	sub    $0xc,%esp
f010eff2:	50                   	push   %eax
f010eff3:	e8 38 5f ff ff       	call   f0104f30 <queue_size>
f010eff8:	83 c4 10             	add    $0x10,%esp
f010effb:	85 c0                	test   %eax,%eax
f010effd:	74 68                	je     f010f067 <wakeup_one+0x81>
		bool locked_by_me = 0;
f010efff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f010f006:	83 ec 0c             	sub    $0xc,%esp
f010f009:	68 c0 42 5f f0       	push   $0xf05f42c0
f010f00e:	e8 92 fd ff ff       	call   f010eda5 <holding_spinlock>
f010f013:	83 c4 10             	add    $0x10,%esp
f010f016:	85 c0                	test   %eax,%eax
f010f018:	75 17                	jne    f010f031 <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f010f01a:	83 ec 0c             	sub    $0xc,%esp
f010f01d:	68 c0 42 5f f0       	push   $0xf05f42c0
f010f022:	e8 65 fb ff ff       	call   f010eb8c <acquire_spinlock>
f010f027:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f010f02a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f010f031:	8b 45 08             	mov    0x8(%ebp),%eax
f010f034:	83 ec 0c             	sub    $0xc,%esp
f010f037:	50                   	push   %eax
f010f038:	e8 9c 5f ff ff       	call   f0104fd9 <dequeue>
f010f03d:	83 c4 10             	add    $0x10,%esp
f010f040:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f010f043:	83 ec 0c             	sub    $0xc,%esp
f010f046:	ff 75 f0             	pushl  -0x10(%ebp)
f010f049:	e8 c6 61 ff ff       	call   f0105214 <sched_insert_ready0>
f010f04e:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f010f051:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f055:	74 10                	je     f010f067 <wakeup_one+0x81>
f010f057:	83 ec 0c             	sub    $0xc,%esp
f010f05a:	68 c0 42 5f f0       	push   $0xf05f42c0
f010f05f:	e8 af fb ff ff       	call   f010ec13 <release_spinlock>
f010f064:	83 c4 10             	add    $0x10,%esp
	}
}
f010f067:	90                   	nop
f010f068:	c9                   	leave  
f010f069:	c3                   	ret    

f010f06a <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010f06a:	55                   	push   %ebp
f010f06b:	89 e5                	mov    %esp,%ebp
f010f06d:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f010f070:	83 ec 0c             	sub    $0xc,%esp
f010f073:	68 c0 42 5f f0       	push   $0xf05f42c0
f010f078:	e8 0f fb ff ff       	call   f010eb8c <acquire_spinlock>
f010f07d:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f010f080:	eb 0e                	jmp    f010f090 <wakeup_all+0x26>
		wakeup_one(chan);
f010f082:	83 ec 0c             	sub    $0xc,%esp
f010f085:	ff 75 08             	pushl  0x8(%ebp)
f010f088:	e8 59 ff ff ff       	call   f010efe6 <wakeup_one>
f010f08d:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f010f090:	8b 45 08             	mov    0x8(%ebp),%eax
f010f093:	83 ec 0c             	sub    $0xc,%esp
f010f096:	50                   	push   %eax
f010f097:	e8 94 5e ff ff       	call   f0104f30 <queue_size>
f010f09c:	83 c4 10             	add    $0x10,%esp
f010f09f:	85 c0                	test   %eax,%eax
f010f0a1:	75 df                	jne    f010f082 <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f010f0a3:	83 ec 0c             	sub    $0xc,%esp
f010f0a6:	68 c0 42 5f f0       	push   $0xf05f42c0
f010f0ab:	e8 63 fb ff ff       	call   f010ec13 <release_spinlock>
f010f0b0:	83 c4 10             	add    $0x10,%esp
}
f010f0b3:	90                   	nop
f010f0b4:	c9                   	leave  
f010f0b5:	c3                   	ret    

f010f0b6 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010f0b6:	55                   	push   %ebp
f010f0b7:	89 e5                	mov    %esp,%ebp
f010f0b9:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010f0bc:	83 ec 04             	sub    $0x4,%esp
f010f0bf:	68 54 6c 12 f0       	push   $0xf0126c54
f010f0c4:	6a 13                	push   $0x13
f010f0c6:	68 7b 6c 12 f0       	push   $0xf0126c7b
f010f0cb:	e8 69 12 ff ff       	call   f0100339 <_panic>

f010f0d0 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010f0d0:	55                   	push   %ebp
f010f0d1:	89 e5                	mov    %esp,%ebp
f010f0d3:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010f0d6:	83 ec 04             	sub    $0x4,%esp
f010f0d9:	68 94 6c 12 f0       	push   $0xf0126c94
f010f0de:	6a 1b                	push   $0x1b
f010f0e0:	68 7b 6c 12 f0       	push   $0xf0126c7b
f010f0e5:	e8 4f 12 ff ff       	call   f0100339 <_panic>

f010f0ea <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010f0ea:	55                   	push   %ebp
f010f0eb:	89 e5                	mov    %esp,%ebp
f010f0ed:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010f0f0:	83 ec 04             	sub    $0x4,%esp
f010f0f3:	68 bc 6c 12 f0       	push   $0xf0126cbc
f010f0f8:	6a 24                	push   $0x24
f010f0fa:	68 7b 6c 12 f0       	push   $0xf0126c7b
f010f0ff:	e8 35 12 ff ff       	call   f0100339 <_panic>

f010f104 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010f104:	55                   	push   %ebp
f010f105:	89 e5                	mov    %esp,%ebp
f010f107:	c7 05 58 48 5f f0 01 	movl   $0x1,0xf05f4858
f010f10e:	00 00 00 
f010f111:	90                   	nop
f010f112:	5d                   	pop    %ebp
f010f113:	c3                   	ret    

f010f114 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010f114:	55                   	push   %ebp
f010f115:	89 e5                	mov    %esp,%ebp
f010f117:	c7 05 58 48 5f f0 02 	movl   $0x2,0xf05f4858
f010f11e:	00 00 00 
f010f121:	90                   	nop
f010f122:	5d                   	pop    %ebp
f010f123:	c3                   	ret    

f010f124 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010f124:	55                   	push   %ebp
f010f125:	89 e5                	mov    %esp,%ebp
f010f127:	c7 05 58 48 5f f0 03 	movl   $0x3,0xf05f4858
f010f12e:	00 00 00 
f010f131:	90                   	nop
f010f132:	5d                   	pop    %ebp
f010f133:	c3                   	ret    

f010f134 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010f134:	55                   	push   %ebp
f010f135:	89 e5                	mov    %esp,%ebp
f010f137:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f010f13c:	83 f8 01             	cmp    $0x1,%eax
f010f13f:	75 04                	jne    f010f145 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010f141:	b0 01                	mov    $0x1,%al
f010f143:	eb 02                	jmp    f010f147 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010f145:	b0 00                	mov    $0x0,%al
f010f147:	5d                   	pop    %ebp
f010f148:	c3                   	ret    

f010f149 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010f149:	55                   	push   %ebp
f010f14a:	89 e5                	mov    %esp,%ebp
f010f14c:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f010f151:	83 f8 02             	cmp    $0x2,%eax
f010f154:	75 04                	jne    f010f15a <isKHeapPlacementStrategyBESTFIT+0x11>
f010f156:	b0 01                	mov    $0x1,%al
f010f158:	eb 02                	jmp    f010f15c <isKHeapPlacementStrategyBESTFIT+0x13>
f010f15a:	b0 00                	mov    $0x0,%al
f010f15c:	5d                   	pop    %ebp
f010f15d:	c3                   	ret    

f010f15e <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010f15e:	55                   	push   %ebp
f010f15f:	89 e5                	mov    %esp,%ebp
f010f161:	a1 58 48 5f f0       	mov    0xf05f4858,%eax
f010f166:	83 f8 03             	cmp    $0x3,%eax
f010f169:	75 04                	jne    f010f16f <isKHeapPlacementStrategyNEXTFIT+0x11>
f010f16b:	b0 01                	mov    $0x1,%al
f010f16d:	eb 02                	jmp    f010f171 <isKHeapPlacementStrategyNEXTFIT+0x13>
f010f16f:	b0 00                	mov    $0x0,%al
f010f171:	5d                   	pop    %ebp
f010f172:	c3                   	ret    

f010f173 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010f173:	55                   	push   %ebp
f010f174:	89 e5                	mov    %esp,%ebp
f010f176:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010f179:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010f180:	eb 26                	jmp    f010f1a8 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010f182:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f185:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f18c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f18f:	01 c2                	add    %eax,%edx
f010f191:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f194:	40                   	inc    %eax
f010f195:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010f19c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f19f:	01 c8                	add    %ecx,%eax
f010f1a1:	8b 00                	mov    (%eax),%eax
f010f1a3:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010f1a5:	ff 45 f4             	incl   -0xc(%ebp)
f010f1a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010f1ab:	48                   	dec    %eax
f010f1ac:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f1af:	7f d1                	jg     f010f182 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010f1b1:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010f1b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010f1bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010f1c2:	eb 35                	jmp    f010f1f9 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010f1c4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f1c7:	89 d0                	mov    %edx,%eax
f010f1c9:	01 c0                	add    %eax,%eax
f010f1cb:	01 d0                	add    %edx,%eax
f010f1cd:	c1 e0 02             	shl    $0x2,%eax
f010f1d0:	05 00 cd 17 f0       	add    $0xf017cd00,%eax
f010f1d5:	8b 10                	mov    (%eax),%edx
f010f1d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1da:	8b 00                	mov    (%eax),%eax
f010f1dc:	83 ec 08             	sub    $0x8,%esp
f010f1df:	52                   	push   %edx
f010f1e0:	50                   	push   %eax
f010f1e1:	e8 73 fa 00 00       	call   f011ec59 <strcmp>
f010f1e6:	83 c4 10             	add    $0x10,%esp
f010f1e9:	85 c0                	test   %eax,%eax
f010f1eb:	75 09                	jne    f010f1f6 <tst_handler+0x83>
		{
			test_found = 1;
f010f1ed:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010f1f4:	eb 0f                	jmp    f010f205 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010f1f6:	ff 45 ec             	incl   -0x14(%ebp)
f010f1f9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f1fc:	a1 b4 cd 17 f0       	mov    0xf017cdb4,%eax
f010f201:	39 c2                	cmp    %eax,%edx
f010f203:	72 bf                	jb     f010f1c4 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010f205:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f209:	74 29                	je     f010f234 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010f20b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f20e:	89 d0                	mov    %edx,%eax
f010f210:	01 c0                	add    %eax,%eax
f010f212:	01 d0                	add    %edx,%eax
f010f214:	c1 e0 02             	shl    $0x2,%eax
f010f217:	05 08 cd 17 f0       	add    $0xf017cd08,%eax
f010f21c:	8b 00                	mov    (%eax),%eax
f010f21e:	83 ec 08             	sub    $0x8,%esp
f010f221:	ff 75 0c             	pushl  0xc(%ebp)
f010f224:	ff 75 08             	pushl  0x8(%ebp)
f010f227:	ff d0                	call   *%eax
f010f229:	83 c4 10             	add    $0x10,%esp
f010f22c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010f22f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f232:	eb 1b                	jmp    f010f24f <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010f234:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f237:	8b 00                	mov    (%eax),%eax
f010f239:	83 ec 08             	sub    $0x8,%esp
f010f23c:	50                   	push   %eax
f010f23d:	68 fc 6f 12 f0       	push   $0xf0126ffc
f010f242:	e8 44 1d ff ff       	call   f0100f8b <cprintf>
f010f247:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f24a:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010f24f:	c9                   	leave  
f010f250:	c3                   	ret    

f010f251 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010f251:	55                   	push   %ebp
f010f252:	89 e5                	mov    %esp,%ebp
f010f254:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010f257:	e8 7c d0 00 00       	call   f011c2d8 <test_three_creation_functions>
	return 0;
f010f25c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f261:	c9                   	leave  
f010f262:	c3                   	ret    

f010f263 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010f263:	55                   	push   %ebp
f010f264:	89 e5                	mov    %esp,%ebp
f010f266:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010f269:	e8 03 69 00 00       	call   f0115b71 <test_priority_normal_and_higher>
	return 0;
f010f26e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f273:	c9                   	leave  
f010f274:	c3                   	ret    

f010f275 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010f275:	55                   	push   %ebp
f010f276:	89 e5                	mov    %esp,%ebp
f010f278:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010f27b:	e8 0b 69 00 00       	call   f0115b8b <test_priority_normal_and_lower>
	return 0;
f010f280:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f285:	c9                   	leave  
f010f286:	c3                   	ret    

f010f287 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010f287:	55                   	push   %ebp
f010f288:	89 e5                	mov    %esp,%ebp
f010f28a:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010f28d:	e8 f9 d1 00 00       	call   f011c48b <test_kfreeall>
	return 0;
f010f292:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f297:	c9                   	leave  
f010f298:	c3                   	ret    

f010f299 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010f299:	55                   	push   %ebp
f010f29a:	89 e5                	mov    %esp,%ebp
f010f29c:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010f29f:	e8 04 d2 00 00       	call   f011c4a8 <test_kexpand>
	return 0;
f010f2a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f2a9:	c9                   	leave  
f010f2aa:	c3                   	ret    

f010f2ab <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010f2ab:	55                   	push   %ebp
f010f2ac:	89 e5                	mov    %esp,%ebp
f010f2ae:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010f2b1:	e8 0f d2 00 00       	call   f011c4c5 <test_kshrink>
	return 0;
f010f2b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f2bb:	c9                   	leave  
f010f2bc:	c3                   	ret    

f010f2bd <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010f2bd:	55                   	push   %ebp
f010f2be:	89 e5                	mov    %esp,%ebp
f010f2c0:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010f2c3:	e8 1a d2 00 00       	call   f011c4e2 <test_kfreelast>
	return 0;
f010f2c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f2cd:	c9                   	leave  
f010f2ce:	c3                   	ret    

f010f2cf <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010f2cf:	55                   	push   %ebp
f010f2d0:	89 e5                	mov    %esp,%ebp
f010f2d2:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010f2d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2d8:	83 c0 04             	add    $0x4,%eax
f010f2db:	8b 00                	mov    (%eax),%eax
f010f2dd:	83 ec 04             	sub    $0x4,%esp
f010f2e0:	6a 0a                	push   $0xa
f010f2e2:	6a 00                	push   $0x0
f010f2e4:	50                   	push   %eax
f010f2e5:	e8 c3 fb 00 00       	call   f011eead <strtol>
f010f2ea:	83 c4 10             	add    $0x10,%esp
f010f2ed:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010f2f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010f2f7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010f2fe:	83 ec 0c             	sub    $0xc,%esp
f010f301:	68 c0 42 5f f0       	push   $0xf05f42c0
f010f306:	e8 81 f8 ff ff       	call   f010eb8c <acquire_spinlock>
f010f30b:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010f30e:	a1 40 43 5f f0       	mov    0xf05f4340,%eax
f010f313:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f316:	eb 3b                	jmp    f010f353 <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010f318:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f31b:	83 c0 20             	add    $0x20,%eax
f010f31e:	83 ec 08             	sub    $0x8,%esp
f010f321:	68 0f 70 12 f0       	push   $0xf012700f
f010f326:	50                   	push   %eax
f010f327:	e8 2d f9 00 00       	call   f011ec59 <strcmp>
f010f32c:	83 c4 10             	add    $0x10,%esp
f010f32f:	85 c0                	test   %eax,%eax
f010f331:	75 12                	jne    f010f345 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010f333:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f337:	74 07                	je     f010f340 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010f339:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010f340:	ff 45 f4             	incl   -0xc(%ebp)
f010f343:	eb 06                	jmp    f010f34b <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010f345:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f349:	74 31                	je     f010f37c <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010f34b:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f010f350:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f353:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f357:	74 08                	je     f010f361 <tst_sc_MLFQ+0x92>
f010f359:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f35c:	8b 40 08             	mov    0x8(%eax),%eax
f010f35f:	eb 05                	jmp    f010f366 <tst_sc_MLFQ+0x97>
f010f361:	b8 00 00 00 00       	mov    $0x0,%eax
f010f366:	a3 48 43 5f f0       	mov    %eax,0xf05f4348
f010f36b:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f010f370:	85 c0                	test   %eax,%eax
f010f372:	75 a4                	jne    f010f318 <tst_sc_MLFQ+0x49>
f010f374:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f378:	75 9e                	jne    f010f318 <tst_sc_MLFQ+0x49>
f010f37a:	eb 01                	jmp    f010f37d <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010f37c:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010f37d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f380:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f383:	75 12                	jne    f010f397 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010f385:	83 ec 0c             	sub    $0xc,%esp
f010f388:	68 18 70 12 f0       	push   $0xf0127018
f010f38d:	e8 f9 1b ff ff       	call   f0100f8b <cprintf>
f010f392:	83 c4 10             	add    $0x10,%esp
f010f395:	eb 17                	jmp    f010f3ae <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010f397:	83 ec 04             	sub    $0x4,%esp
f010f39a:	68 51 70 12 f0       	push   $0xf0127051
f010f39f:	68 9b 00 00 00       	push   $0x9b
f010f3a4:	68 67 70 12 f0       	push   $0xf0127067
f010f3a9:	e8 8b 0f ff ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010f3ae:	83 ec 0c             	sub    $0xc,%esp
f010f3b1:	68 c0 42 5f f0       	push   $0xf05f42c0
f010f3b6:	e8 58 f8 ff ff       	call   f010ec13 <release_spinlock>
f010f3bb:	83 c4 10             	add    $0x10,%esp
	return 0;
f010f3be:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f3c3:	c9                   	leave  
f010f3c4:	c3                   	ret    

f010f3c5 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010f3c5:	55                   	push   %ebp
f010f3c6:	89 e5                	mov    %esp,%ebp
f010f3c8:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010f3cb:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f3cf:	74 17                	je     f010f3e8 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010f3d1:	83 ec 0c             	sub    $0xc,%esp
f010f3d4:	68 80 70 12 f0       	push   $0xf0127080
f010f3d9:	e8 ad 1b ff ff       	call   f0100f8b <cprintf>
f010f3de:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f3e1:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3e6:	eb 45                	jmp    f010f42d <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010f3e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3eb:	83 c0 04             	add    $0x4,%eax
f010f3ee:	8b 00                	mov    (%eax),%eax
f010f3f0:	83 ec 04             	sub    $0x4,%esp
f010f3f3:	6a 0a                	push   $0xa
f010f3f5:	6a 00                	push   $0x0
f010f3f7:	50                   	push   %eax
f010f3f8:	e8 b0 fa 00 00       	call   f011eead <strtol>
f010f3fd:	83 c4 10             	add    $0x10,%esp
f010f400:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010f403:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f406:	83 f8 01             	cmp    $0x1,%eax
f010f409:	74 10                	je     f010f41b <tst_bsd_nice+0x56>
f010f40b:	83 f8 02             	cmp    $0x2,%eax
f010f40e:	74 12                	je     f010f422 <tst_bsd_nice+0x5d>
f010f410:	85 c0                	test   %eax,%eax
f010f412:	75 14                	jne    f010f428 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010f414:	e8 cc d2 00 00       	call   f011c6e5 <test_bsd_nice_0>
		break;
f010f419:	eb 0d                	jmp    f010f428 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010f41b:	e8 4f d5 00 00       	call   f011c96f <test_bsd_nice_1>
		break;
f010f420:	eb 06                	jmp    f010f428 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010f422:	e8 5c d7 00 00       	call   f011cb83 <test_bsd_nice_2>
		break;
f010f427:	90                   	nop
	}
	return 0;
f010f428:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f42d:	c9                   	leave  
f010f42e:	c3                   	ret    

f010f42f <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010f42f:	55                   	push   %ebp
f010f430:	89 e5                	mov    %esp,%ebp
f010f432:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010f435:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f439:	74 17                	je     f010f452 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010f43b:	83 ec 0c             	sub    $0xc,%esp
f010f43e:	68 c0 70 12 f0       	push   $0xf01270c0
f010f443:	e8 43 1b ff ff       	call   f0100f8b <cprintf>
f010f448:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f44b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f450:	eb 0a                	jmp    f010f45c <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010f452:	e8 3f 15 00 00       	call   f0110996 <test_str2lower_function>
	return 0;
f010f457:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f45c:	c9                   	leave  
f010f45d:	c3                   	ret    

f010f45e <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010f45e:	55                   	push   %ebp
f010f45f:	89 e5                	mov    %esp,%ebp
f010f461:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010f464:	e8 63 11 00 00       	call   f01105cc <TestAutoCompleteCommand>
f010f469:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010f46c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f471:	c9                   	leave  
f010f472:	c3                   	ret    

f010f473 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010f473:	55                   	push   %ebp
f010f474:	89 e5                	mov    %esp,%ebp
f010f476:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f479:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f47d:	74 1a                	je     f010f499 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010f47f:	83 ec 0c             	sub    $0xc,%esp
f010f482:	68 f4 70 12 f0       	push   $0xf01270f4
f010f487:	e8 ff 1a ff ff       	call   f0100f8b <cprintf>
f010f48c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f48f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f494:	e9 2f 01 00 00       	jmp    f010f5c8 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010f499:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f49c:	83 c0 04             	add    $0x4,%eax
f010f49f:	8b 00                	mov    (%eax),%eax
f010f4a1:	83 ec 08             	sub    $0x8,%esp
f010f4a4:	68 31 71 12 f0       	push   $0xf0127131
f010f4a9:	50                   	push   %eax
f010f4aa:	e8 aa f7 00 00       	call   f011ec59 <strcmp>
f010f4af:	83 c4 10             	add    $0x10,%esp
f010f4b2:	85 c0                	test   %eax,%eax
f010f4b4:	75 0a                	jne    f010f4c0 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010f4b6:	e8 40 08 00 00       	call   f010fcfb <test_initialize_dynamic_allocator>
f010f4bb:	e9 03 01 00 00       	jmp    f010f5c3 <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010f4c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4c3:	83 c0 04             	add    $0x4,%eax
f010f4c6:	8b 00                	mov    (%eax),%eax
f010f4c8:	83 ec 08             	sub    $0x8,%esp
f010f4cb:	68 36 71 12 f0       	push   $0xf0127136
f010f4d0:	50                   	push   %eax
f010f4d1:	e8 83 f7 00 00       	call   f011ec59 <strcmp>
f010f4d6:	83 c4 10             	add    $0x10,%esp
f010f4d9:	85 c0                	test   %eax,%eax
f010f4db:	75 0a                	jne    f010f4e7 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010f4dd:	e8 4d 08 00 00       	call   f010fd2f <test_alloc_block_FF>
f010f4e2:	e9 dc 00 00 00       	jmp    f010f5c3 <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010f4e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4ea:	83 c0 04             	add    $0x4,%eax
f010f4ed:	8b 00                	mov    (%eax),%eax
f010f4ef:	83 ec 08             	sub    $0x8,%esp
f010f4f2:	68 3e 71 12 f0       	push   $0xf012713e
f010f4f7:	50                   	push   %eax
f010f4f8:	e8 5c f7 00 00       	call   f011ec59 <strcmp>
f010f4fd:	83 c4 10             	add    $0x10,%esp
f010f500:	85 c0                	test   %eax,%eax
f010f502:	75 0a                	jne    f010f50e <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010f504:	e8 43 08 00 00       	call   f010fd4c <test_alloc_block_BF>
f010f509:	e9 b5 00 00 00       	jmp    f010f5c3 <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010f50e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f511:	83 c0 04             	add    $0x4,%eax
f010f514:	8b 00                	mov    (%eax),%eax
f010f516:	83 ec 08             	sub    $0x8,%esp
f010f519:	68 46 71 12 f0       	push   $0xf0127146
f010f51e:	50                   	push   %eax
f010f51f:	e8 35 f7 00 00       	call   f011ec59 <strcmp>
f010f524:	83 c4 10             	add    $0x10,%esp
f010f527:	85 c0                	test   %eax,%eax
f010f529:	75 0a                	jne    f010f535 <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010f52b:	e8 3c 08 00 00       	call   f010fd6c <test_alloc_block_NF>
f010f530:	e9 8e 00 00 00       	jmp    f010f5c3 <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010f535:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f538:	83 c0 04             	add    $0x4,%eax
f010f53b:	8b 00                	mov    (%eax),%eax
f010f53d:	83 ec 08             	sub    $0x8,%esp
f010f540:	68 4e 71 12 f0       	push   $0xf012714e
f010f545:	50                   	push   %eax
f010f546:	e8 0e f7 00 00       	call   f011ec59 <strcmp>
f010f54b:	83 c4 10             	add    $0x10,%esp
f010f54e:	85 c0                	test   %eax,%eax
f010f550:	75 07                	jne    f010f559 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f010f552:	e8 1b 08 00 00       	call   f010fd72 <test_free_block_FF>
f010f557:	eb 6a                	jmp    f010f5c3 <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f010f559:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f55c:	83 c0 04             	add    $0x4,%eax
f010f55f:	8b 00                	mov    (%eax),%eax
f010f561:	83 ec 08             	sub    $0x8,%esp
f010f564:	68 55 71 12 f0       	push   $0xf0127155
f010f569:	50                   	push   %eax
f010f56a:	e8 ea f6 00 00       	call   f011ec59 <strcmp>
f010f56f:	83 c4 10             	add    $0x10,%esp
f010f572:	85 c0                	test   %eax,%eax
f010f574:	75 07                	jne    f010f57d <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f010f576:	e8 14 08 00 00       	call   f010fd8f <test_free_block_BF>
f010f57b:	eb 46                	jmp    f010f5c3 <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f010f57d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f580:	83 c0 04             	add    $0x4,%eax
f010f583:	8b 00                	mov    (%eax),%eax
f010f585:	83 ec 08             	sub    $0x8,%esp
f010f588:	68 5c 71 12 f0       	push   $0xf012715c
f010f58d:	50                   	push   %eax
f010f58e:	e8 c6 f6 00 00       	call   f011ec59 <strcmp>
f010f593:	83 c4 10             	add    $0x10,%esp
f010f596:	85 c0                	test   %eax,%eax
f010f598:	75 07                	jne    f010f5a1 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f010f59a:	e8 0d 08 00 00       	call   f010fdac <test_free_block_NF>
f010f59f:	eb 22                	jmp    f010f5c3 <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f010f5a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5a4:	83 c0 04             	add    $0x4,%eax
f010f5a7:	8b 00                	mov    (%eax),%eax
f010f5a9:	83 ec 08             	sub    $0x8,%esp
f010f5ac:	68 63 71 12 f0       	push   $0xf0127163
f010f5b1:	50                   	push   %eax
f010f5b2:	e8 a2 f6 00 00       	call   f011ec59 <strcmp>
f010f5b7:	83 c4 10             	add    $0x10,%esp
f010f5ba:	85 c0                	test   %eax,%eax
f010f5bc:	75 05                	jne    f010f5c3 <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f010f5be:	e8 06 08 00 00       	call   f010fdc9 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f010f5c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f5c8:	c9                   	leave  
f010f5c9:	c3                   	ret    

f010f5ca <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f010f5ca:	55                   	push   %ebp
f010f5cb:	89 e5                	mov    %esp,%ebp
f010f5cd:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f5d0:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f5d4:	74 1a                	je     f010f5f0 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f010f5d6:	83 ec 0c             	sub    $0xc,%esp
f010f5d9:	68 70 71 12 f0       	push   $0xf0127170
f010f5de:	e8 a8 19 ff ff       	call   f0100f8b <cprintf>
f010f5e3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f5e6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f5eb:	e9 e1 00 00 00       	jmp    f010f6d1 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f010f5f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5f3:	83 c0 04             	add    $0x4,%eax
f010f5f6:	8b 00                	mov    (%eax),%eax
f010f5f8:	83 ec 08             	sub    $0x8,%esp
f010f5fb:	68 a9 71 12 f0       	push   $0xf01271a9
f010f600:	50                   	push   %eax
f010f601:	e8 53 f6 00 00       	call   f011ec59 <strcmp>
f010f606:	83 c4 10             	add    $0x10,%esp
f010f609:	85 c0                	test   %eax,%eax
f010f60b:	75 0a                	jne    f010f617 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f010f60d:	e8 97 1c 00 00       	call   f01112a9 <test_cut_paste_pages>
f010f612:	e9 b5 00 00 00       	jmp    f010f6cc <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f010f617:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f61a:	83 c0 04             	add    $0x4,%eax
f010f61d:	8b 00                	mov    (%eax),%eax
f010f61f:	83 ec 08             	sub    $0x8,%esp
f010f622:	68 b2 71 12 f0       	push   $0xf01271b2
f010f627:	50                   	push   %eax
f010f628:	e8 2c f6 00 00       	call   f011ec59 <strcmp>
f010f62d:	83 c4 10             	add    $0x10,%esp
f010f630:	85 c0                	test   %eax,%eax
f010f632:	75 0a                	jne    f010f63e <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f010f634:	e8 bb 26 00 00       	call   f0111cf4 <test_copy_paste_chunk>
f010f639:	e9 8e 00 00 00       	jmp    f010f6cc <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f010f63e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f641:	83 c0 04             	add    $0x4,%eax
f010f644:	8b 00                	mov    (%eax),%eax
f010f646:	83 ec 08             	sub    $0x8,%esp
f010f649:	68 bc 71 12 f0       	push   $0xf01271bc
f010f64e:	50                   	push   %eax
f010f64f:	e8 05 f6 00 00       	call   f011ec59 <strcmp>
f010f654:	83 c4 10             	add    $0x10,%esp
f010f657:	85 c0                	test   %eax,%eax
f010f659:	75 07                	jne    f010f662 <tst_chunks+0x98>
	{
		test_share_chunk();
f010f65b:	e8 92 37 00 00       	call   f0112df2 <test_share_chunk>
f010f660:	eb 6a                	jmp    f010f6cc <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f010f662:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f665:	83 c0 04             	add    $0x4,%eax
f010f668:	8b 00                	mov    (%eax),%eax
f010f66a:	83 ec 08             	sub    $0x8,%esp
f010f66d:	68 c2 71 12 f0       	push   $0xf01271c2
f010f672:	50                   	push   %eax
f010f673:	e8 e1 f5 00 00       	call   f011ec59 <strcmp>
f010f678:	83 c4 10             	add    $0x10,%esp
f010f67b:	85 c0                	test   %eax,%eax
f010f67d:	75 07                	jne    f010f686 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f010f67f:	e8 96 41 00 00       	call   f011381a <test_allocate_chunk>
f010f684:	eb 46                	jmp    f010f6cc <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f010f686:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f689:	83 c0 04             	add    $0x4,%eax
f010f68c:	8b 00                	mov    (%eax),%eax
f010f68e:	83 ec 08             	sub    $0x8,%esp
f010f691:	68 cb 71 12 f0       	push   $0xf01271cb
f010f696:	50                   	push   %eax
f010f697:	e8 bd f5 00 00       	call   f011ec59 <strcmp>
f010f69c:	83 c4 10             	add    $0x10,%esp
f010f69f:	85 c0                	test   %eax,%eax
f010f6a1:	75 07                	jne    f010f6aa <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f010f6a3:	e8 79 4a 00 00       	call   f0114121 <test_calculate_required_frames>
f010f6a8:	eb 22                	jmp    f010f6cc <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f010f6aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6ad:	83 c0 04             	add    $0x4,%eax
f010f6b0:	8b 00                	mov    (%eax),%eax
f010f6b2:	83 ec 08             	sub    $0x8,%esp
f010f6b5:	68 da 71 12 f0       	push   $0xf01271da
f010f6ba:	50                   	push   %eax
f010f6bb:	e8 99 f5 00 00       	call   f011ec59 <strcmp>
f010f6c0:	83 c4 10             	add    $0x10,%esp
f010f6c3:	85 c0                	test   %eax,%eax
f010f6c5:	75 05                	jne    f010f6cc <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f010f6c7:	e8 c9 52 00 00       	call   f0114995 <test_calculate_allocated_space>
	}
	return 0;
f010f6cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f6d1:	c9                   	leave  
f010f6d2:	c3                   	ret    

f010f6d3 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f010f6d3:	55                   	push   %ebp
f010f6d4:	89 e5                	mov    %esp,%ebp
f010f6d6:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f6d9:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f6dd:	74 1a                	je     f010f6f9 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f010f6df:	83 ec 0c             	sub    $0xc,%esp
f010f6e2:	68 ec 71 12 f0       	push   $0xf01271ec
f010f6e7:	e8 9f 18 ff ff       	call   f0100f8b <cprintf>
f010f6ec:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f6ef:	b8 00 00 00 00       	mov    $0x0,%eax
f010f6f4:	e9 ba 00 00 00       	jmp    f010f7b3 <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f010f6f9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6fc:	83 c0 04             	add    $0x4,%eax
f010f6ff:	8b 00                	mov    (%eax),%eax
f010f701:	83 ec 08             	sub    $0x8,%esp
f010f704:	68 22 72 12 f0       	push   $0xf0127222
f010f709:	50                   	push   %eax
f010f70a:	e8 4a f5 00 00       	call   f011ec59 <strcmp>
f010f70f:	83 c4 10             	add    $0x10,%esp
f010f712:	85 c0                	test   %eax,%eax
f010f714:	75 0a                	jne    f010f720 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f010f716:	e8 01 16 00 00       	call   f0110d1c <test_pt_set_page_permissions>
f010f71b:	e9 8e 00 00 00       	jmp    f010f7ae <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f010f720:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f723:	83 c0 04             	add    $0x4,%eax
f010f726:	8b 00                	mov    (%eax),%eax
f010f728:	83 ec 08             	sub    $0x8,%esp
f010f72b:	68 2a 72 12 f0       	push   $0xf012722a
f010f730:	50                   	push   %eax
f010f731:	e8 23 f5 00 00       	call   f011ec59 <strcmp>
f010f736:	83 c4 10             	add    $0x10,%esp
f010f739:	85 c0                	test   %eax,%eax
f010f73b:	75 07                	jne    f010f744 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f010f73d:	e8 49 18 00 00       	call   f0110f8b <test_pt_set_page_permissions_invalid_va>
f010f742:	eb 6a                	jmp    f010f7ae <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f010f744:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f747:	83 c0 04             	add    $0x4,%eax
f010f74a:	8b 00                	mov    (%eax),%eax
f010f74c:	83 ec 08             	sub    $0x8,%esp
f010f74f:	68 32 72 12 f0       	push   $0xf0127232
f010f754:	50                   	push   %eax
f010f755:	e8 ff f4 00 00       	call   f011ec59 <strcmp>
f010f75a:	83 c4 10             	add    $0x10,%esp
f010f75d:	85 c0                	test   %eax,%eax
f010f75f:	75 07                	jne    f010f768 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f010f761:	e8 6e 18 00 00       	call   f0110fd4 <test_pt_get_page_permissions>
f010f766:	eb 46                	jmp    f010f7ae <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f010f768:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f76b:	83 c0 04             	add    $0x4,%eax
f010f76e:	8b 00                	mov    (%eax),%eax
f010f770:	83 ec 08             	sub    $0x8,%esp
f010f773:	68 3a 72 12 f0       	push   $0xf012723a
f010f778:	50                   	push   %eax
f010f779:	e8 db f4 00 00       	call   f011ec59 <strcmp>
f010f77e:	83 c4 10             	add    $0x10,%esp
f010f781:	85 c0                	test   %eax,%eax
f010f783:	75 07                	jne    f010f78c <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f010f785:	e8 8e 19 00 00       	call   f0111118 <test_pt_clear_page_table_entry>
f010f78a:	eb 22                	jmp    f010f7ae <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f010f78c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f78f:	83 c0 04             	add    $0x4,%eax
f010f792:	8b 00                	mov    (%eax),%eax
f010f794:	83 ec 08             	sub    $0x8,%esp
f010f797:	68 41 72 12 f0       	push   $0xf0127241
f010f79c:	50                   	push   %eax
f010f79d:	e8 b7 f4 00 00       	call   f011ec59 <strcmp>
f010f7a2:	83 c4 10             	add    $0x10,%esp
f010f7a5:	85 c0                	test   %eax,%eax
f010f7a7:	75 05                	jne    f010f7ae <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f010f7a9:	e8 c3 1a 00 00       	call   f0111271 <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f010f7ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f7b3:	c9                   	leave  
f010f7b4:	c3                   	ret    

f010f7b5 <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f010f7b5:	55                   	push   %ebp
f010f7b6:	89 e5                	mov    %esp,%ebp
f010f7b8:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f010f7bb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7be:	83 c0 08             	add    $0x8,%eax
f010f7c1:	8b 00                	mov    (%eax),%eax
f010f7c3:	83 ec 08             	sub    $0x8,%esp
f010f7c6:	68 48 72 12 f0       	push   $0xf0127248
f010f7cb:	50                   	push   %eax
f010f7cc:	e8 88 f4 00 00       	call   f011ec59 <strcmp>
f010f7d1:	83 c4 10             	add    $0x10,%esp
f010f7d4:	85 c0                	test   %eax,%eax
f010f7d6:	75 20                	jne    f010f7f8 <tst_kheap+0x43>
f010f7d8:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010f7dc:	74 1a                	je     f010f7f8 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f010f7de:	83 ec 0c             	sub    $0xc,%esp
f010f7e1:	68 50 72 12 f0       	push   $0xf0127250
f010f7e6:	e8 a0 17 ff ff       	call   f0100f8b <cprintf>
f010f7eb:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f7ee:	b8 00 00 00 00       	mov    $0x0,%eax
f010f7f3:	e9 42 04 00 00       	jmp    f010fc3a <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f010f7f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7fb:	83 c0 08             	add    $0x8,%eax
f010f7fe:	8b 00                	mov    (%eax),%eax
f010f800:	83 ec 08             	sub    $0x8,%esp
f010f803:	68 48 72 12 f0       	push   $0xf0127248
f010f808:	50                   	push   %eax
f010f809:	e8 4b f4 00 00       	call   f011ec59 <strcmp>
f010f80e:	83 c4 10             	add    $0x10,%esp
f010f811:	85 c0                	test   %eax,%eax
f010f813:	74 43                	je     f010f858 <tst_kheap+0xa3>
f010f815:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010f819:	74 3d                	je     f010f858 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f010f81b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f81e:	83 c0 08             	add    $0x8,%eax
f010f821:	8b 00                	mov    (%eax),%eax
f010f823:	83 ec 08             	sub    $0x8,%esp
f010f826:	68 a0 72 12 f0       	push   $0xf01272a0
f010f82b:	50                   	push   %eax
f010f82c:	e8 28 f4 00 00       	call   f011ec59 <strcmp>
f010f831:	83 c4 10             	add    $0x10,%esp
f010f834:	85 c0                	test   %eax,%eax
f010f836:	74 20                	je     f010f858 <tst_kheap+0xa3>
f010f838:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f010f83c:	74 1a                	je     f010f858 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f010f83e:	83 ec 0c             	sub    $0xc,%esp
f010f841:	68 ac 72 12 f0       	push   $0xf01272ac
f010f846:	e8 40 17 ff ff       	call   f0100f8b <cprintf>
f010f84b:	83 c4 10             	add    $0x10,%esp
			return 0;
f010f84e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f853:	e9 e2 03 00 00       	jmp    f010fc3a <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f010f858:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f85b:	83 c0 04             	add    $0x4,%eax
f010f85e:	8b 00                	mov    (%eax),%eax
f010f860:	83 ec 08             	sub    $0x8,%esp
f010f863:	68 f1 72 12 f0       	push   $0xf01272f1
f010f868:	50                   	push   %eax
f010f869:	e8 eb f3 00 00       	call   f011ec59 <strcmp>
f010f86e:	83 c4 10             	add    $0x10,%esp
f010f871:	85 c0                	test   %eax,%eax
f010f873:	74 1d                	je     f010f892 <tst_kheap+0xdd>
f010f875:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f878:	83 c0 04             	add    $0x4,%eax
f010f87b:	8b 00                	mov    (%eax),%eax
f010f87d:	83 ec 08             	sub    $0x8,%esp
f010f880:	68 f4 72 12 f0       	push   $0xf01272f4
f010f885:	50                   	push   %eax
f010f886:	e8 ce f3 00 00       	call   f011ec59 <strcmp>
f010f88b:	83 c4 10             	add    $0x10,%esp
f010f88e:	85 c0                	test   %eax,%eax
f010f890:	75 1a                	jne    f010f8ac <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f010f892:	e8 6d f8 ff ff       	call   f010f104 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010f897:	83 ec 0c             	sub    $0xc,%esp
f010f89a:	68 f8 72 12 f0       	push   $0xf01272f8
f010f89f:	e8 e7 16 ff ff       	call   f0100f8b <cprintf>
f010f8a4:	83 c4 10             	add    $0x10,%esp
f010f8a7:	e9 a0 00 00 00       	jmp    f010f94c <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f010f8ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8af:	83 c0 04             	add    $0x4,%eax
f010f8b2:	8b 00                	mov    (%eax),%eax
f010f8b4:	83 ec 08             	sub    $0x8,%esp
f010f8b7:	68 25 73 12 f0       	push   $0xf0127325
f010f8bc:	50                   	push   %eax
f010f8bd:	e8 97 f3 00 00       	call   f011ec59 <strcmp>
f010f8c2:	83 c4 10             	add    $0x10,%esp
f010f8c5:	85 c0                	test   %eax,%eax
f010f8c7:	74 1d                	je     f010f8e6 <tst_kheap+0x131>
f010f8c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8cc:	83 c0 04             	add    $0x4,%eax
f010f8cf:	8b 00                	mov    (%eax),%eax
f010f8d1:	83 ec 08             	sub    $0x8,%esp
f010f8d4:	68 28 73 12 f0       	push   $0xf0127328
f010f8d9:	50                   	push   %eax
f010f8da:	e8 7a f3 00 00       	call   f011ec59 <strcmp>
f010f8df:	83 c4 10             	add    $0x10,%esp
f010f8e2:	85 c0                	test   %eax,%eax
f010f8e4:	75 17                	jne    f010f8fd <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f010f8e6:	e8 29 f8 ff ff       	call   f010f114 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f010f8eb:	83 ec 0c             	sub    $0xc,%esp
f010f8ee:	68 2c 73 12 f0       	push   $0xf012732c
f010f8f3:	e8 93 16 ff ff       	call   f0100f8b <cprintf>
f010f8f8:	83 c4 10             	add    $0x10,%esp
f010f8fb:	eb 4f                	jmp    f010f94c <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f010f8fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f900:	83 c0 04             	add    $0x4,%eax
f010f903:	8b 00                	mov    (%eax),%eax
f010f905:	83 ec 08             	sub    $0x8,%esp
f010f908:	68 58 73 12 f0       	push   $0xf0127358
f010f90d:	50                   	push   %eax
f010f90e:	e8 46 f3 00 00       	call   f011ec59 <strcmp>
f010f913:	83 c4 10             	add    $0x10,%esp
f010f916:	85 c0                	test   %eax,%eax
f010f918:	74 1d                	je     f010f937 <tst_kheap+0x182>
f010f91a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f91d:	83 c0 04             	add    $0x4,%eax
f010f920:	8b 00                	mov    (%eax),%eax
f010f922:	83 ec 08             	sub    $0x8,%esp
f010f925:	68 5b 73 12 f0       	push   $0xf012735b
f010f92a:	50                   	push   %eax
f010f92b:	e8 29 f3 00 00       	call   f011ec59 <strcmp>
f010f930:	83 c4 10             	add    $0x10,%esp
f010f933:	85 c0                	test   %eax,%eax
f010f935:	75 15                	jne    f010f94c <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f010f937:	e8 e8 f7 ff ff       	call   f010f124 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010f93c:	83 ec 0c             	sub    $0xc,%esp
f010f93f:	68 60 73 12 f0       	push   $0xf0127360
f010f944:	e8 42 16 ff ff       	call   f0100f8b <cprintf>
f010f949:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f010f94c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f94f:	83 c0 08             	add    $0x8,%eax
f010f952:	8b 00                	mov    (%eax),%eax
f010f954:	83 ec 08             	sub    $0x8,%esp
f010f957:	68 48 72 12 f0       	push   $0xf0127248
f010f95c:	50                   	push   %eax
f010f95d:	e8 f7 f2 00 00       	call   f011ec59 <strcmp>
f010f962:	83 c4 10             	add    $0x10,%esp
f010f965:	85 c0                	test   %eax,%eax
f010f967:	0f 85 13 01 00 00    	jne    f010fa80 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f96d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f970:	83 c0 0c             	add    $0xc,%eax
f010f973:	8b 00                	mov    (%eax),%eax
f010f975:	83 ec 04             	sub    $0x4,%esp
f010f978:	6a 0a                	push   $0xa
f010f97a:	6a 00                	push   $0x0
f010f97c:	50                   	push   %eax
f010f97d:	e8 2b f5 00 00       	call   f011eead <strtol>
f010f982:	83 c4 10             	add    $0x10,%esp
f010f985:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f988:	e8 a7 f7 ff ff       	call   f010f134 <isKHeapPlacementStrategyFIRSTFIT>
f010f98d:	84 c0                	test   %al,%al
f010f98f:	74 54                	je     f010f9e5 <tst_kheap+0x230>
		{
			if (testNum == 0)
f010f991:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f995:	75 1a                	jne    f010f9b1 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f997:	83 ec 0c             	sub    $0xc,%esp
f010f99a:	68 8c 73 12 f0       	push   $0xf012738c
f010f99f:	e8 e7 15 ff ff       	call   f0100f8b <cprintf>
f010f9a4:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f9a7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9ac:	e9 89 02 00 00       	jmp    f010fc3a <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f010f9b1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f9b5:	75 0a                	jne    f010f9c1 <tst_kheap+0x20c>
				test_kmalloc();
f010f9b7:	e8 ec 61 00 00       	call   f0115ba8 <test_kmalloc>
f010f9bc:	e9 b5 00 00 00       	jmp    f010fa76 <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f9c1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f9c5:	75 0a                	jne    f010f9d1 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f010f9c7:	e8 7b 6d 00 00       	call   f0116747 <test_kmalloc_firstfit1>
f010f9cc:	e9 a5 00 00 00       	jmp    f010fa76 <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f9d1:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f9d5:	0f 85 9b 00 00 00    	jne    f010fa76 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f010f9db:	e8 4b 78 00 00       	call   f011722b <test_kmalloc_firstfit2>
f010f9e0:	e9 91 00 00 00       	jmp    f010fa76 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f010f9e5:	e8 5f f7 ff ff       	call   f010f149 <isKHeapPlacementStrategyBESTFIT>
f010f9ea:	84 c0                	test   %al,%al
f010f9ec:	74 47                	je     f010fa35 <tst_kheap+0x280>
		{
			if (testNum == 0)
f010f9ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f9f2:	75 1a                	jne    f010fa0e <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f010f9f4:	83 ec 0c             	sub    $0xc,%esp
f010f9f7:	68 dc 73 12 f0       	push   $0xf01273dc
f010f9fc:	e8 8a 15 ff ff       	call   f0100f8b <cprintf>
f010fa01:	83 c4 10             	add    $0x10,%esp
				return 0;
f010fa04:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa09:	e9 2c 02 00 00       	jmp    f010fc3a <tst_kheap+0x485>
			}
			if (testNum == 1)
f010fa0e:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010fa12:	75 07                	jne    f010fa1b <tst_kheap+0x266>
				test_kmalloc();
f010fa14:	e8 8f 61 00 00       	call   f0115ba8 <test_kmalloc>
f010fa19:	eb 5b                	jmp    f010fa76 <tst_kheap+0x2c1>
			else if (testNum == 2)
f010fa1b:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010fa1f:	75 07                	jne    f010fa28 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f010fa21:	e8 3e c8 00 00       	call   f011c264 <test_kmalloc_bestfit1>
f010fa26:	eb 4e                	jmp    f010fa76 <tst_kheap+0x2c1>
			else if (testNum == 3)
f010fa28:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010fa2c:	75 48                	jne    f010fa76 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f010fa2e:	e8 4e c8 00 00       	call   f011c281 <test_kmalloc_bestfit2>
f010fa33:	eb 41                	jmp    f010fa76 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f010fa35:	e8 24 f7 ff ff       	call   f010f15e <isKHeapPlacementStrategyNEXTFIT>
f010fa3a:	84 c0                	test   %al,%al
f010fa3c:	74 38                	je     f010fa76 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f010fa3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fa42:	75 1a                	jne    f010fa5e <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f010fa44:	83 ec 0c             	sub    $0xc,%esp
f010fa47:	68 2c 74 12 f0       	push   $0xf012742c
f010fa4c:	e8 3a 15 ff ff       	call   f0100f8b <cprintf>
f010fa51:	83 c4 10             	add    $0x10,%esp
				return 0;
f010fa54:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa59:	e9 dc 01 00 00       	jmp    f010fc3a <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f010fa5e:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010fa62:	75 07                	jne    f010fa6b <tst_kheap+0x2b6>
				test_kmalloc();
f010fa64:	e8 3f 61 00 00       	call   f0115ba8 <test_kmalloc>
f010fa69:	eb 0b                	jmp    f010fa76 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f010fa6b:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010fa6f:	75 05                	jne    f010fa76 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f010fa71:	e8 d1 c7 00 00       	call   f011c247 <test_kmalloc_nextfit>
		}
		return 0;
f010fa76:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa7b:	e9 ba 01 00 00       	jmp    f010fc3a <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f010fa80:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fa83:	83 c0 08             	add    $0x8,%eax
f010fa86:	8b 00                	mov    (%eax),%eax
f010fa88:	83 ec 08             	sub    $0x8,%esp
f010fa8b:	68 7a 74 12 f0       	push   $0xf012747a
f010fa90:	50                   	push   %eax
f010fa91:	e8 c3 f1 00 00       	call   f011ec59 <strcmp>
f010fa96:	83 c4 10             	add    $0x10,%esp
f010fa99:	85 c0                	test   %eax,%eax
f010fa9b:	75 2f                	jne    f010facc <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f010fa9d:	e8 92 f6 ff ff       	call   f010f134 <isKHeapPlacementStrategyFIRSTFIT>
f010faa2:	84 c0                	test   %al,%al
f010faa4:	74 0f                	je     f010fab5 <tst_kheap+0x300>
		{
			test_fastfirstfit();
f010faa6:	e8 87 82 00 00       	call   f0117d32 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f010faab:	b8 00 00 00 00       	mov    $0x0,%eax
f010fab0:	e9 85 01 00 00       	jmp    f010fc3a <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f010fab5:	83 ec 04             	sub    $0x4,%esp
f010fab8:	68 80 74 12 f0       	push   $0xf0127480
f010fabd:	68 ac 01 00 00       	push   $0x1ac
f010fac2:	68 67 70 12 f0       	push   $0xf0127067
f010fac7:	e8 6d 08 ff ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f010facc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010facf:	83 c0 08             	add    $0x8,%eax
f010fad2:	8b 00                	mov    (%eax),%eax
f010fad4:	83 ec 08             	sub    $0x8,%esp
f010fad7:	68 c1 74 12 f0       	push   $0xf01274c1
f010fadc:	50                   	push   %eax
f010fadd:	e8 77 f1 00 00       	call   f011ec59 <strcmp>
f010fae2:	83 c4 10             	add    $0x10,%esp
f010fae5:	85 c0                	test   %eax,%eax
f010fae7:	75 28                	jne    f010fb11 <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f010fae9:	e8 5b f6 ff ff       	call   f010f149 <isKHeapPlacementStrategyBESTFIT>
f010faee:	84 c0                	test   %al,%al
f010faf0:	75 09                	jne    f010fafb <tst_kheap+0x346>
f010faf2:	e8 3d f6 ff ff       	call   f010f134 <isKHeapPlacementStrategyFIRSTFIT>
f010faf7:	84 c0                	test   %al,%al
f010faf9:	74 07                	je     f010fb02 <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f010fafb:	e8 01 8b 00 00       	call   f0118601 <test_kfree_bestfirstfit>
f010fb00:	eb 05                	jmp    f010fb07 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f010fb02:	e8 b4 c7 00 00       	call   f011c2bb <test_kfree>
		}
		return 0;
f010fb07:	b8 00 00 00 00       	mov    $0x0,%eax
f010fb0c:	e9 29 01 00 00       	jmp    f010fc3a <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f010fb11:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb14:	83 c0 08             	add    $0x8,%eax
f010fb17:	8b 00                	mov    (%eax),%eax
f010fb19:	83 ec 08             	sub    $0x8,%esp
f010fb1c:	68 c7 74 12 f0       	push   $0xf01274c7
f010fb21:	50                   	push   %eax
f010fb22:	e8 32 f1 00 00       	call   f011ec59 <strcmp>
f010fb27:	83 c4 10             	add    $0x10,%esp
f010fb2a:	85 c0                	test   %eax,%eax
f010fb2c:	75 0f                	jne    f010fb3d <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f010fb2e:	e8 2a a1 00 00       	call   f0119c5d <test_kheap_phys_addr>
		return 0;
f010fb33:	b8 00 00 00 00       	mov    $0x0,%eax
f010fb38:	e9 fd 00 00 00       	jmp    f010fc3a <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f010fb3d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb40:	83 c0 08             	add    $0x8,%eax
f010fb43:	8b 00                	mov    (%eax),%eax
f010fb45:	83 ec 08             	sub    $0x8,%esp
f010fb48:	68 d1 74 12 f0       	push   $0xf01274d1
f010fb4d:	50                   	push   %eax
f010fb4e:	e8 06 f1 00 00       	call   f011ec59 <strcmp>
f010fb53:	83 c4 10             	add    $0x10,%esp
f010fb56:	85 c0                	test   %eax,%eax
f010fb58:	75 0f                	jne    f010fb69 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f010fb5a:	e8 e1 ae 00 00       	call   f011aa40 <test_kheap_virt_addr>
		return 0;
f010fb5f:	b8 00 00 00 00       	mov    $0x0,%eax
f010fb64:	e9 d1 00 00 00       	jmp    f010fc3a <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f010fb69:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb6c:	83 c0 08             	add    $0x8,%eax
f010fb6f:	8b 00                	mov    (%eax),%eax
f010fb71:	83 ec 08             	sub    $0x8,%esp
f010fb74:	68 a0 72 12 f0       	push   $0xf01272a0
f010fb79:	50                   	push   %eax
f010fb7a:	e8 da f0 00 00       	call   f011ec59 <strcmp>
f010fb7f:	83 c4 10             	add    $0x10,%esp
f010fb82:	85 c0                	test   %eax,%eax
f010fb84:	0f 85 89 00 00 00    	jne    f010fc13 <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010fb8a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb8d:	83 c0 0c             	add    $0xc,%eax
f010fb90:	8b 00                	mov    (%eax),%eax
f010fb92:	83 ec 04             	sub    $0x4,%esp
f010fb95:	6a 0a                	push   $0xa
f010fb97:	6a 00                	push   $0x0
f010fb99:	50                   	push   %eax
f010fb9a:	e8 0e f3 00 00       	call   f011eead <strtol>
f010fb9f:	83 c4 10             	add    $0x10,%esp
f010fba2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010fba5:	e8 8a f5 ff ff       	call   f010f134 <isKHeapPlacementStrategyFIRSTFIT>
f010fbaa:	84 c0                	test   %al,%al
f010fbac:	74 42                	je     f010fbf0 <tst_kheap+0x43b>
		{
			if (testNum == 0)
f010fbae:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fbb2:	75 17                	jne    f010fbcb <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010fbb4:	83 ec 0c             	sub    $0xc,%esp
f010fbb7:	68 8c 73 12 f0       	push   $0xf012738c
f010fbbc:	e8 ca 13 ff ff       	call   f0100f8b <cprintf>
f010fbc1:	83 c4 10             	add    $0x10,%esp
				return 0;
f010fbc4:	b8 00 00 00 00       	mov    $0x0,%eax
f010fbc9:	eb 6f                	jmp    f010fc3a <tst_kheap+0x485>
			}
			if (testNum==1)
f010fbcb:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f010fbcf:	75 07                	jne    f010fbd8 <tst_kheap+0x423>
				test_krealloc_FF1();
f010fbd1:	e8 63 c9 00 00       	call   f011c539 <test_krealloc_FF1>
f010fbd6:	eb 18                	jmp    f010fbf0 <tst_kheap+0x43b>
			else if (testNum==2)
f010fbd8:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f010fbdc:	75 07                	jne    f010fbe5 <tst_kheap+0x430>
				test_krealloc_FF2();
f010fbde:	e8 73 c9 00 00       	call   f011c556 <test_krealloc_FF2>
f010fbe3:	eb 0b                	jmp    f010fbf0 <tst_kheap+0x43b>
			else if (testNum==3)
f010fbe5:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f010fbe9:	75 05                	jne    f010fbf0 <tst_kheap+0x43b>
				test_krealloc_FF3();
f010fbeb:	e8 83 c9 00 00       	call   f011c573 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f010fbf0:	e8 69 f5 ff ff       	call   f010f15e <isKHeapPlacementStrategyNEXTFIT>
f010fbf5:	84 c0                	test   %al,%al
f010fbf7:	74 05                	je     f010fbfe <tst_kheap+0x449>
		{
			test_krealloc();
f010fbf9:	e8 01 c9 00 00       	call   f011c4ff <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f010fbfe:	e8 46 f5 ff ff       	call   f010f149 <isKHeapPlacementStrategyBESTFIT>
f010fc03:	84 c0                	test   %al,%al
f010fc05:	74 05                	je     f010fc0c <tst_kheap+0x457>
		{
			test_krealloc_BF();
f010fc07:	e8 10 c9 00 00       	call   f011c51c <test_krealloc_BF>
		}
		return 0;
f010fc0c:	b8 00 00 00 00       	mov    $0x0,%eax
f010fc11:	eb 27                	jmp    f010fc3a <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f010fc13:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc16:	83 c0 08             	add    $0x8,%eax
f010fc19:	8b 00                	mov    (%eax),%eax
f010fc1b:	83 ec 08             	sub    $0x8,%esp
f010fc1e:	68 db 74 12 f0       	push   $0xf01274db
f010fc23:	50                   	push   %eax
f010fc24:	e8 30 f0 00 00       	call   f011ec59 <strcmp>
f010fc29:	83 c4 10             	add    $0x10,%esp
f010fc2c:	85 c0                	test   %eax,%eax
f010fc2e:	75 05                	jne    f010fc35 <tst_kheap+0x480>
	{
		test_ksbrk();
f010fc30:	e8 30 bb 00 00       	call   f011b765 <test_ksbrk>
	}
	return 0;
f010fc35:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fc3a:	c9                   	leave  
f010fc3b:	c3                   	ret    

f010fc3c <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f010fc3c:	55                   	push   %ebp
f010fc3d:	89 e5                	mov    %esp,%ebp
f010fc3f:	83 ec 28             	sub    $0x28,%esp
f010fc42:	8b 45 14             	mov    0x14(%ebp),%eax
f010fc45:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f010fc48:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc4b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fc4e:	74 1d                	je     f010fc6d <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f010fc50:	83 ec 04             	sub    $0x4,%esp
f010fc53:	ff 75 08             	pushl  0x8(%ebp)
f010fc56:	ff 75 0c             	pushl  0xc(%ebp)
f010fc59:	68 e0 74 12 f0       	push   $0xf01274e0
f010fc5e:	e8 28 13 ff ff       	call   f0100f8b <cprintf>
f010fc63:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fc66:	b8 00 00 00 00       	mov    $0x0,%eax
f010fc6b:	eb 55                	jmp    f010fcc2 <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f010fc6d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc70:	8b 40 fc             	mov    -0x4(%eax),%eax
f010fc73:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f010fc76:	8b 45 10             	mov    0x10(%ebp),%eax
f010fc79:	8d 50 f8             	lea    -0x8(%eax),%edx
f010fc7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc7f:	01 d0                	add    %edx,%eax
f010fc81:	8b 00                	mov    (%eax),%eax
f010fc83:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f010fc86:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f010fc8a:	0b 45 10             	or     0x10(%ebp),%eax
f010fc8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f010fc90:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fc93:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fc96:	75 08                	jne    f010fca0 <check_block+0x64>
f010fc98:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fc9b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fc9e:	74 1d                	je     f010fcbd <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f010fca0:	ff 75 f0             	pushl  -0x10(%ebp)
f010fca3:	ff 75 f4             	pushl  -0xc(%ebp)
f010fca6:	ff 75 ec             	pushl  -0x14(%ebp)
f010fca9:	68 10 75 12 f0       	push   $0xf0127510
f010fcae:	e8 d8 12 ff ff       	call   f0100f8b <cprintf>
f010fcb3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fcb6:	b8 00 00 00 00       	mov    $0x0,%eax
f010fcbb:	eb 05                	jmp    f010fcc2 <check_block+0x86>
	}
	return 1;
f010fcbd:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010fcc2:	c9                   	leave  
f010fcc3:	c3                   	ret    

f010fcc4 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f010fcc4:	55                   	push   %ebp
f010fcc5:	89 e5                	mov    %esp,%ebp
f010fcc7:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f010fcca:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f010fccf:	3b 45 08             	cmp    0x8(%ebp),%eax
f010fcd2:	74 20                	je     f010fcf4 <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f010fcd4:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f010fcd9:	83 ec 04             	sub    $0x4,%esp
f010fcdc:	50                   	push   %eax
f010fcdd:	ff 75 08             	pushl  0x8(%ebp)
f010fce0:	68 4c 75 12 f0       	push   $0xf012754c
f010fce5:	e8 a1 12 ff ff       	call   f0100f8b <cprintf>
f010fcea:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fced:	b8 00 00 00 00       	mov    $0x0,%eax
f010fcf2:	eb 05                	jmp    f010fcf9 <check_list_size+0x35>
	}
	return 1;
f010fcf4:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010fcf9:	c9                   	leave  
f010fcfa:	c3                   	ret    

f010fcfb <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f010fcfb:	55                   	push   %ebp
f010fcfc:	89 e5                	mov    %esp,%ebp
f010fcfe:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f010fd01:	83 ec 04             	sub    $0x4,%esp
f010fd04:	68 80 75 12 f0       	push   $0xf0127580
f010fd09:	6a 3f                	push   $0x3f
f010fd0b:	68 e0 75 12 f0       	push   $0xf01275e0
f010fd10:	e8 24 06 ff ff       	call   f0100339 <_panic>

f010fd15 <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f010fd15:	55                   	push   %ebp
f010fd16:	89 e5                	mov    %esp,%ebp
f010fd18:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fd1b:	83 ec 04             	sub    $0x4,%esp
f010fd1e:	68 04 76 12 f0       	push   $0xf0127604
f010fd23:	6a 61                	push   $0x61
f010fd25:	68 e0 75 12 f0       	push   $0xf01275e0
f010fd2a:	e8 0a 06 ff ff       	call   f0100339 <_panic>

f010fd2f <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f010fd2f:	55                   	push   %ebp
f010fd30:	89 e5                	mov    %esp,%ebp
f010fd32:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fd35:	83 ec 04             	sub    $0x4,%esp
f010fd38:	68 54 76 12 f0       	push   $0xf0127654
f010fd3d:	68 e7 00 00 00       	push   $0xe7
f010fd42:	68 e0 75 12 f0       	push   $0xf01275e0
f010fd47:	e8 ed 05 ff ff       	call   f0100339 <_panic>

f010fd4c <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f010fd4c:	55                   	push   %ebp
f010fd4d:	89 e5                	mov    %esp,%ebp
f010fd4f:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fd55:	83 ec 04             	sub    $0x4,%esp
f010fd58:	68 a8 76 12 f0       	push   $0xf01276a8
f010fd5d:	68 88 01 00 00       	push   $0x188
f010fd62:	68 e0 75 12 f0       	push   $0xf01275e0
f010fd67:	e8 cd 05 ff ff       	call   f0100339 <_panic>

f010fd6c <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f010fd6c:	55                   	push   %ebp
f010fd6d:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f010fd6f:	90                   	nop
f010fd70:	5d                   	pop    %ebp
f010fd71:	c3                   	ret    

f010fd72 <test_free_block_FF>:

void test_free_block_FF()
{
f010fd72:	55                   	push   %ebp
f010fd73:	89 e5                	mov    %esp,%ebp
f010fd75:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fd78:	83 ec 04             	sub    $0x4,%esp
f010fd7b:	68 fc 76 12 f0       	push   $0xf01276fc
f010fd80:	68 4e 02 00 00       	push   $0x24e
f010fd85:	68 e0 75 12 f0       	push   $0xf01275e0
f010fd8a:	e8 aa 05 ff ff       	call   f0100339 <_panic>

f010fd8f <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f010fd8f:	55                   	push   %ebp
f010fd90:	89 e5                	mov    %esp,%ebp
f010fd92:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fd95:	83 ec 04             	sub    $0x4,%esp
f010fd98:	68 fc 76 12 f0       	push   $0xf01276fc
f010fd9d:	68 9a 03 00 00       	push   $0x39a
f010fda2:	68 e0 75 12 f0       	push   $0xf01275e0
f010fda7:	e8 8d 05 ff ff       	call   f0100339 <_panic>

f010fdac <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f010fdac:	55                   	push   %ebp
f010fdad:	89 e5                	mov    %esp,%ebp
f010fdaf:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f010fdb2:	83 ec 04             	sub    $0x4,%esp
f010fdb5:	68 49 77 12 f0       	push   $0xf0127749
f010fdba:	68 ba 04 00 00       	push   $0x4ba
f010fdbf:	68 e0 75 12 f0       	push   $0xf01275e0
f010fdc4:	e8 70 05 ff ff       	call   f0100339 <_panic>

f010fdc9 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f010fdc9:	55                   	push   %ebp
f010fdca:	89 e5                	mov    %esp,%ebp
f010fdcc:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fdcf:	83 ec 04             	sub    $0x4,%esp
f010fdd2:	68 fc 76 12 f0       	push   $0xf01276fc
f010fdd7:	68 c0 04 00 00       	push   $0x4c0
f010fddc:	68 e0 75 12 f0       	push   $0xf01275e0
f010fde1:	e8 53 05 ff ff       	call   f0100339 <_panic>

f010fde6 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f010fde6:	55                   	push   %ebp
f010fde7:	89 e5                	mov    %esp,%ebp
f010fde9:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fdec:	83 ec 04             	sub    $0x4,%esp
f010fdef:	68 fc 76 12 f0       	push   $0xf01276fc
f010fdf4:	68 e7 05 00 00       	push   $0x5e7
f010fdf9:	68 e0 75 12 f0       	push   $0xf01275e0
f010fdfe:	e8 36 05 ff ff       	call   f0100339 <_panic>

f010fe03 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f010fe03:	55                   	push   %ebp
f010fe04:	89 e5                	mov    %esp,%ebp
f010fe06:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f010fe09:	e8 fd ad ff ff       	call   f010ac0b <get_cpu_proc>
f010fe0e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f010fe11:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fe15:	75 16                	jne    f010fe2d <sys_check_LRU_lists+0x2a>
f010fe17:	68 5c 77 12 f0       	push   $0xf012775c
f010fe1c:	68 6c 77 12 f0       	push   $0xf012776c
f010fe21:	6a 10                	push   $0x10
f010fe23:	68 81 77 12 f0       	push   $0xf0127781
f010fe28:	e8 0c 05 ff ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f010fe2d:	83 ec 0c             	sub    $0xc,%esp
f010fe30:	68 a0 77 12 f0       	push   $0xf01277a0
f010fe35:	e8 51 11 ff ff       	call   f0100f8b <cprintf>
f010fe3a:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f010fe3d:	83 ec 0c             	sub    $0xc,%esp
f010fe40:	ff 75 e0             	pushl  -0x20(%ebp)
f010fe43:	e8 15 9a ff ff       	call   f010985d <env_page_ws_print>
f010fe48:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f010fe4b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fe4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f010fe51:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f010fe58:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f010fe5f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010fe63:	0f 84 a5 00 00 00    	je     f010ff0e <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f010fe69:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f010fe70:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fe73:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010fe79:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fe7c:	eb 4a                	jmp    f010fec8 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f010fe7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fe81:	8b 00                	mov    (%eax),%eax
f010fe83:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010fe86:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010fe89:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010fe8e:	89 c2                	mov    %eax,%edx
f010fe90:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe93:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010fe9a:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe9d:	01 c8                	add    %ecx,%eax
f010fe9f:	8b 00                	mov    (%eax),%eax
f010fea1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010fea4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fea7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010feac:	39 c2                	cmp    %eax,%edx
f010feae:	74 09                	je     f010feb9 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f010feb0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f010feb7:	eb 3e                	jmp    f010fef7 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f010feb9:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f010febc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010febf:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010fec5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fec8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fecc:	74 08                	je     f010fed6 <sys_check_LRU_lists+0xd3>
f010fece:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fed1:	8b 40 10             	mov    0x10(%eax),%eax
f010fed4:	eb 05                	jmp    f010fedb <sys_check_LRU_lists+0xd8>
f010fed6:	b8 00 00 00 00       	mov    $0x0,%eax
f010fedb:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fede:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f010fee4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fee7:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010feed:	85 c0                	test   %eax,%eax
f010feef:	75 8d                	jne    f010fe7e <sys_check_LRU_lists+0x7b>
f010fef1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fef5:	75 87                	jne    f010fe7e <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f010fef7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fefa:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010ff00:	8b 45 10             	mov    0x10(%ebp),%eax
f010ff03:	39 c2                	cmp    %eax,%edx
f010ff05:	74 07                	je     f010ff0e <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f010ff07:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f010ff0e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010ff12:	0f 84 a5 00 00 00    	je     f010ffbd <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f010ff18:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f010ff1f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff22:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010ff28:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ff2b:	eb 4a                	jmp    f010ff77 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f010ff2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ff30:	8b 00                	mov    (%eax),%eax
f010ff32:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010ff35:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ff38:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ff3d:	89 c2                	mov    %eax,%edx
f010ff3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ff42:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ff49:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff4c:	01 c8                	add    %ecx,%eax
f010ff4e:	8b 00                	mov    (%eax),%eax
f010ff50:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010ff53:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff56:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ff5b:	39 c2                	cmp    %eax,%edx
f010ff5d:	74 09                	je     f010ff68 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f010ff5f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f010ff66:	eb 3e                	jmp    f010ffa6 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f010ff68:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f010ff6b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff6e:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010ff74:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ff77:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ff7b:	74 08                	je     f010ff85 <sys_check_LRU_lists+0x182>
f010ff7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ff80:	8b 40 10             	mov    0x10(%eax),%eax
f010ff83:	eb 05                	jmp    f010ff8a <sys_check_LRU_lists+0x187>
f010ff85:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff8a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010ff8d:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f010ff93:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff96:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010ff9c:	85 c0                	test   %eax,%eax
f010ff9e:	75 8d                	jne    f010ff2d <sys_check_LRU_lists+0x12a>
f010ffa0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ffa4:	75 87                	jne    f010ff2d <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f010ffa6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ffa9:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010ffaf:	8b 45 14             	mov    0x14(%ebp),%eax
f010ffb2:	39 c2                	cmp    %eax,%edx
f010ffb4:	74 07                	je     f010ffbd <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f010ffb6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f010ffbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ffc0:	23 45 f0             	and    -0x10(%ebp),%eax
}
f010ffc3:	c9                   	leave  
f010ffc4:	c3                   	ret    

f010ffc5 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f010ffc5:	55                   	push   %ebp
f010ffc6:	89 e5                	mov    %esp,%ebp
f010ffc8:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f010ffcb:	e8 3b ac ff ff       	call   f010ac0b <get_cpu_proc>
f010ffd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f010ffd3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010ffd7:	75 16                	jne    f010ffef <sys_check_LRU_lists_free+0x2a>
f010ffd9:	68 5c 77 12 f0       	push   $0xf012775c
f010ffde:	68 6c 77 12 f0       	push   $0xf012776c
f010ffe3:	6a 45                	push   $0x45
f010ffe5:	68 81 77 12 f0       	push   $0xf0127781
f010ffea:	e8 4a 03 ff ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f010ffef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fff2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f010fff5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f010fffc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ffff:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f0110005:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110008:	eb 65                	jmp    f011006f <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f011000a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0110011:	eb 3a                	jmp    f011004d <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0110013:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110016:	8b 00                	mov    (%eax),%eax
f0110018:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011001b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011001e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110023:	89 c2                	mov    %eax,%edx
f0110025:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110028:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011002f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110032:	01 c8                	add    %ecx,%eax
f0110034:	8b 00                	mov    (%eax),%eax
f0110036:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0110039:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011003c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110041:	39 c2                	cmp    %eax,%edx
f0110043:	75 05                	jne    f011004a <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f0110045:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0110048:	eb 0b                	jmp    f0110055 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f011004a:	ff 45 ec             	incl   -0x14(%ebp)
f011004d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110050:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110053:	7c be                	jl     f0110013 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0110055:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110059:	7e 08                	jle    f0110063 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f011005b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011005e:	e9 ed 00 00 00       	jmp    f0110150 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110063:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110066:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f011006c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011006f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110073:	74 08                	je     f011007d <sys_check_LRU_lists_free+0xb8>
f0110075:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110078:	8b 40 10             	mov    0x10(%eax),%eax
f011007b:	eb 05                	jmp    f0110082 <sys_check_LRU_lists_free+0xbd>
f011007d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110082:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0110085:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f011008b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011008e:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f0110094:	85 c0                	test   %eax,%eax
f0110096:	0f 85 6e ff ff ff    	jne    f011000a <sys_check_LRU_lists_free+0x45>
f011009c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01100a0:	0f 85 64 ff ff ff    	jne    f011000a <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01100a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01100a9:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f01100af:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01100b2:	eb 62                	jmp    f0110116 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f01100b4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01100bb:	eb 3a                	jmp    f01100f7 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f01100bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01100c0:	8b 00                	mov    (%eax),%eax
f01100c2:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01100c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01100c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01100cd:	89 c2                	mov    %eax,%edx
f01100cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01100d2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01100d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01100dc:	01 c8                	add    %ecx,%eax
f01100de:	8b 00                	mov    (%eax),%eax
f01100e0:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01100e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01100e6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01100eb:	39 c2                	cmp    %eax,%edx
f01100ed:	75 05                	jne    f01100f4 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f01100ef:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01100f2:	eb 0b                	jmp    f01100ff <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f01100f4:	ff 45 e8             	incl   -0x18(%ebp)
f01100f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01100fa:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01100fd:	7c be                	jl     f01100bd <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01100ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110103:	7e 05                	jle    f011010a <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0110105:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110108:	eb 46                	jmp    f0110150 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011010a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011010d:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0110113:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110116:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011011a:	74 08                	je     f0110124 <sys_check_LRU_lists_free+0x15f>
f011011c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011011f:	8b 40 10             	mov    0x10(%eax),%eax
f0110122:	eb 05                	jmp    f0110129 <sys_check_LRU_lists_free+0x164>
f0110124:	b8 00 00 00 00       	mov    $0x0,%eax
f0110129:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011012c:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f0110132:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110135:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f011013b:	85 c0                	test   %eax,%eax
f011013d:	0f 85 71 ff ff ff    	jne    f01100b4 <sys_check_LRU_lists_free+0xef>
f0110143:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110147:	0f 85 67 ff ff ff    	jne    f01100b4 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f011014d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110150:	c9                   	leave  
f0110151:	c3                   	ret    

f0110152 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0110152:	55                   	push   %ebp
f0110153:	89 e5                	mov    %esp,%ebp
f0110155:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f0110158:	e8 ae aa ff ff       	call   f010ac0b <get_cpu_proc>
f011015d:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0110160:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0110164:	75 16                	jne    f011017c <sys_check_WS_list+0x2a>
f0110166:	68 5c 77 12 f0       	push   $0xf012775c
f011016b:	68 6c 77 12 f0       	push   $0xf012776c
f0110170:	6a 79                	push   $0x79
f0110172:	68 81 77 12 f0       	push   $0xf0127781
f0110177:	e8 bd 01 ff ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f011017c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011017f:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f0110182:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f0110189:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f011018d:	74 06                	je     f0110195 <sys_check_WS_list+0x43>
f011018f:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0110193:	75 1f                	jne    f01101b4 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0110195:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110198:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f011019e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101a1:	39 c2                	cmp    %eax,%edx
f01101a3:	74 0f                	je     f01101b4 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f01101a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01101ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01101af:	e9 15 03 00 00       	jmp    f01104c9 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f01101b4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01101b8:	74 39                	je     f01101f3 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f01101ba:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01101bd:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01101c3:	8b 00                	mov    (%eax),%eax
f01101c5:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01101c8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01101cb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01101d0:	89 c2                	mov    %eax,%edx
f01101d2:	8b 45 10             	mov    0x10(%ebp),%eax
f01101d5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f01101d8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01101db:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01101e0:	39 c2                	cmp    %eax,%edx
f01101e2:	74 0f                	je     f01101f3 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f01101e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01101eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01101ee:	e9 d6 02 00 00       	jmp    f01104c9 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f01101f3:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f01101f7:	0f 85 3c 01 00 00    	jne    f0110339 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f01101fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0110204:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0110208:	74 4c                	je     f0110256 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f011020a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110211:	eb 3b                	jmp    f011024e <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0110213:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110216:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011021d:	8b 45 08             	mov    0x8(%ebp),%eax
f0110220:	01 d0                	add    %edx,%eax
f0110222:	8b 00                	mov    (%eax),%eax
f0110224:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0110227:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011022a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011022f:	89 c2                	mov    %eax,%edx
f0110231:	8b 45 10             	mov    0x10(%ebp),%eax
f0110234:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0110237:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011023a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011023f:	39 c2                	cmp    %eax,%edx
f0110241:	75 08                	jne    f011024b <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f0110243:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110246:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f0110249:	eb 0b                	jmp    f0110256 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f011024b:	ff 45 e8             	incl   -0x18(%ebp)
f011024e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110251:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110254:	7c bd                	jl     f0110213 <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f0110256:	83 ec 08             	sub    $0x8,%esp
f0110259:	ff 75 ec             	pushl  -0x14(%ebp)
f011025c:	68 c8 77 12 f0       	push   $0xf01277c8
f0110261:	e8 25 0d ff ff       	call   f0100f8b <cprintf>
f0110266:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f0110269:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011026c:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f0110272:	85 c0                	test   %eax,%eax
f0110274:	74 0e                	je     f0110284 <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f0110276:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110279:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f011027f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110282:	eb 0c                	jmp    f0110290 <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0110284:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110287:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011028d:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f0110290:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110293:	8b 00                	mov    (%eax),%eax
f0110295:	83 ec 08             	sub    $0x8,%esp
f0110298:	50                   	push   %eax
f0110299:	68 e7 77 12 f0       	push   $0xf01277e7
f011029e:	e8 e8 0c ff ff       	call   f0100f8b <cprintf>
f01102a3:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f01102a6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01102ad:	eb 79                	jmp    f0110328 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f01102af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01102b2:	8b 00                	mov    (%eax),%eax
f01102b4:	89 45 b8             	mov    %eax,-0x48(%ebp)
f01102b7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01102ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01102bf:	89 c2                	mov    %eax,%edx
f01102c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01102c4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01102cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01102ce:	01 c8                	add    %ecx,%eax
f01102d0:	8b 00                	mov    (%eax),%eax
f01102d2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f01102d5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01102d8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01102dd:	39 c2                	cmp    %eax,%edx
f01102df:	74 0c                	je     f01102ed <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f01102e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01102e8:	e9 d9 01 00 00       	jmp    f01104c6 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f01102ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01102f0:	40                   	inc    %eax
f01102f1:	89 c2                	mov    %eax,%edx
f01102f3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01102f6:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f01102fc:	89 d0                	mov    %edx,%eax
f01102fe:	ba 00 00 00 00       	mov    $0x0,%edx
f0110303:	f7 f1                	div    %ecx
f0110305:	89 d0                	mov    %edx,%eax
f0110307:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f011030a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011030d:	8b 40 10             	mov    0x10(%eax),%eax
f0110310:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f0110313:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110317:	75 0c                	jne    f0110325 <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0110319:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011031c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0110322:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0110325:	ff 45 e4             	incl   -0x1c(%ebp)
f0110328:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011032b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011032e:	0f 8c 7b ff ff ff    	jl     f01102af <sys_check_WS_list+0x15d>
f0110334:	e9 8d 01 00 00       	jmp    f01104c6 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0110339:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f011033d:	74 0a                	je     f0110349 <sys_check_WS_list+0x1f7>
f011033f:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0110343:	0f 85 be 00 00 00    	jne    f0110407 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110349:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0110350:	e9 a1 00 00 00       	jmp    f01103f6 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f0110355:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011035c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011035f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0110365:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110368:	eb 47                	jmp    f01103b1 <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f011036a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011036d:	8b 00                	mov    (%eax),%eax
f011036f:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0110372:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110375:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011037a:	89 c2                	mov    %eax,%edx
f011037c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011037f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110386:	8b 45 08             	mov    0x8(%ebp),%eax
f0110389:	01 c8                	add    %ecx,%eax
f011038b:	8b 00                	mov    (%eax),%eax
f011038d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0110390:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110393:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110398:	39 c2                	cmp    %eax,%edx
f011039a:	75 09                	jne    f01103a5 <sys_check_WS_list+0x253>
				{
					found = 1;
f011039c:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f01103a3:	eb 3b                	jmp    f01103e0 <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01103a5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01103a8:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01103ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01103b1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01103b5:	74 08                	je     f01103bf <sys_check_WS_list+0x26d>
f01103b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01103ba:	8b 40 10             	mov    0x10(%eax),%eax
f01103bd:	eb 05                	jmp    f01103c4 <sys_check_WS_list+0x272>
f01103bf:	b8 00 00 00 00       	mov    $0x0,%eax
f01103c4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01103c7:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f01103cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01103d0:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01103d6:	85 c0                	test   %eax,%eax
f01103d8:	75 90                	jne    f011036a <sys_check_WS_list+0x218>
f01103da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01103de:	75 8a                	jne    f011036a <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f01103e0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01103e4:	75 0d                	jne    f01103f3 <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f01103e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01103ed:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01103ee:	e9 d3 00 00 00       	jmp    f01104c6 <sys_check_WS_list+0x374>
f01103f3:	ff 45 e0             	incl   -0x20(%ebp)
f01103f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01103f9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01103fc:	0f 8c 53 ff ff ff    	jl     f0110355 <sys_check_WS_list+0x203>
f0110402:	e9 bf 00 00 00       	jmp    f01104c6 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0110407:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f011040b:	0f 85 b5 00 00 00    	jne    f01104c6 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110411:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0110418:	e9 9d 00 00 00       	jmp    f01104ba <sys_check_WS_list+0x368>
		{
			bool found = 0;
f011041d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110424:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110427:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011042d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110430:	eb 47                	jmp    f0110479 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110432:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110435:	8b 00                	mov    (%eax),%eax
f0110437:	89 45 b0             	mov    %eax,-0x50(%ebp)
f011043a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011043d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110442:	89 c2                	mov    %eax,%edx
f0110444:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110447:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011044e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110451:	01 c8                	add    %ecx,%eax
f0110453:	8b 00                	mov    (%eax),%eax
f0110455:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0110458:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011045b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110460:	39 c2                	cmp    %eax,%edx
f0110462:	75 09                	jne    f011046d <sys_check_WS_list+0x31b>
				{
					found = 1;
f0110464:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f011046b:	eb 3b                	jmp    f01104a8 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011046d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110470:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0110476:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110479:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011047d:	74 08                	je     f0110487 <sys_check_WS_list+0x335>
f011047f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110482:	8b 40 10             	mov    0x10(%eax),%eax
f0110485:	eb 05                	jmp    f011048c <sys_check_WS_list+0x33a>
f0110487:	b8 00 00 00 00       	mov    $0x0,%eax
f011048c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011048f:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0110495:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110498:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011049e:	85 c0                	test   %eax,%eax
f01104a0:	75 90                	jne    f0110432 <sys_check_WS_list+0x2e0>
f01104a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01104a6:	75 8a                	jne    f0110432 <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f01104a8:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01104ac:	74 09                	je     f01104b7 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f01104ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01104b5:	eb 0f                	jmp    f01104c6 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01104b7:	ff 45 d8             	incl   -0x28(%ebp)
f01104ba:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01104bd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01104c0:	0f 8c 57 ff ff ff    	jl     f011041d <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f01104c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f01104c9:	c9                   	leave  
f01104ca:	c3                   	ret    

f01104cb <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f01104cb:	55                   	push   %ebp
f01104cc:	89 e5                	mov    %esp,%ebp
f01104ce:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f01104d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f01104d8:	8b 15 24 4a 5f f0    	mov    0xf05f4a24,%edx
f01104de:	8b 45 0c             	mov    0xc(%ebp),%eax
f01104e1:	39 c2                	cmp    %eax,%edx
f01104e3:	74 0a                	je     f01104ef <hasExpectedCommands+0x24>
		return 0;
f01104e5:	b8 00 00 00 00       	mov    $0x0,%eax
f01104ea:	e9 8b 00 00 00       	jmp    f011057a <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f01104ef:	a1 18 4a 5f f0       	mov    0xf05f4a18,%eax
f01104f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01104f7:	eb 55                	jmp    f011054e <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01104f9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0110500:	eb 2a                	jmp    f011052c <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f0110502:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110505:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011050c:	8b 45 08             	mov    0x8(%ebp),%eax
f011050f:	01 d0                	add    %edx,%eax
f0110511:	8b 10                	mov    (%eax),%edx
f0110513:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110516:	8b 00                	mov    (%eax),%eax
f0110518:	83 ec 08             	sub    $0x8,%esp
f011051b:	52                   	push   %edx
f011051c:	50                   	push   %eax
f011051d:	e8 37 e7 00 00       	call   f011ec59 <strcmp>
f0110522:	83 c4 10             	add    $0x10,%esp
f0110525:	85 c0                	test   %eax,%eax
f0110527:	74 0d                	je     f0110536 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0110529:	ff 45 f0             	incl   -0x10(%ebp)
f011052c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011052f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110532:	7c ce                	jl     f0110502 <hasExpectedCommands+0x37>
f0110534:	eb 01                	jmp    f0110537 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0110536:	90                   	nop
		if (i == commandsCount)
f0110537:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011053a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011053d:	75 07                	jne    f0110546 <hasExpectedCommands+0x7b>
			return 0;
f011053f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110544:	eb 34                	jmp    f011057a <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0110546:	a1 20 4a 5f f0       	mov    0xf05f4a20,%eax
f011054b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011054e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110552:	74 08                	je     f011055c <hasExpectedCommands+0x91>
f0110554:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110557:	8b 40 10             	mov    0x10(%eax),%eax
f011055a:	eb 05                	jmp    f0110561 <hasExpectedCommands+0x96>
f011055c:	b8 00 00 00 00       	mov    $0x0,%eax
f0110561:	a3 20 4a 5f f0       	mov    %eax,0xf05f4a20
f0110566:	a1 20 4a 5f f0       	mov    0xf05f4a20,%eax
f011056b:	85 c0                	test   %eax,%eax
f011056d:	75 8a                	jne    f01104f9 <hasExpectedCommands+0x2e>
f011056f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110573:	75 84                	jne    f01104f9 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f0110575:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011057a:	c9                   	leave  
f011057b:	c3                   	ret    

f011057c <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f011057c:	55                   	push   %ebp
f011057d:	89 e5                	mov    %esp,%ebp
f011057f:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0110582:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110589:	eb 2e                	jmp    f01105b9 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f011058b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011058e:	89 d0                	mov    %edx,%eax
f0110590:	01 c0                	add    %eax,%eax
f0110592:	01 d0                	add    %edx,%eax
f0110594:	c1 e0 03             	shl    $0x3,%eax
f0110597:	05 40 c5 17 f0       	add    $0xf017c540,%eax
f011059c:	8b 00                	mov    (%eax),%eax
f011059e:	83 ec 08             	sub    $0x8,%esp
f01105a1:	ff 75 08             	pushl  0x8(%ebp)
f01105a4:	50                   	push   %eax
f01105a5:	e8 af e6 00 00       	call   f011ec59 <strcmp>
f01105aa:	83 c4 10             	add    $0x10,%esp
f01105ad:	85 c0                	test   %eax,%eax
f01105af:	75 05                	jne    f01105b6 <getIndexOfCommand+0x3a>
			return i;
f01105b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01105b4:	eb 14                	jmp    f01105ca <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01105b6:	ff 45 f4             	incl   -0xc(%ebp)
f01105b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01105bc:	a1 48 c9 17 f0       	mov    0xf017c948,%eax
f01105c1:	39 c2                	cmp    %eax,%edx
f01105c3:	72 c6                	jb     f011058b <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f01105c5:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f01105ca:	c9                   	leave  
f01105cb:	c3                   	ret    

f01105cc <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f01105cc:	55                   	push   %ebp
f01105cd:	89 e5                	mov    %esp,%ebp
f01105cf:	57                   	push   %edi
f01105d0:	56                   	push   %esi
f01105d1:	53                   	push   %ebx
f01105d2:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f01105d8:	83 ec 0c             	sub    $0xc,%esp
f01105db:	68 20 78 12 f0       	push   $0xf0127820
f01105e0:	e8 a6 09 ff ff       	call   f0100f8b <cprintf>
f01105e5:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f01105e8:	83 ec 0c             	sub    $0xc,%esp
f01105eb:	68 44 78 12 f0       	push   $0xf0127844
f01105f0:	e8 96 09 ff ff       	call   f0100f8b <cprintf>
f01105f5:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f01105f8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f01105ff:	c7 45 8c 5f 78 12 f0 	movl   $0xf012785f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0110606:	83 ec 08             	sub    $0x8,%esp
f0110609:	8d 45 8c             	lea    -0x74(%ebp),%eax
f011060c:	50                   	push   %eax
f011060d:	6a 01                	push   $0x1
f011060f:	e8 bc 1b ff ff       	call   f01021d0 <process_command>
f0110614:	83 c4 10             	add    $0x10,%esp
f0110617:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f011061a:	83 ec 0c             	sub    $0xc,%esp
f011061d:	68 6c 78 12 f0       	push   $0xf012786c
f0110622:	e8 64 09 ff ff       	call   f0100f8b <cprintf>
f0110627:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f011062a:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011062d:	83 ec 0c             	sub    $0xc,%esp
f0110630:	50                   	push   %eax
f0110631:	e8 46 ff ff ff       	call   f011057c <getIndexOfCommand>
f0110636:	83 c4 10             	add    $0x10,%esp
f0110639:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011063c:	75 0f                	jne    f011064d <TestAutoCompleteCommand+0x81>
f011063e:	a1 18 4a 5f f0       	mov    0xf05f4a18,%eax
f0110643:	85 c0                	test   %eax,%eax
f0110645:	75 06                	jne    f011064d <TestAutoCompleteCommand+0x81>
		eval += 15;
f0110647:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011064b:	eb 10                	jmp    f011065d <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011064d:	83 ec 0c             	sub    $0xc,%esp
f0110650:	68 9c 78 12 f0       	push   $0xf012789c
f0110655:	e8 31 09 ff ff       	call   f0100f8b <cprintf>
f011065a:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f011065d:	83 ec 0c             	sub    $0xc,%esp
f0110660:	68 ec 78 12 f0       	push   $0xf01278ec
f0110665:	e8 21 09 ff ff       	call   f0100f8b <cprintf>
f011066a:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f011066d:	c7 45 88 12 79 12 f0 	movl   $0xf0127912,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f0110674:	83 ec 08             	sub    $0x8,%esp
f0110677:	8d 45 88             	lea    -0x78(%ebp),%eax
f011067a:	50                   	push   %eax
f011067b:	6a 01                	push   $0x1
f011067d:	e8 4e 1b ff ff       	call   f01021d0 <process_command>
f0110682:	83 c4 10             	add    $0x10,%esp
f0110685:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0110688:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011068c:	75 30                	jne    f01106be <TestAutoCompleteCommand+0xf2>
f011068e:	8d 45 90             	lea    -0x70(%ebp),%eax
f0110691:	bb f0 7c 12 f0       	mov    $0xf0127cf0,%ebx
f0110696:	ba 03 00 00 00       	mov    $0x3,%edx
f011069b:	89 c7                	mov    %eax,%edi
f011069d:	89 de                	mov    %ebx,%esi
f011069f:	89 d1                	mov    %edx,%ecx
f01106a1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01106a3:	83 ec 08             	sub    $0x8,%esp
f01106a6:	6a 03                	push   $0x3
f01106a8:	8d 45 90             	lea    -0x70(%ebp),%eax
f01106ab:	50                   	push   %eax
f01106ac:	e8 1a fe ff ff       	call   f01104cb <hasExpectedCommands>
f01106b1:	83 c4 10             	add    $0x10,%esp
f01106b4:	85 c0                	test   %eax,%eax
f01106b6:	74 06                	je     f01106be <TestAutoCompleteCommand+0xf2>
		eval += 15;
f01106b8:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01106bc:	eb 10                	jmp    f01106ce <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01106be:	83 ec 0c             	sub    $0xc,%esp
f01106c1:	68 18 79 12 f0       	push   $0xf0127918
f01106c6:	e8 c0 08 ff ff       	call   f0100f8b <cprintf>
f01106cb:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f01106ce:	83 ec 0c             	sub    $0xc,%esp
f01106d1:	68 68 79 12 f0       	push   $0xf0127968
f01106d6:	e8 b0 08 ff ff       	call   f0100f8b <cprintf>
f01106db:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f01106de:	c7 45 84 8d 79 12 f0 	movl   $0xf012798d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f01106e5:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01106e8:	83 ec 04             	sub    $0x4,%esp
f01106eb:	50                   	push   %eax
f01106ec:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01106ef:	50                   	push   %eax
f01106f0:	68 90 79 12 f0       	push   $0xf0127990
f01106f5:	e8 91 08 ff ff       	call   f0100f8b <cprintf>
f01106fa:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f01106fd:	83 ec 08             	sub    $0x8,%esp
f0110700:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0110703:	50                   	push   %eax
f0110704:	6a 01                	push   $0x1
f0110706:	e8 c5 1a ff ff       	call   f01021d0 <process_command>
f011070b:	83 c4 10             	add    $0x10,%esp
f011070e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f0110711:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0110715:	75 1b                	jne    f0110732 <TestAutoCompleteCommand+0x166>
f0110717:	83 ec 08             	sub    $0x8,%esp
f011071a:	6a 01                	push   $0x1
f011071c:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011071f:	50                   	push   %eax
f0110720:	e8 a6 fd ff ff       	call   f01104cb <hasExpectedCommands>
f0110725:	83 c4 10             	add    $0x10,%esp
f0110728:	85 c0                	test   %eax,%eax
f011072a:	74 06                	je     f0110732 <TestAutoCompleteCommand+0x166>
		eval += 15;
f011072c:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0110730:	eb 10                	jmp    f0110742 <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0110732:	83 ec 0c             	sub    $0xc,%esp
f0110735:	68 b0 79 12 f0       	push   $0xf01279b0
f011073a:	e8 4c 08 ff ff       	call   f0100f8b <cprintf>
f011073f:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f0110742:	83 ec 0c             	sub    $0xc,%esp
f0110745:	68 08 7a 12 f0       	push   $0xf0127a08
f011074a:	e8 3c 08 ff ff       	call   f0100f8b <cprintf>
f011074f:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f0110752:	c7 45 80 2e 7a 12 f0 	movl   $0xf0127a2e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0110759:	83 ec 08             	sub    $0x8,%esp
f011075c:	8d 45 80             	lea    -0x80(%ebp),%eax
f011075f:	50                   	push   %eax
f0110760:	6a 01                	push   $0x1
f0110762:	e8 69 1a ff ff       	call   f01021d0 <process_command>
f0110767:	83 c4 10             	add    $0x10,%esp
f011076a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f011076d:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0110771:	75 0f                	jne    f0110782 <TestAutoCompleteCommand+0x1b6>
f0110773:	a1 24 4a 5f f0       	mov    0xf05f4a24,%eax
f0110778:	85 c0                	test   %eax,%eax
f011077a:	75 06                	jne    f0110782 <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f011077c:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0110780:	eb 10                	jmp    f0110792 <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0110782:	83 ec 0c             	sub    $0xc,%esp
f0110785:	68 34 7a 12 f0       	push   $0xf0127a34
f011078a:	e8 fc 07 ff ff       	call   f0100f8b <cprintf>
f011078f:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0110792:	83 ec 0c             	sub    $0xc,%esp
f0110795:	68 84 7a 12 f0       	push   $0xf0127a84
f011079a:	e8 ec 07 ff ff       	call   f0100f8b <cprintf>
f011079f:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f01107a2:	c7 85 7c ff ff ff a9 	movl   $0xf0127aa9,-0x84(%ebp)
f01107a9:	7a 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f01107ac:	83 ec 08             	sub    $0x8,%esp
f01107af:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f01107b5:	50                   	push   %eax
f01107b6:	6a 01                	push   $0x1
f01107b8:	e8 13 1a ff ff       	call   f01021d0 <process_command>
f01107bd:	83 c4 10             	add    $0x10,%esp
f01107c0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f01107c3:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01107c7:	75 30                	jne    f01107f9 <TestAutoCompleteCommand+0x22d>
f01107c9:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01107cc:	bb 80 7d 12 f0       	mov    $0xf0127d80,%ebx
f01107d1:	ba 0c 00 00 00       	mov    $0xc,%edx
f01107d6:	89 c7                	mov    %eax,%edi
f01107d8:	89 de                	mov    %ebx,%esi
f01107da:	89 d1                	mov    %edx,%ecx
f01107dc:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01107de:	83 ec 08             	sub    $0x8,%esp
f01107e1:	6a 0c                	push   $0xc
f01107e3:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01107e6:	50                   	push   %eax
f01107e7:	e8 df fc ff ff       	call   f01104cb <hasExpectedCommands>
f01107ec:	83 c4 10             	add    $0x10,%esp
f01107ef:	85 c0                	test   %eax,%eax
f01107f1:	74 06                	je     f01107f9 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f01107f3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01107f7:	eb 10                	jmp    f0110809 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f01107f9:	83 ec 0c             	sub    $0xc,%esp
f01107fc:	68 ac 7a 12 f0       	push   $0xf0127aac
f0110801:	e8 85 07 ff ff       	call   f0100f8b <cprintf>
f0110806:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0110809:	83 ec 0c             	sub    $0xc,%esp
f011080c:	68 04 7b 12 f0       	push   $0xf0127b04
f0110811:	e8 75 07 ff ff       	call   f0100f8b <cprintf>
f0110816:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0110819:	c7 85 78 ff ff ff 29 	movl   $0xf0127b29,-0x88(%ebp)
f0110820:	7b 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0110823:	83 ec 08             	sub    $0x8,%esp
f0110826:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f011082c:	50                   	push   %eax
f011082d:	6a 01                	push   $0x1
f011082f:	e8 9c 19 ff ff       	call   f01021d0 <process_command>
f0110834:	83 c4 10             	add    $0x10,%esp
f0110837:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f011083a:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011083e:	75 30                	jne    f0110870 <TestAutoCompleteCommand+0x2a4>
f0110840:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0110843:	bb c8 7d 12 f0       	mov    $0xf0127dc8,%ebx
f0110848:	ba 05 00 00 00       	mov    $0x5,%edx
f011084d:	89 c7                	mov    %eax,%edi
f011084f:	89 de                	mov    %ebx,%esi
f0110851:	89 d1                	mov    %edx,%ecx
f0110853:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0110855:	83 ec 08             	sub    $0x8,%esp
f0110858:	6a 05                	push   $0x5
f011085a:	8d 45 cc             	lea    -0x34(%ebp),%eax
f011085d:	50                   	push   %eax
f011085e:	e8 68 fc ff ff       	call   f01104cb <hasExpectedCommands>
f0110863:	83 c4 10             	add    $0x10,%esp
f0110866:	85 c0                	test   %eax,%eax
f0110868:	74 06                	je     f0110870 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f011086a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011086e:	eb 10                	jmp    f0110880 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0110870:	83 ec 0c             	sub    $0xc,%esp
f0110873:	68 2c 7b 12 f0       	push   $0xf0127b2c
f0110878:	e8 0e 07 ff ff       	call   f0100f8b <cprintf>
f011087d:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0110880:	83 ec 0c             	sub    $0xc,%esp
f0110883:	68 84 7b 12 f0       	push   $0xf0127b84
f0110888:	e8 fe 06 ff ff       	call   f0100f8b <cprintf>
f011088d:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0110890:	c7 85 70 ff ff ff b0 	movl   $0xf0127bb0,-0x90(%ebp)
f0110897:	7b 12 f0 
f011089a:	c7 85 74 ff ff ff b5 	movl   $0xf0127bb5,-0x8c(%ebp)
f01108a1:	7b 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f01108a4:	83 ec 08             	sub    $0x8,%esp
f01108a7:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f01108ad:	50                   	push   %eax
f01108ae:	6a 02                	push   $0x2
f01108b0:	e8 1b 19 ff ff       	call   f01021d0 <process_command>
f01108b5:	83 c4 10             	add    $0x10,%esp
f01108b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f01108bb:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01108c1:	83 ec 0c             	sub    $0xc,%esp
f01108c4:	50                   	push   %eax
f01108c5:	e8 b2 fc ff ff       	call   f011057c <getIndexOfCommand>
f01108ca:	83 c4 10             	add    $0x10,%esp
f01108cd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01108d0:	75 0f                	jne    f01108e1 <TestAutoCompleteCommand+0x315>
f01108d2:	a1 18 4a 5f f0       	mov    0xf05f4a18,%eax
f01108d7:	85 c0                	test   %eax,%eax
f01108d9:	75 06                	jne    f01108e1 <TestAutoCompleteCommand+0x315>
		eval += 10;
f01108db:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01108df:	eb 10                	jmp    f01108f1 <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01108e1:	83 ec 0c             	sub    $0xc,%esp
f01108e4:	68 bc 7b 12 f0       	push   $0xf0127bbc
f01108e9:	e8 9d 06 ff ff       	call   f0100f8b <cprintf>
f01108ee:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f01108f1:	83 ec 0c             	sub    $0xc,%esp
f01108f4:	68 0c 7c 12 f0       	push   $0xf0127c0c
f01108f9:	e8 8d 06 ff ff       	call   f0100f8b <cprintf>
f01108fe:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0110901:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0110907:	bb f0 7d 12 f0       	mov    $0xf0127df0,%ebx
f011090c:	ba 03 00 00 00       	mov    $0x3,%edx
f0110911:	89 c7                	mov    %eax,%edi
f0110913:	89 de                	mov    %ebx,%esi
f0110915:	89 d1                	mov    %edx,%ecx
f0110917:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0110919:	83 ec 08             	sub    $0x8,%esp
f011091c:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0110922:	50                   	push   %eax
f0110923:	6a 03                	push   $0x3
f0110925:	e8 a6 18 ff ff       	call   f01021d0 <process_command>
f011092a:	83 c4 10             	add    $0x10,%esp
f011092d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0110930:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0110936:	83 ec 0c             	sub    $0xc,%esp
f0110939:	50                   	push   %eax
f011093a:	e8 3d fc ff ff       	call   f011057c <getIndexOfCommand>
f011093f:	83 c4 10             	add    $0x10,%esp
f0110942:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0110945:	75 0f                	jne    f0110956 <TestAutoCompleteCommand+0x38a>
f0110947:	a1 18 4a 5f f0       	mov    0xf05f4a18,%eax
f011094c:	85 c0                	test   %eax,%eax
f011094e:	75 06                	jne    f0110956 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0110950:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0110954:	eb 10                	jmp    f0110966 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0110956:	83 ec 0c             	sub    $0xc,%esp
f0110959:	68 40 7c 12 f0       	push   $0xf0127c40
f011095e:	e8 28 06 ff ff       	call   f0100f8b <cprintf>
f0110963:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0110966:	83 ec 08             	sub    $0x8,%esp
f0110969:	ff 75 e4             	pushl  -0x1c(%ebp)
f011096c:	68 90 7c 12 f0       	push   $0xf0127c90
f0110971:	e8 15 06 ff ff       	call   f0100f8b <cprintf>
f0110976:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0110979:	83 ec 0c             	sub    $0xc,%esp
f011097c:	68 c0 7c 12 f0       	push   $0xf0127cc0
f0110981:	e8 05 06 ff ff       	call   f0100f8b <cprintf>
f0110986:	83 c4 10             	add    $0x10,%esp

	return 0;
f0110989:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011098e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0110991:	5b                   	pop    %ebx
f0110992:	5e                   	pop    %esi
f0110993:	5f                   	pop    %edi
f0110994:	5d                   	pop    %ebp
f0110995:	c3                   	ret    

f0110996 <test_str2lower_function>:

int test_str2lower_function()
{
f0110996:	55                   	push   %ebp
f0110997:	89 e5                	mov    %esp,%ebp
f0110999:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f011099f:	83 ec 0c             	sub    $0xc,%esp
f01109a2:	68 fc 7d 12 f0       	push   $0xf0127dfc
f01109a7:	e8 df 05 ff ff       	call   f0100f8b <cprintf>
f01109ac:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f01109af:	83 ec 0c             	sub    $0xc,%esp
f01109b2:	68 1d 7e 12 f0       	push   $0xf0127e1d
f01109b7:	e8 cf 05 ff ff       	call   f0100f8b <cprintf>
f01109bc:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f01109bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f01109c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f01109cd:	c7 45 ec 37 7e 12 f0 	movl   $0xf0127e37,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f01109d4:	83 ec 08             	sub    $0x8,%esp
f01109d7:	ff 75 ec             	pushl  -0x14(%ebp)
f01109da:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f01109e0:	50                   	push   %eax
f01109e1:	e8 50 e8 00 00       	call   f011f236 <str2lower>
f01109e6:	83 c4 10             	add    $0x10,%esp
f01109e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f01109ec:	83 ec 0c             	sub    $0xc,%esp
f01109ef:	ff 75 e8             	pushl  -0x18(%ebp)
f01109f2:	e8 56 e1 00 00       	call   f011eb4d <strlen>
f01109f7:	83 c4 10             	add    $0x10,%esp
f01109fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f01109fd:	83 ec 08             	sub    $0x8,%esp
f0110a00:	68 42 7e 12 f0       	push   $0xf0127e42
f0110a05:	ff 75 e8             	pushl  -0x18(%ebp)
f0110a08:	e8 4c e2 00 00       	call   f011ec59 <strcmp>
f0110a0d:	83 c4 10             	add    $0x10,%esp
f0110a10:	85 c0                	test   %eax,%eax
f0110a12:	75 13                	jne    f0110a27 <test_str2lower_function+0x91>
f0110a14:	83 ec 0c             	sub    $0xc,%esp
f0110a17:	ff 75 ec             	pushl  -0x14(%ebp)
f0110a1a:	e8 2e e1 00 00       	call   f011eb4d <strlen>
f0110a1f:	83 c4 10             	add    $0x10,%esp
f0110a22:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110a25:	74 15                	je     f0110a3c <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0110a27:	83 ec 08             	sub    $0x8,%esp
f0110a2a:	ff 75 e8             	pushl  -0x18(%ebp)
f0110a2d:	68 50 7e 12 f0       	push   $0xf0127e50
f0110a32:	e8 54 05 ff ff       	call   f0100f8b <cprintf>
f0110a37:	83 c4 10             	add    $0x10,%esp
f0110a3a:	eb 04                	jmp    f0110a40 <test_str2lower_function+0xaa>
	else
		eval += 10;
f0110a3c:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0110a40:	c7 45 e0 b2 7e 12 f0 	movl   $0xf0127eb2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0110a47:	83 ec 08             	sub    $0x8,%esp
f0110a4a:	ff 75 e0             	pushl  -0x20(%ebp)
f0110a4d:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0110a53:	50                   	push   %eax
f0110a54:	e8 dd e7 00 00       	call   f011f236 <str2lower>
f0110a59:	83 c4 10             	add    $0x10,%esp
f0110a5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110a5f:	83 ec 0c             	sub    $0xc,%esp
f0110a62:	ff 75 e8             	pushl  -0x18(%ebp)
f0110a65:	e8 e3 e0 00 00       	call   f011eb4d <strlen>
f0110a6a:	83 c4 10             	add    $0x10,%esp
f0110a6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0110a70:	83 ec 08             	sub    $0x8,%esp
f0110a73:	68 b2 7e 12 f0       	push   $0xf0127eb2
f0110a78:	ff 75 e8             	pushl  -0x18(%ebp)
f0110a7b:	e8 d9 e1 00 00       	call   f011ec59 <strcmp>
f0110a80:	83 c4 10             	add    $0x10,%esp
f0110a83:	85 c0                	test   %eax,%eax
f0110a85:	75 13                	jne    f0110a9a <test_str2lower_function+0x104>
f0110a87:	83 ec 0c             	sub    $0xc,%esp
f0110a8a:	ff 75 e0             	pushl  -0x20(%ebp)
f0110a8d:	e8 bb e0 00 00       	call   f011eb4d <strlen>
f0110a92:	83 c4 10             	add    $0x10,%esp
f0110a95:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110a98:	74 15                	je     f0110aaf <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0110a9a:	83 ec 08             	sub    $0x8,%esp
f0110a9d:	ff 75 e8             	pushl  -0x18(%ebp)
f0110aa0:	68 b4 7e 12 f0       	push   $0xf0127eb4
f0110aa5:	e8 e1 04 ff ff       	call   f0100f8b <cprintf>
f0110aaa:	83 c4 10             	add    $0x10,%esp
f0110aad:	eb 04                	jmp    f0110ab3 <test_str2lower_function+0x11d>
	else
		eval += 10;
f0110aaf:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0110ab3:	c7 45 dc 0c 7f 12 f0 	movl   $0xf0127f0c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0110aba:	83 ec 08             	sub    $0x8,%esp
f0110abd:	ff 75 dc             	pushl  -0x24(%ebp)
f0110ac0:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0110ac6:	50                   	push   %eax
f0110ac7:	e8 6a e7 00 00       	call   f011f236 <str2lower>
f0110acc:	83 c4 10             	add    $0x10,%esp
f0110acf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110ad2:	83 ec 0c             	sub    $0xc,%esp
f0110ad5:	ff 75 e8             	pushl  -0x18(%ebp)
f0110ad8:	e8 70 e0 00 00       	call   f011eb4d <strlen>
f0110add:	83 c4 10             	add    $0x10,%esp
f0110ae0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0110ae3:	83 ec 08             	sub    $0x8,%esp
f0110ae6:	68 0c 7f 12 f0       	push   $0xf0127f0c
f0110aeb:	ff 75 e8             	pushl  -0x18(%ebp)
f0110aee:	e8 66 e1 00 00       	call   f011ec59 <strcmp>
f0110af3:	83 c4 10             	add    $0x10,%esp
f0110af6:	85 c0                	test   %eax,%eax
f0110af8:	75 13                	jne    f0110b0d <test_str2lower_function+0x177>
f0110afa:	83 ec 0c             	sub    $0xc,%esp
f0110afd:	ff 75 dc             	pushl  -0x24(%ebp)
f0110b00:	e8 48 e0 00 00       	call   f011eb4d <strlen>
f0110b05:	83 c4 10             	add    $0x10,%esp
f0110b08:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110b0b:	74 15                	je     f0110b22 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0110b0d:	83 ec 08             	sub    $0x8,%esp
f0110b10:	ff 75 e8             	pushl  -0x18(%ebp)
f0110b13:	68 18 7f 12 f0       	push   $0xf0127f18
f0110b18:	e8 6e 04 ff ff       	call   f0100f8b <cprintf>
f0110b1d:	83 c4 10             	add    $0x10,%esp
f0110b20:	eb 04                	jmp    f0110b26 <test_str2lower_function+0x190>
	else
		eval += 15;
f0110b22:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0110b26:	c7 45 d8 7b 7f 12 f0 	movl   $0xf0127f7b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0110b2d:	83 ec 08             	sub    $0x8,%esp
f0110b30:	ff 75 d8             	pushl  -0x28(%ebp)
f0110b33:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0110b39:	50                   	push   %eax
f0110b3a:	e8 f7 e6 00 00       	call   f011f236 <str2lower>
f0110b3f:	83 c4 10             	add    $0x10,%esp
f0110b42:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110b45:	83 ec 0c             	sub    $0xc,%esp
f0110b48:	ff 75 e8             	pushl  -0x18(%ebp)
f0110b4b:	e8 fd df 00 00       	call   f011eb4d <strlen>
f0110b50:	83 c4 10             	add    $0x10,%esp
f0110b53:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0110b56:	83 ec 08             	sub    $0x8,%esp
f0110b59:	68 7b 7f 12 f0       	push   $0xf0127f7b
f0110b5e:	ff 75 e8             	pushl  -0x18(%ebp)
f0110b61:	e8 f3 e0 00 00       	call   f011ec59 <strcmp>
f0110b66:	83 c4 10             	add    $0x10,%esp
f0110b69:	85 c0                	test   %eax,%eax
f0110b6b:	75 13                	jne    f0110b80 <test_str2lower_function+0x1ea>
f0110b6d:	83 ec 0c             	sub    $0xc,%esp
f0110b70:	ff 75 d8             	pushl  -0x28(%ebp)
f0110b73:	e8 d5 df 00 00       	call   f011eb4d <strlen>
f0110b78:	83 c4 10             	add    $0x10,%esp
f0110b7b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110b7e:	74 15                	je     f0110b95 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0110b80:	83 ec 08             	sub    $0x8,%esp
f0110b83:	ff 75 e8             	pushl  -0x18(%ebp)
f0110b86:	68 88 7f 12 f0       	push   $0xf0127f88
f0110b8b:	e8 fb 03 ff ff       	call   f0100f8b <cprintf>
f0110b90:	83 c4 10             	add    $0x10,%esp
f0110b93:	eb 04                	jmp    f0110b99 <test_str2lower_function+0x203>
	else
		eval += 15;
f0110b95:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0110b99:	c7 45 d4 ea 7f 12 f0 	movl   $0xf0127fea,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0110ba0:	83 ec 08             	sub    $0x8,%esp
f0110ba3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110ba6:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0110bac:	50                   	push   %eax
f0110bad:	e8 84 e6 00 00       	call   f011f236 <str2lower>
f0110bb2:	83 c4 10             	add    $0x10,%esp
f0110bb5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110bb8:	83 ec 0c             	sub    $0xc,%esp
f0110bbb:	ff 75 e8             	pushl  -0x18(%ebp)
f0110bbe:	e8 8a df 00 00       	call   f011eb4d <strlen>
f0110bc3:	83 c4 10             	add    $0x10,%esp
f0110bc6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0110bc9:	83 ec 08             	sub    $0x8,%esp
f0110bcc:	68 00 80 12 f0       	push   $0xf0128000
f0110bd1:	ff 75 e8             	pushl  -0x18(%ebp)
f0110bd4:	e8 80 e0 00 00       	call   f011ec59 <strcmp>
f0110bd9:	83 c4 10             	add    $0x10,%esp
f0110bdc:	85 c0                	test   %eax,%eax
f0110bde:	75 13                	jne    f0110bf3 <test_str2lower_function+0x25d>
f0110be0:	83 ec 0c             	sub    $0xc,%esp
f0110be3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110be6:	e8 62 df 00 00       	call   f011eb4d <strlen>
f0110beb:	83 c4 10             	add    $0x10,%esp
f0110bee:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110bf1:	74 15                	je     f0110c08 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0110bf3:	83 ec 08             	sub    $0x8,%esp
f0110bf6:	ff 75 e8             	pushl  -0x18(%ebp)
f0110bf9:	68 18 80 12 f0       	push   $0xf0128018
f0110bfe:	e8 88 03 ff ff       	call   f0100f8b <cprintf>
f0110c03:	83 c4 10             	add    $0x10,%esp
f0110c06:	eb 04                	jmp    f0110c0c <test_str2lower_function+0x276>
	else
		eval += 15;
f0110c08:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0110c0c:	c7 45 d0 85 80 12 f0 	movl   $0xf0128085,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0110c13:	83 ec 08             	sub    $0x8,%esp
f0110c16:	ff 75 d0             	pushl  -0x30(%ebp)
f0110c19:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0110c1f:	50                   	push   %eax
f0110c20:	e8 11 e6 00 00       	call   f011f236 <str2lower>
f0110c25:	83 c4 10             	add    $0x10,%esp
f0110c28:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110c2b:	83 ec 0c             	sub    $0xc,%esp
f0110c2e:	ff 75 e8             	pushl  -0x18(%ebp)
f0110c31:	e8 17 df 00 00       	call   f011eb4d <strlen>
f0110c36:	83 c4 10             	add    $0x10,%esp
f0110c39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0110c3c:	83 ec 08             	sub    $0x8,%esp
f0110c3f:	68 91 80 12 f0       	push   $0xf0128091
f0110c44:	ff 75 e8             	pushl  -0x18(%ebp)
f0110c47:	e8 0d e0 00 00       	call   f011ec59 <strcmp>
f0110c4c:	83 c4 10             	add    $0x10,%esp
f0110c4f:	85 c0                	test   %eax,%eax
f0110c51:	75 13                	jne    f0110c66 <test_str2lower_function+0x2d0>
f0110c53:	83 ec 0c             	sub    $0xc,%esp
f0110c56:	ff 75 d0             	pushl  -0x30(%ebp)
f0110c59:	e8 ef de 00 00       	call   f011eb4d <strlen>
f0110c5e:	83 c4 10             	add    $0x10,%esp
f0110c61:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110c64:	74 15                	je     f0110c7b <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0110c66:	83 ec 08             	sub    $0x8,%esp
f0110c69:	ff 75 e8             	pushl  -0x18(%ebp)
f0110c6c:	68 a0 80 12 f0       	push   $0xf01280a0
f0110c71:	e8 15 03 ff ff       	call   f0100f8b <cprintf>
f0110c76:	83 c4 10             	add    $0x10,%esp
f0110c79:	eb 04                	jmp    f0110c7f <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0110c7b:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0110c7f:	c7 45 cc 03 81 12 f0 	movl   $0xf0128103,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0110c86:	83 ec 08             	sub    $0x8,%esp
f0110c89:	ff 75 cc             	pushl  -0x34(%ebp)
f0110c8c:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0110c92:	50                   	push   %eax
f0110c93:	e8 9e e5 00 00       	call   f011f236 <str2lower>
f0110c98:	83 c4 10             	add    $0x10,%esp
f0110c9b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110c9e:	83 ec 0c             	sub    $0xc,%esp
f0110ca1:	ff 75 e8             	pushl  -0x18(%ebp)
f0110ca4:	e8 a4 de 00 00       	call   f011eb4d <strlen>
f0110ca9:	83 c4 10             	add    $0x10,%esp
f0110cac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0110caf:	83 ec 08             	sub    $0x8,%esp
f0110cb2:	68 1e 81 12 f0       	push   $0xf012811e
f0110cb7:	ff 75 e8             	pushl  -0x18(%ebp)
f0110cba:	e8 9a df 00 00       	call   f011ec59 <strcmp>
f0110cbf:	83 c4 10             	add    $0x10,%esp
f0110cc2:	85 c0                	test   %eax,%eax
f0110cc4:	75 13                	jne    f0110cd9 <test_str2lower_function+0x343>
f0110cc6:	83 ec 0c             	sub    $0xc,%esp
f0110cc9:	ff 75 cc             	pushl  -0x34(%ebp)
f0110ccc:	e8 7c de 00 00       	call   f011eb4d <strlen>
f0110cd1:	83 c4 10             	add    $0x10,%esp
f0110cd4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110cd7:	74 15                	je     f0110cee <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0110cd9:	83 ec 08             	sub    $0x8,%esp
f0110cdc:	ff 75 e8             	pushl  -0x18(%ebp)
f0110cdf:	68 3c 81 12 f0       	push   $0xf012813c
f0110ce4:	e8 a2 02 ff ff       	call   f0100f8b <cprintf>
f0110ce9:	83 c4 10             	add    $0x10,%esp
f0110cec:	eb 04                	jmp    f0110cf2 <test_str2lower_function+0x35c>
	else
		eval += 20;
f0110cee:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0110cf2:	83 ec 08             	sub    $0x8,%esp
f0110cf5:	ff 75 f4             	pushl  -0xc(%ebp)
f0110cf8:	68 b0 81 12 f0       	push   $0xf01281b0
f0110cfd:	e8 89 02 ff ff       	call   f0100f8b <cprintf>
f0110d02:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0110d05:	83 ec 0c             	sub    $0xc,%esp
f0110d08:	68 c0 7c 12 f0       	push   $0xf0127cc0
f0110d0d:	e8 79 02 ff ff       	call   f0100f8b <cprintf>
f0110d12:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110d15:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110d1a:	c9                   	leave  
f0110d1b:	c3                   	ret    

f0110d1c <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0110d1c:	55                   	push   %ebp
f0110d1d:	89 e5                	mov    %esp,%ebp
f0110d1f:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0110d22:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0110d29:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0110d30:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110d37:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110d3c:	ff 75 ec             	pushl  -0x14(%ebp)
f0110d3f:	ff 75 f0             	pushl  -0x10(%ebp)
f0110d42:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d45:	50                   	push   %eax
f0110d46:	e8 65 83 ff ff       	call   f01090b0 <pt_set_page_permissions>
f0110d4b:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110d4e:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110d53:	ff 75 ec             	pushl  -0x14(%ebp)
f0110d56:	ff 75 f0             	pushl  -0x10(%ebp)
f0110d59:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d5c:	50                   	push   %eax
f0110d5d:	e8 74 4b 00 00       	call   f01158d6 <CP>
f0110d62:	83 c4 10             	add    $0x10,%esp
f0110d65:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110d68:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110d6c:	74 17                	je     f0110d85 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0110d6e:	83 ec 04             	sub    $0x4,%esp
f0110d71:	68 e0 81 12 f0       	push   $0xf01281e0
f0110d76:	68 23 01 00 00       	push   $0x123
f0110d7b:	68 02 82 12 f0       	push   $0xf0128202
f0110d80:	e8 b4 f5 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0110d85:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0110d8c:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0110d93:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110d9a:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110d9f:	ff 75 ec             	pushl  -0x14(%ebp)
f0110da2:	ff 75 f0             	pushl  -0x10(%ebp)
f0110da5:	ff 75 f4             	pushl  -0xc(%ebp)
f0110da8:	50                   	push   %eax
f0110da9:	e8 02 83 ff ff       	call   f01090b0 <pt_set_page_permissions>
f0110dae:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110db1:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110db6:	ff 75 ec             	pushl  -0x14(%ebp)
f0110db9:	ff 75 f0             	pushl  -0x10(%ebp)
f0110dbc:	ff 75 f4             	pushl  -0xc(%ebp)
f0110dbf:	50                   	push   %eax
f0110dc0:	e8 11 4b 00 00       	call   f01158d6 <CP>
f0110dc5:	83 c4 10             	add    $0x10,%esp
f0110dc8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110dcb:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110dcf:	74 17                	je     f0110de8 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0110dd1:	83 ec 04             	sub    $0x4,%esp
f0110dd4:	68 20 82 12 f0       	push   $0xf0128220
f0110dd9:	68 2f 01 00 00       	push   $0x12f
f0110dde:	68 02 82 12 f0       	push   $0xf0128202
f0110de3:	e8 51 f5 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0110de8:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0110def:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0110df6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110dfd:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110e02:	ff 75 ec             	pushl  -0x14(%ebp)
f0110e05:	ff 75 f0             	pushl  -0x10(%ebp)
f0110e08:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e0b:	50                   	push   %eax
f0110e0c:	e8 9f 82 ff ff       	call   f01090b0 <pt_set_page_permissions>
f0110e11:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110e14:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110e19:	ff 75 ec             	pushl  -0x14(%ebp)
f0110e1c:	ff 75 f0             	pushl  -0x10(%ebp)
f0110e1f:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e22:	50                   	push   %eax
f0110e23:	e8 ae 4a 00 00       	call   f01158d6 <CP>
f0110e28:	83 c4 10             	add    $0x10,%esp
f0110e2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110e2e:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110e32:	74 17                	je     f0110e4b <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0110e34:	83 ec 04             	sub    $0x4,%esp
f0110e37:	68 44 82 12 f0       	push   $0xf0128244
f0110e3c:	68 3a 01 00 00       	push   $0x13a
f0110e41:	68 02 82 12 f0       	push   $0xf0128202
f0110e46:	e8 ee f4 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0110e4b:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0110e52:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0110e59:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110e60:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110e65:	ff 75 ec             	pushl  -0x14(%ebp)
f0110e68:	ff 75 f0             	pushl  -0x10(%ebp)
f0110e6b:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e6e:	50                   	push   %eax
f0110e6f:	e8 3c 82 ff ff       	call   f01090b0 <pt_set_page_permissions>
f0110e74:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110e77:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110e7c:	ff 75 ec             	pushl  -0x14(%ebp)
f0110e7f:	ff 75 f0             	pushl  -0x10(%ebp)
f0110e82:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e85:	50                   	push   %eax
f0110e86:	e8 4b 4a 00 00       	call   f01158d6 <CP>
f0110e8b:	83 c4 10             	add    $0x10,%esp
f0110e8e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110e91:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110e95:	74 17                	je     f0110eae <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0110e97:	83 ec 04             	sub    $0x4,%esp
f0110e9a:	68 68 82 12 f0       	push   $0xf0128268
f0110e9f:	68 46 01 00 00       	push   $0x146
f0110ea4:	68 02 82 12 f0       	push   $0xf0128202
f0110ea9:	e8 8b f4 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0110eae:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0110eb5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0110ebc:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110ec3:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110ec8:	ff 75 ec             	pushl  -0x14(%ebp)
f0110ecb:	ff 75 f0             	pushl  -0x10(%ebp)
f0110ece:	ff 75 f4             	pushl  -0xc(%ebp)
f0110ed1:	50                   	push   %eax
f0110ed2:	e8 d9 81 ff ff       	call   f01090b0 <pt_set_page_permissions>
f0110ed7:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110eda:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110edf:	ff 75 ec             	pushl  -0x14(%ebp)
f0110ee2:	ff 75 f0             	pushl  -0x10(%ebp)
f0110ee5:	ff 75 f4             	pushl  -0xc(%ebp)
f0110ee8:	50                   	push   %eax
f0110ee9:	e8 e8 49 00 00       	call   f01158d6 <CP>
f0110eee:	83 c4 10             	add    $0x10,%esp
f0110ef1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110ef4:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110ef8:	74 17                	je     f0110f11 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0110efa:	83 ec 04             	sub    $0x4,%esp
f0110efd:	68 8c 82 12 f0       	push   $0xf012828c
f0110f02:	68 52 01 00 00       	push   $0x152
f0110f07:	68 02 82 12 f0       	push   $0xf0128202
f0110f0c:	e8 28 f4 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0110f11:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0110f18:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0110f1f:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110f26:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110f2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0110f2e:	ff 75 f0             	pushl  -0x10(%ebp)
f0110f31:	ff 75 f4             	pushl  -0xc(%ebp)
f0110f34:	50                   	push   %eax
f0110f35:	e8 76 81 ff ff       	call   f01090b0 <pt_set_page_permissions>
f0110f3a:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110f3d:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110f42:	ff 75 ec             	pushl  -0x14(%ebp)
f0110f45:	ff 75 f0             	pushl  -0x10(%ebp)
f0110f48:	ff 75 f4             	pushl  -0xc(%ebp)
f0110f4b:	50                   	push   %eax
f0110f4c:	e8 85 49 00 00       	call   f01158d6 <CP>
f0110f51:	83 c4 10             	add    $0x10,%esp
f0110f54:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110f57:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110f5b:	74 17                	je     f0110f74 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0110f5d:	83 ec 04             	sub    $0x4,%esp
f0110f60:	68 b0 82 12 f0       	push   $0xf01282b0
f0110f65:	68 5e 01 00 00       	push   $0x15e
f0110f6a:	68 02 82 12 f0       	push   $0xf0128202
f0110f6f:	e8 c5 f3 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0110f74:	83 ec 0c             	sub    $0xc,%esp
f0110f77:	68 dc 82 12 f0       	push   $0xf01282dc
f0110f7c:	e8 0a 00 ff ff       	call   f0100f8b <cprintf>
f0110f81:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110f84:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110f89:	c9                   	leave  
f0110f8a:	c3                   	ret    

f0110f8b <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0110f8b:	55                   	push   %ebp
f0110f8c:	89 e5                	mov    %esp,%ebp
f0110f8e:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0110f91:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0110f98:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0110f9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110fa6:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110fab:	ff 75 ec             	pushl  -0x14(%ebp)
f0110fae:	ff 75 f0             	pushl  -0x10(%ebp)
f0110fb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0110fb4:	50                   	push   %eax
f0110fb5:	e8 f6 80 ff ff       	call   f01090b0 <pt_set_page_permissions>
f0110fba:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0110fbd:	83 ec 04             	sub    $0x4,%esp
f0110fc0:	68 2c 83 12 f0       	push   $0xf012832c
f0110fc5:	68 6b 01 00 00       	push   $0x16b
f0110fca:	68 02 82 12 f0       	push   $0xf0128202
f0110fcf:	e8 65 f3 fe ff       	call   f0100339 <_panic>

f0110fd4 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0110fd4:	55                   	push   %ebp
f0110fd5:	89 e5                	mov    %esp,%ebp
f0110fd7:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0110fda:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0110fe1:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0110fe6:	83 ec 08             	sub    $0x8,%esp
f0110fe9:	ff 75 f4             	pushl  -0xc(%ebp)
f0110fec:	50                   	push   %eax
f0110fed:	e8 82 81 ff ff       	call   f0109174 <pt_get_page_permissions>
f0110ff2:	83 c4 10             	add    $0x10,%esp
f0110ff5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0110ff8:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0110ffc:	74 17                	je     f0111015 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0110ffe:	83 ec 04             	sub    $0x4,%esp
f0111001:	68 c8 83 12 f0       	push   $0xf01283c8
f0111006:	68 79 01 00 00       	push   $0x179
f011100b:	68 02 82 12 f0       	push   $0xf0128202
f0111010:	e8 24 f3 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0111015:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011101c:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0111021:	83 ec 08             	sub    $0x8,%esp
f0111024:	ff 75 f4             	pushl  -0xc(%ebp)
f0111027:	50                   	push   %eax
f0111028:	e8 47 81 ff ff       	call   f0109174 <pt_get_page_permissions>
f011102d:	83 c4 10             	add    $0x10,%esp
f0111030:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0111033:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111037:	74 17                	je     f0111050 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0111039:	83 ec 04             	sub    $0x4,%esp
f011103c:	68 ec 83 12 f0       	push   $0xf01283ec
f0111041:	68 81 01 00 00       	push   $0x181
f0111046:	68 02 82 12 f0       	push   $0xf0128202
f011104b:	e8 e9 f2 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0111050:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111057:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011105c:	83 ec 08             	sub    $0x8,%esp
f011105f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111062:	50                   	push   %eax
f0111063:	e8 0c 81 ff ff       	call   f0109174 <pt_get_page_permissions>
f0111068:	83 c4 10             	add    $0x10,%esp
f011106b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f011106e:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111072:	74 17                	je     f011108b <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0111074:	83 ec 04             	sub    $0x4,%esp
f0111077:	68 10 84 12 f0       	push   $0xf0128410
f011107c:	68 89 01 00 00       	push   $0x189
f0111081:	68 02 82 12 f0       	push   $0xf0128202
f0111086:	e8 ae f2 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f011108b:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111092:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0111097:	83 ec 08             	sub    $0x8,%esp
f011109a:	ff 75 f4             	pushl  -0xc(%ebp)
f011109d:	50                   	push   %eax
f011109e:	e8 d1 80 ff ff       	call   f0109174 <pt_get_page_permissions>
f01110a3:	83 c4 10             	add    $0x10,%esp
f01110a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f01110a9:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01110ad:	74 17                	je     f01110c6 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f01110af:	83 ec 04             	sub    $0x4,%esp
f01110b2:	68 34 84 12 f0       	push   $0xf0128434
f01110b7:	68 90 01 00 00       	push   $0x190
f01110bc:	68 02 82 12 f0       	push   $0xf0128202
f01110c1:	e8 73 f2 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f01110c6:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01110cd:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f01110d2:	83 ec 08             	sub    $0x8,%esp
f01110d5:	ff 75 f4             	pushl  -0xc(%ebp)
f01110d8:	50                   	push   %eax
f01110d9:	e8 96 80 ff ff       	call   f0109174 <pt_get_page_permissions>
f01110de:	83 c4 10             	add    $0x10,%esp
f01110e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f01110e4:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f01110e8:	74 17                	je     f0111101 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f01110ea:	83 ec 04             	sub    $0x4,%esp
f01110ed:	68 58 84 12 f0       	push   $0xf0128458
f01110f2:	68 97 01 00 00       	push   $0x197
f01110f7:	68 02 82 12 f0       	push   $0xf0128202
f01110fc:	e8 38 f2 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0111101:	83 ec 0c             	sub    $0xc,%esp
f0111104:	68 7c 84 12 f0       	push   $0xf012847c
f0111109:	e8 7d fe fe ff       	call   f0100f8b <cprintf>
f011110e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111111:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111116:	c9                   	leave  
f0111117:	c3                   	ret    

f0111118 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0111118:	55                   	push   %ebp
f0111119:	89 e5                	mov    %esp,%ebp
f011111b:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f011111e:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111125:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011112a:	83 ec 08             	sub    $0x8,%esp
f011112d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111130:	50                   	push   %eax
f0111131:	e8 87 80 ff ff       	call   f01091bd <pt_clear_page_table_entry>
f0111136:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0111139:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011113e:	83 ec 08             	sub    $0x8,%esp
f0111141:	ff 75 f4             	pushl  -0xc(%ebp)
f0111144:	50                   	push   %eax
f0111145:	e8 e8 46 00 00       	call   f0115832 <CE>
f011114a:	83 c4 10             	add    $0x10,%esp
f011114d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111150:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111154:	74 17                	je     f011116d <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0111156:	83 ec 04             	sub    $0x4,%esp
f0111159:	68 c4 84 12 f0       	push   $0xf01284c4
f011115e:	68 a7 01 00 00       	push   $0x1a7
f0111163:	68 02 82 12 f0       	push   $0xf0128202
f0111168:	e8 cc f1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f011116d:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111174:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0111179:	83 ec 08             	sub    $0x8,%esp
f011117c:	ff 75 f4             	pushl  -0xc(%ebp)
f011117f:	50                   	push   %eax
f0111180:	e8 38 80 ff ff       	call   f01091bd <pt_clear_page_table_entry>
f0111185:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111188:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011118d:	83 ec 08             	sub    $0x8,%esp
f0111190:	ff 75 f4             	pushl  -0xc(%ebp)
f0111193:	50                   	push   %eax
f0111194:	e8 99 46 00 00       	call   f0115832 <CE>
f0111199:	83 c4 10             	add    $0x10,%esp
f011119c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011119f:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01111a3:	74 17                	je     f01111bc <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f01111a5:	83 ec 04             	sub    $0x4,%esp
f01111a8:	68 f0 84 12 f0       	push   $0xf01284f0
f01111ad:	68 af 01 00 00       	push   $0x1af
f01111b2:	68 02 82 12 f0       	push   $0xf0128202
f01111b7:	e8 7d f1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f01111bc:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01111c3:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f01111c8:	83 ec 08             	sub    $0x8,%esp
f01111cb:	ff 75 f4             	pushl  -0xc(%ebp)
f01111ce:	50                   	push   %eax
f01111cf:	e8 e9 7f ff ff       	call   f01091bd <pt_clear_page_table_entry>
f01111d4:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01111d7:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f01111dc:	83 ec 08             	sub    $0x8,%esp
f01111df:	ff 75 f4             	pushl  -0xc(%ebp)
f01111e2:	50                   	push   %eax
f01111e3:	e8 4a 46 00 00       	call   f0115832 <CE>
f01111e8:	83 c4 10             	add    $0x10,%esp
f01111eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01111ee:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01111f2:	74 17                	je     f011120b <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f01111f4:	83 ec 04             	sub    $0x4,%esp
f01111f7:	68 1c 85 12 f0       	push   $0xf012851c
f01111fc:	68 b7 01 00 00       	push   $0x1b7
f0111201:	68 02 82 12 f0       	push   $0xf0128202
f0111206:	e8 2e f1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f011120b:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111212:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0111217:	83 ec 08             	sub    $0x8,%esp
f011121a:	ff 75 f4             	pushl  -0xc(%ebp)
f011121d:	50                   	push   %eax
f011121e:	e8 9a 7f ff ff       	call   f01091bd <pt_clear_page_table_entry>
f0111223:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111226:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011122b:	83 ec 08             	sub    $0x8,%esp
f011122e:	ff 75 f4             	pushl  -0xc(%ebp)
f0111231:	50                   	push   %eax
f0111232:	e8 fb 45 00 00       	call   f0115832 <CE>
f0111237:	83 c4 10             	add    $0x10,%esp
f011123a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011123d:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111241:	74 17                	je     f011125a <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0111243:	83 ec 04             	sub    $0x4,%esp
f0111246:	68 48 85 12 f0       	push   $0xf0128548
f011124b:	68 bf 01 00 00       	push   $0x1bf
f0111250:	68 02 82 12 f0       	push   $0xf0128202
f0111255:	e8 df f0 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f011125a:	83 ec 0c             	sub    $0xc,%esp
f011125d:	68 74 85 12 f0       	push   $0xf0128574
f0111262:	e8 24 fd fe ff       	call   f0100f8b <cprintf>
f0111267:	83 c4 10             	add    $0x10,%esp
	return 0;
f011126a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011126f:	c9                   	leave  
f0111270:	c3                   	ret    

f0111271 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0111271:	55                   	push   %ebp
f0111272:	89 e5                	mov    %esp,%ebp
f0111274:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0111277:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011127e:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0111283:	83 ec 08             	sub    $0x8,%esp
f0111286:	ff 75 f4             	pushl  -0xc(%ebp)
f0111289:	50                   	push   %eax
f011128a:	e8 2e 7f ff ff       	call   f01091bd <pt_clear_page_table_entry>
f011128f:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0111292:	83 ec 04             	sub    $0x4,%esp
f0111295:	68 c0 85 12 f0       	push   $0xf01285c0
f011129a:	68 ca 01 00 00       	push   $0x1ca
f011129f:	68 02 82 12 f0       	push   $0xf0128202
f01112a4:	e8 90 f0 fe ff       	call   f0100339 <_panic>

f01112a9 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f01112a9:	55                   	push   %ebp
f01112aa:	89 e5                	mov    %esp,%ebp
f01112ac:	57                   	push   %edi
f01112ad:	56                   	push   %esi
f01112ae:	53                   	push   %ebx
f01112af:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01112b5:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01112bb:	bb 04 89 12 f0       	mov    $0xf0128904,%ebx
f01112c0:	ba 0f 00 00 00       	mov    $0xf,%edx
f01112c5:	89 c7                	mov    %eax,%edi
f01112c7:	89 de                	mov    %ebx,%esi
f01112c9:	89 d1                	mov    %edx,%ecx
f01112cb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01112cd:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01112d3:	b9 23 00 00 00       	mov    $0x23,%ecx
f01112d8:	b0 00                	mov    $0x0,%al
f01112da:	89 d7                	mov    %edx,%edi
f01112dc:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01112de:	6a 00                	push   $0x0
f01112e0:	6a 0a                	push   $0xa
f01112e2:	6a 14                	push   $0x14
f01112e4:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01112ea:	50                   	push   %eax
f01112eb:	e8 9d 8e ff ff       	call   f010a18d <env_create>
f01112f0:	83 c4 10             	add    $0x10,%esp
f01112f3:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01112f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01112f9:	8b 40 64             	mov    0x64(%eax),%eax
f01112fc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01112ff:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111302:	8b 40 68             	mov    0x68(%eax),%eax
f0111305:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0111308:	8b 45 90             	mov    -0x70(%ebp),%eax
f011130b:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011130e:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0111315:	75 70 20 
f0111318:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f011131f:	00 00 00 
f0111322:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0111328:	b9 03 00 00 00       	mov    $0x3,%ecx
f011132d:	b8 00 00 00 00       	mov    $0x0,%eax
f0111332:	89 d7                	mov    %edx,%edi
f0111334:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0111336:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111339:	8b 40 10             	mov    0x10(%eax),%eax
f011133c:	83 ec 08             	sub    $0x8,%esp
f011133f:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0111345:	52                   	push   %edx
f0111346:	50                   	push   %eax
f0111347:	e8 a7 dc 00 00       	call   f011eff3 <ltostr>
f011134c:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011134f:	83 ec 04             	sub    $0x4,%esp
f0111352:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111358:	50                   	push   %eax
f0111359:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f011135f:	50                   	push   %eax
f0111360:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0111366:	50                   	push   %eax
f0111367:	e8 60 dd 00 00       	call   f011f0cc <strcconcat>
f011136c:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f011136f:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0111376:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f011137d:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0111384:	83 ec 0c             	sub    $0xc,%esp
f0111387:	ff 75 d4             	pushl  -0x2c(%ebp)
f011138a:	e8 85 45 00 00       	call   f0115914 <ClearUserSpace>
f011138f:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0111392:	83 ec 04             	sub    $0x4,%esp
f0111395:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f011139b:	50                   	push   %eax
f011139c:	68 56 86 12 f0       	push   $0xf0128656
f01113a1:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01113a7:	50                   	push   %eax
f01113a8:	e8 1f dd 00 00       	call   f011f0cc <strcconcat>
f01113ad:	83 c4 10             	add    $0x10,%esp
f01113b0:	83 ec 0c             	sub    $0xc,%esp
f01113b3:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01113b9:	50                   	push   %eax
f01113ba:	e8 3c 0b ff ff       	call   f0101efb <execute_command>
f01113bf:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f01113c2:	83 ec 04             	sub    $0x4,%esp
f01113c5:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01113cb:	50                   	push   %eax
f01113cc:	68 61 86 12 f0       	push   $0xf0128661
f01113d1:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01113d7:	50                   	push   %eax
f01113d8:	e8 ef dc 00 00       	call   f011f0cc <strcconcat>
f01113dd:	83 c4 10             	add    $0x10,%esp
f01113e0:	83 ec 0c             	sub    $0xc,%esp
f01113e3:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01113e9:	50                   	push   %eax
f01113ea:	e8 0c 0b ff ff       	call   f0101efb <execute_command>
f01113ef:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f01113f2:	83 ec 04             	sub    $0x4,%esp
f01113f5:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01113fb:	50                   	push   %eax
f01113fc:	68 6c 86 12 f0       	push   $0xf012866c
f0111401:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111407:	50                   	push   %eax
f0111408:	e8 bf dc 00 00       	call   f011f0cc <strcconcat>
f011140d:	83 c4 10             	add    $0x10,%esp
f0111410:	83 ec 0c             	sub    $0xc,%esp
f0111413:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0111419:	50                   	push   %eax
f011141a:	e8 dc 0a ff ff       	call   f0101efb <execute_command>
f011141f:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0111422:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0111429:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011142c:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f011142f:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0111436:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111439:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f011143c:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0111443:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111446:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0111449:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011144c:	83 ec 08             	sub    $0x8,%esp
f011144f:	50                   	push   %eax
f0111450:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111453:	e8 9d 44 00 00       	call   f01158f5 <GP>
f0111458:	83 c4 10             	add    $0x10,%esp
f011145b:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f011145e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0111465:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f011146c:	e8 b5 c5 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0111471:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0111474:	83 ec 0c             	sub    $0xc,%esp
f0111477:	68 78 86 12 f0       	push   $0xf0128678
f011147c:	e8 0a fb fe ff       	call   f0100f8b <cprintf>
f0111481:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0111484:	6a 03                	push   $0x3
f0111486:	68 00 00 90 02       	push   $0x2900000
f011148b:	68 00 00 80 02       	push   $0x2800000
f0111490:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111493:	e8 48 8a ff ff       	call   f0109ee0 <cut_paste_pages>
f0111498:	83 c4 10             	add    $0x10,%esp
f011149b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f011149e:	e8 83 c5 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01114a3:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f01114a6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f01114ad:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01114b1:	75 08                	jne    f01114bb <test_cut_paste_pages+0x212>
f01114b3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01114b6:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01114b9:	74 2b                	je     f01114e6 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01114bb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01114be:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01114c1:	83 ec 0c             	sub    $0xc,%esp
f01114c4:	50                   	push   %eax
f01114c5:	ff 75 b4             	pushl  -0x4c(%ebp)
f01114c8:	68 a8 86 12 f0       	push   $0xf01286a8
f01114cd:	68 04 02 00 00       	push   $0x204
f01114d2:	68 02 82 12 f0       	push   $0xf0128202
f01114d7:	e8 fa ef fe ff       	call   f01004d6 <_warn>
f01114dc:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01114df:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f01114e6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01114ea:	74 04                	je     f01114f0 <test_cut_paste_pages+0x247>
f01114ec:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01114f0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01114f7:	83 ec 08             	sub    $0x8,%esp
f01114fa:	6a 00                	push   $0x0
f01114fc:	6a 01                	push   $0x1
f01114fe:	6a 00                	push   $0x0
f0111500:	68 ff 0f 00 00       	push   $0xfff
f0111505:	ff 75 bc             	pushl  -0x44(%ebp)
f0111508:	6a 01                	push   $0x1
f011150a:	68 00 30 00 00       	push   $0x3000
f011150f:	68 00 00 90 02       	push   $0x2900000
f0111514:	68 00 00 80 02       	push   $0x2800000
f0111519:	ff 75 d4             	pushl  -0x2c(%ebp)
f011151c:	e8 27 44 00 00       	call   f0115948 <CCP>
f0111521:	83 c4 30             	add    $0x30,%esp
f0111524:	83 f8 01             	cmp    $0x1,%eax
f0111527:	74 21                	je     f011154a <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0111529:	83 ec 04             	sub    $0x4,%esp
f011152c:	68 fc 86 12 f0       	push   $0xf01286fc
f0111531:	68 0c 02 00 00       	push   $0x20c
f0111536:	68 02 82 12 f0       	push   $0xf0128202
f011153b:	e8 96 ef fe ff       	call   f01004d6 <_warn>
f0111540:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111543:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f011154a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011154e:	74 04                	je     f0111554 <test_cut_paste_pages+0x2ab>
f0111550:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0111554:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f011155b:	83 ec 04             	sub    $0x4,%esp
f011155e:	6a 00                	push   $0x0
f0111560:	68 00 00 90 02       	push   $0x2900000
f0111565:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111568:	e8 b7 41 00 00       	call   f0115724 <CB>
f011156d:	83 c4 10             	add    $0x10,%esp
f0111570:	85 c0                	test   %eax,%eax
f0111572:	0f 84 f6 00 00 00    	je     f011166e <test_cut_paste_pages+0x3c5>
f0111578:	83 ec 04             	sub    $0x4,%esp
f011157b:	6a 00                	push   $0x0
f011157d:	68 00 10 90 02       	push   $0x2901000
f0111582:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111585:	e8 9a 41 00 00       	call   f0115724 <CB>
f011158a:	83 c4 10             	add    $0x10,%esp
f011158d:	85 c0                	test   %eax,%eax
f011158f:	0f 84 d9 00 00 00    	je     f011166e <test_cut_paste_pages+0x3c5>
f0111595:	83 ec 04             	sub    $0x4,%esp
f0111598:	6a 00                	push   $0x0
f011159a:	68 00 20 90 02       	push   $0x2902000
f011159f:	ff 75 d4             	pushl  -0x2c(%ebp)
f01115a2:	e8 7d 41 00 00       	call   f0115724 <CB>
f01115a7:	83 c4 10             	add    $0x10,%esp
f01115aa:	85 c0                	test   %eax,%eax
f01115ac:	0f 84 bc 00 00 00    	je     f011166e <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f01115b2:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f01115b9:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f01115c0:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f01115c7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01115ca:	8a 00                	mov    (%eax),%al
f01115cc:	3c 61                	cmp    $0x61,%al
f01115ce:	75 12                	jne    f01115e2 <test_cut_paste_pages+0x339>
f01115d0:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01115d3:	8a 00                	mov    (%eax),%al
f01115d5:	3c 62                	cmp    $0x62,%al
f01115d7:	75 09                	jne    f01115e2 <test_cut_paste_pages+0x339>
f01115d9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01115dc:	8a 00                	mov    (%eax),%al
f01115de:	3c 63                	cmp    $0x63,%al
f01115e0:	74 21                	je     f0111603 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01115e2:	83 ec 04             	sub    $0x4,%esp
f01115e5:	68 48 87 12 f0       	push   $0xf0128748
f01115ea:	68 19 02 00 00       	push   $0x219
f01115ef:	68 02 82 12 f0       	push   $0xf0128202
f01115f4:	e8 dd ee fe ff       	call   f01004d6 <_warn>
f01115f9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01115fc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0111603:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111607:	74 04                	je     f011160d <test_cut_paste_pages+0x364>
f0111609:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011160d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0111614:	83 ec 04             	sub    $0x4,%esp
f0111617:	6a 01                	push   $0x1
f0111619:	68 00 10 90 02       	push   $0x2901000
f011161e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111621:	e8 fe 40 00 00       	call   f0115724 <CB>
f0111626:	83 c4 10             	add    $0x10,%esp
f0111629:	85 c0                	test   %eax,%eax
f011162b:	74 41                	je     f011166e <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f011162d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111630:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0111633:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111636:	8a 00                	mov    (%eax),%al
f0111638:	3c 79                	cmp    $0x79,%al
f011163a:	74 21                	je     f011165d <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011163c:	83 ec 04             	sub    $0x4,%esp
f011163f:	68 48 87 12 f0       	push   $0xf0128748
f0111644:	68 24 02 00 00       	push   $0x224
f0111649:	68 02 82 12 f0       	push   $0xf0128202
f011164e:	e8 83 ee fe ff       	call   f01004d6 <_warn>
f0111653:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0111656:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f011165d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111661:	74 04                	je     f0111667 <test_cut_paste_pages+0x3be>
f0111663:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0111667:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f011166e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111671:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0111674:	6a 02                	push   $0x2
f0111676:	68 00 f0 bf 02       	push   $0x2bff000
f011167b:	68 00 10 90 02       	push   $0x2901000
f0111680:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111683:	e8 58 88 ff ff       	call   f0109ee0 <cut_paste_pages>
f0111688:	83 c4 10             	add    $0x10,%esp
f011168b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f011168e:	e8 93 c3 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0111693:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0111696:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f011169a:	75 0b                	jne    f01116a7 <test_cut_paste_pages+0x3fe>
f011169c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011169f:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01116a2:	83 f8 01             	cmp    $0x1,%eax
f01116a5:	74 2b                	je     f01116d2 <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01116a7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01116aa:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01116ad:	83 ec 0c             	sub    $0xc,%esp
f01116b0:	50                   	push   %eax
f01116b1:	ff 75 b4             	pushl  -0x4c(%ebp)
f01116b4:	68 a8 86 12 f0       	push   $0xf01286a8
f01116b9:	68 35 02 00 00       	push   $0x235
f01116be:	68 02 82 12 f0       	push   $0xf0128202
f01116c3:	e8 0e ee fe ff       	call   f01004d6 <_warn>
f01116c8:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01116cb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01116d2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01116d6:	74 04                	je     f01116dc <test_cut_paste_pages+0x433>
f01116d8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01116dc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01116e3:	83 ec 08             	sub    $0x8,%esp
f01116e6:	6a 00                	push   $0x0
f01116e8:	6a 01                	push   $0x1
f01116ea:	6a 00                	push   $0x0
f01116ec:	68 ff 0f 00 00       	push   $0xfff
f01116f1:	ff 75 bc             	pushl  -0x44(%ebp)
f01116f4:	6a 01                	push   $0x1
f01116f6:	68 00 20 00 00       	push   $0x2000
f01116fb:	68 00 f0 bf 02       	push   $0x2bff000
f0111700:	68 00 10 90 02       	push   $0x2901000
f0111705:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111708:	e8 3b 42 00 00       	call   f0115948 <CCP>
f011170d:	83 c4 30             	add    $0x30,%esp
f0111710:	83 f8 01             	cmp    $0x1,%eax
f0111713:	74 21                	je     f0111736 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0111715:	83 ec 04             	sub    $0x4,%esp
f0111718:	68 fc 86 12 f0       	push   $0xf01286fc
f011171d:	68 3d 02 00 00       	push   $0x23d
f0111722:	68 02 82 12 f0       	push   $0xf0128202
f0111727:	e8 aa ed fe ff       	call   f01004d6 <_warn>
f011172c:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011172f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0111736:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011173a:	74 04                	je     f0111740 <test_cut_paste_pages+0x497>
f011173c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0111740:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0111747:	83 ec 04             	sub    $0x4,%esp
f011174a:	6a 00                	push   $0x0
f011174c:	68 ff f7 bf 02       	push   $0x2bff7ff
f0111751:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111754:	e8 cb 3f 00 00       	call   f0115724 <CB>
f0111759:	83 c4 10             	add    $0x10,%esp
f011175c:	85 c0                	test   %eax,%eax
f011175e:	74 6b                	je     f01117cb <test_cut_paste_pages+0x522>
f0111760:	83 ec 04             	sub    $0x4,%esp
f0111763:	6a 00                	push   $0x0
f0111765:	68 ff 0f c0 02       	push   $0x2c00fff
f011176a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011176d:	e8 b2 3f 00 00       	call   f0115724 <CB>
f0111772:	83 c4 10             	add    $0x10,%esp
f0111775:	85 c0                	test   %eax,%eax
f0111777:	74 52                	je     f01117cb <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0111779:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0111780:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0111787:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011178a:	8a 00                	mov    (%eax),%al
f011178c:	3c 79                	cmp    $0x79,%al
f011178e:	75 09                	jne    f0111799 <test_cut_paste_pages+0x4f0>
f0111790:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111793:	8a 00                	mov    (%eax),%al
f0111795:	3c 63                	cmp    $0x63,%al
f0111797:	74 21                	je     f01117ba <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0111799:	83 ec 04             	sub    $0x4,%esp
f011179c:	68 48 87 12 f0       	push   $0xf0128748
f01117a1:	68 49 02 00 00       	push   $0x249
f01117a6:	68 02 82 12 f0       	push   $0xf0128202
f01117ab:	e8 26 ed fe ff       	call   f01004d6 <_warn>
f01117b0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01117b3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01117ba:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01117be:	74 04                	je     f01117c4 <test_cut_paste_pages+0x51b>
f01117c0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01117c4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f01117cb:	83 ec 0c             	sub    $0xc,%esp
f01117ce:	68 81 87 12 f0       	push   $0xf0128781
f01117d3:	e8 b3 f7 fe ff       	call   f0100f8b <cprintf>
f01117d8:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f01117db:	83 ec 0c             	sub    $0xc,%esp
f01117de:	68 90 87 12 f0       	push   $0xf0128790
f01117e3:	e8 a3 f7 fe ff       	call   f0100f8b <cprintf>
f01117e8:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f01117eb:	83 ec 04             	sub    $0x4,%esp
f01117ee:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01117f4:	50                   	push   %eax
f01117f5:	68 b9 87 12 f0       	push   $0xf01287b9
f01117fa:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111800:	50                   	push   %eax
f0111801:	e8 c6 d8 00 00       	call   f011f0cc <strcconcat>
f0111806:	83 c4 10             	add    $0x10,%esp
f0111809:	83 ec 0c             	sub    $0xc,%esp
f011180c:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0111812:	50                   	push   %eax
f0111813:	e8 e3 06 ff ff       	call   f0101efb <execute_command>
f0111818:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f011181b:	83 ec 04             	sub    $0x4,%esp
f011181e:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0111824:	50                   	push   %eax
f0111825:	68 c4 87 12 f0       	push   $0xf01287c4
f011182a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111830:	50                   	push   %eax
f0111831:	e8 96 d8 00 00       	call   f011f0cc <strcconcat>
f0111836:	83 c4 10             	add    $0x10,%esp
f0111839:	83 ec 0c             	sub    $0xc,%esp
f011183c:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0111842:	50                   	push   %eax
f0111843:	e8 b3 06 ff ff       	call   f0101efb <execute_command>
f0111848:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f011184b:	83 ec 04             	sub    $0x4,%esp
f011184e:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0111854:	50                   	push   %eax
f0111855:	68 cf 87 12 f0       	push   $0xf01287cf
f011185a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111860:	50                   	push   %eax
f0111861:	e8 66 d8 00 00       	call   f011f0cc <strcconcat>
f0111866:	83 c4 10             	add    $0x10,%esp
f0111869:	83 ec 0c             	sub    $0xc,%esp
f011186c:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0111872:	50                   	push   %eax
f0111873:	e8 83 06 ff ff       	call   f0101efb <execute_command>
f0111878:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f011187b:	83 ec 04             	sub    $0x4,%esp
f011187e:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0111884:	50                   	push   %eax
f0111885:	68 da 87 12 f0       	push   $0xf01287da
f011188a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111890:	50                   	push   %eax
f0111891:	e8 36 d8 00 00       	call   f011f0cc <strcconcat>
f0111896:	83 c4 10             	add    $0x10,%esp
f0111899:	83 ec 0c             	sub    $0xc,%esp
f011189c:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f01118a2:	50                   	push   %eax
f01118a3:	e8 53 06 ff ff       	call   f0101efb <execute_command>
f01118a8:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f01118ab:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f01118b2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01118b5:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f01118b8:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f01118bf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01118c2:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f01118c5:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f01118cc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01118cf:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f01118d2:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f01118d9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01118dc:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f01118df:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f01118e6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01118e9:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f01118ec:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f01118f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01118f6:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f01118f9:	83 ec 08             	sub    $0x8,%esp
f01118fc:	68 00 00 c0 01       	push   $0x1c00000
f0111901:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111904:	e8 ec 3f 00 00       	call   f01158f5 <GP>
f0111909:	83 c4 10             	add    $0x10,%esp
f011190c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f011190f:	83 ec 08             	sub    $0x8,%esp
f0111912:	68 00 00 40 01       	push   $0x1400000
f0111917:	ff 75 d4             	pushl  -0x2c(%ebp)
f011191a:	e8 d6 3f 00 00       	call   f01158f5 <GP>
f011191f:	83 c4 10             	add    $0x10,%esp
f0111922:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0111925:	e8 fc c0 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011192a:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f011192d:	6a 01                	push   $0x1
f011192f:	68 00 00 40 01       	push   $0x1400000
f0111934:	68 00 00 c0 01       	push   $0x1c00000
f0111939:	ff 75 d4             	pushl  -0x2c(%ebp)
f011193c:	e8 9f 85 ff ff       	call   f0109ee0 <cut_paste_pages>
f0111941:	83 c4 10             	add    $0x10,%esp
f0111944:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0111947:	e8 da c0 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011194c:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f011194f:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0111953:	75 08                	jne    f011195d <test_cut_paste_pages+0x6b4>
f0111955:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111958:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011195b:	74 2b                	je     f0111988 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011195d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111960:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111963:	83 ec 0c             	sub    $0xc,%esp
f0111966:	50                   	push   %eax
f0111967:	ff 75 b4             	pushl  -0x4c(%ebp)
f011196a:	68 e8 87 12 f0       	push   $0xf01287e8
f011196f:	68 6c 02 00 00       	push   $0x26c
f0111974:	68 02 82 12 f0       	push   $0xf0128202
f0111979:	e8 58 eb fe ff       	call   f01004d6 <_warn>
f011197e:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0111981:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0111988:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011198c:	74 04                	je     f0111992 <test_cut_paste_pages+0x6e9>
f011198e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0111992:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0111999:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f01119a0:	83 ec 08             	sub    $0x8,%esp
f01119a3:	6a 00                	push   $0x0
f01119a5:	68 ff 0f 00 00       	push   $0xfff
f01119aa:	ff 75 a4             	pushl  -0x5c(%ebp)
f01119ad:	68 ff 0f 00 00       	push   $0xfff
f01119b2:	ff 75 a0             	pushl  -0x60(%ebp)
f01119b5:	6a 01                	push   $0x1
f01119b7:	68 00 10 00 00       	push   $0x1000
f01119bc:	68 00 00 40 01       	push   $0x1400000
f01119c1:	68 00 00 c0 01       	push   $0x1c00000
f01119c6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01119c9:	e8 7a 3f 00 00       	call   f0115948 <CCP>
f01119ce:	83 c4 30             	add    $0x30,%esp
f01119d1:	83 f8 01             	cmp    $0x1,%eax
f01119d4:	74 28                	je     f01119fe <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01119d6:	83 ec 04             	sub    $0x4,%esp
f01119d9:	68 fc 86 12 f0       	push   $0xf01286fc
f01119de:	68 75 02 00 00       	push   $0x275
f01119e3:	68 02 82 12 f0       	push   $0xf0128202
f01119e8:	e8 e9 ea fe ff       	call   f01004d6 <_warn>
f01119ed:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01119f0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f01119f7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f01119fe:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111a02:	74 04                	je     f0111a08 <test_cut_paste_pages+0x75f>
f0111a04:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0111a08:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0111a0f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0111a13:	0f 84 92 00 00 00    	je     f0111aab <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0111a19:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0111a20:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0111a27:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0111a2e:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0111a35:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0111a3c:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111a43:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111a46:	8a 00                	mov    (%eax),%al
f0111a48:	3c 61                	cmp    $0x61,%al
f0111a4a:	75 2d                	jne    f0111a79 <test_cut_paste_pages+0x7d0>
f0111a4c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111a4f:	8a 00                	mov    (%eax),%al
f0111a51:	3c 78                	cmp    $0x78,%al
f0111a53:	75 24                	jne    f0111a79 <test_cut_paste_pages+0x7d0>
f0111a55:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111a58:	8a 00                	mov    (%eax),%al
f0111a5a:	3c 62                	cmp    $0x62,%al
f0111a5c:	75 1b                	jne    f0111a79 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111a5e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0111a61:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111a63:	3c 79                	cmp    $0x79,%al
f0111a65:	75 12                	jne    f0111a79 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111a67:	8b 45 98             	mov    -0x68(%ebp),%eax
f0111a6a:	8a 00                	mov    (%eax),%al
f0111a6c:	3c 63                	cmp    $0x63,%al
f0111a6e:	75 09                	jne    f0111a79 <test_cut_paste_pages+0x7d0>
f0111a70:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0111a73:	8a 00                	mov    (%eax),%al
f0111a75:	3c 7a                	cmp    $0x7a,%al
f0111a77:	74 21                	je     f0111a9a <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0111a79:	83 ec 04             	sub    $0x4,%esp
f0111a7c:	68 48 87 12 f0       	push   $0xf0128748
f0111a81:	68 87 02 00 00       	push   $0x287
f0111a86:	68 02 82 12 f0       	push   $0xf0128202
f0111a8b:	e8 46 ea fe ff       	call   f01004d6 <_warn>
f0111a90:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0111a93:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0111a9a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111a9e:	74 04                	je     f0111aa4 <test_cut_paste_pages+0x7fb>
f0111aa0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0111aa4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0111aab:	e8 76 bf ff ff       	call   f010da26 <sys_calculate_free_frames>
f0111ab0:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0111ab3:	6a 03                	push   $0x3
f0111ab5:	68 00 f0 bf 01       	push   $0x1bff000
f0111aba:	68 00 00 40 01       	push   $0x1400000
f0111abf:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111ac2:	e8 19 84 ff ff       	call   f0109ee0 <cut_paste_pages>
f0111ac7:	83 c4 10             	add    $0x10,%esp
f0111aca:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0111acd:	e8 54 bf ff ff       	call   f010da26 <sys_calculate_free_frames>
f0111ad2:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0111ad5:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0111ad9:	75 08                	jne    f0111ae3 <test_cut_paste_pages+0x83a>
f0111adb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111ade:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0111ae1:	74 2b                	je     f0111b0e <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0111ae3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111ae6:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111ae9:	83 ec 0c             	sub    $0xc,%esp
f0111aec:	50                   	push   %eax
f0111aed:	ff 75 b4             	pushl  -0x4c(%ebp)
f0111af0:	68 e8 87 12 f0       	push   $0xf01287e8
f0111af5:	68 96 02 00 00       	push   $0x296
f0111afa:	68 02 82 12 f0       	push   $0xf0128202
f0111aff:	e8 d2 e9 fe ff       	call   f01004d6 <_warn>
f0111b04:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0111b07:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0111b0e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111b12:	74 04                	je     f0111b18 <test_cut_paste_pages+0x86f>
f0111b14:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0111b18:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0111b1f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0111b26:	83 ec 04             	sub    $0x4,%esp
f0111b29:	6a 00                	push   $0x0
f0111b2b:	68 00 00 40 01       	push   $0x1400000
f0111b30:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111b33:	e8 ec 3b 00 00       	call   f0115724 <CB>
f0111b38:	83 c4 10             	add    $0x10,%esp
f0111b3b:	83 f8 01             	cmp    $0x1,%eax
f0111b3e:	0f 85 80 00 00 00    	jne    f0111bc4 <test_cut_paste_pages+0x91b>
f0111b44:	83 ec 04             	sub    $0x4,%esp
f0111b47:	6a 00                	push   $0x0
f0111b49:	68 00 10 40 01       	push   $0x1401000
f0111b4e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111b51:	e8 ce 3b 00 00       	call   f0115724 <CB>
f0111b56:	83 c4 10             	add    $0x10,%esp
f0111b59:	83 f8 01             	cmp    $0x1,%eax
f0111b5c:	75 66                	jne    f0111bc4 <test_cut_paste_pages+0x91b>
f0111b5e:	83 ec 04             	sub    $0x4,%esp
f0111b61:	6a 00                	push   $0x0
f0111b63:	68 00 20 40 01       	push   $0x1402000
f0111b68:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111b6b:	e8 b4 3b 00 00       	call   f0115724 <CB>
f0111b70:	83 c4 10             	add    $0x10,%esp
f0111b73:	83 f8 01             	cmp    $0x1,%eax
f0111b76:	75 4c                	jne    f0111bc4 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0111b78:	83 ec 04             	sub    $0x4,%esp
f0111b7b:	6a 00                	push   $0x0
f0111b7d:	68 00 f0 bf 01       	push   $0x1bff000
f0111b82:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111b85:	e8 9a 3b 00 00       	call   f0115724 <CB>
f0111b8a:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0111b8d:	85 c0                	test   %eax,%eax
f0111b8f:	75 33                	jne    f0111bc4 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0111b91:	83 ec 04             	sub    $0x4,%esp
f0111b94:	6a 00                	push   $0x0
f0111b96:	68 00 00 c0 01       	push   $0x1c00000
f0111b9b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111b9e:	e8 81 3b 00 00       	call   f0115724 <CB>
f0111ba3:	83 c4 10             	add    $0x10,%esp
f0111ba6:	83 f8 01             	cmp    $0x1,%eax
f0111ba9:	75 19                	jne    f0111bc4 <test_cut_paste_pages+0x91b>
f0111bab:	83 ec 04             	sub    $0x4,%esp
f0111bae:	6a 00                	push   $0x0
f0111bb0:	68 00 10 c0 01       	push   $0x1c01000
f0111bb5:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111bb8:	e8 67 3b 00 00       	call   f0115724 <CB>
f0111bbd:	83 c4 10             	add    $0x10,%esp
f0111bc0:	85 c0                	test   %eax,%eax
f0111bc2:	74 28                	je     f0111bec <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0111bc4:	83 ec 04             	sub    $0x4,%esp
f0111bc7:	68 48 88 12 f0       	push   $0xf0128848
f0111bcc:	68 9f 02 00 00       	push   $0x29f
f0111bd1:	68 02 82 12 f0       	push   $0xf0128202
f0111bd6:	e8 fb e8 fe ff       	call   f01004d6 <_warn>
f0111bdb:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111bde:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0111be5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0111bec:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111bf0:	74 04                	je     f0111bf6 <test_cut_paste_pages+0x94d>
f0111bf2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0111bf6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0111bfd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0111c01:	0f 84 99 00 00 00    	je     f0111ca0 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0111c07:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0111c0e:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0111c15:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0111c1c:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0111c23:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0111c2a:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111c31:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111c34:	8a 00                	mov    (%eax),%al
f0111c36:	3c 61                	cmp    $0x61,%al
f0111c38:	75 2d                	jne    f0111c67 <test_cut_paste_pages+0x9be>
f0111c3a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111c3d:	8a 00                	mov    (%eax),%al
f0111c3f:	3c 78                	cmp    $0x78,%al
f0111c41:	75 24                	jne    f0111c67 <test_cut_paste_pages+0x9be>
f0111c43:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111c46:	8a 00                	mov    (%eax),%al
f0111c48:	3c 62                	cmp    $0x62,%al
f0111c4a:	75 1b                	jne    f0111c67 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111c4c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0111c4f:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111c51:	3c 79                	cmp    $0x79,%al
f0111c53:	75 12                	jne    f0111c67 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111c55:	8b 45 98             	mov    -0x68(%ebp),%eax
f0111c58:	8a 00                	mov    (%eax),%al
f0111c5a:	3c 63                	cmp    $0x63,%al
f0111c5c:	75 09                	jne    f0111c67 <test_cut_paste_pages+0x9be>
f0111c5e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0111c61:	8a 00                	mov    (%eax),%al
f0111c63:	3c 7a                	cmp    $0x7a,%al
f0111c65:	74 28                	je     f0111c8f <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0111c67:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0111c6e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0111c75:	83 ec 04             	sub    $0x4,%esp
f0111c78:	68 48 87 12 f0       	push   $0xf0128748
f0111c7d:	68 b3 02 00 00       	push   $0x2b3
f0111c82:	68 02 82 12 f0       	push   $0xf0128202
f0111c87:	e8 4a e8 fe ff       	call   f01004d6 <_warn>
f0111c8c:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0111c8f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111c93:	74 04                	je     f0111c99 <test_cut_paste_pages+0x9f0>
f0111c95:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0111c99:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0111ca0:	83 ec 0c             	sub    $0xc,%esp
f0111ca3:	68 81 88 12 f0       	push   $0xf0128881
f0111ca8:	e8 de f2 fe ff       	call   f0100f8b <cprintf>
f0111cad:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0111cb0:	83 ec 08             	sub    $0x8,%esp
f0111cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111cb6:	68 90 88 12 f0       	push   $0xf0128890
f0111cbb:	e8 cb f2 fe ff       	call   f0100f8b <cprintf>
f0111cc0:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0111cc3:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0111cc7:	75 10                	jne    f0111cd9 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0111cc9:	83 ec 0c             	sub    $0xc,%esp
f0111ccc:	68 c4 88 12 f0       	push   $0xf01288c4
f0111cd1:	e8 b5 f2 fe ff       	call   f0100f8b <cprintf>
f0111cd6:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0111cd9:	a1 a4 4a 5f f0       	mov    0xf05f4aa4,%eax
f0111cde:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0111ce1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111ce4:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0111ce7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111cec:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111cef:	5b                   	pop    %ebx
f0111cf0:	5e                   	pop    %esi
f0111cf1:	5f                   	pop    %edi
f0111cf2:	5d                   	pop    %ebp
f0111cf3:	c3                   	ret    

f0111cf4 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0111cf4:	55                   	push   %ebp
f0111cf5:	89 e5                	mov    %esp,%ebp
f0111cf7:	57                   	push   %edi
f0111cf8:	56                   	push   %esi
f0111cf9:	53                   	push   %ebx
f0111cfa:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0111d00:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0111d06:	bb 04 89 12 f0       	mov    $0xf0128904,%ebx
f0111d0b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111d10:	89 c7                	mov    %eax,%edi
f0111d12:	89 de                	mov    %ebx,%esi
f0111d14:	89 d1                	mov    %edx,%ecx
f0111d16:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111d18:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0111d1e:	b9 23 00 00 00       	mov    $0x23,%ecx
f0111d23:	b0 00                	mov    $0x0,%al
f0111d25:	89 d7                	mov    %edx,%edi
f0111d27:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0111d29:	6a 00                	push   $0x0
f0111d2b:	6a 0a                	push   $0xa
f0111d2d:	6a 14                	push   $0x14
f0111d2f:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0111d35:	50                   	push   %eax
f0111d36:	e8 52 84 ff ff       	call   f010a18d <env_create>
f0111d3b:	83 c4 10             	add    $0x10,%esp
f0111d3e:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0111d41:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d44:	8b 40 64             	mov    0x64(%eax),%eax
f0111d47:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0111d4a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d4d:	8b 40 68             	mov    0x68(%eax),%eax
f0111d50:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0111d56:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0111d5c:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0111d5f:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0111d66:	75 70 20 
f0111d69:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0111d70:	00 00 00 
f0111d73:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0111d79:	b9 03 00 00 00       	mov    $0x3,%ecx
f0111d7e:	b8 00 00 00 00       	mov    $0x0,%eax
f0111d83:	89 d7                	mov    %edx,%edi
f0111d85:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0111d87:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d8a:	8b 40 10             	mov    0x10(%eax),%eax
f0111d8d:	83 ec 08             	sub    $0x8,%esp
f0111d90:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0111d96:	52                   	push   %edx
f0111d97:	50                   	push   %eax
f0111d98:	e8 56 d2 00 00       	call   f011eff3 <ltostr>
f0111d9d:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0111da0:	83 ec 04             	sub    $0x4,%esp
f0111da3:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111da9:	50                   	push   %eax
f0111daa:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0111db0:	50                   	push   %eax
f0111db1:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0111db7:	50                   	push   %eax
f0111db8:	e8 0f d3 00 00       	call   f011f0cc <strcconcat>
f0111dbd:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0111dc0:	83 ec 0c             	sub    $0xc,%esp
f0111dc3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111dc6:	e8 49 3b 00 00       	call   f0115914 <ClearUserSpace>
f0111dcb:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0111dce:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0111dd5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0111ddc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0111de3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0111dea:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0111df1:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0111df8:	83 ec 0c             	sub    $0xc,%esp
f0111dfb:	68 38 89 12 f0       	push   $0xf0128938
f0111e00:	e8 86 f1 fe ff       	call   f0100f8b <cprintf>
f0111e05:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0111e08:	83 ec 04             	sub    $0x4,%esp
f0111e0b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111e11:	50                   	push   %eax
f0111e12:	68 6e 89 12 f0       	push   $0xf012896e
f0111e17:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111e1d:	50                   	push   %eax
f0111e1e:	e8 a9 d2 00 00       	call   f011f0cc <strcconcat>
f0111e23:	83 c4 10             	add    $0x10,%esp
f0111e26:	83 ec 0c             	sub    $0xc,%esp
f0111e29:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111e2f:	50                   	push   %eax
f0111e30:	e8 c6 00 ff ff       	call   f0101efb <execute_command>
f0111e35:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0111e38:	83 ec 04             	sub    $0x4,%esp
f0111e3b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111e41:	50                   	push   %eax
f0111e42:	68 73 89 12 f0       	push   $0xf0128973
f0111e47:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111e4d:	50                   	push   %eax
f0111e4e:	e8 79 d2 00 00       	call   f011f0cc <strcconcat>
f0111e53:	83 c4 10             	add    $0x10,%esp
f0111e56:	83 ec 0c             	sub    $0xc,%esp
f0111e59:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111e5f:	50                   	push   %eax
f0111e60:	e8 96 00 ff ff       	call   f0101efb <execute_command>
f0111e65:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0111e68:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0111e6e:	bb 79 8c 12 f0       	mov    $0xf0128c79,%ebx
f0111e73:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111e78:	89 c7                	mov    %eax,%edi
f0111e7a:	89 de                	mov    %ebx,%esi
f0111e7c:	89 d1                	mov    %edx,%ecx
f0111e7e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111e80:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0111e86:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111e8b:	b0 00                	mov    $0x0,%al
f0111e8d:	89 d7                	mov    %edx,%edi
f0111e8f:	f3 aa                	rep stos %al,%es:(%edi)
f0111e91:	83 ec 0c             	sub    $0xc,%esp
f0111e94:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0111e9a:	50                   	push   %eax
f0111e9b:	e8 5b 00 ff ff       	call   f0101efb <execute_command>
f0111ea0:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0111ea3:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0111ea9:	bb dd 8c 12 f0       	mov    $0xf0128cdd,%ebx
f0111eae:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111eb3:	89 c7                	mov    %eax,%edi
f0111eb5:	89 de                	mov    %ebx,%esi
f0111eb7:	89 d1                	mov    %edx,%ecx
f0111eb9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111ebb:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0111ec1:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111ec6:	b0 00                	mov    $0x0,%al
f0111ec8:	89 d7                	mov    %edx,%edi
f0111eca:	f3 aa                	rep stos %al,%es:(%edi)
f0111ecc:	83 ec 0c             	sub    $0xc,%esp
f0111ecf:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0111ed5:	50                   	push   %eax
f0111ed6:	e8 20 00 ff ff       	call   f0101efb <execute_command>
f0111edb:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0111ede:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0111ee4:	bb 41 8d 12 f0       	mov    $0xf0128d41,%ebx
f0111ee9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111eee:	89 c7                	mov    %eax,%edi
f0111ef0:	89 de                	mov    %ebx,%esi
f0111ef2:	89 d1                	mov    %edx,%ecx
f0111ef4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111ef6:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0111efc:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111f01:	b0 00                	mov    $0x0,%al
f0111f03:	89 d7                	mov    %edx,%edi
f0111f05:	f3 aa                	rep stos %al,%es:(%edi)
f0111f07:	83 ec 0c             	sub    $0xc,%esp
f0111f0a:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0111f10:	50                   	push   %eax
f0111f11:	e8 e5 ff fe ff       	call   f0101efb <execute_command>
f0111f16:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0111f19:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0111f1f:	bb a5 8d 12 f0       	mov    $0xf0128da5,%ebx
f0111f24:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111f29:	89 c7                	mov    %eax,%edi
f0111f2b:	89 de                	mov    %ebx,%esi
f0111f2d:	89 d1                	mov    %edx,%ecx
f0111f2f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111f31:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0111f37:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111f3c:	b0 00                	mov    $0x0,%al
f0111f3e:	89 d7                	mov    %edx,%edi
f0111f40:	f3 aa                	rep stos %al,%es:(%edi)
f0111f42:	83 ec 0c             	sub    $0xc,%esp
f0111f45:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0111f4b:	50                   	push   %eax
f0111f4c:	e8 aa ff fe ff       	call   f0101efb <execute_command>
f0111f51:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0111f54:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0111f5a:	bb 09 8e 12 f0       	mov    $0xf0128e09,%ebx
f0111f5f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111f64:	89 c7                	mov    %eax,%edi
f0111f66:	89 de                	mov    %ebx,%esi
f0111f68:	89 d1                	mov    %edx,%ecx
f0111f6a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111f6c:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0111f72:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111f77:	b0 00                	mov    $0x0,%al
f0111f79:	89 d7                	mov    %edx,%edi
f0111f7b:	f3 aa                	rep stos %al,%es:(%edi)
f0111f7d:	83 ec 0c             	sub    $0xc,%esp
f0111f80:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0111f86:	50                   	push   %eax
f0111f87:	e8 6f ff fe ff       	call   f0101efb <execute_command>
f0111f8c:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0111f8f:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0111f95:	bb 6d 8e 12 f0       	mov    $0xf0128e6d,%ebx
f0111f9a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111f9f:	89 c7                	mov    %eax,%edi
f0111fa1:	89 de                	mov    %ebx,%esi
f0111fa3:	89 d1                	mov    %edx,%ecx
f0111fa5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111fa7:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0111fad:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111fb2:	b0 00                	mov    $0x0,%al
f0111fb4:	89 d7                	mov    %edx,%edi
f0111fb6:	f3 aa                	rep stos %al,%es:(%edi)
f0111fb8:	83 ec 0c             	sub    $0xc,%esp
f0111fbb:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0111fc1:	50                   	push   %eax
f0111fc2:	e8 34 ff fe ff       	call   f0101efb <execute_command>
f0111fc7:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0111fca:	83 ec 04             	sub    $0x4,%esp
f0111fcd:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0111fd3:	50                   	push   %eax
f0111fd4:	68 7b 89 12 f0       	push   $0xf012897b
f0111fd9:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111fdf:	50                   	push   %eax
f0111fe0:	e8 e7 d0 00 00       	call   f011f0cc <strcconcat>
f0111fe5:	83 c4 10             	add    $0x10,%esp
f0111fe8:	83 ec 0c             	sub    $0xc,%esp
f0111feb:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0111ff1:	50                   	push   %eax
f0111ff2:	e8 04 ff fe ff       	call   f0101efb <execute_command>
f0111ff7:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0111ffa:	83 ec 04             	sub    $0x4,%esp
f0111ffd:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112003:	50                   	push   %eax
f0112004:	68 85 89 12 f0       	push   $0xf0128985
f0112009:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011200f:	50                   	push   %eax
f0112010:	e8 b7 d0 00 00       	call   f011f0cc <strcconcat>
f0112015:	83 c4 10             	add    $0x10,%esp
f0112018:	83 ec 0c             	sub    $0xc,%esp
f011201b:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112021:	50                   	push   %eax
f0112022:	e8 d4 fe fe ff       	call   f0101efb <execute_command>
f0112027:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f011202a:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112030:	bb d1 8e 12 f0       	mov    $0xf0128ed1,%ebx
f0112035:	ba 0f 00 00 00       	mov    $0xf,%edx
f011203a:	89 c7                	mov    %eax,%edi
f011203c:	89 de                	mov    %ebx,%esi
f011203e:	89 d1                	mov    %edx,%ecx
f0112040:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112042:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112048:	b9 55 00 00 00       	mov    $0x55,%ecx
f011204d:	b0 00                	mov    $0x0,%al
f011204f:	89 d7                	mov    %edx,%edi
f0112051:	f3 aa                	rep stos %al,%es:(%edi)
f0112053:	83 ec 0c             	sub    $0xc,%esp
f0112056:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011205c:	50                   	push   %eax
f011205d:	e8 99 fe fe ff       	call   f0101efb <execute_command>
f0112062:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0112065:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011206b:	bb 35 8f 12 f0       	mov    $0xf0128f35,%ebx
f0112070:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112075:	89 c7                	mov    %eax,%edi
f0112077:	89 de                	mov    %ebx,%esi
f0112079:	89 d1                	mov    %edx,%ecx
f011207b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011207d:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112083:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112088:	b0 00                	mov    $0x0,%al
f011208a:	89 d7                	mov    %edx,%edi
f011208c:	f3 aa                	rep stos %al,%es:(%edi)
f011208e:	83 ec 0c             	sub    $0xc,%esp
f0112091:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112097:	50                   	push   %eax
f0112098:	e8 5e fe fe ff       	call   f0101efb <execute_command>
f011209d:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f01120a0:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01120a6:	bb 99 8f 12 f0       	mov    $0xf0128f99,%ebx
f01120ab:	ba 0f 00 00 00       	mov    $0xf,%edx
f01120b0:	89 c7                	mov    %eax,%edi
f01120b2:	89 de                	mov    %ebx,%esi
f01120b4:	89 d1                	mov    %edx,%ecx
f01120b6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01120b8:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01120be:	b9 55 00 00 00       	mov    $0x55,%ecx
f01120c3:	b0 00                	mov    $0x0,%al
f01120c5:	89 d7                	mov    %edx,%edi
f01120c7:	f3 aa                	rep stos %al,%es:(%edi)
f01120c9:	83 ec 0c             	sub    $0xc,%esp
f01120cc:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01120d2:	50                   	push   %eax
f01120d3:	e8 23 fe fe ff       	call   f0101efb <execute_command>
f01120d8:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f01120db:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01120e2:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f01120e9:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f01120f0:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f01120f7:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f01120fe:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0112105:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f011210c:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0112113:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f011211a:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0112121:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0112128:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f011212f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112132:	8a 00                	mov    (%eax),%al
f0112134:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f011213a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011213d:	8a 00                	mov    (%eax),%al
f011213f:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0112145:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112148:	8a 00                	mov    (%eax),%al
f011214a:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112150:	e8 d1 b8 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0112155:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0112158:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011215b:	89 d0                	mov    %edx,%eax
f011215d:	01 c0                	add    %eax,%eax
f011215f:	01 d0                	add    %edx,%eax
f0112161:	01 c0                	add    %eax,%eax
f0112163:	50                   	push   %eax
f0112164:	68 00 00 10 00       	push   $0x100000
f0112169:	6a 00                	push   $0x0
f011216b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011216e:	e8 87 7d ff ff       	call   f0109efa <copy_paste_chunk>
f0112173:	83 c4 10             	add    $0x10,%esp
f0112176:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112179:	e8 a8 b8 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011217e:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0112181:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0112188:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f011218c:	75 08                	jne    f0112196 <test_copy_paste_chunk+0x4a2>
f011218e:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112191:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0112194:	74 2b                	je     f01121c1 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112196:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112199:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011219c:	83 ec 0c             	sub    $0xc,%esp
f011219f:	50                   	push   %eax
f01121a0:	ff 75 88             	pushl  -0x78(%ebp)
f01121a3:	68 94 89 12 f0       	push   $0xf0128994
f01121a8:	68 06 03 00 00       	push   $0x306
f01121ad:	68 02 82 12 f0       	push   $0xf0128202
f01121b2:	e8 1f e3 fe ff       	call   f01004d6 <_warn>
f01121b7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01121ba:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01121c1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01121c5:	74 04                	je     f01121cb <test_copy_paste_chunk+0x4d7>
f01121c7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01121cb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f01121d2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01121d5:	8a 00                	mov    (%eax),%al
f01121d7:	3c 61                	cmp    $0x61,%al
f01121d9:	75 75                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f01121db:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01121de:	8a 00                	mov    (%eax),%al
f01121e0:	3c 78                	cmp    $0x78,%al
f01121e2:	75 6c                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f01121e4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01121e7:	8a 00                	mov    (%eax),%al
f01121e9:	3c 62                	cmp    $0x62,%al
f01121eb:	75 63                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f01121ed:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01121f0:	8a 00                	mov    (%eax),%al
f01121f2:	3c 79                	cmp    $0x79,%al
f01121f4:	75 5a                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f01121f6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01121f9:	8a 00                	mov    (%eax),%al
f01121fb:	3c 63                	cmp    $0x63,%al
f01121fd:	75 51                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f01121ff:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112202:	8a 00                	mov    (%eax),%al
f0112204:	3c 7a                	cmp    $0x7a,%al
f0112206:	75 48                	jne    f0112250 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0112208:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011220b:	8a 00                	mov    (%eax),%al
f011220d:	3c 64                	cmp    $0x64,%al
f011220f:	75 3f                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f0112211:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112214:	8a 10                	mov    (%eax),%dl
f0112216:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f011221c:	38 c2                	cmp    %al,%dl
f011221e:	75 30                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f0112220:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112223:	8a 00                	mov    (%eax),%al
f0112225:	3c 65                	cmp    $0x65,%al
f0112227:	75 27                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f0112229:	8b 45 98             	mov    -0x68(%ebp),%eax
f011222c:	8a 10                	mov    (%eax),%dl
f011222e:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0112234:	38 c2                	cmp    %al,%dl
f0112236:	75 18                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f0112238:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011223b:	8a 00                	mov    (%eax),%al
f011223d:	3c 66                	cmp    $0x66,%al
f011223f:	75 0f                	jne    f0112250 <test_copy_paste_chunk+0x55c>
f0112241:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112244:	8a 10                	mov    (%eax),%dl
f0112246:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011224c:	38 c2                	cmp    %al,%dl
f011224e:	74 21                	je     f0112271 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112250:	83 ec 04             	sub    $0x4,%esp
f0112253:	68 f8 89 12 f0       	push   $0xf01289f8
f0112258:	68 0f 03 00 00       	push   $0x30f
f011225d:	68 02 82 12 f0       	push   $0xf0128202
f0112262:	e8 6f e2 fe ff       	call   f01004d6 <_warn>
f0112267:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011226a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112271:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112275:	74 04                	je     f011227b <test_copy_paste_chunk+0x587>
f0112277:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011227b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0112282:	83 ec 0c             	sub    $0xc,%esp
f0112285:	68 32 8a 12 f0       	push   $0xf0128a32
f011228a:	e8 fc ec fe ff       	call   f0100f8b <cprintf>
f011228f:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0112292:	83 ec 0c             	sub    $0xc,%esp
f0112295:	68 44 8a 12 f0       	push   $0xf0128a44
f011229a:	e8 ec ec fe ff       	call   f0100f8b <cprintf>
f011229f:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f01122a2:	83 ec 04             	sub    $0x4,%esp
f01122a5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01122ab:	50                   	push   %eax
f01122ac:	68 7a 8a 12 f0       	push   $0xf0128a7a
f01122b1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01122b7:	50                   	push   %eax
f01122b8:	e8 0f ce 00 00       	call   f011f0cc <strcconcat>
f01122bd:	83 c4 10             	add    $0x10,%esp
f01122c0:	83 ec 0c             	sub    $0xc,%esp
f01122c3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01122c9:	50                   	push   %eax
f01122ca:	e8 2c fc fe ff       	call   f0101efb <execute_command>
f01122cf:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f01122d2:	83 ec 04             	sub    $0x4,%esp
f01122d5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01122db:	50                   	push   %eax
f01122dc:	68 84 8a 12 f0       	push   $0xf0128a84
f01122e1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01122e7:	50                   	push   %eax
f01122e8:	e8 df cd 00 00       	call   f011f0cc <strcconcat>
f01122ed:	83 c4 10             	add    $0x10,%esp
f01122f0:	83 ec 0c             	sub    $0xc,%esp
f01122f3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01122f9:	50                   	push   %eax
f01122fa:	e8 fc fb fe ff       	call   f0101efb <execute_command>
f01122ff:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0112302:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112308:	bb fd 8f 12 f0       	mov    $0xf0128ffd,%ebx
f011230d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112312:	89 c7                	mov    %eax,%edi
f0112314:	89 de                	mov    %ebx,%esi
f0112316:	89 d1                	mov    %edx,%ecx
f0112318:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011231a:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112320:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112325:	b0 00                	mov    $0x0,%al
f0112327:	89 d7                	mov    %edx,%edi
f0112329:	f3 aa                	rep stos %al,%es:(%edi)
f011232b:	83 ec 0c             	sub    $0xc,%esp
f011232e:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112334:	50                   	push   %eax
f0112335:	e8 c1 fb fe ff       	call   f0101efb <execute_command>
f011233a:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f011233d:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112343:	bb 61 90 12 f0       	mov    $0xf0129061,%ebx
f0112348:	ba 0f 00 00 00       	mov    $0xf,%edx
f011234d:	89 c7                	mov    %eax,%edi
f011234f:	89 de                	mov    %ebx,%esi
f0112351:	89 d1                	mov    %edx,%ecx
f0112353:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112355:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f011235b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112360:	b0 00                	mov    $0x0,%al
f0112362:	89 d7                	mov    %edx,%edi
f0112364:	f3 aa                	rep stos %al,%es:(%edi)
f0112366:	83 ec 0c             	sub    $0xc,%esp
f0112369:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011236f:	50                   	push   %eax
f0112370:	e8 86 fb fe ff       	call   f0101efb <execute_command>
f0112375:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0112378:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011237e:	bb c5 90 12 f0       	mov    $0xf01290c5,%ebx
f0112383:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112388:	89 c7                	mov    %eax,%edi
f011238a:	89 de                	mov    %ebx,%esi
f011238c:	89 d1                	mov    %edx,%ecx
f011238e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112390:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112396:	b9 55 00 00 00       	mov    $0x55,%ecx
f011239b:	b0 00                	mov    $0x0,%al
f011239d:	89 d7                	mov    %edx,%edi
f011239f:	f3 aa                	rep stos %al,%es:(%edi)
f01123a1:	83 ec 0c             	sub    $0xc,%esp
f01123a4:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01123aa:	50                   	push   %eax
f01123ab:	e8 4b fb fe ff       	call   f0101efb <execute_command>
f01123b0:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f01123b3:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01123b9:	bb 29 91 12 f0       	mov    $0xf0129129,%ebx
f01123be:	ba 0f 00 00 00       	mov    $0xf,%edx
f01123c3:	89 c7                	mov    %eax,%edi
f01123c5:	89 de                	mov    %ebx,%esi
f01123c7:	89 d1                	mov    %edx,%ecx
f01123c9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01123cb:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01123d1:	b9 55 00 00 00       	mov    $0x55,%ecx
f01123d6:	b0 00                	mov    $0x0,%al
f01123d8:	89 d7                	mov    %edx,%edi
f01123da:	f3 aa                	rep stos %al,%es:(%edi)
f01123dc:	83 ec 0c             	sub    $0xc,%esp
f01123df:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01123e5:	50                   	push   %eax
f01123e6:	e8 10 fb fe ff       	call   f0101efb <execute_command>
f01123eb:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f01123ee:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01123f4:	bb 8d 91 12 f0       	mov    $0xf012918d,%ebx
f01123f9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01123fe:	89 c7                	mov    %eax,%edi
f0112400:	89 de                	mov    %ebx,%esi
f0112402:	89 d1                	mov    %edx,%ecx
f0112404:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112406:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f011240c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112411:	b0 00                	mov    $0x0,%al
f0112413:	89 d7                	mov    %edx,%edi
f0112415:	f3 aa                	rep stos %al,%es:(%edi)
f0112417:	83 ec 0c             	sub    $0xc,%esp
f011241a:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112420:	50                   	push   %eax
f0112421:	e8 d5 fa fe ff       	call   f0101efb <execute_command>
f0112426:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0112429:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011242f:	bb f1 91 12 f0       	mov    $0xf01291f1,%ebx
f0112434:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112439:	89 c7                	mov    %eax,%edi
f011243b:	89 de                	mov    %ebx,%esi
f011243d:	89 d1                	mov    %edx,%ecx
f011243f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112441:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112447:	b9 55 00 00 00       	mov    $0x55,%ecx
f011244c:	b0 00                	mov    $0x0,%al
f011244e:	89 d7                	mov    %edx,%edi
f0112450:	f3 aa                	rep stos %al,%es:(%edi)
f0112452:	83 ec 0c             	sub    $0xc,%esp
f0112455:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011245b:	50                   	push   %eax
f011245c:	e8 9a fa fe ff       	call   f0101efb <execute_command>
f0112461:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0112464:	83 ec 04             	sub    $0x4,%esp
f0112467:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011246d:	50                   	push   %eax
f011246e:	68 8e 8a 12 f0       	push   $0xf0128a8e
f0112473:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112479:	50                   	push   %eax
f011247a:	e8 4d cc 00 00       	call   f011f0cc <strcconcat>
f011247f:	83 c4 10             	add    $0x10,%esp
f0112482:	83 ec 0c             	sub    $0xc,%esp
f0112485:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011248b:	50                   	push   %eax
f011248c:	e8 6a fa fe ff       	call   f0101efb <execute_command>
f0112491:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0112494:	83 ec 04             	sub    $0x4,%esp
f0112497:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011249d:	50                   	push   %eax
f011249e:	68 98 8a 12 f0       	push   $0xf0128a98
f01124a3:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01124a9:	50                   	push   %eax
f01124aa:	e8 1d cc 00 00       	call   f011f0cc <strcconcat>
f01124af:	83 c4 10             	add    $0x10,%esp
f01124b2:	83 ec 0c             	sub    $0xc,%esp
f01124b5:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01124bb:	50                   	push   %eax
f01124bc:	e8 3a fa fe ff       	call   f0101efb <execute_command>
f01124c1:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f01124c4:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01124ca:	bb 55 92 12 f0       	mov    $0xf0129255,%ebx
f01124cf:	ba 0f 00 00 00       	mov    $0xf,%edx
f01124d4:	89 c7                	mov    %eax,%edi
f01124d6:	89 de                	mov    %ebx,%esi
f01124d8:	89 d1                	mov    %edx,%ecx
f01124da:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01124dc:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01124e2:	b9 55 00 00 00       	mov    $0x55,%ecx
f01124e7:	b0 00                	mov    $0x0,%al
f01124e9:	89 d7                	mov    %edx,%edi
f01124eb:	f3 aa                	rep stos %al,%es:(%edi)
f01124ed:	83 ec 0c             	sub    $0xc,%esp
f01124f0:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01124f6:	50                   	push   %eax
f01124f7:	e8 ff f9 fe ff       	call   f0101efb <execute_command>
f01124fc:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f01124ff:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112505:	bb b9 92 12 f0       	mov    $0xf01292b9,%ebx
f011250a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011250f:	89 c7                	mov    %eax,%edi
f0112511:	89 de                	mov    %ebx,%esi
f0112513:	89 d1                	mov    %edx,%ecx
f0112515:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112517:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011251d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112522:	b0 00                	mov    $0x0,%al
f0112524:	89 d7                	mov    %edx,%edi
f0112526:	f3 aa                	rep stos %al,%es:(%edi)
f0112528:	83 ec 0c             	sub    $0xc,%esp
f011252b:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112531:	50                   	push   %eax
f0112532:	e8 c4 f9 fe ff       	call   f0101efb <execute_command>
f0112537:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f011253a:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112540:	bb 1d 93 12 f0       	mov    $0xf012931d,%ebx
f0112545:	ba 0f 00 00 00       	mov    $0xf,%edx
f011254a:	89 c7                	mov    %eax,%edi
f011254c:	89 de                	mov    %ebx,%esi
f011254e:	89 d1                	mov    %edx,%ecx
f0112550:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112552:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112558:	b9 55 00 00 00       	mov    $0x55,%ecx
f011255d:	b0 00                	mov    $0x0,%al
f011255f:	89 d7                	mov    %edx,%edi
f0112561:	f3 aa                	rep stos %al,%es:(%edi)
f0112563:	83 ec 0c             	sub    $0xc,%esp
f0112566:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011256c:	50                   	push   %eax
f011256d:	e8 89 f9 fe ff       	call   f0101efb <execute_command>
f0112572:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0112575:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f011257c:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0112583:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f011258a:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0112591:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0112598:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f011259f:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f01125a6:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f01125ad:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f01125b4:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f01125bb:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f01125c2:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f01125c9:	8b 45 90             	mov    -0x70(%ebp),%eax
f01125cc:	8a 00                	mov    (%eax),%al
f01125ce:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01125d4:	e8 4d b4 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01125d9:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f01125dc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01125df:	89 d0                	mov    %edx,%eax
f01125e1:	01 c0                	add    %eax,%eax
f01125e3:	01 d0                	add    %edx,%eax
f01125e5:	01 c0                	add    %eax,%eax
f01125e7:	50                   	push   %eax
f01125e8:	68 00 00 40 00       	push   $0x400000
f01125ed:	68 00 00 20 00       	push   $0x200000
f01125f2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125f5:	e8 00 79 ff ff       	call   f0109efa <copy_paste_chunk>
f01125fa:	83 c4 10             	add    $0x10,%esp
f01125fd:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112600:	e8 21 b4 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0112605:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0112608:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f011260f:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0112613:	75 08                	jne    f011261d <test_copy_paste_chunk+0x929>
f0112615:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112618:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011261b:	74 2b                	je     f0112648 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011261d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112620:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112623:	83 ec 0c             	sub    $0xc,%esp
f0112626:	50                   	push   %eax
f0112627:	ff 75 80             	pushl  -0x80(%ebp)
f011262a:	68 a4 8a 12 f0       	push   $0xf0128aa4
f011262f:	68 3f 03 00 00       	push   $0x33f
f0112634:	68 02 82 12 f0       	push   $0xf0128202
f0112639:	e8 98 de fe ff       	call   f01004d6 <_warn>
f011263e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112641:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112648:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011264c:	74 04                	je     f0112652 <test_copy_paste_chunk+0x95e>
f011264e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112652:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0112659:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0112660:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0112663:	83 ec 08             	sub    $0x8,%esp
f0112666:	6a 01                	push   $0x1
f0112668:	6a 07                	push   $0x7
f011266a:	6a 07                	push   $0x7
f011266c:	6a 07                	push   $0x7
f011266e:	6a 07                	push   $0x7
f0112670:	6a 01                	push   $0x1
f0112672:	68 00 20 00 00       	push   $0x2000
f0112677:	68 00 00 40 00       	push   $0x400000
f011267c:	68 00 00 20 00       	push   $0x200000
f0112681:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112684:	e8 bf 32 00 00       	call   f0115948 <CCP>
f0112689:	83 c4 30             	add    $0x30,%esp
f011268c:	83 f8 01             	cmp    $0x1,%eax
f011268f:	74 2b                	je     f01126bc <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0112691:	83 ec 04             	sub    $0x4,%esp
f0112694:	68 f8 8a 12 f0       	push   $0xf0128af8
f0112699:	68 48 03 00 00       	push   $0x348
f011269e:	68 02 82 12 f0       	push   $0xf0128202
f01126a3:	e8 2e de fe ff       	call   f01004d6 <_warn>
f01126a8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01126ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f01126b2:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f01126b9:	00 00 00 
		}
		if (correct) eval += 5 ;
f01126bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01126c0:	74 04                	je     f01126c6 <test_copy_paste_chunk+0x9d2>
f01126c2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01126c6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f01126cd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01126d0:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f01126d3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01126d6:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f01126d9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01126dc:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f01126df:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01126e2:	8a 00                	mov    (%eax),%al
f01126e4:	3c 61                	cmp    $0x61,%al
f01126e6:	75 69                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f01126e8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01126eb:	8a 00                	mov    (%eax),%al
f01126ed:	3c 61                	cmp    $0x61,%al
f01126ef:	75 60                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f01126f1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01126f4:	8a 00                	mov    (%eax),%al
f01126f6:	3c 79                	cmp    $0x79,%al
f01126f8:	75 57                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f01126fa:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01126fd:	8a 00                	mov    (%eax),%al
f01126ff:	3c 62                	cmp    $0x62,%al
f0112701:	75 4e                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f0112703:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112706:	8a 00                	mov    (%eax),%al
f0112708:	3c 63                	cmp    $0x63,%al
f011270a:	75 45                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f011270c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011270f:	8a 00                	mov    (%eax),%al
f0112711:	3c 7a                	cmp    $0x7a,%al
f0112713:	75 3c                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0112715:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112718:	8a 00                	mov    (%eax),%al
f011271a:	3c 77                	cmp    $0x77,%al
f011271c:	75 33                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f011271e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112721:	8a 00                	mov    (%eax),%al
f0112723:	3c 64                	cmp    $0x64,%al
f0112725:	75 2a                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f0112727:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011272a:	8a 00                	mov    (%eax),%al
f011272c:	3c 65                	cmp    $0x65,%al
f011272e:	75 21                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f0112730:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112733:	8a 00                	mov    (%eax),%al
f0112735:	3c 65                	cmp    $0x65,%al
f0112737:	75 18                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f0112739:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011273c:	8a 00                	mov    (%eax),%al
f011273e:	3c 66                	cmp    $0x66,%al
f0112740:	75 0f                	jne    f0112751 <test_copy_paste_chunk+0xa5d>
f0112742:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112745:	8a 10                	mov    (%eax),%dl
f0112747:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011274d:	38 c2                	cmp    %al,%dl
f011274f:	74 21                	je     f0112772 <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112751:	83 ec 04             	sub    $0x4,%esp
f0112754:	68 f8 89 12 f0       	push   $0xf01289f8
f0112759:	68 56 03 00 00       	push   $0x356
f011275e:	68 02 82 12 f0       	push   $0xf0128202
f0112763:	e8 6e dd fe ff       	call   f01004d6 <_warn>
f0112768:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011276b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112772:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112776:	74 04                	je     f011277c <test_copy_paste_chunk+0xa88>
f0112778:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011277c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0112783:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112786:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112789:	e8 98 b2 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011278e:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0112791:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0112794:	89 c2                	mov    %eax,%edx
f0112796:	01 d2                	add    %edx,%edx
f0112798:	01 d0                	add    %edx,%eax
f011279a:	50                   	push   %eax
f011279b:	68 00 08 20 00       	push   $0x200800
f01127a0:	68 00 08 40 00       	push   $0x400800
f01127a5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127a8:	e8 4d 77 ff ff       	call   f0109efa <copy_paste_chunk>
f01127ad:	83 c4 10             	add    $0x10,%esp
f01127b0:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01127b3:	e8 6e b2 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01127b8:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01127bb:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01127bf:	75 08                	jne    f01127c9 <test_copy_paste_chunk+0xad5>
f01127c1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01127c4:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01127c7:	74 2b                	je     f01127f4 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01127c9:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01127cc:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01127cf:	83 ec 0c             	sub    $0xc,%esp
f01127d2:	50                   	push   %eax
f01127d3:	ff 75 80             	pushl  -0x80(%ebp)
f01127d6:	68 a4 8a 12 f0       	push   $0xf0128aa4
f01127db:	68 66 03 00 00       	push   $0x366
f01127e0:	68 02 82 12 f0       	push   $0xf0128202
f01127e5:	e8 ec dc fe ff       	call   f01004d6 <_warn>
f01127ea:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01127ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01127f4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01127f8:	74 04                	je     f01127fe <test_copy_paste_chunk+0xb0a>
f01127fa:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01127fe:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0112805:	83 ec 08             	sub    $0x8,%esp
f0112808:	6a 01                	push   $0x1
f011280a:	6a 07                	push   $0x7
f011280c:	6a 07                	push   $0x7
f011280e:	6a 07                	push   $0x7
f0112810:	6a 07                	push   $0x7
f0112812:	6a 01                	push   $0x1
f0112814:	68 00 20 00 00       	push   $0x2000
f0112819:	68 00 00 20 00       	push   $0x200000
f011281e:	68 00 00 40 00       	push   $0x400000
f0112823:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112826:	e8 1d 31 00 00       	call   f0115948 <CCP>
f011282b:	83 c4 30             	add    $0x30,%esp
f011282e:	83 f8 01             	cmp    $0x1,%eax
f0112831:	74 21                	je     f0112854 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0112833:	83 ec 04             	sub    $0x4,%esp
f0112836:	68 44 8b 12 f0       	push   $0xf0128b44
f011283b:	68 6e 03 00 00       	push   $0x36e
f0112840:	68 02 82 12 f0       	push   $0xf0128202
f0112845:	e8 8c dc fe ff       	call   f01004d6 <_warn>
f011284a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011284d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112854:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112858:	74 04                	je     f011285e <test_copy_paste_chunk+0xb6a>
f011285a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011285e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0112865:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112868:	8a 00                	mov    (%eax),%al
f011286a:	3c 61                	cmp    $0x61,%al
f011286c:	75 69                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
f011286e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112871:	8a 00                	mov    (%eax),%al
f0112873:	3c 61                	cmp    $0x61,%al
f0112875:	75 60                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
f0112877:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011287a:	8a 00                	mov    (%eax),%al
f011287c:	3c 79                	cmp    $0x79,%al
f011287e:	75 57                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
f0112880:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112883:	8a 00                	mov    (%eax),%al
f0112885:	3c 62                	cmp    $0x62,%al
f0112887:	75 4e                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
f0112889:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011288c:	8a 00                	mov    (%eax),%al
f011288e:	3c 7a                	cmp    $0x7a,%al
f0112890:	75 45                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
f0112892:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112895:	8a 00                	mov    (%eax),%al
f0112897:	3c 7a                	cmp    $0x7a,%al
f0112899:	75 3c                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f011289b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011289e:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01128a0:	3c 64                	cmp    $0x64,%al
f01128a2:	75 33                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f01128a4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01128a7:	8a 00                	mov    (%eax),%al
f01128a9:	3c 64                	cmp    $0x64,%al
f01128ab:	75 2a                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
f01128ad:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01128b0:	8a 00                	mov    (%eax),%al
f01128b2:	3c 65                	cmp    $0x65,%al
f01128b4:	75 21                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
f01128b6:	8b 45 98             	mov    -0x68(%ebp),%eax
f01128b9:	8a 00                	mov    (%eax),%al
f01128bb:	3c 78                	cmp    $0x78,%al
f01128bd:	75 18                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
f01128bf:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01128c2:	8a 00                	mov    (%eax),%al
f01128c4:	3c 66                	cmp    $0x66,%al
f01128c6:	75 0f                	jne    f01128d7 <test_copy_paste_chunk+0xbe3>
f01128c8:	8b 45 90             	mov    -0x70(%ebp),%eax
f01128cb:	8a 10                	mov    (%eax),%dl
f01128cd:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01128d3:	38 c2                	cmp    %al,%dl
f01128d5:	74 21                	je     f01128f8 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01128d7:	83 ec 04             	sub    $0x4,%esp
f01128da:	68 f8 89 12 f0       	push   $0xf01289f8
f01128df:	68 77 03 00 00       	push   $0x377
f01128e4:	68 02 82 12 f0       	push   $0xf0128202
f01128e9:	e8 e8 db fe ff       	call   f01004d6 <_warn>
f01128ee:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01128f1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01128f8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01128fc:	74 04                	je     f0112902 <test_copy_paste_chunk+0xc0e>
f01128fe:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112902:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0112909:	83 ec 0c             	sub    $0xc,%esp
f011290c:	68 8f 8b 12 f0       	push   $0xf0128b8f
f0112911:	e8 75 e6 fe ff       	call   f0100f8b <cprintf>
f0112916:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0112919:	83 ec 0c             	sub    $0xc,%esp
f011291c:	68 a0 8b 12 f0       	push   $0xf0128ba0
f0112921:	e8 65 e6 fe ff       	call   f0100f8b <cprintf>
f0112926:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0112929:	83 ec 04             	sub    $0x4,%esp
f011292c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112932:	50                   	push   %eax
f0112933:	68 d4 8b 12 f0       	push   $0xf0128bd4
f0112938:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011293e:	50                   	push   %eax
f011293f:	e8 88 c7 00 00       	call   f011f0cc <strcconcat>
f0112944:	83 c4 10             	add    $0x10,%esp
f0112947:	83 ec 0c             	sub    $0xc,%esp
f011294a:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112950:	50                   	push   %eax
f0112951:	e8 a5 f5 fe ff       	call   f0101efb <execute_command>
f0112956:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0112959:	83 ec 04             	sub    $0x4,%esp
f011295c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112962:	50                   	push   %eax
f0112963:	68 de 8b 12 f0       	push   $0xf0128bde
f0112968:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011296e:	50                   	push   %eax
f011296f:	e8 58 c7 00 00       	call   f011f0cc <strcconcat>
f0112974:	83 c4 10             	add    $0x10,%esp
f0112977:	83 ec 0c             	sub    $0xc,%esp
f011297a:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112980:	50                   	push   %eax
f0112981:	e8 75 f5 fe ff       	call   f0101efb <execute_command>
f0112986:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0112989:	83 ec 04             	sub    $0x4,%esp
f011298c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112992:	50                   	push   %eax
f0112993:	68 e8 8b 12 f0       	push   $0xf0128be8
f0112998:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011299e:	50                   	push   %eax
f011299f:	e8 28 c7 00 00       	call   f011f0cc <strcconcat>
f01129a4:	83 c4 10             	add    $0x10,%esp
f01129a7:	83 ec 0c             	sub    $0xc,%esp
f01129aa:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01129b0:	50                   	push   %eax
f01129b1:	e8 45 f5 fe ff       	call   f0101efb <execute_command>
f01129b6:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f01129b9:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01129bf:	bb 81 93 12 f0       	mov    $0xf0129381,%ebx
f01129c4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01129c9:	89 c7                	mov    %eax,%edi
f01129cb:	89 de                	mov    %ebx,%esi
f01129cd:	89 d1                	mov    %edx,%ecx
f01129cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01129d1:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01129d7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01129dc:	b0 00                	mov    $0x0,%al
f01129de:	89 d7                	mov    %edx,%edi
f01129e0:	f3 aa                	rep stos %al,%es:(%edi)
f01129e2:	83 ec 0c             	sub    $0xc,%esp
f01129e5:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01129eb:	50                   	push   %eax
f01129ec:	e8 0a f5 fe ff       	call   f0101efb <execute_command>
f01129f1:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f01129f4:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01129fa:	bb e5 93 12 f0       	mov    $0xf01293e5,%ebx
f01129ff:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112a04:	89 c7                	mov    %eax,%edi
f0112a06:	89 de                	mov    %ebx,%esi
f0112a08:	89 d1                	mov    %edx,%ecx
f0112a0a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112a0c:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112a12:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a17:	b0 00                	mov    $0x0,%al
f0112a19:	89 d7                	mov    %edx,%edi
f0112a1b:	f3 aa                	rep stos %al,%es:(%edi)
f0112a1d:	83 ec 0c             	sub    $0xc,%esp
f0112a20:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112a26:	50                   	push   %eax
f0112a27:	e8 cf f4 fe ff       	call   f0101efb <execute_command>
f0112a2c:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0112a2f:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112a35:	bb 49 94 12 f0       	mov    $0xf0129449,%ebx
f0112a3a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112a3f:	89 c7                	mov    %eax,%edi
f0112a41:	89 de                	mov    %ebx,%esi
f0112a43:	89 d1                	mov    %edx,%ecx
f0112a45:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112a47:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112a4d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a52:	b0 00                	mov    $0x0,%al
f0112a54:	89 d7                	mov    %edx,%edi
f0112a56:	f3 aa                	rep stos %al,%es:(%edi)
f0112a58:	83 ec 0c             	sub    $0xc,%esp
f0112a5b:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112a61:	50                   	push   %eax
f0112a62:	e8 94 f4 fe ff       	call   f0101efb <execute_command>
f0112a67:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112a6a:	e8 b7 af ff ff       	call   f010da26 <sys_calculate_free_frames>
f0112a6f:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0112a72:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112a75:	89 d0                	mov    %edx,%eax
f0112a77:	01 c0                	add    %eax,%eax
f0112a79:	01 d0                	add    %edx,%eax
f0112a7b:	c1 e0 02             	shl    $0x2,%eax
f0112a7e:	50                   	push   %eax
f0112a7f:	68 00 00 90 00       	push   $0x900000
f0112a84:	68 00 00 80 00       	push   $0x800000
f0112a89:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a8c:	e8 69 74 ff ff       	call   f0109efa <copy_paste_chunk>
f0112a91:	83 c4 10             	add    $0x10,%esp
f0112a94:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112a9a:	e8 87 af ff ff       	call   f010da26 <sys_calculate_free_frames>
f0112a9f:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0112aa2:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0112aa9:	75 0b                	jne    f0112ab6 <test_copy_paste_chunk+0xdc2>
f0112aab:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112aae:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112ab1:	83 f8 03             	cmp    $0x3,%eax
f0112ab4:	74 2e                	je     f0112ae4 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112ab6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112ab9:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112abc:	83 ec 0c             	sub    $0xc,%esp
f0112abf:	50                   	push   %eax
f0112ac0:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0112ac6:	68 a4 8a 12 f0       	push   $0xf0128aa4
f0112acb:	68 95 03 00 00       	push   $0x395
f0112ad0:	68 02 82 12 f0       	push   $0xf0128202
f0112ad5:	e8 fc d9 fe ff       	call   f01004d6 <_warn>
f0112ada:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112add:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112ae4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ae8:	74 04                	je     f0112aee <test_copy_paste_chunk+0xdfa>
f0112aea:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112aee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0112af5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0112afc:	83 ec 08             	sub    $0x8,%esp
f0112aff:	6a 01                	push   $0x1
f0112b01:	6a 07                	push   $0x7
f0112b03:	6a 07                	push   $0x7
f0112b05:	6a 07                	push   $0x7
f0112b07:	6a 07                	push   $0x7
f0112b09:	6a 01                	push   $0x1
f0112b0b:	68 00 30 00 00       	push   $0x3000
f0112b10:	68 00 00 90 00       	push   $0x900000
f0112b15:	68 00 00 80 00       	push   $0x800000
f0112b1a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b1d:	e8 26 2e 00 00       	call   f0115948 <CCP>
f0112b22:	83 c4 30             	add    $0x30,%esp
f0112b25:	83 f8 01             	cmp    $0x1,%eax
f0112b28:	74 28                	je     f0112b52 <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0112b2a:	83 ec 04             	sub    $0x4,%esp
f0112b2d:	68 44 8b 12 f0       	push   $0xf0128b44
f0112b32:	68 9e 03 00 00       	push   $0x39e
f0112b37:	68 02 82 12 f0       	push   $0xf0128202
f0112b3c:	e8 95 d9 fe ff       	call   f01004d6 <_warn>
f0112b41:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112b44:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0112b4b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0112b52:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b56:	74 04                	je     f0112b5c <test_copy_paste_chunk+0xe68>
f0112b58:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112b5c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0112b63:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112b67:	0f 84 9e 00 00 00    	je     f0112c0b <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0112b6d:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0112b74:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0112b7b:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0112b82:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0112b89:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0112b90:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0112b97:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112b9a:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0112b9d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112ba0:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0112ba3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112ba6:	8a 00                	mov    (%eax),%al
f0112ba8:	3c 61                	cmp    $0x61,%al
f0112baa:	75 2d                	jne    f0112bd9 <test_copy_paste_chunk+0xee5>
f0112bac:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112baf:	8a 00                	mov    (%eax),%al
f0112bb1:	3c 61                	cmp    $0x61,%al
f0112bb3:	75 24                	jne    f0112bd9 <test_copy_paste_chunk+0xee5>
f0112bb5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112bb8:	8a 00                	mov    (%eax),%al
f0112bba:	3c 79                	cmp    $0x79,%al
f0112bbc:	75 1b                	jne    f0112bd9 <test_copy_paste_chunk+0xee5>
f0112bbe:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112bc1:	8a 00                	mov    (%eax),%al
f0112bc3:	3c 62                	cmp    $0x62,%al
f0112bc5:	75 12                	jne    f0112bd9 <test_copy_paste_chunk+0xee5>
f0112bc7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112bca:	8a 00                	mov    (%eax),%al
f0112bcc:	3c 63                	cmp    $0x63,%al
f0112bce:	75 09                	jne    f0112bd9 <test_copy_paste_chunk+0xee5>
f0112bd0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112bd3:	8a 00                	mov    (%eax),%al
f0112bd5:	3c 7a                	cmp    $0x7a,%al
f0112bd7:	74 21                	je     f0112bfa <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112bd9:	83 ec 04             	sub    $0x4,%esp
f0112bdc:	68 f8 89 12 f0       	push   $0xf01289f8
f0112be1:	68 b0 03 00 00       	push   $0x3b0
f0112be6:	68 02 82 12 f0       	push   $0xf0128202
f0112beb:	e8 e6 d8 fe ff       	call   f01004d6 <_warn>
f0112bf0:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112bf3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0112bfa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112bfe:	74 04                	je     f0112c04 <test_copy_paste_chunk+0xf10>
f0112c00:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0112c04:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112c0b:	e8 16 ae ff ff       	call   f010da26 <sys_calculate_free_frames>
f0112c10:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0112c13:	6a 00                	push   $0x0
f0112c15:	6a 02                	push   $0x2
f0112c17:	68 00 10 90 00       	push   $0x901000
f0112c1c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c1f:	e8 b1 2b 00 00       	call   f01157d5 <SB>
f0112c24:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0112c27:	6a 00                	push   $0x0
f0112c29:	6a 02                	push   $0x2
f0112c2b:	68 00 20 90 00       	push   $0x902000
f0112c30:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c33:	e8 9d 2b 00 00       	call   f01157d5 <SB>
f0112c38:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0112c3b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0112c3e:	c1 e0 03             	shl    $0x3,%eax
f0112c41:	50                   	push   %eax
f0112c42:	68 00 f0 bf 00       	push   $0xbff000
f0112c47:	68 00 10 90 00       	push   $0x901000
f0112c4c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c4f:	e8 a6 72 ff ff       	call   f0109efa <copy_paste_chunk>
f0112c54:	83 c4 10             	add    $0x10,%esp
f0112c57:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112c5d:	e8 c4 ad ff ff       	call   f010da26 <sys_calculate_free_frames>
f0112c62:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0112c65:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0112c6c:	75 0b                	jne    f0112c79 <test_copy_paste_chunk+0xf85>
f0112c6e:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112c71:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112c74:	83 f8 03             	cmp    $0x3,%eax
f0112c77:	74 2e                	je     f0112ca7 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112c79:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112c7c:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112c7f:	83 ec 0c             	sub    $0xc,%esp
f0112c82:	50                   	push   %eax
f0112c83:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0112c89:	68 a4 8a 12 f0       	push   $0xf0128aa4
f0112c8e:	68 c0 03 00 00       	push   $0x3c0
f0112c93:	68 02 82 12 f0       	push   $0xf0128202
f0112c98:	e8 39 d8 fe ff       	call   f01004d6 <_warn>
f0112c9d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112ca0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112ca7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112cab:	74 04                	je     f0112cb1 <test_copy_paste_chunk+0xfbd>
f0112cad:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112cb1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0112cb8:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0112cbf:	83 ec 08             	sub    $0x8,%esp
f0112cc2:	6a 01                	push   $0x1
f0112cc4:	6a 07                	push   $0x7
f0112cc6:	6a 03                	push   $0x3
f0112cc8:	6a 07                	push   $0x7
f0112cca:	6a 03                	push   $0x3
f0112ccc:	6a 01                	push   $0x1
f0112cce:	68 00 20 00 00       	push   $0x2000
f0112cd3:	68 00 f0 bf 00       	push   $0xbff000
f0112cd8:	68 00 10 90 00       	push   $0x901000
f0112cdd:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ce0:	e8 63 2c 00 00       	call   f0115948 <CCP>
f0112ce5:	83 c4 30             	add    $0x30,%esp
f0112ce8:	83 f8 01             	cmp    $0x1,%eax
f0112ceb:	74 28                	je     f0112d15 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0112ced:	83 ec 04             	sub    $0x4,%esp
f0112cf0:	68 44 8b 12 f0       	push   $0xf0128b44
f0112cf5:	68 c9 03 00 00       	push   $0x3c9
f0112cfa:	68 02 82 12 f0       	push   $0xf0128202
f0112cff:	e8 d2 d7 fe ff       	call   f01004d6 <_warn>
f0112d04:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112d07:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0112d0e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0112d15:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d19:	74 04                	je     f0112d1f <test_copy_paste_chunk+0x102b>
f0112d1b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112d1f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0112d26:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112d2a:	74 72                	je     f0112d9e <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0112d2c:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0112d33:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0112d3a:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0112d41:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0112d48:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112d4b:	8a 00                	mov    (%eax),%al
f0112d4d:	3c 62                	cmp    $0x62,%al
f0112d4f:	75 1b                	jne    f0112d6c <test_copy_paste_chunk+0x1078>
f0112d51:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112d54:	8a 00                	mov    (%eax),%al
f0112d56:	3c 62                	cmp    $0x62,%al
f0112d58:	75 12                	jne    f0112d6c <test_copy_paste_chunk+0x1078>
f0112d5a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112d5d:	8a 00                	mov    (%eax),%al
f0112d5f:	3c 7a                	cmp    $0x7a,%al
f0112d61:	75 09                	jne    f0112d6c <test_copy_paste_chunk+0x1078>
f0112d63:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112d66:	8a 00                	mov    (%eax),%al
f0112d68:	3c 7a                	cmp    $0x7a,%al
f0112d6a:	74 21                	je     f0112d8d <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112d6c:	83 ec 04             	sub    $0x4,%esp
f0112d6f:	68 f8 89 12 f0       	push   $0xf01289f8
f0112d74:	68 d5 03 00 00       	push   $0x3d5
f0112d79:	68 02 82 12 f0       	push   $0xf0128202
f0112d7e:	e8 53 d7 fe ff       	call   f01004d6 <_warn>
f0112d83:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112d86:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112d8d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d91:	74 04                	je     f0112d97 <test_copy_paste_chunk+0x10a3>
f0112d93:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112d97:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0112d9e:	83 ec 0c             	sub    $0xc,%esp
f0112da1:	68 f2 8b 12 f0       	push   $0xf0128bf2
f0112da6:	e8 e0 e1 fe ff       	call   f0100f8b <cprintf>
f0112dab:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0112dae:	83 ec 08             	sub    $0x8,%esp
f0112db1:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112db4:	68 04 8c 12 f0       	push   $0xf0128c04
f0112db9:	e8 cd e1 fe ff       	call   f0100f8b <cprintf>
f0112dbe:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0112dc1:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112dc5:	75 10                	jne    f0112dd7 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0112dc7:	83 ec 0c             	sub    $0xc,%esp
f0112dca:	68 38 8c 12 f0       	push   $0xf0128c38
f0112dcf:	e8 b7 e1 fe ff       	call   f0100f8b <cprintf>
f0112dd4:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112dd7:	a1 a4 4a 5f f0       	mov    0xf05f4aa4,%eax
f0112ddc:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112ddf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112de2:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112de5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112dea:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112ded:	5b                   	pop    %ebx
f0112dee:	5e                   	pop    %esi
f0112def:	5f                   	pop    %edi
f0112df0:	5d                   	pop    %ebp
f0112df1:	c3                   	ret    

f0112df2 <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0112df2:	55                   	push   %ebp
f0112df3:	89 e5                	mov    %esp,%ebp
f0112df5:	57                   	push   %edi
f0112df6:	56                   	push   %esi
f0112df7:	53                   	push   %ebx
f0112df8:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112dfe:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0112e04:	bb 04 89 12 f0       	mov    $0xf0128904,%ebx
f0112e09:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e0e:	89 c7                	mov    %eax,%edi
f0112e10:	89 de                	mov    %ebx,%esi
f0112e12:	89 d1                	mov    %edx,%ecx
f0112e14:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e16:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0112e1c:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112e21:	b0 00                	mov    $0x0,%al
f0112e23:	89 d7                	mov    %edx,%edi
f0112e25:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112e27:	6a 00                	push   $0x0
f0112e29:	6a 0a                	push   $0xa
f0112e2b:	6a 14                	push   $0x14
f0112e2d:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0112e33:	50                   	push   %eax
f0112e34:	e8 54 73 ff ff       	call   f010a18d <env_create>
f0112e39:	83 c4 10             	add    $0x10,%esp
f0112e3c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112e3f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112e42:	8b 40 64             	mov    0x64(%eax),%eax
f0112e45:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0112e48:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112e4b:	8b 40 68             	mov    0x68(%eax),%eax
f0112e4e:	89 45 80             	mov    %eax,-0x80(%ebp)
f0112e51:	8b 45 80             	mov    -0x80(%ebp),%eax
f0112e54:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0112e57:	83 ec 0c             	sub    $0xc,%esp
f0112e5a:	ff 75 cc             	pushl  -0x34(%ebp)
f0112e5d:	e8 b2 2a 00 00       	call   f0115914 <ClearUserSpace>
f0112e62:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0112e65:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0112e6c:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0112e73:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0112e7a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0112e7e:	83 ec 0c             	sub    $0xc,%esp
f0112e81:	68 b0 94 12 f0       	push   $0xf01294b0
f0112e86:	e8 00 e1 fe ff       	call   f0100f8b <cprintf>
f0112e8b:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0112e8e:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0112e95:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0112e9c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112e9f:	8a 00                	mov    (%eax),%al
f0112ea1:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0112ea7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112eaa:	8a 00                	mov    (%eax),%al
f0112eac:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112eb2:	e8 6f ab ff ff       	call   f010da26 <sys_calculate_free_frames>
f0112eb7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0112eba:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112ebd:	89 d0                	mov    %edx,%eax
f0112ebf:	01 c0                	add    %eax,%eax
f0112ec1:	01 d0                	add    %edx,%eax
f0112ec3:	01 c0                	add    %eax,%eax
f0112ec5:	83 ec 0c             	sub    $0xc,%esp
f0112ec8:	6a 02                	push   $0x2
f0112eca:	50                   	push   %eax
f0112ecb:	68 00 40 10 f0       	push   $0xf0104000
f0112ed0:	68 00 00 10 f0       	push   $0xf0100000
f0112ed5:	ff 75 cc             	pushl  -0x34(%ebp)
f0112ed8:	e8 37 70 ff ff       	call   f0109f14 <share_chunk>
f0112edd:	83 c4 20             	add    $0x20,%esp
f0112ee0:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112ee3:	e8 3e ab ff ff       	call   f010da26 <sys_calculate_free_frames>
f0112ee8:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0112eeb:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0112eef:	75 08                	jne    f0112ef9 <test_share_chunk+0x107>
f0112ef1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112ef4:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0112ef7:	74 28                	je     f0112f21 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0112ef9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112efc:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0112eff:	83 ec 0c             	sub    $0xc,%esp
f0112f02:	50                   	push   %eax
f0112f03:	ff 75 b0             	pushl  -0x50(%ebp)
f0112f06:	68 dc 94 12 f0       	push   $0xf01294dc
f0112f0b:	68 11 04 00 00       	push   $0x411
f0112f10:	68 02 82 12 f0       	push   $0xf0128202
f0112f15:	e8 bc d5 fe ff       	call   f01004d6 <_warn>
f0112f1a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112f1d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112f21:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112f25:	74 04                	je     f0112f2b <test_share_chunk+0x139>
f0112f27:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112f2b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0112f2f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0112f32:	c1 e0 03             	shl    $0x3,%eax
f0112f35:	83 ec 08             	sub    $0x8,%esp
f0112f38:	68 fd 00 00 00       	push   $0xfd
f0112f3d:	6a 07                	push   $0x7
f0112f3f:	6a 03                	push   $0x3
f0112f41:	6a 07                	push   $0x7
f0112f43:	6a 03                	push   $0x3
f0112f45:	6a 01                	push   $0x1
f0112f47:	50                   	push   %eax
f0112f48:	68 00 40 10 f0       	push   $0xf0104000
f0112f4d:	68 00 00 10 f0       	push   $0xf0100000
f0112f52:	ff 75 cc             	pushl  -0x34(%ebp)
f0112f55:	e8 ee 29 00 00       	call   f0115948 <CCP>
f0112f5a:	83 c4 30             	add    $0x30,%esp
f0112f5d:	85 c0                	test   %eax,%eax
f0112f5f:	75 1e                	jne    f0112f7f <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0112f61:	83 ec 04             	sub    $0x4,%esp
f0112f64:	68 38 95 12 f0       	push   $0xf0129538
f0112f69:	68 19 04 00 00       	push   $0x419
f0112f6e:	68 02 82 12 f0       	push   $0xf0128202
f0112f73:	e8 5e d5 fe ff       	call   f01004d6 <_warn>
f0112f78:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112f7b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112f7f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112f83:	74 04                	je     f0112f89 <test_share_chunk+0x197>
f0112f85:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0112f89:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112f8c:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0112f8f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112f92:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0112f95:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112f98:	8a 00                	mov    (%eax),%al
f0112f9a:	3c 41                	cmp    $0x41,%al
f0112f9c:	75 09                	jne    f0112fa7 <test_share_chunk+0x1b5>
f0112f9e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112fa1:	8a 00                	mov    (%eax),%al
f0112fa3:	3c 42                	cmp    $0x42,%al
f0112fa5:	74 1e                	je     f0112fc5 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0112fa7:	83 ec 04             	sub    $0x4,%esp
f0112faa:	68 80 95 12 f0       	push   $0xf0129580
f0112faf:	68 23 04 00 00       	push   $0x423
f0112fb4:	68 02 82 12 f0       	push   $0xf0128202
f0112fb9:	e8 18 d5 fe ff       	call   f01004d6 <_warn>
f0112fbe:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112fc1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0112fc5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112fc9:	74 04                	je     f0112fcf <test_share_chunk+0x1dd>
f0112fcb:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112fcf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0112fd3:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0112fd9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112fdc:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0112fde:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0112fe4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112fe7:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0112fe9:	83 ec 0c             	sub    $0xc,%esp
f0112fec:	68 b5 95 12 f0       	push   $0xf01295b5
f0112ff1:	e8 95 df fe ff       	call   f0100f8b <cprintf>
f0112ff6:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0112ff9:	83 ec 0c             	sub    $0xc,%esp
f0112ffc:	68 c4 95 12 f0       	push   $0xf01295c4
f0113001:	e8 85 df fe ff       	call   f0100f8b <cprintf>
f0113006:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113009:	e8 18 aa ff ff       	call   f010da26 <sys_calculate_free_frames>
f011300e:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0113011:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113014:	c1 e0 05             	shl    $0x5,%eax
f0113017:	83 ec 0c             	sub    $0xc,%esp
f011301a:	68 02 0e 00 00       	push   $0xe02
f011301f:	50                   	push   %eax
f0113020:	68 00 00 00 40       	push   $0x40000000
f0113025:	68 00 00 00 f0       	push   $0xf0000000
f011302a:	ff 75 cc             	pushl  -0x34(%ebp)
f011302d:	e8 e2 6e ff ff       	call   f0109f14 <share_chunk>
f0113032:	83 c4 20             	add    $0x20,%esp
f0113035:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113038:	e8 e9 a9 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011303d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0113040:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0113044:	75 1f                	jne    f0113065 <test_share_chunk+0x273>
f0113046:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113049:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011304c:	89 c1                	mov    %eax,%ecx
f011304e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113051:	c1 e0 05             	shl    $0x5,%eax
f0113054:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113057:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011305e:	99                   	cltd   
f011305f:	f7 fb                	idiv   %ebx
f0113061:	39 c1                	cmp    %eax,%ecx
f0113063:	74 28                	je     f011308d <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113065:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113068:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011306b:	83 ec 0c             	sub    $0xc,%esp
f011306e:	50                   	push   %eax
f011306f:	ff 75 a8             	pushl  -0x58(%ebp)
f0113072:	68 00 96 12 f0       	push   $0xf0129600
f0113077:	68 3b 04 00 00       	push   $0x43b
f011307c:	68 02 82 12 f0       	push   $0xf0128202
f0113081:	e8 50 d4 fe ff       	call   f01004d6 <_warn>
f0113086:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113089:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011308d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113091:	74 04                	je     f0113097 <test_share_chunk+0x2a5>
f0113093:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113097:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011309b:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01130a2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01130a5:	c1 e0 05             	shl    $0x5,%eax
f01130a8:	83 ec 08             	sub    $0x8,%esp
f01130ab:	6a 02                	push   $0x2
f01130ad:	6a 07                	push   $0x7
f01130af:	6a 03                	push   $0x3
f01130b1:	68 07 0e 00 00       	push   $0xe07
f01130b6:	68 03 0e 00 00       	push   $0xe03
f01130bb:	6a ff                	push   $0xffffffff
f01130bd:	50                   	push   %eax
f01130be:	68 00 00 00 40       	push   $0x40000000
f01130c3:	68 00 00 00 f0       	push   $0xf0000000
f01130c8:	ff 75 cc             	pushl  -0x34(%ebp)
f01130cb:	e8 78 28 00 00       	call   f0115948 <CCP>
f01130d0:	83 c4 30             	add    $0x30,%esp
f01130d3:	85 c0                	test   %eax,%eax
f01130d5:	75 25                	jne    f01130fc <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01130d7:	83 ec 04             	sub    $0x4,%esp
f01130da:	68 38 95 12 f0       	push   $0xf0129538
f01130df:	68 44 04 00 00       	push   $0x444
f01130e4:	68 02 82 12 f0       	push   $0xf0128202
f01130e9:	e8 e8 d3 fe ff       	call   f01004d6 <_warn>
f01130ee:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01130f1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01130f5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01130fc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01130ff:	89 d0                	mov    %edx,%eax
f0113101:	01 c0                	add    %eax,%eax
f0113103:	01 d0                	add    %edx,%eax
f0113105:	c1 e0 02             	shl    $0x2,%eax
f0113108:	83 ec 08             	sub    $0x8,%esp
f011310b:	6a 02                	push   $0x2
f011310d:	6a 07                	push   $0x7
f011310f:	6a 03                	push   $0x3
f0113111:	68 07 0e 00 00       	push   $0xe07
f0113116:	68 03 0e 00 00       	push   $0xe03
f011311b:	6a 02                	push   $0x2
f011311d:	50                   	push   %eax
f011311e:	68 00 00 00 40       	push   $0x40000000
f0113123:	68 00 00 00 f0       	push   $0xf0000000
f0113128:	ff 75 cc             	pushl  -0x34(%ebp)
f011312b:	e8 18 28 00 00       	call   f0115948 <CCP>
f0113130:	83 c4 30             	add    $0x30,%esp
f0113133:	85 c0                	test   %eax,%eax
f0113135:	75 1e                	jne    f0113155 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113137:	83 ec 04             	sub    $0x4,%esp
f011313a:	68 38 95 12 f0       	push   $0xf0129538
f011313f:	68 4b 04 00 00       	push   $0x44b
f0113144:	68 02 82 12 f0       	push   $0xf0128202
f0113149:	e8 88 d3 fe ff       	call   f01004d6 <_warn>
f011314e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113151:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113155:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113159:	74 04                	je     f011315f <test_share_chunk+0x36d>
f011315b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011315f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0113163:	b8 70 74 61 f0       	mov    $0xf0617470,%eax
f0113168:	05 00 00 00 10       	add    $0x10000000,%eax
f011316d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113170:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113173:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0113178:	83 ec 08             	sub    $0x8,%esp
f011317b:	6a 02                	push   $0x2
f011317d:	6a 07                	push   $0x7
f011317f:	6a 03                	push   $0x3
f0113181:	68 07 0e 00 00       	push   $0xe07
f0113186:	68 03 0e 00 00       	push   $0xe03
f011318b:	6a 02                	push   $0x2
f011318d:	50                   	push   %eax
f011318e:	68 00 00 0a 40       	push   $0x400a0000
f0113193:	68 00 00 0a f0       	push   $0xf00a0000
f0113198:	ff 75 cc             	pushl  -0x34(%ebp)
f011319b:	e8 a8 27 00 00       	call   f0115948 <CCP>
f01131a0:	83 c4 30             	add    $0x30,%esp
f01131a3:	85 c0                	test   %eax,%eax
f01131a5:	75 1e                	jne    f01131c5 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01131a7:	83 ec 04             	sub    $0x4,%esp
f01131aa:	68 38 95 12 f0       	push   $0xf0129538
f01131af:	68 55 04 00 00       	push   $0x455
f01131b4:	68 02 82 12 f0       	push   $0xf0128202
f01131b9:	e8 18 d3 fe ff       	call   f01004d6 <_warn>
f01131be:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01131c1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01131c5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01131c9:	74 04                	je     f01131cf <test_share_chunk+0x3dd>
f01131cb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01131cf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01131d3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01131d7:	0f 84 a4 00 00 00    	je     f0113281 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f01131dd:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f01131e4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01131e7:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f01131ea:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f01131f1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01131f4:	8a 00                	mov    (%eax),%al
f01131f6:	3c 41                	cmp    $0x41,%al
f01131f8:	75 09                	jne    f0113203 <test_share_chunk+0x411>
f01131fa:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01131fd:	8a 00                	mov    (%eax),%al
f01131ff:	3c 41                	cmp    $0x41,%al
f0113201:	74 1e                	je     f0113221 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113203:	83 ec 04             	sub    $0x4,%esp
f0113206:	68 80 95 12 f0       	push   $0xf0129580
f011320b:	68 62 04 00 00       	push   $0x462
f0113210:	68 02 82 12 f0       	push   $0xf0128202
f0113215:	e8 bc d2 fe ff       	call   f01004d6 <_warn>
f011321a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011321d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113221:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113225:	74 04                	je     f011322b <test_share_chunk+0x439>
f0113227:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011322b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f011322f:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0113236:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113239:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f011323c:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0113243:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113246:	8a 00                	mov    (%eax),%al
f0113248:	3c 43                	cmp    $0x43,%al
f011324a:	75 09                	jne    f0113255 <test_share_chunk+0x463>
f011324c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011324f:	8a 00                	mov    (%eax),%al
f0113251:	3c 43                	cmp    $0x43,%al
f0113253:	74 1e                	je     f0113273 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113255:	83 ec 04             	sub    $0x4,%esp
f0113258:	68 80 95 12 f0       	push   $0xf0129580
f011325d:	68 6d 04 00 00       	push   $0x46d
f0113262:	68 02 82 12 f0       	push   $0xf0128202
f0113267:	e8 6a d2 fe ff       	call   f01004d6 <_warn>
f011326c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011326f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113273:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113277:	74 04                	je     f011327d <test_share_chunk+0x48b>
f0113279:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011327d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0113281:	83 ec 0c             	sub    $0xc,%esp
f0113284:	68 8f 8b 12 f0       	push   $0xf0128b8f
f0113289:	e8 fd dc fe ff       	call   f0100f8b <cprintf>
f011328e:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0113291:	83 ec 0c             	sub    $0xc,%esp
f0113294:	68 50 96 12 f0       	push   $0xf0129650
f0113299:	e8 ed dc fe ff       	call   f0100f8b <cprintf>
f011329e:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01132a1:	e8 80 a7 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01132a6:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f01132a9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01132ac:	89 d0                	mov    %edx,%eax
f01132ae:	c1 e0 03             	shl    $0x3,%eax
f01132b1:	01 d0                	add    %edx,%eax
f01132b3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01132ba:	01 d0                	add    %edx,%eax
f01132bc:	c1 e0 03             	shl    $0x3,%eax
f01132bf:	83 ec 0c             	sub    $0xc,%esp
f01132c2:	6a 06                	push   $0x6
f01132c4:	50                   	push   %eax
f01132c5:	6a 00                	push   $0x0
f01132c7:	68 00 00 00 40       	push   $0x40000000
f01132cc:	ff 75 cc             	pushl  -0x34(%ebp)
f01132cf:	e8 40 6c ff ff       	call   f0109f14 <share_chunk>
f01132d4:	83 c4 20             	add    $0x20,%esp
f01132d7:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01132da:	e8 47 a7 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01132df:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f01132e2:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f01132e6:	75 0b                	jne    f01132f3 <test_share_chunk+0x501>
f01132e8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01132eb:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01132ee:	83 f8 01             	cmp    $0x1,%eax
f01132f1:	74 28                	je     f011331b <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01132f3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01132f6:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01132f9:	83 ec 0c             	sub    $0xc,%esp
f01132fc:	50                   	push   %eax
f01132fd:	ff 75 a0             	pushl  -0x60(%ebp)
f0113300:	68 00 96 12 f0       	push   $0xf0129600
f0113305:	68 83 04 00 00       	push   $0x483
f011330a:	68 02 82 12 f0       	push   $0xf0128202
f011330f:	e8 c2 d1 fe ff       	call   f01004d6 <_warn>
f0113314:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113317:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011331b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011331f:	74 04                	je     f0113325 <test_share_chunk+0x533>
f0113321:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113325:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113329:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113330:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113333:	05 00 80 02 00       	add    $0x28000,%eax
f0113338:	c1 e0 02             	shl    $0x2,%eax
f011333b:	83 ec 08             	sub    $0x8,%esp
f011333e:	6a 02                	push   $0x2
f0113340:	6a 07                	push   $0x7
f0113342:	6a 03                	push   $0x3
f0113344:	6a 07                	push   $0x7
f0113346:	6a 07                	push   $0x7
f0113348:	6a ff                	push   $0xffffffff
f011334a:	50                   	push   %eax
f011334b:	6a 00                	push   $0x0
f011334d:	68 00 00 00 40       	push   $0x40000000
f0113352:	ff 75 cc             	pushl  -0x34(%ebp)
f0113355:	e8 ee 25 00 00       	call   f0115948 <CCP>
f011335a:	83 c4 30             	add    $0x30,%esp
f011335d:	85 c0                	test   %eax,%eax
f011335f:	75 25                	jne    f0113386 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113361:	83 ec 04             	sub    $0x4,%esp
f0113364:	68 38 95 12 f0       	push   $0xf0129538
f0113369:	68 8c 04 00 00       	push   $0x48c
f011336e:	68 02 82 12 f0       	push   $0xf0128202
f0113373:	e8 5e d1 fe ff       	call   f01004d6 <_warn>
f0113378:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011337b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011337f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113386:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113389:	89 d0                	mov    %edx,%eax
f011338b:	01 c0                	add    %eax,%eax
f011338d:	01 d0                	add    %edx,%eax
f011338f:	c1 e0 02             	shl    $0x2,%eax
f0113392:	83 ec 08             	sub    $0x8,%esp
f0113395:	6a 02                	push   $0x2
f0113397:	6a 07                	push   $0x7
f0113399:	6a 03                	push   $0x3
f011339b:	6a 07                	push   $0x7
f011339d:	6a 07                	push   $0x7
f011339f:	6a 03                	push   $0x3
f01133a1:	50                   	push   %eax
f01133a2:	6a 00                	push   $0x0
f01133a4:	68 00 00 00 40       	push   $0x40000000
f01133a9:	ff 75 cc             	pushl  -0x34(%ebp)
f01133ac:	e8 97 25 00 00       	call   f0115948 <CCP>
f01133b1:	83 c4 30             	add    $0x30,%esp
f01133b4:	85 c0                	test   %eax,%eax
f01133b6:	75 1e                	jne    f01133d6 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01133b8:	83 ec 04             	sub    $0x4,%esp
f01133bb:	68 38 95 12 f0       	push   $0xf0129538
f01133c0:	68 93 04 00 00       	push   $0x493
f01133c5:	68 02 82 12 f0       	push   $0xf0128202
f01133ca:	e8 07 d1 fe ff       	call   f01004d6 <_warn>
f01133cf:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01133d2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01133d6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01133da:	74 04                	je     f01133e0 <test_share_chunk+0x5ee>
f01133dc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01133e0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01133e4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01133e7:	89 d0                	mov    %edx,%eax
f01133e9:	01 c0                	add    %eax,%eax
f01133eb:	01 d0                	add    %edx,%eax
f01133ed:	c1 e0 02             	shl    $0x2,%eax
f01133f0:	f7 d8                	neg    %eax
f01133f2:	05 00 00 0a 00       	add    $0xa0000,%eax
f01133f7:	83 ec 08             	sub    $0x8,%esp
f01133fa:	6a 02                	push   $0x2
f01133fc:	6a 07                	push   $0x7
f01133fe:	6a 03                	push   $0x3
f0113400:	6a 07                	push   $0x7
f0113402:	6a 07                	push   $0x7
f0113404:	6a 02                	push   $0x2
f0113406:	50                   	push   %eax
f0113407:	68 00 30 00 00       	push   $0x3000
f011340c:	68 00 30 00 40       	push   $0x40003000
f0113411:	ff 75 cc             	pushl  -0x34(%ebp)
f0113414:	e8 2f 25 00 00       	call   f0115948 <CCP>
f0113419:	83 c4 30             	add    $0x30,%esp
f011341c:	85 c0                	test   %eax,%eax
f011341e:	75 1e                	jne    f011343e <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113420:	83 ec 04             	sub    $0x4,%esp
f0113423:	68 38 95 12 f0       	push   $0xf0129538
f0113428:	68 9b 04 00 00       	push   $0x49b
f011342d:	68 02 82 12 f0       	push   $0xf0128202
f0113432:	e8 9f d0 fe ff       	call   f01004d6 <_warn>
f0113437:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011343a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011343e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113442:	74 04                	je     f0113448 <test_share_chunk+0x656>
f0113444:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113448:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011344c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011344f:	c1 e0 02             	shl    $0x2,%eax
f0113452:	83 ec 08             	sub    $0x8,%esp
f0113455:	6a 02                	push   $0x2
f0113457:	6a 07                	push   $0x7
f0113459:	6a 03                	push   $0x3
f011345b:	6a 07                	push   $0x7
f011345d:	6a 07                	push   $0x7
f011345f:	6a 03                	push   $0x3
f0113461:	50                   	push   %eax
f0113462:	68 00 00 0a 00       	push   $0xa0000
f0113467:	68 00 00 0a 40       	push   $0x400a0000
f011346c:	ff 75 cc             	pushl  -0x34(%ebp)
f011346f:	e8 d4 24 00 00       	call   f0115948 <CCP>
f0113474:	83 c4 30             	add    $0x30,%esp
f0113477:	85 c0                	test   %eax,%eax
f0113479:	75 1e                	jne    f0113499 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011347b:	83 ec 04             	sub    $0x4,%esp
f011347e:	68 38 95 12 f0       	push   $0xf0129538
f0113483:	68 a3 04 00 00       	push   $0x4a3
f0113488:	68 02 82 12 f0       	push   $0xf0128202
f011348d:	e8 44 d0 fe ff       	call   f01004d6 <_warn>
f0113492:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113495:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113499:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011349d:	74 04                	je     f01134a3 <test_share_chunk+0x6b1>
f011349f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01134a3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01134a7:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01134ab:	0f 84 92 00 00 00    	je     f0113543 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f01134b1:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f01134b8:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f01134bf:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f01134c6:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f01134cd:	8b 45 98             	mov    -0x68(%ebp),%eax
f01134d0:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f01134d3:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f01134da:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01134e1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01134e4:	8a 00                	mov    (%eax),%al
f01134e6:	3c 41                	cmp    $0x41,%al
f01134e8:	75 2d                	jne    f0113517 <test_share_chunk+0x725>
f01134ea:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01134ed:	8a 00                	mov    (%eax),%al
f01134ef:	3c 41                	cmp    $0x41,%al
f01134f1:	75 24                	jne    f0113517 <test_share_chunk+0x725>
f01134f3:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01134f6:	8a 00                	mov    (%eax),%al
f01134f8:	3c 41                	cmp    $0x41,%al
f01134fa:	75 1b                	jne    f0113517 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01134fc:	8b 45 98             	mov    -0x68(%ebp),%eax
f01134ff:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0113501:	3c 44                	cmp    $0x44,%al
f0113503:	75 12                	jne    f0113517 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0113505:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113508:	8a 00                	mov    (%eax),%al
f011350a:	3c 44                	cmp    $0x44,%al
f011350c:	75 09                	jne    f0113517 <test_share_chunk+0x725>
f011350e:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113511:	8a 00                	mov    (%eax),%al
f0113513:	3c 44                	cmp    $0x44,%al
f0113515:	74 1e                	je     f0113535 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113517:	83 ec 04             	sub    $0x4,%esp
f011351a:	68 80 95 12 f0       	push   $0xf0129580
f011351f:	68 b5 04 00 00       	push   $0x4b5
f0113524:	68 02 82 12 f0       	push   $0xf0128202
f0113529:	e8 a8 cf fe ff       	call   f01004d6 <_warn>
f011352e:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113531:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113535:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113539:	74 04                	je     f011353f <test_share_chunk+0x74d>
f011353b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011353f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113543:	83 ec 0c             	sub    $0xc,%esp
f0113546:	68 f2 8b 12 f0       	push   $0xf0128bf2
f011354b:	e8 3b da fe ff       	call   f0100f8b <cprintf>
f0113550:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0113553:	83 ec 0c             	sub    $0xc,%esp
f0113556:	68 8c 96 12 f0       	push   $0xf012968c
f011355b:	e8 2b da fe ff       	call   f0100f8b <cprintf>
f0113560:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113563:	e8 be a4 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0113568:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f011356b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011356e:	89 d0                	mov    %edx,%eax
f0113570:	01 c0                	add    %eax,%eax
f0113572:	01 d0                	add    %edx,%eax
f0113574:	01 c0                	add    %eax,%eax
f0113576:	01 d0                	add    %edx,%eax
f0113578:	83 ec 0c             	sub    $0xc,%esp
f011357b:	6a 04                	push   $0x4
f011357d:	50                   	push   %eax
f011357e:	68 00 fc 3f 00       	push   $0x3ffc00
f0113583:	68 00 fc 09 00       	push   $0x9fc00
f0113588:	ff 75 cc             	pushl  -0x34(%ebp)
f011358b:	e8 84 69 ff ff       	call   f0109f14 <share_chunk>
f0113590:	83 c4 20             	add    $0x20,%esp
f0113593:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113596:	e8 8b a4 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011359b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011359e:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f01135a2:	75 0b                	jne    f01135af <test_share_chunk+0x7bd>
f01135a4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01135a7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01135aa:	83 f8 01             	cmp    $0x1,%eax
f01135ad:	74 28                	je     f01135d7 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01135af:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01135b2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01135b5:	83 ec 0c             	sub    $0xc,%esp
f01135b8:	50                   	push   %eax
f01135b9:	ff 75 8c             	pushl  -0x74(%ebp)
f01135bc:	68 00 96 12 f0       	push   $0xf0129600
f01135c1:	68 cb 04 00 00       	push   $0x4cb
f01135c6:	68 02 82 12 f0       	push   $0xf0128202
f01135cb:	e8 06 cf fe ff       	call   f01004d6 <_warn>
f01135d0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01135d3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01135d7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01135db:	74 04                	je     f01135e1 <test_share_chunk+0x7ef>
f01135dd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01135e1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01135e5:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01135ec:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01135ef:	89 d0                	mov    %edx,%eax
f01135f1:	01 c0                	add    %eax,%eax
f01135f3:	01 d0                	add    %edx,%eax
f01135f5:	c1 e0 02             	shl    $0x2,%eax
f01135f8:	83 ec 08             	sub    $0x8,%esp
f01135fb:	6a 02                	push   $0x2
f01135fd:	6a 07                	push   $0x7
f01135ff:	6a 07                	push   $0x7
f0113601:	6a 07                	push   $0x7
f0113603:	6a 05                	push   $0x5
f0113605:	6a ff                	push   $0xffffffff
f0113607:	50                   	push   %eax
f0113608:	68 00 f0 3f 00       	push   $0x3ff000
f011360d:	68 00 f0 09 00       	push   $0x9f000
f0113612:	ff 75 cc             	pushl  -0x34(%ebp)
f0113615:	e8 2e 23 00 00       	call   f0115948 <CCP>
f011361a:	83 c4 30             	add    $0x30,%esp
f011361d:	85 c0                	test   %eax,%eax
f011361f:	75 25                	jne    f0113646 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113621:	83 ec 04             	sub    $0x4,%esp
f0113624:	68 38 95 12 f0       	push   $0xf0129538
f0113629:	68 d4 04 00 00       	push   $0x4d4
f011362e:	68 02 82 12 f0       	push   $0xf0128202
f0113633:	e8 9e ce fe ff       	call   f01004d6 <_warn>
f0113638:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011363b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011363f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0113646:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011364a:	74 04                	je     f0113650 <test_share_chunk+0x85e>
f011364c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113650:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0113654:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113657:	c1 e0 02             	shl    $0x2,%eax
f011365a:	83 ec 08             	sub    $0x8,%esp
f011365d:	6a 02                	push   $0x2
f011365f:	6a 07                	push   $0x7
f0113661:	6a 07                	push   $0x7
f0113663:	6a 07                	push   $0x7
f0113665:	6a 05                	push   $0x5
f0113667:	6a 03                	push   $0x3
f0113669:	50                   	push   %eax
f011366a:	68 00 f0 3f 00       	push   $0x3ff000
f011366f:	68 00 f0 09 00       	push   $0x9f000
f0113674:	ff 75 cc             	pushl  -0x34(%ebp)
f0113677:	e8 cc 22 00 00       	call   f0115948 <CCP>
f011367c:	83 c4 30             	add    $0x30,%esp
f011367f:	85 c0                	test   %eax,%eax
f0113681:	75 1e                	jne    f01136a1 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113683:	83 ec 04             	sub    $0x4,%esp
f0113686:	68 38 95 12 f0       	push   $0xf0129538
f011368b:	68 dd 04 00 00       	push   $0x4dd
f0113690:	68 02 82 12 f0       	push   $0xf0128202
f0113695:	e8 3c ce fe ff       	call   f01004d6 <_warn>
f011369a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011369d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01136a1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01136a5:	74 04                	je     f01136ab <test_share_chunk+0x8b9>
f01136a7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01136ab:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01136af:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01136b2:	c1 e0 03             	shl    $0x3,%eax
f01136b5:	83 ec 08             	sub    $0x8,%esp
f01136b8:	6a 02                	push   $0x2
f01136ba:	6a 07                	push   $0x7
f01136bc:	6a 07                	push   $0x7
f01136be:	6a 07                	push   $0x7
f01136c0:	6a 05                	push   $0x5
f01136c2:	6a 04                	push   $0x4
f01136c4:	50                   	push   %eax
f01136c5:	68 00 00 40 00       	push   $0x400000
f01136ca:	68 00 00 0a 00       	push   $0xa0000
f01136cf:	ff 75 cc             	pushl  -0x34(%ebp)
f01136d2:	e8 71 22 00 00       	call   f0115948 <CCP>
f01136d7:	83 c4 30             	add    $0x30,%esp
f01136da:	85 c0                	test   %eax,%eax
f01136dc:	75 1e                	jne    f01136fc <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01136de:	83 ec 04             	sub    $0x4,%esp
f01136e1:	68 38 95 12 f0       	push   $0xf0129538
f01136e6:	68 e5 04 00 00       	push   $0x4e5
f01136eb:	68 02 82 12 f0       	push   $0xf0128202
f01136f0:	e8 e1 cd fe ff       	call   f01004d6 <_warn>
f01136f5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01136f8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01136fc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113700:	74 04                	je     f0113706 <test_share_chunk+0x914>
f0113702:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113706:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f011370a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011370e:	0f 84 b2 00 00 00    	je     f01137c6 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0113714:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f011371b:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0113722:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0113729:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0113730:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0113737:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f011373e:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0113745:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f011374c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011374f:	8a 00                	mov    (%eax),%al
f0113751:	3c 44                	cmp    $0x44,%al
f0113753:	75 45                	jne    f011379a <test_share_chunk+0x9a8>
f0113755:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113758:	8a 00                	mov    (%eax),%al
f011375a:	3c 44                	cmp    $0x44,%al
f011375c:	75 3c                	jne    f011379a <test_share_chunk+0x9a8>
f011375e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113761:	8a 00                	mov    (%eax),%al
f0113763:	3c 44                	cmp    $0x44,%al
f0113765:	75 33                	jne    f011379a <test_share_chunk+0x9a8>
f0113767:	8b 45 98             	mov    -0x68(%ebp),%eax
f011376a:	8a 00                	mov    (%eax),%al
f011376c:	3c 44                	cmp    $0x44,%al
f011376e:	75 2a                	jne    f011379a <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0113770:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113773:	8a 10                	mov    (%eax),%dl
f0113775:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113778:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f011377a:	38 c2                	cmp    %al,%dl
f011377c:	75 1c                	jne    f011379a <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f011377e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113781:	8a 10                	mov    (%eax),%dl
f0113783:	8b 45 88             	mov    -0x78(%ebp),%eax
f0113786:	8a 00                	mov    (%eax),%al
f0113788:	38 c2                	cmp    %al,%dl
f011378a:	75 0e                	jne    f011379a <test_share_chunk+0x9a8>
f011378c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011378f:	8a 10                	mov    (%eax),%dl
f0113791:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0113794:	8a 00                	mov    (%eax),%al
f0113796:	38 c2                	cmp    %al,%dl
f0113798:	74 1e                	je     f01137b8 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011379a:	83 ec 04             	sub    $0x4,%esp
f011379d:	68 80 95 12 f0       	push   $0xf0129580
f01137a2:	68 fa 04 00 00       	push   $0x4fa
f01137a7:	68 02 82 12 f0       	push   $0xf0128202
f01137ac:	e8 25 cd fe ff       	call   f01004d6 <_warn>
f01137b1:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01137b4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01137b8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01137bc:	74 04                	je     f01137c2 <test_share_chunk+0x9d0>
f01137be:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01137c2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f01137c6:	83 ec 0c             	sub    $0xc,%esp
f01137c9:	68 c4 96 12 f0       	push   $0xf01296c4
f01137ce:	e8 b8 d7 fe ff       	call   f0100f8b <cprintf>
f01137d3:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f01137d6:	83 ec 08             	sub    $0x8,%esp
f01137d9:	ff 75 e4             	pushl  -0x1c(%ebp)
f01137dc:	68 d4 96 12 f0       	push   $0xf01296d4
f01137e1:	e8 a5 d7 fe ff       	call   f0100f8b <cprintf>
f01137e6:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01137e9:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01137ed:	75 10                	jne    f01137ff <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f01137ef:	83 ec 0c             	sub    $0xc,%esp
f01137f2:	68 04 97 12 f0       	push   $0xf0129704
f01137f7:	e8 8f d7 fe ff       	call   f0100f8b <cprintf>
f01137fc:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01137ff:	a1 a4 4a 5f f0       	mov    0xf05f4aa4,%eax
f0113804:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0113807:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011380a:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011380d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113812:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113815:	5b                   	pop    %ebx
f0113816:	5e                   	pop    %esi
f0113817:	5f                   	pop    %edi
f0113818:	5d                   	pop    %ebp
f0113819:	c3                   	ret    

f011381a <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f011381a:	55                   	push   %ebp
f011381b:	89 e5                	mov    %esp,%ebp
f011381d:	57                   	push   %edi
f011381e:	56                   	push   %esi
f011381f:	53                   	push   %ebx
f0113820:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113826:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011382c:	bb 04 89 12 f0       	mov    $0xf0128904,%ebx
f0113831:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113836:	89 c7                	mov    %eax,%edi
f0113838:	89 de                	mov    %ebx,%esi
f011383a:	89 d1                	mov    %edx,%ecx
f011383c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011383e:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0113844:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113849:	b0 00                	mov    $0x0,%al
f011384b:	89 d7                	mov    %edx,%edi
f011384d:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011384f:	6a 00                	push   $0x0
f0113851:	6a 0a                	push   $0xa
f0113853:	6a 14                	push   $0x14
f0113855:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011385b:	50                   	push   %eax
f011385c:	e8 2c 69 ff ff       	call   f010a18d <env_create>
f0113861:	83 c4 10             	add    $0x10,%esp
f0113864:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113867:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011386a:	8b 40 64             	mov    0x64(%eax),%eax
f011386d:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0113870:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113873:	8b 40 68             	mov    0x68(%eax),%eax
f0113876:	89 45 90             	mov    %eax,-0x70(%ebp)
f0113879:	8b 45 90             	mov    -0x70(%ebp),%eax
f011387c:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f011387f:	83 ec 0c             	sub    $0xc,%esp
f0113882:	ff 75 cc             	pushl  -0x34(%ebp)
f0113885:	e8 8a 20 00 00       	call   f0115914 <ClearUserSpace>
f011388a:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011388d:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113894:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f011389b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f01138a2:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f01138a6:	83 ec 0c             	sub    $0xc,%esp
f01138a9:	68 40 97 12 f0       	push   $0xf0129740
f01138ae:	e8 d8 d6 fe ff       	call   f0100f8b <cprintf>
f01138b3:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f01138b6:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f01138bd:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f01138c4:	eb 03                	jmp    f01138c9 <test_allocate_chunk+0xaf>
f01138c6:	ff 4d e4             	decl   -0x1c(%ebp)
f01138c9:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01138d0:	76 09                	jbe    f01138db <test_allocate_chunk+0xc1>
f01138d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01138d5:	8a 00                	mov    (%eax),%al
f01138d7:	84 c0                	test   %al,%al
f01138d9:	74 eb                	je     f01138c6 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f01138db:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01138e2:	75 06                	jne    f01138ea <test_allocate_chunk+0xd0>
f01138e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01138e7:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f01138ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01138ed:	8a 00                	mov    (%eax),%al
f01138ef:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f01138f5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01138f8:	8a 00                	mov    (%eax),%al
f01138fa:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f0113900:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113903:	8a 00                	mov    (%eax),%al
f0113905:	0f be c0             	movsbl %al,%eax
f0113908:	83 ec 08             	sub    $0x8,%esp
f011390b:	50                   	push   %eax
f011390c:	68 6a 97 12 f0       	push   $0xf012976a
f0113911:	e8 75 d6 fe ff       	call   f0100f8b <cprintf>
f0113916:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0113919:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011391c:	8a 00                	mov    (%eax),%al
f011391e:	0f be c0             	movsbl %al,%eax
f0113921:	83 ec 08             	sub    $0x8,%esp
f0113924:	50                   	push   %eax
f0113925:	68 76 97 12 f0       	push   $0xf0129776
f011392a:	e8 5c d6 fe ff       	call   f0100f8b <cprintf>
f011392f:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0113932:	83 ec 08             	sub    $0x8,%esp
f0113935:	68 00 f0 bf ef       	push   $0xefbff000
f011393a:	ff 75 cc             	pushl  -0x34(%ebp)
f011393d:	e8 b3 1f 00 00       	call   f01158f5 <GP>
f0113942:	83 c4 10             	add    $0x10,%esp
f0113945:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113948:	e8 d9 a0 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011394d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0113950:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113953:	c1 e0 02             	shl    $0x2,%eax
f0113956:	6a 02                	push   $0x2
f0113958:	50                   	push   %eax
f0113959:	68 00 f0 bf ef       	push   $0xefbff000
f011395e:	ff 75 cc             	pushl  -0x34(%ebp)
f0113961:	e8 c8 65 ff ff       	call   f0109f2e <allocate_chunk>
f0113966:	83 c4 10             	add    $0x10,%esp
f0113969:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011396c:	e8 b5 a0 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0113971:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0113974:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0113978:	75 08                	jne    f0113982 <test_allocate_chunk+0x168>
f011397a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011397d:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113980:	74 2a                	je     f01139ac <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0113982:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113985:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113988:	83 ec 08             	sub    $0x8,%esp
f011398b:	6a 00                	push   $0x0
f011398d:	50                   	push   %eax
f011398e:	ff 75 b0             	pushl  -0x50(%ebp)
f0113991:	68 84 97 12 f0       	push   $0xf0129784
f0113996:	68 3a 05 00 00       	push   $0x53a
f011399b:	68 02 82 12 f0       	push   $0xf0128202
f01139a0:	e8 31 cb fe ff       	call   f01004d6 <_warn>
f01139a5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01139a8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01139ac:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01139b0:	74 04                	je     f01139b6 <test_allocate_chunk+0x19c>
f01139b2:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01139b6:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01139ba:	e8 67 a0 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01139bf:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f01139c2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01139c5:	01 c0                	add    %eax,%eax
f01139c7:	89 c1                	mov    %eax,%ecx
f01139c9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01139cc:	89 d0                	mov    %edx,%eax
f01139ce:	c1 e0 02             	shl    $0x2,%eax
f01139d1:	01 d0                	add    %edx,%eax
f01139d3:	f7 d8                	neg    %eax
f01139d5:	2d 00 00 40 10       	sub    $0x10400000,%eax
f01139da:	6a 02                	push   $0x2
f01139dc:	51                   	push   %ecx
f01139dd:	50                   	push   %eax
f01139de:	ff 75 cc             	pushl  -0x34(%ebp)
f01139e1:	e8 48 65 ff ff       	call   f0109f2e <allocate_chunk>
f01139e6:	83 c4 10             	add    $0x10,%esp
f01139e9:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01139ec:	e8 35 a0 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01139f1:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01139f4:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01139f8:	75 08                	jne    f0113a02 <test_allocate_chunk+0x1e8>
f01139fa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01139fd:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113a00:	74 2a                	je     f0113a2c <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0113a02:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a05:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113a08:	83 ec 08             	sub    $0x8,%esp
f0113a0b:	6a 00                	push   $0x0
f0113a0d:	50                   	push   %eax
f0113a0e:	ff 75 b0             	pushl  -0x50(%ebp)
f0113a11:	68 84 97 12 f0       	push   $0xf0129784
f0113a16:	68 48 05 00 00       	push   $0x548
f0113a1b:	68 02 82 12 f0       	push   $0xf0128202
f0113a20:	e8 b1 ca fe ff       	call   f01004d6 <_warn>
f0113a25:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113a28:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0113a2c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113a30:	74 04                	je     f0113a36 <test_allocate_chunk+0x21c>
f0113a32:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113a36:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0113a3a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113a3d:	c1 e0 02             	shl    $0x2,%eax
f0113a40:	83 ec 08             	sub    $0x8,%esp
f0113a43:	6a 03                	push   $0x3
f0113a45:	6a 00                	push   $0x0
f0113a47:	6a 00                	push   $0x0
f0113a49:	68 ff 0f 00 00       	push   $0xfff
f0113a4e:	ff 75 b8             	pushl  -0x48(%ebp)
f0113a51:	6a 01                	push   $0x1
f0113a53:	50                   	push   %eax
f0113a54:	68 00 f0 bf ef       	push   $0xefbff000
f0113a59:	6a 00                	push   $0x0
f0113a5b:	ff 75 cc             	pushl  -0x34(%ebp)
f0113a5e:	e8 e5 1e 00 00       	call   f0115948 <CCP>
f0113a63:	83 c4 30             	add    $0x30,%esp
f0113a66:	85 c0                	test   %eax,%eax
f0113a68:	75 1e                	jne    f0113a88 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113a6a:	83 ec 04             	sub    $0x4,%esp
f0113a6d:	68 ec 97 12 f0       	push   $0xf01297ec
f0113a72:	68 50 05 00 00       	push   $0x550
f0113a77:	68 02 82 12 f0       	push   $0xf0128202
f0113a7c:	e8 55 ca fe ff       	call   f01004d6 <_warn>
f0113a81:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113a84:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113a88:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113a8c:	74 04                	je     f0113a92 <test_allocate_chunk+0x278>
f0113a8e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113a92:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0113a96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113a99:	8a 10                	mov    (%eax),%dl
f0113a9b:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0113aa1:	38 c2                	cmp    %al,%dl
f0113aa3:	75 0f                	jne    f0113ab4 <test_allocate_chunk+0x29a>
f0113aa5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113aa8:	8a 10                	mov    (%eax),%dl
f0113aaa:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0113ab0:	38 c2                	cmp    %al,%dl
f0113ab2:	74 1e                	je     f0113ad2 <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0113ab4:	83 ec 04             	sub    $0x4,%esp
f0113ab7:	68 38 98 12 f0       	push   $0xf0129838
f0113abc:	68 58 05 00 00       	push   $0x558
f0113ac1:	68 02 82 12 f0       	push   $0xf0128202
f0113ac6:	e8 0b ca fe ff       	call   f01004d6 <_warn>
f0113acb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113ace:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0113ad2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113ad6:	74 04                	je     f0113adc <test_allocate_chunk+0x2c2>
f0113ad8:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113adc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0113ae0:	83 ec 0c             	sub    $0xc,%esp
f0113ae3:	68 b5 95 12 f0       	push   $0xf01295b5
f0113ae8:	e8 9e d4 fe ff       	call   f0100f8b <cprintf>
f0113aed:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0113af0:	83 ec 0c             	sub    $0xc,%esp
f0113af3:	68 70 98 12 f0       	push   $0xf0129870
f0113af8:	e8 8e d4 fe ff       	call   f0100f8b <cprintf>
f0113afd:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113b00:	e8 21 9f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0113b05:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0113b08:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b0b:	c1 e0 05             	shl    $0x5,%eax
f0113b0e:	68 02 0e 00 00       	push   $0xe02
f0113b13:	50                   	push   %eax
f0113b14:	6a 00                	push   $0x0
f0113b16:	ff 75 cc             	pushl  -0x34(%ebp)
f0113b19:	e8 10 64 ff ff       	call   f0109f2e <allocate_chunk>
f0113b1e:	83 c4 10             	add    $0x10,%esp
f0113b21:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113b24:	e8 fd 9e ff ff       	call   f010da26 <sys_calculate_free_frames>
f0113b29:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0113b2c:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0113b30:	75 36                	jne    f0113b68 <test_allocate_chunk+0x34e>
f0113b32:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113b35:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113b38:	89 c1                	mov    %eax,%ecx
f0113b3a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b3d:	c1 e0 05             	shl    $0x5,%eax
f0113b40:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113b43:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113b4a:	99                   	cltd   
f0113b4b:	f7 fe                	idiv   %esi
f0113b4d:	89 c3                	mov    %eax,%ebx
f0113b4f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b52:	c1 e0 05             	shl    $0x5,%eax
f0113b55:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113b58:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113b5f:	99                   	cltd   
f0113b60:	f7 fe                	idiv   %esi
f0113b62:	01 d8                	add    %ebx,%eax
f0113b64:	39 c1                	cmp    %eax,%ecx
f0113b66:	74 54                	je     f0113bbc <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0113b68:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b6b:	c1 e0 05             	shl    $0x5,%eax
f0113b6e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113b71:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113b78:	99                   	cltd   
f0113b79:	f7 ff                	idiv   %edi
f0113b7b:	89 c1                	mov    %eax,%ecx
f0113b7d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b80:	c1 e0 05             	shl    $0x5,%eax
f0113b83:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113b86:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113b8d:	99                   	cltd   
f0113b8e:	f7 fe                	idiv   %esi
f0113b90:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0113b93:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113b96:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113b99:	83 ec 08             	sub    $0x8,%esp
f0113b9c:	52                   	push   %edx
f0113b9d:	50                   	push   %eax
f0113b9e:	ff 75 a8             	pushl  -0x58(%ebp)
f0113ba1:	68 b0 98 12 f0       	push   $0xf01298b0
f0113ba6:	68 6d 05 00 00       	push   $0x56d
f0113bab:	68 02 82 12 f0       	push   $0xf0128202
f0113bb0:	e8 21 c9 fe ff       	call   f01004d6 <_warn>
f0113bb5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113bb8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113bbc:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113bc0:	74 04                	je     f0113bc6 <test_allocate_chunk+0x3ac>
f0113bc2:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113bc6:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0113bca:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0113bd1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113bd4:	c1 e0 05             	shl    $0x5,%eax
f0113bd7:	83 ec 08             	sub    $0x8,%esp
f0113bda:	6a 03                	push   $0x3
f0113bdc:	6a 00                	push   $0x0
f0113bde:	6a 00                	push   $0x0
f0113be0:	68 07 0e 00 00       	push   $0xe07
f0113be5:	68 03 0e 00 00       	push   $0xe03
f0113bea:	6a 01                	push   $0x1
f0113bec:	50                   	push   %eax
f0113bed:	6a 00                	push   $0x0
f0113bef:	6a 00                	push   $0x0
f0113bf1:	ff 75 cc             	pushl  -0x34(%ebp)
f0113bf4:	e8 4f 1d 00 00       	call   f0115948 <CCP>
f0113bf9:	83 c4 30             	add    $0x30,%esp
f0113bfc:	85 c0                	test   %eax,%eax
f0113bfe:	75 25                	jne    f0113c25 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113c00:	83 ec 04             	sub    $0x4,%esp
f0113c03:	68 ec 97 12 f0       	push   $0xf01297ec
f0113c08:	68 76 05 00 00       	push   $0x576
f0113c0d:	68 02 82 12 f0       	push   $0xf0128202
f0113c12:	e8 bf c8 fe ff       	call   f01004d6 <_warn>
f0113c17:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c1a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0113c1e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0113c25:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113c29:	74 04                	je     f0113c2f <test_allocate_chunk+0x415>
f0113c2b:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113c2f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0113c33:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0113c37:	74 5a                	je     f0113c93 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0113c39:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113c3c:	01 c0                	add    %eax,%eax
f0113c3e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0113c41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113c44:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0113c47:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113c4a:	01 c0                	add    %eax,%eax
f0113c4c:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0113c4f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c52:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0113c55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113c58:	8a 00                	mov    (%eax),%al
f0113c5a:	3c 4b                	cmp    $0x4b,%al
f0113c5c:	75 09                	jne    f0113c67 <test_allocate_chunk+0x44d>
f0113c5e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c61:	8a 00                	mov    (%eax),%al
f0113c63:	3c 4d                	cmp    $0x4d,%al
f0113c65:	74 1e                	je     f0113c85 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0113c67:	83 ec 04             	sub    $0x4,%esp
f0113c6a:	68 38 98 12 f0       	push   $0xf0129838
f0113c6f:	68 84 05 00 00       	push   $0x584
f0113c74:	68 02 82 12 f0       	push   $0xf0128202
f0113c79:	e8 58 c8 fe ff       	call   f01004d6 <_warn>
f0113c7e:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113c81:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0113c85:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113c89:	74 04                	je     f0113c8f <test_allocate_chunk+0x475>
f0113c8b:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0113c8f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0113c93:	83 ec 0c             	sub    $0xc,%esp
f0113c96:	68 8f 8b 12 f0       	push   $0xf0128b8f
f0113c9b:	e8 eb d2 fe ff       	call   f0100f8b <cprintf>
f0113ca0:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0113ca3:	83 ec 0c             	sub    $0xc,%esp
f0113ca6:	68 10 99 12 f0       	push   $0xf0129910
f0113cab:	e8 db d2 fe ff       	call   f0100f8b <cprintf>
f0113cb0:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113cb3:	e8 6e 9d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0113cb8:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0113cbb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113cbe:	c1 e0 06             	shl    $0x6,%eax
f0113cc1:	89 c2                	mov    %eax,%edx
f0113cc3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113cc6:	c1 e0 05             	shl    $0x5,%eax
f0113cc9:	6a 00                	push   $0x0
f0113ccb:	52                   	push   %edx
f0113ccc:	50                   	push   %eax
f0113ccd:	ff 75 cc             	pushl  -0x34(%ebp)
f0113cd0:	e8 59 62 ff ff       	call   f0109f2e <allocate_chunk>
f0113cd5:	83 c4 10             	add    $0x10,%esp
f0113cd8:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113cdb:	e8 46 9d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0113ce0:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0113ce3:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0113ce7:	75 36                	jne    f0113d1f <test_allocate_chunk+0x505>
f0113ce9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113cec:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113cef:	89 c1                	mov    %eax,%ecx
f0113cf1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113cf4:	c1 e0 06             	shl    $0x6,%eax
f0113cf7:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113cfa:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113d01:	99                   	cltd   
f0113d02:	f7 ff                	idiv   %edi
f0113d04:	89 c3                	mov    %eax,%ebx
f0113d06:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113d09:	c1 e0 06             	shl    $0x6,%eax
f0113d0c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d0f:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113d16:	99                   	cltd   
f0113d17:	f7 fe                	idiv   %esi
f0113d19:	01 d8                	add    %ebx,%eax
f0113d1b:	39 c1                	cmp    %eax,%ecx
f0113d1d:	74 54                	je     f0113d73 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0113d1f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113d22:	c1 e0 06             	shl    $0x6,%eax
f0113d25:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113d28:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113d2f:	99                   	cltd   
f0113d30:	f7 fb                	idiv   %ebx
f0113d32:	89 c1                	mov    %eax,%ecx
f0113d34:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113d37:	c1 e0 06             	shl    $0x6,%eax
f0113d3a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d3d:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113d44:	99                   	cltd   
f0113d45:	f7 ff                	idiv   %edi
f0113d47:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0113d4a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d4d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113d50:	83 ec 08             	sub    $0x8,%esp
f0113d53:	52                   	push   %edx
f0113d54:	50                   	push   %eax
f0113d55:	ff 75 a4             	pushl  -0x5c(%ebp)
f0113d58:	68 b0 98 12 f0       	push   $0xf01298b0
f0113d5d:	68 9a 05 00 00       	push   $0x59a
f0113d62:	68 02 82 12 f0       	push   $0xf0128202
f0113d67:	e8 6a c7 fe ff       	call   f01004d6 <_warn>
f0113d6c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113d6f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113d73:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113d77:	74 04                	je     f0113d7d <test_allocate_chunk+0x563>
f0113d79:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113d7d:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0113d81:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0113d88:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113d8b:	c1 e0 06             	shl    $0x6,%eax
f0113d8e:	89 c2                	mov    %eax,%edx
f0113d90:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113d93:	c1 e0 05             	shl    $0x5,%eax
f0113d96:	83 ec 08             	sub    $0x8,%esp
f0113d99:	6a 03                	push   $0x3
f0113d9b:	6a 00                	push   $0x0
f0113d9d:	6a 00                	push   $0x0
f0113d9f:	68 07 0e 00 00       	push   $0xe07
f0113da4:	6a 01                	push   $0x1
f0113da6:	6a 01                	push   $0x1
f0113da8:	52                   	push   %edx
f0113da9:	50                   	push   %eax
f0113daa:	6a 00                	push   $0x0
f0113dac:	ff 75 cc             	pushl  -0x34(%ebp)
f0113daf:	e8 94 1b 00 00       	call   f0115948 <CCP>
f0113db4:	83 c4 30             	add    $0x30,%esp
f0113db7:	85 c0                	test   %eax,%eax
f0113db9:	75 25                	jne    f0113de0 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113dbb:	83 ec 04             	sub    $0x4,%esp
f0113dbe:	68 ec 97 12 f0       	push   $0xf01297ec
f0113dc3:	68 a3 05 00 00       	push   $0x5a3
f0113dc8:	68 02 82 12 f0       	push   $0xf0128202
f0113dcd:	e8 04 c7 fe ff       	call   f01004d6 <_warn>
f0113dd2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113dd5:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0113dd9:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0113de0:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113de4:	74 04                	je     f0113dea <test_allocate_chunk+0x5d0>
f0113de6:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113dea:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0113dee:	83 ec 0c             	sub    $0xc,%esp
f0113df1:	68 f2 8b 12 f0       	push   $0xf0128bf2
f0113df6:	e8 90 d1 fe ff       	call   f0100f8b <cprintf>
f0113dfb:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0113dfe:	83 ec 0c             	sub    $0xc,%esp
f0113e01:	68 50 99 12 f0       	push   $0xf0129950
f0113e06:	e8 80 d1 fe ff       	call   f0100f8b <cprintf>
f0113e0b:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113e0e:	e8 13 9c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0113e13:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0113e16:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113e19:	c1 e0 06             	shl    $0x6,%eax
f0113e1c:	68 06 0e 00 00       	push   $0xe06
f0113e21:	50                   	push   %eax
f0113e22:	68 00 00 00 80       	push   $0x80000000
f0113e27:	ff 75 cc             	pushl  -0x34(%ebp)
f0113e2a:	e8 ff 60 ff ff       	call   f0109f2e <allocate_chunk>
f0113e2f:	83 c4 10             	add    $0x10,%esp
f0113e32:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113e35:	e8 ec 9b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0113e3a:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0113e3d:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0113e41:	75 36                	jne    f0113e79 <test_allocate_chunk+0x65f>
f0113e43:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113e46:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113e49:	89 c1                	mov    %eax,%ecx
f0113e4b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113e4e:	c1 e0 06             	shl    $0x6,%eax
f0113e51:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113e54:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113e5b:	99                   	cltd   
f0113e5c:	f7 fb                	idiv   %ebx
f0113e5e:	89 c3                	mov    %eax,%ebx
f0113e60:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113e63:	c1 e0 06             	shl    $0x6,%eax
f0113e66:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113e69:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113e70:	99                   	cltd   
f0113e71:	f7 fe                	idiv   %esi
f0113e73:	01 d8                	add    %ebx,%eax
f0113e75:	39 c1                	cmp    %eax,%ecx
f0113e77:	74 54                	je     f0113ecd <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0113e79:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113e7c:	c1 e0 06             	shl    $0x6,%eax
f0113e7f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113e82:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113e89:	99                   	cltd   
f0113e8a:	f7 ff                	idiv   %edi
f0113e8c:	89 c1                	mov    %eax,%ecx
f0113e8e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113e91:	c1 e0 06             	shl    $0x6,%eax
f0113e94:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113e97:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113e9e:	99                   	cltd   
f0113e9f:	f7 fb                	idiv   %ebx
f0113ea1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0113ea4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ea7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113eaa:	83 ec 08             	sub    $0x8,%esp
f0113ead:	52                   	push   %edx
f0113eae:	50                   	push   %eax
f0113eaf:	ff 75 9c             	pushl  -0x64(%ebp)
f0113eb2:	68 b0 98 12 f0       	push   $0xf01298b0
f0113eb7:	68 b9 05 00 00       	push   $0x5b9
f0113ebc:	68 02 82 12 f0       	push   $0xf0128202
f0113ec1:	e8 10 c6 fe ff       	call   f01004d6 <_warn>
f0113ec6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113ec9:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113ecd:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113ed1:	74 04                	je     f0113ed7 <test_allocate_chunk+0x6bd>
f0113ed3:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113ed7:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0113edb:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0113ee2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113ee5:	c1 e0 06             	shl    $0x6,%eax
f0113ee8:	83 ec 08             	sub    $0x8,%esp
f0113eeb:	6a 03                	push   $0x3
f0113eed:	6a 00                	push   $0x0
f0113eef:	6a 00                	push   $0x0
f0113ef1:	68 07 0e 00 00       	push   $0xe07
f0113ef6:	68 07 0e 00 00       	push   $0xe07
f0113efb:	6a 01                	push   $0x1
f0113efd:	50                   	push   %eax
f0113efe:	68 00 00 00 80       	push   $0x80000000
f0113f03:	6a 00                	push   $0x0
f0113f05:	ff 75 cc             	pushl  -0x34(%ebp)
f0113f08:	e8 3b 1a 00 00       	call   f0115948 <CCP>
f0113f0d:	83 c4 30             	add    $0x30,%esp
f0113f10:	85 c0                	test   %eax,%eax
f0113f12:	75 25                	jne    f0113f39 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113f14:	83 ec 04             	sub    $0x4,%esp
f0113f17:	68 ec 97 12 f0       	push   $0xf01297ec
f0113f1c:	68 c2 05 00 00       	push   $0x5c2
f0113f21:	68 02 82 12 f0       	push   $0xf0128202
f0113f26:	e8 ab c5 fe ff       	call   f01004d6 <_warn>
f0113f2b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113f2e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0113f32:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0113f39:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113f3d:	74 04                	je     f0113f43 <test_allocate_chunk+0x729>
f0113f3f:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113f43:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0113f47:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0113f4b:	74 6f                	je     f0113fbc <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0113f4d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113f50:	01 c0                	add    %eax,%eax
f0113f52:	05 00 00 00 80       	add    $0x80000000,%eax
f0113f57:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0113f5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113f5d:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0113f60:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113f63:	89 d0                	mov    %edx,%eax
f0113f65:	c1 e0 02             	shl    $0x2,%eax
f0113f68:	01 d0                	add    %edx,%eax
f0113f6a:	01 c0                	add    %eax,%eax
f0113f6c:	01 d0                	add    %edx,%eax
f0113f6e:	01 c0                	add    %eax,%eax
f0113f70:	05 00 00 00 80       	add    $0x80000000,%eax
f0113f75:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0113f78:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113f7b:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0113f7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113f81:	8a 00                	mov    (%eax),%al
f0113f83:	3c 4b                	cmp    $0x4b,%al
f0113f85:	75 09                	jne    f0113f90 <test_allocate_chunk+0x776>
f0113f87:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113f8a:	8a 00                	mov    (%eax),%al
f0113f8c:	3c 4d                	cmp    $0x4d,%al
f0113f8e:	74 1e                	je     f0113fae <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0113f90:	83 ec 04             	sub    $0x4,%esp
f0113f93:	68 38 98 12 f0       	push   $0xf0129838
f0113f98:	68 d0 05 00 00       	push   $0x5d0
f0113f9d:	68 02 82 12 f0       	push   $0xf0128202
f0113fa2:	e8 2f c5 fe ff       	call   f01004d6 <_warn>
f0113fa7:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113faa:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0113fae:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113fb2:	74 04                	je     f0113fb8 <test_allocate_chunk+0x79e>
f0113fb4:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0113fb8:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0113fbc:	83 ec 0c             	sub    $0xc,%esp
f0113fbf:	68 c4 96 12 f0       	push   $0xf01296c4
f0113fc4:	e8 c2 cf fe ff       	call   f0100f8b <cprintf>
f0113fc9:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0113fcc:	83 ec 0c             	sub    $0xc,%esp
f0113fcf:	68 8c 99 12 f0       	push   $0xf012998c
f0113fd4:	e8 b2 cf fe ff       	call   f0100f8b <cprintf>
f0113fd9:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113fdc:	e8 45 9a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0113fe1:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0113fe4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113fe7:	89 d0                	mov    %edx,%eax
f0113fe9:	01 c0                	add    %eax,%eax
f0113feb:	01 d0                	add    %edx,%eax
f0113fed:	01 c0                	add    %eax,%eax
f0113fef:	01 d0                	add    %edx,%eax
f0113ff1:	68 04 0e 00 00       	push   $0xe04
f0113ff6:	50                   	push   %eax
f0113ff7:	68 00 fc 3f 40       	push   $0x403ffc00
f0113ffc:	ff 75 cc             	pushl  -0x34(%ebp)
f0113fff:	e8 2a 5f ff ff       	call   f0109f2e <allocate_chunk>
f0114004:	83 c4 10             	add    $0x10,%esp
f0114007:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011400a:	e8 17 9a ff ff       	call   f010da26 <sys_calculate_free_frames>
f011400f:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0114012:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0114016:	75 0b                	jne    f0114023 <test_allocate_chunk+0x809>
f0114018:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011401b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011401e:	83 f8 05             	cmp    $0x5,%eax
f0114021:	74 2a                	je     f011404d <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0114023:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114026:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114029:	83 ec 08             	sub    $0x8,%esp
f011402c:	6a 05                	push   $0x5
f011402e:	50                   	push   %eax
f011402f:	ff 75 98             	pushl  -0x68(%ebp)
f0114032:	68 b0 98 12 f0       	push   $0xf01298b0
f0114037:	68 e7 05 00 00       	push   $0x5e7
f011403c:	68 02 82 12 f0       	push   $0xf0128202
f0114041:	e8 90 c4 fe ff       	call   f01004d6 <_warn>
f0114046:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114049:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011404d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114051:	74 04                	je     f0114057 <test_allocate_chunk+0x83d>
f0114053:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114057:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f011405b:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114062:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114065:	89 d0                	mov    %edx,%eax
f0114067:	01 c0                	add    %eax,%eax
f0114069:	01 d0                	add    %edx,%eax
f011406b:	c1 e0 02             	shl    $0x2,%eax
f011406e:	83 ec 08             	sub    $0x8,%esp
f0114071:	6a 03                	push   $0x3
f0114073:	6a 00                	push   $0x0
f0114075:	6a 00                	push   $0x0
f0114077:	68 07 0e 00 00       	push   $0xe07
f011407c:	68 05 0e 00 00       	push   $0xe05
f0114081:	6a 01                	push   $0x1
f0114083:	50                   	push   %eax
f0114084:	68 00 f0 3f 40       	push   $0x403ff000
f0114089:	6a 00                	push   $0x0
f011408b:	ff 75 cc             	pushl  -0x34(%ebp)
f011408e:	e8 b5 18 00 00       	call   f0115948 <CCP>
f0114093:	83 c4 30             	add    $0x30,%esp
f0114096:	85 c0                	test   %eax,%eax
f0114098:	75 25                	jne    f01140bf <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011409a:	83 ec 04             	sub    $0x4,%esp
f011409d:	68 ec 97 12 f0       	push   $0xf01297ec
f01140a2:	68 f0 05 00 00       	push   $0x5f0
f01140a7:	68 02 82 12 f0       	push   $0xf0128202
f01140ac:	e8 25 c4 fe ff       	call   f01004d6 <_warn>
f01140b1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01140b4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01140b8:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f01140bf:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01140c3:	74 04                	je     f01140c9 <test_allocate_chunk+0x8af>
f01140c5:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01140c9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f01140cd:	83 ec 0c             	sub    $0xc,%esp
f01140d0:	68 c3 99 12 f0       	push   $0xf01299c3
f01140d5:	e8 b1 ce fe ff       	call   f0100f8b <cprintf>
f01140da:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f01140dd:	83 ec 08             	sub    $0x8,%esp
f01140e0:	ff 75 e0             	pushl  -0x20(%ebp)
f01140e3:	68 d4 99 12 f0       	push   $0xf01299d4
f01140e8:	e8 9e ce fe ff       	call   f0100f8b <cprintf>
f01140ed:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01140f0:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f01140f4:	75 10                	jne    f0114106 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f01140f6:	83 ec 0c             	sub    $0xc,%esp
f01140f9:	68 08 9a 12 f0       	push   $0xf0129a08
f01140fe:	e8 88 ce fe ff       	call   f0100f8b <cprintf>
f0114103:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114106:	a1 a4 4a 5f f0       	mov    0xf05f4aa4,%eax
f011410b:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011410e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114111:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114114:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114119:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011411c:	5b                   	pop    %ebx
f011411d:	5e                   	pop    %esi
f011411e:	5f                   	pop    %edi
f011411f:	5d                   	pop    %ebp
f0114120:	c3                   	ret    

f0114121 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0114121:	55                   	push   %ebp
f0114122:	89 e5                	mov    %esp,%ebp
f0114124:	57                   	push   %edi
f0114125:	56                   	push   %esi
f0114126:	53                   	push   %ebx
f0114127:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011412d:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114130:	bb 04 89 12 f0       	mov    $0xf0128904,%ebx
f0114135:	ba 0f 00 00 00       	mov    $0xf,%edx
f011413a:	89 c7                	mov    %eax,%edi
f011413c:	89 de                	mov    %ebx,%esi
f011413e:	89 d1                	mov    %edx,%ecx
f0114140:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114142:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0114145:	b9 23 00 00 00       	mov    $0x23,%ecx
f011414a:	b0 00                	mov    $0x0,%al
f011414c:	89 d7                	mov    %edx,%edi
f011414e:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114150:	6a 00                	push   $0x0
f0114152:	6a 0a                	push   $0xa
f0114154:	6a 14                	push   $0x14
f0114156:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114159:	50                   	push   %eax
f011415a:	e8 2e 60 ff ff       	call   f010a18d <env_create>
f011415f:	83 c4 10             	add    $0x10,%esp
f0114162:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114165:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114168:	8b 40 64             	mov    0x64(%eax),%eax
f011416b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011416e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114171:	8b 40 68             	mov    0x68(%eax),%eax
f0114174:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0114177:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011417a:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011417d:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0114184:	75 70 20 
f0114187:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011418e:	00 00 00 
f0114191:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0114194:	b9 03 00 00 00       	mov    $0x3,%ecx
f0114199:	b8 00 00 00 00       	mov    $0x0,%eax
f011419e:	89 d7                	mov    %edx,%edi
f01141a0:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01141a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01141a5:	8b 40 10             	mov    0x10(%eax),%eax
f01141a8:	83 ec 08             	sub    $0x8,%esp
f01141ab:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01141b1:	52                   	push   %edx
f01141b2:	50                   	push   %eax
f01141b3:	e8 3b ae 00 00       	call   f011eff3 <ltostr>
f01141b8:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01141bb:	83 ec 04             	sub    $0x4,%esp
f01141be:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01141c4:	50                   	push   %eax
f01141c5:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01141cb:	50                   	push   %eax
f01141cc:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01141d2:	50                   	push   %eax
f01141d3:	e8 f4 ae 00 00       	call   f011f0cc <strcconcat>
f01141d8:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01141db:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f01141e2:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f01141e9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f01141f0:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f01141f7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f01141fb:	83 ec 0c             	sub    $0xc,%esp
f01141fe:	ff 75 d8             	pushl  -0x28(%ebp)
f0114201:	e8 0e 17 00 00       	call   f0115914 <ClearUserSpace>
f0114206:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0114209:	83 ec 0c             	sub    $0xc,%esp
f011420c:	68 48 9a 12 f0       	push   $0xf0129a48
f0114211:	e8 75 cd fe ff       	call   f0100f8b <cprintf>
f0114216:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0114219:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011421c:	c1 e0 03             	shl    $0x3,%eax
f011421f:	83 ec 04             	sub    $0x4,%esp
f0114222:	50                   	push   %eax
f0114223:	6a 00                	push   $0x0
f0114225:	ff 75 d8             	pushl  -0x28(%ebp)
f0114228:	e8 35 5d ff ff       	call   f0109f62 <calculate_required_frames>
f011422d:	83 c4 10             	add    $0x10,%esp
f0114230:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114233:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114237:	74 23                	je     f011425c <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114239:	83 ec 0c             	sub    $0xc,%esp
f011423c:	6a 03                	push   $0x3
f011423e:	ff 75 c8             	pushl  -0x38(%ebp)
f0114241:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0114246:	68 29 06 00 00       	push   $0x629
f011424b:	68 02 82 12 f0       	push   $0xf0128202
f0114250:	e8 81 c2 fe ff       	call   f01004d6 <_warn>
f0114255:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114258:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011425c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114260:	74 04                	je     f0114266 <test_calculate_required_frames+0x145>
f0114262:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114266:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f011426a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011426d:	c1 e0 02             	shl    $0x2,%eax
f0114270:	83 ec 04             	sub    $0x4,%esp
f0114273:	50                   	push   %eax
f0114274:	6a 00                	push   $0x0
f0114276:	ff 75 d8             	pushl  -0x28(%ebp)
f0114279:	e8 e4 5c ff ff       	call   f0109f62 <calculate_required_frames>
f011427e:	83 c4 10             	add    $0x10,%esp
f0114281:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0114284:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f011428b:	74 26                	je     f01142b3 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f011428d:	83 ec 0c             	sub    $0xc,%esp
f0114290:	68 01 04 00 00       	push   $0x401
f0114295:	ff 75 c8             	pushl  -0x38(%ebp)
f0114298:	68 7c 9a 12 f0       	push   $0xf0129a7c
f011429d:	68 33 06 00 00       	push   $0x633
f01142a2:	68 02 82 12 f0       	push   $0xf0128202
f01142a7:	e8 2a c2 fe ff       	call   f01004d6 <_warn>
f01142ac:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01142af:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01142b3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01142b7:	74 04                	je     f01142bd <test_calculate_required_frames+0x19c>
f01142b9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01142bd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01142c1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01142c4:	c1 e0 0a             	shl    $0xa,%eax
f01142c7:	83 ec 04             	sub    $0x4,%esp
f01142ca:	50                   	push   %eax
f01142cb:	6a 00                	push   $0x0
f01142cd:	ff 75 d8             	pushl  -0x28(%ebp)
f01142d0:	e8 8d 5c ff ff       	call   f0109f62 <calculate_required_frames>
f01142d5:	83 c4 10             	add    $0x10,%esp
f01142d8:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f01142db:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01142de:	c1 e0 0a             	shl    $0xa,%eax
f01142e1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01142e4:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01142eb:	99                   	cltd   
f01142ec:	f7 fb                	idiv   %ebx
f01142ee:	89 c1                	mov    %eax,%ecx
f01142f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01142f3:	c1 e0 0a             	shl    $0xa,%eax
f01142f6:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01142f9:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114300:	99                   	cltd   
f0114301:	f7 fe                	idiv   %esi
f0114303:	01 c8                	add    %ecx,%eax
f0114305:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0114308:	74 4c                	je     f0114356 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f011430a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011430d:	c1 e0 0a             	shl    $0xa,%eax
f0114310:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114313:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011431a:	99                   	cltd   
f011431b:	f7 fb                	idiv   %ebx
f011431d:	89 c1                	mov    %eax,%ecx
f011431f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114322:	c1 e0 0a             	shl    $0xa,%eax
f0114325:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114328:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011432f:	99                   	cltd   
f0114330:	f7 fe                	idiv   %esi
f0114332:	01 c8                	add    %ecx,%eax
f0114334:	83 ec 0c             	sub    $0xc,%esp
f0114337:	50                   	push   %eax
f0114338:	ff 75 c8             	pushl  -0x38(%ebp)
f011433b:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0114340:	68 3d 06 00 00       	push   $0x63d
f0114345:	68 02 82 12 f0       	push   $0xf0128202
f011434a:	e8 87 c1 fe ff       	call   f01004d6 <_warn>
f011434f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114352:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114356:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011435a:	74 04                	je     f0114360 <test_calculate_required_frames+0x23f>
f011435c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114360:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0114364:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114367:	89 d0                	mov    %edx,%eax
f0114369:	01 c0                	add    %eax,%eax
f011436b:	01 d0                	add    %edx,%eax
f011436d:	01 c0                	add    %eax,%eax
f011436f:	83 ec 04             	sub    $0x4,%esp
f0114372:	50                   	push   %eax
f0114373:	68 00 10 00 00       	push   $0x1000
f0114378:	ff 75 d8             	pushl  -0x28(%ebp)
f011437b:	e8 e2 5b ff ff       	call   f0109f62 <calculate_required_frames>
f0114380:	83 c4 10             	add    $0x10,%esp
f0114383:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114386:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011438a:	74 23                	je     f01143af <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011438c:	83 ec 0c             	sub    $0xc,%esp
f011438f:	6a 03                	push   $0x3
f0114391:	ff 75 c8             	pushl  -0x38(%ebp)
f0114394:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0114399:	68 49 06 00 00       	push   $0x649
f011439e:	68 02 82 12 f0       	push   $0xf0128202
f01143a3:	e8 2e c1 fe ff       	call   f01004d6 <_warn>
f01143a8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01143ab:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01143af:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143b3:	74 04                	je     f01143b9 <test_calculate_required_frames+0x298>
f01143b5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01143b9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01143bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01143c0:	89 c2                	mov    %eax,%edx
f01143c2:	01 d2                	add    %edx,%edx
f01143c4:	01 d0                	add    %edx,%eax
f01143c6:	83 ec 04             	sub    $0x4,%esp
f01143c9:	50                   	push   %eax
f01143ca:	68 00 18 00 00       	push   $0x1800
f01143cf:	ff 75 d8             	pushl  -0x28(%ebp)
f01143d2:	e8 8b 5b ff ff       	call   f0109f62 <calculate_required_frames>
f01143d7:	83 c4 10             	add    $0x10,%esp
f01143da:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01143dd:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01143e1:	74 23                	je     f0114406 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01143e3:	83 ec 0c             	sub    $0xc,%esp
f01143e6:	6a 03                	push   $0x3
f01143e8:	ff 75 c8             	pushl  -0x38(%ebp)
f01143eb:	68 7c 9a 12 f0       	push   $0xf0129a7c
f01143f0:	68 53 06 00 00       	push   $0x653
f01143f5:	68 02 82 12 f0       	push   $0xf0128202
f01143fa:	e8 d7 c0 fe ff       	call   f01004d6 <_warn>
f01143ff:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114402:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114406:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011440a:	74 04                	je     f0114410 <test_calculate_required_frames+0x2ef>
f011440c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114410:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0114414:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114417:	89 d0                	mov    %edx,%eax
f0114419:	c1 e0 02             	shl    $0x2,%eax
f011441c:	01 d0                	add    %edx,%eax
f011441e:	01 c0                	add    %eax,%eax
f0114420:	83 ec 04             	sub    $0x4,%esp
f0114423:	50                   	push   %eax
f0114424:	68 00 00 40 00       	push   $0x400000
f0114429:	ff 75 d8             	pushl  -0x28(%ebp)
f011442c:	e8 31 5b ff ff       	call   f0109f62 <calculate_required_frames>
f0114431:	83 c4 10             	add    $0x10,%esp
f0114434:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0114437:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f011443e:	74 26                	je     f0114466 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0114440:	83 ec 0c             	sub    $0xc,%esp
f0114443:	68 03 0a 00 00       	push   $0xa03
f0114448:	ff 75 c8             	pushl  -0x38(%ebp)
f011444b:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0114450:	68 5d 06 00 00       	push   $0x65d
f0114455:	68 02 82 12 f0       	push   $0xf0128202
f011445a:	e8 77 c0 fe ff       	call   f01004d6 <_warn>
f011445f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114462:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114466:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011446a:	74 04                	je     f0114470 <test_calculate_required_frames+0x34f>
f011446c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114470:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0114474:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114477:	01 c0                	add    %eax,%eax
f0114479:	83 ec 04             	sub    $0x4,%esp
f011447c:	50                   	push   %eax
f011447d:	68 00 00 70 00       	push   $0x700000
f0114482:	ff 75 d8             	pushl  -0x28(%ebp)
f0114485:	e8 d8 5a ff ff       	call   f0109f62 <calculate_required_frames>
f011448a:	83 c4 10             	add    $0x10,%esp
f011448d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0114490:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0114497:	74 26                	je     f01144bf <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0114499:	83 ec 0c             	sub    $0xc,%esp
f011449c:	68 02 02 00 00       	push   $0x202
f01144a1:	ff 75 c8             	pushl  -0x38(%ebp)
f01144a4:	68 7c 9a 12 f0       	push   $0xf0129a7c
f01144a9:	68 69 06 00 00       	push   $0x669
f01144ae:	68 02 82 12 f0       	push   $0xf0128202
f01144b3:	e8 1e c0 fe ff       	call   f01004d6 <_warn>
f01144b8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01144bb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01144bf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144c3:	74 04                	je     f01144c9 <test_calculate_required_frames+0x3a8>
f01144c5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01144c9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01144cd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01144d0:	83 ec 04             	sub    $0x4,%esp
f01144d3:	50                   	push   %eax
f01144d4:	68 ff ff 3f 00       	push   $0x3fffff
f01144d9:	ff 75 d8             	pushl  -0x28(%ebp)
f01144dc:	e8 81 5a ff ff       	call   f0109f62 <calculate_required_frames>
f01144e1:	83 c4 10             	add    $0x10,%esp
f01144e4:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f01144e7:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f01144eb:	74 23                	je     f0114510 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f01144ed:	83 ec 0c             	sub    $0xc,%esp
f01144f0:	6a 04                	push   $0x4
f01144f2:	ff 75 c8             	pushl  -0x38(%ebp)
f01144f5:	68 7c 9a 12 f0       	push   $0xf0129a7c
f01144fa:	68 73 06 00 00       	push   $0x673
f01144ff:	68 02 82 12 f0       	push   $0xf0128202
f0114504:	e8 cd bf fe ff       	call   f01004d6 <_warn>
f0114509:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011450c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114510:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114514:	74 04                	je     f011451a <test_calculate_required_frames+0x3f9>
f0114516:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011451a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011451e:	83 ec 0c             	sub    $0xc,%esp
f0114521:	68 b5 95 12 f0       	push   $0xf01295b5
f0114526:	e8 60 ca fe ff       	call   f0100f8b <cprintf>
f011452b:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f011452e:	83 ec 0c             	sub    $0xc,%esp
f0114531:	68 d4 9a 12 f0       	push   $0xf0129ad4
f0114536:	e8 50 ca fe ff       	call   f0100f8b <cprintf>
f011453b:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f011453e:	83 ec 04             	sub    $0x4,%esp
f0114541:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0114547:	50                   	push   %eax
f0114548:	68 6e 89 12 f0       	push   $0xf012896e
f011454d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114553:	50                   	push   %eax
f0114554:	e8 73 ab 00 00       	call   f011f0cc <strcconcat>
f0114559:	83 c4 10             	add    $0x10,%esp
f011455c:	83 ec 0c             	sub    $0xc,%esp
f011455f:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0114565:	50                   	push   %eax
f0114566:	e8 90 d9 fe ff       	call   f0101efb <execute_command>
f011456b:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f011456e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114571:	c1 e0 03             	shl    $0x3,%eax
f0114574:	83 ec 04             	sub    $0x4,%esp
f0114577:	50                   	push   %eax
f0114578:	6a 00                	push   $0x0
f011457a:	ff 75 d8             	pushl  -0x28(%ebp)
f011457d:	e8 e0 59 ff ff       	call   f0109f62 <calculate_required_frames>
f0114582:	83 c4 10             	add    $0x10,%esp
f0114585:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0114588:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f011458f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114592:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114595:	74 24                	je     f01145bb <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0114597:	83 ec 0c             	sub    $0xc,%esp
f011459a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011459d:	ff 75 c8             	pushl  -0x38(%ebp)
f01145a0:	68 7c 9a 12 f0       	push   $0xf0129a7c
f01145a5:	68 87 06 00 00       	push   $0x687
f01145aa:	68 02 82 12 f0       	push   $0xf0128202
f01145af:	e8 22 bf fe ff       	call   f01004d6 <_warn>
f01145b4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01145b7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01145bb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145bf:	74 04                	je     f01145c5 <test_calculate_required_frames+0x4a4>
f01145c1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01145c5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01145c9:	83 ec 04             	sub    $0x4,%esp
f01145cc:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01145d2:	50                   	push   %eax
f01145d3:	68 7b 89 12 f0       	push   $0xf012897b
f01145d8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01145de:	50                   	push   %eax
f01145df:	e8 e8 aa 00 00       	call   f011f0cc <strcconcat>
f01145e4:	83 c4 10             	add    $0x10,%esp
f01145e7:	83 ec 0c             	sub    $0xc,%esp
f01145ea:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01145f0:	50                   	push   %eax
f01145f1:	e8 05 d9 fe ff       	call   f0101efb <execute_command>
f01145f6:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01145f9:	83 ec 04             	sub    $0x4,%esp
f01145fc:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114602:	50                   	push   %eax
f0114603:	68 08 9b 12 f0       	push   $0xf0129b08
f0114608:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011460e:	50                   	push   %eax
f011460f:	e8 b8 aa 00 00       	call   f011f0cc <strcconcat>
f0114614:	83 c4 10             	add    $0x10,%esp
f0114617:	83 ec 0c             	sub    $0xc,%esp
f011461a:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114620:	50                   	push   %eax
f0114621:	e8 d5 d8 fe ff       	call   f0101efb <execute_command>
f0114626:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0114629:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011462c:	c1 e0 03             	shl    $0x3,%eax
f011462f:	83 ec 04             	sub    $0x4,%esp
f0114632:	50                   	push   %eax
f0114633:	6a 00                	push   $0x0
f0114635:	ff 75 d8             	pushl  -0x28(%ebp)
f0114638:	e8 25 59 ff ff       	call   f0109f62 <calculate_required_frames>
f011463d:	83 c4 10             	add    $0x10,%esp
f0114640:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0114643:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f011464a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011464d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114650:	74 24                	je     f0114676 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0114652:	83 ec 0c             	sub    $0xc,%esp
f0114655:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114658:	ff 75 c8             	pushl  -0x38(%ebp)
f011465b:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0114660:	68 95 06 00 00       	push   $0x695
f0114665:	68 02 82 12 f0       	push   $0xf0128202
f011466a:	e8 67 be fe ff       	call   f01004d6 <_warn>
f011466f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114672:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114676:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011467a:	74 04                	je     f0114680 <test_calculate_required_frames+0x55f>
f011467c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114680:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0114684:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114687:	c1 e0 0a             	shl    $0xa,%eax
f011468a:	83 ec 04             	sub    $0x4,%esp
f011468d:	50                   	push   %eax
f011468e:	6a 00                	push   $0x0
f0114690:	ff 75 d8             	pushl  -0x28(%ebp)
f0114693:	e8 ca 58 ff ff       	call   f0109f62 <calculate_required_frames>
f0114698:	83 c4 10             	add    $0x10,%esp
f011469b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f011469e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01146a1:	c1 e0 0a             	shl    $0xa,%eax
f01146a4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01146a7:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01146ae:	99                   	cltd   
f01146af:	f7 fb                	idiv   %ebx
f01146b1:	89 c1                	mov    %eax,%ecx
f01146b3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01146b6:	c1 e0 0a             	shl    $0xa,%eax
f01146b9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01146bc:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01146c3:	99                   	cltd   
f01146c4:	f7 fe                	idiv   %esi
f01146c6:	01 c8                	add    %ecx,%eax
f01146c8:	83 e8 05             	sub    $0x5,%eax
f01146cb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f01146ce:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01146d1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01146d4:	74 24                	je     f01146fa <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01146d6:	83 ec 0c             	sub    $0xc,%esp
f01146d9:	ff 75 c4             	pushl  -0x3c(%ebp)
f01146dc:	ff 75 c8             	pushl  -0x38(%ebp)
f01146df:	68 7c 9a 12 f0       	push   $0xf0129a7c
f01146e4:	68 a0 06 00 00       	push   $0x6a0
f01146e9:	68 02 82 12 f0       	push   $0xf0128202
f01146ee:	e8 e3 bd fe ff       	call   f01004d6 <_warn>
f01146f3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01146f6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01146fa:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146fe:	74 04                	je     f0114704 <test_calculate_required_frames+0x5e3>
f0114700:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114704:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0114708:	83 ec 04             	sub    $0x4,%esp
f011470b:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114711:	50                   	push   %eax
f0114712:	68 14 9b 12 f0       	push   $0xf0129b14
f0114717:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011471d:	50                   	push   %eax
f011471e:	e8 a9 a9 00 00       	call   f011f0cc <strcconcat>
f0114723:	83 c4 10             	add    $0x10,%esp
f0114726:	83 ec 0c             	sub    $0xc,%esp
f0114729:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011472f:	50                   	push   %eax
f0114730:	e8 c6 d7 fe ff       	call   f0101efb <execute_command>
f0114735:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0114738:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011473b:	89 c2                	mov    %eax,%edx
f011473d:	01 d2                	add    %edx,%edx
f011473f:	01 d0                	add    %edx,%eax
f0114741:	83 ec 04             	sub    $0x4,%esp
f0114744:	50                   	push   %eax
f0114745:	68 00 18 00 00       	push   $0x1800
f011474a:	ff 75 d8             	pushl  -0x28(%ebp)
f011474d:	e8 10 58 ff ff       	call   f0109f62 <calculate_required_frames>
f0114752:	83 c4 10             	add    $0x10,%esp
f0114755:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0114758:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f011475f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114762:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114765:	74 24                	je     f011478b <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0114767:	83 ec 0c             	sub    $0xc,%esp
f011476a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011476d:	ff 75 c8             	pushl  -0x38(%ebp)
f0114770:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0114775:	68 af 06 00 00       	push   $0x6af
f011477a:	68 02 82 12 f0       	push   $0xf0128202
f011477f:	e8 52 bd fe ff       	call   f01004d6 <_warn>
f0114784:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114787:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011478b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011478f:	74 04                	je     f0114795 <test_calculate_required_frames+0x674>
f0114791:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114795:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0114799:	83 ec 04             	sub    $0x4,%esp
f011479c:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01147a2:	50                   	push   %eax
f01147a3:	68 d4 8b 12 f0       	push   $0xf0128bd4
f01147a8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01147ae:	50                   	push   %eax
f01147af:	e8 18 a9 00 00       	call   f011f0cc <strcconcat>
f01147b4:	83 c4 10             	add    $0x10,%esp
f01147b7:	83 ec 0c             	sub    $0xc,%esp
f01147ba:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01147c0:	50                   	push   %eax
f01147c1:	e8 35 d7 fe ff       	call   f0101efb <execute_command>
f01147c6:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01147c9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01147cc:	89 d0                	mov    %edx,%eax
f01147ce:	c1 e0 02             	shl    $0x2,%eax
f01147d1:	01 d0                	add    %edx,%eax
f01147d3:	01 c0                	add    %eax,%eax
f01147d5:	83 ec 04             	sub    $0x4,%esp
f01147d8:	50                   	push   %eax
f01147d9:	68 00 00 40 00       	push   $0x400000
f01147de:	ff 75 d8             	pushl  -0x28(%ebp)
f01147e1:	e8 7c 57 ff ff       	call   f0109f62 <calculate_required_frames>
f01147e6:	83 c4 10             	add    $0x10,%esp
f01147e9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f01147ec:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f01147f3:	74 26                	je     f011481b <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01147f5:	83 ec 0c             	sub    $0xc,%esp
f01147f8:	68 03 0a 00 00       	push   $0xa03
f01147fd:	ff 75 c8             	pushl  -0x38(%ebp)
f0114800:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0114805:	68 bb 06 00 00       	push   $0x6bb
f011480a:	68 02 82 12 f0       	push   $0xf0128202
f011480f:	e8 c2 bc fe ff       	call   f01004d6 <_warn>
f0114814:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114817:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011481b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011481f:	74 04                	je     f0114825 <test_calculate_required_frames+0x704>
f0114821:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114825:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0114829:	83 ec 04             	sub    $0x4,%esp
f011482c:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114832:	50                   	push   %eax
f0114833:	68 de 8b 12 f0       	push   $0xf0128bde
f0114838:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011483e:	50                   	push   %eax
f011483f:	e8 88 a8 00 00       	call   f011f0cc <strcconcat>
f0114844:	83 c4 10             	add    $0x10,%esp
f0114847:	83 ec 0c             	sub    $0xc,%esp
f011484a:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114850:	50                   	push   %eax
f0114851:	e8 a5 d6 fe ff       	call   f0101efb <execute_command>
f0114856:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0114859:	83 ec 04             	sub    $0x4,%esp
f011485c:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114862:	50                   	push   %eax
f0114863:	68 1c 9b 12 f0       	push   $0xf0129b1c
f0114868:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011486e:	50                   	push   %eax
f011486f:	e8 58 a8 00 00       	call   f011f0cc <strcconcat>
f0114874:	83 c4 10             	add    $0x10,%esp
f0114877:	83 ec 0c             	sub    $0xc,%esp
f011487a:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114880:	50                   	push   %eax
f0114881:	e8 75 d6 fe ff       	call   f0101efb <execute_command>
f0114886:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0114889:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011488c:	01 c0                	add    %eax,%eax
f011488e:	83 ec 04             	sub    $0x4,%esp
f0114891:	50                   	push   %eax
f0114892:	68 00 00 70 00       	push   $0x700000
f0114897:	ff 75 d8             	pushl  -0x28(%ebp)
f011489a:	e8 c3 56 ff ff       	call   f0109f62 <calculate_required_frames>
f011489f:	83 c4 10             	add    $0x10,%esp
f01148a2:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f01148a5:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f01148ac:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01148af:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01148b2:	74 24                	je     f01148d8 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01148b4:	83 ec 0c             	sub    $0xc,%esp
f01148b7:	ff 75 c4             	pushl  -0x3c(%ebp)
f01148ba:	ff 75 c8             	pushl  -0x38(%ebp)
f01148bd:	68 7c 9a 12 f0       	push   $0xf0129a7c
f01148c2:	68 cb 06 00 00       	push   $0x6cb
f01148c7:	68 02 82 12 f0       	push   $0xf0128202
f01148cc:	e8 05 bc fe ff       	call   f01004d6 <_warn>
f01148d1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01148d4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01148d8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01148dc:	74 04                	je     f01148e2 <test_calculate_required_frames+0x7c1>
f01148de:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01148e2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01148e6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01148e9:	83 ec 04             	sub    $0x4,%esp
f01148ec:	50                   	push   %eax
f01148ed:	68 ff ff 3f 00       	push   $0x3fffff
f01148f2:	ff 75 d8             	pushl  -0x28(%ebp)
f01148f5:	e8 68 56 ff ff       	call   f0109f62 <calculate_required_frames>
f01148fa:	83 c4 10             	add    $0x10,%esp
f01148fd:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f0114900:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0114907:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011490a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011490d:	74 24                	je     f0114933 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011490f:	83 ec 0c             	sub    $0xc,%esp
f0114912:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114915:	ff 75 c8             	pushl  -0x38(%ebp)
f0114918:	68 7c 9a 12 f0       	push   $0xf0129a7c
f011491d:	68 d6 06 00 00       	push   $0x6d6
f0114922:	68 02 82 12 f0       	push   $0xf0128202
f0114927:	e8 aa bb fe ff       	call   f01004d6 <_warn>
f011492c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011492f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114933:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114937:	74 04                	je     f011493d <test_calculate_required_frames+0x81c>
f0114939:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011493d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0114941:	83 ec 0c             	sub    $0xc,%esp
f0114944:	68 8f 8b 12 f0       	push   $0xf0128b8f
f0114949:	e8 3d c6 fe ff       	call   f0100f8b <cprintf>
f011494e:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0114951:	83 ec 08             	sub    $0x8,%esp
f0114954:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114957:	68 28 9b 12 f0       	push   $0xf0129b28
f011495c:	e8 2a c6 fe ff       	call   f0100f8b <cprintf>
f0114961:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114964:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114968:	75 10                	jne    f011497a <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f011496a:	83 ec 0c             	sub    $0xc,%esp
f011496d:	68 68 9b 12 f0       	push   $0xf0129b68
f0114972:	e8 14 c6 fe ff       	call   f0100f8b <cprintf>
f0114977:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011497a:	a1 a4 4a 5f f0       	mov    0xf05f4aa4,%eax
f011497f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0114982:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0114985:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114988:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011498d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114990:	5b                   	pop    %ebx
f0114991:	5e                   	pop    %esi
f0114992:	5f                   	pop    %edi
f0114993:	5d                   	pop    %ebp
f0114994:	c3                   	ret    

f0114995 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0114995:	55                   	push   %ebp
f0114996:	89 e5                	mov    %esp,%ebp
f0114998:	57                   	push   %edi
f0114999:	56                   	push   %esi
f011499a:	53                   	push   %ebx
f011499b:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01149a1:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01149a4:	bb 04 89 12 f0       	mov    $0xf0128904,%ebx
f01149a9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01149ae:	89 c7                	mov    %eax,%edi
f01149b0:	89 de                	mov    %ebx,%esi
f01149b2:	89 d1                	mov    %edx,%ecx
f01149b4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01149b6:	8d 55 9d             	lea    -0x63(%ebp),%edx
f01149b9:	b9 23 00 00 00       	mov    $0x23,%ecx
f01149be:	b0 00                	mov    $0x0,%al
f01149c0:	89 d7                	mov    %edx,%edi
f01149c2:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01149c4:	6a 00                	push   $0x0
f01149c6:	6a 0a                	push   $0xa
f01149c8:	6a 14                	push   $0x14
f01149ca:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01149cd:	50                   	push   %eax
f01149ce:	e8 ba 57 ff ff       	call   f010a18d <env_create>
f01149d3:	83 c4 10             	add    $0x10,%esp
f01149d6:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01149d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01149dc:	8b 40 64             	mov    0x64(%eax),%eax
f01149df:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f01149e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01149e5:	8b 40 68             	mov    0x68(%eax),%eax
f01149e8:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01149eb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01149ee:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01149f1:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01149f8:	75 70 20 
f01149fb:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0114a02:	00 00 00 
f0114a05:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0114a08:	b9 03 00 00 00       	mov    $0x3,%ecx
f0114a0d:	b8 00 00 00 00       	mov    $0x0,%eax
f0114a12:	89 d7                	mov    %edx,%edi
f0114a14:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0114a16:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114a19:	8b 40 10             	mov    0x10(%eax),%eax
f0114a1c:	83 ec 08             	sub    $0x8,%esp
f0114a1f:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0114a25:	52                   	push   %edx
f0114a26:	50                   	push   %eax
f0114a27:	e8 c7 a5 00 00       	call   f011eff3 <ltostr>
f0114a2c:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0114a2f:	83 ec 04             	sub    $0x4,%esp
f0114a32:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114a38:	50                   	push   %eax
f0114a39:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0114a3f:	50                   	push   %eax
f0114a40:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0114a46:	50                   	push   %eax
f0114a47:	e8 80 a6 00 00       	call   f011f0cc <strcconcat>
f0114a4c:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114a4f:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0114a56:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0114a5d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0114a64:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0114a68:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114a6f:	00 00 00 
	uint32 num_tables = 0;
f0114a72:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114a79:	00 00 00 
	ClearUserSpace(proc_directory);
f0114a7c:	83 ec 0c             	sub    $0xc,%esp
f0114a7f:	ff 75 d8             	pushl  -0x28(%ebp)
f0114a82:	e8 8d 0e 00 00       	call   f0115914 <ClearUserSpace>
f0114a87:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0114a8a:	83 ec 0c             	sub    $0xc,%esp
f0114a8d:	68 48 9a 12 f0       	push   $0xf0129a48
f0114a92:	e8 f4 c4 fe ff       	call   f0100f8b <cprintf>
f0114a97:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0114a9a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114a9d:	c1 e0 03             	shl    $0x3,%eax
f0114aa0:	89 c2                	mov    %eax,%edx
f0114aa2:	83 ec 0c             	sub    $0xc,%esp
f0114aa5:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114aab:	50                   	push   %eax
f0114aac:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114ab2:	50                   	push   %eax
f0114ab3:	52                   	push   %edx
f0114ab4:	6a 00                	push   $0x0
f0114ab6:	ff 75 d8             	pushl  -0x28(%ebp)
f0114ab9:	e8 8a 54 ff ff       	call   f0109f48 <calculate_allocated_space>
f0114abe:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114ac1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114ac7:	85 c0                	test   %eax,%eax
f0114ac9:	74 27                	je     f0114af2 <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114acb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114ad1:	83 ec 0c             	sub    $0xc,%esp
f0114ad4:	6a 00                	push   $0x0
f0114ad6:	50                   	push   %eax
f0114ad7:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0114adc:	68 0b 07 00 00       	push   $0x70b
f0114ae1:	68 02 82 12 f0       	push   $0xf0128202
f0114ae6:	e8 eb b9 fe ff       	call   f01004d6 <_warn>
f0114aeb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114aee:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114af2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114af8:	85 c0                	test   %eax,%eax
f0114afa:	74 27                	je     f0114b23 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114afc:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114b02:	83 ec 0c             	sub    $0xc,%esp
f0114b05:	6a 00                	push   $0x0
f0114b07:	50                   	push   %eax
f0114b08:	68 14 9c 12 f0       	push   $0xf0129c14
f0114b0d:	68 10 07 00 00       	push   $0x710
f0114b12:	68 02 82 12 f0       	push   $0xf0128202
f0114b17:	e8 ba b9 fe ff       	call   f01004d6 <_warn>
f0114b1c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b1f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114b23:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b27:	74 04                	je     f0114b2d <test_calculate_allocated_space+0x198>
f0114b29:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114b2d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0114b31:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114b38:	00 00 00 
		num_pages = 0;
f0114b3b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114b42:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0114b45:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114b48:	c1 e0 02             	shl    $0x2,%eax
f0114b4b:	89 c2                	mov    %eax,%edx
f0114b4d:	83 ec 0c             	sub    $0xc,%esp
f0114b50:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114b56:	50                   	push   %eax
f0114b57:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114b5d:	50                   	push   %eax
f0114b5e:	52                   	push   %edx
f0114b5f:	6a 00                	push   $0x0
f0114b61:	ff 75 d8             	pushl  -0x28(%ebp)
f0114b64:	e8 df 53 ff ff       	call   f0109f48 <calculate_allocated_space>
f0114b69:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114b6c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114b72:	85 c0                	test   %eax,%eax
f0114b74:	74 27                	je     f0114b9d <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114b76:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114b7c:	83 ec 0c             	sub    $0xc,%esp
f0114b7f:	6a 00                	push   $0x0
f0114b81:	50                   	push   %eax
f0114b82:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0114b87:	68 1c 07 00 00       	push   $0x71c
f0114b8c:	68 02 82 12 f0       	push   $0xf0128202
f0114b91:	e8 40 b9 fe ff       	call   f01004d6 <_warn>
f0114b96:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b99:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114b9d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114ba3:	85 c0                	test   %eax,%eax
f0114ba5:	74 27                	je     f0114bce <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114ba7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114bad:	83 ec 0c             	sub    $0xc,%esp
f0114bb0:	6a 00                	push   $0x0
f0114bb2:	50                   	push   %eax
f0114bb3:	68 14 9c 12 f0       	push   $0xf0129c14
f0114bb8:	68 21 07 00 00       	push   $0x721
f0114bbd:	68 02 82 12 f0       	push   $0xf0128202
f0114bc2:	e8 0f b9 fe ff       	call   f01004d6 <_warn>
f0114bc7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114bca:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114bce:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114bd2:	74 04                	je     f0114bd8 <test_calculate_allocated_space+0x243>
f0114bd4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114bd8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0114bdc:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114be3:	00 00 00 
		num_pages = 0;
f0114be6:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114bed:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0114bf0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114bf3:	c1 e0 0a             	shl    $0xa,%eax
f0114bf6:	89 c2                	mov    %eax,%edx
f0114bf8:	83 ec 0c             	sub    $0xc,%esp
f0114bfb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114c01:	50                   	push   %eax
f0114c02:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114c08:	50                   	push   %eax
f0114c09:	52                   	push   %edx
f0114c0a:	6a 00                	push   $0x0
f0114c0c:	ff 75 d8             	pushl  -0x28(%ebp)
f0114c0f:	e8 34 53 ff ff       	call   f0109f48 <calculate_allocated_space>
f0114c14:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114c17:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114c1d:	85 c0                	test   %eax,%eax
f0114c1f:	74 27                	je     f0114c48 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114c21:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114c27:	83 ec 0c             	sub    $0xc,%esp
f0114c2a:	6a 00                	push   $0x0
f0114c2c:	50                   	push   %eax
f0114c2d:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0114c32:	68 2d 07 00 00       	push   $0x72d
f0114c37:	68 02 82 12 f0       	push   $0xf0128202
f0114c3c:	e8 95 b8 fe ff       	call   f01004d6 <_warn>
f0114c41:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114c44:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114c48:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114c4e:	85 c0                	test   %eax,%eax
f0114c50:	74 27                	je     f0114c79 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114c52:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114c58:	83 ec 0c             	sub    $0xc,%esp
f0114c5b:	6a 00                	push   $0x0
f0114c5d:	50                   	push   %eax
f0114c5e:	68 14 9c 12 f0       	push   $0xf0129c14
f0114c63:	68 32 07 00 00       	push   $0x732
f0114c68:	68 02 82 12 f0       	push   $0xf0128202
f0114c6d:	e8 64 b8 fe ff       	call   f01004d6 <_warn>
f0114c72:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114c75:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114c79:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c7d:	74 04                	je     f0114c83 <test_calculate_allocated_space+0x2ee>
f0114c7f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114c83:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0114c87:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114c8e:	00 00 00 
		num_pages = 0;
f0114c91:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114c98:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0114c9b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114c9e:	89 d0                	mov    %edx,%eax
f0114ca0:	01 c0                	add    %eax,%eax
f0114ca2:	01 d0                	add    %edx,%eax
f0114ca4:	01 c0                	add    %eax,%eax
f0114ca6:	05 00 10 00 00       	add    $0x1000,%eax
f0114cab:	89 c2                	mov    %eax,%edx
f0114cad:	83 ec 0c             	sub    $0xc,%esp
f0114cb0:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114cb6:	50                   	push   %eax
f0114cb7:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114cbd:	50                   	push   %eax
f0114cbe:	52                   	push   %edx
f0114cbf:	68 00 10 00 00       	push   $0x1000
f0114cc4:	ff 75 d8             	pushl  -0x28(%ebp)
f0114cc7:	e8 7c 52 ff ff       	call   f0109f48 <calculate_allocated_space>
f0114ccc:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114ccf:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114cd5:	85 c0                	test   %eax,%eax
f0114cd7:	74 27                	je     f0114d00 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114cd9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114cdf:	83 ec 0c             	sub    $0xc,%esp
f0114ce2:	6a 00                	push   $0x0
f0114ce4:	50                   	push   %eax
f0114ce5:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0114cea:	68 3f 07 00 00       	push   $0x73f
f0114cef:	68 02 82 12 f0       	push   $0xf0128202
f0114cf4:	e8 dd b7 fe ff       	call   f01004d6 <_warn>
f0114cf9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114cfc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114d00:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114d06:	85 c0                	test   %eax,%eax
f0114d08:	74 27                	je     f0114d31 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114d0a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114d10:	83 ec 0c             	sub    $0xc,%esp
f0114d13:	6a 00                	push   $0x0
f0114d15:	50                   	push   %eax
f0114d16:	68 14 9c 12 f0       	push   $0xf0129c14
f0114d1b:	68 44 07 00 00       	push   $0x744
f0114d20:	68 02 82 12 f0       	push   $0xf0128202
f0114d25:	e8 ac b7 fe ff       	call   f01004d6 <_warn>
f0114d2a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d2d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114d31:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d35:	74 04                	je     f0114d3b <test_calculate_allocated_space+0x3a6>
f0114d37:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d3b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0114d3f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114d46:	00 00 00 
		num_pages = 0;
f0114d49:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114d50:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0114d53:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114d56:	89 c2                	mov    %eax,%edx
f0114d58:	01 d2                	add    %edx,%edx
f0114d5a:	01 d0                	add    %edx,%eax
f0114d5c:	05 00 18 00 00       	add    $0x1800,%eax
f0114d61:	89 c2                	mov    %eax,%edx
f0114d63:	83 ec 0c             	sub    $0xc,%esp
f0114d66:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114d6c:	50                   	push   %eax
f0114d6d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114d73:	50                   	push   %eax
f0114d74:	52                   	push   %edx
f0114d75:	68 00 18 00 00       	push   $0x1800
f0114d7a:	ff 75 d8             	pushl  -0x28(%ebp)
f0114d7d:	e8 c6 51 ff ff       	call   f0109f48 <calculate_allocated_space>
f0114d82:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114d85:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114d8b:	85 c0                	test   %eax,%eax
f0114d8d:	74 27                	je     f0114db6 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114d8f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114d95:	83 ec 0c             	sub    $0xc,%esp
f0114d98:	6a 00                	push   $0x0
f0114d9a:	50                   	push   %eax
f0114d9b:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0114da0:	68 50 07 00 00       	push   $0x750
f0114da5:	68 02 82 12 f0       	push   $0xf0128202
f0114daa:	e8 27 b7 fe ff       	call   f01004d6 <_warn>
f0114daf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114db2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114db6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114dbc:	85 c0                	test   %eax,%eax
f0114dbe:	74 27                	je     f0114de7 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114dc0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114dc6:	83 ec 0c             	sub    $0xc,%esp
f0114dc9:	6a 00                	push   $0x0
f0114dcb:	50                   	push   %eax
f0114dcc:	68 14 9c 12 f0       	push   $0xf0129c14
f0114dd1:	68 55 07 00 00       	push   $0x755
f0114dd6:	68 02 82 12 f0       	push   $0xf0128202
f0114ddb:	e8 f6 b6 fe ff       	call   f01004d6 <_warn>
f0114de0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114de3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114de7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114deb:	74 04                	je     f0114df1 <test_calculate_allocated_space+0x45c>
f0114ded:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114df1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0114df5:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114dfc:	00 00 00 
		num_pages = 0;
f0114dff:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114e06:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0114e09:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114e0c:	89 d0                	mov    %edx,%eax
f0114e0e:	c1 e0 02             	shl    $0x2,%eax
f0114e11:	01 d0                	add    %edx,%eax
f0114e13:	01 c0                	add    %eax,%eax
f0114e15:	05 00 00 40 00       	add    $0x400000,%eax
f0114e1a:	89 c2                	mov    %eax,%edx
f0114e1c:	83 ec 0c             	sub    $0xc,%esp
f0114e1f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114e25:	50                   	push   %eax
f0114e26:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114e2c:	50                   	push   %eax
f0114e2d:	52                   	push   %edx
f0114e2e:	68 00 00 40 00       	push   $0x400000
f0114e33:	ff 75 d8             	pushl  -0x28(%ebp)
f0114e36:	e8 0d 51 ff ff       	call   f0109f48 <calculate_allocated_space>
f0114e3b:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114e3e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114e44:	85 c0                	test   %eax,%eax
f0114e46:	74 27                	je     f0114e6f <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114e48:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114e4e:	83 ec 0c             	sub    $0xc,%esp
f0114e51:	6a 00                	push   $0x0
f0114e53:	50                   	push   %eax
f0114e54:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0114e59:	68 61 07 00 00       	push   $0x761
f0114e5e:	68 02 82 12 f0       	push   $0xf0128202
f0114e63:	e8 6e b6 fe ff       	call   f01004d6 <_warn>
f0114e68:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e6b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114e6f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114e75:	85 c0                	test   %eax,%eax
f0114e77:	74 27                	je     f0114ea0 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114e79:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114e7f:	83 ec 0c             	sub    $0xc,%esp
f0114e82:	6a 00                	push   $0x0
f0114e84:	50                   	push   %eax
f0114e85:	68 14 9c 12 f0       	push   $0xf0129c14
f0114e8a:	68 66 07 00 00       	push   $0x766
f0114e8f:	68 02 82 12 f0       	push   $0xf0128202
f0114e94:	e8 3d b6 fe ff       	call   f01004d6 <_warn>
f0114e99:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e9c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ea0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ea4:	74 04                	je     f0114eaa <test_calculate_allocated_space+0x515>
f0114ea6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114eaa:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0114eae:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114eb5:	00 00 00 
		num_pages = 0;
f0114eb8:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114ebf:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0114ec2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114ec5:	05 00 00 38 00       	add    $0x380000,%eax
f0114eca:	01 c0                	add    %eax,%eax
f0114ecc:	89 c2                	mov    %eax,%edx
f0114ece:	83 ec 0c             	sub    $0xc,%esp
f0114ed1:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114ed7:	50                   	push   %eax
f0114ed8:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114ede:	50                   	push   %eax
f0114edf:	52                   	push   %edx
f0114ee0:	68 00 00 70 00       	push   $0x700000
f0114ee5:	ff 75 d8             	pushl  -0x28(%ebp)
f0114ee8:	e8 5b 50 ff ff       	call   f0109f48 <calculate_allocated_space>
f0114eed:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114ef0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114ef6:	85 c0                	test   %eax,%eax
f0114ef8:	74 27                	je     f0114f21 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114efa:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114f00:	83 ec 0c             	sub    $0xc,%esp
f0114f03:	6a 00                	push   $0x0
f0114f05:	50                   	push   %eax
f0114f06:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0114f0b:	68 73 07 00 00       	push   $0x773
f0114f10:	68 02 82 12 f0       	push   $0xf0128202
f0114f15:	e8 bc b5 fe ff       	call   f01004d6 <_warn>
f0114f1a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f1d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114f21:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114f27:	85 c0                	test   %eax,%eax
f0114f29:	74 27                	je     f0114f52 <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114f2b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114f31:	83 ec 0c             	sub    $0xc,%esp
f0114f34:	6a 00                	push   $0x0
f0114f36:	50                   	push   %eax
f0114f37:	68 14 9c 12 f0       	push   $0xf0129c14
f0114f3c:	68 78 07 00 00       	push   $0x778
f0114f41:	68 02 82 12 f0       	push   $0xf0128202
f0114f46:	e8 8b b5 fe ff       	call   f01004d6 <_warn>
f0114f4b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f4e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114f52:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114f56:	74 04                	je     f0114f5c <test_calculate_allocated_space+0x5c7>
f0114f58:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114f5c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0114f60:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114f67:	00 00 00 
		num_pages = 0;
f0114f6a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114f71:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0114f74:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114f77:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0114f7c:	89 c2                	mov    %eax,%edx
f0114f7e:	83 ec 0c             	sub    $0xc,%esp
f0114f81:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114f87:	50                   	push   %eax
f0114f88:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114f8e:	50                   	push   %eax
f0114f8f:	52                   	push   %edx
f0114f90:	68 ff ff 3f 00       	push   $0x3fffff
f0114f95:	ff 75 d8             	pushl  -0x28(%ebp)
f0114f98:	e8 ab 4f ff ff       	call   f0109f48 <calculate_allocated_space>
f0114f9d:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114fa0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114fa6:	85 c0                	test   %eax,%eax
f0114fa8:	74 27                	je     f0114fd1 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114faa:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114fb0:	83 ec 0c             	sub    $0xc,%esp
f0114fb3:	6a 00                	push   $0x0
f0114fb5:	50                   	push   %eax
f0114fb6:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0114fbb:	68 84 07 00 00       	push   $0x784
f0114fc0:	68 02 82 12 f0       	push   $0xf0128202
f0114fc5:	e8 0c b5 fe ff       	call   f01004d6 <_warn>
f0114fca:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114fcd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114fd1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114fd7:	85 c0                	test   %eax,%eax
f0114fd9:	74 27                	je     f0115002 <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114fdb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114fe1:	83 ec 0c             	sub    $0xc,%esp
f0114fe4:	6a 00                	push   $0x0
f0114fe6:	50                   	push   %eax
f0114fe7:	68 14 9c 12 f0       	push   $0xf0129c14
f0114fec:	68 89 07 00 00       	push   $0x789
f0114ff1:	68 02 82 12 f0       	push   $0xf0128202
f0114ff6:	e8 db b4 fe ff       	call   f01004d6 <_warn>
f0114ffb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ffe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115002:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115006:	74 04                	je     f011500c <test_calculate_allocated_space+0x677>
f0115008:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011500c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115010:	83 ec 0c             	sub    $0xc,%esp
f0115013:	68 b5 95 12 f0       	push   $0xf01295b5
f0115018:	e8 6e bf fe ff       	call   f0100f8b <cprintf>
f011501d:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115020:	83 ec 0c             	sub    $0xc,%esp
f0115023:	68 d4 9a 12 f0       	push   $0xf0129ad4
f0115028:	e8 5e bf fe ff       	call   f0100f8b <cprintf>
f011502d:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115030:	83 ec 04             	sub    $0x4,%esp
f0115033:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115039:	50                   	push   %eax
f011503a:	68 6e 89 12 f0       	push   $0xf012896e
f011503f:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115045:	50                   	push   %eax
f0115046:	e8 81 a0 00 00       	call   f011f0cc <strcconcat>
f011504b:	83 c4 10             	add    $0x10,%esp
f011504e:	83 ec 0c             	sub    $0xc,%esp
f0115051:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115057:	50                   	push   %eax
f0115058:	e8 9e ce fe ff       	call   f0101efb <execute_command>
f011505d:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0115060:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115067:	00 00 00 
		num_pages = 0;
f011506a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115071:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115074:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115077:	c1 e0 03             	shl    $0x3,%eax
f011507a:	89 c2                	mov    %eax,%edx
f011507c:	83 ec 0c             	sub    $0xc,%esp
f011507f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115085:	50                   	push   %eax
f0115086:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011508c:	50                   	push   %eax
f011508d:	52                   	push   %edx
f011508e:	6a 00                	push   $0x0
f0115090:	ff 75 d8             	pushl  -0x28(%ebp)
f0115093:	e8 b0 4e ff ff       	call   f0109f48 <calculate_allocated_space>
f0115098:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f011509b:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f01150a2:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01150a9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01150af:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01150b2:	74 28                	je     f01150dc <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01150b4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01150ba:	83 ec 0c             	sub    $0xc,%esp
f01150bd:	ff 75 c8             	pushl  -0x38(%ebp)
f01150c0:	50                   	push   %eax
f01150c1:	68 b4 9b 12 f0       	push   $0xf0129bb4
f01150c6:	68 a0 07 00 00       	push   $0x7a0
f01150cb:	68 02 82 12 f0       	push   $0xf0128202
f01150d0:	e8 01 b4 fe ff       	call   f01004d6 <_warn>
f01150d5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01150d8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01150dc:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01150e2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01150e5:	74 28                	je     f011510f <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01150e7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01150ed:	83 ec 0c             	sub    $0xc,%esp
f01150f0:	ff 75 c4             	pushl  -0x3c(%ebp)
f01150f3:	50                   	push   %eax
f01150f4:	68 14 9c 12 f0       	push   $0xf0129c14
f01150f9:	68 a5 07 00 00       	push   $0x7a5
f01150fe:	68 02 82 12 f0       	push   $0xf0128202
f0115103:	e8 ce b3 fe ff       	call   f01004d6 <_warn>
f0115108:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011510b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011510f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115113:	74 04                	je     f0115119 <test_calculate_allocated_space+0x784>
f0115115:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115119:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f011511d:	83 ec 04             	sub    $0x4,%esp
f0115120:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115126:	50                   	push   %eax
f0115127:	68 7b 89 12 f0       	push   $0xf012897b
f011512c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115132:	50                   	push   %eax
f0115133:	e8 94 9f 00 00       	call   f011f0cc <strcconcat>
f0115138:	83 c4 10             	add    $0x10,%esp
f011513b:	83 ec 0c             	sub    $0xc,%esp
f011513e:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115144:	50                   	push   %eax
f0115145:	e8 b1 cd fe ff       	call   f0101efb <execute_command>
f011514a:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f011514d:	83 ec 04             	sub    $0x4,%esp
f0115150:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115156:	50                   	push   %eax
f0115157:	68 08 9b 12 f0       	push   $0xf0129b08
f011515c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115162:	50                   	push   %eax
f0115163:	e8 64 9f 00 00       	call   f011f0cc <strcconcat>
f0115168:	83 c4 10             	add    $0x10,%esp
f011516b:	83 ec 0c             	sub    $0xc,%esp
f011516e:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115174:	50                   	push   %eax
f0115175:	e8 81 cd fe ff       	call   f0101efb <execute_command>
f011517a:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f011517d:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115184:	00 00 00 
		num_pages = 0;
f0115187:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011518e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0115191:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115194:	c1 e0 03             	shl    $0x3,%eax
f0115197:	89 c2                	mov    %eax,%edx
f0115199:	83 ec 0c             	sub    $0xc,%esp
f011519c:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01151a2:	50                   	push   %eax
f01151a3:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01151a9:	50                   	push   %eax
f01151aa:	52                   	push   %edx
f01151ab:	6a 00                	push   $0x0
f01151ad:	ff 75 d8             	pushl  -0x28(%ebp)
f01151b0:	e8 93 4d ff ff       	call   f0109f48 <calculate_allocated_space>
f01151b5:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01151b8:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f01151bf:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01151c6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01151cc:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01151cf:	74 28                	je     f01151f9 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01151d1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01151d7:	83 ec 0c             	sub    $0xc,%esp
f01151da:	ff 75 c8             	pushl  -0x38(%ebp)
f01151dd:	50                   	push   %eax
f01151de:	68 b4 9b 12 f0       	push   $0xf0129bb4
f01151e3:	68 b6 07 00 00       	push   $0x7b6
f01151e8:	68 02 82 12 f0       	push   $0xf0128202
f01151ed:	e8 e4 b2 fe ff       	call   f01004d6 <_warn>
f01151f2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01151f5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01151f9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01151ff:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115202:	74 28                	je     f011522c <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115204:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011520a:	83 ec 0c             	sub    $0xc,%esp
f011520d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115210:	50                   	push   %eax
f0115211:	68 14 9c 12 f0       	push   $0xf0129c14
f0115216:	68 bb 07 00 00       	push   $0x7bb
f011521b:	68 02 82 12 f0       	push   $0xf0128202
f0115220:	e8 b1 b2 fe ff       	call   f01004d6 <_warn>
f0115225:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115228:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011522c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115230:	74 04                	je     f0115236 <test_calculate_allocated_space+0x8a1>
f0115232:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115236:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f011523a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115241:	00 00 00 
		num_pages = 0;
f0115244:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011524b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011524e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115251:	c1 e0 0a             	shl    $0xa,%eax
f0115254:	89 c2                	mov    %eax,%edx
f0115256:	83 ec 0c             	sub    $0xc,%esp
f0115259:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011525f:	50                   	push   %eax
f0115260:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115266:	50                   	push   %eax
f0115267:	52                   	push   %edx
f0115268:	6a 00                	push   $0x0
f011526a:	ff 75 d8             	pushl  -0x28(%ebp)
f011526d:	e8 d6 4c ff ff       	call   f0109f48 <calculate_allocated_space>
f0115272:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0115275:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f011527c:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115283:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115289:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011528c:	74 28                	je     f01152b6 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011528e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115294:	83 ec 0c             	sub    $0xc,%esp
f0115297:	ff 75 c8             	pushl  -0x38(%ebp)
f011529a:	50                   	push   %eax
f011529b:	68 b4 9b 12 f0       	push   $0xf0129bb4
f01152a0:	68 c9 07 00 00       	push   $0x7c9
f01152a5:	68 02 82 12 f0       	push   $0xf0128202
f01152aa:	e8 27 b2 fe ff       	call   f01004d6 <_warn>
f01152af:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152b2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01152b6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01152bc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01152bf:	74 28                	je     f01152e9 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01152c1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01152c7:	83 ec 0c             	sub    $0xc,%esp
f01152ca:	ff 75 c4             	pushl  -0x3c(%ebp)
f01152cd:	50                   	push   %eax
f01152ce:	68 14 9c 12 f0       	push   $0xf0129c14
f01152d3:	68 ce 07 00 00       	push   $0x7ce
f01152d8:	68 02 82 12 f0       	push   $0xf0128202
f01152dd:	e8 f4 b1 fe ff       	call   f01004d6 <_warn>
f01152e2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152e5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01152e9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01152ed:	74 04                	je     f01152f3 <test_calculate_allocated_space+0x95e>
f01152ef:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01152f3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01152f7:	83 ec 04             	sub    $0x4,%esp
f01152fa:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115300:	50                   	push   %eax
f0115301:	68 14 9b 12 f0       	push   $0xf0129b14
f0115306:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011530c:	50                   	push   %eax
f011530d:	e8 ba 9d 00 00       	call   f011f0cc <strcconcat>
f0115312:	83 c4 10             	add    $0x10,%esp
f0115315:	83 ec 0c             	sub    $0xc,%esp
f0115318:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011531e:	50                   	push   %eax
f011531f:	e8 d7 cb fe ff       	call   f0101efb <execute_command>
f0115324:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0115327:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011532e:	00 00 00 
		num_pages = 0;
f0115331:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115338:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f011533b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011533e:	89 c2                	mov    %eax,%edx
f0115340:	01 d2                	add    %edx,%edx
f0115342:	01 d0                	add    %edx,%eax
f0115344:	05 00 18 00 00       	add    $0x1800,%eax
f0115349:	89 c2                	mov    %eax,%edx
f011534b:	83 ec 0c             	sub    $0xc,%esp
f011534e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115354:	50                   	push   %eax
f0115355:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011535b:	50                   	push   %eax
f011535c:	52                   	push   %edx
f011535d:	68 00 18 00 00       	push   $0x1800
f0115362:	ff 75 d8             	pushl  -0x28(%ebp)
f0115365:	e8 de 4b ff ff       	call   f0109f48 <calculate_allocated_space>
f011536a:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011536d:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0115374:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011537b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115381:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115384:	74 28                	je     f01153ae <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115386:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011538c:	83 ec 0c             	sub    $0xc,%esp
f011538f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115392:	50                   	push   %eax
f0115393:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0115398:	68 df 07 00 00       	push   $0x7df
f011539d:	68 02 82 12 f0       	push   $0xf0128202
f01153a2:	e8 2f b1 fe ff       	call   f01004d6 <_warn>
f01153a7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153aa:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01153ae:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01153b4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01153b7:	74 28                	je     f01153e1 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01153b9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01153bf:	83 ec 0c             	sub    $0xc,%esp
f01153c2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01153c5:	50                   	push   %eax
f01153c6:	68 14 9c 12 f0       	push   $0xf0129c14
f01153cb:	68 e4 07 00 00       	push   $0x7e4
f01153d0:	68 02 82 12 f0       	push   $0xf0128202
f01153d5:	e8 fc b0 fe ff       	call   f01004d6 <_warn>
f01153da:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153dd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01153e1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01153e5:	74 04                	je     f01153eb <test_calculate_allocated_space+0xa56>
f01153e7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01153eb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f01153ef:	83 ec 04             	sub    $0x4,%esp
f01153f2:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01153f8:	50                   	push   %eax
f01153f9:	68 d4 8b 12 f0       	push   $0xf0128bd4
f01153fe:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115404:	50                   	push   %eax
f0115405:	e8 c2 9c 00 00       	call   f011f0cc <strcconcat>
f011540a:	83 c4 10             	add    $0x10,%esp
f011540d:	83 ec 0c             	sub    $0xc,%esp
f0115410:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115416:	50                   	push   %eax
f0115417:	e8 df ca fe ff       	call   f0101efb <execute_command>
f011541c:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f011541f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115426:	00 00 00 
		num_pages = 0;
f0115429:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115430:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115433:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115436:	89 d0                	mov    %edx,%eax
f0115438:	c1 e0 02             	shl    $0x2,%eax
f011543b:	01 d0                	add    %edx,%eax
f011543d:	01 c0                	add    %eax,%eax
f011543f:	05 00 00 40 00       	add    $0x400000,%eax
f0115444:	89 c2                	mov    %eax,%edx
f0115446:	83 ec 0c             	sub    $0xc,%esp
f0115449:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011544f:	50                   	push   %eax
f0115450:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115456:	50                   	push   %eax
f0115457:	52                   	push   %edx
f0115458:	68 00 00 40 00       	push   $0x400000
f011545d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115460:	e8 e3 4a ff ff       	call   f0109f48 <calculate_allocated_space>
f0115465:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115468:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011546f:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115476:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011547c:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011547f:	74 28                	je     f01154a9 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115481:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115487:	83 ec 0c             	sub    $0xc,%esp
f011548a:	ff 75 c8             	pushl  -0x38(%ebp)
f011548d:	50                   	push   %eax
f011548e:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0115493:	68 f4 07 00 00       	push   $0x7f4
f0115498:	68 02 82 12 f0       	push   $0xf0128202
f011549d:	e8 34 b0 fe ff       	call   f01004d6 <_warn>
f01154a2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154a5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01154a9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01154af:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01154b2:	74 28                	je     f01154dc <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01154b4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01154ba:	83 ec 0c             	sub    $0xc,%esp
f01154bd:	ff 75 c4             	pushl  -0x3c(%ebp)
f01154c0:	50                   	push   %eax
f01154c1:	68 14 9c 12 f0       	push   $0xf0129c14
f01154c6:	68 f9 07 00 00       	push   $0x7f9
f01154cb:	68 02 82 12 f0       	push   $0xf0128202
f01154d0:	e8 01 b0 fe ff       	call   f01004d6 <_warn>
f01154d5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154d8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01154dc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01154e0:	74 04                	je     f01154e6 <test_calculate_allocated_space+0xb51>
f01154e2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01154e6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01154ea:	83 ec 04             	sub    $0x4,%esp
f01154ed:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01154f3:	50                   	push   %eax
f01154f4:	68 de 8b 12 f0       	push   $0xf0128bde
f01154f9:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01154ff:	50                   	push   %eax
f0115500:	e8 c7 9b 00 00       	call   f011f0cc <strcconcat>
f0115505:	83 c4 10             	add    $0x10,%esp
f0115508:	83 ec 0c             	sub    $0xc,%esp
f011550b:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115511:	50                   	push   %eax
f0115512:	e8 e4 c9 fe ff       	call   f0101efb <execute_command>
f0115517:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f011551a:	83 ec 04             	sub    $0x4,%esp
f011551d:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115523:	50                   	push   %eax
f0115524:	68 1c 9b 12 f0       	push   $0xf0129b1c
f0115529:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011552f:	50                   	push   %eax
f0115530:	e8 97 9b 00 00       	call   f011f0cc <strcconcat>
f0115535:	83 c4 10             	add    $0x10,%esp
f0115538:	83 ec 0c             	sub    $0xc,%esp
f011553b:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115541:	50                   	push   %eax
f0115542:	e8 b4 c9 fe ff       	call   f0101efb <execute_command>
f0115547:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f011554a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115551:	00 00 00 
		num_pages = 0;
f0115554:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011555b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f011555e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115561:	05 00 00 38 00       	add    $0x380000,%eax
f0115566:	01 c0                	add    %eax,%eax
f0115568:	89 c2                	mov    %eax,%edx
f011556a:	83 ec 0c             	sub    $0xc,%esp
f011556d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115573:	50                   	push   %eax
f0115574:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011557a:	50                   	push   %eax
f011557b:	52                   	push   %edx
f011557c:	68 00 00 70 00       	push   $0x700000
f0115581:	ff 75 d8             	pushl  -0x28(%ebp)
f0115584:	e8 bf 49 ff ff       	call   f0109f48 <calculate_allocated_space>
f0115589:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011558c:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0115593:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011559a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01155a0:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01155a3:	74 28                	je     f01155cd <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01155a5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01155ab:	83 ec 0c             	sub    $0xc,%esp
f01155ae:	ff 75 c8             	pushl  -0x38(%ebp)
f01155b1:	50                   	push   %eax
f01155b2:	68 b4 9b 12 f0       	push   $0xf0129bb4
f01155b7:	68 0b 08 00 00       	push   $0x80b
f01155bc:	68 02 82 12 f0       	push   $0xf0128202
f01155c1:	e8 10 af fe ff       	call   f01004d6 <_warn>
f01155c6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155c9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01155cd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01155d3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01155d6:	74 28                	je     f0115600 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01155d8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01155de:	83 ec 0c             	sub    $0xc,%esp
f01155e1:	ff 75 c4             	pushl  -0x3c(%ebp)
f01155e4:	50                   	push   %eax
f01155e5:	68 14 9c 12 f0       	push   $0xf0129c14
f01155ea:	68 10 08 00 00       	push   $0x810
f01155ef:	68 02 82 12 f0       	push   $0xf0128202
f01155f4:	e8 dd ae fe ff       	call   f01004d6 <_warn>
f01155f9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155fc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115600:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115604:	74 04                	je     f011560a <test_calculate_allocated_space+0xc75>
f0115606:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011560a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f011560e:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115615:	00 00 00 
		num_pages = 0;
f0115618:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011561f:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0115622:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115625:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f011562a:	89 c2                	mov    %eax,%edx
f011562c:	83 ec 0c             	sub    $0xc,%esp
f011562f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115635:	50                   	push   %eax
f0115636:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011563c:	50                   	push   %eax
f011563d:	52                   	push   %edx
f011563e:	68 ff ff 3f 00       	push   $0x3fffff
f0115643:	ff 75 d8             	pushl  -0x28(%ebp)
f0115646:	e8 fd 48 ff ff       	call   f0109f48 <calculate_allocated_space>
f011564b:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011564e:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0115655:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011565c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115662:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115665:	74 28                	je     f011568f <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115667:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011566d:	83 ec 0c             	sub    $0xc,%esp
f0115670:	ff 75 c8             	pushl  -0x38(%ebp)
f0115673:	50                   	push   %eax
f0115674:	68 b4 9b 12 f0       	push   $0xf0129bb4
f0115679:	68 1e 08 00 00       	push   $0x81e
f011567e:	68 02 82 12 f0       	push   $0xf0128202
f0115683:	e8 4e ae fe ff       	call   f01004d6 <_warn>
f0115688:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011568b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011568f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115695:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115698:	74 28                	je     f01156c2 <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011569a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01156a0:	83 ec 0c             	sub    $0xc,%esp
f01156a3:	ff 75 c4             	pushl  -0x3c(%ebp)
f01156a6:	50                   	push   %eax
f01156a7:	68 14 9c 12 f0       	push   $0xf0129c14
f01156ac:	68 23 08 00 00       	push   $0x823
f01156b1:	68 02 82 12 f0       	push   $0xf0128202
f01156b6:	e8 1b ae fe ff       	call   f01004d6 <_warn>
f01156bb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156be:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01156c2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01156c6:	74 04                	je     f01156cc <test_calculate_allocated_space+0xd37>
f01156c8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01156cc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01156d0:	83 ec 0c             	sub    $0xc,%esp
f01156d3:	68 8f 8b 12 f0       	push   $0xf0128b8f
f01156d8:	e8 ae b8 fe ff       	call   f0100f8b <cprintf>
f01156dd:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f01156e0:	83 ec 08             	sub    $0x8,%esp
f01156e3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01156e6:	68 70 9c 12 f0       	push   $0xf0129c70
f01156eb:	e8 9b b8 fe ff       	call   f0100f8b <cprintf>
f01156f0:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01156f3:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01156f7:	75 10                	jne    f0115709 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f01156f9:	83 ec 0c             	sub    $0xc,%esp
f01156fc:	68 b0 9c 12 f0       	push   $0xf0129cb0
f0115701:	e8 85 b8 fe ff       	call   f0100f8b <cprintf>
f0115706:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115709:	a1 a4 4a 5f f0       	mov    0xf05f4aa4,%eax
f011570e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115711:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115714:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115717:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011571c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011571f:	5b                   	pop    %ebx
f0115720:	5e                   	pop    %esi
f0115721:	5f                   	pop    %edi
f0115722:	5d                   	pop    %ebp
f0115723:	c3                   	ret    

f0115724 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0115724:	55                   	push   %ebp
f0115725:	89 e5                	mov    %esp,%ebp
f0115727:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f011572a:	8b 45 10             	mov    0x10(%ebp),%eax
f011572d:	ba 01 00 00 00       	mov    $0x1,%edx
f0115732:	88 c1                	mov    %al,%cl
f0115734:	d3 e2                	shl    %cl,%edx
f0115736:	89 d0                	mov    %edx,%eax
f0115738:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011573b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011573e:	c1 e8 16             	shr    $0x16,%eax
f0115741:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115748:	8b 45 08             	mov    0x8(%ebp),%eax
f011574b:	01 d0                	add    %edx,%eax
f011574d:	8b 00                	mov    (%eax),%eax
f011574f:	83 e0 01             	and    $0x1,%eax
f0115752:	85 c0                	test   %eax,%eax
f0115754:	75 07                	jne    f011575d <CB+0x39>
f0115756:	b8 00 00 00 00       	mov    $0x0,%eax
f011575b:	eb 76                	jmp    f01157d3 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011575d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115760:	c1 e8 16             	shr    $0x16,%eax
f0115763:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011576a:	8b 45 08             	mov    0x8(%ebp),%eax
f011576d:	01 d0                	add    %edx,%eax
f011576f:	8b 00                	mov    (%eax),%eax
f0115771:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0115776:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0115779:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011577c:	c1 e8 0c             	shr    $0xc,%eax
f011577f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0115782:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f0115787:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011578a:	72 17                	jb     f01157a3 <CB+0x7f>
f011578c:	ff 75 f0             	pushl  -0x10(%ebp)
f011578f:	68 fc 9c 12 f0       	push   $0xf0129cfc
f0115794:	68 3e 08 00 00       	push   $0x83e
f0115799:	68 02 82 12 f0       	push   $0xf0128202
f011579e:	e8 96 ab fe ff       	call   f0100339 <_panic>
f01157a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01157a6:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01157ab:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f01157ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01157b1:	c1 e8 0c             	shr    $0xc,%eax
f01157b4:	25 ff 03 00 00       	and    $0x3ff,%eax
f01157b9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01157c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01157c3:	01 d0                	add    %edx,%eax
f01157c5:	8b 00                	mov    (%eax),%eax
f01157c7:	23 45 f4             	and    -0xc(%ebp),%eax
f01157ca:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01157cd:	0f 94 c0             	sete   %al
f01157d0:	0f b6 c0             	movzbl %al,%eax
}
f01157d3:	c9                   	leave  
f01157d4:	c3                   	ret    

f01157d5 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f01157d5:	55                   	push   %ebp
f01157d6:	89 e5                	mov    %esp,%ebp
f01157d8:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01157db:	68 2b 9d 12 f0       	push   $0xf0129d2b
f01157e0:	68 3a 9d 12 f0       	push   $0xf0129d3a
f01157e5:	68 43 08 00 00       	push   $0x843
f01157ea:	68 02 82 12 f0       	push   $0xf0128202
f01157ef:	e8 45 ab fe ff       	call   f0100339 <_panic>

f01157f4 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f01157f4:	55                   	push   %ebp
f01157f5:	89 e5                	mov    %esp,%ebp
f01157f7:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01157fa:	68 2b 9d 12 f0       	push   $0xf0129d2b
f01157ff:	68 3a 9d 12 f0       	push   $0xf0129d3a
f0115804:	68 4d 08 00 00       	push   $0x84d
f0115809:	68 02 82 12 f0       	push   $0xf0128202
f011580e:	e8 26 ab fe ff       	call   f0100339 <_panic>

f0115813 <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f0115813:	55                   	push   %ebp
f0115814:	89 e5                	mov    %esp,%ebp
f0115816:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0115819:	68 2b 9d 12 f0       	push   $0xf0129d2b
f011581e:	68 3a 9d 12 f0       	push   $0xf0129d3a
f0115823:	68 5c 08 00 00       	push   $0x85c
f0115828:	68 02 82 12 f0       	push   $0xf0128202
f011582d:	e8 07 ab fe ff       	call   f0100339 <_panic>

f0115832 <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f0115832:	55                   	push   %ebp
f0115833:	89 e5                	mov    %esp,%ebp
f0115835:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0115838:	8b 45 0c             	mov    0xc(%ebp),%eax
f011583b:	c1 e8 16             	shr    $0x16,%eax
f011583e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115845:	8b 45 08             	mov    0x8(%ebp),%eax
f0115848:	01 d0                	add    %edx,%eax
f011584a:	8b 00                	mov    (%eax),%eax
f011584c:	83 e0 01             	and    $0x1,%eax
f011584f:	85 c0                	test   %eax,%eax
f0115851:	75 07                	jne    f011585a <CE+0x28>
f0115853:	b8 00 00 00 00       	mov    $0x0,%eax
f0115858:	eb 7a                	jmp    f01158d4 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011585a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011585d:	c1 e8 16             	shr    $0x16,%eax
f0115860:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115867:	8b 45 08             	mov    0x8(%ebp),%eax
f011586a:	01 d0                	add    %edx,%eax
f011586c:	8b 00                	mov    (%eax),%eax
f011586e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0115873:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0115876:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0115879:	c1 e8 0c             	shr    $0xc,%eax
f011587c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011587f:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f0115884:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0115887:	72 17                	jb     f01158a0 <CE+0x6e>
f0115889:	ff 75 f4             	pushl  -0xc(%ebp)
f011588c:	68 fc 9c 12 f0       	push   $0xf0129cfc
f0115891:	68 65 08 00 00       	push   $0x865
f0115896:	68 02 82 12 f0       	push   $0xf0128202
f011589b:	e8 99 aa fe ff       	call   f0100339 <_panic>
f01158a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01158a3:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01158a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f01158ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f01158ae:	c1 e8 0c             	shr    $0xc,%eax
f01158b1:	25 ff 03 00 00       	and    $0x3ff,%eax
f01158b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01158bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01158c0:	01 d0                	add    %edx,%eax
f01158c2:	8b 00                	mov    (%eax),%eax
f01158c4:	85 c0                	test   %eax,%eax
f01158c6:	74 07                	je     f01158cf <CE+0x9d>
f01158c8:	b8 00 00 00 00       	mov    $0x0,%eax
f01158cd:	eb 05                	jmp    f01158d4 <CE+0xa2>
	return 1;
f01158cf:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01158d4:	c9                   	leave  
f01158d5:	c3                   	ret    

f01158d6 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f01158d6:	55                   	push   %ebp
f01158d7:	89 e5                	mov    %esp,%ebp
f01158d9:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01158dc:	68 2b 9d 12 f0       	push   $0xf0129d2b
f01158e1:	68 3a 9d 12 f0       	push   $0xf0129d3a
f01158e6:	68 6c 08 00 00       	push   $0x86c
f01158eb:	68 02 82 12 f0       	push   $0xf0128202
f01158f0:	e8 44 aa fe ff       	call   f0100339 <_panic>

f01158f5 <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f01158f5:	55                   	push   %ebp
f01158f6:	89 e5                	mov    %esp,%ebp
f01158f8:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01158fb:	68 2b 9d 12 f0       	push   $0xf0129d2b
f0115900:	68 3a 9d 12 f0       	push   $0xf0129d3a
f0115905:	68 7c 08 00 00       	push   $0x87c
f011590a:	68 02 82 12 f0       	push   $0xf0128202
f011590f:	e8 25 aa fe ff       	call   f0100339 <_panic>

f0115914 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f0115914:	55                   	push   %ebp
f0115915:	89 e5                	mov    %esp,%ebp
f0115917:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f011591a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0115921:	eb 18                	jmp    f011593b <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0115923:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0115926:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011592d:	8b 45 08             	mov    0x8(%ebp),%eax
f0115930:	01 d0                	add    %edx,%eax
f0115932:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0115938:	ff 45 fc             	incl   -0x4(%ebp)
f011593b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011593e:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0115943:	76 de                	jbe    f0115923 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0115945:	90                   	nop
f0115946:	c9                   	leave  
f0115947:	c3                   	ret    

f0115948 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0115948:	55                   	push   %ebp
f0115949:	89 e5                	mov    %esp,%ebp
f011594b:	83 ec 38             	sub    $0x38,%esp
f011594e:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0115951:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0115954:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115957:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011595c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f011595f:	8b 45 10             	mov    0x10(%ebp),%eax
f0115962:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0115967:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f011596a:	e9 ea 01 00 00       	jmp    f0115b59 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f011596f:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0115973:	74 44                	je     f01159b9 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0115975:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0115978:	83 ec 04             	sub    $0x4,%esp
f011597b:	8d 55 dc             	lea    -0x24(%ebp),%edx
f011597e:	52                   	push   %edx
f011597f:	50                   	push   %eax
f0115980:	ff 75 08             	pushl  0x8(%ebp)
f0115983:	e8 76 2d ff ff       	call   f01086fe <get_frame_info>
f0115988:	83 c4 10             	add    $0x10,%esp
f011598b:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f011598e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115991:	85 c0                	test   %eax,%eax
f0115993:	75 24                	jne    f01159b9 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0115995:	83 ec 04             	sub    $0x4,%esp
f0115998:	68 50 9d 12 f0       	push   $0xf0129d50
f011599d:	68 99 08 00 00       	push   $0x899
f01159a2:	68 02 82 12 f0       	push   $0xf0128202
f01159a7:	e8 2a ab fe ff       	call   f01004d6 <_warn>
f01159ac:	83 c4 10             	add    $0x10,%esp
				return 0;
f01159af:	b8 00 00 00 00       	mov    $0x0,%eax
f01159b4:	e9 b6 01 00 00       	jmp    f0115b6f <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f01159b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01159bc:	83 ec 04             	sub    $0x4,%esp
f01159bf:	8d 55 d8             	lea    -0x28(%ebp),%edx
f01159c2:	52                   	push   %edx
f01159c3:	50                   	push   %eax
f01159c4:	ff 75 08             	pushl  0x8(%ebp)
f01159c7:	e8 32 2d ff ff       	call   f01086fe <get_frame_info>
f01159cc:	83 c4 10             	add    $0x10,%esp
f01159cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f01159d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01159d5:	85 c0                	test   %eax,%eax
f01159d7:	75 24                	jne    f01159fd <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f01159d9:	83 ec 04             	sub    $0x4,%esp
f01159dc:	68 7c 9d 12 f0       	push   $0xf0129d7c
f01159e1:	68 a0 08 00 00       	push   $0x8a0
f01159e6:	68 02 82 12 f0       	push   $0xf0128202
f01159eb:	e8 e6 aa fe ff       	call   f01004d6 <_warn>
f01159f0:	83 c4 10             	add    $0x10,%esp
			return 0;
f01159f3:	b8 00 00 00 00       	mov    $0x0,%eax
f01159f8:	e9 72 01 00 00       	jmp    f0115b6f <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f01159fd:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0115a01:	75 70                	jne    f0115a73 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0115a03:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115a06:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0115a09:	c1 ea 0c             	shr    $0xc,%edx
f0115a0c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0115a12:	c1 e2 02             	shl    $0x2,%edx
f0115a15:	01 d0                	add    %edx,%eax
f0115a17:	8b 00                	mov    (%eax),%eax
f0115a19:	c1 e8 0c             	shr    $0xc,%eax
f0115a1c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0115a1f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0115a22:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0115a25:	c1 ea 0c             	shr    $0xc,%edx
f0115a28:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0115a2e:	c1 e2 02             	shl    $0x2,%edx
f0115a31:	01 d0                	add    %edx,%eax
f0115a33:	8b 00                	mov    (%eax),%eax
f0115a35:	c1 e8 0c             	shr    $0xc,%eax
f0115a38:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0115a3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0115a3e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0115a41:	74 30                	je     f0115a73 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0115a43:	83 ec 04             	sub    $0x4,%esp
f0115a46:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115a49:	ff 75 e8             	pushl  -0x18(%ebp)
f0115a4c:	ff 75 f0             	pushl  -0x10(%ebp)
f0115a4f:	ff 75 f4             	pushl  -0xc(%ebp)
f0115a52:	68 a8 9d 12 f0       	push   $0xf0129da8
f0115a57:	68 aa 08 00 00       	push   $0x8aa
f0115a5c:	68 02 82 12 f0       	push   $0xf0128202
f0115a61:	e8 70 aa fe ff       	call   f01004d6 <_warn>
f0115a66:	83 c4 20             	add    $0x20,%esp
				return 0;
f0115a69:	b8 00 00 00 00       	mov    $0x0,%eax
f0115a6e:	e9 fc 00 00 00       	jmp    f0115b6f <CCP+0x227>
			}
		}
		if (ref != -1)
f0115a73:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0115a77:	74 52                	je     f0115acb <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0115a79:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0115a7d:	74 0e                	je     f0115a8d <CCP+0x145>
f0115a7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0115a82:	8b 40 08             	mov    0x8(%eax),%eax
f0115a85:	0f b7 c0             	movzwl %ax,%eax
f0115a88:	3b 45 18             	cmp    0x18(%ebp),%eax
f0115a8b:	74 3e                	je     f0115acb <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0115a8d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0115a91:	74 0b                	je     f0115a9e <CCP+0x156>
f0115a93:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0115a96:	8b 40 08             	mov    0x8(%eax),%eax
f0115a99:	0f b7 c0             	movzwl %ax,%eax
f0115a9c:	eb 05                	jmp    f0115aa3 <CCP+0x15b>
f0115a9e:	b8 00 00 00 00       	mov    $0x0,%eax
f0115aa3:	83 ec 0c             	sub    $0xc,%esp
f0115aa6:	50                   	push   %eax
f0115aa7:	ff 75 f0             	pushl  -0x10(%ebp)
f0115aaa:	68 04 9e 12 f0       	push   $0xf0129e04
f0115aaf:	68 b2 08 00 00       	push   $0x8b2
f0115ab4:	68 02 82 12 f0       	push   $0xf0128202
f0115ab9:	e8 18 aa fe ff       	call   f01004d6 <_warn>
f0115abe:	83 c4 20             	add    $0x20,%esp
				return 0;
f0115ac1:	b8 00 00 00 00       	mov    $0x0,%eax
f0115ac6:	e9 a4 00 00 00       	jmp    f0115b6f <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0115acb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115ace:	ff 75 20             	pushl  0x20(%ebp)
f0115ad1:	ff 75 1c             	pushl  0x1c(%ebp)
f0115ad4:	50                   	push   %eax
f0115ad5:	ff 75 08             	pushl  0x8(%ebp)
f0115ad8:	e8 17 fd ff ff       	call   f01157f4 <CPs>
f0115add:	83 c4 10             	add    $0x10,%esp
f0115ae0:	85 c0                	test   %eax,%eax
f0115ae2:	7f 21                	jg     f0115b05 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0115ae4:	83 ec 04             	sub    $0x4,%esp
f0115ae7:	68 74 9e 12 f0       	push   $0xf0129e74
f0115aec:	68 b8 08 00 00       	push   $0x8b8
f0115af1:	68 02 82 12 f0       	push   $0xf0128202
f0115af6:	e8 db a9 fe ff       	call   f01004d6 <_warn>
f0115afb:	83 c4 10             	add    $0x10,%esp
			return 0;
f0115afe:	b8 00 00 00 00       	mov    $0x0,%eax
f0115b03:	eb 6a                	jmp    f0115b6f <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0115b05:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0115b09:	74 3a                	je     f0115b45 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0115b0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0115b0e:	ff 75 28             	pushl  0x28(%ebp)
f0115b11:	ff 75 24             	pushl  0x24(%ebp)
f0115b14:	50                   	push   %eax
f0115b15:	ff 75 08             	pushl  0x8(%ebp)
f0115b18:	e8 d7 fc ff ff       	call   f01157f4 <CPs>
f0115b1d:	83 c4 10             	add    $0x10,%esp
f0115b20:	85 c0                	test   %eax,%eax
f0115b22:	7f 21                	jg     f0115b45 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0115b24:	83 ec 04             	sub    $0x4,%esp
f0115b27:	68 bc 9e 12 f0       	push   $0xf0129ebc
f0115b2c:	68 bf 08 00 00       	push   $0x8bf
f0115b31:	68 02 82 12 f0       	push   $0xf0128202
f0115b36:	e8 9b a9 fe ff       	call   f01004d6 <_warn>
f0115b3b:	83 c4 10             	add    $0x10,%esp
				return 0;
f0115b3e:	b8 00 00 00 00       	mov    $0x0,%eax
f0115b43:	eb 2a                	jmp    f0115b6f <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0115b45:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0115b49:	74 07                	je     f0115b52 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0115b4b:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0115b52:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0115b59:	8b 55 10             	mov    0x10(%ebp),%edx
f0115b5c:	8b 45 14             	mov    0x14(%ebp),%eax
f0115b5f:	01 d0                	add    %edx,%eax
f0115b61:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0115b64:	0f 87 05 fe ff ff    	ja     f011596f <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0115b6a:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0115b6f:	c9                   	leave  
f0115b70:	c3                   	ret    

f0115b71 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0115b71:	55                   	push   %ebp
f0115b72:	89 e5                	mov    %esp,%ebp
f0115b74:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0115b77:	83 ec 04             	sub    $0x4,%esp
f0115b7a:	68 fc 9e 12 f0       	push   $0xf0129efc
f0115b7f:	6a 0e                	push   $0xe
f0115b81:	68 0c 9f 12 f0       	push   $0xf0129f0c
f0115b86:	e8 ae a7 fe ff       	call   f0100339 <_panic>

f0115b8b <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0115b8b:	55                   	push   %ebp
f0115b8c:	89 e5                	mov    %esp,%ebp
f0115b8e:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0115b91:	83 ec 04             	sub    $0x4,%esp
f0115b94:	68 fc 9e 12 f0       	push   $0xf0129efc
f0115b99:	68 d7 00 00 00       	push   $0xd7
f0115b9e:	68 0c 9f 12 f0       	push   $0xf0129f0c
f0115ba3:	e8 91 a7 fe ff       	call   f0100339 <_panic>

f0115ba8 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0115ba8:	55                   	push   %ebp
f0115ba9:	89 e5                	mov    %esp,%ebp
f0115bab:	57                   	push   %edi
f0115bac:	53                   	push   %ebx
f0115bad:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0115bb3:	83 ec 0c             	sub    $0xc,%esp
f0115bb6:	68 28 9f 12 f0       	push   $0xf0129f28
f0115bbb:	e8 cb b3 fe ff       	call   f0100f8b <cprintf>
f0115bc0:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0115bc3:	83 ec 0c             	sub    $0xc,%esp
f0115bc6:	68 58 9f 12 f0       	push   $0xf0129f58
f0115bcb:	e8 bb b3 fe ff       	call   f0100f8b <cprintf>
f0115bd0:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0115bd3:	83 ec 0c             	sub    $0xc,%esp
f0115bd6:	68 28 9f 12 f0       	push   $0xf0129f28
f0115bdb:	e8 ab b3 fe ff       	call   f0100f8b <cprintf>
f0115be0:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0115be3:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0115be7:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0115beb:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0115bf1:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0115bf7:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0115bfe:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f0115c05:	e8 1c 7e ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115c0a:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0115c0d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0115c14:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0115c1b:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0115c21:	b9 14 00 00 00       	mov    $0x14,%ecx
f0115c26:	b8 00 00 00 00       	mov    $0x0,%eax
f0115c2b:	89 d7                	mov    %edx,%edi
f0115c2d:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0115c2f:	83 ec 0c             	sub    $0xc,%esp
f0115c32:	68 b1 9f 12 f0       	push   $0xf0129fb1
f0115c37:	e8 4f b3 fe ff       	call   f0100f8b <cprintf>
f0115c3c:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0115c3f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f0115c46:	e8 db 7d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115c4b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115c4e:	e8 13 ec fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115c53:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f0115c56:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0115c5d:	83 ec 0c             	sub    $0xc,%esp
f0115c60:	ff 75 cc             	pushl  -0x34(%ebp)
f0115c63:	e8 28 31 ff ff       	call   f0108d90 <kmalloc>
f0115c68:	83 c4 10             	add    $0x10,%esp
f0115c6b:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0115c71:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0115c77:	85 c0                	test   %eax,%eax
f0115c79:	74 17                	je     f0115c92 <test_kmalloc+0xea>
f0115c7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115c82:	83 ec 0c             	sub    $0xc,%esp
f0115c85:	68 d0 9f 12 f0       	push   $0xf0129fd0
f0115c8a:	e8 fc b2 fe ff       	call   f0100f8b <cprintf>
f0115c8f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115c92:	e8 cf eb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115c97:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115c9a:	74 17                	je     f0115cb3 <test_kmalloc+0x10b>
f0115c9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115ca3:	83 ec 0c             	sub    $0xc,%esp
f0115ca6:	68 04 a0 12 f0       	push   $0xf012a004
f0115cab:	e8 db b2 fe ff       	call   f0100f8b <cprintf>
f0115cb0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115cb3:	e8 6e 7d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115cb8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0115cbb:	74 17                	je     f0115cd4 <test_kmalloc+0x12c>
f0115cbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115cc4:	83 ec 0c             	sub    $0xc,%esp
f0115cc7:	68 70 a0 12 f0       	push   $0xf012a070
f0115ccc:	e8 ba b2 fe ff       	call   f0100f8b <cprintf>
f0115cd1:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0115cd4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0115cd8:	74 04                	je     f0115cde <test_kmalloc+0x136>
f0115cda:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0115cde:	83 ec 0c             	sub    $0xc,%esp
f0115ce1:	68 b4 a0 12 f0       	push   $0xf012a0b4
f0115ce6:	e8 a0 b2 fe ff       	call   f0100f8b <cprintf>
f0115ceb:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0115cee:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115cf5:	e8 2c 7d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115cfa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115cfd:	e8 64 eb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115d02:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0115d05:	83 ec 0c             	sub    $0xc,%esp
f0115d08:	68 00 fc 1f 00       	push   $0x1ffc00
f0115d0d:	e8 7e 30 ff ff       	call   f0108d90 <kmalloc>
f0115d12:	83 c4 10             	add    $0x10,%esp
f0115d15:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0115d1b:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0115d21:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0115d26:	74 17                	je     f0115d3f <test_kmalloc+0x197>
f0115d28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115d2f:	83 ec 0c             	sub    $0xc,%esp
f0115d32:	68 f8 a0 12 f0       	push   $0xf012a0f8
f0115d37:	e8 4f b2 fe ff       	call   f0100f8b <cprintf>
f0115d3c:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115d3f:	e8 22 eb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115d44:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115d47:	74 17                	je     f0115d60 <test_kmalloc+0x1b8>
f0115d49:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115d50:	83 ec 0c             	sub    $0xc,%esp
f0115d53:	68 4c a1 12 f0       	push   $0xf012a14c
f0115d58:	e8 2e b2 fe ff       	call   f0100f8b <cprintf>
f0115d5d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115d60:	e8 c1 7c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115d65:	89 c2                	mov    %eax,%edx
f0115d67:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115d6a:	29 d0                	sub    %edx,%eax
f0115d6c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0115d71:	7f 17                	jg     f0115d8a <test_kmalloc+0x1e2>
f0115d73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115d7a:	83 ec 0c             	sub    $0xc,%esp
f0115d7d:	68 b8 a1 12 f0       	push   $0xf012a1b8
f0115d82:	e8 04 b2 fe ff       	call   f0100f8b <cprintf>
f0115d87:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115d8a:	e8 97 7c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115d8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115d92:	e8 cf ea fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115d97:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0115d9a:	83 ec 0c             	sub    $0xc,%esp
f0115d9d:	68 00 fc 1f 00       	push   $0x1ffc00
f0115da2:	e8 e9 2f ff ff       	call   f0108d90 <kmalloc>
f0115da7:	83 c4 10             	add    $0x10,%esp
f0115daa:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0115db0:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0115db6:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0115dbb:	74 17                	je     f0115dd4 <test_kmalloc+0x22c>
f0115dbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115dc4:	83 ec 0c             	sub    $0xc,%esp
f0115dc7:	68 fc a1 12 f0       	push   $0xf012a1fc
f0115dcc:	e8 ba b1 fe ff       	call   f0100f8b <cprintf>
f0115dd1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115dd4:	e8 8d ea fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115dd9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115ddc:	74 17                	je     f0115df5 <test_kmalloc+0x24d>
f0115dde:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115de5:	83 ec 0c             	sub    $0xc,%esp
f0115de8:	68 50 a2 12 f0       	push   $0xf012a250
f0115ded:	e8 99 b1 fe ff       	call   f0100f8b <cprintf>
f0115df2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115df5:	e8 2c 7c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115dfa:	89 c2                	mov    %eax,%edx
f0115dfc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115dff:	29 d0                	sub    %edx,%eax
f0115e01:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0115e06:	7f 17                	jg     f0115e1f <test_kmalloc+0x277>
f0115e08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115e0f:	83 ec 0c             	sub    $0xc,%esp
f0115e12:	68 bc a2 12 f0       	push   $0xf012a2bc
f0115e17:	e8 6f b1 fe ff       	call   f0100f8b <cprintf>
f0115e1c:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0115e1f:	e8 02 7c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115e24:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115e27:	e8 3a ea fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115e2c:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0115e2f:	83 ec 0c             	sub    $0xc,%esp
f0115e32:	68 ff 07 00 00       	push   $0x7ff
f0115e37:	e8 54 2f ff ff       	call   f0108d90 <kmalloc>
f0115e3c:	83 c4 10             	add    $0x10,%esp
f0115e3f:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0115e45:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0115e4b:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0115e50:	76 28                	jbe    f0115e7a <test_kmalloc+0x2d2>
f0115e52:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0115e58:	83 ec 0c             	sub    $0xc,%esp
f0115e5b:	6a 00                	push   $0x0
f0115e5d:	e8 3f 2e ff ff       	call   f0108ca1 <sbrk>
f0115e62:	83 c4 10             	add    $0x10,%esp
f0115e65:	39 c3                	cmp    %eax,%ebx
f0115e67:	73 11                	jae    f0115e7a <test_kmalloc+0x2d2>
f0115e69:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0115e6f:	89 c2                	mov    %eax,%edx
f0115e71:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f0115e76:	39 c2                	cmp    %eax,%edx
f0115e78:	72 17                	jb     f0115e91 <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0115e7a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115e81:	83 ec 0c             	sub    $0xc,%esp
f0115e84:	68 00 a3 12 f0       	push   $0xf012a300
f0115e89:	e8 fd b0 fe ff       	call   f0100f8b <cprintf>
f0115e8e:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115e91:	e8 d0 e9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115e96:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115e99:	74 17                	je     f0115eb2 <test_kmalloc+0x30a>
f0115e9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115ea2:	83 ec 0c             	sub    $0xc,%esp
f0115ea5:	68 8c a3 12 f0       	push   $0xf012a38c
f0115eaa:	e8 dc b0 fe ff       	call   f0100f8b <cprintf>
f0115eaf:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115eb2:	e8 af e9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115eb7:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0115eba:	83 ec 0c             	sub    $0xc,%esp
f0115ebd:	68 ff 07 00 00       	push   $0x7ff
f0115ec2:	e8 c9 2e ff ff       	call   f0108d90 <kmalloc>
f0115ec7:	83 c4 10             	add    $0x10,%esp
f0115eca:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0115ed0:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0115ed6:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0115edb:	76 28                	jbe    f0115f05 <test_kmalloc+0x35d>
f0115edd:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f0115ee3:	83 ec 0c             	sub    $0xc,%esp
f0115ee6:	6a 00                	push   $0x0
f0115ee8:	e8 b4 2d ff ff       	call   f0108ca1 <sbrk>
f0115eed:	83 c4 10             	add    $0x10,%esp
f0115ef0:	39 c3                	cmp    %eax,%ebx
f0115ef2:	73 11                	jae    f0115f05 <test_kmalloc+0x35d>
f0115ef4:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0115efa:	89 c2                	mov    %eax,%edx
f0115efc:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f0115f01:	39 c2                	cmp    %eax,%edx
f0115f03:	72 17                	jb     f0115f1c <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0115f05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115f0c:	83 ec 0c             	sub    $0xc,%esp
f0115f0f:	68 f8 a3 12 f0       	push   $0xf012a3f8
f0115f14:	e8 72 b0 fe ff       	call   f0100f8b <cprintf>
f0115f19:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115f1c:	e8 45 e9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115f21:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115f24:	74 17                	je     f0115f3d <test_kmalloc+0x395>
f0115f26:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115f2d:	83 ec 0c             	sub    $0xc,%esp
f0115f30:	68 84 a4 12 f0       	push   $0xf012a484
f0115f35:	e8 51 b0 fe ff       	call   f0100f8b <cprintf>
f0115f3a:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f0115f3d:	e8 e4 7a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115f42:	89 c2                	mov    %eax,%edx
f0115f44:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115f47:	29 d0                	sub    %edx,%eax
f0115f49:	83 f8 01             	cmp    $0x1,%eax
f0115f4c:	74 17                	je     f0115f65 <test_kmalloc+0x3bd>
f0115f4e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115f55:	83 ec 0c             	sub    $0xc,%esp
f0115f58:	68 f0 a4 12 f0       	push   $0xf012a4f0
f0115f5d:	e8 29 b0 fe ff       	call   f0100f8b <cprintf>
f0115f62:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115f65:	e8 bc 7a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115f6a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115f6d:	e8 f4 e8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115f72:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0115f75:	83 ec 0c             	sub    $0xc,%esp
f0115f78:	68 00 1c 00 00       	push   $0x1c00
f0115f7d:	e8 0e 2e ff ff       	call   f0108d90 <kmalloc>
f0115f82:	83 c4 10             	add    $0x10,%esp
f0115f85:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0115f8b:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0115f91:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0115f96:	74 17                	je     f0115faf <test_kmalloc+0x407>
f0115f98:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115f9f:	83 ec 0c             	sub    $0xc,%esp
f0115fa2:	68 10 a5 12 f0       	push   $0xf012a510
f0115fa7:	e8 df af fe ff       	call   f0100f8b <cprintf>
f0115fac:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115faf:	e8 b2 e8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0115fb4:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115fb7:	74 17                	je     f0115fd0 <test_kmalloc+0x428>
f0115fb9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115fc0:	83 ec 0c             	sub    $0xc,%esp
f0115fc3:	68 64 a5 12 f0       	push   $0xf012a564
f0115fc8:	e8 be af fe ff       	call   f0100f8b <cprintf>
f0115fcd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115fd0:	e8 51 7a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115fd5:	89 c2                	mov    %eax,%edx
f0115fd7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115fda:	29 d0                	sub    %edx,%eax
f0115fdc:	83 f8 01             	cmp    $0x1,%eax
f0115fdf:	7f 17                	jg     f0115ff8 <test_kmalloc+0x450>
f0115fe1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115fe8:	83 ec 0c             	sub    $0xc,%esp
f0115feb:	68 d0 a5 12 f0       	push   $0xf012a5d0
f0115ff0:	e8 96 af fe ff       	call   f0100f8b <cprintf>
f0115ff5:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115ff8:	e8 29 7a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0115ffd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116000:	e8 61 e8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116005:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0116008:	83 ec 0c             	sub    $0xc,%esp
f011600b:	68 00 fc 2f 00       	push   $0x2ffc00
f0116010:	e8 7b 2d ff ff       	call   f0108d90 <kmalloc>
f0116015:	83 c4 10             	add    $0x10,%esp
f0116018:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011601e:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0116024:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0116029:	74 17                	je     f0116042 <test_kmalloc+0x49a>
f011602b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116032:	83 ec 0c             	sub    $0xc,%esp
f0116035:	68 14 a6 12 f0       	push   $0xf012a614
f011603a:	e8 4c af fe ff       	call   f0100f8b <cprintf>
f011603f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116042:	e8 1f e8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116047:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011604a:	74 17                	je     f0116063 <test_kmalloc+0x4bb>
f011604c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116053:	83 ec 0c             	sub    $0xc,%esp
f0116056:	68 68 a6 12 f0       	push   $0xf012a668
f011605b:	e8 2b af fe ff       	call   f0100f8b <cprintf>
f0116060:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116063:	e8 be 79 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116068:	89 c2                	mov    %eax,%edx
f011606a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011606d:	29 d0                	sub    %edx,%eax
f011606f:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116074:	7f 17                	jg     f011608d <test_kmalloc+0x4e5>
f0116076:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011607d:	83 ec 0c             	sub    $0xc,%esp
f0116080:	68 d4 a6 12 f0       	push   $0xf012a6d4
f0116085:	e8 01 af fe ff       	call   f0100f8b <cprintf>
f011608a:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011608d:	e8 94 79 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116092:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116095:	e8 cc e7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011609a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011609d:	83 ec 0c             	sub    $0xc,%esp
f01160a0:	68 00 fc 5f 00       	push   $0x5ffc00
f01160a5:	e8 e6 2c ff ff       	call   f0108d90 <kmalloc>
f01160aa:	83 c4 10             	add    $0x10,%esp
f01160ad:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01160b3:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01160b9:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01160be:	74 17                	je     f01160d7 <test_kmalloc+0x52f>
f01160c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01160c7:	83 ec 0c             	sub    $0xc,%esp
f01160ca:	68 18 a7 12 f0       	push   $0xf012a718
f01160cf:	e8 b7 ae fe ff       	call   f0100f8b <cprintf>
f01160d4:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01160d7:	e8 8a e7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01160dc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01160df:	74 17                	je     f01160f8 <test_kmalloc+0x550>
f01160e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01160e8:	83 ec 0c             	sub    $0xc,%esp
f01160eb:	68 6c a7 12 f0       	push   $0xf012a76c
f01160f0:	e8 96 ae fe ff       	call   f0100f8b <cprintf>
f01160f5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01160f8:	e8 29 79 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01160fd:	89 c2                	mov    %eax,%edx
f01160ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116102:	29 d0                	sub    %edx,%eax
f0116104:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0116109:	7f 17                	jg     f0116122 <test_kmalloc+0x57a>
f011610b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116112:	83 ec 0c             	sub    $0xc,%esp
f0116115:	68 d8 a7 12 f0       	push   $0xf012a7d8
f011611a:	e8 6c ae fe ff       	call   f0100f8b <cprintf>
f011611f:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116122:	e8 ff 78 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116127:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011612a:	e8 37 e7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011612f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0116132:	83 ec 0c             	sub    $0xc,%esp
f0116135:	68 00 38 00 00       	push   $0x3800
f011613a:	e8 51 2c ff ff       	call   f0108d90 <kmalloc>
f011613f:	83 c4 10             	add    $0x10,%esp
f0116142:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116148:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011614e:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0116153:	74 17                	je     f011616c <test_kmalloc+0x5c4>
f0116155:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011615c:	83 ec 0c             	sub    $0xc,%esp
f011615f:	68 1c a8 12 f0       	push   $0xf012a81c
f0116164:	e8 22 ae fe ff       	call   f0100f8b <cprintf>
f0116169:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011616c:	e8 f5 e6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116171:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116174:	74 17                	je     f011618d <test_kmalloc+0x5e5>
f0116176:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011617d:	83 ec 0c             	sub    $0xc,%esp
f0116180:	68 70 a8 12 f0       	push   $0xf012a870
f0116185:	e8 01 ae fe ff       	call   f0100f8b <cprintf>
f011618a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011618d:	e8 94 78 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116192:	89 c2                	mov    %eax,%edx
f0116194:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116197:	29 d0                	sub    %edx,%eax
f0116199:	83 f8 03             	cmp    $0x3,%eax
f011619c:	7f 17                	jg     f01161b5 <test_kmalloc+0x60d>
f011619e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01161a5:	83 ec 0c             	sub    $0xc,%esp
f01161a8:	68 dc a8 12 f0       	push   $0xf012a8dc
f01161ad:	e8 d9 ad fe ff       	call   f0100f8b <cprintf>
f01161b2:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01161b5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01161b9:	74 04                	je     f01161bf <test_kmalloc+0x617>
f01161bb:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01161bf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f01161c6:	83 ec 0c             	sub    $0xc,%esp
f01161c9:	68 20 a9 12 f0       	push   $0xf012a920
f01161ce:	e8 b8 ad fe ff       	call   f0100f8b <cprintf>
f01161d3:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f01161d6:	e8 4b 78 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01161db:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01161de:	e8 83 e6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01161e3:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f01161e6:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f01161ed:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01161f3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f01161f6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01161f9:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01161fc:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f01161fe:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116201:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116204:	01 c2                	add    %eax,%edx
f0116206:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116209:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f011620b:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116211:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0116214:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f011621b:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011621e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116221:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0116224:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116227:	01 c0                	add    %eax,%eax
f0116229:	89 c2                	mov    %eax,%edx
f011622b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011622e:	01 c2                	add    %eax,%edx
f0116230:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116234:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f0116237:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011623d:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0116240:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f0116247:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011624a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011624d:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f011624f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116252:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116259:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011625c:	01 c2                	add    %eax,%edx
f011625e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116261:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0116263:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116269:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f011626c:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0116273:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116276:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116279:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f011627b:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011627e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116281:	01 c2                	add    %eax,%edx
f0116283:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116286:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f0116288:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011628e:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f0116291:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f0116298:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011629b:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011629e:	88 10                	mov    %dl,(%eax)
f01162a0:	8b 55 a8             	mov    -0x58(%ebp),%edx
f01162a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01162a6:	66 89 42 02          	mov    %ax,0x2(%edx)
f01162aa:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01162ad:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01162b0:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f01162b3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01162b6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01162bd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01162c0:	01 c2                	add    %eax,%edx
f01162c2:	8a 45 ea             	mov    -0x16(%ebp),%al
f01162c5:	88 02                	mov    %al,(%edx)
f01162c7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01162ca:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01162d1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01162d4:	01 c2                	add    %eax,%edx
f01162d6:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01162da:	66 89 42 02          	mov    %ax,0x2(%edx)
f01162de:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01162e1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01162e8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01162eb:	01 c2                	add    %eax,%edx
f01162ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01162f0:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f01162f3:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f01162fa:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0116300:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0116303:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116306:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116309:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f011630b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011630e:	89 c2                	mov    %eax,%edx
f0116310:	c1 ea 1f             	shr    $0x1f,%edx
f0116313:	01 d0                	add    %edx,%eax
f0116315:	d1 f8                	sar    %eax
f0116317:	89 c2                	mov    %eax,%edx
f0116319:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011631c:	01 c2                	add    %eax,%edx
f011631e:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116321:	88 c1                	mov    %al,%cl
f0116323:	c0 e9 07             	shr    $0x7,%cl
f0116326:	01 c8                	add    %ecx,%eax
f0116328:	d0 f8                	sar    %al
f011632a:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f011632c:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011632f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116332:	01 c2                	add    %eax,%edx
f0116334:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116337:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f0116339:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011633f:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0116342:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f0116349:	8b 55 98             	mov    -0x68(%ebp),%edx
f011634c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011634f:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0116352:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116355:	01 c0                	add    %eax,%eax
f0116357:	89 c2                	mov    %eax,%edx
f0116359:	8b 45 98             	mov    -0x68(%ebp),%eax
f011635c:	01 c2                	add    %eax,%edx
f011635e:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116362:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f0116365:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116368:	8a 00                	mov    (%eax),%al
f011636a:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011636d:	75 0f                	jne    f011637e <test_kmalloc+0x7d6>
f011636f:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116372:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116375:	01 d0                	add    %edx,%eax
f0116377:	8a 00                	mov    (%eax),%al
f0116379:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011637c:	74 17                	je     f0116395 <test_kmalloc+0x7ed>
f011637e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116385:	83 ec 0c             	sub    $0xc,%esp
f0116388:	68 58 a9 12 f0       	push   $0xf012a958
f011638d:	e8 f9 ab fe ff       	call   f0100f8b <cprintf>
f0116392:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0116395:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116398:	66 8b 00             	mov    (%eax),%ax
f011639b:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011639f:	75 15                	jne    f01163b6 <test_kmalloc+0x80e>
f01163a1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01163a4:	01 c0                	add    %eax,%eax
f01163a6:	89 c2                	mov    %eax,%edx
f01163a8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01163ab:	01 d0                	add    %edx,%eax
f01163ad:	66 8b 00             	mov    (%eax),%ax
f01163b0:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01163b4:	74 17                	je     f01163cd <test_kmalloc+0x825>
f01163b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01163bd:	83 ec 0c             	sub    $0xc,%esp
f01163c0:	68 90 a9 12 f0       	push   $0xf012a990
f01163c5:	e8 c1 ab fe ff       	call   f0100f8b <cprintf>
f01163ca:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f01163cd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01163d0:	8b 00                	mov    (%eax),%eax
f01163d2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01163d5:	75 16                	jne    f01163ed <test_kmalloc+0x845>
f01163d7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01163da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01163e1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01163e4:	01 d0                	add    %edx,%eax
f01163e6:	8b 00                	mov    (%eax),%eax
f01163e8:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01163eb:	74 17                	je     f0116404 <test_kmalloc+0x85c>
f01163ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01163f4:	83 ec 0c             	sub    $0xc,%esp
f01163f7:	68 cc a9 12 f0       	push   $0xf012a9cc
f01163fc:	e8 8a ab fe ff       	call   f0100f8b <cprintf>
f0116401:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f0116404:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116407:	8a 00                	mov    (%eax),%al
f0116409:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011640c:	75 0f                	jne    f011641d <test_kmalloc+0x875>
f011640e:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0116411:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116414:	01 d0                	add    %edx,%eax
f0116416:	8a 00                	mov    (%eax),%al
f0116418:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011641b:	74 17                	je     f0116434 <test_kmalloc+0x88c>
f011641d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116424:	83 ec 0c             	sub    $0xc,%esp
f0116427:	68 08 aa 12 f0       	push   $0xf012aa08
f011642c:	e8 5a ab fe ff       	call   f0100f8b <cprintf>
f0116431:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f0116434:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116437:	8a 00                	mov    (%eax),%al
f0116439:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011643c:	75 16                	jne    f0116454 <test_kmalloc+0x8ac>
f011643e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116441:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116448:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011644b:	01 d0                	add    %edx,%eax
f011644d:	8a 00                	mov    (%eax),%al
f011644f:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116452:	74 17                	je     f011646b <test_kmalloc+0x8c3>
f0116454:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011645b:	83 ec 0c             	sub    $0xc,%esp
f011645e:	68 44 aa 12 f0       	push   $0xf012aa44
f0116463:	e8 23 ab fe ff       	call   f0100f8b <cprintf>
f0116468:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f011646b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011646e:	66 8b 40 02          	mov    0x2(%eax),%ax
f0116472:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116476:	75 19                	jne    f0116491 <test_kmalloc+0x8e9>
f0116478:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011647b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116482:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116485:	01 d0                	add    %edx,%eax
f0116487:	66 8b 40 02          	mov    0x2(%eax),%ax
f011648b:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011648f:	74 17                	je     f01164a8 <test_kmalloc+0x900>
f0116491:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116498:	83 ec 0c             	sub    $0xc,%esp
f011649b:	68 80 aa 12 f0       	push   $0xf012aa80
f01164a0:	e8 e6 aa fe ff       	call   f0100f8b <cprintf>
f01164a5:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f01164a8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01164ab:	8b 40 04             	mov    0x4(%eax),%eax
f01164ae:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01164b1:	75 17                	jne    f01164ca <test_kmalloc+0x922>
f01164b3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01164b6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01164bd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01164c0:	01 d0                	add    %edx,%eax
f01164c2:	8b 40 04             	mov    0x4(%eax),%eax
f01164c5:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01164c8:	74 17                	je     f01164e1 <test_kmalloc+0x939>
f01164ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01164d1:	83 ec 0c             	sub    $0xc,%esp
f01164d4:	68 bc aa 12 f0       	push   $0xf012aabc
f01164d9:	e8 ad aa fe ff       	call   f0100f8b <cprintf>
f01164de:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f01164e1:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01164e4:	8a 00                	mov    (%eax),%al
f01164e6:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01164e9:	75 34                	jne    f011651f <test_kmalloc+0x977>
f01164eb:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01164ee:	89 c2                	mov    %eax,%edx
f01164f0:	c1 ea 1f             	shr    $0x1f,%edx
f01164f3:	01 d0                	add    %edx,%eax
f01164f5:	d1 f8                	sar    %eax
f01164f7:	89 c2                	mov    %eax,%edx
f01164f9:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01164fc:	01 d0                	add    %edx,%eax
f01164fe:	8a 10                	mov    (%eax),%dl
f0116500:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116503:	88 c1                	mov    %al,%cl
f0116505:	c0 e9 07             	shr    $0x7,%cl
f0116508:	01 c8                	add    %ecx,%eax
f011650a:	d0 f8                	sar    %al
f011650c:	38 c2                	cmp    %al,%dl
f011650e:	75 0f                	jne    f011651f <test_kmalloc+0x977>
f0116510:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116513:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116516:	01 d0                	add    %edx,%eax
f0116518:	8a 00                	mov    (%eax),%al
f011651a:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011651d:	74 17                	je     f0116536 <test_kmalloc+0x98e>
f011651f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116526:	83 ec 0c             	sub    $0xc,%esp
f0116529:	68 f8 aa 12 f0       	push   $0xf012aaf8
f011652e:	e8 58 aa fe ff       	call   f0100f8b <cprintf>
f0116533:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f0116536:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116539:	66 8b 00             	mov    (%eax),%ax
f011653c:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116540:	75 15                	jne    f0116557 <test_kmalloc+0x9af>
f0116542:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116545:	01 c0                	add    %eax,%eax
f0116547:	89 c2                	mov    %eax,%edx
f0116549:	8b 45 98             	mov    -0x68(%ebp),%eax
f011654c:	01 d0                	add    %edx,%eax
f011654e:	66 8b 00             	mov    (%eax),%ax
f0116551:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116555:	74 17                	je     f011656e <test_kmalloc+0x9c6>
f0116557:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011655e:	83 ec 0c             	sub    $0xc,%esp
f0116561:	68 30 ab 12 f0       	push   $0xf012ab30
f0116566:	e8 20 aa fe ff       	call   f0100f8b <cprintf>
f011656b:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011656e:	e8 b3 74 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116573:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116576:	74 17                	je     f011658f <test_kmalloc+0x9e7>
f0116578:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011657f:	83 ec 0c             	sub    $0xc,%esp
f0116582:	68 6c ab 12 f0       	push   $0xf012ab6c
f0116587:	e8 ff a9 fe ff       	call   f0100f8b <cprintf>
f011658c:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011658f:	e8 d2 e2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116594:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116597:	74 17                	je     f01165b0 <test_kmalloc+0xa08>
f0116599:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01165a0:	83 ec 0c             	sub    $0xc,%esp
f01165a3:	68 b0 ab 12 f0       	push   $0xf012abb0
f01165a8:	e8 de a9 fe ff       	call   f0100f8b <cprintf>
f01165ad:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f01165b0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01165b4:	74 04                	je     f01165ba <test_kmalloc+0xa12>
f01165b6:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f01165ba:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f01165c1:	83 ec 0c             	sub    $0xc,%esp
f01165c4:	68 1c ac 12 f0       	push   $0xf012ac1c
f01165c9:	e8 bd a9 fe ff       	call   f0100f8b <cprintf>
f01165ce:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f01165d1:	e8 50 74 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01165d6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01165d9:	e8 88 e2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01165de:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f01165e1:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		cprintf("restOfKheap : %x\n",restOfKHeap);
f01165e8:	83 ec 08             	sub    $0x8,%esp
f01165eb:	ff 75 90             	pushl  -0x70(%ebp)
f01165ee:	68 40 ac 12 f0       	push   $0xf012ac40
f01165f3:	e8 93 a9 fe ff       	call   f0100f8b <cprintf>
f01165f8:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f01165fb:	8b 45 90             	mov    -0x70(%ebp),%eax
f01165fe:	40                   	inc    %eax
f01165ff:	83 ec 0c             	sub    $0xc,%esp
f0116602:	50                   	push   %eax
f0116603:	e8 88 27 ff ff       	call   f0108d90 <kmalloc>
f0116608:	83 c4 10             	add    $0x10,%esp
f011660b:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f0116611:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0116617:	85 c0                	test   %eax,%eax
f0116619:	74 17                	je     f0116632 <test_kmalloc+0xa8a>
f011661b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116622:	83 ec 0c             	sub    $0xc,%esp
f0116625:	68 54 ac 12 f0       	push   $0xf012ac54
f011662a:	e8 5c a9 fe ff       	call   f0100f8b <cprintf>
f011662f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116632:	e8 2f e2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116637:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011663a:	74 17                	je     f0116653 <test_kmalloc+0xaab>
f011663c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116643:	83 ec 0c             	sub    $0xc,%esp
f0116646:	68 8c ac 12 f0       	push   $0xf012ac8c
f011664b:	e8 3b a9 fe ff       	call   f0100f8b <cprintf>
f0116650:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116653:	e8 ce 73 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116658:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011665b:	74 17                	je     f0116674 <test_kmalloc+0xacc>
f011665d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116664:	83 ec 0c             	sub    $0xc,%esp
f0116667:	68 f8 ac 12 f0       	push   $0xf012acf8
f011666c:	e8 1a a9 fe ff       	call   f0100f8b <cprintf>
f0116671:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116674:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116678:	74 04                	je     f011667e <test_kmalloc+0xad6>
f011667a:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011667e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f0116685:	83 ec 0c             	sub    $0xc,%esp
f0116688:	68 3c ad 12 f0       	push   $0xf012ad3c
f011668d:	e8 f9 a8 fe ff       	call   f0100f8b <cprintf>
f0116692:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f0116695:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011669b:	05 00 40 00 00       	add    $0x4000,%eax
f01166a0:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f01166a3:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f01166aa:	eb 6a                	jmp    f0116716 <test_kmalloc+0xb6e>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f01166ac:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f01166b1:	83 ec 04             	sub    $0x4,%esp
f01166b4:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f01166ba:	52                   	push   %edx
f01166bb:	ff 75 ec             	pushl  -0x14(%ebp)
f01166be:	50                   	push   %eax
f01166bf:	e8 c0 1c ff ff       	call   f0108384 <get_page_table>
f01166c4:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f01166c7:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f01166cd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01166d0:	c1 ea 0c             	shr    $0xc,%edx
f01166d3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01166d9:	c1 e2 02             	shl    $0x2,%edx
f01166dc:	01 d0                	add    %edx,%eax
f01166de:	8b 00                	mov    (%eax),%eax
f01166e0:	25 ff 0f 00 00       	and    $0xfff,%eax
f01166e5:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f01166e8:	8b 45 88             	mov    -0x78(%ebp),%eax
f01166eb:	83 e0 04             	and    $0x4,%eax
f01166ee:	85 c0                	test   %eax,%eax
f01166f0:	74 1d                	je     f011670f <test_kmalloc+0xb67>
			{
				if (correct)
f01166f2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01166f6:	74 17                	je     f011670f <test_kmalloc+0xb67>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f01166f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01166ff:	83 ec 0c             	sub    $0xc,%esp
f0116702:	68 80 ad 12 f0       	push   $0xf012ad80
f0116707:	e8 7f a8 fe ff       	call   f0100f8b <cprintf>
f011670c:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011670f:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f0116716:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116719:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011671c:	72 8e                	jb     f01166ac <test_kmalloc+0xb04>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011671e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116722:	74 04                	je     f0116728 <test_kmalloc+0xb80>
f0116724:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f0116728:	83 ec 08             	sub    $0x8,%esp
f011672b:	ff 75 f4             	pushl  -0xc(%ebp)
f011672e:	68 d0 ad 12 f0       	push   $0xf012add0
f0116733:	e8 53 a8 fe ff       	call   f0100f8b <cprintf>
f0116738:	83 c4 10             	add    $0x10,%esp

	return 1;
f011673b:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0116740:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0116743:	5b                   	pop    %ebx
f0116744:	5f                   	pop    %edi
f0116745:	5d                   	pop    %ebp
f0116746:	c3                   	ret    

f0116747 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f0116747:	55                   	push   %ebp
f0116748:	89 e5                	mov    %esp,%ebp
f011674a:	57                   	push   %edi
f011674b:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011674e:	83 ec 0c             	sub    $0xc,%esp
f0116751:	68 28 9f 12 f0       	push   $0xf0129f28
f0116756:	e8 30 a8 fe ff       	call   f0100f8b <cprintf>
f011675b:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011675e:	83 ec 0c             	sub    $0xc,%esp
f0116761:	68 58 9f 12 f0       	push   $0xf0129f58
f0116766:	e8 20 a8 fe ff       	call   f0100f8b <cprintf>
f011676b:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011676e:	83 ec 0c             	sub    $0xc,%esp
f0116771:	68 28 9f 12 f0       	push   $0xf0129f28
f0116776:	e8 10 a8 fe ff       	call   f0100f8b <cprintf>
f011677b:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f011677e:	8d 55 98             	lea    -0x68(%ebp),%edx
f0116781:	b9 14 00 00 00       	mov    $0x14,%ecx
f0116786:	b8 00 00 00 00       	mov    $0x0,%eax
f011678b:	89 d7                	mov    %edx,%edi
f011678d:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f011678f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0116796:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f011679d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f01167a4:	83 ec 0c             	sub    $0xc,%esp
f01167a7:	68 fc ad 12 f0       	push   $0xf012adfc
f01167ac:	e8 da a7 fe ff       	call   f0100f8b <cprintf>
f01167b1:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01167b4:	e8 6d 72 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01167b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01167bc:	e8 a5 e0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01167c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f01167c4:	83 ec 0c             	sub    $0xc,%esp
f01167c7:	68 00 fc 0f 00       	push   $0xffc00
f01167cc:	e8 bf 25 ff ff       	call   f0108d90 <kmalloc>
f01167d1:	83 c4 10             	add    $0x10,%esp
f01167d4:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f01167d7:	8b 45 98             	mov    -0x68(%ebp),%eax
f01167da:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01167df:	74 17                	je     f01167f8 <test_kmalloc_firstfit1+0xb1>
f01167e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01167e8:	83 ec 0c             	sub    $0xc,%esp
f01167eb:	68 3c ae 12 f0       	push   $0xf012ae3c
f01167f0:	e8 96 a7 fe ff       	call   f0100f8b <cprintf>
f01167f5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01167f8:	e8 69 e0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01167fd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116800:	74 17                	je     f0116819 <test_kmalloc_firstfit1+0xd2>
f0116802:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116809:	83 ec 0c             	sub    $0xc,%esp
f011680c:	68 4c a1 12 f0       	push   $0xf012a14c
f0116811:	e8 75 a7 fe ff       	call   f0100f8b <cprintf>
f0116816:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f0116819:	e8 08 72 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011681e:	89 c2                	mov    %eax,%edx
f0116820:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116823:	29 d0                	sub    %edx,%eax
f0116825:	3d ff 00 00 00       	cmp    $0xff,%eax
f011682a:	7f 17                	jg     f0116843 <test_kmalloc_firstfit1+0xfc>
f011682c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116833:	83 ec 0c             	sub    $0xc,%esp
f0116836:	68 6f ae 12 f0       	push   $0xf012ae6f
f011683b:	e8 4b a7 fe ff       	call   f0100f8b <cprintf>
f0116840:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116843:	e8 de 71 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116848:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011684b:	e8 16 e0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116850:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0116853:	83 ec 0c             	sub    $0xc,%esp
f0116856:	68 00 fc 0f 00       	push   $0xffc00
f011685b:	e8 30 25 ff ff       	call   f0108d90 <kmalloc>
f0116860:	83 c4 10             	add    $0x10,%esp
f0116863:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0116866:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116869:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011686e:	74 17                	je     f0116887 <test_kmalloc_firstfit1+0x140>
f0116870:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116877:	83 ec 0c             	sub    $0xc,%esp
f011687a:	68 88 ae 12 f0       	push   $0xf012ae88
f011687f:	e8 07 a7 fe ff       	call   f0100f8b <cprintf>
f0116884:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116887:	e8 da df fe ff       	call   f0104866 <pf_calculate_free_frames>
f011688c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011688f:	74 17                	je     f01168a8 <test_kmalloc_firstfit1+0x161>
f0116891:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116898:	83 ec 0c             	sub    $0xc,%esp
f011689b:	68 50 a2 12 f0       	push   $0xf012a250
f01168a0:	e8 e6 a6 fe ff       	call   f0100f8b <cprintf>
f01168a5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f01168a8:	e8 79 71 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01168ad:	89 c2                	mov    %eax,%edx
f01168af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01168b2:	29 d0                	sub    %edx,%eax
f01168b4:	3d ff 00 00 00       	cmp    $0xff,%eax
f01168b9:	7f 17                	jg     f01168d2 <test_kmalloc_firstfit1+0x18b>
f01168bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01168c2:	83 ec 0c             	sub    $0xc,%esp
f01168c5:	68 bb ae 12 f0       	push   $0xf012aebb
f01168ca:	e8 bc a6 fe ff       	call   f0100f8b <cprintf>
f01168cf:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01168d2:	e8 4f 71 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01168d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01168da:	e8 87 df fe ff       	call   f0104866 <pf_calculate_free_frames>
f01168df:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f01168e2:	83 ec 0c             	sub    $0xc,%esp
f01168e5:	68 00 fc 0f 00       	push   $0xffc00
f01168ea:	e8 a1 24 ff ff       	call   f0108d90 <kmalloc>
f01168ef:	83 c4 10             	add    $0x10,%esp
f01168f2:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f01168f5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01168f8:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01168fd:	74 17                	je     f0116916 <test_kmalloc_firstfit1+0x1cf>
f01168ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116906:	83 ec 0c             	sub    $0xc,%esp
f0116909:	68 d4 ae 12 f0       	push   $0xf012aed4
f011690e:	e8 78 a6 fe ff       	call   f0100f8b <cprintf>
f0116913:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116916:	e8 4b df fe ff       	call   f0104866 <pf_calculate_free_frames>
f011691b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011691e:	74 17                	je     f0116937 <test_kmalloc_firstfit1+0x1f0>
f0116920:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116927:	83 ec 0c             	sub    $0xc,%esp
f011692a:	68 8c a3 12 f0       	push   $0xf012a38c
f011692f:	e8 57 a6 fe ff       	call   f0100f8b <cprintf>
f0116934:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0116937:	e8 ea 70 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011693c:	89 c2                	mov    %eax,%edx
f011693e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116941:	29 d0                	sub    %edx,%eax
f0116943:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116948:	7f 17                	jg     f0116961 <test_kmalloc_firstfit1+0x21a>
f011694a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116951:	83 ec 0c             	sub    $0xc,%esp
f0116954:	68 07 af 12 f0       	push   $0xf012af07
f0116959:	e8 2d a6 fe ff       	call   f0100f8b <cprintf>
f011695e:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116961:	e8 c0 70 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116966:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116969:	e8 f8 de fe ff       	call   f0104866 <pf_calculate_free_frames>
f011696e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0116971:	83 ec 0c             	sub    $0xc,%esp
f0116974:	68 00 fc 0f 00       	push   $0xffc00
f0116979:	e8 12 24 ff ff       	call   f0108d90 <kmalloc>
f011697e:	83 c4 10             	add    $0x10,%esp
f0116981:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0116984:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116987:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011698c:	74 17                	je     f01169a5 <test_kmalloc_firstfit1+0x25e>
f011698e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116995:	83 ec 0c             	sub    $0xc,%esp
f0116998:	68 20 af 12 f0       	push   $0xf012af20
f011699d:	e8 e9 a5 fe ff       	call   f0100f8b <cprintf>
f01169a2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01169a5:	e8 bc de fe ff       	call   f0104866 <pf_calculate_free_frames>
f01169aa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01169ad:	74 17                	je     f01169c6 <test_kmalloc_firstfit1+0x27f>
f01169af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169b6:	83 ec 0c             	sub    $0xc,%esp
f01169b9:	68 84 a4 12 f0       	push   $0xf012a484
f01169be:	e8 c8 a5 fe ff       	call   f0100f8b <cprintf>
f01169c3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f01169c6:	e8 5b 70 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01169cb:	89 c2                	mov    %eax,%edx
f01169cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01169d0:	29 d0                	sub    %edx,%eax
f01169d2:	3d ff 00 00 00       	cmp    $0xff,%eax
f01169d7:	7f 17                	jg     f01169f0 <test_kmalloc_firstfit1+0x2a9>
f01169d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169e0:	83 ec 0c             	sub    $0xc,%esp
f01169e3:	68 53 af 12 f0       	push   $0xf012af53
f01169e8:	e8 9e a5 fe ff       	call   f0100f8b <cprintf>
f01169ed:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01169f0:	e8 31 70 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01169f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01169f8:	e8 69 de fe ff       	call   f0104866 <pf_calculate_free_frames>
f01169fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0116a00:	83 ec 0c             	sub    $0xc,%esp
f0116a03:	68 00 fc 1f 00       	push   $0x1ffc00
f0116a08:	e8 83 23 ff ff       	call   f0108d90 <kmalloc>
f0116a0d:	83 c4 10             	add    $0x10,%esp
f0116a10:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f0116a13:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116a16:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0116a1b:	74 17                	je     f0116a34 <test_kmalloc_firstfit1+0x2ed>
f0116a1d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a24:	83 ec 0c             	sub    $0xc,%esp
f0116a27:	68 6c af 12 f0       	push   $0xf012af6c
f0116a2c:	e8 5a a5 fe ff       	call   f0100f8b <cprintf>
f0116a31:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116a34:	e8 2d de fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116a39:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116a3c:	74 17                	je     f0116a55 <test_kmalloc_firstfit1+0x30e>
f0116a3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a45:	83 ec 0c             	sub    $0xc,%esp
f0116a48:	68 64 a5 12 f0       	push   $0xf012a564
f0116a4d:	e8 39 a5 fe ff       	call   f0100f8b <cprintf>
f0116a52:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0116a55:	e8 cc 6f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116a5a:	89 c2                	mov    %eax,%edx
f0116a5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116a5f:	29 d0                	sub    %edx,%eax
f0116a61:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116a66:	7f 17                	jg     f0116a7f <test_kmalloc_firstfit1+0x338>
f0116a68:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a6f:	83 ec 0c             	sub    $0xc,%esp
f0116a72:	68 9f af 12 f0       	push   $0xf012af9f
f0116a77:	e8 0f a5 fe ff       	call   f0100f8b <cprintf>
f0116a7c:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116a7f:	e8 a2 6f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116a84:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116a87:	e8 da dd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116a8c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0116a8f:	83 ec 0c             	sub    $0xc,%esp
f0116a92:	68 00 fc 1f 00       	push   $0x1ffc00
f0116a97:	e8 f4 22 ff ff       	call   f0108d90 <kmalloc>
f0116a9c:	83 c4 10             	add    $0x10,%esp
f0116a9f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0116aa2:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116aa5:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0116aaa:	74 17                	je     f0116ac3 <test_kmalloc_firstfit1+0x37c>
f0116aac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ab3:	83 ec 0c             	sub    $0xc,%esp
f0116ab6:	68 b8 af 12 f0       	push   $0xf012afb8
f0116abb:	e8 cb a4 fe ff       	call   f0100f8b <cprintf>
f0116ac0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116ac3:	e8 9e dd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116ac8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116acb:	74 17                	je     f0116ae4 <test_kmalloc_firstfit1+0x39d>
f0116acd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ad4:	83 ec 0c             	sub    $0xc,%esp
f0116ad7:	68 68 a6 12 f0       	push   $0xf012a668
f0116adc:	e8 aa a4 fe ff       	call   f0100f8b <cprintf>
f0116ae1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0116ae4:	e8 3d 6f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116ae9:	89 c2                	mov    %eax,%edx
f0116aeb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116aee:	29 d0                	sub    %edx,%eax
f0116af0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116af5:	7f 17                	jg     f0116b0e <test_kmalloc_firstfit1+0x3c7>
f0116af7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116afe:	83 ec 0c             	sub    $0xc,%esp
f0116b01:	68 eb af 12 f0       	push   $0xf012afeb
f0116b06:	e8 80 a4 fe ff       	call   f0100f8b <cprintf>
f0116b0b:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116b0e:	e8 13 6f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116b13:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116b16:	e8 4b dd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116b1b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0116b1e:	83 ec 0c             	sub    $0xc,%esp
f0116b21:	68 00 fc 2f 00       	push   $0x2ffc00
f0116b26:	e8 65 22 ff ff       	call   f0108d90 <kmalloc>
f0116b2b:	83 c4 10             	add    $0x10,%esp
f0116b2e:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0116b31:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116b34:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0116b39:	74 17                	je     f0116b52 <test_kmalloc_firstfit1+0x40b>
f0116b3b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b42:	83 ec 0c             	sub    $0xc,%esp
f0116b45:	68 04 b0 12 f0       	push   $0xf012b004
f0116b4a:	e8 3c a4 fe ff       	call   f0100f8b <cprintf>
f0116b4f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116b52:	e8 0f dd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116b57:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116b5a:	74 17                	je     f0116b73 <test_kmalloc_firstfit1+0x42c>
f0116b5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b63:	83 ec 0c             	sub    $0xc,%esp
f0116b66:	68 6c a7 12 f0       	push   $0xf012a76c
f0116b6b:	e8 1b a4 fe ff       	call   f0100f8b <cprintf>
f0116b70:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0116b73:	e8 ae 6e ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116b78:	89 c2                	mov    %eax,%edx
f0116b7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116b7d:	29 d0                	sub    %edx,%eax
f0116b7f:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116b84:	7f 17                	jg     f0116b9d <test_kmalloc_firstfit1+0x456>
f0116b86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b8d:	83 ec 0c             	sub    $0xc,%esp
f0116b90:	68 37 b0 12 f0       	push   $0xf012b037
f0116b95:	e8 f1 a3 fe ff       	call   f0100f8b <cprintf>
f0116b9a:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116b9d:	e8 84 6e ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116ba2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ba5:	e8 bc dc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116baa:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0116bad:	83 ec 0c             	sub    $0xc,%esp
f0116bb0:	68 00 fc 2f 00       	push   $0x2ffc00
f0116bb5:	e8 d6 21 ff ff       	call   f0108d90 <kmalloc>
f0116bba:	83 c4 10             	add    $0x10,%esp
f0116bbd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0116bc0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116bc3:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0116bc8:	74 17                	je     f0116be1 <test_kmalloc_firstfit1+0x49a>
f0116bca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116bd1:	83 ec 0c             	sub    $0xc,%esp
f0116bd4:	68 50 b0 12 f0       	push   $0xf012b050
f0116bd9:	e8 ad a3 fe ff       	call   f0100f8b <cprintf>
f0116bde:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116be1:	e8 80 dc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116be6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116be9:	74 17                	je     f0116c02 <test_kmalloc_firstfit1+0x4bb>
f0116beb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116bf2:	83 ec 0c             	sub    $0xc,%esp
f0116bf5:	68 70 a8 12 f0       	push   $0xf012a870
f0116bfa:	e8 8c a3 fe ff       	call   f0100f8b <cprintf>
f0116bff:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0116c02:	e8 1f 6e ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116c07:	89 c2                	mov    %eax,%edx
f0116c09:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c0c:	29 d0                	sub    %edx,%eax
f0116c0e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116c13:	7f 17                	jg     f0116c2c <test_kmalloc_firstfit1+0x4e5>
f0116c15:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c1c:	83 ec 0c             	sub    $0xc,%esp
f0116c1f:	68 83 b0 12 f0       	push   $0xf012b083
f0116c24:	e8 62 a3 fe ff       	call   f0100f8b <cprintf>
f0116c29:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116c2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116c30:	74 04                	je     f0116c36 <test_kmalloc_firstfit1+0x4ef>
f0116c32:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0116c36:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0116c3d:	83 ec 0c             	sub    $0xc,%esp
f0116c40:	68 9c b0 12 f0       	push   $0xf012b09c
f0116c45:	e8 41 a3 fe ff       	call   f0100f8b <cprintf>
f0116c4a:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116c4d:	e8 d4 6d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116c55:	e8 0c dc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116c5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0116c5d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116c60:	83 ec 0c             	sub    $0xc,%esp
f0116c63:	50                   	push   %eax
f0116c64:	e8 3d 23 ff ff       	call   f0108fa6 <kfree>
f0116c69:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116c6c:	e8 f5 db fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116c71:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116c74:	74 17                	je     f0116c8d <test_kmalloc_firstfit1+0x546>
f0116c76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c7d:	83 ec 0c             	sub    $0xc,%esp
f0116c80:	68 c4 b0 12 f0       	push   $0xf012b0c4
f0116c85:	e8 01 a3 fe ff       	call   f0100f8b <cprintf>
f0116c8a:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0116c8d:	e8 94 6d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116c92:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116c95:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116c9a:	7f 17                	jg     f0116cb3 <test_kmalloc_firstfit1+0x56c>
f0116c9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ca3:	83 ec 0c             	sub    $0xc,%esp
f0116ca6:	68 2f b1 12 f0       	push   $0xf012b12f
f0116cab:	e8 db a2 fe ff       	call   f0100f8b <cprintf>
f0116cb0:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116cb3:	e8 6e 6d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116cb8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116cbb:	e8 a6 db fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116cc0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0116cc3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116cc6:	83 ec 0c             	sub    $0xc,%esp
f0116cc9:	50                   	push   %eax
f0116cca:	e8 d7 22 ff ff       	call   f0108fa6 <kfree>
f0116ccf:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116cd2:	e8 8f db fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116cd7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116cda:	74 17                	je     f0116cf3 <test_kmalloc_firstfit1+0x5ac>
f0116cdc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ce3:	83 ec 0c             	sub    $0xc,%esp
f0116ce6:	68 40 b1 12 f0       	push   $0xf012b140
f0116ceb:	e8 9b a2 fe ff       	call   f0100f8b <cprintf>
f0116cf0:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f0116cf3:	e8 2e 6d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116cf8:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116cfb:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116d00:	7f 17                	jg     f0116d19 <test_kmalloc_firstfit1+0x5d2>
f0116d02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d09:	83 ec 0c             	sub    $0xc,%esp
f0116d0c:	68 ac b1 12 f0       	push   $0xf012b1ac
f0116d11:	e8 75 a2 fe ff       	call   f0100f8b <cprintf>
f0116d16:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116d19:	e8 08 6d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116d1e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116d21:	e8 40 db fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116d26:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0116d29:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116d2c:	83 ec 0c             	sub    $0xc,%esp
f0116d2f:	50                   	push   %eax
f0116d30:	e8 71 22 ff ff       	call   f0108fa6 <kfree>
f0116d35:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116d38:	e8 29 db fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116d3d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116d40:	74 17                	je     f0116d59 <test_kmalloc_firstfit1+0x612>
f0116d42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d49:	83 ec 0c             	sub    $0xc,%esp
f0116d4c:	68 c0 b1 12 f0       	push   $0xf012b1c0
f0116d51:	e8 35 a2 fe ff       	call   f0100f8b <cprintf>
f0116d56:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f0116d59:	e8 c8 6c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116d5e:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116d61:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116d66:	7f 17                	jg     f0116d7f <test_kmalloc_firstfit1+0x638>
f0116d68:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d6f:	83 ec 0c             	sub    $0xc,%esp
f0116d72:	68 2c b2 12 f0       	push   $0xf012b22c
f0116d77:	e8 0f a2 fe ff       	call   f0100f8b <cprintf>
f0116d7c:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116d7f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116d83:	74 04                	je     f0116d89 <test_kmalloc_firstfit1+0x642>
f0116d85:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0116d89:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f0116d90:	83 ec 0c             	sub    $0xc,%esp
f0116d93:	68 40 b2 12 f0       	push   $0xf012b240
f0116d98:	e8 ee a1 fe ff       	call   f0100f8b <cprintf>
f0116d9d:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116da0:	e8 81 6c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116da5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116da8:	e8 b9 da fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116dad:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0116db0:	83 ec 0c             	sub    $0xc,%esp
f0116db3:	68 00 fc 07 00       	push   $0x7fc00
f0116db8:	e8 d3 1f ff ff       	call   f0108d90 <kmalloc>
f0116dbd:	83 c4 10             	add    $0x10,%esp
f0116dc0:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0116dc3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116dc6:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0116dcb:	74 17                	je     f0116de4 <test_kmalloc_firstfit1+0x69d>
f0116dcd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116dd4:	83 ec 0c             	sub    $0xc,%esp
f0116dd7:	68 6c b2 12 f0       	push   $0xf012b26c
f0116ddc:	e8 aa a1 fe ff       	call   f0100f8b <cprintf>
f0116de1:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116de4:	e8 7d da fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116de9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116dec:	74 17                	je     f0116e05 <test_kmalloc_firstfit1+0x6be>
f0116dee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116df5:	83 ec 0c             	sub    $0xc,%esp
f0116df8:	68 a0 b2 12 f0       	push   $0xf012b2a0
f0116dfd:	e8 89 a1 fe ff       	call   f0100f8b <cprintf>
f0116e02:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0116e05:	e8 1c 6c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116e0a:	89 c2                	mov    %eax,%edx
f0116e0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116e0f:	29 d0                	sub    %edx,%eax
f0116e11:	83 f8 7f             	cmp    $0x7f,%eax
f0116e14:	7f 17                	jg     f0116e2d <test_kmalloc_firstfit1+0x6e6>
f0116e16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e1d:	83 ec 0c             	sub    $0xc,%esp
f0116e20:	68 0c b3 12 f0       	push   $0xf012b30c
f0116e25:	e8 61 a1 fe ff       	call   f0100f8b <cprintf>
f0116e2a:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116e2d:	e8 f4 6b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116e32:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116e35:	e8 2c da fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116e3a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f0116e3d:	83 ec 0c             	sub    $0xc,%esp
f0116e40:	68 00 fc 0f 00       	push   $0xffc00
f0116e45:	e8 46 1f ff ff       	call   f0108d90 <kmalloc>
f0116e4a:	83 c4 10             	add    $0x10,%esp
f0116e4d:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0116e50:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116e53:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0116e58:	74 17                	je     f0116e71 <test_kmalloc_firstfit1+0x72a>
f0116e5a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e61:	83 ec 0c             	sub    $0xc,%esp
f0116e64:	68 24 b3 12 f0       	push   $0xf012b324
f0116e69:	e8 1d a1 fe ff       	call   f0100f8b <cprintf>
f0116e6e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116e71:	e8 f0 d9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116e76:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116e79:	74 17                	je     f0116e92 <test_kmalloc_firstfit1+0x74b>
f0116e7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e82:	83 ec 0c             	sub    $0xc,%esp
f0116e85:	68 58 b3 12 f0       	push   $0xf012b358
f0116e8a:	e8 fc a0 fe ff       	call   f0100f8b <cprintf>
f0116e8f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f0116e92:	e8 8f 6b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116e97:	89 c2                	mov    %eax,%edx
f0116e99:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116e9c:	29 d0                	sub    %edx,%eax
f0116e9e:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116ea3:	7f 17                	jg     f0116ebc <test_kmalloc_firstfit1+0x775>
f0116ea5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116eac:	83 ec 0c             	sub    $0xc,%esp
f0116eaf:	68 c4 b3 12 f0       	push   $0xf012b3c4
f0116eb4:	e8 d2 a0 fe ff       	call   f0100f8b <cprintf>
f0116eb9:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116ebc:	e8 65 6b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116ec1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ec4:	e8 9d d9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116ec9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0116ecc:	83 ec 0c             	sub    $0xc,%esp
f0116ecf:	68 00 fc 03 00       	push   $0x3fc00
f0116ed4:	e8 b7 1e ff ff       	call   f0108d90 <kmalloc>
f0116ed9:	83 c4 10             	add    $0x10,%esp
f0116edc:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0116edf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116ee2:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0116ee7:	74 17                	je     f0116f00 <test_kmalloc_firstfit1+0x7b9>
f0116ee9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ef0:	83 ec 0c             	sub    $0xc,%esp
f0116ef3:	68 dc b3 12 f0       	push   $0xf012b3dc
f0116ef8:	e8 8e a0 fe ff       	call   f0100f8b <cprintf>
f0116efd:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116f00:	e8 61 d9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116f05:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116f08:	74 17                	je     f0116f21 <test_kmalloc_firstfit1+0x7da>
f0116f0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f11:	83 ec 0c             	sub    $0xc,%esp
f0116f14:	68 10 b4 12 f0       	push   $0xf012b410
f0116f19:	e8 6d a0 fe ff       	call   f0100f8b <cprintf>
f0116f1e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0116f21:	e8 00 6b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116f26:	89 c2                	mov    %eax,%edx
f0116f28:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116f2b:	29 d0                	sub    %edx,%eax
f0116f2d:	83 f8 3f             	cmp    $0x3f,%eax
f0116f30:	7f 17                	jg     f0116f49 <test_kmalloc_firstfit1+0x802>
f0116f32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f39:	83 ec 0c             	sub    $0xc,%esp
f0116f3c:	68 7c b4 12 f0       	push   $0xf012b47c
f0116f41:	e8 45 a0 fe ff       	call   f0100f8b <cprintf>
f0116f46:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116f49:	e8 d8 6a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116f4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116f51:	e8 10 d9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116f56:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0116f59:	83 ec 0c             	sub    $0xc,%esp
f0116f5c:	68 00 00 20 00       	push   $0x200000
f0116f61:	e8 2a 1e ff ff       	call   f0108d90 <kmalloc>
f0116f66:	83 c4 10             	add    $0x10,%esp
f0116f69:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f0116f6c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116f6f:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0116f74:	74 17                	je     f0116f8d <test_kmalloc_firstfit1+0x846>
f0116f76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f7d:	83 ec 0c             	sub    $0xc,%esp
f0116f80:	68 94 b4 12 f0       	push   $0xf012b494
f0116f85:	e8 01 a0 fe ff       	call   f0100f8b <cprintf>
f0116f8a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f0116f8d:	e8 94 6a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116f92:	89 c2                	mov    %eax,%edx
f0116f94:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116f97:	29 d0                	sub    %edx,%eax
f0116f99:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116f9e:	7f 17                	jg     f0116fb7 <test_kmalloc_firstfit1+0x870>
f0116fa0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fa7:	83 ec 0c             	sub    $0xc,%esp
f0116faa:	68 c8 b4 12 f0       	push   $0xf012b4c8
f0116faf:	e8 d7 9f fe ff       	call   f0100f8b <cprintf>
f0116fb4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116fb7:	e8 aa d8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116fbc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116fbf:	74 17                	je     f0116fd8 <test_kmalloc_firstfit1+0x891>
f0116fc1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fc8:	83 ec 0c             	sub    $0xc,%esp
f0116fcb:	68 e0 b4 12 f0       	push   $0xf012b4e0
f0116fd0:	e8 b6 9f fe ff       	call   f0100f8b <cprintf>
f0116fd5:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0116fd8:	e8 49 6a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0116fdd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116fe0:	e8 81 d8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0116fe5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0116fe8:	83 ec 0c             	sub    $0xc,%esp
f0116feb:	68 00 fc 3f 00       	push   $0x3ffc00
f0116ff0:	e8 9b 1d ff ff       	call   f0108d90 <kmalloc>
f0116ff5:	83 c4 10             	add    $0x10,%esp
f0116ff8:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0116ffb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0116ffe:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f0117003:	74 17                	je     f011701c <test_kmalloc_firstfit1+0x8d5>
f0117005:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011700c:	83 ec 0c             	sub    $0xc,%esp
f011700f:	68 4c b5 12 f0       	push   $0xf012b54c
f0117014:	e8 72 9f fe ff       	call   f0100f8b <cprintf>
f0117019:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011701c:	e8 45 d8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117021:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117024:	74 17                	je     f011703d <test_kmalloc_firstfit1+0x8f6>
f0117026:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011702d:	83 ec 0c             	sub    $0xc,%esp
f0117030:	68 80 b5 12 f0       	push   $0xf012b580
f0117035:	e8 51 9f fe ff       	call   f0100f8b <cprintf>
f011703a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f011703d:	e8 e4 69 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117042:	89 c2                	mov    %eax,%edx
f0117044:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117047:	29 d0                	sub    %edx,%eax
f0117049:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f011704e:	7f 17                	jg     f0117067 <test_kmalloc_firstfit1+0x920>
f0117050:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117057:	83 ec 0c             	sub    $0xc,%esp
f011705a:	68 ec b5 12 f0       	push   $0xf012b5ec
f011705f:	e8 27 9f fe ff       	call   f0100f8b <cprintf>
f0117064:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117067:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011706b:	74 04                	je     f0117071 <test_kmalloc_firstfit1+0x92a>
f011706d:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0117071:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f0117078:	83 ec 0c             	sub    $0xc,%esp
f011707b:	68 04 b6 12 f0       	push   $0xf012b604
f0117080:	e8 06 9f fe ff       	call   f0100f8b <cprintf>
f0117085:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117088:	e8 99 69 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011708d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117090:	e8 d1 d7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117095:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0117098:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011709b:	83 ec 0c             	sub    $0xc,%esp
f011709e:	50                   	push   %eax
f011709f:	e8 02 1f ff ff       	call   f0108fa6 <kfree>
f01170a4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01170a7:	e8 ba d7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01170ac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01170af:	74 17                	je     f01170c8 <test_kmalloc_firstfit1+0x981>
f01170b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170b8:	83 ec 0c             	sub    $0xc,%esp
f01170bb:	68 b0 ab 12 f0       	push   $0xf012abb0
f01170c0:	e8 c6 9e fe ff       	call   f0100f8b <cprintf>
f01170c5:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f01170c8:	e8 59 69 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01170cd:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01170d0:	3d ff 00 00 00       	cmp    $0xff,%eax
f01170d5:	7f 17                	jg     f01170ee <test_kmalloc_firstfit1+0x9a7>
f01170d7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170de:	83 ec 0c             	sub    $0xc,%esp
f01170e1:	68 38 b6 12 f0       	push   $0xf012b638
f01170e6:	e8 a0 9e fe ff       	call   f0100f8b <cprintf>
f01170eb:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f01170ee:	e8 33 69 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01170f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01170f6:	e8 6b d7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01170fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f01170fe:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117101:	83 ec 0c             	sub    $0xc,%esp
f0117104:	50                   	push   %eax
f0117105:	e8 9c 1e ff ff       	call   f0108fa6 <kfree>
f011710a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011710d:	e8 54 d7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117112:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117115:	74 17                	je     f011712e <test_kmalloc_firstfit1+0x9e7>
f0117117:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011711e:	83 ec 0c             	sub    $0xc,%esp
f0117121:	68 8c ac 12 f0       	push   $0xf012ac8c
f0117126:	e8 60 9e fe ff       	call   f0100f8b <cprintf>
f011712b:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f011712e:	e8 f3 68 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117133:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117136:	3d ff 00 00 00       	cmp    $0xff,%eax
f011713b:	7f 17                	jg     f0117154 <test_kmalloc_firstfit1+0xa0d>
f011713d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117144:	83 ec 0c             	sub    $0xc,%esp
f0117147:	68 49 b6 12 f0       	push   $0xf012b649
f011714c:	e8 3a 9e fe ff       	call   f0100f8b <cprintf>
f0117151:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117154:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117158:	74 04                	je     f011715e <test_kmalloc_firstfit1+0xa17>
f011715a:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011715e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f0117165:	83 ec 0c             	sub    $0xc,%esp
f0117168:	68 5c b6 12 f0       	push   $0xf012b65c
f011716d:	e8 19 9e fe ff       	call   f0100f8b <cprintf>
f0117172:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0117175:	e8 ac 68 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011717a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011717d:	e8 e4 d6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117182:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0117185:	83 ec 0c             	sub    $0xc,%esp
f0117188:	68 00 00 10 00       	push   $0x100000
f011718d:	e8 fe 1b ff ff       	call   f0108d90 <kmalloc>
f0117192:	83 c4 10             	add    $0x10,%esp
f0117195:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0117198:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011719b:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f01171a0:	74 17                	je     f01171b9 <test_kmalloc_firstfit1+0xa72>
f01171a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171a9:	83 ec 0c             	sub    $0xc,%esp
f01171ac:	68 9c b6 12 f0       	push   $0xf012b69c
f01171b1:	e8 d5 9d fe ff       	call   f0100f8b <cprintf>
f01171b6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01171b9:	e8 a8 d6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01171be:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01171c1:	74 17                	je     f01171da <test_kmalloc_firstfit1+0xa93>
f01171c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171ca:	83 ec 0c             	sub    $0xc,%esp
f01171cd:	68 d0 b6 12 f0       	push   $0xf012b6d0
f01171d2:	e8 b4 9d fe ff       	call   f0100f8b <cprintf>
f01171d7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f01171da:	e8 47 68 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01171df:	89 c2                	mov    %eax,%edx
f01171e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01171e4:	29 d0                	sub    %edx,%eax
f01171e6:	3d ff 00 00 00       	cmp    $0xff,%eax
f01171eb:	7f 17                	jg     f0117204 <test_kmalloc_firstfit1+0xabd>
f01171ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171f4:	83 ec 0c             	sub    $0xc,%esp
f01171f7:	68 3c b7 12 f0       	push   $0xf012b73c
f01171fc:	e8 8a 9d fe ff       	call   f0100f8b <cprintf>
f0117201:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0117204:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117208:	74 04                	je     f011720e <test_kmalloc_firstfit1+0xac7>
f011720a:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f011720e:	83 ec 08             	sub    $0x8,%esp
f0117211:	ff 75 f4             	pushl  -0xc(%ebp)
f0117214:	68 54 b7 12 f0       	push   $0xf012b754
f0117219:	e8 6d 9d fe ff       	call   f0100f8b <cprintf>
f011721e:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117221:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117226:	8b 7d fc             	mov    -0x4(%ebp),%edi
f0117229:	c9                   	leave  
f011722a:	c3                   	ret    

f011722b <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f011722b:	55                   	push   %ebp
f011722c:	89 e5                	mov    %esp,%ebp
f011722e:	57                   	push   %edi
f011722f:	53                   	push   %ebx
f0117230:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117233:	83 ec 0c             	sub    $0xc,%esp
f0117236:	68 28 9f 12 f0       	push   $0xf0129f28
f011723b:	e8 4b 9d fe ff       	call   f0100f8b <cprintf>
f0117240:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117243:	83 ec 0c             	sub    $0xc,%esp
f0117246:	68 58 9f 12 f0       	push   $0xf0129f58
f011724b:	e8 3b 9d fe ff       	call   f0100f8b <cprintf>
f0117250:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117253:	83 ec 0c             	sub    $0xc,%esp
f0117256:	68 28 9f 12 f0       	push   $0xf0129f28
f011725b:	e8 2b 9d fe ff       	call   f0100f8b <cprintf>
f0117260:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117263:	8d 55 98             	lea    -0x68(%ebp),%edx
f0117266:	b9 14 00 00 00       	mov    $0x14,%ecx
f011726b:	b8 00 00 00 00       	mov    $0x0,%eax
f0117270:	89 d7                	mov    %edx,%edi
f0117272:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117274:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011727b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117282:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0117289:	83 ec 0c             	sub    $0xc,%esp
f011728c:	68 8c b7 12 f0       	push   $0xf012b78c
f0117291:	e8 f5 9c fe ff       	call   f0100f8b <cprintf>
f0117296:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0117299:	83 ec 0c             	sub    $0xc,%esp
f011729c:	68 01 e0 ff 07       	push   $0x7ffe001
f01172a1:	e8 ea 1a ff ff       	call   f0108d90 <kmalloc>
f01172a6:	83 c4 10             	add    $0x10,%esp
f01172a9:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f01172ac:	8b 45 98             	mov    -0x68(%ebp),%eax
f01172af:	85 c0                	test   %eax,%eax
f01172b1:	74 17                	je     f01172ca <test_kmalloc_firstfit2+0x9f>
f01172b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172ba:	83 ec 0c             	sub    $0xc,%esp
f01172bd:	68 c0 b7 12 f0       	push   $0xf012b7c0
f01172c2:	e8 c4 9c fe ff       	call   f0100f8b <cprintf>
f01172c7:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01172ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01172ce:	74 04                	je     f01172d4 <test_kmalloc_firstfit2+0xa9>
f01172d0:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01172d4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f01172db:	83 ec 0c             	sub    $0xc,%esp
f01172de:	68 08 b8 12 f0       	push   $0xf012b808
f01172e3:	e8 a3 9c fe ff       	call   f0100f8b <cprintf>
f01172e8:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01172eb:	e8 36 67 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01172f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01172f3:	e8 6e d5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01172f8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f01172fb:	83 ec 0c             	sub    $0xc,%esp
f01172fe:	68 00 fc 1f 00       	push   $0x1ffc00
f0117303:	e8 88 1a ff ff       	call   f0108d90 <kmalloc>
f0117308:	83 c4 10             	add    $0x10,%esp
f011730b:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f011730e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117311:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117316:	74 17                	je     f011732f <test_kmalloc_firstfit2+0x104>
f0117318:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011731f:	83 ec 0c             	sub    $0xc,%esp
f0117322:	68 88 ae 12 f0       	push   $0xf012ae88
f0117327:	e8 5f 9c fe ff       	call   f0100f8b <cprintf>
f011732c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011732f:	e8 32 d5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117334:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117337:	74 17                	je     f0117350 <test_kmalloc_firstfit2+0x125>
f0117339:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117340:	83 ec 0c             	sub    $0xc,%esp
f0117343:	68 50 a2 12 f0       	push   $0xf012a250
f0117348:	e8 3e 9c fe ff       	call   f0100f8b <cprintf>
f011734d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117350:	e8 d1 66 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117355:	89 c2                	mov    %eax,%edx
f0117357:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011735a:	29 d0                	sub    %edx,%eax
f011735c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117361:	7f 17                	jg     f011737a <test_kmalloc_firstfit2+0x14f>
f0117363:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011736a:	83 ec 0c             	sub    $0xc,%esp
f011736d:	68 bb ae 12 f0       	push   $0xf012aebb
f0117372:	e8 14 9c fe ff       	call   f0100f8b <cprintf>
f0117377:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011737a:	e8 a7 66 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011737f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117382:	e8 df d4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117387:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011738a:	83 ec 0c             	sub    $0xc,%esp
f011738d:	68 00 fc 1f 00       	push   $0x1ffc00
f0117392:	e8 f9 19 ff ff       	call   f0108d90 <kmalloc>
f0117397:	83 c4 10             	add    $0x10,%esp
f011739a:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f011739d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01173a0:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01173a5:	74 17                	je     f01173be <test_kmalloc_firstfit2+0x193>
f01173a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173ae:	83 ec 0c             	sub    $0xc,%esp
f01173b1:	68 d4 ae 12 f0       	push   $0xf012aed4
f01173b6:	e8 d0 9b fe ff       	call   f0100f8b <cprintf>
f01173bb:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01173be:	e8 a3 d4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01173c3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01173c6:	74 17                	je     f01173df <test_kmalloc_firstfit2+0x1b4>
f01173c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173cf:	83 ec 0c             	sub    $0xc,%esp
f01173d2:	68 8c a3 12 f0       	push   $0xf012a38c
f01173d7:	e8 af 9b fe ff       	call   f0100f8b <cprintf>
f01173dc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01173df:	e8 42 66 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01173e4:	89 c2                	mov    %eax,%edx
f01173e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01173e9:	29 d0                	sub    %edx,%eax
f01173eb:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01173f0:	7f 17                	jg     f0117409 <test_kmalloc_firstfit2+0x1de>
f01173f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173f9:	83 ec 0c             	sub    $0xc,%esp
f01173fc:	68 07 af 12 f0       	push   $0xf012af07
f0117401:	e8 85 9b fe ff       	call   f0100f8b <cprintf>
f0117406:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117409:	e8 18 66 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011740e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117411:	e8 50 d4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117416:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0117419:	83 ec 0c             	sub    $0xc,%esp
f011741c:	68 00 1c 00 00       	push   $0x1c00
f0117421:	e8 6a 19 ff ff       	call   f0108d90 <kmalloc>
f0117426:	83 c4 10             	add    $0x10,%esp
f0117429:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f011742c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011742f:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117434:	74 17                	je     f011744d <test_kmalloc_firstfit2+0x222>
f0117436:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011743d:	83 ec 0c             	sub    $0xc,%esp
f0117440:	68 20 af 12 f0       	push   $0xf012af20
f0117445:	e8 41 9b fe ff       	call   f0100f8b <cprintf>
f011744a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011744d:	e8 14 d4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117452:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117455:	74 17                	je     f011746e <test_kmalloc_firstfit2+0x243>
f0117457:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011745e:	83 ec 0c             	sub    $0xc,%esp
f0117461:	68 84 a4 12 f0       	push   $0xf012a484
f0117466:	e8 20 9b fe ff       	call   f0100f8b <cprintf>
f011746b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f011746e:	e8 b3 65 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117473:	89 c2                	mov    %eax,%edx
f0117475:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117478:	29 d0                	sub    %edx,%eax
f011747a:	83 f8 01             	cmp    $0x1,%eax
f011747d:	7f 17                	jg     f0117496 <test_kmalloc_firstfit2+0x26b>
f011747f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117486:	83 ec 0c             	sub    $0xc,%esp
f0117489:	68 53 af 12 f0       	push   $0xf012af53
f011748e:	e8 f8 9a fe ff       	call   f0100f8b <cprintf>
f0117493:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117496:	e8 8b 65 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011749b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011749e:	e8 c3 d3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01174a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f01174a6:	8b 45 98             	mov    -0x68(%ebp),%eax
f01174a9:	83 ec 0c             	sub    $0xc,%esp
f01174ac:	50                   	push   %eax
f01174ad:	e8 f4 1a ff ff       	call   f0108fa6 <kfree>
f01174b2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01174b5:	e8 ac d3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01174ba:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01174bd:	74 17                	je     f01174d6 <test_kmalloc_firstfit2+0x2ab>
f01174bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174c6:	83 ec 0c             	sub    $0xc,%esp
f01174c9:	68 64 a5 12 f0       	push   $0xf012a564
f01174ce:	e8 b8 9a fe ff       	call   f0100f8b <cprintf>
f01174d3:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f01174d6:	e8 4b 65 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01174db:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01174de:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01174e3:	7f 17                	jg     f01174fc <test_kmalloc_firstfit2+0x2d1>
f01174e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174ec:	83 ec 0c             	sub    $0xc,%esp
f01174ef:	68 4e b8 12 f0       	push   $0xf012b84e
f01174f4:	e8 92 9a fe ff       	call   f0100f8b <cprintf>
f01174f9:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01174fc:	e8 25 65 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117501:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117504:	e8 5d d3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117509:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011750c:	83 ec 0c             	sub    $0xc,%esp
f011750f:	68 00 fc 2f 00       	push   $0x2ffc00
f0117514:	e8 77 18 ff ff       	call   f0108d90 <kmalloc>
f0117519:	83 c4 10             	add    $0x10,%esp
f011751c:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f011751f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117522:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0117527:	74 17                	je     f0117540 <test_kmalloc_firstfit2+0x315>
f0117529:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117530:	83 ec 0c             	sub    $0xc,%esp
f0117533:	68 b8 af 12 f0       	push   $0xf012afb8
f0117538:	e8 4e 9a fe ff       	call   f0100f8b <cprintf>
f011753d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117540:	e8 21 d3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117545:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117548:	74 17                	je     f0117561 <test_kmalloc_firstfit2+0x336>
f011754a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117551:	83 ec 0c             	sub    $0xc,%esp
f0117554:	68 68 a6 12 f0       	push   $0xf012a668
f0117559:	e8 2d 9a fe ff       	call   f0100f8b <cprintf>
f011755e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117561:	e8 c0 64 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117566:	89 c2                	mov    %eax,%edx
f0117568:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011756b:	29 d0                	sub    %edx,%eax
f011756d:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117572:	7f 17                	jg     f011758b <test_kmalloc_firstfit2+0x360>
f0117574:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011757b:	83 ec 0c             	sub    $0xc,%esp
f011757e:	68 eb af 12 f0       	push   $0xf012afeb
f0117583:	e8 03 9a fe ff       	call   f0100f8b <cprintf>
f0117588:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011758b:	e8 96 64 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117590:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117593:	e8 ce d2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117598:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f011759b:	83 ec 0c             	sub    $0xc,%esp
f011759e:	68 00 18 20 00       	push   $0x201800
f01175a3:	e8 e8 17 ff ff       	call   f0108d90 <kmalloc>
f01175a8:	83 c4 10             	add    $0x10,%esp
f01175ab:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f01175ae:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01175b1:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01175b6:	74 17                	je     f01175cf <test_kmalloc_firstfit2+0x3a4>
f01175b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175bf:	83 ec 0c             	sub    $0xc,%esp
f01175c2:	68 04 b0 12 f0       	push   $0xf012b004
f01175c7:	e8 bf 99 fe ff       	call   f0100f8b <cprintf>
f01175cc:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01175cf:	e8 92 d2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01175d4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01175d7:	74 17                	je     f01175f0 <test_kmalloc_firstfit2+0x3c5>
f01175d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175e0:	83 ec 0c             	sub    $0xc,%esp
f01175e3:	68 6c a7 12 f0       	push   $0xf012a76c
f01175e8:	e8 9e 99 fe ff       	call   f0100f8b <cprintf>
f01175ed:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f01175f0:	e8 31 64 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01175f5:	89 c2                	mov    %eax,%edx
f01175f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01175fa:	29 d0                	sub    %edx,%eax
f01175fc:	3d 01 02 00 00       	cmp    $0x201,%eax
f0117601:	7f 17                	jg     f011761a <test_kmalloc_firstfit2+0x3ef>
f0117603:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011760a:	83 ec 0c             	sub    $0xc,%esp
f011760d:	68 37 b0 12 f0       	push   $0xf012b037
f0117612:	e8 74 99 fe ff       	call   f0100f8b <cprintf>
f0117617:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011761a:	e8 07 64 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011761f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117622:	e8 3f d2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117627:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f011762a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011762d:	83 ec 0c             	sub    $0xc,%esp
f0117630:	50                   	push   %eax
f0117631:	e8 70 19 ff ff       	call   f0108fa6 <kfree>
f0117636:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117639:	e8 28 d2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011763e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117641:	74 17                	je     f011765a <test_kmalloc_firstfit2+0x42f>
f0117643:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011764a:	83 ec 0c             	sub    $0xc,%esp
f011764d:	68 70 a8 12 f0       	push   $0xf012a870
f0117652:	e8 34 99 fe ff       	call   f0100f8b <cprintf>
f0117657:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f011765a:	e8 c7 63 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011765f:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117662:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117667:	7f 17                	jg     f0117680 <test_kmalloc_firstfit2+0x455>
f0117669:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117670:	83 ec 0c             	sub    $0xc,%esp
f0117673:	68 5e b8 12 f0       	push   $0xf012b85e
f0117678:	e8 0e 99 fe ff       	call   f0100f8b <cprintf>
f011767d:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0117680:	e8 a1 63 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117685:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117688:	e8 d9 d1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011768d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0117690:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117693:	83 ec 0c             	sub    $0xc,%esp
f0117696:	50                   	push   %eax
f0117697:	e8 0a 19 ff ff       	call   f0108fa6 <kfree>
f011769c:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f011769f:	e8 82 63 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01176a4:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01176a7:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01176ac:	7f 17                	jg     f01176c5 <test_kmalloc_firstfit2+0x49a>
f01176ae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176b5:	83 ec 0c             	sub    $0xc,%esp
f01176b8:	68 2f b1 12 f0       	push   $0xf012b12f
f01176bd:	e8 c9 98 fe ff       	call   f0100f8b <cprintf>
f01176c2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01176c5:	e8 9c d1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01176ca:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01176cd:	74 17                	je     f01176e6 <test_kmalloc_firstfit2+0x4bb>
f01176cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176d6:	83 ec 0c             	sub    $0xc,%esp
f01176d9:	68 c4 b0 12 f0       	push   $0xf012b0c4
f01176de:	e8 a8 98 fe ff       	call   f0100f8b <cprintf>
f01176e3:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01176e6:	e8 3b 63 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01176eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01176ee:	e8 73 d1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01176f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f01176f6:	83 ec 0c             	sub    $0xc,%esp
f01176f9:	68 00 fc 4f 00       	push   $0x4ffc00
f01176fe:	e8 8d 16 ff ff       	call   f0108d90 <kmalloc>
f0117703:	83 c4 10             	add    $0x10,%esp
f0117706:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f0117709:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011770c:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0117711:	74 17                	je     f011772a <test_kmalloc_firstfit2+0x4ff>
f0117713:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011771a:	83 ec 0c             	sub    $0xc,%esp
f011771d:	68 70 b8 12 f0       	push   $0xf012b870
f0117722:	e8 64 98 fe ff       	call   f0100f8b <cprintf>
f0117727:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011772a:	e8 37 d1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011772f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117732:	74 17                	je     f011774b <test_kmalloc_firstfit2+0x520>
f0117734:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011773b:	83 ec 0c             	sub    $0xc,%esp
f011773e:	68 40 b1 12 f0       	push   $0xf012b140
f0117743:	e8 43 98 fe ff       	call   f0100f8b <cprintf>
f0117748:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f011774b:	e8 d6 62 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117750:	89 c2                	mov    %eax,%edx
f0117752:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117755:	29 d0                	sub    %edx,%eax
f0117757:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f011775c:	7f 17                	jg     f0117775 <test_kmalloc_firstfit2+0x54a>
f011775e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117765:	83 ec 0c             	sub    $0xc,%esp
f0117768:	68 a4 b8 12 f0       	push   $0xf012b8a4
f011776d:	e8 19 98 fe ff       	call   f0100f8b <cprintf>
f0117772:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0117775:	e8 ac 62 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011777a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011777d:	e8 e4 d0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117782:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0117785:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117788:	83 ec 0c             	sub    $0xc,%esp
f011778b:	50                   	push   %eax
f011778c:	e8 15 18 ff ff       	call   f0108fa6 <kfree>
f0117791:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117794:	e8 cd d0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117799:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011779c:	74 17                	je     f01177b5 <test_kmalloc_firstfit2+0x58a>
f011779e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177a5:	83 ec 0c             	sub    $0xc,%esp
f01177a8:	68 c0 b1 12 f0       	push   $0xf012b1c0
f01177ad:	e8 d9 97 fe ff       	call   f0100f8b <cprintf>
f01177b2:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f01177b5:	e8 6c 62 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01177ba:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01177bd:	83 f8 01             	cmp    $0x1,%eax
f01177c0:	7f 17                	jg     f01177d9 <test_kmalloc_firstfit2+0x5ae>
f01177c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177c9:	83 ec 0c             	sub    $0xc,%esp
f01177cc:	68 2c b2 12 f0       	push   $0xf012b22c
f01177d1:	e8 b5 97 fe ff       	call   f0100f8b <cprintf>
f01177d6:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f01177d9:	e8 48 62 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01177de:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01177e1:	e8 80 d0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01177e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f01177e9:	83 ec 0c             	sub    $0xc,%esp
f01177ec:	68 00 04 00 00       	push   $0x400
f01177f1:	e8 9a 15 ff ff       	call   f0108d90 <kmalloc>
f01177f6:	83 c4 10             	add    $0x10,%esp
f01177f9:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01177fc:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01177ff:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117804:	76 22                	jbe    f0117828 <test_kmalloc_firstfit2+0x5fd>
f0117806:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f0117809:	83 ec 0c             	sub    $0xc,%esp
f011780c:	6a 00                	push   $0x0
f011780e:	e8 8e 14 ff ff       	call   f0108ca1 <sbrk>
f0117813:	83 c4 10             	add    $0x10,%esp
f0117816:	39 c3                	cmp    %eax,%ebx
f0117818:	73 0e                	jae    f0117828 <test_kmalloc_firstfit2+0x5fd>
f011781a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011781d:	89 c2                	mov    %eax,%edx
f011781f:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f0117824:	39 c2                	cmp    %eax,%edx
f0117826:	72 17                	jb     f011783f <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0117828:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011782f:	83 ec 0c             	sub    $0xc,%esp
f0117832:	68 bc b8 12 f0       	push   $0xf012b8bc
f0117837:	e8 4f 97 fe ff       	call   f0100f8b <cprintf>
f011783c:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011783f:	e8 22 d0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117844:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117847:	74 17                	je     f0117860 <test_kmalloc_firstfit2+0x635>
f0117849:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117850:	83 ec 0c             	sub    $0xc,%esp
f0117853:	68 a0 b2 12 f0       	push   $0xf012b2a0
f0117858:	e8 2e 97 fe ff       	call   f0100f8b <cprintf>
f011785d:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117860:	e8 01 d0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117865:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0117868:	83 ec 0c             	sub    $0xc,%esp
f011786b:	68 00 08 00 00       	push   $0x800
f0117870:	e8 1b 15 ff ff       	call   f0108d90 <kmalloc>
f0117875:	83 c4 10             	add    $0x10,%esp
f0117878:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011787b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011787e:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117883:	76 22                	jbe    f01178a7 <test_kmalloc_firstfit2+0x67c>
f0117885:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0117888:	83 ec 0c             	sub    $0xc,%esp
f011788b:	6a 00                	push   $0x0
f011788d:	e8 0f 14 ff ff       	call   f0108ca1 <sbrk>
f0117892:	83 c4 10             	add    $0x10,%esp
f0117895:	39 c3                	cmp    %eax,%ebx
f0117897:	73 0e                	jae    f01178a7 <test_kmalloc_firstfit2+0x67c>
f0117899:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011789c:	89 c2                	mov    %eax,%edx
f011789e:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f01178a3:	39 c2                	cmp    %eax,%edx
f01178a5:	72 17                	jb     f01178be <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01178a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178ae:	83 ec 0c             	sub    $0xc,%esp
f01178b1:	68 48 b9 12 f0       	push   $0xf012b948
f01178b6:	e8 d0 96 fe ff       	call   f0100f8b <cprintf>
f01178bb:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01178be:	e8 a3 cf fe ff       	call   f0104866 <pf_calculate_free_frames>
f01178c3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01178c6:	74 17                	je     f01178df <test_kmalloc_firstfit2+0x6b4>
f01178c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178cf:	83 ec 0c             	sub    $0xc,%esp
f01178d2:	68 58 b3 12 f0       	push   $0xf012b358
f01178d7:	e8 af 96 fe ff       	call   f0100f8b <cprintf>
f01178dc:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01178df:	e8 82 cf fe ff       	call   f0104866 <pf_calculate_free_frames>
f01178e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f01178e7:	83 ec 0c             	sub    $0xc,%esp
f01178ea:	68 00 04 00 00       	push   $0x400
f01178ef:	e8 9c 14 ff ff       	call   f0108d90 <kmalloc>
f01178f4:	83 c4 10             	add    $0x10,%esp
f01178f7:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f01178fa:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01178fd:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117902:	76 22                	jbe    f0117926 <test_kmalloc_firstfit2+0x6fb>
f0117904:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0117907:	83 ec 0c             	sub    $0xc,%esp
f011790a:	6a 00                	push   $0x0
f011790c:	e8 90 13 ff ff       	call   f0108ca1 <sbrk>
f0117911:	83 c4 10             	add    $0x10,%esp
f0117914:	39 c3                	cmp    %eax,%ebx
f0117916:	73 0e                	jae    f0117926 <test_kmalloc_firstfit2+0x6fb>
f0117918:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011791b:	89 c2                	mov    %eax,%edx
f011791d:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f0117922:	39 c2                	cmp    %eax,%edx
f0117924:	72 17                	jb     f011793d <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0117926:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011792d:	83 ec 0c             	sub    $0xc,%esp
f0117930:	68 d4 b9 12 f0       	push   $0xf012b9d4
f0117935:	e8 51 96 fe ff       	call   f0100f8b <cprintf>
f011793a:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011793d:	e8 24 cf fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117942:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117945:	74 17                	je     f011795e <test_kmalloc_firstfit2+0x733>
f0117947:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011794e:	83 ec 0c             	sub    $0xc,%esp
f0117951:	68 10 b4 12 f0       	push   $0xf012b410
f0117956:	e8 30 96 fe ff       	call   f0100f8b <cprintf>
f011795b:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f011795e:	e8 c3 60 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117963:	89 c2                	mov    %eax,%edx
f0117965:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117968:	29 d0                	sub    %edx,%eax
f011796a:	83 f8 01             	cmp    $0x1,%eax
f011796d:	74 17                	je     f0117986 <test_kmalloc_firstfit2+0x75b>
f011796f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117976:	83 ec 0c             	sub    $0xc,%esp
f0117979:	68 60 ba 12 f0       	push   $0xf012ba60
f011797e:	e8 08 96 fe ff       	call   f0100f8b <cprintf>
f0117983:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0117986:	e8 9b 60 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011798b:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011798e:	e8 d3 ce fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117993:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0117996:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117999:	83 ec 0c             	sub    $0xc,%esp
f011799c:	50                   	push   %eax
f011799d:	e8 04 16 ff ff       	call   f0108fa6 <kfree>
f01179a2:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01179a5:	e8 bc ce fe ff       	call   f0104866 <pf_calculate_free_frames>
f01179aa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01179ad:	74 17                	je     f01179c6 <test_kmalloc_firstfit2+0x79b>
f01179af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179b6:	83 ec 0c             	sub    $0xc,%esp
f01179b9:	68 e0 b4 12 f0       	push   $0xf012b4e0
f01179be:	e8 c8 95 fe ff       	call   f0100f8b <cprintf>
f01179c3:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f01179c6:	e8 5b 60 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01179cb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01179ce:	74 17                	je     f01179e7 <test_kmalloc_firstfit2+0x7bc>
f01179d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179d7:	83 ec 0c             	sub    $0xc,%esp
f01179da:	68 84 ba 12 f0       	push   $0xf012ba84
f01179df:	e8 a7 95 fe ff       	call   f0100f8b <cprintf>
f01179e4:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f01179e7:	e8 3a 60 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01179ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01179ef:	e8 72 ce fe ff       	call   f0104866 <pf_calculate_free_frames>
f01179f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f01179f7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01179fa:	83 ec 0c             	sub    $0xc,%esp
f01179fd:	50                   	push   %eax
f01179fe:	e8 a3 15 ff ff       	call   f0108fa6 <kfree>
f0117a03:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a06:	e8 5b ce fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117a0b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a0e:	74 17                	je     f0117a27 <test_kmalloc_firstfit2+0x7fc>
f0117a10:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a17:	83 ec 0c             	sub    $0xc,%esp
f0117a1a:	68 80 b5 12 f0       	push   $0xf012b580
f0117a1f:	e8 67 95 fe ff       	call   f0100f8b <cprintf>
f0117a24:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0117a27:	e8 fa 5f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117a2c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117a2f:	74 17                	je     f0117a48 <test_kmalloc_firstfit2+0x81d>
f0117a31:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a38:	83 ec 0c             	sub    $0xc,%esp
f0117a3b:	68 e4 ba 12 f0       	push   $0xf012bae4
f0117a40:	e8 46 95 fe ff       	call   f0100f8b <cprintf>
f0117a45:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0117a48:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117a4c:	74 04                	je     f0117a52 <test_kmalloc_firstfit2+0x827>
f0117a4e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0117a52:	83 ec 0c             	sub    $0xc,%esp
f0117a55:	68 44 bb 12 f0       	push   $0xf012bb44
f0117a5a:	e8 2c 95 fe ff       	call   f0100f8b <cprintf>
f0117a5f:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117a62:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a69:	e8 b8 5f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117a6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a71:	e8 f0 cd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117a76:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0117a79:	83 ec 0c             	sub    $0xc,%esp
f0117a7c:	68 00 08 00 00       	push   $0x800
f0117a81:	e8 0a 13 ff ff       	call   f0108d90 <kmalloc>
f0117a86:	83 c4 10             	add    $0x10,%esp
f0117a89:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0117a8c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0117a8f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117a92:	39 c2                	cmp    %eax,%edx
f0117a94:	74 17                	je     f0117aad <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0117a96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a9d:	83 ec 0c             	sub    $0xc,%esp
f0117aa0:	68 7c bb 12 f0       	push   $0xf012bb7c
f0117aa5:	e8 e1 94 fe ff       	call   f0100f8b <cprintf>
f0117aaa:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117aad:	e8 b4 cd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117ab2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ab5:	74 17                	je     f0117ace <test_kmalloc_firstfit2+0x8a3>
f0117ab7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117abe:	83 ec 0c             	sub    $0xc,%esp
f0117ac1:	68 b0 ab 12 f0       	push   $0xf012abb0
f0117ac6:	e8 c0 94 fe ff       	call   f0100f8b <cprintf>
f0117acb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0117ace:	e8 53 5f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117ad3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117ad6:	74 17                	je     f0117aef <test_kmalloc_firstfit2+0x8c4>
f0117ad8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117adf:	83 ec 0c             	sub    $0xc,%esp
f0117ae2:	68 b0 bb 12 f0       	push   $0xf012bbb0
f0117ae7:	e8 9f 94 fe ff       	call   f0100f8b <cprintf>
f0117aec:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117aef:	e8 32 5f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117af4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117af7:	e8 6a cd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117afc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0117aff:	83 ec 0c             	sub    $0xc,%esp
f0117b02:	68 00 04 00 00       	push   $0x400
f0117b07:	e8 84 12 ff ff       	call   f0108d90 <kmalloc>
f0117b0c:	83 c4 10             	add    $0x10,%esp
f0117b0f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0117b12:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117b15:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0117b18:	81 c2 08 08 00 00    	add    $0x808,%edx
f0117b1e:	39 d0                	cmp    %edx,%eax
f0117b20:	74 17                	je     f0117b39 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0117b22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b29:	83 ec 0c             	sub    $0xc,%esp
f0117b2c:	68 c8 bb 12 f0       	push   $0xf012bbc8
f0117b31:	e8 55 94 fe ff       	call   f0100f8b <cprintf>
f0117b36:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b39:	e8 28 cd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117b3e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b41:	74 17                	je     f0117b5a <test_kmalloc_firstfit2+0x92f>
f0117b43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b4a:	83 ec 0c             	sub    $0xc,%esp
f0117b4d:	68 8c ac 12 f0       	push   $0xf012ac8c
f0117b52:	e8 34 94 fe ff       	call   f0100f8b <cprintf>
f0117b57:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0117b5a:	e8 c7 5e ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117b5f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117b62:	74 17                	je     f0117b7b <test_kmalloc_firstfit2+0x950>
f0117b64:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b6b:	83 ec 0c             	sub    $0xc,%esp
f0117b6e:	68 fc bb 12 f0       	push   $0xf012bbfc
f0117b73:	e8 13 94 fe ff       	call   f0100f8b <cprintf>
f0117b78:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0117b7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117b7f:	74 04                	je     f0117b85 <test_kmalloc_firstfit2+0x95a>
f0117b81:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0117b85:	83 ec 0c             	sub    $0xc,%esp
f0117b88:	68 14 bc 12 f0       	push   $0xf012bc14
f0117b8d:	e8 f9 93 fe ff       	call   f0100f8b <cprintf>
f0117b92:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117b95:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b9c:	e8 85 5e ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117ba1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117ba4:	e8 bd cc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117ba9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0117bac:	83 ec 0c             	sub    $0xc,%esp
f0117baf:	68 00 04 70 00       	push   $0x700400
f0117bb4:	e8 d7 11 ff ff       	call   f0108d90 <kmalloc>
f0117bb9:	83 c4 10             	add    $0x10,%esp
f0117bbc:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0117bbf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117bc2:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117bc7:	74 17                	je     f0117be0 <test_kmalloc_firstfit2+0x9b5>
f0117bc9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bd0:	83 ec 0c             	sub    $0xc,%esp
f0117bd3:	68 9c b6 12 f0       	push   $0xf012b69c
f0117bd8:	e8 ae 93 fe ff       	call   f0100f8b <cprintf>
f0117bdd:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117be0:	e8 81 cc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117be5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117be8:	74 17                	je     f0117c01 <test_kmalloc_firstfit2+0x9d6>
f0117bea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bf1:	83 ec 0c             	sub    $0xc,%esp
f0117bf4:	68 d0 b6 12 f0       	push   $0xf012b6d0
f0117bf9:	e8 8d 93 fe ff       	call   f0100f8b <cprintf>
f0117bfe:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0117c01:	e8 20 5e ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117c06:	89 c2                	mov    %eax,%edx
f0117c08:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c0b:	29 d0                	sub    %edx,%eax
f0117c0d:	3d 00 07 00 00       	cmp    $0x700,%eax
f0117c12:	7f 17                	jg     f0117c2b <test_kmalloc_firstfit2+0xa00>
f0117c14:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c1b:	83 ec 0c             	sub    $0xc,%esp
f0117c1e:	68 3c b7 12 f0       	push   $0xf012b73c
f0117c23:	e8 63 93 fe ff       	call   f0100f8b <cprintf>
f0117c28:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c2b:	e8 f6 5d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117c30:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c33:	e8 2e cc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117c38:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f0117c3b:	83 ec 0c             	sub    $0xc,%esp
f0117c3e:	68 00 0c 00 00       	push   $0xc00
f0117c43:	e8 48 11 ff ff       	call   f0108d90 <kmalloc>
f0117c48:	83 c4 10             	add    $0x10,%esp
f0117c4b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0117c4e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117c51:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f0117c56:	74 17                	je     f0117c6f <test_kmalloc_firstfit2+0xa44>
f0117c58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c5f:	83 ec 0c             	sub    $0xc,%esp
f0117c62:	68 48 bc 12 f0       	push   $0xf012bc48
f0117c67:	e8 1f 93 fe ff       	call   f0100f8b <cprintf>
f0117c6c:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c6f:	e8 f2 cb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117c74:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c77:	74 17                	je     f0117c90 <test_kmalloc_firstfit2+0xa65>
f0117c79:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c80:	83 ec 0c             	sub    $0xc,%esp
f0117c83:	68 7c bc 12 f0       	push   $0xf012bc7c
f0117c88:	e8 fe 92 fe ff       	call   f0100f8b <cprintf>
f0117c8d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0117c90:	e8 91 5d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117c95:	89 c2                	mov    %eax,%edx
f0117c97:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c9a:	29 d0                	sub    %edx,%eax
f0117c9c:	85 c0                	test   %eax,%eax
f0117c9e:	7f 17                	jg     f0117cb7 <test_kmalloc_firstfit2+0xa8c>
f0117ca0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ca7:	83 ec 0c             	sub    $0xc,%esp
f0117caa:	68 e8 bc 12 f0       	push   $0xf012bce8
f0117caf:	e8 d7 92 fe ff       	call   f0100f8b <cprintf>
f0117cb4:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0117cb7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117cbb:	74 04                	je     f0117cc1 <test_kmalloc_firstfit2+0xa96>
f0117cbd:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0117cc1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0117cc8:	83 ec 0c             	sub    $0xc,%esp
f0117ccb:	68 00 bd 12 f0       	push   $0xf012bd00
f0117cd0:	e8 b6 92 fe ff       	call   f0100f8b <cprintf>
f0117cd5:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f0117cd8:	83 ec 0c             	sub    $0xc,%esp
f0117cdb:	68 00 e0 1f 07       	push   $0x71fe000
f0117ce0:	e8 ab 10 ff ff       	call   f0108d90 <kmalloc>
f0117ce5:	83 c4 10             	add    $0x10,%esp
f0117ce8:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0117ceb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117cee:	85 c0                	test   %eax,%eax
f0117cf0:	74 17                	je     f0117d09 <test_kmalloc_firstfit2+0xade>
f0117cf2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cf9:	83 ec 0c             	sub    $0xc,%esp
f0117cfc:	68 54 bd 12 f0       	push   $0xf012bd54
f0117d01:	e8 85 92 fe ff       	call   f0100f8b <cprintf>
f0117d06:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0117d09:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117d0d:	74 04                	je     f0117d13 <test_kmalloc_firstfit2+0xae8>
f0117d0f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f0117d13:	83 ec 08             	sub    $0x8,%esp
f0117d16:	ff 75 f4             	pushl  -0xc(%ebp)
f0117d19:	68 bc bd 12 f0       	push   $0xf012bdbc
f0117d1e:	e8 68 92 fe ff       	call   f0100f8b <cprintf>
f0117d23:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117d26:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117d2b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0117d2e:	5b                   	pop    %ebx
f0117d2f:	5f                   	pop    %edi
f0117d30:	5d                   	pop    %ebp
f0117d31:	c3                   	ret    

f0117d32 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0117d32:	55                   	push   %ebp
f0117d33:	89 e5                	mov    %esp,%ebp
f0117d35:	53                   	push   %ebx
f0117d36:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117d39:	83 ec 0c             	sub    $0xc,%esp
f0117d3c:	68 28 9f 12 f0       	push   $0xf0129f28
f0117d41:	e8 45 92 fe ff       	call   f0100f8b <cprintf>
f0117d46:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117d49:	83 ec 0c             	sub    $0xc,%esp
f0117d4c:	68 58 9f 12 f0       	push   $0xf0129f58
f0117d51:	e8 35 92 fe ff       	call   f0100f8b <cprintf>
f0117d56:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117d59:	83 ec 0c             	sub    $0xc,%esp
f0117d5c:	68 28 9f 12 f0       	push   $0xf0129f28
f0117d61:	e8 25 92 fe ff       	call   f0100f8b <cprintf>
f0117d66:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f0117d69:	e8 b8 5c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117d6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f0117d71:	e8 f0 ca fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117d76:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0117d79:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f0117d80:	83 ec 0c             	sub    $0xc,%esp
f0117d83:	68 f1 bd 12 f0       	push   $0xf012bdf1
f0117d88:	e8 fe 91 fe ff       	call   f0100f8b <cprintf>
f0117d8d:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f0117d90:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0117d95:	ba 00 00 00 00       	mov    $0x0,%edx
f0117d9a:	f7 75 e4             	divl   -0x1c(%ebp)
f0117d9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f0117da0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0117da7:	eb 1d                	jmp    f0117dc6 <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0117da9:	83 ec 0c             	sub    $0xc,%esp
f0117dac:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117daf:	e8 dc 0f ff ff       	call   f0108d90 <kmalloc>
f0117db4:	83 c4 10             	add    $0x10,%esp
f0117db7:	89 c2                	mov    %eax,%edx
f0117db9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117dbc:	89 14 85 60 c0 5c f0 	mov    %edx,-0xfa33fa0(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0117dc3:	ff 45 f4             	incl   -0xc(%ebp)
f0117dc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117dc9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0117dcc:	7c db                	jl     f0117da9 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0117dce:	83 ec 0c             	sub    $0xc,%esp
f0117dd1:	68 f5 bd 12 f0       	push   $0xf012bdf5
f0117dd6:	e8 b0 91 fe ff       	call   f0100f8b <cprintf>
f0117ddb:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0117dde:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0117de3:	ba 00 00 00 00       	mov    $0x0,%edx
f0117de8:	f7 75 e4             	divl   -0x1c(%ebp)
f0117deb:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0117dee:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117df2:	74 1e                	je     f0117e12 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0117df4:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0117df7:	8d 43 01             	lea    0x1(%ebx),%eax
f0117dfa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0117dfd:	83 ec 0c             	sub    $0xc,%esp
f0117e00:	ff 75 e0             	pushl  -0x20(%ebp)
f0117e03:	e8 88 0f ff ff       	call   f0108d90 <kmalloc>
f0117e08:	83 c4 10             	add    $0x10,%esp
f0117e0b:	89 04 9d 60 c0 5c f0 	mov    %eax,-0xfa33fa0(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0117e12:	83 ec 04             	sub    $0x4,%esp
f0117e15:	ff 75 f0             	pushl  -0x10(%ebp)
f0117e18:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117e1b:	68 fc bd 12 f0       	push   $0xf012bdfc
f0117e20:	e8 66 91 fe ff       	call   f0100f8b <cprintf>
f0117e25:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0117e28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0117e2f:	eb 36                	jmp    f0117e67 <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0117e31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117e34:	8b 04 85 60 c0 5c f0 	mov    -0xfa33fa0(,%eax,4),%eax
f0117e3b:	89 c2                	mov    %eax,%edx
f0117e3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117e40:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0117e44:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0117e49:	39 c2                	cmp    %eax,%edx
f0117e4b:	74 17                	je     f0117e64 <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0117e4d:	83 ec 04             	sub    $0x4,%esp
f0117e50:	68 44 be 12 f0       	push   $0xf012be44
f0117e55:	68 e4 02 00 00       	push   $0x2e4
f0117e5a:	68 87 be 12 f0       	push   $0xf012be87
f0117e5f:	e8 d5 84 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0117e64:	ff 45 f4             	incl   -0xc(%ebp)
f0117e67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117e6a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0117e6d:	7c c2                	jl     f0117e31 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117e6f:	e8 f2 c9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117e74:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e77:	74 17                	je     f0117e90 <test_fastfirstfit+0x15e>
f0117e79:	83 ec 04             	sub    $0x4,%esp
f0117e7c:	68 a0 be 12 f0       	push   $0xf012bea0
f0117e81:	68 e7 02 00 00       	push   $0x2e7
f0117e86:	68 87 be 12 f0       	push   $0xf012be87
f0117e8b:	e8 a9 84 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0117e90:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0117e93:	e8 8e 5b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117e98:	29 c3                	sub    %eax,%ebx
f0117e9a:	89 d8                	mov    %ebx,%eax
f0117e9c:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0117ea1:	77 17                	ja     f0117eba <test_fastfirstfit+0x188>
f0117ea3:	83 ec 04             	sub    $0x4,%esp
f0117ea6:	68 08 bf 12 f0       	push   $0xf012bf08
f0117eab:	68 e8 02 00 00       	push   $0x2e8
f0117eb0:	68 87 be 12 f0       	push   $0xf012be87
f0117eb5:	e8 7f 84 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0117eba:	e8 a7 c9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117ebf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0117ec2:	e8 5f 5b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0117eca:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0117ece:	7f 17                	jg     f0117ee7 <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0117ed0:	83 ec 04             	sub    $0x4,%esp
f0117ed3:	68 1c bf 12 f0       	push   $0xf012bf1c
f0117ed8:	68 ef 02 00 00       	push   $0x2ef
f0117edd:	68 87 be 12 f0       	push   $0xf012be87
f0117ee2:	e8 52 84 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f0117ee7:	a1 60 c0 5c f0       	mov    0xf05cc060,%eax
f0117eec:	83 ec 0c             	sub    $0xc,%esp
f0117eef:	50                   	push   %eax
f0117ef0:	e8 b1 10 ff ff       	call   f0108fa6 <kfree>
f0117ef5:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f0117ef8:	a1 68 c0 5c f0       	mov    0xf05cc068,%eax
f0117efd:	83 ec 0c             	sub    $0xc,%esp
f0117f00:	50                   	push   %eax
f0117f01:	e8 a0 10 ff ff       	call   f0108fa6 <kfree>
f0117f06:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0117f09:	a1 6c c0 5c f0       	mov    0xf05cc06c,%eax
f0117f0e:	83 ec 0c             	sub    $0xc,%esp
f0117f11:	50                   	push   %eax
f0117f12:	e8 8f 10 ff ff       	call   f0108fa6 <kfree>
f0117f17:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f0117f1a:	a1 74 c0 5c f0       	mov    0xf05cc074,%eax
f0117f1f:	83 ec 0c             	sub    $0xc,%esp
f0117f22:	50                   	push   %eax
f0117f23:	e8 7e 10 ff ff       	call   f0108fa6 <kfree>
f0117f28:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f0117f2b:	a1 88 c0 5c f0       	mov    0xf05cc088,%eax
f0117f30:	83 ec 0c             	sub    $0xc,%esp
f0117f33:	50                   	push   %eax
f0117f34:	e8 6d 10 ff ff       	call   f0108fa6 <kfree>
f0117f39:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f0117f3c:	a1 90 c0 5c f0       	mov    0xf05cc090,%eax
f0117f41:	83 ec 0c             	sub    $0xc,%esp
f0117f44:	50                   	push   %eax
f0117f45:	e8 5c 10 ff ff       	call   f0108fa6 <kfree>
f0117f4a:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f0117f4d:	a1 8c c0 5c f0       	mov    0xf05cc08c,%eax
f0117f52:	83 ec 0c             	sub    $0xc,%esp
f0117f55:	50                   	push   %eax
f0117f56:	e8 4b 10 ff ff       	call   f0108fa6 <kfree>
f0117f5b:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f0117f5e:	a1 b0 c0 5c f0       	mov    0xf05cc0b0,%eax
f0117f63:	83 ec 0c             	sub    $0xc,%esp
f0117f66:	50                   	push   %eax
f0117f67:	e8 3a 10 ff ff       	call   f0108fa6 <kfree>
f0117f6c:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f0117f6f:	a1 c4 c0 5c f0       	mov    0xf05cc0c4,%eax
f0117f74:	83 ec 0c             	sub    $0xc,%esp
f0117f77:	50                   	push   %eax
f0117f78:	e8 29 10 ff ff       	call   f0108fa6 <kfree>
f0117f7d:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f0117f80:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117f83:	83 e8 02             	sub    $0x2,%eax
f0117f86:	8b 04 85 60 c0 5c f0 	mov    -0xfa33fa0(,%eax,4),%eax
f0117f8d:	83 ec 0c             	sub    $0xc,%esp
f0117f90:	50                   	push   %eax
f0117f91:	e8 10 10 ff ff       	call   f0108fa6 <kfree>
f0117f96:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0117f99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117f9c:	83 e8 03             	sub    $0x3,%eax
f0117f9f:	8b 04 85 60 c0 5c f0 	mov    -0xfa33fa0(,%eax,4),%eax
f0117fa6:	83 ec 0c             	sub    $0xc,%esp
f0117fa9:	50                   	push   %eax
f0117faa:	e8 f7 0f ff ff       	call   f0108fa6 <kfree>
f0117faf:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117fb2:	e8 af c8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0117fb7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117fba:	74 17                	je     f0117fd3 <test_fastfirstfit+0x2a1>
f0117fbc:	83 ec 04             	sub    $0x4,%esp
f0117fbf:	68 a0 be 12 f0       	push   $0xf012bea0
f0117fc4:	68 fc 02 00 00       	push   $0x2fc
f0117fc9:	68 87 be 12 f0       	push   $0xf012be87
f0117fce:	e8 66 83 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f0117fd3:	e8 4e 5a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0117fd8:	89 c2                	mov    %eax,%edx
f0117fda:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117fdd:	89 d1                	mov    %edx,%ecx
f0117fdf:	29 c1                	sub    %eax,%ecx
f0117fe1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0117fe4:	89 d0                	mov    %edx,%eax
f0117fe6:	c1 e0 02             	shl    $0x2,%eax
f0117fe9:	01 d0                	add    %edx,%eax
f0117feb:	01 c0                	add    %eax,%eax
f0117fed:	01 d0                	add    %edx,%eax
f0117fef:	c1 e8 0c             	shr    $0xc,%eax
f0117ff2:	39 c1                	cmp    %eax,%ecx
f0117ff4:	74 17                	je     f011800d <test_fastfirstfit+0x2db>
f0117ff6:	83 ec 04             	sub    $0x4,%esp
f0117ff9:	68 58 bf 12 f0       	push   $0xf012bf58
f0117ffe:	68 fd 02 00 00       	push   $0x2fd
f0118003:	68 87 be 12 f0       	push   $0xf012be87
f0118008:	e8 2c 83 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f011800d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118010:	01 c0                	add    %eax,%eax
f0118012:	89 c2                	mov    %eax,%edx
f0118014:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118017:	d1 e8                	shr    %eax
f0118019:	01 d0                	add    %edx,%eax
f011801b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011801e:	e8 43 c8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118023:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118026:	e8 fb 59 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011802b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011802e:	83 ec 0c             	sub    $0xc,%esp
f0118031:	ff 75 dc             	pushl  -0x24(%ebp)
f0118034:	e8 57 0d ff ff       	call   f0108d90 <kmalloc>
f0118039:	83 c4 10             	add    $0x10,%esp
f011803c:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f011803f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118042:	89 d0                	mov    %edx,%eax
f0118044:	c1 e0 02             	shl    $0x2,%eax
f0118047:	01 d0                	add    %edx,%eax
f0118049:	01 c0                	add    %eax,%eax
f011804b:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118051:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118054:	39 c2                	cmp    %eax,%edx
f0118056:	74 17                	je     f011806f <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f0118058:	83 ec 04             	sub    $0x4,%esp
f011805b:	68 98 bf 12 f0       	push   $0xf012bf98
f0118060:	68 08 03 00 00       	push   $0x308
f0118065:	68 87 be 12 f0       	push   $0xf012be87
f011806a:	e8 ca 82 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011806f:	e8 f2 c7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118074:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118077:	74 17                	je     f0118090 <test_fastfirstfit+0x35e>
f0118079:	83 ec 04             	sub    $0x4,%esp
f011807c:	68 a0 be 12 f0       	push   $0xf012bea0
f0118081:	68 09 03 00 00       	push   $0x309
f0118086:	68 87 be 12 f0       	push   $0xf012be87
f011808b:	e8 a9 82 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118090:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118093:	e8 8e 59 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118098:	29 c3                	sub    %eax,%ebx
f011809a:	89 da                	mov    %ebx,%edx
f011809c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011809f:	c1 e8 0c             	shr    $0xc,%eax
f01180a2:	39 c2                	cmp    %eax,%edx
f01180a4:	73 17                	jae    f01180bd <test_fastfirstfit+0x38b>
f01180a6:	83 ec 04             	sub    $0x4,%esp
f01180a9:	68 08 bf 12 f0       	push   $0xf012bf08
f01180ae:	68 0a 03 00 00       	push   $0x30a
f01180b3:	68 87 be 12 f0       	push   $0xf012be87
f01180b8:	e8 7c 82 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f01180bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01180c0:	01 c0                	add    %eax,%eax
f01180c2:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01180c5:	e8 9c c7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01180ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01180cd:	e8 54 59 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01180d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01180d5:	83 ec 0c             	sub    $0xc,%esp
f01180d8:	ff 75 dc             	pushl  -0x24(%ebp)
f01180db:	e8 b0 0c ff ff       	call   f0108d90 <kmalloc>
f01180e0:	83 c4 10             	add    $0x10,%esp
f01180e3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f01180e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01180e9:	05 00 08 00 7c       	add    $0x7c000800,%eax
f01180ee:	01 c0                	add    %eax,%eax
f01180f0:	89 c2                	mov    %eax,%edx
f01180f2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01180f5:	39 c2                	cmp    %eax,%edx
f01180f7:	74 17                	je     f0118110 <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f01180f9:	83 ec 04             	sub    $0x4,%esp
f01180fc:	68 98 bf 12 f0       	push   $0xf012bf98
f0118101:	68 14 03 00 00       	push   $0x314
f0118106:	68 87 be 12 f0       	push   $0xf012be87
f011810b:	e8 29 82 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118110:	e8 51 c7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118115:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118118:	74 17                	je     f0118131 <test_fastfirstfit+0x3ff>
f011811a:	83 ec 04             	sub    $0x4,%esp
f011811d:	68 a0 be 12 f0       	push   $0xf012bea0
f0118122:	68 15 03 00 00       	push   $0x315
f0118127:	68 87 be 12 f0       	push   $0xf012be87
f011812c:	e8 08 82 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118131:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118134:	e8 ed 58 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118139:	29 c3                	sub    %eax,%ebx
f011813b:	89 da                	mov    %ebx,%edx
f011813d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118140:	c1 e8 0c             	shr    $0xc,%eax
f0118143:	39 c2                	cmp    %eax,%edx
f0118145:	73 17                	jae    f011815e <test_fastfirstfit+0x42c>
f0118147:	83 ec 04             	sub    $0x4,%esp
f011814a:	68 08 bf 12 f0       	push   $0xf012bf08
f011814f:	68 16 03 00 00       	push   $0x316
f0118154:	68 87 be 12 f0       	push   $0xf012be87
f0118159:	e8 db 81 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f011815e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118161:	89 c2                	mov    %eax,%edx
f0118163:	01 d2                	add    %edx,%edx
f0118165:	01 d0                	add    %edx,%eax
f0118167:	d1 e8                	shr    %eax
f0118169:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011816c:	e8 f5 c6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118171:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118174:	e8 ad 58 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118179:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011817c:	83 ec 0c             	sub    $0xc,%esp
f011817f:	ff 75 dc             	pushl  -0x24(%ebp)
f0118182:	e8 09 0c ff ff       	call   f0108d90 <kmalloc>
f0118187:	83 c4 10             	add    $0x10,%esp
f011818a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f011818d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118190:	83 e8 03             	sub    $0x3,%eax
f0118193:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118197:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011819d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01181a0:	39 c2                	cmp    %eax,%edx
f01181a2:	74 17                	je     f01181bb <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f01181a4:	83 ec 04             	sub    $0x4,%esp
f01181a7:	68 98 bf 12 f0       	push   $0xf012bf98
f01181ac:	68 20 03 00 00       	push   $0x320
f01181b1:	68 87 be 12 f0       	push   $0xf012be87
f01181b6:	e8 7e 81 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01181bb:	e8 a6 c6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01181c0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181c3:	74 17                	je     f01181dc <test_fastfirstfit+0x4aa>
f01181c5:	83 ec 04             	sub    $0x4,%esp
f01181c8:	68 a0 be 12 f0       	push   $0xf012bea0
f01181cd:	68 21 03 00 00       	push   $0x321
f01181d2:	68 87 be 12 f0       	push   $0xf012be87
f01181d7:	e8 5d 81 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01181dc:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01181df:	e8 42 58 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01181e4:	29 c3                	sub    %eax,%ebx
f01181e6:	89 da                	mov    %ebx,%edx
f01181e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01181eb:	c1 e8 0c             	shr    $0xc,%eax
f01181ee:	39 c2                	cmp    %eax,%edx
f01181f0:	73 17                	jae    f0118209 <test_fastfirstfit+0x4d7>
f01181f2:	83 ec 04             	sub    $0x4,%esp
f01181f5:	68 08 bf 12 f0       	push   $0xf012bf08
f01181fa:	68 22 03 00 00       	push   $0x322
f01181ff:	68 87 be 12 f0       	push   $0xf012be87
f0118204:	e8 30 81 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118209:	e8 58 c6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011820e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118211:	e8 10 58 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118216:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118219:	83 ec 0c             	sub    $0xc,%esp
f011821c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011821f:	e8 6c 0b ff ff       	call   f0108d90 <kmalloc>
f0118224:	83 c4 10             	add    $0x10,%esp
f0118227:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f011822a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011822d:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118232:	74 17                	je     f011824b <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0118234:	83 ec 04             	sub    $0x4,%esp
f0118237:	68 98 bf 12 f0       	push   $0xf012bf98
f011823c:	68 2b 03 00 00       	push   $0x32b
f0118241:	68 87 be 12 f0       	push   $0xf012be87
f0118246:	e8 ee 80 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011824b:	e8 16 c6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118250:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118253:	74 17                	je     f011826c <test_fastfirstfit+0x53a>
f0118255:	83 ec 04             	sub    $0x4,%esp
f0118258:	68 a0 be 12 f0       	push   $0xf012bea0
f011825d:	68 2c 03 00 00       	push   $0x32c
f0118262:	68 87 be 12 f0       	push   $0xf012be87
f0118267:	e8 cd 80 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011826c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011826f:	e8 b2 57 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118274:	29 c3                	sub    %eax,%ebx
f0118276:	89 da                	mov    %ebx,%edx
f0118278:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011827b:	c1 e8 0c             	shr    $0xc,%eax
f011827e:	39 c2                	cmp    %eax,%edx
f0118280:	73 17                	jae    f0118299 <test_fastfirstfit+0x567>
f0118282:	83 ec 04             	sub    $0x4,%esp
f0118285:	68 08 bf 12 f0       	push   $0xf012bf08
f011828a:	68 2d 03 00 00       	push   $0x32d
f011828f:	68 87 be 12 f0       	push   $0xf012be87
f0118294:	e8 a0 80 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118299:	e8 c8 c5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011829e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01182a1:	e8 80 57 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01182a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01182a9:	83 ec 0c             	sub    $0xc,%esp
f01182ac:	ff 75 e4             	pushl  -0x1c(%ebp)
f01182af:	e8 dc 0a ff ff       	call   f0108d90 <kmalloc>
f01182b4:	83 c4 10             	add    $0x10,%esp
f01182b7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f01182ba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01182bd:	89 d0                	mov    %edx,%eax
f01182bf:	c1 e0 02             	shl    $0x2,%eax
f01182c2:	01 d0                	add    %edx,%eax
f01182c4:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01182ca:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01182cd:	39 c2                	cmp    %eax,%edx
f01182cf:	74 17                	je     f01182e8 <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f01182d1:	83 ec 04             	sub    $0x4,%esp
f01182d4:	68 98 bf 12 f0       	push   $0xf012bf98
f01182d9:	68 36 03 00 00       	push   $0x336
f01182de:	68 87 be 12 f0       	push   $0xf012be87
f01182e3:	e8 51 80 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01182e8:	e8 79 c5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01182ed:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01182f0:	74 17                	je     f0118309 <test_fastfirstfit+0x5d7>
f01182f2:	83 ec 04             	sub    $0x4,%esp
f01182f5:	68 a0 be 12 f0       	push   $0xf012bea0
f01182fa:	68 37 03 00 00       	push   $0x337
f01182ff:	68 87 be 12 f0       	push   $0xf012be87
f0118304:	e8 30 80 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118309:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011830c:	e8 15 57 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118311:	29 c3                	sub    %eax,%ebx
f0118313:	89 da                	mov    %ebx,%edx
f0118315:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118318:	c1 e8 0c             	shr    $0xc,%eax
f011831b:	39 c2                	cmp    %eax,%edx
f011831d:	73 17                	jae    f0118336 <test_fastfirstfit+0x604>
f011831f:	83 ec 04             	sub    $0x4,%esp
f0118322:	68 08 bf 12 f0       	push   $0xf012bf08
f0118327:	68 38 03 00 00       	push   $0x338
f011832c:	68 87 be 12 f0       	push   $0xf012be87
f0118331:	e8 03 80 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118336:	e8 2b c5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011833b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011833e:	e8 e3 56 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118343:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118346:	83 ec 0c             	sub    $0xc,%esp
f0118349:	ff 75 e4             	pushl  -0x1c(%ebp)
f011834c:	e8 3f 0a ff ff       	call   f0108d90 <kmalloc>
f0118351:	83 c4 10             	add    $0x10,%esp
f0118354:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f0118357:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011835a:	89 d0                	mov    %edx,%eax
f011835c:	c1 e0 02             	shl    $0x2,%eax
f011835f:	01 d0                	add    %edx,%eax
f0118361:	c1 e0 02             	shl    $0x2,%eax
f0118364:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011836a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011836d:	39 c2                	cmp    %eax,%edx
f011836f:	74 17                	je     f0118388 <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f0118371:	83 ec 04             	sub    $0x4,%esp
f0118374:	68 98 bf 12 f0       	push   $0xf012bf98
f0118379:	68 41 03 00 00       	push   $0x341
f011837e:	68 87 be 12 f0       	push   $0xf012be87
f0118383:	e8 b1 7f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118388:	e8 d9 c4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011838d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118390:	74 17                	je     f01183a9 <test_fastfirstfit+0x677>
f0118392:	83 ec 04             	sub    $0x4,%esp
f0118395:	68 a0 be 12 f0       	push   $0xf012bea0
f011839a:	68 42 03 00 00       	push   $0x342
f011839f:	68 87 be 12 f0       	push   $0xf012be87
f01183a4:	e8 90 7f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01183a9:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01183ac:	e8 75 56 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01183b1:	29 c3                	sub    %eax,%ebx
f01183b3:	89 da                	mov    %ebx,%edx
f01183b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01183b8:	c1 e8 0c             	shr    $0xc,%eax
f01183bb:	39 c2                	cmp    %eax,%edx
f01183bd:	73 17                	jae    f01183d6 <test_fastfirstfit+0x6a4>
f01183bf:	83 ec 04             	sub    $0x4,%esp
f01183c2:	68 08 bf 12 f0       	push   $0xf012bf08
f01183c7:	68 43 03 00 00       	push   $0x343
f01183cc:	68 87 be 12 f0       	push   $0xf012be87
f01183d1:	e8 63 7f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01183d6:	e8 8b c4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01183db:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01183de:	e8 43 56 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01183e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01183e6:	83 ec 0c             	sub    $0xc,%esp
f01183e9:	ff 75 e4             	pushl  -0x1c(%ebp)
f01183ec:	e8 9f 09 ff ff       	call   f0108d90 <kmalloc>
f01183f1:	83 c4 10             	add    $0x10,%esp
f01183f4:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f01183f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01183fa:	89 d0                	mov    %edx,%eax
f01183fc:	c1 e0 02             	shl    $0x2,%eax
f01183ff:	01 d0                	add    %edx,%eax
f0118401:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118408:	01 d0                	add    %edx,%eax
f011840a:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118410:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118413:	39 c2                	cmp    %eax,%edx
f0118415:	74 17                	je     f011842e <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f0118417:	83 ec 04             	sub    $0x4,%esp
f011841a:	68 98 bf 12 f0       	push   $0xf012bf98
f011841f:	68 4c 03 00 00       	push   $0x34c
f0118424:	68 87 be 12 f0       	push   $0xf012be87
f0118429:	e8 0b 7f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011842e:	e8 33 c4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118433:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118436:	74 17                	je     f011844f <test_fastfirstfit+0x71d>
f0118438:	83 ec 04             	sub    $0x4,%esp
f011843b:	68 a0 be 12 f0       	push   $0xf012bea0
f0118440:	68 4d 03 00 00       	push   $0x34d
f0118445:	68 87 be 12 f0       	push   $0xf012be87
f011844a:	e8 ea 7e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011844f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118452:	e8 cf 55 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118457:	29 c3                	sub    %eax,%ebx
f0118459:	89 da                	mov    %ebx,%edx
f011845b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011845e:	c1 e8 0c             	shr    $0xc,%eax
f0118461:	39 c2                	cmp    %eax,%edx
f0118463:	73 17                	jae    f011847c <test_fastfirstfit+0x74a>
f0118465:	83 ec 04             	sub    $0x4,%esp
f0118468:	68 08 bf 12 f0       	push   $0xf012bf08
f011846d:	68 4e 03 00 00       	push   $0x34e
f0118472:	68 87 be 12 f0       	push   $0xf012be87
f0118477:	e8 bd 7e fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f011847c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011847f:	d1 e8                	shr    %eax
f0118481:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118484:	e8 dd c3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118489:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011848c:	e8 95 55 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118491:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118494:	83 ec 0c             	sub    $0xc,%esp
f0118497:	ff 75 dc             	pushl  -0x24(%ebp)
f011849a:	e8 f1 08 ff ff       	call   f0108d90 <kmalloc>
f011849f:	83 c4 10             	add    $0x10,%esp
f01184a2:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f01184a5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01184a8:	89 d0                	mov    %edx,%eax
f01184aa:	c1 e0 02             	shl    $0x2,%eax
f01184ad:	01 d0                	add    %edx,%eax
f01184af:	01 c0                	add    %eax,%eax
f01184b1:	89 c1                	mov    %eax,%ecx
f01184b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01184b6:	89 d0                	mov    %edx,%eax
f01184b8:	c1 e0 02             	shl    $0x2,%eax
f01184bb:	01 d0                	add    %edx,%eax
f01184bd:	d1 e8                	shr    %eax
f01184bf:	01 c8                	add    %ecx,%eax
f01184c1:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01184c7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01184ca:	39 c2                	cmp    %eax,%edx
f01184cc:	74 17                	je     f01184e5 <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f01184ce:	83 ec 04             	sub    $0x4,%esp
f01184d1:	68 98 bf 12 f0       	push   $0xf012bf98
f01184d6:	68 58 03 00 00       	push   $0x358
f01184db:	68 87 be 12 f0       	push   $0xf012be87
f01184e0:	e8 54 7e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01184e5:	e8 7c c3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01184ea:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01184ed:	74 17                	je     f0118506 <test_fastfirstfit+0x7d4>
f01184ef:	83 ec 04             	sub    $0x4,%esp
f01184f2:	68 a0 be 12 f0       	push   $0xf012bea0
f01184f7:	68 59 03 00 00       	push   $0x359
f01184fc:	68 87 be 12 f0       	push   $0xf012be87
f0118501:	e8 33 7e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118506:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118509:	e8 18 55 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011850e:	29 c3                	sub    %eax,%ebx
f0118510:	89 da                	mov    %ebx,%edx
f0118512:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118515:	c1 e8 0c             	shr    $0xc,%eax
f0118518:	39 c2                	cmp    %eax,%edx
f011851a:	73 17                	jae    f0118533 <test_fastfirstfit+0x801>
f011851c:	83 ec 04             	sub    $0x4,%esp
f011851f:	68 08 bf 12 f0       	push   $0xf012bf08
f0118524:	68 5a 03 00 00       	push   $0x35a
f0118529:	68 87 be 12 f0       	push   $0xf012be87
f011852e:	e8 06 7e fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0118533:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118536:	d1 e8                	shr    %eax
f0118538:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011853b:	e8 26 c3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118540:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118543:	e8 de 54 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118548:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011854b:	83 ec 0c             	sub    $0xc,%esp
f011854e:	ff 75 dc             	pushl  -0x24(%ebp)
f0118551:	e8 3a 08 ff ff       	call   f0108d90 <kmalloc>
f0118556:	83 c4 10             	add    $0x10,%esp
f0118559:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f011855c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011855f:	83 e8 03             	sub    $0x3,%eax
f0118562:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118566:	89 c2                	mov    %eax,%edx
f0118568:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011856b:	89 c1                	mov    %eax,%ecx
f011856d:	01 c9                	add    %ecx,%ecx
f011856f:	01 c8                	add    %ecx,%eax
f0118571:	d1 e8                	shr    %eax
f0118573:	01 d0                	add    %edx,%eax
f0118575:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011857b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011857e:	39 c2                	cmp    %eax,%edx
f0118580:	74 17                	je     f0118599 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f0118582:	83 ec 04             	sub    $0x4,%esp
f0118585:	68 98 bf 12 f0       	push   $0xf012bf98
f011858a:	68 64 03 00 00       	push   $0x364
f011858f:	68 87 be 12 f0       	push   $0xf012be87
f0118594:	e8 a0 7d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118599:	e8 c8 c2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011859e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01185a1:	74 17                	je     f01185ba <test_fastfirstfit+0x888>
f01185a3:	83 ec 04             	sub    $0x4,%esp
f01185a6:	68 a0 be 12 f0       	push   $0xf012bea0
f01185ab:	68 65 03 00 00       	push   $0x365
f01185b0:	68 87 be 12 f0       	push   $0xf012be87
f01185b5:	e8 7f 7d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01185ba:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01185bd:	e8 64 54 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01185c2:	29 c3                	sub    %eax,%ebx
f01185c4:	89 da                	mov    %ebx,%edx
f01185c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01185c9:	c1 e8 0c             	shr    $0xc,%eax
f01185cc:	39 c2                	cmp    %eax,%edx
f01185ce:	73 17                	jae    f01185e7 <test_fastfirstfit+0x8b5>
f01185d0:	83 ec 04             	sub    $0x4,%esp
f01185d3:	68 08 bf 12 f0       	push   $0xf012bf08
f01185d8:	68 66 03 00 00       	push   $0x366
f01185dd:	68 87 be 12 f0       	push   $0xf012be87
f01185e2:	e8 52 7d fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f01185e7:	83 ec 0c             	sub    $0xc,%esp
f01185ea:	68 b8 bf 12 f0       	push   $0xf012bfb8
f01185ef:	e8 97 89 fe ff       	call   f0100f8b <cprintf>
f01185f4:	83 c4 10             	add    $0x10,%esp
	return 1;
f01185f7:	b8 01 00 00 00       	mov    $0x1,%eax

}
f01185fc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01185ff:	c9                   	leave  
f0118600:	c3                   	ret    

f0118601 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f0118601:	55                   	push   %ebp
f0118602:	89 e5                	mov    %esp,%ebp
f0118604:	57                   	push   %edi
f0118605:	53                   	push   %ebx
f0118606:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011860c:	83 ec 0c             	sub    $0xc,%esp
f011860f:	68 28 9f 12 f0       	push   $0xf0129f28
f0118614:	e8 72 89 fe ff       	call   f0100f8b <cprintf>
f0118619:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011861c:	83 ec 0c             	sub    $0xc,%esp
f011861f:	68 58 9f 12 f0       	push   $0xf0129f58
f0118624:	e8 62 89 fe ff       	call   f0100f8b <cprintf>
f0118629:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011862c:	83 ec 0c             	sub    $0xc,%esp
f011862f:	68 28 9f 12 f0       	push   $0xf0129f28
f0118634:	e8 52 89 fe ff       	call   f0100f8b <cprintf>
f0118639:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011863c:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f0118640:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f0118644:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f011864a:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f0118650:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0118657:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011865e:	e8 c3 53 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118663:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0118666:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f011866c:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118671:	b8 00 00 00 00       	mov    $0x0,%eax
f0118676:	89 d7                	mov    %edx,%edi
f0118678:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011867a:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f0118680:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118685:	b8 00 00 00 00       	mov    $0x0,%eax
f011868a:	89 d7                	mov    %edx,%edi
f011868c:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011868e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f0118695:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f011869c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f01186a3:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f01186a9:	b9 14 00 00 00       	mov    $0x14,%ecx
f01186ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01186b3:	89 d7                	mov    %edx,%edi
f01186b5:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f01186b7:	83 ec 0c             	sub    $0xc,%esp
f01186ba:	68 fc bf 12 f0       	push   $0xf012bffc
f01186bf:	e8 c7 88 fe ff       	call   f0100f8b <cprintf>
f01186c4:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f01186c7:	e8 5a 53 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01186cc:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01186cf:	e8 92 c1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01186d4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f01186d7:	83 ec 0c             	sub    $0xc,%esp
f01186da:	68 00 fc 1f 00       	push   $0x1ffc00
f01186df:	e8 ac 06 ff ff       	call   f0108d90 <kmalloc>
f01186e4:	83 c4 10             	add    $0x10,%esp
f01186e7:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01186ed:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f01186f3:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01186f8:	74 17                	je     f0118711 <test_kfree_bestfirstfit+0x110>
f01186fa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118701:	83 ec 0c             	sub    $0xc,%esp
f0118704:	68 34 c0 12 f0       	push   $0xf012c034
f0118709:	e8 7d 88 fe ff       	call   f0100f8b <cprintf>
f011870e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118711:	e8 50 c1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118716:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118719:	74 17                	je     f0118732 <test_kfree_bestfirstfit+0x131>
f011871b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118722:	83 ec 0c             	sub    $0xc,%esp
f0118725:	68 88 c0 12 f0       	push   $0xf012c088
f011872a:	e8 5c 88 fe ff       	call   f0100f8b <cprintf>
f011872f:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118732:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118735:	e8 ec 52 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011873a:	29 c3                	sub    %eax,%ebx
f011873c:	89 d8                	mov    %ebx,%eax
f011873e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118743:	77 17                	ja     f011875c <test_kfree_bestfirstfit+0x15b>
f0118745:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011874c:	83 ec 0c             	sub    $0xc,%esp
f011874f:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0118754:	e8 32 88 fe ff       	call   f0100f8b <cprintf>
f0118759:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f011875c:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f0118763:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0118766:	e8 bb 52 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011876b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011876e:	e8 f3 c0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118773:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0118776:	83 ec 0c             	sub    $0xc,%esp
f0118779:	68 00 fc 1f 00       	push   $0x1ffc00
f011877e:	e8 0d 06 ff ff       	call   f0108d90 <kmalloc>
f0118783:	83 c4 10             	add    $0x10,%esp
f0118786:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011878c:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0118792:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118797:	74 17                	je     f01187b0 <test_kfree_bestfirstfit+0x1af>
f0118799:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01187a0:	83 ec 0c             	sub    $0xc,%esp
f01187a3:	68 40 c1 12 f0       	push   $0xf012c140
f01187a8:	e8 de 87 fe ff       	call   f0100f8b <cprintf>
f01187ad:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187b0:	e8 b1 c0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01187b5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01187b8:	74 17                	je     f01187d1 <test_kfree_bestfirstfit+0x1d0>
f01187ba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01187c1:	83 ec 0c             	sub    $0xc,%esp
f01187c4:	68 94 c1 12 f0       	push   $0xf012c194
f01187c9:	e8 bd 87 fe ff       	call   f0100f8b <cprintf>
f01187ce:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01187d1:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01187d4:	e8 4d 52 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01187d9:	29 c3                	sub    %eax,%ebx
f01187db:	89 d8                	mov    %ebx,%eax
f01187dd:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01187e2:	77 17                	ja     f01187fb <test_kfree_bestfirstfit+0x1fa>
f01187e4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01187eb:	83 ec 0c             	sub    $0xc,%esp
f01187ee:	68 04 c2 12 f0       	push   $0xf012c204
f01187f3:	e8 93 87 fe ff       	call   f0100f8b <cprintf>
f01187f8:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f01187fb:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f0118802:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f0118805:	e8 1c 52 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011880a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011880d:	e8 54 c0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118812:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f0118815:	83 ec 0c             	sub    $0xc,%esp
f0118818:	68 00 1c 00 00       	push   $0x1c00
f011881d:	e8 6e 05 ff ff       	call   f0108d90 <kmalloc>
f0118822:	83 c4 10             	add    $0x10,%esp
f0118825:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011882b:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0118831:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118836:	74 17                	je     f011884f <test_kfree_bestfirstfit+0x24e>
f0118838:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011883f:	83 ec 0c             	sub    $0xc,%esp
f0118842:	68 4c c2 12 f0       	push   $0xf012c24c
f0118847:	e8 3f 87 fe ff       	call   f0100f8b <cprintf>
f011884c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011884f:	e8 12 c0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118854:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118857:	74 17                	je     f0118870 <test_kfree_bestfirstfit+0x26f>
f0118859:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118860:	83 ec 0c             	sub    $0xc,%esp
f0118863:	68 a0 c2 12 f0       	push   $0xf012c2a0
f0118868:	e8 1e 87 fe ff       	call   f0100f8b <cprintf>
f011886d:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118870:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118873:	e8 ae 51 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118878:	29 c3                	sub    %eax,%ebx
f011887a:	89 d8                	mov    %ebx,%eax
f011887c:	83 f8 01             	cmp    $0x1,%eax
f011887f:	77 17                	ja     f0118898 <test_kfree_bestfirstfit+0x297>
f0118881:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118888:	83 ec 0c             	sub    $0xc,%esp
f011888b:	68 10 c3 12 f0       	push   $0xf012c310
f0118890:	e8 f6 86 fe ff       	call   f0100f8b <cprintf>
f0118895:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f0118898:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f011889f:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f01188a2:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01188a8:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f01188ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01188b2:	eb 0e                	jmp    f01188c2 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f01188b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01188b7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01188ba:	01 d0                	add    %edx,%eax
f01188bc:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f01188bf:	ff 45 f4             	incl   -0xc(%ebp)
f01188c2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01188c8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01188cb:	7f e7                	jg     f01188b4 <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f01188cd:	e8 54 51 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01188d2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01188d5:	e8 8c bf fe ff       	call   f0104866 <pf_calculate_free_frames>
f01188da:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f01188dd:	83 ec 0c             	sub    $0xc,%esp
f01188e0:	68 00 fc 2f 00       	push   $0x2ffc00
f01188e5:	e8 a6 04 ff ff       	call   f0108d90 <kmalloc>
f01188ea:	83 c4 10             	add    $0x10,%esp
f01188ed:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01188f3:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01188f9:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01188fe:	74 17                	je     f0118917 <test_kfree_bestfirstfit+0x316>
f0118900:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118907:	83 ec 0c             	sub    $0xc,%esp
f011890a:	68 58 c3 12 f0       	push   $0xf012c358
f011890f:	e8 77 86 fe ff       	call   f0100f8b <cprintf>
f0118914:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118917:	e8 4a bf fe ff       	call   f0104866 <pf_calculate_free_frames>
f011891c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011891f:	74 17                	je     f0118938 <test_kfree_bestfirstfit+0x337>
f0118921:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118928:	83 ec 0c             	sub    $0xc,%esp
f011892b:	68 ac c3 12 f0       	push   $0xf012c3ac
f0118930:	e8 56 86 fe ff       	call   f0100f8b <cprintf>
f0118935:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118938:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011893b:	e8 e6 50 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118940:	29 c3                	sub    %eax,%ebx
f0118942:	89 d8                	mov    %ebx,%eax
f0118944:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118949:	77 17                	ja     f0118962 <test_kfree_bestfirstfit+0x361>
f011894b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118952:	83 ec 0c             	sub    $0xc,%esp
f0118955:	68 1c c4 12 f0       	push   $0xf012c41c
f011895a:	e8 2c 86 fe ff       	call   f0100f8b <cprintf>
f011895f:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f0118962:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f0118969:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f011896c:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0118972:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f0118975:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011897c:	eb 0e                	jmp    f011898c <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f011897e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118981:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118984:	01 d0                	add    %edx,%eax
f0118986:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0118989:	ff 45 f4             	incl   -0xc(%ebp)
f011898c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0118992:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118995:	7f e7                	jg     f011897e <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0118997:	e8 8a 50 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011899c:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011899f:	e8 c2 be fe ff       	call   f0104866 <pf_calculate_free_frames>
f01189a4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f01189a7:	83 ec 0c             	sub    $0xc,%esp
f01189aa:	68 00 fc 5f 00       	push   $0x5ffc00
f01189af:	e8 dc 03 ff ff       	call   f0108d90 <kmalloc>
f01189b4:	83 c4 10             	add    $0x10,%esp
f01189b7:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01189bd:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f01189c3:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01189c8:	74 17                	je     f01189e1 <test_kfree_bestfirstfit+0x3e0>
f01189ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01189d1:	83 ec 0c             	sub    $0xc,%esp
f01189d4:	68 64 c4 12 f0       	push   $0xf012c464
f01189d9:	e8 ad 85 fe ff       	call   f0100f8b <cprintf>
f01189de:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01189e1:	e8 80 be fe ff       	call   f0104866 <pf_calculate_free_frames>
f01189e6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01189e9:	74 17                	je     f0118a02 <test_kfree_bestfirstfit+0x401>
f01189eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01189f2:	83 ec 0c             	sub    $0xc,%esp
f01189f5:	68 b8 c4 12 f0       	push   $0xf012c4b8
f01189fa:	e8 8c 85 fe ff       	call   f0100f8b <cprintf>
f01189ff:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118a02:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118a05:	e8 1c 50 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118a0a:	29 c3                	sub    %eax,%ebx
f0118a0c:	89 d8                	mov    %ebx,%eax
f0118a0e:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0118a13:	77 17                	ja     f0118a2c <test_kfree_bestfirstfit+0x42b>
f0118a15:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118a1c:	83 ec 0c             	sub    $0xc,%esp
f0118a1f:	68 28 c5 12 f0       	push   $0xf012c528
f0118a24:	e8 62 85 fe ff       	call   f0100f8b <cprintf>
f0118a29:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f0118a2c:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f0118a33:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f0118a36:	e8 eb 4f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118a3b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118a3e:	e8 23 be fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118a43:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0118a46:	83 ec 0c             	sub    $0xc,%esp
f0118a49:	68 00 38 00 00       	push   $0x3800
f0118a4e:	e8 3d 03 ff ff       	call   f0108d90 <kmalloc>
f0118a53:	83 c4 10             	add    $0x10,%esp
f0118a56:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118a5c:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0118a62:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0118a67:	74 17                	je     f0118a80 <test_kfree_bestfirstfit+0x47f>
f0118a69:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118a70:	83 ec 0c             	sub    $0xc,%esp
f0118a73:	68 70 c5 12 f0       	push   $0xf012c570
f0118a78:	e8 0e 85 fe ff       	call   f0100f8b <cprintf>
f0118a7d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a80:	e8 e1 bd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118a85:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118a88:	74 17                	je     f0118aa1 <test_kfree_bestfirstfit+0x4a0>
f0118a8a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118a91:	83 ec 0c             	sub    $0xc,%esp
f0118a94:	68 c4 c5 12 f0       	push   $0xf012c5c4
f0118a99:	e8 ed 84 fe ff       	call   f0100f8b <cprintf>
f0118a9e:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118aa1:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118aa4:	e8 7d 4f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118aa9:	29 c3                	sub    %eax,%ebx
f0118aab:	89 d8                	mov    %ebx,%eax
f0118aad:	83 f8 03             	cmp    $0x3,%eax
f0118ab0:	77 17                	ja     f0118ac9 <test_kfree_bestfirstfit+0x4c8>
f0118ab2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118ab9:	83 ec 0c             	sub    $0xc,%esp
f0118abc:	68 34 c6 12 f0       	push   $0xf012c634
f0118ac1:	e8 c5 84 fe ff       	call   f0100f8b <cprintf>
f0118ac6:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0118ac9:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0118ad0:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0118ad6:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0118ad9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118ae0:	eb 0e                	jmp    f0118af0 <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0118ae2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118ae5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118ae8:	01 d0                	add    %edx,%eax
f0118aea:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0118aed:	ff 45 f4             	incl   -0xc(%ebp)
f0118af0:	8b 45 80             	mov    -0x80(%ebp),%eax
f0118af3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118af6:	7f ea                	jg     f0118ae2 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0118af8:	e8 29 4f ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118afd:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0118b00:	e8 61 bd fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118b05:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0118b08:	83 ec 0c             	sub    $0xc,%esp
f0118b0b:	68 00 08 00 00       	push   $0x800
f0118b10:	e8 7b 02 ff ff       	call   f0108d90 <kmalloc>
f0118b15:	83 c4 10             	add    $0x10,%esp
f0118b18:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118b1e:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118b24:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118b29:	76 28                	jbe    f0118b53 <test_kfree_bestfirstfit+0x552>
f0118b2b:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f0118b31:	83 ec 0c             	sub    $0xc,%esp
f0118b34:	6a 00                	push   $0x0
f0118b36:	e8 66 01 ff ff       	call   f0108ca1 <sbrk>
f0118b3b:	83 c4 10             	add    $0x10,%esp
f0118b3e:	39 c3                	cmp    %eax,%ebx
f0118b40:	73 11                	jae    f0118b53 <test_kfree_bestfirstfit+0x552>
f0118b42:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118b48:	89 c2                	mov    %eax,%edx
f0118b4a:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f0118b4f:	39 c2                	cmp    %eax,%edx
f0118b51:	72 17                	jb     f0118b6a <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118b53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118b5a:	83 ec 0c             	sub    $0xc,%esp
f0118b5d:	68 7c c6 12 f0       	push   $0xf012c67c
f0118b62:	e8 24 84 fe ff       	call   f0100f8b <cprintf>
f0118b67:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b6a:	e8 f7 bc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118b6f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118b72:	74 17                	je     f0118b8b <test_kfree_bestfirstfit+0x58a>
f0118b74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118b7b:	83 ec 0c             	sub    $0xc,%esp
f0118b7e:	68 08 c7 12 f0       	push   $0xf012c708
f0118b83:	e8 03 84 fe ff       	call   f0100f8b <cprintf>
f0118b88:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0118b8b:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0118b92:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0118b95:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118b9b:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0118b9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118ba5:	eb 0e                	jmp    f0118bb5 <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0118ba7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118baa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118bad:	01 d0                	add    %edx,%eax
f0118baf:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0118bb2:	ff 45 f4             	incl   -0xc(%ebp)
f0118bb5:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0118bbb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118bbe:	7f e7                	jg     f0118ba7 <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0118bc0:	e8 a1 bc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118bc5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0118bc8:	83 ec 0c             	sub    $0xc,%esp
f0118bcb:	68 00 08 00 00       	push   $0x800
f0118bd0:	e8 bb 01 ff ff       	call   f0108d90 <kmalloc>
f0118bd5:	83 c4 10             	add    $0x10,%esp
f0118bd8:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0118bde:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0118be4:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118be9:	76 28                	jbe    f0118c13 <test_kfree_bestfirstfit+0x612>
f0118beb:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f0118bf1:	83 ec 0c             	sub    $0xc,%esp
f0118bf4:	6a 00                	push   $0x0
f0118bf6:	e8 a6 00 ff ff       	call   f0108ca1 <sbrk>
f0118bfb:	83 c4 10             	add    $0x10,%esp
f0118bfe:	39 c3                	cmp    %eax,%ebx
f0118c00:	73 11                	jae    f0118c13 <test_kfree_bestfirstfit+0x612>
f0118c02:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0118c08:	89 c2                	mov    %eax,%edx
f0118c0a:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f0118c0f:	39 c2                	cmp    %eax,%edx
f0118c11:	72 17                	jb     f0118c2a <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118c13:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118c1a:	83 ec 0c             	sub    $0xc,%esp
f0118c1d:	68 78 c7 12 f0       	push   $0xf012c778
f0118c22:	e8 64 83 fe ff       	call   f0100f8b <cprintf>
f0118c27:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c2a:	e8 37 bc fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118c2f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118c32:	74 17                	je     f0118c4b <test_kfree_bestfirstfit+0x64a>
f0118c34:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118c3b:	83 ec 0c             	sub    $0xc,%esp
f0118c3e:	68 04 c8 12 f0       	push   $0xf012c804
f0118c43:	e8 43 83 fe ff       	call   f0100f8b <cprintf>
f0118c48:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f0118c4b:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f0118c52:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f0118c55:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0118c5b:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f0118c5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118c65:	eb 0e                	jmp    f0118c75 <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f0118c67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118c6a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118c6d:	01 d0                	add    %edx,%eax
f0118c6f:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f0118c72:	ff 45 f4             	incl   -0xc(%ebp)
f0118c75:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0118c7b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118c7e:	7f e7                	jg     f0118c67 <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f0118c80:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118c83:	e8 9e 4d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118c88:	29 c3                	sub    %eax,%ebx
f0118c8a:	89 d8                	mov    %ebx,%eax
f0118c8c:	83 f8 01             	cmp    $0x1,%eax
f0118c8f:	74 17                	je     f0118ca8 <test_kfree_bestfirstfit+0x6a7>
f0118c91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118c98:	83 ec 0c             	sub    $0xc,%esp
f0118c9b:	68 74 c8 12 f0       	push   $0xf012c874
f0118ca0:	e8 e6 82 fe ff       	call   f0100f8b <cprintf>
f0118ca5:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f0118ca8:	83 ec 0c             	sub    $0xc,%esp
f0118cab:	68 98 c8 12 f0       	push   $0xf012c898
f0118cb0:	e8 d6 82 fe ff       	call   f0100f8b <cprintf>
f0118cb5:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f0118cb8:	e8 69 4d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118cbd:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0118cc0:	e8 a1 bb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118cc5:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f0118cc8:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0118cce:	83 ec 0c             	sub    $0xc,%esp
f0118cd1:	50                   	push   %eax
f0118cd2:	e8 cf 02 ff ff       	call   f0108fa6 <kfree>
f0118cd7:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118cda:	e8 87 bb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118cdf:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118ce2:	74 17                	je     f0118cfb <test_kfree_bestfirstfit+0x6fa>
f0118ce4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118ceb:	83 ec 0c             	sub    $0xc,%esp
f0118cee:	68 c8 c8 12 f0       	push   $0xf012c8c8
f0118cf3:	e8 93 82 fe ff       	call   f0100f8b <cprintf>
f0118cf8:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0118cfb:	e8 26 4d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118d00:	89 c2                	mov    %eax,%edx
f0118d02:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118d05:	29 c2                	sub    %eax,%edx
f0118d07:	89 d0                	mov    %edx,%eax
f0118d09:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118d0e:	77 17                	ja     f0118d27 <test_kfree_bestfirstfit+0x726>
f0118d10:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118d17:	83 ec 0c             	sub    $0xc,%esp
f0118d1a:	68 38 c9 12 f0       	push   $0xf012c938
f0118d1f:	e8 67 82 fe ff       	call   f0100f8b <cprintf>
f0118d24:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f0118d27:	e8 fa 4c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118d2c:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118d2f:	e8 32 bb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118d34:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f0118d37:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118d3d:	83 ec 0c             	sub    $0xc,%esp
f0118d40:	50                   	push   %eax
f0118d41:	e8 60 02 ff ff       	call   f0108fa6 <kfree>
f0118d46:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d49:	e8 18 bb fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118d4e:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118d51:	74 17                	je     f0118d6a <test_kfree_bestfirstfit+0x769>
f0118d53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118d5a:	83 ec 0c             	sub    $0xc,%esp
f0118d5d:	68 74 c9 12 f0       	push   $0xf012c974
f0118d62:	e8 24 82 fe ff       	call   f0100f8b <cprintf>
f0118d67:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118d6a:	e8 b7 4c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118d6f:	89 c2                	mov    %eax,%edx
f0118d71:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118d74:	39 c2                	cmp    %eax,%edx
f0118d76:	74 17                	je     f0118d8f <test_kfree_bestfirstfit+0x78e>
f0118d78:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118d7f:	83 ec 0c             	sub    $0xc,%esp
f0118d82:	68 e4 c9 12 f0       	push   $0xf012c9e4
f0118d87:	e8 ff 81 fe ff       	call   f0100f8b <cprintf>
f0118d8c:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f0118d8f:	e8 92 4c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118d94:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118d97:	e8 ca ba fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118d9c:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f0118d9f:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0118da5:	83 ec 0c             	sub    $0xc,%esp
f0118da8:	50                   	push   %eax
f0118da9:	e8 f8 01 ff ff       	call   f0108fa6 <kfree>
f0118dae:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118db1:	e8 b0 ba fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118db6:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118db9:	74 17                	je     f0118dd2 <test_kfree_bestfirstfit+0x7d1>
f0118dbb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118dc2:	83 ec 0c             	sub    $0xc,%esp
f0118dc5:	68 44 ca 12 f0       	push   $0xf012ca44
f0118dca:	e8 bc 81 fe ff       	call   f0100f8b <cprintf>
f0118dcf:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0118dd2:	e8 4f 4c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118dd7:	89 c2                	mov    %eax,%edx
f0118dd9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118ddc:	29 c2                	sub    %eax,%edx
f0118dde:	89 d0                	mov    %edx,%eax
f0118de0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118de5:	77 17                	ja     f0118dfe <test_kfree_bestfirstfit+0x7fd>
f0118de7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118dee:	83 ec 0c             	sub    $0xc,%esp
f0118df1:	68 b4 ca 12 f0       	push   $0xf012cab4
f0118df6:	e8 90 81 fe ff       	call   f0100f8b <cprintf>
f0118dfb:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f0118dfe:	e8 23 4c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118e03:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118e06:	e8 5b ba fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118e0b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f0118e0e:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0118e14:	83 ec 0c             	sub    $0xc,%esp
f0118e17:	50                   	push   %eax
f0118e18:	e8 89 01 ff ff       	call   f0108fa6 <kfree>
f0118e1d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e20:	e8 41 ba fe ff       	call   f0104866 <pf_calculate_free_frames>
f0118e25:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118e28:	74 17                	je     f0118e41 <test_kfree_bestfirstfit+0x840>
f0118e2a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118e31:	83 ec 0c             	sub    $0xc,%esp
f0118e34:	68 f0 ca 12 f0       	push   $0xf012caf0
f0118e39:	e8 4d 81 fe ff       	call   f0100f8b <cprintf>
f0118e3e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0118e41:	e8 e0 4b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0118e46:	89 c2                	mov    %eax,%edx
f0118e48:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118e4b:	29 c2                	sub    %eax,%edx
f0118e4d:	89 d0                	mov    %edx,%eax
f0118e4f:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0118e54:	77 17                	ja     f0118e6d <test_kfree_bestfirstfit+0x86c>
f0118e56:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118e5d:	83 ec 0c             	sub    $0xc,%esp
f0118e60:	68 60 cb 12 f0       	push   $0xf012cb60
f0118e65:	e8 21 81 fe ff       	call   f0100f8b <cprintf>
f0118e6a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118e6d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118e71:	74 04                	je     f0118e77 <test_kfree_bestfirstfit+0x876>
f0118e73:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0118e77:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f0118e7e:	83 ec 0c             	sub    $0xc,%esp
f0118e81:	68 9c cb 12 f0       	push   $0xf012cb9c
f0118e86:	e8 00 81 fe ff       	call   f0100f8b <cprintf>
f0118e8b:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f0118e8e:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0118e94:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f0118e97:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118e9e:	eb 1e                	jmp    f0118ebe <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f0118ea0:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0118ea6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118ea9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118eac:	01 c8                	add    %ecx,%eax
f0118eae:	8a 00                	mov    (%eax),%al
f0118eb0:	0f be c0             	movsbl %al,%eax
f0118eb3:	01 d0                	add    %edx,%eax
f0118eb5:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f0118ebb:	ff 45 f4             	incl   -0xc(%ebp)
f0118ebe:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0118ec4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118ec7:	7f d7                	jg     f0118ea0 <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f0118ec9:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0118ecf:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0118ed5:	89 c1                	mov    %eax,%ecx
f0118ed7:	01 c9                	add    %ecx,%ecx
f0118ed9:	01 c8                	add    %ecx,%eax
f0118edb:	39 c2                	cmp    %eax,%edx
f0118edd:	74 17                	je     f0118ef6 <test_kfree_bestfirstfit+0x8f5>
f0118edf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118ee6:	83 ec 0c             	sub    $0xc,%esp
f0118ee9:	68 e4 cb 12 f0       	push   $0xf012cbe4
f0118eee:	e8 98 80 fe ff       	call   f0100f8b <cprintf>
f0118ef3:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f0118ef6:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0118efc:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f0118eff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118f06:	eb 1e                	jmp    f0118f26 <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f0118f08:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f0118f0e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118f11:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f14:	01 c8                	add    %ecx,%eax
f0118f16:	8a 00                	mov    (%eax),%al
f0118f18:	0f be c0             	movsbl %al,%eax
f0118f1b:	01 d0                	add    %edx,%eax
f0118f1d:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f0118f23:	ff 45 f4             	incl   -0xc(%ebp)
f0118f26:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0118f2c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118f2f:	7f d7                	jg     f0118f08 <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f0118f31:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0118f37:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f0118f3d:	c1 e2 02             	shl    $0x2,%edx
f0118f40:	39 d0                	cmp    %edx,%eax
f0118f42:	74 17                	je     f0118f5b <test_kfree_bestfirstfit+0x95a>
f0118f44:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118f4b:	83 ec 0c             	sub    $0xc,%esp
f0118f4e:	68 1c cc 12 f0       	push   $0xf012cc1c
f0118f53:	e8 33 80 fe ff       	call   f0100f8b <cprintf>
f0118f58:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f0118f5b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0118f61:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f0118f64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118f6b:	eb 1e                	jmp    f0118f8b <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f0118f6d:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f0118f73:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118f76:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f79:	01 c8                	add    %ecx,%eax
f0118f7b:	8a 00                	mov    (%eax),%al
f0118f7d:	0f be c0             	movsbl %al,%eax
f0118f80:	01 d0                	add    %edx,%eax
f0118f82:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f0118f88:	ff 45 f4             	incl   -0xc(%ebp)
f0118f8b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0118f91:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118f94:	7f d7                	jg     f0118f6d <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f0118f96:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f0118f9c:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0118fa2:	89 d0                	mov    %edx,%eax
f0118fa4:	c1 e0 02             	shl    $0x2,%eax
f0118fa7:	01 d0                	add    %edx,%eax
f0118fa9:	39 c1                	cmp    %eax,%ecx
f0118fab:	74 17                	je     f0118fc4 <test_kfree_bestfirstfit+0x9c3>
f0118fad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118fb4:	83 ec 0c             	sub    $0xc,%esp
f0118fb7:	68 54 cc 12 f0       	push   $0xf012cc54
f0118fbc:	e8 ca 7f fe ff       	call   f0100f8b <cprintf>
f0118fc1:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f0118fc4:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0118fca:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f0118fcd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118fd4:	eb 1e                	jmp    f0118ff4 <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f0118fd6:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f0118fdc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118fdf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118fe2:	01 c8                	add    %ecx,%eax
f0118fe4:	8a 00                	mov    (%eax),%al
f0118fe6:	0f be c0             	movsbl %al,%eax
f0118fe9:	01 d0                	add    %edx,%eax
f0118feb:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f0118ff1:	ff 45 f4             	incl   -0xc(%ebp)
f0118ff4:	8b 45 80             	mov    -0x80(%ebp),%eax
f0118ff7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118ffa:	7f da                	jg     f0118fd6 <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f0118ffc:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f0119002:	8b 55 80             	mov    -0x80(%ebp),%edx
f0119005:	89 d0                	mov    %edx,%eax
f0119007:	01 c0                	add    %eax,%eax
f0119009:	01 d0                	add    %edx,%eax
f011900b:	01 c0                	add    %eax,%eax
f011900d:	01 d0                	add    %edx,%eax
f011900f:	39 c1                	cmp    %eax,%ecx
f0119011:	74 17                	je     f011902a <test_kfree_bestfirstfit+0xa29>
f0119013:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011901a:	83 ec 0c             	sub    $0xc,%esp
f011901d:	68 8c cc 12 f0       	push   $0xf012cc8c
f0119022:	e8 64 7f fe ff       	call   f0100f8b <cprintf>
f0119027:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011902a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011902e:	74 04                	je     f0119034 <test_kfree_bestfirstfit+0xa33>
f0119030:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0119034:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f011903b:	83 ec 0c             	sub    $0xc,%esp
f011903e:	68 c4 cc 12 f0       	push   $0xf012ccc4
f0119043:	e8 43 7f fe ff       	call   f0100f8b <cprintf>
f0119048:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011904b:	e8 d6 49 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119050:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119053:	e8 0e b8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119058:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011905b:	83 ec 0c             	sub    $0xc,%esp
f011905e:	68 00 04 00 00       	push   $0x400
f0119063:	e8 28 fd fe ff       	call   f0108d90 <kmalloc>
f0119068:	83 c4 10             	add    $0x10,%esp
f011906b:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f0119071:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f0119077:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011907d:	39 c2                	cmp    %eax,%edx
f011907f:	74 17                	je     f0119098 <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119081:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119088:	83 ec 0c             	sub    $0xc,%esp
f011908b:	68 e4 cc 12 f0       	push   $0xf012cce4
f0119090:	e8 f6 7e fe ff       	call   f0100f8b <cprintf>
f0119095:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119098:	e8 c9 b7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011909d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01190a0:	74 17                	je     f01190b9 <test_kfree_bestfirstfit+0xab8>
f01190a2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01190a9:	83 ec 0c             	sub    $0xc,%esp
f01190ac:	68 38 cd 12 f0       	push   $0xf012cd38
f01190b1:	e8 d5 7e fe ff       	call   f0100f8b <cprintf>
f01190b6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f01190b9:	e8 68 49 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01190be:	89 c2                	mov    %eax,%edx
f01190c0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01190c3:	39 c2                	cmp    %eax,%edx
f01190c5:	74 17                	je     f01190de <test_kfree_bestfirstfit+0xadd>
f01190c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01190ce:	83 ec 0c             	sub    $0xc,%esp
f01190d1:	68 a8 cd 12 f0       	push   $0xf012cda8
f01190d6:	e8 b0 7e fe ff       	call   f0100f8b <cprintf>
f01190db:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f01190de:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f01190e5:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f01190eb:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f01190ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01190f5:	eb 0e                	jmp    f0119105 <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f01190f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01190fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01190fd:	01 d0                	add    %edx,%eax
f01190ff:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f0119102:	ff 45 f4             	incl   -0xc(%ebp)
f0119105:	8b 45 88             	mov    -0x78(%ebp),%eax
f0119108:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011910b:	7f ea                	jg     f01190f7 <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011910d:	e8 14 49 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119112:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119115:	e8 4c b7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011911a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011911d:	83 ec 0c             	sub    $0xc,%esp
f0119120:	68 00 00 30 00       	push   $0x300000
f0119125:	e8 66 fc fe ff       	call   f0108d90 <kmalloc>
f011912a:	83 c4 10             	add    $0x10,%esp
f011912d:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119133:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119139:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011913e:	74 17                	je     f0119157 <test_kfree_bestfirstfit+0xb56>
f0119140:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119147:	83 ec 0c             	sub    $0xc,%esp
f011914a:	68 24 ce 12 f0       	push   $0xf012ce24
f011914f:	e8 37 7e fe ff       	call   f0100f8b <cprintf>
f0119154:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119157:	e8 0a b7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011915c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011915f:	74 17                	je     f0119178 <test_kfree_bestfirstfit+0xb77>
f0119161:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119168:	83 ec 0c             	sub    $0xc,%esp
f011916b:	68 78 ce 12 f0       	push   $0xf012ce78
f0119170:	e8 16 7e fe ff       	call   f0100f8b <cprintf>
f0119175:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119178:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011917b:	e8 a6 48 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119180:	29 c3                	sub    %eax,%ebx
f0119182:	89 d8                	mov    %ebx,%eax
f0119184:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119189:	77 17                	ja     f01191a2 <test_kfree_bestfirstfit+0xba1>
f011918b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119192:	83 ec 0c             	sub    $0xc,%esp
f0119195:	68 e8 ce 12 f0       	push   $0xf012cee8
f011919a:	e8 ec 7d fe ff       	call   f0100f8b <cprintf>
f011919f:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f01191a2:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f01191a9:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f01191af:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f01191b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01191b9:	eb 0e                	jmp    f01191c9 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f01191bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01191be:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01191c1:	01 d0                	add    %edx,%eax
f01191c3:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f01191c6:	ff 45 f4             	incl   -0xc(%ebp)
f01191c9:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01191cc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01191cf:	7f ea                	jg     f01191bb <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f01191d1:	e8 50 48 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01191d6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01191d9:	e8 88 b6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01191de:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f01191e1:	83 ec 0c             	sub    $0xc,%esp
f01191e4:	68 00 00 10 00       	push   $0x100000
f01191e9:	e8 a2 fb fe ff       	call   f0108d90 <kmalloc>
f01191ee:	83 c4 10             	add    $0x10,%esp
f01191f1:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01191f7:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f01191fd:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0119202:	74 17                	je     f011921b <test_kfree_bestfirstfit+0xc1a>
f0119204:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011920b:	83 ec 0c             	sub    $0xc,%esp
f011920e:	68 30 cf 12 f0       	push   $0xf012cf30
f0119213:	e8 73 7d fe ff       	call   f0100f8b <cprintf>
f0119218:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011921b:	e8 46 b6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119220:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119223:	74 17                	je     f011923c <test_kfree_bestfirstfit+0xc3b>
f0119225:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011922c:	83 ec 0c             	sub    $0xc,%esp
f011922f:	68 84 cf 12 f0       	push   $0xf012cf84
f0119234:	e8 52 7d fe ff       	call   f0100f8b <cprintf>
f0119239:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011923c:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011923f:	e8 e2 47 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119244:	29 c3                	sub    %eax,%ebx
f0119246:	89 d8                	mov    %ebx,%eax
f0119248:	3d ff 00 00 00       	cmp    $0xff,%eax
f011924d:	77 17                	ja     f0119266 <test_kfree_bestfirstfit+0xc65>
f011924f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119256:	83 ec 0c             	sub    $0xc,%esp
f0119259:	68 f4 cf 12 f0       	push   $0xf012cff4
f011925e:	e8 28 7d fe ff       	call   f0100f8b <cprintf>
f0119263:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f0119266:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f011926d:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119273:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f0119276:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011927d:	eb 0e                	jmp    f011928d <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f011927f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119282:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119285:	01 d0                	add    %edx,%eax
f0119287:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011928a:	ff 45 f4             	incl   -0xc(%ebp)
f011928d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0119290:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119293:	7f ea                	jg     f011927f <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f0119295:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119299:	74 04                	je     f011929f <test_kfree_bestfirstfit+0xc9e>
f011929b:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011929f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f01192a6:	83 ec 0c             	sub    $0xc,%esp
f01192a9:	68 3c d0 12 f0       	push   $0xf012d03c
f01192ae:	e8 d8 7c fe ff       	call   f0100f8b <cprintf>
f01192b3:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f01192b6:	e8 6b 47 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01192bb:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01192be:	e8 a3 b5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01192c3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f01192c6:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01192cc:	83 ec 0c             	sub    $0xc,%esp
f01192cf:	50                   	push   %eax
f01192d0:	e8 d1 fc fe ff       	call   f0108fa6 <kfree>
f01192d5:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01192d8:	e8 89 b5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01192dd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01192e0:	74 17                	je     f01192f9 <test_kfree_bestfirstfit+0xcf8>
f01192e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192e9:	83 ec 0c             	sub    $0xc,%esp
f01192ec:	68 68 d0 12 f0       	push   $0xf012d068
f01192f1:	e8 95 7c fe ff       	call   f0100f8b <cprintf>
f01192f6:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f01192f9:	e8 28 47 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01192fe:	89 c2                	mov    %eax,%edx
f0119300:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119303:	29 c2                	sub    %eax,%edx
f0119305:	89 d0                	mov    %edx,%eax
f0119307:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011930c:	77 17                	ja     f0119325 <test_kfree_bestfirstfit+0xd24>
f011930e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119315:	83 ec 0c             	sub    $0xc,%esp
f0119318:	68 d8 d0 12 f0       	push   $0xf012d0d8
f011931d:	e8 69 7c fe ff       	call   f0100f8b <cprintf>
f0119322:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f0119325:	e8 fc 46 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011932a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011932d:	e8 34 b5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119332:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f0119335:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011933b:	83 ec 0c             	sub    $0xc,%esp
f011933e:	50                   	push   %eax
f011933f:	e8 62 fc fe ff       	call   f0108fa6 <kfree>
f0119344:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119347:	e8 1a b5 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011934c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011934f:	74 17                	je     f0119368 <test_kfree_bestfirstfit+0xd67>
f0119351:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119358:	83 ec 0c             	sub    $0xc,%esp
f011935b:	68 14 d1 12 f0       	push   $0xf012d114
f0119360:	e8 26 7c fe ff       	call   f0100f8b <cprintf>
f0119365:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119368:	e8 b9 46 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011936d:	89 c2                	mov    %eax,%edx
f011936f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119372:	29 c2                	sub    %eax,%edx
f0119374:	89 d0                	mov    %edx,%eax
f0119376:	83 f8 01             	cmp    $0x1,%eax
f0119379:	77 17                	ja     f0119392 <test_kfree_bestfirstfit+0xd91>
f011937b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119382:	83 ec 0c             	sub    $0xc,%esp
f0119385:	68 84 d1 12 f0       	push   $0xf012d184
f011938a:	e8 fc 7b fe ff       	call   f0100f8b <cprintf>
f011938f:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f0119392:	e8 8f 46 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119397:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011939a:	e8 c7 b4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011939f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f01193a2:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f01193a8:	83 ec 0c             	sub    $0xc,%esp
f01193ab:	50                   	push   %eax
f01193ac:	e8 f5 fb fe ff       	call   f0108fa6 <kfree>
f01193b1:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01193b4:	e8 ad b4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01193b9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01193bc:	74 17                	je     f01193d5 <test_kfree_bestfirstfit+0xdd4>
f01193be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193c5:	83 ec 0c             	sub    $0xc,%esp
f01193c8:	68 c0 d1 12 f0       	push   $0xf012d1c0
f01193cd:	e8 b9 7b fe ff       	call   f0100f8b <cprintf>
f01193d2:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f01193d5:	e8 4c 46 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01193da:	89 c2                	mov    %eax,%edx
f01193dc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01193df:	29 c2                	sub    %eax,%edx
f01193e1:	89 d0                	mov    %edx,%eax
f01193e3:	83 f8 03             	cmp    $0x3,%eax
f01193e6:	77 17                	ja     f01193ff <test_kfree_bestfirstfit+0xdfe>
f01193e8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193ef:	83 ec 0c             	sub    $0xc,%esp
f01193f2:	68 30 d2 12 f0       	push   $0xf012d230
f01193f7:	e8 8f 7b fe ff       	call   f0100f8b <cprintf>
f01193fc:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f01193ff:	e8 22 46 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119404:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119407:	e8 5a b4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011940c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f011940f:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119415:	83 ec 0c             	sub    $0xc,%esp
f0119418:	50                   	push   %eax
f0119419:	e8 88 fb fe ff       	call   f0108fa6 <kfree>
f011941e:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119421:	e8 40 b4 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119426:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119429:	74 17                	je     f0119442 <test_kfree_bestfirstfit+0xe41>
f011942b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119432:	83 ec 0c             	sub    $0xc,%esp
f0119435:	68 6c d2 12 f0       	push   $0xf012d26c
f011943a:	e8 4c 7b fe ff       	call   f0100f8b <cprintf>
f011943f:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119442:	e8 df 45 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119447:	89 c2                	mov    %eax,%edx
f0119449:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011944c:	29 c2                	sub    %eax,%edx
f011944e:	89 d0                	mov    %edx,%eax
f0119450:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119455:	77 17                	ja     f011946e <test_kfree_bestfirstfit+0xe6d>
f0119457:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011945e:	83 ec 0c             	sub    $0xc,%esp
f0119461:	68 dc d2 12 f0       	push   $0xf012d2dc
f0119466:	e8 20 7b fe ff       	call   f0100f8b <cprintf>
f011946b:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f011946e:	e8 b3 45 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119473:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119476:	e8 eb b3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011947b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f011947e:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119484:	83 ec 0c             	sub    $0xc,%esp
f0119487:	50                   	push   %eax
f0119488:	e8 19 fb fe ff       	call   f0108fa6 <kfree>
f011948d:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119490:	e8 d1 b3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119495:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119498:	74 17                	je     f01194b1 <test_kfree_bestfirstfit+0xeb0>
f011949a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194a1:	83 ec 0c             	sub    $0xc,%esp
f01194a4:	68 18 d3 12 f0       	push   $0xf012d318
f01194a9:	e8 dd 7a fe ff       	call   f0100f8b <cprintf>
f01194ae:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f01194b1:	e8 70 45 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01194b6:	89 c2                	mov    %eax,%edx
f01194b8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01194bb:	29 c2                	sub    %eax,%edx
f01194bd:	89 d0                	mov    %edx,%eax
f01194bf:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01194c4:	77 17                	ja     f01194dd <test_kfree_bestfirstfit+0xedc>
f01194c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194cd:	83 ec 0c             	sub    $0xc,%esp
f01194d0:	68 88 d3 12 f0       	push   $0xf012d388
f01194d5:	e8 b1 7a fe ff       	call   f0100f8b <cprintf>
f01194da:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f01194dd:	e8 44 45 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01194e2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01194e5:	e8 7c b3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01194ea:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f01194ed:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f01194f3:	83 ec 0c             	sub    $0xc,%esp
f01194f6:	50                   	push   %eax
f01194f7:	e8 aa fa fe ff       	call   f0108fa6 <kfree>
f01194fc:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01194ff:	e8 62 b3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119504:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119507:	74 17                	je     f0119520 <test_kfree_bestfirstfit+0xf1f>
f0119509:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119510:	83 ec 0c             	sub    $0xc,%esp
f0119513:	68 c4 d3 12 f0       	push   $0xf012d3c4
f0119518:	e8 6e 7a fe ff       	call   f0100f8b <cprintf>
f011951d:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119520:	e8 01 45 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119525:	89 c2                	mov    %eax,%edx
f0119527:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011952a:	39 c2                	cmp    %eax,%edx
f011952c:	74 17                	je     f0119545 <test_kfree_bestfirstfit+0xf44>
f011952e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119535:	83 ec 0c             	sub    $0xc,%esp
f0119538:	68 34 d4 12 f0       	push   $0xf012d434
f011953d:	e8 49 7a fe ff       	call   f0100f8b <cprintf>
f0119542:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f0119545:	e8 dc 44 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011954a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011954d:	e8 14 b3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119552:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f0119555:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011955b:	83 ec 0c             	sub    $0xc,%esp
f011955e:	50                   	push   %eax
f011955f:	e8 42 fa fe ff       	call   f0108fa6 <kfree>
f0119564:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119567:	e8 fa b2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011956c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011956f:	74 17                	je     f0119588 <test_kfree_bestfirstfit+0xf87>
f0119571:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119578:	83 ec 0c             	sub    $0xc,%esp
f011957b:	68 70 d4 12 f0       	push   $0xf012d470
f0119580:	e8 06 7a fe ff       	call   f0100f8b <cprintf>
f0119585:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119588:	e8 99 44 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011958d:	89 c2                	mov    %eax,%edx
f011958f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119592:	39 c2                	cmp    %eax,%edx
f0119594:	74 17                	je     f01195ad <test_kfree_bestfirstfit+0xfac>
f0119596:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011959d:	83 ec 0c             	sub    $0xc,%esp
f01195a0:	68 e0 d4 12 f0       	push   $0xf012d4e0
f01195a5:	e8 e1 79 fe ff       	call   f0100f8b <cprintf>
f01195aa:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f01195ad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01195b1:	74 04                	je     f01195b7 <test_kfree_bestfirstfit+0xfb6>
f01195b3:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f01195b7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f01195be:	83 ec 0c             	sub    $0xc,%esp
f01195c1:	68 40 d5 12 f0       	push   $0xf012d540
f01195c6:	e8 c0 79 fe ff       	call   f0100f8b <cprintf>
f01195cb:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f01195ce:	83 ec 0c             	sub    $0xc,%esp
f01195d1:	6a 03                	push   $0x3
f01195d3:	e8 63 48 ff ff       	call   f010de3b <sys_bypassPageFault>
f01195d8:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f01195db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01195e2:	e9 af 00 00 00       	jmp    f0119696 <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f01195e7:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01195eb:	0f 84 a1 00 00 00    	je     f0119692 <test_kfree_bestfirstfit+0x1091>
f01195f1:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f01195f5:	0f 84 97 00 00 00    	je     f0119692 <test_kfree_bestfirstfit+0x1091>
f01195fb:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f01195ff:	0f 84 8d 00 00 00    	je     f0119692 <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f0119605:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119608:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011960f:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f0119612:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119615:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f0119618:	e8 0c 48 ff ff       	call   f010de29 <sys_rcr2>
f011961d:	89 c2                	mov    %eax,%edx
f011961f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119622:	39 c2                	cmp    %eax,%edx
f0119624:	74 1d                	je     f0119643 <test_kfree_bestfirstfit+0x1042>
				if (correct)
f0119626:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011962a:	74 17                	je     f0119643 <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011962c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119633:	83 ec 0c             	sub    $0xc,%esp
f0119636:	68 80 d5 12 f0       	push   $0xf012d580
f011963b:	e8 4b 79 fe ff       	call   f0100f8b <cprintf>
f0119640:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f0119643:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119646:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011964d:	89 c2                	mov    %eax,%edx
f011964f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119652:	01 d0                	add    %edx,%eax
f0119654:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f0119657:	e8 cd 47 ff ff       	call   f010de29 <sys_rcr2>
f011965c:	89 c2                	mov    %eax,%edx
f011965e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119661:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f0119668:	89 c1                	mov    %eax,%ecx
f011966a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011966d:	01 c8                	add    %ecx,%eax
f011966f:	39 c2                	cmp    %eax,%edx
f0119671:	74 20                	je     f0119693 <test_kfree_bestfirstfit+0x1092>
				if (correct)
f0119673:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119677:	74 1a                	je     f0119693 <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f0119679:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119680:	83 ec 0c             	sub    $0xc,%esp
f0119683:	68 cc d5 12 f0       	push   $0xf012d5cc
f0119688:	e8 fe 78 fe ff       	call   f0100f8b <cprintf>
f011968d:	83 c4 10             	add    $0x10,%esp
f0119690:	eb 01                	jmp    f0119693 <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f0119692:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f0119693:	ff 45 f4             	incl   -0xc(%ebp)
f0119696:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011969a:	0f 8e 47 ff ff ff    	jle    f01195e7 <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f01196a0:	83 ec 0c             	sub    $0xc,%esp
f01196a3:	6a 00                	push   $0x0
f01196a5:	e8 91 47 ff ff       	call   f010de3b <sys_bypassPageFault>
f01196aa:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f01196ad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01196b1:	74 04                	je     f01196b7 <test_kfree_bestfirstfit+0x10b6>
f01196b3:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f01196b7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f01196be:	83 ec 0c             	sub    $0xc,%esp
f01196c1:	68 18 d6 12 f0       	push   $0xf012d618
f01196c6:	e8 c0 78 fe ff       	call   f0100f8b <cprintf>
f01196cb:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f01196ce:	e8 53 43 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01196d3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01196d6:	e8 8b b1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f01196db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f01196de:	83 ec 0c             	sub    $0xc,%esp
f01196e1:	68 00 04 00 00       	push   $0x400
f01196e6:	e8 a5 f6 fe ff       	call   f0108d90 <kmalloc>
f01196eb:	83 c4 10             	add    $0x10,%esp
f01196ee:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f01196f4:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f01196fa:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119700:	39 c2                	cmp    %eax,%edx
f0119702:	74 17                	je     f011971b <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119704:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011970b:	83 ec 0c             	sub    $0xc,%esp
f011970e:	68 3c d6 12 f0       	push   $0xf012d63c
f0119713:	e8 73 78 fe ff       	call   f0100f8b <cprintf>
f0119718:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011971b:	e8 46 b1 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119720:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119723:	74 17                	je     f011973c <test_kfree_bestfirstfit+0x113b>
f0119725:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011972c:	83 ec 0c             	sub    $0xc,%esp
f011972f:	68 90 d6 12 f0       	push   $0xf012d690
f0119734:	e8 52 78 fe ff       	call   f0100f8b <cprintf>
f0119739:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011973c:	e8 e5 42 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119741:	89 c2                	mov    %eax,%edx
f0119743:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119746:	39 c2                	cmp    %eax,%edx
f0119748:	74 17                	je     f0119761 <test_kfree_bestfirstfit+0x1160>
f011974a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119751:	83 ec 0c             	sub    $0xc,%esp
f0119754:	68 00 d7 12 f0       	push   $0xf012d700
f0119759:	e8 2d 78 fe ff       	call   f0100f8b <cprintf>
f011975e:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f0119761:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f0119768:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011976e:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f0119771:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119778:	eb 0e                	jmp    f0119788 <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011977a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011977d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119780:	01 d0                	add    %edx,%eax
f0119782:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f0119785:	ff 45 f4             	incl   -0xc(%ebp)
f0119788:	8b 45 90             	mov    -0x70(%ebp),%eax
f011978b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011978e:	7f ea                	jg     f011977a <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f0119790:	e8 91 42 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119795:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119798:	e8 c9 b0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011979d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f01197a0:	83 ec 0c             	sub    $0xc,%esp
f01197a3:	68 00 08 00 00       	push   $0x800
f01197a8:	e8 e3 f5 fe ff       	call   f0108d90 <kmalloc>
f01197ad:	83 c4 10             	add    $0x10,%esp
f01197b0:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f01197b6:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01197bc:	05 08 04 00 00       	add    $0x408,%eax
f01197c1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f01197c4:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f01197ca:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01197cd:	74 35                	je     f0119804 <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f01197cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f01197d6:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f01197dc:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f01197e2:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f01197e8:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f01197ee:	81 c2 00 04 00 00    	add    $0x400,%edx
f01197f4:	50                   	push   %eax
f01197f5:	51                   	push   %ecx
f01197f6:	52                   	push   %edx
f01197f7:	68 7c d7 12 f0       	push   $0xf012d77c
f01197fc:	e8 8a 77 fe ff       	call   f0100f8b <cprintf>
f0119801:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119804:	e8 5d b0 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119809:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011980c:	74 17                	je     f0119825 <test_kfree_bestfirstfit+0x1224>
f011980e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119815:	83 ec 0c             	sub    $0xc,%esp
f0119818:	68 f0 d7 12 f0       	push   $0xf012d7f0
f011981d:	e8 69 77 fe ff       	call   f0100f8b <cprintf>
f0119822:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f0119825:	e8 fc 41 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011982a:	89 c2                	mov    %eax,%edx
f011982c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011982f:	39 c2                	cmp    %eax,%edx
f0119831:	74 17                	je     f011984a <test_kfree_bestfirstfit+0x1249>
f0119833:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011983a:	83 ec 0c             	sub    $0xc,%esp
f011983d:	68 60 d8 12 f0       	push   $0xf012d860
f0119842:	e8 44 77 fe ff       	call   f0100f8b <cprintf>
f0119847:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011984a:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f0119851:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f0119857:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011985a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119861:	eb 0e                	jmp    f0119871 <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f0119863:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119866:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119869:	01 d0                	add    %edx,%eax
f011986b:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011986e:	ff 45 f4             	incl   -0xc(%ebp)
f0119871:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0119874:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119877:	7f ea                	jg     f0119863 <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f0119879:	e8 a8 41 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011987e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119881:	e8 e0 af fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119886:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f0119889:	83 ec 0c             	sub    $0xc,%esp
f011988c:	68 00 06 00 00       	push   $0x600
f0119891:	e8 fa f4 fe ff       	call   f0108d90 <kmalloc>
f0119896:	83 c4 10             	add    $0x10,%esp
f0119899:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011989f:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01198a5:	05 10 0c 00 00       	add    $0xc10,%eax
f01198aa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f01198ad:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f01198b3:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01198b6:	74 17                	je     f01198cf <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01198b8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198bf:	83 ec 0c             	sub    $0xc,%esp
f01198c2:	68 dc d8 12 f0       	push   $0xf012d8dc
f01198c7:	e8 bf 76 fe ff       	call   f0100f8b <cprintf>
f01198cc:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01198cf:	e8 92 af fe ff       	call   f0104866 <pf_calculate_free_frames>
f01198d4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01198d7:	74 17                	je     f01198f0 <test_kfree_bestfirstfit+0x12ef>
f01198d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198e0:	83 ec 0c             	sub    $0xc,%esp
f01198e3:	68 30 d9 12 f0       	push   $0xf012d930
f01198e8:	e8 9e 76 fe ff       	call   f0100f8b <cprintf>
f01198ed:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f01198f0:	e8 31 41 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01198f5:	89 c2                	mov    %eax,%edx
f01198f7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01198fa:	39 c2                	cmp    %eax,%edx
f01198fc:	74 17                	je     f0119915 <test_kfree_bestfirstfit+0x1314>
f01198fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119905:	83 ec 0c             	sub    $0xc,%esp
f0119908:	68 a0 d9 12 f0       	push   $0xf012d9a0
f011990d:	e8 79 76 fe ff       	call   f0100f8b <cprintf>
f0119912:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f0119915:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011991c:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f0119922:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f0119925:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011992c:	eb 0e                	jmp    f011993c <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011992e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119931:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119934:	01 d0                	add    %edx,%eax
f0119936:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f0119939:	ff 45 f4             	incl   -0xc(%ebp)
f011993c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011993f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119942:	7f ea                	jg     f011992e <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f0119944:	e8 dd 40 ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119949:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011994c:	e8 15 af fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119951:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f0119954:	83 ec 0c             	sub    $0xc,%esp
f0119957:	68 00 00 e0 01       	push   $0x1e00000
f011995c:	e8 2f f4 fe ff       	call   f0108d90 <kmalloc>
f0119961:	83 c4 10             	add    $0x10,%esp
f0119964:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011996a:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119970:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119975:	74 17                	je     f011998e <test_kfree_bestfirstfit+0x138d>
f0119977:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011997e:	83 ec 0c             	sub    $0xc,%esp
f0119981:	68 1c da 12 f0       	push   $0xf012da1c
f0119986:	e8 00 76 fe ff       	call   f0100f8b <cprintf>
f011998b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011998e:	e8 d3 ae fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119993:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119996:	74 17                	je     f01199af <test_kfree_bestfirstfit+0x13ae>
f0119998:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011999f:	83 ec 0c             	sub    $0xc,%esp
f01199a2:	68 70 da 12 f0       	push   $0xf012da70
f01199a7:	e8 df 75 fe ff       	call   f0100f8b <cprintf>
f01199ac:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01199af:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01199b2:	e8 6f 40 ff ff       	call   f010da26 <sys_calculate_free_frames>
f01199b7:	29 c3                	sub    %eax,%ebx
f01199b9:	89 d8                	mov    %ebx,%eax
f01199bb:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f01199c0:	77 17                	ja     f01199d9 <test_kfree_bestfirstfit+0x13d8>
f01199c2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199c9:	83 ec 0c             	sub    $0xc,%esp
f01199cc:	68 e0 da 12 f0       	push   $0xf012dae0
f01199d1:	e8 b5 75 fe ff       	call   f0100f8b <cprintf>
f01199d6:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f01199d9:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f01199e0:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f01199e6:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f01199e9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01199f0:	eb 0e                	jmp    f0119a00 <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f01199f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01199f5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199f8:	01 d0                	add    %edx,%eax
f01199fa:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f01199fd:	ff 45 f4             	incl   -0xc(%ebp)
f0119a00:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0119a03:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a06:	7f ea                	jg     f01199f2 <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f0119a08:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119a0e:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f0119a11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a18:	eb 1e                	jmp    f0119a38 <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f0119a1a:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f0119a20:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119a23:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119a26:	01 c8                	add    %ecx,%eax
f0119a28:	8a 00                	mov    (%eax),%al
f0119a2a:	0f be c0             	movsbl %al,%eax
f0119a2d:	01 d0                	add    %edx,%eax
f0119a2f:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f0119a35:	ff 45 f4             	incl   -0xc(%ebp)
f0119a38:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0119a3b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a3e:	7f da                	jg     f0119a1a <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f0119a40:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f0119a46:	8b 55 8c             	mov    -0x74(%ebp),%edx
f0119a49:	89 d0                	mov    %edx,%eax
f0119a4b:	c1 e0 02             	shl    $0x2,%eax
f0119a4e:	01 d0                	add    %edx,%eax
f0119a50:	01 c0                	add    %eax,%eax
f0119a52:	39 c1                	cmp    %eax,%ecx
f0119a54:	74 17                	je     f0119a6d <test_kfree_bestfirstfit+0x146c>
f0119a56:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a5d:	83 ec 0c             	sub    $0xc,%esp
f0119a60:	68 28 db 12 f0       	push   $0xf012db28
f0119a65:	e8 21 75 fe ff       	call   f0100f8b <cprintf>
f0119a6a:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f0119a6d:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f0119a73:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f0119a76:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a7d:	eb 1e                	jmp    f0119a9d <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f0119a7f:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0119a85:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119a88:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119a8b:	01 c8                	add    %ecx,%eax
f0119a8d:	8a 00                	mov    (%eax),%al
f0119a8f:	0f be c0             	movsbl %al,%eax
f0119a92:	01 d0                	add    %edx,%eax
f0119a94:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f0119a9a:	ff 45 f4             	incl   -0xc(%ebp)
f0119a9d:	8b 45 90             	mov    -0x70(%ebp),%eax
f0119aa0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119aa3:	7f da                	jg     f0119a7f <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f0119aa5:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0119aab:	8b 55 90             	mov    -0x70(%ebp),%edx
f0119aae:	89 d0                	mov    %edx,%eax
f0119ab0:	c1 e0 02             	shl    $0x2,%eax
f0119ab3:	01 d0                	add    %edx,%eax
f0119ab5:	01 c0                	add    %eax,%eax
f0119ab7:	01 d0                	add    %edx,%eax
f0119ab9:	39 c1                	cmp    %eax,%ecx
f0119abb:	74 17                	je     f0119ad4 <test_kfree_bestfirstfit+0x14d3>
f0119abd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ac4:	83 ec 0c             	sub    $0xc,%esp
f0119ac7:	68 58 db 12 f0       	push   $0xf012db58
f0119acc:	e8 ba 74 fe ff       	call   f0100f8b <cprintf>
f0119ad1:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f0119ad4:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f0119ada:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f0119add:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119ae4:	eb 1e                	jmp    f0119b04 <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f0119ae6:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f0119aec:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119aef:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119af2:	01 c8                	add    %ecx,%eax
f0119af4:	8a 00                	mov    (%eax),%al
f0119af6:	0f be c0             	movsbl %al,%eax
f0119af9:	01 d0                	add    %edx,%eax
f0119afb:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f0119b01:	ff 45 f4             	incl   -0xc(%ebp)
f0119b04:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0119b07:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119b0a:	7f da                	jg     f0119ae6 <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f0119b0c:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f0119b12:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0119b15:	89 d0                	mov    %edx,%eax
f0119b17:	01 c0                	add    %eax,%eax
f0119b19:	01 d0                	add    %edx,%eax
f0119b1b:	c1 e0 02             	shl    $0x2,%eax
f0119b1e:	39 c1                	cmp    %eax,%ecx
f0119b20:	74 17                	je     f0119b39 <test_kfree_bestfirstfit+0x1538>
f0119b22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b29:	83 ec 0c             	sub    $0xc,%esp
f0119b2c:	68 88 db 12 f0       	push   $0xf012db88
f0119b31:	e8 55 74 fe ff       	call   f0100f8b <cprintf>
f0119b36:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f0119b39:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f0119b3f:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f0119b42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119b49:	eb 1e                	jmp    f0119b69 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f0119b4b:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f0119b51:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119b54:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119b57:	01 c8                	add    %ecx,%eax
f0119b59:	8a 00                	mov    (%eax),%al
f0119b5b:	0f be c0             	movsbl %al,%eax
f0119b5e:	01 d0                	add    %edx,%eax
f0119b60:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f0119b66:	ff 45 f4             	incl   -0xc(%ebp)
f0119b69:	8b 45 98             	mov    -0x68(%ebp),%eax
f0119b6c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119b6f:	7f da                	jg     f0119b4b <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f0119b71:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f0119b77:	8b 55 98             	mov    -0x68(%ebp),%edx
f0119b7a:	89 d0                	mov    %edx,%eax
f0119b7c:	01 c0                	add    %eax,%eax
f0119b7e:	01 d0                	add    %edx,%eax
f0119b80:	c1 e0 02             	shl    $0x2,%eax
f0119b83:	01 d0                	add    %edx,%eax
f0119b85:	39 c1                	cmp    %eax,%ecx
f0119b87:	74 17                	je     f0119ba0 <test_kfree_bestfirstfit+0x159f>
f0119b89:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b90:	83 ec 0c             	sub    $0xc,%esp
f0119b93:	68 b8 db 12 f0       	push   $0xf012dbb8
f0119b98:	e8 ee 73 fe ff       	call   f0100f8b <cprintf>
f0119b9d:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f0119ba0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119ba4:	74 04                	je     f0119baa <test_kfree_bestfirstfit+0x15a9>
f0119ba6:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f0119baa:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f0119bb1:	83 ec 0c             	sub    $0xc,%esp
f0119bb4:	68 e5 db 12 f0       	push   $0xf012dbe5
f0119bb9:	e8 cd 73 fe ff       	call   f0100f8b <cprintf>
f0119bbe:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f0119bc1:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f0119bc8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0119bcf:	eb 4e                	jmp    f0119c1f <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f0119bd1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0119bd4:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f0119bd9:	83 ec 04             	sub    $0x4,%esp
f0119bdc:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f0119be2:	51                   	push   %ecx
f0119be3:	52                   	push   %edx
f0119be4:	50                   	push   %eax
f0119be5:	e8 9a e7 fe ff       	call   f0108384 <get_page_table>
f0119bea:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f0119bed:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f0119bf3:	85 c0                	test   %eax,%eax
f0119bf5:	75 1d                	jne    f0119c14 <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f0119bf7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119bfb:	74 17                	je     f0119c14 <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f0119bfd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c04:	83 ec 0c             	sub    $0xc,%esp
f0119c07:	68 04 dc 12 f0       	push   $0xf012dc04
f0119c0c:	e8 7a 73 fe ff       	call   f0100f8b <cprintf>
f0119c11:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f0119c14:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f0119c1b:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f0119c1f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0119c23:	78 ac                	js     f0119bd1 <test_kfree_bestfirstfit+0x15d0>
f0119c25:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0119c29:	7f 09                	jg     f0119c34 <test_kfree_bestfirstfit+0x1633>
f0119c2b:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f0119c32:	76 9d                	jbe    f0119bd1 <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f0119c34:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119c38:	74 04                	je     f0119c3e <test_kfree_bestfirstfit+0x163d>
f0119c3a:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f0119c3e:	83 ec 08             	sub    $0x8,%esp
f0119c41:	ff 75 f0             	pushl  -0x10(%ebp)
f0119c44:	68 6c dc 12 f0       	push   $0xf012dc6c
f0119c49:	e8 3d 73 fe ff       	call   f0100f8b <cprintf>
f0119c4e:	83 c4 10             	add    $0x10,%esp

	return 1;
f0119c51:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0119c56:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0119c59:	5b                   	pop    %ebx
f0119c5a:	5f                   	pop    %edi
f0119c5b:	5d                   	pop    %ebp
f0119c5c:	c3                   	ret    

f0119c5d <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f0119c5d:	55                   	push   %ebp
f0119c5e:	89 e5                	mov    %esp,%ebp
f0119c60:	57                   	push   %edi
f0119c61:	53                   	push   %ebx
f0119c62:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119c68:	83 ec 0c             	sub    $0xc,%esp
f0119c6b:	68 28 9f 12 f0       	push   $0xf0129f28
f0119c70:	e8 16 73 fe ff       	call   f0100f8b <cprintf>
f0119c75:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0119c78:	83 ec 0c             	sub    $0xc,%esp
f0119c7b:	68 58 9f 12 f0       	push   $0xf0129f58
f0119c80:	e8 06 73 fe ff       	call   f0100f8b <cprintf>
f0119c85:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0119c88:	83 ec 0c             	sub    $0xc,%esp
f0119c8b:	68 28 9f 12 f0       	push   $0xf0129f28
f0119c90:	e8 f6 72 fe ff       	call   f0100f8b <cprintf>
f0119c95:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0119c98:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f0119c9c:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f0119ca0:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f0119ca6:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f0119cac:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0119cb3:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f0119cba:	e8 67 3d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119cbf:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f0119cc2:	83 ec 0c             	sub    $0xc,%esp
f0119cc5:	68 90 dc 12 f0       	push   $0xf012dc90
f0119cca:	e8 bc 72 fe ff       	call   f0100f8b <cprintf>
f0119ccf:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0119cd2:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f0119cd8:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119cdd:	b8 00 00 00 00       	mov    $0x0,%eax
f0119ce2:	89 d7                	mov    %edx,%edi
f0119ce4:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f0119ce6:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f0119cec:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119cf1:	b8 00 00 00 00       	mov    $0x0,%eax
f0119cf6:	89 d7                	mov    %edx,%edi
f0119cf8:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f0119cfa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f0119d01:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f0119d08:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f0119d0e:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119d13:	b8 00 00 00 00       	mov    $0x0,%eax
f0119d18:	89 d7                	mov    %edx,%edi
f0119d1a:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119d1c:	e8 05 3d ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119d21:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119d24:	e8 3d ab fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119d29:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119d2c:	83 ec 0c             	sub    $0xc,%esp
f0119d2f:	68 00 fc 1f 00       	push   $0x1ffc00
f0119d34:	e8 57 f0 fe ff       	call   f0108d90 <kmalloc>
f0119d39:	83 c4 10             	add    $0x10,%esp
f0119d3c:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119d42:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f0119d48:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119d4d:	74 17                	je     f0119d66 <test_kheap_phys_addr+0x109>
f0119d4f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d56:	83 ec 0c             	sub    $0xc,%esp
f0119d59:	68 34 c0 12 f0       	push   $0xf012c034
f0119d5e:	e8 28 72 fe ff       	call   f0100f8b <cprintf>
f0119d63:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d66:	e8 fb aa fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119d6b:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119d6e:	74 17                	je     f0119d87 <test_kheap_phys_addr+0x12a>
f0119d70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d77:	83 ec 0c             	sub    $0xc,%esp
f0119d7a:	68 88 c0 12 f0       	push   $0xf012c088
f0119d7f:	e8 07 72 fe ff       	call   f0100f8b <cprintf>
f0119d84:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119d87:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119d8a:	e8 97 3c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119d8f:	29 c3                	sub    %eax,%ebx
f0119d91:	89 d8                	mov    %ebx,%eax
f0119d93:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119d98:	77 17                	ja     f0119db1 <test_kheap_phys_addr+0x154>
f0119d9a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119da1:	83 ec 0c             	sub    $0xc,%esp
f0119da4:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119da9:	e8 dd 71 fe ff       	call   f0100f8b <cprintf>
f0119dae:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119db1:	e8 70 3c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119db6:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119db9:	e8 a8 aa fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119dbe:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0119dc1:	83 ec 0c             	sub    $0xc,%esp
f0119dc4:	68 00 fc 1f 00       	push   $0x1ffc00
f0119dc9:	e8 c2 ef fe ff       	call   f0108d90 <kmalloc>
f0119dce:	83 c4 10             	add    $0x10,%esp
f0119dd1:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119dd7:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f0119ddd:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119de2:	74 17                	je     f0119dfb <test_kheap_phys_addr+0x19e>
f0119de4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119deb:	83 ec 0c             	sub    $0xc,%esp
f0119dee:	68 40 c1 12 f0       	push   $0xf012c140
f0119df3:	e8 93 71 fe ff       	call   f0100f8b <cprintf>
f0119df8:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119dfb:	e8 66 aa fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119e00:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119e03:	74 17                	je     f0119e1c <test_kheap_phys_addr+0x1bf>
f0119e05:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e0c:	83 ec 0c             	sub    $0xc,%esp
f0119e0f:	68 94 c1 12 f0       	push   $0xf012c194
f0119e14:	e8 72 71 fe ff       	call   f0100f8b <cprintf>
f0119e19:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119e1c:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119e1f:	e8 02 3c ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119e24:	29 c3                	sub    %eax,%ebx
f0119e26:	89 d8                	mov    %ebx,%eax
f0119e28:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119e2d:	77 17                	ja     f0119e46 <test_kheap_phys_addr+0x1e9>
f0119e2f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e36:	83 ec 0c             	sub    $0xc,%esp
f0119e39:	68 04 c2 12 f0       	push   $0xf012c204
f0119e3e:	e8 48 71 fe ff       	call   f0100f8b <cprintf>
f0119e43:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f0119e46:	e8 db 3b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119e4b:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119e4e:	e8 13 aa fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119e53:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0119e56:	83 ec 0c             	sub    $0xc,%esp
f0119e59:	68 00 04 00 00       	push   $0x400
f0119e5e:	e8 2d ef fe ff       	call   f0108d90 <kmalloc>
f0119e63:	83 c4 10             	add    $0x10,%esp
f0119e66:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119e6c:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f0119e72:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119e77:	76 28                	jbe    f0119ea1 <test_kheap_phys_addr+0x244>
f0119e79:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f0119e7f:	83 ec 0c             	sub    $0xc,%esp
f0119e82:	6a 00                	push   $0x0
f0119e84:	e8 18 ee fe ff       	call   f0108ca1 <sbrk>
f0119e89:	83 c4 10             	add    $0x10,%esp
f0119e8c:	39 c3                	cmp    %eax,%ebx
f0119e8e:	73 11                	jae    f0119ea1 <test_kheap_phys_addr+0x244>
f0119e90:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f0119e96:	89 c2                	mov    %eax,%edx
f0119e98:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f0119e9d:	39 c2                	cmp    %eax,%edx
f0119e9f:	72 17                	jb     f0119eb8 <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119ea1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ea8:	83 ec 0c             	sub    $0xc,%esp
f0119eab:	68 c0 dc 12 f0       	push   $0xf012dcc0
f0119eb0:	e8 d6 70 fe ff       	call   f0100f8b <cprintf>
f0119eb5:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119eb8:	e8 a9 a9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119ebd:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119ec0:	74 17                	je     f0119ed9 <test_kheap_phys_addr+0x27c>
f0119ec2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ec9:	83 ec 0c             	sub    $0xc,%esp
f0119ecc:	68 a0 c2 12 f0       	push   $0xf012c2a0
f0119ed1:	e8 b5 70 fe ff       	call   f0100f8b <cprintf>
f0119ed6:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f0119ed9:	e8 48 3b ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119ede:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119ee1:	e8 80 a9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119ee6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119ee9:	83 ec 0c             	sub    $0xc,%esp
f0119eec:	68 00 08 00 00       	push   $0x800
f0119ef1:	e8 9a ee fe ff       	call   f0108d90 <kmalloc>
f0119ef6:	83 c4 10             	add    $0x10,%esp
f0119ef9:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119eff:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f0119f05:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119f0a:	76 28                	jbe    f0119f34 <test_kheap_phys_addr+0x2d7>
f0119f0c:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f0119f12:	83 ec 0c             	sub    $0xc,%esp
f0119f15:	6a 00                	push   $0x0
f0119f17:	e8 85 ed fe ff       	call   f0108ca1 <sbrk>
f0119f1c:	83 c4 10             	add    $0x10,%esp
f0119f1f:	39 c3                	cmp    %eax,%ebx
f0119f21:	73 11                	jae    f0119f34 <test_kheap_phys_addr+0x2d7>
f0119f23:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f0119f29:	89 c2                	mov    %eax,%edx
f0119f2b:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f0119f30:	39 c2                	cmp    %eax,%edx
f0119f32:	72 17                	jb     f0119f4b <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119f34:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f3b:	83 ec 0c             	sub    $0xc,%esp
f0119f3e:	68 4c dd 12 f0       	push   $0xf012dd4c
f0119f43:	e8 43 70 fe ff       	call   f0100f8b <cprintf>
f0119f48:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f4b:	e8 16 a9 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119f50:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119f53:	74 17                	je     f0119f6c <test_kheap_phys_addr+0x30f>
f0119f55:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f5c:	83 ec 0c             	sub    $0xc,%esp
f0119f5f:	68 ac c3 12 f0       	push   $0xf012c3ac
f0119f64:	e8 22 70 fe ff       	call   f0100f8b <cprintf>
f0119f69:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f0119f6c:	e8 b5 3a ff ff       	call   f010da26 <sys_calculate_free_frames>
f0119f71:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119f74:	e8 ed a8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119f79:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f0119f7c:	83 ec 0c             	sub    $0xc,%esp
f0119f7f:	68 00 06 00 00       	push   $0x600
f0119f84:	e8 07 ee fe ff       	call   f0108d90 <kmalloc>
f0119f89:	83 c4 10             	add    $0x10,%esp
f0119f8c:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0119f92:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f0119f98:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119f9d:	76 28                	jbe    f0119fc7 <test_kheap_phys_addr+0x36a>
f0119f9f:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f0119fa5:	83 ec 0c             	sub    $0xc,%esp
f0119fa8:	6a 00                	push   $0x0
f0119faa:	e8 f2 ec fe ff       	call   f0108ca1 <sbrk>
f0119faf:	83 c4 10             	add    $0x10,%esp
f0119fb2:	39 c3                	cmp    %eax,%ebx
f0119fb4:	73 11                	jae    f0119fc7 <test_kheap_phys_addr+0x36a>
f0119fb6:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f0119fbc:	89 c2                	mov    %eax,%edx
f0119fbe:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f0119fc3:	39 c2                	cmp    %eax,%edx
f0119fc5:	72 17                	jb     f0119fde <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119fc7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fce:	83 ec 0c             	sub    $0xc,%esp
f0119fd1:	68 d8 dd 12 f0       	push   $0xf012ddd8
f0119fd6:	e8 b0 6f fe ff       	call   f0100f8b <cprintf>
f0119fdb:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119fde:	e8 83 a8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f0119fe3:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119fe6:	74 17                	je     f0119fff <test_kheap_phys_addr+0x3a2>
f0119fe8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fef:	83 ec 0c             	sub    $0xc,%esp
f0119ff2:	68 b8 c4 12 f0       	push   $0xf012c4b8
f0119ff7:	e8 8f 6f fe ff       	call   f0100f8b <cprintf>
f0119ffc:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f0119fff:	e8 22 3a ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a004:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a007:	e8 5a a8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a00c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011a00f:	83 ec 0c             	sub    $0xc,%esp
f011a012:	68 00 1c 00 00       	push   $0x1c00
f011a017:	e8 74 ed fe ff       	call   f0108d90 <kmalloc>
f011a01c:	83 c4 10             	add    $0x10,%esp
f011a01f:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a025:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011a02b:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011a030:	74 17                	je     f011a049 <test_kheap_phys_addr+0x3ec>
f011a032:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a039:	83 ec 0c             	sub    $0xc,%esp
f011a03c:	68 70 c5 12 f0       	push   $0xf012c570
f011a041:	e8 45 6f fe ff       	call   f0100f8b <cprintf>
f011a046:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a049:	e8 18 a8 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a04e:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a051:	74 17                	je     f011a06a <test_kheap_phys_addr+0x40d>
f011a053:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a05a:	83 ec 0c             	sub    $0xc,%esp
f011a05d:	68 c4 c5 12 f0       	push   $0xf012c5c4
f011a062:	e8 24 6f fe ff       	call   f0100f8b <cprintf>
f011a067:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a06a:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a06d:	e8 b4 39 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a072:	29 c3                	sub    %eax,%ebx
f011a074:	89 d8                	mov    %ebx,%eax
f011a076:	83 f8 01             	cmp    $0x1,%eax
f011a079:	77 17                	ja     f011a092 <test_kheap_phys_addr+0x435>
f011a07b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a082:	83 ec 0c             	sub    $0xc,%esp
f011a085:	68 34 c6 12 f0       	push   $0xf012c634
f011a08a:	e8 fc 6e fe ff       	call   f0100f8b <cprintf>
f011a08f:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011a092:	e8 8f 39 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a097:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a09a:	e8 c7 a7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a09f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011a0a2:	83 ec 0c             	sub    $0xc,%esp
f011a0a5:	68 00 fc 2f 00       	push   $0x2ffc00
f011a0aa:	e8 e1 ec fe ff       	call   f0108d90 <kmalloc>
f011a0af:	83 c4 10             	add    $0x10,%esp
f011a0b2:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a0b8:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011a0be:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011a0c3:	74 17                	je     f011a0dc <test_kheap_phys_addr+0x47f>
f011a0c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0cc:	83 ec 0c             	sub    $0xc,%esp
f011a0cf:	68 64 de 12 f0       	push   $0xf012de64
f011a0d4:	e8 b2 6e fe ff       	call   f0100f8b <cprintf>
f011a0d9:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a0dc:	e8 85 a7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a0e1:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a0e4:	74 17                	je     f011a0fd <test_kheap_phys_addr+0x4a0>
f011a0e6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0ed:	83 ec 0c             	sub    $0xc,%esp
f011a0f0:	68 08 c7 12 f0       	push   $0xf012c708
f011a0f5:	e8 91 6e fe ff       	call   f0100f8b <cprintf>
f011a0fa:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a0fd:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a100:	e8 21 39 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a105:	29 c3                	sub    %eax,%ebx
f011a107:	89 d8                	mov    %ebx,%eax
f011a109:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a10e:	77 17                	ja     f011a127 <test_kheap_phys_addr+0x4ca>
f011a110:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a117:	83 ec 0c             	sub    $0xc,%esp
f011a11a:	68 b8 de 12 f0       	push   $0xf012deb8
f011a11f:	e8 67 6e fe ff       	call   f0100f8b <cprintf>
f011a124:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011a127:	e8 fa 38 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a12c:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a12f:	e8 32 a7 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a134:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011a137:	83 ec 0c             	sub    $0xc,%esp
f011a13a:	68 00 fc 5f 00       	push   $0x5ffc00
f011a13f:	e8 4c ec fe ff       	call   f0108d90 <kmalloc>
f011a144:	83 c4 10             	add    $0x10,%esp
f011a147:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a14d:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011a153:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011a158:	74 17                	je     f011a171 <test_kheap_phys_addr+0x514>
f011a15a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a161:	83 ec 0c             	sub    $0xc,%esp
f011a164:	68 00 df 12 f0       	push   $0xf012df00
f011a169:	e8 1d 6e fe ff       	call   f0100f8b <cprintf>
f011a16e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a171:	e8 f0 a6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a176:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a179:	74 17                	je     f011a192 <test_kheap_phys_addr+0x535>
f011a17b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a182:	83 ec 0c             	sub    $0xc,%esp
f011a185:	68 04 c8 12 f0       	push   $0xf012c804
f011a18a:	e8 fc 6d fe ff       	call   f0100f8b <cprintf>
f011a18f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a192:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a195:	e8 8c 38 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a19a:	29 c3                	sub    %eax,%ebx
f011a19c:	89 d8                	mov    %ebx,%eax
f011a19e:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a1a3:	77 17                	ja     f011a1bc <test_kheap_phys_addr+0x55f>
f011a1a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1ac:	83 ec 0c             	sub    $0xc,%esp
f011a1af:	68 54 df 12 f0       	push   $0xf012df54
f011a1b4:	e8 d2 6d fe ff       	call   f0100f8b <cprintf>
f011a1b9:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011a1bc:	e8 65 38 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a1c1:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a1c4:	e8 9d a6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a1c9:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011a1cc:	83 ec 0c             	sub    $0xc,%esp
f011a1cf:	68 00 38 00 00       	push   $0x3800
f011a1d4:	e8 b7 eb fe ff       	call   f0108d90 <kmalloc>
f011a1d9:	83 c4 10             	add    $0x10,%esp
f011a1dc:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a1e2:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011a1e8:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011a1ed:	74 17                	je     f011a206 <test_kheap_phys_addr+0x5a9>
f011a1ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1f6:	83 ec 0c             	sub    $0xc,%esp
f011a1f9:	68 9c df 12 f0       	push   $0xf012df9c
f011a1fe:	e8 88 6d fe ff       	call   f0100f8b <cprintf>
f011a203:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a206:	e8 5b a6 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a20b:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a20e:	74 17                	je     f011a227 <test_kheap_phys_addr+0x5ca>
f011a210:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a217:	83 ec 0c             	sub    $0xc,%esp
f011a21a:	68 f0 df 12 f0       	push   $0xf012dff0
f011a21f:	e8 67 6d fe ff       	call   f0100f8b <cprintf>
f011a224:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a227:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a22a:	e8 f7 37 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a22f:	29 c3                	sub    %eax,%ebx
f011a231:	89 d8                	mov    %ebx,%eax
f011a233:	83 f8 03             	cmp    $0x3,%eax
f011a236:	77 17                	ja     f011a24f <test_kheap_phys_addr+0x5f2>
f011a238:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a23f:	83 ec 0c             	sub    $0xc,%esp
f011a242:	68 60 e0 12 f0       	push   $0xf012e060
f011a247:	e8 3f 6d fe ff       	call   f0100f8b <cprintf>
f011a24c:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011a24f:	83 ec 0c             	sub    $0xc,%esp
f011a252:	68 a8 e0 12 f0       	push   $0xf012e0a8
f011a257:	e8 2f 6d fe ff       	call   f0100f8b <cprintf>
f011a25c:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011a25f:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011a266:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011a26d:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011a274:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f011a279:	05 00 10 00 00       	add    $0x1000,%eax
f011a27e:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011a281:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a284:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011a287:	eb 2e                	jmp    f011a2b7 <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011a289:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011a28c:	8d 43 01             	lea    0x1(%ebx),%eax
f011a28f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011a292:	83 ec 0c             	sub    $0xc,%esp
f011a295:	ff 75 e8             	pushl  -0x18(%ebp)
f011a298:	e8 b7 ed fe ff       	call   f0109054 <kheap_physical_address>
f011a29d:	83 c4 10             	add    $0x10,%esp
f011a2a0:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011a2a7:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011a2aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a2ad:	01 d0                	add    %edx,%eax
f011a2af:	05 00 10 00 00       	add    $0x1000,%eax
f011a2b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011a2b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a2ba:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011a2bd:	72 ca                	jb     f011a289 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011a2bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a2c2:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011a2c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011a2cc:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a2cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011a2d2:	e9 ce 00 00 00       	jmp    f011a3a5 <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a2d7:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011a2dc:	83 ec 04             	sub    $0x4,%esp
f011a2df:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011a2e5:	52                   	push   %edx
f011a2e6:	ff 75 e8             	pushl  -0x18(%ebp)
f011a2e9:	50                   	push   %eax
f011a2ea:	e8 95 e0 fe ff       	call   f0108384 <get_page_table>
f011a2ef:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a2f2:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011a2f8:	85 c0                	test   %eax,%eax
f011a2fa:	75 1e                	jne    f011a31a <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a2fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a303:	83 ec 04             	sub    $0x4,%esp
f011a306:	68 f4 e0 12 f0       	push   $0xf012e0f4
f011a30b:	68 e8 05 00 00       	push   $0x5e8
f011a310:	68 87 be 12 f0       	push   $0xf012be87
f011a315:	e8 1f 60 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a31a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a31d:	c1 e8 0c             	shr    $0xc,%eax
f011a320:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a325:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011a328:	eb 62                	jmp    f011a38c <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011a32a:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011a330:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011a333:	c1 e2 02             	shl    $0x2,%edx
f011a336:	01 d0                	add    %edx,%eax
f011a338:	8b 00                	mov    (%eax),%eax
f011a33a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a33f:	89 c2                	mov    %eax,%edx
f011a341:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a344:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a349:	01 c2                	add    %eax,%edx
f011a34b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a34e:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011a355:	39 c2                	cmp    %eax,%edx
f011a357:	74 1d                	je     f011a376 <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011a359:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a35d:	74 17                	je     f011a376 <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011a35f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a366:	83 ec 0c             	sub    $0xc,%esp
f011a369:	68 54 e1 12 f0       	push   $0xf012e154
f011a36e:	e8 18 6c fe ff       	call   f0100f8b <cprintf>
f011a373:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011a376:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011a379:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a37c:	01 d0                	add    %edx,%eax
f011a37e:	05 00 10 00 00       	add    $0x1000,%eax
f011a383:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a386:	ff 45 e4             	incl   -0x1c(%ebp)
f011a389:	ff 45 f4             	incl   -0xc(%ebp)
f011a38c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a38f:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011a392:	7d 11                	jge    f011a3a5 <test_kheap_phys_addr+0x748>
f011a394:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011a39b:	7f 08                	jg     f011a3a5 <test_kheap_phys_addr+0x748>
f011a39d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a3a0:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011a3a3:	72 85                	jb     f011a32a <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011a3a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a3a8:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011a3ab:	0f 82 26 ff ff ff    	jb     f011a2d7 <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011a3b1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a3b5:	74 04                	je     f011a3bb <test_kheap_phys_addr+0x75e>
f011a3b7:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011a3bb:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011a3c2:	83 ec 0c             	sub    $0xc,%esp
f011a3c5:	68 78 e1 12 f0       	push   $0xf012e178
f011a3ca:	e8 bc 6b fe ff       	call   f0100f8b <cprintf>
f011a3cf:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011a3d2:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011a3d9:	e9 b0 00 00 00       	jmp    f011a48e <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011a3de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a3e1:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011a3e8:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011a3eb:	83 ec 0c             	sub    $0xc,%esp
f011a3ee:	ff 75 90             	pushl  -0x70(%ebp)
f011a3f1:	e8 5e ec fe ff       	call   f0109054 <kheap_physical_address>
f011a3f6:	83 c4 10             	add    $0x10,%esp
f011a3f9:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a3fc:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011a401:	83 ec 04             	sub    $0x4,%esp
f011a404:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011a40a:	52                   	push   %edx
f011a40b:	ff 75 90             	pushl  -0x70(%ebp)
f011a40e:	50                   	push   %eax
f011a40f:	e8 70 df fe ff       	call   f0108384 <get_page_table>
f011a414:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a417:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011a41d:	85 c0                	test   %eax,%eax
f011a41f:	75 1e                	jne    f011a43f <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a421:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a428:	83 ec 04             	sub    $0x4,%esp
f011a42b:	68 c8 e1 12 f0       	push   $0xf012e1c8
f011a430:	68 05 06 00 00       	push   $0x605
f011a435:	68 87 be 12 f0       	push   $0xf012be87
f011a43a:	e8 fa 5e fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011a43f:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011a445:	8b 55 90             	mov    -0x70(%ebp),%edx
f011a448:	c1 ea 0c             	shr    $0xc,%edx
f011a44b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011a451:	c1 e2 02             	shl    $0x2,%edx
f011a454:	01 d0                	add    %edx,%eax
f011a456:	8b 00                	mov    (%eax),%eax
f011a458:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a45d:	89 c2                	mov    %eax,%edx
f011a45f:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a462:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a467:	01 d0                	add    %edx,%eax
f011a469:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011a46c:	74 1d                	je     f011a48b <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011a46e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a472:	74 17                	je     f011a48b <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011a474:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a47b:	83 ec 0c             	sub    $0xc,%esp
f011a47e:	68 28 e2 12 f0       	push   $0xf012e228
f011a483:	e8 03 6b fe ff       	call   f0100f8b <cprintf>
f011a488:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011a48b:	ff 45 e0             	incl   -0x20(%ebp)
f011a48e:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011a492:	0f 8e 46 ff ff ff    	jle    f011a3de <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011a498:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a49c:	74 04                	je     f011a4a2 <test_kheap_phys_addr+0x845>
f011a49e:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a4a2:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011a4a9:	83 ec 0c             	sub    $0xc,%esp
f011a4ac:	68 4c e2 12 f0       	push   $0xf012e24c
f011a4b1:	e8 d5 6a fe ff       	call   f0100f8b <cprintf>
f011a4b6:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011a4b9:	e8 68 35 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a4be:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011a4c1:	e8 a0 a3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a4c6:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011a4c9:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011a4cf:	83 ec 0c             	sub    $0xc,%esp
f011a4d2:	50                   	push   %eax
f011a4d3:	e8 ce ea fe ff       	call   f0108fa6 <kfree>
f011a4d8:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a4db:	e8 86 a3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a4e0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011a4e3:	74 17                	je     f011a4fc <test_kheap_phys_addr+0x89f>
f011a4e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4ec:	83 ec 0c             	sub    $0xc,%esp
f011a4ef:	68 38 cd 12 f0       	push   $0xf012cd38
f011a4f4:	e8 92 6a fe ff       	call   f0100f8b <cprintf>
f011a4f9:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a4fc:	e8 25 35 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a501:	89 c2                	mov    %eax,%edx
f011a503:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a506:	29 c2                	sub    %eax,%edx
f011a508:	89 d0                	mov    %edx,%eax
f011a50a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a50f:	77 17                	ja     f011a528 <test_kheap_phys_addr+0x8cb>
f011a511:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a518:	83 ec 0c             	sub    $0xc,%esp
f011a51b:	68 74 e2 12 f0       	push   $0xf012e274
f011a520:	e8 66 6a fe ff       	call   f0100f8b <cprintf>
f011a525:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a528:	e8 f9 34 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a52d:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a530:	e8 31 a3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a535:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011a538:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011a53e:	83 ec 0c             	sub    $0xc,%esp
f011a541:	50                   	push   %eax
f011a542:	e8 5f ea fe ff       	call   f0108fa6 <kfree>
f011a547:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a54a:	e8 17 a3 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a54f:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011a552:	74 17                	je     f011a56b <test_kheap_phys_addr+0x90e>
f011a554:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a55b:	83 ec 0c             	sub    $0xc,%esp
f011a55e:	68 78 ce 12 f0       	push   $0xf012ce78
f011a563:	e8 23 6a fe ff       	call   f0100f8b <cprintf>
f011a568:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a56b:	e8 b6 34 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a570:	89 c2                	mov    %eax,%edx
f011a572:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a575:	29 c2                	sub    %eax,%edx
f011a577:	89 d0                	mov    %edx,%eax
f011a579:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a57e:	77 17                	ja     f011a597 <test_kheap_phys_addr+0x93a>
f011a580:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a587:	83 ec 0c             	sub    $0xc,%esp
f011a58a:	68 b0 e2 12 f0       	push   $0xf012e2b0
f011a58f:	e8 f7 69 fe ff       	call   f0100f8b <cprintf>
f011a594:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011a597:	e8 8a 34 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a59c:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a59f:	e8 c2 a2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a5a4:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011a5a7:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011a5ad:	83 ec 0c             	sub    $0xc,%esp
f011a5b0:	50                   	push   %eax
f011a5b1:	e8 f0 e9 fe ff       	call   f0108fa6 <kfree>
f011a5b6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a5b9:	e8 a8 a2 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011a5be:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011a5c1:	74 17                	je     f011a5da <test_kheap_phys_addr+0x97d>
f011a5c3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5ca:	83 ec 0c             	sub    $0xc,%esp
f011a5cd:	68 84 cf 12 f0       	push   $0xf012cf84
f011a5d2:	e8 b4 69 fe ff       	call   f0100f8b <cprintf>
f011a5d7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a5da:	e8 47 34 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011a5df:	89 c2                	mov    %eax,%edx
f011a5e1:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a5e4:	29 c2                	sub    %eax,%edx
f011a5e6:	89 d0                	mov    %edx,%eax
f011a5e8:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a5ed:	77 17                	ja     f011a606 <test_kheap_phys_addr+0x9a9>
f011a5ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5f6:	83 ec 0c             	sub    $0xc,%esp
f011a5f9:	68 ec e2 12 f0       	push   $0xf012e2ec
f011a5fe:	e8 88 69 fe ff       	call   f0100f8b <cprintf>
f011a603:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011a606:	83 ec 0c             	sub    $0xc,%esp
f011a609:	68 28 e3 12 f0       	push   $0xf012e328
f011a60e:	e8 78 69 fe ff       	call   f0100f8b <cprintf>
f011a613:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011a616:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011a61d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011a624:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011a62b:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011a62e:	8b 15 d8 cd 17 f0    	mov    0xf017cdd8,%edx
f011a634:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011a63a:	01 d0                	add    %edx,%eax
f011a63c:	05 00 10 00 00       	add    $0x1000,%eax
f011a641:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011a647:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a64d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011a650:	eb 25                	jmp    f011a677 <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011a652:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011a655:	8d 43 01             	lea    0x1(%ebx),%eax
f011a658:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011a65b:	83 ec 0c             	sub    $0xc,%esp
f011a65e:	ff 75 d8             	pushl  -0x28(%ebp)
f011a661:	e8 ee e9 fe ff       	call   f0109054 <kheap_physical_address>
f011a666:	83 c4 10             	add    $0x10,%esp
f011a669:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011a670:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011a677:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a67a:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011a67d:	72 d3                	jb     f011a652 <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011a67f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a682:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011a688:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011a68f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a695:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011a698:	e9 f4 00 00 00       	jmp    f011a791 <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a69d:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011a6a2:	83 ec 04             	sub    $0x4,%esp
f011a6a5:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011a6ab:	52                   	push   %edx
f011a6ac:	ff 75 d8             	pushl  -0x28(%ebp)
f011a6af:	50                   	push   %eax
f011a6b0:	e8 cf dc fe ff       	call   f0108384 <get_page_table>
f011a6b5:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a6b8:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011a6be:	85 c0                	test   %eax,%eax
f011a6c0:	75 24                	jne    f011a6e6 <test_kheap_phys_addr+0xa89>
				if (correct)
f011a6c2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6c6:	74 1e                	je     f011a6e6 <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a6c8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6cf:	83 ec 04             	sub    $0x4,%esp
f011a6d2:	68 78 e3 12 f0       	push   $0xf012e378
f011a6d7:	68 43 06 00 00       	push   $0x643
f011a6dc:	68 87 be 12 f0       	push   $0xf012be87
f011a6e1:	e8 53 5c fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a6e6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a6e9:	c1 e8 0c             	shr    $0xc,%eax
f011a6ec:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a6f1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011a6f4:	eb 7b                	jmp    f011a771 <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011a6f6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011a6fd:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011a703:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011a706:	c1 e2 02             	shl    $0x2,%edx
f011a709:	01 d0                	add    %edx,%eax
f011a70b:	8b 00                	mov    (%eax),%eax
f011a70d:	83 e0 01             	and    $0x1,%eax
f011a710:	85 c0                	test   %eax,%eax
f011a712:	74 24                	je     f011a738 <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011a714:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011a71a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011a71d:	c1 e2 02             	shl    $0x2,%edx
f011a720:	01 d0                	add    %edx,%eax
f011a722:	8b 00                	mov    (%eax),%eax
f011a724:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a729:	89 c2                	mov    %eax,%edx
f011a72b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a72e:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a733:	01 d0                	add    %edx,%eax
f011a735:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011a738:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a73b:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011a742:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011a745:	74 1d                	je     f011a764 <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011a747:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a74b:	74 17                	je     f011a764 <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011a74d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a754:	83 ec 0c             	sub    $0xc,%esp
f011a757:	68 d8 e3 12 f0       	push   $0xf012e3d8
f011a75c:	e8 2a 68 fe ff       	call   f0100f8b <cprintf>
f011a761:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011a764:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a76b:	ff 45 d4             	incl   -0x2c(%ebp)
f011a76e:	ff 45 f4             	incl   -0xc(%ebp)
f011a771:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a774:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011a77a:	7d 15                	jge    f011a791 <test_kheap_phys_addr+0xb34>
f011a77c:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011a783:	7f 0c                	jg     f011a791 <test_kheap_phys_addr+0xb34>
f011a785:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a788:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011a78b:	0f 82 65 ff ff ff    	jb     f011a6f6 <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011a791:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a794:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011a797:	0f 82 00 ff ff ff    	jb     f011a69d <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011a79d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a7a1:	74 04                	je     f011a7a7 <test_kheap_phys_addr+0xb4a>
f011a7a3:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011a7a7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011a7ae:	83 ec 0c             	sub    $0xc,%esp
f011a7b1:	68 fc e3 12 f0       	push   $0xf012e3fc
f011a7b6:	e8 d0 67 fe ff       	call   f0100f8b <cprintf>
f011a7bb:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011a7be:	83 ec 0c             	sub    $0xc,%esp
f011a7c1:	6a 00                	push   $0x0
f011a7c3:	e8 d9 e4 fe ff       	call   f0108ca1 <sbrk>
f011a7c8:	83 c4 10             	add    $0x10,%esp
f011a7cb:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011a7d0:	77 17                	ja     f011a7e9 <test_kheap_phys_addr+0xb8c>
f011a7d2:	83 ec 04             	sub    $0x4,%esp
f011a7d5:	68 54 e4 12 f0       	push   $0xf012e454
f011a7da:	68 5e 06 00 00       	push   $0x65e
f011a7df:	68 87 be 12 f0       	push   $0xf012be87
f011a7e4:	e8 50 5b fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011a7e9:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011a7f0:	e9 af 00 00 00       	jmp    f011a8a4 <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011a7f5:	83 ec 0c             	sub    $0xc,%esp
f011a7f8:	ff 75 d0             	pushl  -0x30(%ebp)
f011a7fb:	e8 54 e8 fe ff       	call   f0109054 <kheap_physical_address>
f011a800:	83 c4 10             	add    $0x10,%esp
f011a803:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a809:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011a80e:	83 ec 04             	sub    $0x4,%esp
f011a811:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011a817:	52                   	push   %edx
f011a818:	ff 75 d0             	pushl  -0x30(%ebp)
f011a81b:	50                   	push   %eax
f011a81c:	e8 63 db fe ff       	call   f0108384 <get_page_table>
f011a821:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a824:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011a82a:	85 c0                	test   %eax,%eax
f011a82c:	75 24                	jne    f011a852 <test_kheap_phys_addr+0xbf5>
				if (correct)
f011a82e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a832:	74 1e                	je     f011a852 <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a834:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a83b:	83 ec 04             	sub    $0x4,%esp
f011a83e:	68 70 e4 12 f0       	push   $0xf012e470
f011a843:	68 66 06 00 00       	push   $0x666
f011a848:	68 87 be 12 f0       	push   $0xf012be87
f011a84d:	e8 e7 5a fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011a852:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011a858:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011a85b:	c1 ea 0c             	shr    $0xc,%edx
f011a85e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011a864:	c1 e2 02             	shl    $0x2,%edx
f011a867:	01 d0                	add    %edx,%eax
f011a869:	8b 00                	mov    (%eax),%eax
f011a86b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a870:	89 c2                	mov    %eax,%edx
f011a872:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011a875:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a87a:	01 d0                	add    %edx,%eax
f011a87c:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011a882:	74 1d                	je     f011a8a1 <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011a884:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a888:	74 17                	je     f011a8a1 <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011a88a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a891:	83 ec 0c             	sub    $0xc,%esp
f011a894:	68 d0 e4 12 f0       	push   $0xf012e4d0
f011a899:	e8 ed 66 fe ff       	call   f0100f8b <cprintf>
f011a89e:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011a8a1:	ff 45 d0             	incl   -0x30(%ebp)
f011a8a4:	83 ec 0c             	sub    $0xc,%esp
f011a8a7:	6a 00                	push   $0x0
f011a8a9:	e8 f3 e3 fe ff       	call   f0108ca1 <sbrk>
f011a8ae:	83 c4 10             	add    $0x10,%esp
f011a8b1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a8b4:	0f 87 3b ff ff ff    	ja     f011a7f5 <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011a8ba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a8be:	74 04                	je     f011a8c4 <test_kheap_phys_addr+0xc67>
f011a8c0:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011a8c4:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011a8cb:	83 ec 0c             	sub    $0xc,%esp
f011a8ce:	68 f4 e4 12 f0       	push   $0xf012e4f4
f011a8d3:	e8 b3 66 fe ff       	call   f0100f8b <cprintf>
f011a8d8:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011a8db:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011a8e2:	10 00 f9 
		i = 0;
f011a8e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011a8ec:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a8f2:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011a8f5:	eb 0a                	jmp    f011a901 <test_kheap_phys_addr+0xca4>
		{
			i++;
f011a8f7:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011a8fa:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011a901:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011a908:	76 ed                	jbe    f011a8f7 <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011a90a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a90d:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011a913:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011a91a:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a920:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011a923:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011a92a:	e9 cb 00 00 00       	jmp    f011a9fa <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011a92f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011a932:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011a937:	83 ec 04             	sub    $0x4,%esp
f011a93a:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011a940:	51                   	push   %ecx
f011a941:	52                   	push   %edx
f011a942:	50                   	push   %eax
f011a943:	e8 3c da fe ff       	call   f0108384 <get_page_table>
f011a948:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a94b:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011a951:	85 c0                	test   %eax,%eax
f011a953:	75 24                	jne    f011a979 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011a955:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a959:	74 1e                	je     f011a979 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a95b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a962:	83 ec 04             	sub    $0x4,%esp
f011a965:	68 30 e5 12 f0       	push   $0xf012e530
f011a96a:	68 88 06 00 00       	push   $0x688
f011a96f:	68 87 be 12 f0       	push   $0xf012be87
f011a974:	e8 c0 59 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011a979:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011a980:	eb 59                	jmp    f011a9db <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011a982:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a985:	c1 e0 0c             	shl    $0xc,%eax
f011a988:	89 c2                	mov    %eax,%edx
f011a98a:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a990:	01 d0                	add    %edx,%eax
f011a992:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011a998:	83 ec 0c             	sub    $0xc,%esp
f011a99b:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011a9a1:	e8 ae e6 fe ff       	call   f0109054 <kheap_physical_address>
f011a9a6:	83 c4 10             	add    $0x10,%esp
f011a9a9:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011a9af:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011a9b6:	74 1d                	je     f011a9d5 <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011a9b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a9bc:	74 17                	je     f011a9d5 <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011a9be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9c5:	83 ec 0c             	sub    $0xc,%esp
f011a9c8:	68 90 e5 12 f0       	push   $0xf012e590
f011a9cd:	e8 b9 65 fe ff       	call   f0100f8b <cprintf>
f011a9d2:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011a9d5:	ff 45 c8             	incl   -0x38(%ebp)
f011a9d8:	ff 45 f4             	incl   -0xc(%ebp)
f011a9db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a9de:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011a9e4:	7d 09                	jge    f011a9ef <test_kheap_phys_addr+0xd92>
f011a9e6:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011a9ed:	7e 93                	jle    f011a982 <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011a9ef:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011a9f6:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011a9fa:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011a9fe:	0f 88 2b ff ff ff    	js     f011a92f <test_kheap_phys_addr+0xcd2>
f011aa04:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011aa08:	7f 0d                	jg     f011aa17 <test_kheap_phys_addr+0xdba>
f011aa0a:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011aa11:	0f 86 18 ff ff ff    	jbe    f011a92f <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011aa17:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aa1b:	74 04                	je     f011aa21 <test_kheap_phys_addr+0xdc4>
f011aa1d:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011aa21:	83 ec 08             	sub    $0x8,%esp
f011aa24:	ff 75 f0             	pushl  -0x10(%ebp)
f011aa27:	68 b4 e5 12 f0       	push   $0xf012e5b4
f011aa2c:	e8 5a 65 fe ff       	call   f0100f8b <cprintf>
f011aa31:	83 c4 10             	add    $0x10,%esp

	return 1;
f011aa34:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011aa39:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011aa3c:	5b                   	pop    %ebx
f011aa3d:	5f                   	pop    %edi
f011aa3e:	5d                   	pop    %ebp
f011aa3f:	c3                   	ret    

f011aa40 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011aa40:	55                   	push   %ebp
f011aa41:	89 e5                	mov    %esp,%ebp
f011aa43:	57                   	push   %edi
f011aa44:	56                   	push   %esi
f011aa45:	53                   	push   %ebx
f011aa46:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011aa4c:	89 e0                	mov    %esp,%eax
f011aa4e:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011aa50:	83 ec 0c             	sub    $0xc,%esp
f011aa53:	68 28 9f 12 f0       	push   $0xf0129f28
f011aa58:	e8 2e 65 fe ff       	call   f0100f8b <cprintf>
f011aa5d:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011aa60:	83 ec 0c             	sub    $0xc,%esp
f011aa63:	68 58 9f 12 f0       	push   $0xf0129f58
f011aa68:	e8 1e 65 fe ff       	call   f0100f8b <cprintf>
f011aa6d:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011aa70:	83 ec 0c             	sub    $0xc,%esp
f011aa73:	68 28 9f 12 f0       	push   $0xf0129f28
f011aa78:	e8 0e 65 fe ff       	call   f0100f8b <cprintf>
f011aa7d:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011aa80:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011aa84:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011aa88:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011aa8e:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011aa94:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011aa9b:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011aaa2:	e8 7f 2f ff ff       	call   f010da26 <sys_calculate_free_frames>
f011aaa7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011aaaa:	83 ec 0c             	sub    $0xc,%esp
f011aaad:	68 90 dc 12 f0       	push   $0xf012dc90
f011aab2:	e8 d4 64 fe ff       	call   f0100f8b <cprintf>
f011aab7:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011aaba:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011aac0:	b9 14 00 00 00       	mov    $0x14,%ecx
f011aac5:	b8 00 00 00 00       	mov    $0x0,%eax
f011aaca:	89 d7                	mov    %edx,%edi
f011aacc:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011aace:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011aad4:	b9 14 00 00 00       	mov    $0x14,%ecx
f011aad9:	b8 00 00 00 00       	mov    $0x0,%eax
f011aade:	89 d7                	mov    %edx,%edi
f011aae0:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011aae2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011aae9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011aaf0:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011aaf6:	b9 14 00 00 00       	mov    $0x14,%ecx
f011aafb:	b8 00 00 00 00       	mov    $0x0,%eax
f011ab00:	89 d7                	mov    %edx,%edi
f011ab02:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ab04:	e8 1d 2f ff ff       	call   f010da26 <sys_calculate_free_frames>
f011ab09:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ab0c:	e8 55 9d fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ab11:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011ab14:	83 ec 0c             	sub    $0xc,%esp
f011ab17:	68 00 fc 1f 00       	push   $0x1ffc00
f011ab1c:	e8 6f e2 fe ff       	call   f0108d90 <kmalloc>
f011ab21:	83 c4 10             	add    $0x10,%esp
f011ab24:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ab2a:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011ab30:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ab35:	74 17                	je     f011ab4e <test_kheap_virt_addr+0x10e>
f011ab37:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ab3e:	83 ec 0c             	sub    $0xc,%esp
f011ab41:	68 34 c0 12 f0       	push   $0xf012c034
f011ab46:	e8 40 64 fe ff       	call   f0100f8b <cprintf>
f011ab4b:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab4e:	e8 13 9d fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ab53:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ab56:	74 17                	je     f011ab6f <test_kheap_virt_addr+0x12f>
f011ab58:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ab5f:	83 ec 0c             	sub    $0xc,%esp
f011ab62:	68 88 c0 12 f0       	push   $0xf012c088
f011ab67:	e8 1f 64 fe ff       	call   f0100f8b <cprintf>
f011ab6c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ab6f:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ab72:	e8 af 2e ff ff       	call   f010da26 <sys_calculate_free_frames>
f011ab77:	29 c3                	sub    %eax,%ebx
f011ab79:	89 d8                	mov    %ebx,%eax
f011ab7b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ab80:	77 17                	ja     f011ab99 <test_kheap_virt_addr+0x159>
f011ab82:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ab89:	83 ec 0c             	sub    $0xc,%esp
f011ab8c:	68 f8 c0 12 f0       	push   $0xf012c0f8
f011ab91:	e8 f5 63 fe ff       	call   f0100f8b <cprintf>
f011ab96:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ab99:	e8 88 2e ff ff       	call   f010da26 <sys_calculate_free_frames>
f011ab9e:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aba1:	e8 c0 9c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aba6:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011aba9:	83 ec 0c             	sub    $0xc,%esp
f011abac:	68 00 fc 1f 00       	push   $0x1ffc00
f011abb1:	e8 da e1 fe ff       	call   f0108d90 <kmalloc>
f011abb6:	83 c4 10             	add    $0x10,%esp
f011abb9:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011abbf:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011abc5:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011abca:	74 17                	je     f011abe3 <test_kheap_virt_addr+0x1a3>
f011abcc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011abd3:	83 ec 0c             	sub    $0xc,%esp
f011abd6:	68 40 c1 12 f0       	push   $0xf012c140
f011abdb:	e8 ab 63 fe ff       	call   f0100f8b <cprintf>
f011abe0:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011abe3:	e8 7e 9c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011abe8:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011abeb:	74 17                	je     f011ac04 <test_kheap_virt_addr+0x1c4>
f011abed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011abf4:	83 ec 0c             	sub    $0xc,%esp
f011abf7:	68 94 c1 12 f0       	push   $0xf012c194
f011abfc:	e8 8a 63 fe ff       	call   f0100f8b <cprintf>
f011ac01:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ac04:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ac07:	e8 1a 2e ff ff       	call   f010da26 <sys_calculate_free_frames>
f011ac0c:	29 c3                	sub    %eax,%ebx
f011ac0e:	89 d8                	mov    %ebx,%eax
f011ac10:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ac15:	77 17                	ja     f011ac2e <test_kheap_virt_addr+0x1ee>
f011ac17:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ac1e:	83 ec 0c             	sub    $0xc,%esp
f011ac21:	68 04 c2 12 f0       	push   $0xf012c204
f011ac26:	e8 60 63 fe ff       	call   f0100f8b <cprintf>
f011ac2b:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011ac2e:	e8 f3 2d ff ff       	call   f010da26 <sys_calculate_free_frames>
f011ac33:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ac36:	e8 2b 9c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ac3b:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011ac3e:	83 ec 0c             	sub    $0xc,%esp
f011ac41:	68 00 04 00 00       	push   $0x400
f011ac46:	e8 45 e1 fe ff       	call   f0108d90 <kmalloc>
f011ac4b:	83 c4 10             	add    $0x10,%esp
f011ac4e:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011ac54:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011ac5a:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011ac5f:	76 28                	jbe    f011ac89 <test_kheap_virt_addr+0x249>
f011ac61:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011ac67:	83 ec 0c             	sub    $0xc,%esp
f011ac6a:	6a 00                	push   $0x0
f011ac6c:	e8 30 e0 fe ff       	call   f0108ca1 <sbrk>
f011ac71:	83 c4 10             	add    $0x10,%esp
f011ac74:	39 c3                	cmp    %eax,%ebx
f011ac76:	73 11                	jae    f011ac89 <test_kheap_virt_addr+0x249>
f011ac78:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011ac7e:	89 c2                	mov    %eax,%edx
f011ac80:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f011ac85:	39 c2                	cmp    %eax,%edx
f011ac87:	72 17                	jb     f011aca0 <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011ac89:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ac90:	83 ec 0c             	sub    $0xc,%esp
f011ac93:	68 c0 dc 12 f0       	push   $0xf012dcc0
f011ac98:	e8 ee 62 fe ff       	call   f0100f8b <cprintf>
f011ac9d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aca0:	e8 c1 9b fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aca5:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011aca8:	74 17                	je     f011acc1 <test_kheap_virt_addr+0x281>
f011acaa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011acb1:	83 ec 0c             	sub    $0xc,%esp
f011acb4:	68 a0 c2 12 f0       	push   $0xf012c2a0
f011acb9:	e8 cd 62 fe ff       	call   f0100f8b <cprintf>
f011acbe:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011acc1:	e8 60 2d ff ff       	call   f010da26 <sys_calculate_free_frames>
f011acc6:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011acc9:	e8 98 9b fe ff       	call   f0104866 <pf_calculate_free_frames>
f011acce:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011acd1:	83 ec 0c             	sub    $0xc,%esp
f011acd4:	68 00 08 00 00       	push   $0x800
f011acd9:	e8 b2 e0 fe ff       	call   f0108d90 <kmalloc>
f011acde:	83 c4 10             	add    $0x10,%esp
f011ace1:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011ace7:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011aced:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011acf2:	76 28                	jbe    f011ad1c <test_kheap_virt_addr+0x2dc>
f011acf4:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011acfa:	83 ec 0c             	sub    $0xc,%esp
f011acfd:	6a 00                	push   $0x0
f011acff:	e8 9d df fe ff       	call   f0108ca1 <sbrk>
f011ad04:	83 c4 10             	add    $0x10,%esp
f011ad07:	39 c3                	cmp    %eax,%ebx
f011ad09:	73 11                	jae    f011ad1c <test_kheap_virt_addr+0x2dc>
f011ad0b:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011ad11:	89 c2                	mov    %eax,%edx
f011ad13:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f011ad18:	39 c2                	cmp    %eax,%edx
f011ad1a:	72 17                	jb     f011ad33 <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011ad1c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ad23:	83 ec 0c             	sub    $0xc,%esp
f011ad26:	68 4c dd 12 f0       	push   $0xf012dd4c
f011ad2b:	e8 5b 62 fe ff       	call   f0100f8b <cprintf>
f011ad30:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ad33:	e8 2e 9b fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ad38:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ad3b:	74 17                	je     f011ad54 <test_kheap_virt_addr+0x314>
f011ad3d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ad44:	83 ec 0c             	sub    $0xc,%esp
f011ad47:	68 ac c3 12 f0       	push   $0xf012c3ac
f011ad4c:	e8 3a 62 fe ff       	call   f0100f8b <cprintf>
f011ad51:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011ad54:	e8 cd 2c ff ff       	call   f010da26 <sys_calculate_free_frames>
f011ad59:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ad5c:	e8 05 9b fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ad61:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011ad64:	83 ec 0c             	sub    $0xc,%esp
f011ad67:	68 00 06 00 00       	push   $0x600
f011ad6c:	e8 1f e0 fe ff       	call   f0108d90 <kmalloc>
f011ad71:	83 c4 10             	add    $0x10,%esp
f011ad74:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011ad7a:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011ad80:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011ad85:	76 28                	jbe    f011adaf <test_kheap_virt_addr+0x36f>
f011ad87:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011ad8d:	83 ec 0c             	sub    $0xc,%esp
f011ad90:	6a 00                	push   $0x0
f011ad92:	e8 0a df fe ff       	call   f0108ca1 <sbrk>
f011ad97:	83 c4 10             	add    $0x10,%esp
f011ad9a:	39 c3                	cmp    %eax,%ebx
f011ad9c:	73 11                	jae    f011adaf <test_kheap_virt_addr+0x36f>
f011ad9e:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011ada4:	89 c2                	mov    %eax,%edx
f011ada6:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f011adab:	39 c2                	cmp    %eax,%edx
f011adad:	72 17                	jb     f011adc6 <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011adaf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011adb6:	83 ec 0c             	sub    $0xc,%esp
f011adb9:	68 d8 dd 12 f0       	push   $0xf012ddd8
f011adbe:	e8 c8 61 fe ff       	call   f0100f8b <cprintf>
f011adc3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011adc6:	e8 9b 9a fe ff       	call   f0104866 <pf_calculate_free_frames>
f011adcb:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011adce:	74 17                	je     f011ade7 <test_kheap_virt_addr+0x3a7>
f011add0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011add7:	83 ec 0c             	sub    $0xc,%esp
f011adda:	68 b8 c4 12 f0       	push   $0xf012c4b8
f011addf:	e8 a7 61 fe ff       	call   f0100f8b <cprintf>
f011ade4:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011ade7:	e8 3a 2c ff ff       	call   f010da26 <sys_calculate_free_frames>
f011adec:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011adef:	e8 72 9a fe ff       	call   f0104866 <pf_calculate_free_frames>
f011adf4:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011adf7:	83 ec 0c             	sub    $0xc,%esp
f011adfa:	68 00 1c 00 00       	push   $0x1c00
f011adff:	e8 8c df fe ff       	call   f0108d90 <kmalloc>
f011ae04:	83 c4 10             	add    $0x10,%esp
f011ae07:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ae0d:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011ae13:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011ae18:	74 17                	je     f011ae31 <test_kheap_virt_addr+0x3f1>
f011ae1a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ae21:	83 ec 0c             	sub    $0xc,%esp
f011ae24:	68 70 c5 12 f0       	push   $0xf012c570
f011ae29:	e8 5d 61 fe ff       	call   f0100f8b <cprintf>
f011ae2e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae31:	e8 30 9a fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ae36:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ae39:	74 17                	je     f011ae52 <test_kheap_virt_addr+0x412>
f011ae3b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ae42:	83 ec 0c             	sub    $0xc,%esp
f011ae45:	68 c4 c5 12 f0       	push   $0xf012c5c4
f011ae4a:	e8 3c 61 fe ff       	call   f0100f8b <cprintf>
f011ae4f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ae52:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ae55:	e8 cc 2b ff ff       	call   f010da26 <sys_calculate_free_frames>
f011ae5a:	29 c3                	sub    %eax,%ebx
f011ae5c:	89 d8                	mov    %ebx,%eax
f011ae5e:	83 f8 01             	cmp    $0x1,%eax
f011ae61:	77 17                	ja     f011ae7a <test_kheap_virt_addr+0x43a>
f011ae63:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ae6a:	83 ec 0c             	sub    $0xc,%esp
f011ae6d:	68 34 c6 12 f0       	push   $0xf012c634
f011ae72:	e8 14 61 fe ff       	call   f0100f8b <cprintf>
f011ae77:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011ae7a:	e8 a7 2b ff ff       	call   f010da26 <sys_calculate_free_frames>
f011ae7f:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ae82:	e8 df 99 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011ae87:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011ae8a:	83 ec 0c             	sub    $0xc,%esp
f011ae8d:	68 00 fc 2f 00       	push   $0x2ffc00
f011ae92:	e8 f9 de fe ff       	call   f0108d90 <kmalloc>
f011ae97:	83 c4 10             	add    $0x10,%esp
f011ae9a:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aea0:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011aea6:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011aeab:	74 17                	je     f011aec4 <test_kheap_virt_addr+0x484>
f011aead:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aeb4:	83 ec 0c             	sub    $0xc,%esp
f011aeb7:	68 64 de 12 f0       	push   $0xf012de64
f011aebc:	e8 ca 60 fe ff       	call   f0100f8b <cprintf>
f011aec1:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aec4:	e8 9d 99 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aec9:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011aecc:	74 17                	je     f011aee5 <test_kheap_virt_addr+0x4a5>
f011aece:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aed5:	83 ec 0c             	sub    $0xc,%esp
f011aed8:	68 08 c7 12 f0       	push   $0xf012c708
f011aedd:	e8 a9 60 fe ff       	call   f0100f8b <cprintf>
f011aee2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aee5:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011aee8:	e8 39 2b ff ff       	call   f010da26 <sys_calculate_free_frames>
f011aeed:	29 c3                	sub    %eax,%ebx
f011aeef:	89 d8                	mov    %ebx,%eax
f011aef1:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011aef6:	77 17                	ja     f011af0f <test_kheap_virt_addr+0x4cf>
f011aef8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aeff:	83 ec 0c             	sub    $0xc,%esp
f011af02:	68 b8 de 12 f0       	push   $0xf012deb8
f011af07:	e8 7f 60 fe ff       	call   f0100f8b <cprintf>
f011af0c:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011af0f:	e8 12 2b ff ff       	call   f010da26 <sys_calculate_free_frames>
f011af14:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011af17:	e8 4a 99 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011af1c:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011af1f:	83 ec 0c             	sub    $0xc,%esp
f011af22:	68 00 fc 5f 00       	push   $0x5ffc00
f011af27:	e8 64 de fe ff       	call   f0108d90 <kmalloc>
f011af2c:	83 c4 10             	add    $0x10,%esp
f011af2f:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011af35:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011af3b:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011af40:	74 17                	je     f011af59 <test_kheap_virt_addr+0x519>
f011af42:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011af49:	83 ec 0c             	sub    $0xc,%esp
f011af4c:	68 00 df 12 f0       	push   $0xf012df00
f011af51:	e8 35 60 fe ff       	call   f0100f8b <cprintf>
f011af56:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af59:	e8 08 99 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011af5e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011af61:	74 17                	je     f011af7a <test_kheap_virt_addr+0x53a>
f011af63:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011af6a:	83 ec 0c             	sub    $0xc,%esp
f011af6d:	68 04 c8 12 f0       	push   $0xf012c804
f011af72:	e8 14 60 fe ff       	call   f0100f8b <cprintf>
f011af77:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011af7a:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011af7d:	e8 a4 2a ff ff       	call   f010da26 <sys_calculate_free_frames>
f011af82:	29 c3                	sub    %eax,%ebx
f011af84:	89 d8                	mov    %ebx,%eax
f011af86:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011af8b:	77 17                	ja     f011afa4 <test_kheap_virt_addr+0x564>
f011af8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011af94:	83 ec 0c             	sub    $0xc,%esp
f011af97:	68 54 df 12 f0       	push   $0xf012df54
f011af9c:	e8 ea 5f fe ff       	call   f0100f8b <cprintf>
f011afa1:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011afa4:	e8 7d 2a ff ff       	call   f010da26 <sys_calculate_free_frames>
f011afa9:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011afac:	e8 b5 98 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011afb1:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011afb4:	83 ec 0c             	sub    $0xc,%esp
f011afb7:	68 00 38 00 00       	push   $0x3800
f011afbc:	e8 cf dd fe ff       	call   f0108d90 <kmalloc>
f011afc1:	83 c4 10             	add    $0x10,%esp
f011afc4:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011afca:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011afd0:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011afd5:	74 17                	je     f011afee <test_kheap_virt_addr+0x5ae>
f011afd7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011afde:	83 ec 0c             	sub    $0xc,%esp
f011afe1:	68 9c df 12 f0       	push   $0xf012df9c
f011afe6:	e8 a0 5f fe ff       	call   f0100f8b <cprintf>
f011afeb:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011afee:	e8 73 98 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011aff3:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011aff6:	74 17                	je     f011b00f <test_kheap_virt_addr+0x5cf>
f011aff8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011afff:	83 ec 0c             	sub    $0xc,%esp
f011b002:	68 f0 df 12 f0       	push   $0xf012dff0
f011b007:	e8 7f 5f fe ff       	call   f0100f8b <cprintf>
f011b00c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b00f:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b012:	e8 0f 2a ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b017:	29 c3                	sub    %eax,%ebx
f011b019:	89 d8                	mov    %ebx,%eax
f011b01b:	83 f8 03             	cmp    $0x3,%eax
f011b01e:	77 17                	ja     f011b037 <test_kheap_virt_addr+0x5f7>
f011b020:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b027:	83 ec 0c             	sub    $0xc,%esp
f011b02a:	68 60 e0 12 f0       	push   $0xf012e060
f011b02f:	e8 57 5f fe ff       	call   f0100f8b <cprintf>
f011b034:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011b037:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011b03e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b041:	c1 e8 0c             	shr    $0xc,%eax
f011b044:	89 c2                	mov    %eax,%edx
f011b046:	4a                   	dec    %edx
f011b047:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011b04a:	c1 e0 02             	shl    $0x2,%eax
f011b04d:	8d 50 03             	lea    0x3(%eax),%edx
f011b050:	b8 10 00 00 00       	mov    $0x10,%eax
f011b055:	48                   	dec    %eax
f011b056:	01 d0                	add    %edx,%eax
f011b058:	bf 10 00 00 00       	mov    $0x10,%edi
f011b05d:	ba 00 00 00 00       	mov    $0x0,%edx
f011b062:	f7 f7                	div    %edi
f011b064:	6b c0 10             	imul   $0x10,%eax,%eax
f011b067:	29 c4                	sub    %eax,%esp
f011b069:	89 e0                	mov    %esp,%eax
f011b06b:	83 c0 03             	add    $0x3,%eax
f011b06e:	c1 e8 02             	shr    $0x2,%eax
f011b071:	c1 e0 02             	shl    $0x2,%eax
f011b074:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011b077:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b07a:	c1 e8 0c             	shr    $0xc,%eax
f011b07d:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011b080:	83 ec 0c             	sub    $0xc,%esp
f011b083:	68 e8 e5 12 f0       	push   $0xf012e5e8
f011b088:	e8 fe 5e fe ff       	call   f0100f8b <cprintf>
f011b08d:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b090:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b097:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f011b09c:	05 00 10 00 00       	add    $0x1000,%eax
f011b0a1:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011b0a4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b0ab:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b0ae:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011b0b1:	e9 2d 01 00 00       	jmp    f011b1e3 <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b0b6:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011b0bb:	83 ec 04             	sub    $0x4,%esp
f011b0be:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011b0c4:	52                   	push   %edx
f011b0c5:	ff 75 dc             	pushl  -0x24(%ebp)
f011b0c8:	50                   	push   %eax
f011b0c9:	e8 b6 d2 fe ff       	call   f0108384 <get_page_table>
f011b0ce:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b0d1:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b0d7:	85 c0                	test   %eax,%eax
f011b0d9:	75 1e                	jne    f011b0f9 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b0db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b0e2:	83 ec 04             	sub    $0x4,%esp
f011b0e5:	68 f4 e0 12 f0       	push   $0xf012e0f4
f011b0ea:	68 27 07 00 00       	push   $0x727
f011b0ef:	68 87 be 12 f0       	push   $0xf012be87
f011b0f4:	e8 40 52 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011b0f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011b0fc:	c1 e8 0c             	shr    $0xc,%eax
f011b0ff:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b104:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b107:	e9 ba 00 00 00       	jmp    f011b1c6 <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011b10c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011b10f:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011b112:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b118:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b11b:	c1 e2 02             	shl    $0x2,%edx
f011b11e:	01 d0                	add    %edx,%eax
f011b120:	8b 00                	mov    (%eax),%eax
f011b122:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b127:	89 c2                	mov    %eax,%edx
f011b129:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b12c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011b12f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b132:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011b135:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b138:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b13b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011b13e:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b141:	83 ec 0c             	sub    $0xc,%esp
f011b144:	50                   	push   %eax
f011b145:	e8 3b df fe ff       	call   f0109085 <kheap_virtual_address>
f011b14a:	83 c4 10             	add    $0x10,%esp
f011b14d:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011b150:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011b153:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b156:	01 d0                	add    %edx,%eax
f011b158:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b15b:	74 5c                	je     f011b1b9 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011b15d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b161:	74 56                	je     f011b1b9 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011b163:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b166:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011b169:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b16c:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011b172:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011b175:	c1 e1 02             	shl    $0x2,%ecx
f011b178:	01 ca                	add    %ecx,%edx
f011b17a:	8b 12                	mov    (%edx),%edx
f011b17c:	89 d1                	mov    %edx,%ecx
f011b17e:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011b184:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011b187:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b18a:	01 da                	add    %ebx,%edx
f011b18c:	83 ec 0c             	sub    $0xc,%esp
f011b18f:	50                   	push   %eax
f011b190:	51                   	push   %ecx
f011b191:	52                   	push   %edx
f011b192:	ff 75 8c             	pushl  -0x74(%ebp)
f011b195:	68 34 e6 12 f0       	push   $0xf012e634
f011b19a:	e8 ec 5d fe ff       	call   f0100f8b <cprintf>
f011b19f:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011b1a2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b1a9:	83 ec 0c             	sub    $0xc,%esp
f011b1ac:	68 78 e6 12 f0       	push   $0xf012e678
f011b1b1:	e8 d5 5d fe ff       	call   f0100f8b <cprintf>
f011b1b6:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011b1b9:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011b1c0:	ff 45 d4             	incl   -0x2c(%ebp)
f011b1c3:	ff 45 d8             	incl   -0x28(%ebp)
f011b1c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b1c9:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011b1cc:	7d 15                	jge    f011b1e3 <test_kheap_virt_addr+0x7a3>
f011b1ce:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011b1d5:	7f 0c                	jg     f011b1e3 <test_kheap_virt_addr+0x7a3>
f011b1d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011b1da:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011b1dd:	0f 82 29 ff ff ff    	jb     f011b10c <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b1e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011b1e6:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011b1e9:	0f 82 c7 fe ff ff    	jb     f011b0b6 <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011b1ef:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b1f3:	74 04                	je     f011b1f9 <test_kheap_virt_addr+0x7b9>
f011b1f5:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011b1f9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011b200:	83 ec 0c             	sub    $0xc,%esp
f011b203:	68 9c e6 12 f0       	push   $0xf012e69c
f011b208:	e8 7e 5d fe ff       	call   f0100f8b <cprintf>
f011b20d:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011b210:	e8 11 28 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b215:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011b218:	e8 49 96 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b21d:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011b220:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b226:	83 ec 0c             	sub    $0xc,%esp
f011b229:	50                   	push   %eax
f011b22a:	e8 77 dd fe ff       	call   f0108fa6 <kfree>
f011b22f:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b232:	e8 2f 96 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b237:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b23a:	74 17                	je     f011b253 <test_kheap_virt_addr+0x813>
f011b23c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b243:	83 ec 0c             	sub    $0xc,%esp
f011b246:	68 c4 e6 12 f0       	push   $0xf012e6c4
f011b24b:	e8 3b 5d fe ff       	call   f0100f8b <cprintf>
f011b250:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b253:	e8 ce 27 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b258:	89 c2                	mov    %eax,%edx
f011b25a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b25d:	29 c2                	sub    %eax,%edx
f011b25f:	89 d0                	mov    %edx,%eax
f011b261:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b266:	77 17                	ja     f011b27f <test_kheap_virt_addr+0x83f>
f011b268:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b26f:	83 ec 0c             	sub    $0xc,%esp
f011b272:	68 34 e7 12 f0       	push   $0xf012e734
f011b277:	e8 0f 5d fe ff       	call   f0100f8b <cprintf>
f011b27c:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b27f:	e8 a2 27 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b284:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b287:	e8 da 95 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b28c:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011b28f:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b295:	83 ec 0c             	sub    $0xc,%esp
f011b298:	50                   	push   %eax
f011b299:	e8 08 dd fe ff       	call   f0108fa6 <kfree>
f011b29e:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b2a1:	e8 c0 95 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b2a6:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b2a9:	74 17                	je     f011b2c2 <test_kheap_virt_addr+0x882>
f011b2ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b2b2:	83 ec 0c             	sub    $0xc,%esp
f011b2b5:	68 70 e7 12 f0       	push   $0xf012e770
f011b2ba:	e8 cc 5c fe ff       	call   f0100f8b <cprintf>
f011b2bf:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b2c2:	e8 5f 27 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b2c7:	89 c2                	mov    %eax,%edx
f011b2c9:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b2cc:	29 c2                	sub    %eax,%edx
f011b2ce:	89 d0                	mov    %edx,%eax
f011b2d0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b2d5:	77 17                	ja     f011b2ee <test_kheap_virt_addr+0x8ae>
f011b2d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b2de:	83 ec 0c             	sub    $0xc,%esp
f011b2e1:	68 e0 e7 12 f0       	push   $0xf012e7e0
f011b2e6:	e8 a0 5c fe ff       	call   f0100f8b <cprintf>
f011b2eb:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b2ee:	e8 33 27 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b2f3:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b2f6:	e8 6b 95 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b2fb:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b2fe:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b304:	83 ec 0c             	sub    $0xc,%esp
f011b307:	50                   	push   %eax
f011b308:	e8 99 dc fe ff       	call   f0108fa6 <kfree>
f011b30d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b310:	e8 51 95 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b315:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b318:	74 17                	je     f011b331 <test_kheap_virt_addr+0x8f1>
f011b31a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b321:	83 ec 0c             	sub    $0xc,%esp
f011b324:	68 1c e8 12 f0       	push   $0xf012e81c
f011b329:	e8 5d 5c fe ff       	call   f0100f8b <cprintf>
f011b32e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b331:	e8 f0 26 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b336:	89 c2                	mov    %eax,%edx
f011b338:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b33b:	29 c2                	sub    %eax,%edx
f011b33d:	89 d0                	mov    %edx,%eax
f011b33f:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b344:	77 17                	ja     f011b35d <test_kheap_virt_addr+0x91d>
f011b346:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b34d:	83 ec 0c             	sub    $0xc,%esp
f011b350:	68 8c e8 12 f0       	push   $0xf012e88c
f011b355:	e8 31 5c fe ff       	call   f0100f8b <cprintf>
f011b35a:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011b35d:	83 ec 0c             	sub    $0xc,%esp
f011b360:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011b365:	e8 21 5c fe ff       	call   f0100f8b <cprintf>
f011b36a:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b36d:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b374:	a1 d8 cd 17 f0       	mov    0xf017cdd8,%eax
f011b379:	05 00 10 00 00       	add    $0x1000,%eax
f011b37e:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011b384:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011b38b:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011b392:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011b395:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b39b:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b39e:	eb 44                	jmp    f011b3e4 <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b3a0:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b3a3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b3a6:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b3a9:	83 ec 0c             	sub    $0xc,%esp
f011b3ac:	50                   	push   %eax
f011b3ad:	e8 d3 dc fe ff       	call   f0109085 <kheap_virtual_address>
f011b3b2:	83 c4 10             	add    $0x10,%esp
f011b3b5:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011b3bb:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011b3c2:	74 1d                	je     f011b3e1 <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011b3c4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b3c8:	74 17                	je     f011b3e1 <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011b3ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b3d1:	83 ec 0c             	sub    $0xc,%esp
f011b3d4:	68 18 e9 12 f0       	push   $0xf012e918
f011b3d9:	e8 ad 5b fe ff       	call   f0100f8b <cprintf>
f011b3de:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011b3e1:	ff 45 d0             	incl   -0x30(%ebp)
f011b3e4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b3ea:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011b3f0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b3f3:	39 c2                	cmp    %eax,%edx
f011b3f5:	77 a9                	ja     f011b3a0 <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b3f7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b3fd:	05 00 04 00 00       	add    $0x400,%eax
f011b402:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b405:	eb 64                	jmp    f011b46b <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b407:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b40a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b40d:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b410:	83 ec 0c             	sub    $0xc,%esp
f011b413:	50                   	push   %eax
f011b414:	e8 6c dc fe ff       	call   f0109085 <kheap_virtual_address>
f011b419:	83 c4 10             	add    $0x10,%esp
f011b41c:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011b422:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b425:	c1 e0 0c             	shl    $0xc,%eax
f011b428:	89 c2                	mov    %eax,%edx
f011b42a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b430:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011b433:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b436:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b439:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b43c:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b441:	01 c8                	add    %ecx,%eax
f011b443:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011b449:	74 1d                	je     f011b468 <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011b44b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b44f:	74 17                	je     f011b468 <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011b451:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b458:	83 ec 0c             	sub    $0xc,%esp
f011b45b:	68 3c e9 12 f0       	push   $0xf012e93c
f011b460:	e8 26 5b fe ff       	call   f0100f8b <cprintf>
f011b465:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b468:	ff 45 d0             	incl   -0x30(%ebp)
f011b46b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b471:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011b477:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b47a:	39 c2                	cmp    %eax,%edx
f011b47c:	77 89                	ja     f011b407 <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b47e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b484:	05 02 07 00 00       	add    $0x702,%eax
f011b489:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b48c:	eb 44                	jmp    f011b4d2 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b48e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b491:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b494:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b497:	83 ec 0c             	sub    $0xc,%esp
f011b49a:	50                   	push   %eax
f011b49b:	e8 e5 db fe ff       	call   f0109085 <kheap_virtual_address>
f011b4a0:	83 c4 10             	add    $0x10,%esp
f011b4a3:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011b4a9:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011b4b0:	74 1d                	je     f011b4cf <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011b4b2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b4b6:	74 17                	je     f011b4cf <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011b4b8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b4bf:	83 ec 0c             	sub    $0xc,%esp
f011b4c2:	68 60 e9 12 f0       	push   $0xf012e960
f011b4c7:	e8 bf 5a fe ff       	call   f0100f8b <cprintf>
f011b4cc:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b4cf:	ff 45 d0             	incl   -0x30(%ebp)
f011b4d2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b4d8:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011b4de:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b4e1:	39 c2                	cmp    %eax,%edx
f011b4e3:	77 a9                	ja     f011b48e <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011b4e5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b4eb:	05 02 0d 00 00       	add    $0xd02,%eax
f011b4f0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b4f3:	eb 64                	jmp    f011b559 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b4f5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b4f8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b4fb:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b4fe:	83 ec 0c             	sub    $0xc,%esp
f011b501:	50                   	push   %eax
f011b502:	e8 7e db fe ff       	call   f0109085 <kheap_virtual_address>
f011b507:	83 c4 10             	add    $0x10,%esp
f011b50a:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011b510:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b513:	c1 e0 0c             	shl    $0xc,%eax
f011b516:	89 c2                	mov    %eax,%edx
f011b518:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b51e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011b521:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b524:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b527:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b52a:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b52f:	01 c8                	add    %ecx,%eax
f011b531:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011b537:	74 1d                	je     f011b556 <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011b539:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b53d:	74 17                	je     f011b556 <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011b53f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b546:	83 ec 0c             	sub    $0xc,%esp
f011b549:	68 84 e9 12 f0       	push   $0xf012e984
f011b54e:	e8 38 5a fe ff       	call   f0100f8b <cprintf>
f011b553:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011b556:	ff 45 d0             	incl   -0x30(%ebp)
f011b559:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b55f:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011b565:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b568:	39 c2                	cmp    %eax,%edx
f011b56a:	77 89                	ja     f011b4f5 <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011b56c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b570:	74 04                	je     f011b576 <test_kheap_virt_addr+0xb36>
f011b572:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011b576:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011b57d:	83 ec 0c             	sub    $0xc,%esp
f011b580:	68 a8 e9 12 f0       	push   $0xf012e9a8
f011b585:	e8 01 5a fe ff       	call   f0100f8b <cprintf>
f011b58a:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011b58d:	83 ec 0c             	sub    $0xc,%esp
f011b590:	6a 00                	push   $0x0
f011b592:	e8 0a d7 fe ff       	call   f0108ca1 <sbrk>
f011b597:	83 c4 10             	add    $0x10,%esp
f011b59a:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b59f:	77 17                	ja     f011b5b8 <test_kheap_virt_addr+0xb78>
f011b5a1:	83 ec 04             	sub    $0x4,%esp
f011b5a4:	68 ef e9 12 f0       	push   $0xf012e9ef
f011b5a9:	68 92 07 00 00       	push   $0x792
f011b5ae:	68 87 be 12 f0       	push   $0xf012be87
f011b5b3:	e8 81 4d fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b5b8:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011b5bf:	e9 d1 00 00 00       	jmp    f011b695 <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b5c4:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011b5c9:	83 ec 04             	sub    $0x4,%esp
f011b5cc:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b5d2:	52                   	push   %edx
f011b5d3:	ff 75 cc             	pushl  -0x34(%ebp)
f011b5d6:	50                   	push   %eax
f011b5d7:	e8 a8 cd fe ff       	call   f0108384 <get_page_table>
f011b5dc:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b5df:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b5e5:	85 c0                	test   %eax,%eax
f011b5e7:	75 1e                	jne    f011b607 <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b5e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b5f0:	83 ec 04             	sub    $0x4,%esp
f011b5f3:	68 78 e3 12 f0       	push   $0xf012e378
f011b5f8:	68 98 07 00 00       	push   $0x798
f011b5fd:	68 87 be 12 f0       	push   $0xf012be87
f011b602:	e8 32 4d fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011b607:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b60d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011b610:	c1 ea 0c             	shr    $0xc,%edx
f011b613:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b619:	c1 e2 02             	shl    $0x2,%edx
f011b61c:	01 d0                	add    %edx,%eax
f011b61e:	8b 00                	mov    (%eax),%eax
f011b620:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b625:	89 c2                	mov    %eax,%edx
f011b627:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011b62a:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b62f:	01 d0                	add    %edx,%eax
f011b631:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011b637:	83 ec 0c             	sub    $0xc,%esp
f011b63a:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011b640:	e8 40 da fe ff       	call   f0109085 <kheap_virtual_address>
f011b645:	83 c4 10             	add    $0x10,%esp
f011b648:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011b64e:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011b654:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011b657:	74 39                	je     f011b692 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011b659:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b65d:	74 33                	je     f011b692 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011b65f:	ff 75 cc             	pushl  -0x34(%ebp)
f011b662:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011b668:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011b66e:	68 08 ea 12 f0       	push   $0xf012ea08
f011b673:	e8 13 59 fe ff       	call   f0100f8b <cprintf>
f011b678:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011b67b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b682:	83 ec 0c             	sub    $0xc,%esp
f011b685:	68 34 ea 12 f0       	push   $0xf012ea34
f011b68a:	e8 fc 58 fe ff       	call   f0100f8b <cprintf>
f011b68f:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b692:	ff 45 cc             	incl   -0x34(%ebp)
f011b695:	83 ec 0c             	sub    $0xc,%esp
f011b698:	6a 00                	push   $0x0
f011b69a:	e8 02 d6 fe ff       	call   f0108ca1 <sbrk>
f011b69f:	83 c4 10             	add    $0x10,%esp
f011b6a2:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011b6a5:	0f 87 19 ff ff ff    	ja     f011b5c4 <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011b6ab:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b6af:	74 04                	je     f011b6b5 <test_kheap_virt_addr+0xc75>
f011b6b1:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011b6b5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011b6bc:	83 ec 0c             	sub    $0xc,%esp
f011b6bf:	68 58 ea 12 f0       	push   $0xf012ea58
f011b6c4:	e8 c2 58 fe ff       	call   f0100f8b <cprintf>
f011b6c9:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011b6cc:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011b6d3:	eb 5a                	jmp    f011b72f <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011b6d5:	83 ec 0c             	sub    $0xc,%esp
f011b6d8:	ff 75 c8             	pushl  -0x38(%ebp)
f011b6db:	e8 a5 d9 fe ff       	call   f0109085 <kheap_virtual_address>
f011b6e0:	83 c4 10             	add    $0x10,%esp
f011b6e3:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011b6e9:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011b6f0:	74 36                	je     f011b728 <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011b6f2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b6f6:	74 30                	je     f011b728 <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011b6f8:	83 ec 04             	sub    $0x4,%esp
f011b6fb:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011b701:	ff 75 c8             	pushl  -0x38(%ebp)
f011b704:	68 97 ea 12 f0       	push   $0xf012ea97
f011b709:	e8 7d 58 fe ff       	call   f0100f8b <cprintf>
f011b70e:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011b711:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b718:	83 ec 0c             	sub    $0xc,%esp
f011b71b:	68 b4 ea 12 f0       	push   $0xf012eab4
f011b720:	e8 66 58 fe ff       	call   f0100f8b <cprintf>
f011b725:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011b728:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011b72f:	b8 70 74 61 00       	mov    $0x617470,%eax
f011b734:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011b737:	72 9c                	jb     f011b6d5 <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011b739:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b73d:	74 04                	je     f011b743 <test_kheap_virt_addr+0xd03>
f011b73f:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011b743:	83 ec 08             	sub    $0x8,%esp
f011b746:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b749:	68 d8 ea 12 f0       	push   $0xf012ead8
f011b74e:	e8 38 58 fe ff       	call   f0100f8b <cprintf>
f011b753:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b756:	b8 01 00 00 00       	mov    $0x1,%eax
f011b75b:	89 f4                	mov    %esi,%esp

}
f011b75d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011b760:	5b                   	pop    %ebx
f011b761:	5e                   	pop    %esi
f011b762:	5f                   	pop    %edi
f011b763:	5d                   	pop    %ebp
f011b764:	c3                   	ret    

f011b765 <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011b765:	55                   	push   %ebp
f011b766:	89 e5                	mov    %esp,%ebp
f011b768:	57                   	push   %edi
f011b769:	56                   	push   %esi
f011b76a:	53                   	push   %ebx
f011b76b:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011b771:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011b777:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b77c:	b8 00 00 00 00       	mov    $0x0,%eax
f011b781:	89 d7                	mov    %edx,%edi
f011b783:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011b785:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011b78c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011b793:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011b79a:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f011b79f:	0f b6 c0             	movzbl %al,%eax
f011b7a2:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011b7a5:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011b7ac:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b7af:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011b7b2:	39 c2                	cmp    %eax,%edx
f011b7b4:	73 02                	jae    f011b7b8 <test_ksbrk+0x53>
f011b7b6:	89 c2                	mov    %eax,%edx
f011b7b8:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f011b7bd:	0f b6 c0             	movzbl %al,%eax
f011b7c0:	c1 e0 04             	shl    $0x4,%eax
f011b7c3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011b7c6:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011b7cd:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011b7d0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b7d3:	39 c8                	cmp    %ecx,%eax
f011b7d5:	73 02                	jae    f011b7d9 <test_ksbrk+0x74>
f011b7d7:	89 c8                	mov    %ecx,%eax
f011b7d9:	01 d0                	add    %edx,%eax
f011b7db:	83 c0 10             	add    $0x10,%eax
f011b7de:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011b7e3:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011b7e6:	83 ec 0c             	sub    $0xc,%esp
f011b7e9:	68 0c eb 12 f0       	push   $0xf012eb0c
f011b7ee:	e8 98 57 fe ff       	call   f0100f8b <cprintf>
f011b7f3:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011b7f6:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b7fd:	e8 24 22 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b802:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b805:	e8 5c 90 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b80a:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011b80d:	83 ec 10             	sub    $0x10,%esp
f011b810:	89 e0                	mov    %esp,%eax
f011b812:	89 c2                	mov    %eax,%edx
f011b814:	bb f0 43 5f f0       	mov    $0xf05f43f0,%ebx
f011b819:	b8 04 00 00 00       	mov    $0x4,%eax
f011b81e:	89 d7                	mov    %edx,%edi
f011b820:	89 de                	mov    %ebx,%esi
f011b822:	89 c1                	mov    %eax,%ecx
f011b824:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011b826:	e8 53 3e 00 00       	call   f011f67e <print_blocks_list>
f011b82b:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011b82e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b831:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b834:	29 c2                	sub    %eax,%edx
f011b836:	89 d0                	mov    %edx,%eax
f011b838:	83 ec 0c             	sub    $0xc,%esp
f011b83b:	50                   	push   %eax
f011b83c:	e8 4f d5 fe ff       	call   f0108d90 <kmalloc>
f011b841:	83 c4 10             	add    $0x10,%esp
f011b844:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011b84a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b84d:	89 c2                	mov    %eax,%edx
f011b84f:	c1 ea 1f             	shr    $0x1f,%edx
f011b852:	01 d0                	add    %edx,%eax
f011b854:	d1 f8                	sar    %eax
f011b856:	89 c2                	mov    %eax,%edx
f011b858:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b85b:	01 d0                	add    %edx,%eax
f011b85d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011b860:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011b866:	6a 01                	push   $0x1
f011b868:	ff 75 b8             	pushl  -0x48(%ebp)
f011b86b:	ff 75 ac             	pushl  -0x54(%ebp)
f011b86e:	50                   	push   %eax
f011b86f:	e8 c8 43 ff ff       	call   f010fc3c <check_block>
f011b874:	83 c4 10             	add    $0x10,%esp
f011b877:	85 c0                	test   %eax,%eax
f011b879:	75 17                	jne    f011b892 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011b87b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b882:	83 ec 0c             	sub    $0xc,%esp
f011b885:	68 5d eb 12 f0       	push   $0xf012eb5d
f011b88a:	e8 fc 56 fe ff       	call   f0100f8b <cprintf>
f011b88f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011b892:	e8 8f 21 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b897:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011b89a:	74 17                	je     f011b8b3 <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011b89c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b8a3:	83 ec 0c             	sub    $0xc,%esp
f011b8a6:	68 74 eb 12 f0       	push   $0xf012eb74
f011b8ab:	e8 db 56 fe ff       	call   f0100f8b <cprintf>
f011b8b0:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011b8b3:	e8 ae 8f fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b8b8:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011b8bb:	74 17                	je     f011b8d4 <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b8bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b8c4:	83 ec 0c             	sub    $0xc,%esp
f011b8c7:	68 94 eb 12 f0       	push   $0xf012eb94
f011b8cc:	e8 ba 56 fe ff       	call   f0100f8b <cprintf>
f011b8d1:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011b8d4:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f011b8d9:	0f b6 c0             	movzbl %al,%eax
f011b8dc:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011b8df:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011b8e6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b8e9:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011b8ec:	39 c2                	cmp    %eax,%edx
f011b8ee:	73 02                	jae    f011b8f2 <test_ksbrk+0x18d>
f011b8f0:	89 c2                	mov    %eax,%edx
f011b8f2:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f011b8f7:	0f b6 c0             	movzbl %al,%eax
f011b8fa:	c1 e0 04             	shl    $0x4,%eax
f011b8fd:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011b900:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011b907:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011b90a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b90d:	39 c8                	cmp    %ecx,%eax
f011b90f:	73 02                	jae    f011b913 <test_ksbrk+0x1ae>
f011b911:	89 c8                	mov    %ecx,%eax
f011b913:	01 d0                	add    %edx,%eax
f011b915:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011b91a:	29 c2                	sub    %eax,%edx
f011b91c:	89 d0                	mov    %edx,%eax
f011b91e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b921:	e8 00 21 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b926:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b929:	e8 38 8f fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b92e:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011b931:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b934:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b937:	29 c2                	sub    %eax,%edx
f011b939:	89 d0                	mov    %edx,%eax
f011b93b:	83 ec 0c             	sub    $0xc,%esp
f011b93e:	50                   	push   %eax
f011b93f:	e8 4c d4 fe ff       	call   f0108d90 <kmalloc>
f011b944:	83 c4 10             	add    $0x10,%esp
f011b947:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011b94d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b950:	89 c2                	mov    %eax,%edx
f011b952:	c1 ea 1f             	shr    $0x1f,%edx
f011b955:	01 d0                	add    %edx,%eax
f011b957:	d1 f8                	sar    %eax
f011b959:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011b95f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b962:	01 d0                	add    %edx,%eax
f011b964:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011b967:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011b96d:	6a 01                	push   $0x1
f011b96f:	ff 75 b8             	pushl  -0x48(%ebp)
f011b972:	ff 75 ac             	pushl  -0x54(%ebp)
f011b975:	50                   	push   %eax
f011b976:	e8 c1 42 ff ff       	call   f010fc3c <check_block>
f011b97b:	83 c4 10             	add    $0x10,%esp
f011b97e:	85 c0                	test   %eax,%eax
f011b980:	75 17                	jne    f011b999 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011b982:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b989:	83 ec 0c             	sub    $0xc,%esp
f011b98c:	68 02 ec 12 f0       	push   $0xf012ec02
f011b991:	e8 f5 55 fe ff       	call   f0100f8b <cprintf>
f011b996:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011b999:	e8 88 20 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b99e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011b9a1:	74 17                	je     f011b9ba <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011b9a3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b9aa:	83 ec 0c             	sub    $0xc,%esp
f011b9ad:	68 1c ec 12 f0       	push   $0xf012ec1c
f011b9b2:	e8 d4 55 fe ff       	call   f0100f8b <cprintf>
f011b9b7:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011b9ba:	e8 a7 8e fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b9bf:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011b9c2:	74 17                	je     f011b9db <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b9c4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b9cb:	83 ec 0c             	sub    $0xc,%esp
f011b9ce:	68 3c ec 12 f0       	push   $0xf012ec3c
f011b9d3:	e8 b3 55 fe ff       	call   f0100f8b <cprintf>
f011b9d8:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011b9db:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011b9e2:	e8 3f 20 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011b9e7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b9ea:	e8 77 8e fe ff       	call   f0104866 <pf_calculate_free_frames>
f011b9ef:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011b9f2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b9f5:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b9f8:	29 c2                	sub    %eax,%edx
f011b9fa:	89 d0                	mov    %edx,%eax
f011b9fc:	83 ec 0c             	sub    $0xc,%esp
f011b9ff:	50                   	push   %eax
f011ba00:	e8 8b d3 fe ff       	call   f0108d90 <kmalloc>
f011ba05:	83 c4 10             	add    $0x10,%esp
f011ba08:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011ba0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ba11:	89 c2                	mov    %eax,%edx
f011ba13:	c1 ea 1f             	shr    $0x1f,%edx
f011ba16:	01 d0                	add    %edx,%eax
f011ba18:	d1 f8                	sar    %eax
f011ba1a:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011ba1f:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011ba22:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011ba28:	6a 01                	push   $0x1
f011ba2a:	ff 75 b8             	pushl  -0x48(%ebp)
f011ba2d:	ff 75 ac             	pushl  -0x54(%ebp)
f011ba30:	50                   	push   %eax
f011ba31:	e8 06 42 ff ff       	call   f010fc3c <check_block>
f011ba36:	83 c4 10             	add    $0x10,%esp
f011ba39:	85 c0                	test   %eax,%eax
f011ba3b:	75 17                	jne    f011ba54 <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011ba3d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba44:	83 ec 0c             	sub    $0xc,%esp
f011ba47:	68 aa ec 12 f0       	push   $0xf012ecaa
f011ba4c:	e8 3a 55 fe ff       	call   f0100f8b <cprintf>
f011ba51:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011ba54:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ba57:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011ba5a:	b8 00 10 00 00       	mov    $0x1000,%eax
f011ba5f:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011ba62:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011ba65:	6a 00                	push   $0x0
f011ba67:	ff 75 98             	pushl  -0x68(%ebp)
f011ba6a:	ff 75 ac             	pushl  -0x54(%ebp)
f011ba6d:	ff 75 ac             	pushl  -0x54(%ebp)
f011ba70:	e8 c7 41 ff ff       	call   f010fc3c <check_block>
f011ba75:	83 c4 10             	add    $0x10,%esp
f011ba78:	85 c0                	test   %eax,%eax
f011ba7a:	75 17                	jne    f011ba93 <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011ba7c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba83:	83 ec 0c             	sub    $0xc,%esp
f011ba86:	68 c1 ec 12 f0       	push   $0xf012ecc1
f011ba8b:	e8 fb 54 fe ff       	call   f0100f8b <cprintf>
f011ba90:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011ba93:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011ba9a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ba9d:	8b 00                	mov    (%eax),%eax
f011ba9f:	83 f8 01             	cmp    $0x1,%eax
f011baa2:	74 17                	je     f011babb <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011baa4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011baab:	83 ec 0c             	sub    $0xc,%esp
f011baae:	68 d8 ec 12 f0       	push   $0xf012ecd8
f011bab3:	e8 d3 54 fe ff       	call   f0100f8b <cprintf>
f011bab8:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011babb:	83 ec 0c             	sub    $0xc,%esp
f011babe:	6a 00                	push   $0x0
f011bac0:	e8 dc d1 fe ff       	call   f0108ca1 <sbrk>
f011bac5:	83 c4 10             	add    $0x10,%esp
f011bac8:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011bacb:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011bad2:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bad5:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011bad8:	74 1d                	je     f011baf7 <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011bada:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bae1:	83 ec 04             	sub    $0x4,%esp
f011bae4:	ff 75 90             	pushl  -0x70(%ebp)
f011bae7:	ff 75 8c             	pushl  -0x74(%ebp)
f011baea:	68 04 ed 12 f0       	push   $0xf012ed04
f011baef:	e8 97 54 fe ff       	call   f0100f8b <cprintf>
f011baf4:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011baf7:	e8 2a 1f ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bafc:	89 c2                	mov    %eax,%edx
f011bafe:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011bb01:	29 d0                	sub    %edx,%eax
f011bb03:	83 f8 01             	cmp    $0x1,%eax
f011bb06:	74 17                	je     f011bb1f <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011bb08:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb0f:	83 ec 0c             	sub    $0xc,%esp
f011bb12:	68 38 ed 12 f0       	push   $0xf012ed38
f011bb17:	e8 6f 54 fe ff       	call   f0100f8b <cprintf>
f011bb1c:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bb1f:	e8 42 8d fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bb24:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bb27:	74 17                	je     f011bb40 <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb29:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb30:	83 ec 0c             	sub    $0xc,%esp
f011bb33:	68 58 ed 12 f0       	push   $0xf012ed58
f011bb38:	e8 4e 54 fe ff       	call   f0100f8b <cprintf>
f011bb3d:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011bb40:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011bb47:	e8 da 1e ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bb4c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bb4f:	e8 12 8d fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bb54:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011bb57:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bb5a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011bb5d:	29 c2                	sub    %eax,%edx
f011bb5f:	89 d0                	mov    %edx,%eax
f011bb61:	83 ec 0c             	sub    $0xc,%esp
f011bb64:	50                   	push   %eax
f011bb65:	e8 26 d2 fe ff       	call   f0108d90 <kmalloc>
f011bb6a:	83 c4 10             	add    $0x10,%esp
f011bb6d:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011bb73:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011bb7a:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011bb80:	6a 01                	push   $0x1
f011bb82:	ff 75 b8             	pushl  -0x48(%ebp)
f011bb85:	ff 75 ac             	pushl  -0x54(%ebp)
f011bb88:	50                   	push   %eax
f011bb89:	e8 ae 40 ff ff       	call   f010fc3c <check_block>
f011bb8e:	83 c4 10             	add    $0x10,%esp
f011bb91:	85 c0                	test   %eax,%eax
f011bb93:	75 17                	jne    f011bbac <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011bb95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb9c:	83 ec 0c             	sub    $0xc,%esp
f011bb9f:	68 c7 ed 12 f0       	push   $0xf012edc7
f011bba4:	e8 e2 53 fe ff       	call   f0100f8b <cprintf>
f011bba9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011bbac:	e8 75 1e ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bbb1:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011bbb4:	74 17                	je     f011bbcd <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011bbb6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bbbd:	83 ec 0c             	sub    $0xc,%esp
f011bbc0:	68 e0 ed 12 f0       	push   $0xf012ede0
f011bbc5:	e8 c1 53 fe ff       	call   f0100f8b <cprintf>
f011bbca:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bbcd:	e8 94 8c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bbd2:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bbd5:	74 17                	je     f011bbee <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bbd7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bbde:	83 ec 0c             	sub    $0xc,%esp
f011bbe1:	68 00 ee 12 f0       	push   $0xf012ee00
f011bbe6:	e8 a0 53 fe ff       	call   f0100f8b <cprintf>
f011bbeb:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011bbee:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bbf2:	74 04                	je     f011bbf8 <test_ksbrk+0x493>
		eval += 25;
f011bbf4:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011bbf8:	83 ec 0c             	sub    $0xc,%esp
f011bbfb:	68 70 ee 12 f0       	push   $0xf012ee70
f011bc00:	e8 86 53 fe ff       	call   f0100f8b <cprintf>
f011bc05:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011bc08:	83 ec 0c             	sub    $0xc,%esp
f011bc0b:	6a 00                	push   $0x0
f011bc0d:	e8 8f d0 fe ff       	call   f0108ca1 <sbrk>
f011bc12:	83 c4 10             	add    $0x10,%esp
f011bc15:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011bc18:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011bc1f:	e8 02 1e ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bc24:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bc27:	e8 3a 8c fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bc2c:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011bc2f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bc32:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011bc35:	29 c2                	sub    %eax,%edx
f011bc37:	89 d0                	mov    %edx,%eax
f011bc39:	83 ec 0c             	sub    $0xc,%esp
f011bc3c:	50                   	push   %eax
f011bc3d:	e8 4e d1 fe ff       	call   f0108d90 <kmalloc>
f011bc42:	83 c4 10             	add    $0x10,%esp
f011bc45:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011bc4b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bc4e:	89 c2                	mov    %eax,%edx
f011bc50:	c1 ea 1f             	shr    $0x1f,%edx
f011bc53:	01 d0                	add    %edx,%eax
f011bc55:	d1 f8                	sar    %eax
f011bc57:	89 c2                	mov    %eax,%edx
f011bc59:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bc5c:	01 d0                	add    %edx,%eax
f011bc5e:	83 e8 04             	sub    $0x4,%eax
f011bc61:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011bc64:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011bc6a:	6a 01                	push   $0x1
f011bc6c:	ff 75 b8             	pushl  -0x48(%ebp)
f011bc6f:	ff 75 ac             	pushl  -0x54(%ebp)
f011bc72:	50                   	push   %eax
f011bc73:	e8 c4 3f ff ff       	call   f010fc3c <check_block>
f011bc78:	83 c4 10             	add    $0x10,%esp
f011bc7b:	85 c0                	test   %eax,%eax
f011bc7d:	75 17                	jne    f011bc96 <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011bc7f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc86:	83 ec 0c             	sub    $0xc,%esp
f011bc89:	68 d3 ee 12 f0       	push   $0xf012eed3
f011bc8e:	e8 f8 52 fe ff       	call   f0100f8b <cprintf>
f011bc93:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011bc96:	e8 8b 1d ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bc9b:	89 c2                	mov    %eax,%edx
f011bc9d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011bca0:	29 d0                	sub    %edx,%eax
f011bca2:	83 f8 01             	cmp    $0x1,%eax
f011bca5:	74 17                	je     f011bcbe <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011bca7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bcae:	83 ec 0c             	sub    $0xc,%esp
f011bcb1:	68 ec ee 12 f0       	push   $0xf012eeec
f011bcb6:	e8 d0 52 fe ff       	call   f0100f8b <cprintf>
f011bcbb:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bcbe:	e8 a3 8b fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bcc3:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bcc6:	74 17                	je     f011bcdf <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bcc8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bccf:	83 ec 0c             	sub    $0xc,%esp
f011bcd2:	68 0c ef 12 f0       	push   $0xf012ef0c
f011bcd7:	e8 af 52 fe ff       	call   f0100f8b <cprintf>
f011bcdc:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011bcdf:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011bce6:	e8 3b 1d ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bceb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bcee:	e8 73 8b fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bcf3:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011bcf6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bcf9:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011bcfc:	29 c2                	sub    %eax,%edx
f011bcfe:	89 d0                	mov    %edx,%eax
f011bd00:	83 ec 0c             	sub    $0xc,%esp
f011bd03:	50                   	push   %eax
f011bd04:	e8 87 d0 fe ff       	call   f0108d90 <kmalloc>
f011bd09:	83 c4 10             	add    $0x10,%esp
f011bd0c:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011bd12:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011bd19:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011bd1f:	6a 01                	push   $0x1
f011bd21:	ff 75 b8             	pushl  -0x48(%ebp)
f011bd24:	ff 75 ac             	pushl  -0x54(%ebp)
f011bd27:	50                   	push   %eax
f011bd28:	e8 0f 3f ff ff       	call   f010fc3c <check_block>
f011bd2d:	83 c4 10             	add    $0x10,%esp
f011bd30:	85 c0                	test   %eax,%eax
f011bd32:	75 17                	jne    f011bd4b <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011bd34:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd3b:	83 ec 0c             	sub    $0xc,%esp
f011bd3e:	68 7a ef 12 f0       	push   $0xf012ef7a
f011bd43:	e8 43 52 fe ff       	call   f0100f8b <cprintf>
f011bd48:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011bd4b:	e8 d6 1c ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bd50:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011bd53:	74 17                	je     f011bd6c <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011bd55:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd5c:	83 ec 0c             	sub    $0xc,%esp
f011bd5f:	68 94 ef 12 f0       	push   $0xf012ef94
f011bd64:	e8 22 52 fe ff       	call   f0100f8b <cprintf>
f011bd69:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bd6c:	e8 f5 8a fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bd71:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bd74:	74 17                	je     f011bd8d <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd76:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd7d:	83 ec 0c             	sub    $0xc,%esp
f011bd80:	68 b4 ef 12 f0       	push   $0xf012efb4
f011bd85:	e8 01 52 fe ff       	call   f0100f8b <cprintf>
f011bd8a:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011bd8d:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011bd94:	e8 8d 1c ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bd99:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bd9c:	e8 c5 8a fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bda1:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011bda4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bda7:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011bdaa:	29 c2                	sub    %eax,%edx
f011bdac:	89 d0                	mov    %edx,%eax
f011bdae:	83 ec 0c             	sub    $0xc,%esp
f011bdb1:	50                   	push   %eax
f011bdb2:	e8 d9 cf fe ff       	call   f0108d90 <kmalloc>
f011bdb7:	83 c4 10             	add    $0x10,%esp
f011bdba:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011bdc0:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011bdc7:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011bdcd:	6a 01                	push   $0x1
f011bdcf:	ff 75 b8             	pushl  -0x48(%ebp)
f011bdd2:	ff 75 ac             	pushl  -0x54(%ebp)
f011bdd5:	50                   	push   %eax
f011bdd6:	e8 61 3e ff ff       	call   f010fc3c <check_block>
f011bddb:	83 c4 10             	add    $0x10,%esp
f011bdde:	85 c0                	test   %eax,%eax
f011bde0:	75 17                	jne    f011bdf9 <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011bde2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bde9:	83 ec 0c             	sub    $0xc,%esp
f011bdec:	68 22 f0 12 f0       	push   $0xf012f022
f011bdf1:	e8 95 51 fe ff       	call   f0100f8b <cprintf>
f011bdf6:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011bdf9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011bdfc:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011bdff:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011be06:	6a 00                	push   $0x0
f011be08:	ff 75 98             	pushl  -0x68(%ebp)
f011be0b:	ff 75 ac             	pushl  -0x54(%ebp)
f011be0e:	ff 75 ac             	pushl  -0x54(%ebp)
f011be11:	e8 26 3e ff ff       	call   f010fc3c <check_block>
f011be16:	83 c4 10             	add    $0x10,%esp
f011be19:	85 c0                	test   %eax,%eax
f011be1b:	75 17                	jne    f011be34 <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011be1d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be24:	83 ec 0c             	sub    $0xc,%esp
f011be27:	68 39 f0 12 f0       	push   $0xf012f039
f011be2c:	e8 5a 51 fe ff       	call   f0100f8b <cprintf>
f011be31:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011be34:	8b 45 88             	mov    -0x78(%ebp),%eax
f011be37:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011be3c:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011be3f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011be42:	8b 00                	mov    (%eax),%eax
f011be44:	83 f8 01             	cmp    $0x1,%eax
f011be47:	74 17                	je     f011be60 <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011be49:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be50:	83 ec 0c             	sub    $0xc,%esp
f011be53:	68 50 f0 12 f0       	push   $0xf012f050
f011be58:	e8 2e 51 fe ff       	call   f0100f8b <cprintf>
f011be5d:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011be60:	83 ec 0c             	sub    $0xc,%esp
f011be63:	6a 00                	push   $0x0
f011be65:	e8 37 ce fe ff       	call   f0108ca1 <sbrk>
f011be6a:	83 c4 10             	add    $0x10,%esp
f011be6d:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011be70:	8b 45 88             	mov    -0x78(%ebp),%eax
f011be73:	05 00 20 00 00       	add    $0x2000,%eax
f011be78:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011be7b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011be7e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011be81:	74 1d                	je     f011bea0 <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011be83:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be8a:	83 ec 04             	sub    $0x4,%esp
f011be8d:	ff 75 90             	pushl  -0x70(%ebp)
f011be90:	ff 75 8c             	pushl  -0x74(%ebp)
f011be93:	68 7c f0 12 f0       	push   $0xf012f07c
f011be98:	e8 ee 50 fe ff       	call   f0100f8b <cprintf>
f011be9d:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011bea0:	e8 81 1b ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bea5:	89 c2                	mov    %eax,%edx
f011bea7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011beaa:	29 d0                	sub    %edx,%eax
f011beac:	83 f8 01             	cmp    $0x1,%eax
f011beaf:	74 17                	je     f011bec8 <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011beb1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011beb8:	83 ec 0c             	sub    $0xc,%esp
f011bebb:	68 b0 f0 12 f0       	push   $0xf012f0b0
f011bec0:	e8 c6 50 fe ff       	call   f0100f8b <cprintf>
f011bec5:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bec8:	e8 99 89 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011becd:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bed0:	74 17                	je     f011bee9 <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bed2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bed9:	83 ec 0c             	sub    $0xc,%esp
f011bedc:	68 d0 f0 12 f0       	push   $0xf012f0d0
f011bee1:	e8 a5 50 fe ff       	call   f0100f8b <cprintf>
f011bee6:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011bee9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011beed:	74 04                	je     f011bef3 <test_ksbrk+0x78e>
		eval += 25;
f011beef:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011bef3:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011befa:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011bf00:	bb 0c f4 12 f0       	mov    $0xf012f40c,%ebx
f011bf05:	ba 05 00 00 00       	mov    $0x5,%edx
f011bf0a:	89 c7                	mov    %eax,%edi
f011bf0c:	89 de                	mov    %ebx,%esi
f011bf0e:	89 d1                	mov    %edx,%ecx
f011bf10:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011bf12:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011bf18:	bb 20 f4 12 f0       	mov    $0xf012f420,%ebx
f011bf1d:	ba 05 00 00 00       	mov    $0x5,%edx
f011bf22:	89 c7                	mov    %eax,%edi
f011bf24:	89 de                	mov    %ebx,%esi
f011bf26:	89 d1                	mov    %edx,%ecx
f011bf28:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011bf2a:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011bf30:	bb 34 f4 12 f0       	mov    $0xf012f434,%ebx
f011bf35:	ba 05 00 00 00       	mov    $0x5,%edx
f011bf3a:	89 c7                	mov    %eax,%edi
f011bf3c:	89 de                	mov    %ebx,%esi
f011bf3e:	89 d1                	mov    %edx,%ecx
f011bf40:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011bf42:	83 ec 04             	sub    $0x4,%esp
f011bf45:	68 00 00 00 f8       	push   $0xf8000000
f011bf4a:	68 00 10 00 00       	push   $0x1000
f011bf4f:	68 00 00 00 f6       	push   $0xf6000000
f011bf54:	e8 6e cc fe ff       	call   f0108bc7 <initialize_kheap_dynamic_allocator>
f011bf59:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011bf5c:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011bf63:	eb 1b                	jmp    f011bf80 <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011bf65:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011bf6a:	83 ec 08             	sub    $0x8,%esp
f011bf6d:	ff 75 dc             	pushl  -0x24(%ebp)
f011bf70:	50                   	push   %eax
f011bf71:	e8 fe c7 fe ff       	call   f0108774 <unmap_frame>
f011bf76:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011bf79:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011bf80:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011bf87:	76 dc                	jbe    f011bf65 <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011bf89:	83 ec 0c             	sub    $0xc,%esp
f011bf8c:	68 40 f1 12 f0       	push   $0xf012f140
f011bf91:	e8 f5 4f fe ff       	call   f0100f8b <cprintf>
f011bf96:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011bf99:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011bfa0:	e9 21 01 00 00       	jmp    f011c0c6 <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011bfa5:	e8 7c 1a ff ff       	call   f010da26 <sys_calculate_free_frames>
f011bfaa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011bfad:	e8 b4 88 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bfb2:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011bfb5:	83 ec 0c             	sub    $0xc,%esp
f011bfb8:	6a 00                	push   $0x0
f011bfba:	e8 e2 cc fe ff       	call   f0108ca1 <sbrk>
f011bfbf:	83 c4 10             	add    $0x10,%esp
f011bfc2:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011bfc5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bfc8:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011bfcf:	83 ec 0c             	sub    $0xc,%esp
f011bfd2:	50                   	push   %eax
f011bfd3:	e8 c9 cc fe ff       	call   f0108ca1 <sbrk>
f011bfd8:	83 c4 10             	add    $0x10,%esp
f011bfdb:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011bfde:	83 ec 0c             	sub    $0xc,%esp
f011bfe1:	6a 00                	push   $0x0
f011bfe3:	e8 b9 cc fe ff       	call   f0108ca1 <sbrk>
f011bfe8:	83 c4 10             	add    $0x10,%esp
f011bfeb:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011bfee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bff5:	e8 6c 88 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011bffa:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bffd:	74 1a                	je     f011c019 <test_ksbrk+0x8b4>
			{
				correct = 0;
f011bfff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011c006:	83 ec 08             	sub    $0x8,%esp
f011c009:	ff 75 d8             	pushl  -0x28(%ebp)
f011c00c:	68 84 f1 12 f0       	push   $0xf012f184
f011c011:	e8 75 4f fe ff       	call   f0100f8b <cprintf>
f011c016:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011c019:	e8 08 1a ff ff       	call   f010da26 <sys_calculate_free_frames>
f011c01e:	89 c2                	mov    %eax,%edx
f011c020:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c023:	29 d0                	sub    %edx,%eax
f011c025:	89 c2                	mov    %eax,%edx
f011c027:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c02a:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011c031:	39 c2                	cmp    %eax,%edx
f011c033:	74 1a                	je     f011c04f <test_ksbrk+0x8ea>
			{
				correct = 0;
f011c035:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011c03c:	83 ec 08             	sub    $0x8,%esp
f011c03f:	ff 75 d8             	pushl  -0x28(%ebp)
f011c042:	68 f4 f1 12 f0       	push   $0xf012f1f4
f011c047:	e8 3f 4f fe ff       	call   f0100f8b <cprintf>
f011c04c:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011c04f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c052:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011c059:	8b 45 80             	mov    -0x80(%ebp),%eax
f011c05c:	39 c2                	cmp    %eax,%edx
f011c05e:	74 25                	je     f011c085 <test_ksbrk+0x920>
			{
				correct = 0;
f011c060:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011c067:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c06a:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011c071:	ff 75 80             	pushl  -0x80(%ebp)
f011c074:	50                   	push   %eax
f011c075:	ff 75 d8             	pushl  -0x28(%ebp)
f011c078:	68 14 f2 12 f0       	push   $0xf012f214
f011c07d:	e8 09 4f fe ff       	call   f0100f8b <cprintf>
f011c082:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011c085:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c088:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011c08f:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011c092:	74 25                	je     f011c0b9 <test_ksbrk+0x954>
			{
				correct = 0;
f011c094:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011c09b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c09e:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011c0a5:	ff 75 90             	pushl  -0x70(%ebp)
f011c0a8:	50                   	push   %eax
f011c0a9:	ff 75 d8             	pushl  -0x28(%ebp)
f011c0ac:	68 4c f2 12 f0       	push   $0xf012f24c
f011c0b1:	e8 d5 4e fe ff       	call   f0100f8b <cprintf>
f011c0b6:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011c0b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c0bd:	74 04                	je     f011c0c3 <test_ksbrk+0x95e>
				eval += 10;
f011c0bf:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011c0c3:	ff 45 d8             	incl   -0x28(%ebp)
f011c0c6:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011c0c9:	8d 50 ff             	lea    -0x1(%eax),%edx
f011c0cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c0cf:	39 c2                	cmp    %eax,%edx
f011c0d1:	0f 87 ce fe ff ff    	ja     f011bfa5 <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011c0d7:	83 ec 0c             	sub    $0xc,%esp
f011c0da:	68 80 f2 12 f0       	push   $0xf012f280
f011c0df:	e8 a7 4e fe ff       	call   f0100f8b <cprintf>
f011c0e4:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011c0e7:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011c0ea:	48                   	dec    %eax
f011c0eb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c0ee:	e9 18 01 00 00       	jmp    f011c20b <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011c0f3:	e8 2e 19 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011c0f8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011c0fb:	e8 66 87 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011c100:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011c103:	83 ec 0c             	sub    $0xc,%esp
f011c106:	6a 00                	push   $0x0
f011c108:	e8 94 cb fe ff       	call   f0108ca1 <sbrk>
f011c10d:	83 c4 10             	add    $0x10,%esp
f011c110:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011c113:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c116:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011c11d:	83 ec 0c             	sub    $0xc,%esp
f011c120:	50                   	push   %eax
f011c121:	e8 7b cb fe ff       	call   f0108ca1 <sbrk>
f011c126:	83 c4 10             	add    $0x10,%esp
f011c129:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011c12f:	83 ec 0c             	sub    $0xc,%esp
f011c132:	6a 00                	push   $0x0
f011c134:	e8 68 cb fe ff       	call   f0108ca1 <sbrk>
f011c139:	83 c4 10             	add    $0x10,%esp
f011c13c:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011c13f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c146:	e8 1b 87 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011c14b:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c14e:	74 1a                	je     f011c16a <test_ksbrk+0xa05>
			{
				correct = 0;
f011c150:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011c157:	83 ec 08             	sub    $0x8,%esp
f011c15a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c15d:	68 d0 f2 12 f0       	push   $0xf012f2d0
f011c162:	e8 24 4e fe ff       	call   f0100f8b <cprintf>
f011c167:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c16a:	e8 b7 18 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011c16f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c172:	74 1a                	je     f011c18e <test_ksbrk+0xa29>
			{
				correct = 0;
f011c174:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011c17b:	83 ec 08             	sub    $0x8,%esp
f011c17e:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c181:	68 40 f3 12 f0       	push   $0xf012f340
f011c186:	e8 00 4e fe ff       	call   f0100f8b <cprintf>
f011c18b:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011c18e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c191:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011c198:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c19e:	39 c2                	cmp    %eax,%edx
f011c1a0:	74 28                	je     f011c1ca <test_ksbrk+0xa65>
			{
				correct = 0;
f011c1a2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011c1a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c1ac:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011c1b3:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011c1b9:	50                   	push   %eax
f011c1ba:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c1bd:	68 60 f3 12 f0       	push   $0xf012f360
f011c1c2:	e8 c4 4d fe ff       	call   f0100f8b <cprintf>
f011c1c7:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011c1ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c1cd:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011c1d4:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011c1d7:	74 25                	je     f011c1fe <test_ksbrk+0xa99>
			{
				correct = 0;
f011c1d9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011c1e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c1e3:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011c1ea:	ff 75 90             	pushl  -0x70(%ebp)
f011c1ed:	50                   	push   %eax
f011c1ee:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c1f1:	68 98 f3 12 f0       	push   $0xf012f398
f011c1f6:	e8 90 4d fe ff       	call   f0100f8b <cprintf>
f011c1fb:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011c1fe:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c202:	74 04                	je     f011c208 <test_ksbrk+0xaa3>
				eval += 10;
f011c204:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011c208:	ff 45 d4             	incl   -0x2c(%ebp)
f011c20b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c20e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c211:	0f 82 dc fe ff ff    	jb     f011c0f3 <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011c217:	83 ec 08             	sub    $0x8,%esp
f011c21a:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c21d:	68 cc f3 12 f0       	push   $0xf012f3cc
f011c222:	e8 64 4d fe ff       	call   f0100f8b <cprintf>
f011c227:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011c22a:	83 ec 0c             	sub    $0xc,%esp
f011c22d:	68 f6 f3 12 f0       	push   $0xf012f3f6
f011c232:	e8 54 4d fe ff       	call   f0100f8b <cprintf>
f011c237:	83 c4 10             	add    $0x10,%esp
	return 0;
f011c23a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011c23f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c242:	5b                   	pop    %ebx
f011c243:	5e                   	pop    %esi
f011c244:	5f                   	pop    %edi
f011c245:	5d                   	pop    %ebp
f011c246:	c3                   	ret    

f011c247 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011c247:	55                   	push   %ebp
f011c248:	89 e5                	mov    %esp,%ebp
f011c24a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c24d:	83 ec 04             	sub    $0x4,%esp
f011c250:	68 48 f4 12 f0       	push   $0xf012f448
f011c255:	68 c3 08 00 00       	push   $0x8c3
f011c25a:	68 87 be 12 f0       	push   $0xf012be87
f011c25f:	e8 d5 40 fe ff       	call   f0100339 <_panic>

f011c264 <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011c264:	55                   	push   %ebp
f011c265:	89 e5                	mov    %esp,%ebp
f011c267:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c26a:	83 ec 04             	sub    $0x4,%esp
f011c26d:	68 48 f4 12 f0       	push   $0xf012f448
f011c272:	68 c8 08 00 00       	push   $0x8c8
f011c277:	68 87 be 12 f0       	push   $0xf012be87
f011c27c:	e8 b8 40 fe ff       	call   f0100339 <_panic>

f011c281 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011c281:	55                   	push   %ebp
f011c282:	89 e5                	mov    %esp,%ebp
f011c284:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c287:	83 ec 04             	sub    $0x4,%esp
f011c28a:	68 48 f4 12 f0       	push   $0xf012f448
f011c28f:	68 cd 08 00 00       	push   $0x8cd
f011c294:	68 87 be 12 f0       	push   $0xf012be87
f011c299:	e8 9b 40 fe ff       	call   f0100339 <_panic>

f011c29e <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011c29e:	55                   	push   %ebp
f011c29f:	89 e5                	mov    %esp,%ebp
f011c2a1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c2a4:	83 ec 04             	sub    $0x4,%esp
f011c2a7:	68 48 f4 12 f0       	push   $0xf012f448
f011c2ac:	68 d2 08 00 00       	push   $0x8d2
f011c2b1:	68 87 be 12 f0       	push   $0xf012be87
f011c2b6:	e8 7e 40 fe ff       	call   f0100339 <_panic>

f011c2bb <test_kfree>:
}

int test_kfree()
{
f011c2bb:	55                   	push   %ebp
f011c2bc:	89 e5                	mov    %esp,%ebp
f011c2be:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c2c1:	83 ec 04             	sub    $0x4,%esp
f011c2c4:	68 48 f4 12 f0       	push   $0xf012f448
f011c2c9:	68 d7 08 00 00       	push   $0x8d7
f011c2ce:	68 87 be 12 f0       	push   $0xf012be87
f011c2d3:	e8 61 40 fe ff       	call   f0100339 <_panic>

f011c2d8 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011c2d8:	55                   	push   %ebp
f011c2d9:	89 e5                	mov    %esp,%ebp
f011c2db:	57                   	push   %edi
f011c2dc:	56                   	push   %esi
f011c2dd:	53                   	push   %ebx
f011c2de:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011c2e4:	a0 dc cd 17 f0       	mov    0xf017cddc,%al
f011c2e9:	84 c0                	test   %al,%al
f011c2eb:	74 56                	je     f011c343 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011c2ed:	c6 05 dc cd 17 f0 00 	movb   $0x0,0xf017cddc
		initFreeFrames = sys_calculate_free_frames() ;
f011c2f4:	e8 2d 17 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011c2f9:	a3 88 71 61 f0       	mov    %eax,0xf0617188
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011c2fe:	e8 63 85 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011c303:	a3 84 71 61 f0       	mov    %eax,0xf0617184
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011c308:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011c30e:	bb ad f5 12 f0       	mov    $0xf012f5ad,%ebx
f011c313:	ba 11 00 00 00       	mov    $0x11,%edx
f011c318:	89 c7                	mov    %eax,%edi
f011c31a:	89 de                	mov    %ebx,%esi
f011c31c:	89 d1                	mov    %edx,%ecx
f011c31e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011c320:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011c326:	b9 53 00 00 00       	mov    $0x53,%ecx
f011c32b:	b0 00                	mov    $0x0,%al
f011c32d:	89 d7                	mov    %edx,%edi
f011c32f:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011c331:	83 ec 0c             	sub    $0xc,%esp
f011c334:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011c33a:	50                   	push   %eax
f011c33b:	e8 bb 5b fe ff       	call   f0101efb <execute_command>
f011c340:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011c343:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011c34a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011c351:	a1 40 43 5f f0       	mov    0xf05f4340,%eax
f011c356:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011c359:	eb 2b                	jmp    f011c386 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011c35b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c35e:	83 c0 20             	add    $0x20,%eax
f011c361:	83 ec 08             	sub    $0x8,%esp
f011c364:	68 58 f4 12 f0       	push   $0xf012f458
f011c369:	50                   	push   %eax
f011c36a:	e8 ea 28 00 00       	call   f011ec59 <strcmp>
f011c36f:	83 c4 10             	add    $0x10,%esp
f011c372:	85 c0                	test   %eax,%eax
f011c374:	75 08                	jne    f011c37e <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011c376:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c379:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011c37c:	eb 2f                	jmp    f011c3ad <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011c37e:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f011c383:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011c386:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c38a:	74 08                	je     f011c394 <test_three_creation_functions+0xbc>
f011c38c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c38f:	8b 40 08             	mov    0x8(%eax),%eax
f011c392:	eb 05                	jmp    f011c399 <test_three_creation_functions+0xc1>
f011c394:	b8 00 00 00 00       	mov    $0x0,%eax
f011c399:	a3 48 43 5f f0       	mov    %eax,0xf05f4348
f011c39e:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f011c3a3:	85 c0                	test   %eax,%eax
f011c3a5:	75 b4                	jne    f011c35b <test_three_creation_functions+0x83>
f011c3a7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c3ab:	75 ae                	jne    f011c35b <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011c3ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c3b0:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f011c3b6:	85 c0                	test   %eax,%eax
f011c3b8:	74 17                	je     f011c3d1 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011c3ba:	83 ec 04             	sub    $0x4,%esp
f011c3bd:	68 60 f4 12 f0       	push   $0xf012f460
f011c3c2:	68 f8 08 00 00       	push   $0x8f8
f011c3c7:	68 87 be 12 f0       	push   $0xf012be87
f011c3cc:	e8 68 3f fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011c3d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c3d4:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011c3da:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011c3dd:	e8 44 16 ff ff       	call   f010da26 <sys_calculate_free_frames>
f011c3e2:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011c3e5:	e8 7c 84 fe ff       	call   f0104866 <pf_calculate_free_frames>
f011c3ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011c3ed:	a1 84 71 61 f0       	mov    0xf0617184,%eax
f011c3f2:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011c3f5:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011c3f8:	74 17                	je     f011c411 <test_three_creation_functions+0x139>
f011c3fa:	83 ec 04             	sub    $0x4,%esp
f011c3fd:	68 a0 be 12 f0       	push   $0xf012bea0
f011c402:	68 02 09 00 00       	push   $0x902
f011c407:	68 87 be 12 f0       	push   $0xf012be87
f011c40c:	e8 28 3f fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011c411:	a1 88 71 61 f0       	mov    0xf0617188,%eax
f011c416:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011c419:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c41c:	83 c2 15             	add    $0x15,%edx
f011c41f:	39 d0                	cmp    %edx,%eax
f011c421:	74 17                	je     f011c43a <test_three_creation_functions+0x162>
f011c423:	83 ec 04             	sub    $0x4,%esp
f011c426:	68 b0 f4 12 f0       	push   $0xf012f4b0
f011c42b:	68 04 09 00 00       	push   $0x904
f011c430:	68 87 be 12 f0       	push   $0xf012be87
f011c435:	e8 ff 3e fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011c43a:	83 ec 0c             	sub    $0xc,%esp
f011c43d:	68 00 10 00 00       	push   $0x1000
f011c442:	e8 49 c9 fe ff       	call   f0108d90 <kmalloc>
f011c447:	83 c4 10             	add    $0x10,%esp
f011c44a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011c44d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c450:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011c455:	74 17                	je     f011c46e <test_three_creation_functions+0x196>
f011c457:	83 ec 04             	sub    $0x4,%esp
f011c45a:	68 f0 f4 12 f0       	push   $0xf012f4f0
f011c45f:	68 08 09 00 00       	push   $0x908
f011c464:	68 87 be 12 f0       	push   $0xf012be87
f011c469:	e8 cb 3e fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011c46e:	83 ec 0c             	sub    $0xc,%esp
f011c471:	68 60 f5 12 f0       	push   $0xf012f560
f011c476:	e8 10 4b fe ff       	call   f0100f8b <cprintf>
f011c47b:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c47e:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011c483:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c486:	5b                   	pop    %ebx
f011c487:	5e                   	pop    %esi
f011c488:	5f                   	pop    %edi
f011c489:	5d                   	pop    %ebp
f011c48a:	c3                   	ret    

f011c48b <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011c48b:	55                   	push   %ebp
f011c48c:	89 e5                	mov    %esp,%ebp
f011c48e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c491:	83 ec 04             	sub    $0x4,%esp
f011c494:	68 48 f4 12 f0       	push   $0xf012f448
f011c499:	68 16 09 00 00       	push   $0x916
f011c49e:	68 87 be 12 f0       	push   $0xf012be87
f011c4a3:	e8 91 3e fe ff       	call   f0100339 <_panic>

f011c4a8 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011c4a8:	55                   	push   %ebp
f011c4a9:	89 e5                	mov    %esp,%ebp
f011c4ab:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c4ae:	83 ec 04             	sub    $0x4,%esp
f011c4b1:	68 48 f4 12 f0       	push   $0xf012f448
f011c4b6:	68 1e 09 00 00       	push   $0x91e
f011c4bb:	68 87 be 12 f0       	push   $0xf012be87
f011c4c0:	e8 74 3e fe ff       	call   f0100339 <_panic>

f011c4c5 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011c4c5:	55                   	push   %ebp
f011c4c6:	89 e5                	mov    %esp,%ebp
f011c4c8:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c4cb:	83 ec 04             	sub    $0x4,%esp
f011c4ce:	68 48 f4 12 f0       	push   $0xf012f448
f011c4d3:	68 25 09 00 00       	push   $0x925
f011c4d8:	68 87 be 12 f0       	push   $0xf012be87
f011c4dd:	e8 57 3e fe ff       	call   f0100339 <_panic>

f011c4e2 <test_kfreelast>:

}


int test_kfreelast()
{
f011c4e2:	55                   	push   %ebp
f011c4e3:	89 e5                	mov    %esp,%ebp
f011c4e5:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c4e8:	83 ec 04             	sub    $0x4,%esp
f011c4eb:	68 48 f4 12 f0       	push   $0xf012f448
f011c4f0:	68 2c 09 00 00       	push   $0x92c
f011c4f5:	68 87 be 12 f0       	push   $0xf012be87
f011c4fa:	e8 3a 3e fe ff       	call   f0100339 <_panic>

f011c4ff <test_krealloc>:

}

int test_krealloc() {
f011c4ff:	55                   	push   %ebp
f011c500:	89 e5                	mov    %esp,%ebp
f011c502:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c505:	83 ec 04             	sub    $0x4,%esp
f011c508:	68 48 f4 12 f0       	push   $0xf012f448
f011c50d:	68 31 09 00 00       	push   $0x931
f011c512:	68 87 be 12 f0       	push   $0xf012be87
f011c517:	e8 1d 3e fe ff       	call   f0100339 <_panic>

f011c51c <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011c51c:	55                   	push   %ebp
f011c51d:	89 e5                	mov    %esp,%ebp
f011c51f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c522:	83 ec 04             	sub    $0x4,%esp
f011c525:	68 48 f4 12 f0       	push   $0xf012f448
f011c52a:	68 36 09 00 00       	push   $0x936
f011c52f:	68 87 be 12 f0       	push   $0xf012be87
f011c534:	e8 00 3e fe ff       	call   f0100339 <_panic>

f011c539 <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011c539:	55                   	push   %ebp
f011c53a:	89 e5                	mov    %esp,%ebp
f011c53c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c53f:	83 ec 04             	sub    $0x4,%esp
f011c542:	68 48 f4 12 f0       	push   $0xf012f448
f011c547:	68 3c 09 00 00       	push   $0x93c
f011c54c:	68 87 be 12 f0       	push   $0xf012be87
f011c551:	e8 e3 3d fe ff       	call   f0100339 <_panic>

f011c556 <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011c556:	55                   	push   %ebp
f011c557:	89 e5                	mov    %esp,%ebp
f011c559:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c55c:	83 ec 04             	sub    $0x4,%esp
f011c55f:	68 48 f4 12 f0       	push   $0xf012f448
f011c564:	68 41 09 00 00       	push   $0x941
f011c569:	68 87 be 12 f0       	push   $0xf012be87
f011c56e:	e8 c6 3d fe ff       	call   f0100339 <_panic>

f011c573 <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011c573:	55                   	push   %ebp
f011c574:	89 e5                	mov    %esp,%ebp
f011c576:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c579:	83 ec 04             	sub    $0x4,%esp
f011c57c:	68 48 f4 12 f0       	push   $0xf012f448
f011c581:	68 47 09 00 00       	push   $0x947
f011c586:	68 87 be 12 f0       	push   $0xf012be87
f011c58b:	e8 a9 3d fe ff       	call   f0100339 <_panic>

f011c590 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011c590:	55                   	push   %ebp
f011c591:	89 e5                	mov    %esp,%ebp
f011c593:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c596:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c59d:	e9 84 00 00 00       	jmp    f011c626 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011c5a2:	83 ec 08             	sub    $0x8,%esp
f011c5a5:	ff 75 f4             	pushl  -0xc(%ebp)
f011c5a8:	68 14 f6 12 f0       	push   $0xf012f614
f011c5ad:	e8 d9 49 fe ff       	call   f0100f8b <cprintf>
f011c5b2:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011c5b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c5bc:	eb 4c                	jmp    f011c60a <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011c5be:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c5c1:	89 d0                	mov    %edx,%eax
f011c5c3:	c1 e0 02             	shl    $0x2,%eax
f011c5c6:	01 d0                	add    %edx,%eax
f011c5c8:	c1 e0 03             	shl    $0x3,%eax
f011c5cb:	89 c2                	mov    %eax,%edx
f011c5cd:	8b 45 08             	mov    0x8(%ebp),%eax
f011c5d0:	01 c2                	add    %eax,%edx
f011c5d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c5d5:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011c5d8:	85 c0                	test   %eax,%eax
f011c5da:	74 36                	je     f011c612 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011c5dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c5df:	89 d0                	mov    %edx,%eax
f011c5e1:	c1 e0 02             	shl    $0x2,%eax
f011c5e4:	01 d0                	add    %edx,%eax
f011c5e6:	c1 e0 03             	shl    $0x3,%eax
f011c5e9:	89 c2                	mov    %eax,%edx
f011c5eb:	8b 45 08             	mov    0x8(%ebp),%eax
f011c5ee:	01 c2                	add    %eax,%edx
f011c5f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c5f3:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011c5f6:	83 ec 08             	sub    $0x8,%esp
f011c5f9:	50                   	push   %eax
f011c5fa:	68 1c f6 12 f0       	push   $0xf012f61c
f011c5ff:	e8 87 49 fe ff       	call   f0100f8b <cprintf>
f011c604:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011c607:	ff 45 f0             	incl   -0x10(%ebp)
f011c60a:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011c60e:	7e ae                	jle    f011c5be <print_order+0x2e>
f011c610:	eb 01                	jmp    f011c613 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011c612:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011c613:	83 ec 0c             	sub    $0xc,%esp
f011c616:	68 21 f6 12 f0       	push   $0xf012f621
f011c61b:	e8 6b 49 fe ff       	call   f0100f8b <cprintf>
f011c620:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c623:	ff 45 f4             	incl   -0xc(%ebp)
f011c626:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011c62a:	0f 8e 72 ff ff ff    	jle    f011c5a2 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011c630:	90                   	nop
f011c631:	c9                   	leave  
f011c632:	c3                   	ret    

f011c633 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011c633:	55                   	push   %ebp
f011c634:	89 e5                	mov    %esp,%ebp
f011c636:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011c639:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011c640:	83 ec 0c             	sub    $0xc,%esp
f011c643:	68 c0 42 5f f0       	push   $0xf05f42c0
f011c648:	e8 3f 25 ff ff       	call   f010eb8c <acquire_spinlock>
f011c64d:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011c650:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011c657:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c65e:	8b 55 0c             	mov    0xc(%ebp),%edx
f011c661:	8b 45 10             	mov    0x10(%ebp),%eax
f011c664:	01 d0                	add    %edx,%eax
f011c666:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011c669:	a1 4c 43 5f f0       	mov    0xf05f434c,%eax
f011c66e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011c671:	a1 44 43 5f f0       	mov    0xf05f4344,%eax
f011c676:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011c679:	ff 75 e8             	pushl  -0x18(%ebp)
f011c67c:	ff 75 0c             	pushl  0xc(%ebp)
f011c67f:	ff 75 08             	pushl  0x8(%ebp)
f011c682:	68 24 f6 12 f0       	push   $0xf012f624
f011c687:	e8 ff 48 fe ff       	call   f0100f8b <cprintf>
f011c68c:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011c68f:	eb 34                	jmp    f011c6c5 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011c691:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c694:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011c697:	7d 05                	jge    f011c69e <find_in_range+0x6b>
			{
				i++;
f011c699:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011c69c:	eb 1e                	jmp    f011c6bc <find_in_range+0x89>
			}
			if (i >= end)
f011c69e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c6a1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011c6a4:	7d 29                	jge    f011c6cf <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011c6a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c6a9:	8b 40 10             	mov    0x10(%eax),%eax
f011c6ac:	3b 45 08             	cmp    0x8(%ebp),%eax
f011c6af:	75 08                	jne    f011c6b9 <find_in_range+0x86>
			{
				ret = i;
f011c6b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c6b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011c6b7:	eb 17                	jmp    f011c6d0 <find_in_range+0x9d>
			}
			i++;
f011c6b9:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011c6bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c6bf:	8b 40 0c             	mov    0xc(%eax),%eax
f011c6c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011c6c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c6c8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011c6cb:	7c c4                	jl     f011c691 <find_in_range+0x5e>
f011c6cd:	eb 01                	jmp    f011c6d0 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011c6cf:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011c6d0:	83 ec 0c             	sub    $0xc,%esp
f011c6d3:	68 c0 42 5f f0       	push   $0xf05f42c0
f011c6d8:	e8 36 25 ff ff       	call   f010ec13 <release_spinlock>
f011c6dd:	83 c4 10             	add    $0x10,%esp
	return ret;
f011c6e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011c6e3:	c9                   	leave  
f011c6e4:	c3                   	ret    

f011c6e5 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011c6e5:	55                   	push   %ebp
f011c6e6:	89 e5                	mov    %esp,%ebp
f011c6e8:	57                   	push   %edi
f011c6e9:	56                   	push   %esi
f011c6ea:	53                   	push   %ebx
f011c6eb:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011c6ee:	a0 dd cd 17 f0       	mov    0xf017cddd,%al
f011c6f3:	84 c0                	test   %al,%al
f011c6f5:	0f 84 9b 01 00 00    	je     f011c896 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011c6fb:	c6 05 dd cd 17 f0 00 	movb   $0x0,0xf017cddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011c702:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011c705:	bb 9c f7 12 f0       	mov    $0xf012f79c,%ebx
f011c70a:	ba 05 00 00 00       	mov    $0x5,%edx
f011c70f:	89 c7                	mov    %eax,%edi
f011c711:	89 de                	mov    %ebx,%esi
f011c713:	89 d1                	mov    %edx,%ecx
f011c715:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011c717:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011c71e:	e9 44 01 00 00       	jmp    f011c867 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011c723:	6a 00                	push   $0x0
f011c725:	6a 00                	push   $0x0
f011c727:	68 f4 01 00 00       	push   $0x1f4
f011c72c:	68 55 f6 12 f0       	push   $0xf012f655
f011c731:	e8 57 da fe ff       	call   f010a18d <env_create>
f011c736:	83 c4 10             	add    $0x10,%esp
f011c739:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011c73c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c73f:	b9 05 00 00 00       	mov    $0x5,%ecx
f011c744:	99                   	cltd   
f011c745:	f7 f9                	idiv   %ecx
f011c747:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011c74a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c74d:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011c751:	83 ec 08             	sub    $0x8,%esp
f011c754:	50                   	push   %eax
f011c755:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c758:	e8 c7 9e fe ff       	call   f0106624 <env_set_nice>
f011c75d:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011c760:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011c764:	75 14                	jne    f011c77a <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011c766:	83 ec 04             	sub    $0x4,%esp
f011c769:	68 5d f6 12 f0       	push   $0xf012f65d
f011c76e:	6a 53                	push   $0x53
f011c770:	68 76 f6 12 f0       	push   $0xf012f676
f011c775:	e8 bf 3b fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011c77a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c77d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011c783:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011c788:	74 14                	je     f011c79e <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011c78a:	83 ec 04             	sub    $0x4,%esp
f011c78d:	68 94 f6 12 f0       	push   $0xf012f694
f011c792:	6a 55                	push   $0x55
f011c794:	68 76 f6 12 f0       	push   $0xf012f676
f011c799:	e8 9b 3b fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011c79e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c7a1:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011c7a5:	83 c0 0a             	add    $0xa,%eax
f011c7a8:	83 f8 14             	cmp    $0x14,%eax
f011c7ab:	0f 87 a5 00 00 00    	ja     f011c856 <test_bsd_nice_0+0x171>
f011c7b1:	8b 04 85 b0 f7 12 f0 	mov    -0xfed0850(,%eax,4),%eax
f011c7b8:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011c7ba:	a1 5c 40 5f f0       	mov    0xf05f405c,%eax
f011c7bf:	8d 50 01             	lea    0x1(%eax),%edx
f011c7c2:	89 15 5c 40 5f f0    	mov    %edx,0xf05f405c
f011c7c8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c7cb:	8b 52 10             	mov    0x10(%edx),%edx
f011c7ce:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011c7d5:	eb 7f                	jmp    f011c856 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011c7d7:	a1 60 40 5f f0       	mov    0xf05f4060,%eax
f011c7dc:	8d 50 01             	lea    0x1(%eax),%edx
f011c7df:	89 15 60 40 5f f0    	mov    %edx,0xf05f4060
f011c7e5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c7e8:	8b 52 10             	mov    0x10(%edx),%edx
f011c7eb:	83 c0 0a             	add    $0xa,%eax
f011c7ee:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011c7f5:	eb 5f                	jmp    f011c856 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011c7f7:	a1 64 40 5f f0       	mov    0xf05f4064,%eax
f011c7fc:	8d 50 01             	lea    0x1(%eax),%edx
f011c7ff:	89 15 64 40 5f f0    	mov    %edx,0xf05f4064
f011c805:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c808:	8b 52 10             	mov    0x10(%edx),%edx
f011c80b:	83 c0 14             	add    $0x14,%eax
f011c80e:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011c815:	eb 3f                	jmp    f011c856 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011c817:	a1 68 40 5f f0       	mov    0xf05f4068,%eax
f011c81c:	8d 50 01             	lea    0x1(%eax),%edx
f011c81f:	89 15 68 40 5f f0    	mov    %edx,0xf05f4068
f011c825:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c828:	8b 52 10             	mov    0x10(%edx),%edx
f011c82b:	83 c0 1e             	add    $0x1e,%eax
f011c82e:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011c835:	eb 1f                	jmp    f011c856 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011c837:	a1 6c 40 5f f0       	mov    0xf05f406c,%eax
f011c83c:	8d 50 01             	lea    0x1(%eax),%edx
f011c83f:	89 15 6c 40 5f f0    	mov    %edx,0xf05f406c
f011c845:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c848:	8b 52 10             	mov    0x10(%edx),%edx
f011c84b:	83 c0 28             	add    $0x28,%eax
f011c84e:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011c855:	90                   	nop
			}
			sched_new_env(env);
f011c856:	83 ec 0c             	sub    $0xc,%esp
f011c859:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c85c:	e8 59 8e fe ff       	call   f01056ba <sched_new_env>
f011c861:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011c864:	ff 45 e4             	incl   -0x1c(%ebp)
f011c867:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011c86b:	0f 8e b2 fe ff ff    	jle    f011c723 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011c871:	83 ec 0c             	sub    $0xc,%esp
f011c874:	68 c4 f6 12 f0       	push   $0xf012f6c4
f011c879:	e8 0d 47 fe ff       	call   f0100f8b <cprintf>
f011c87e:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011c881:	83 ec 0c             	sub    $0xc,%esp
f011c884:	68 13 f7 12 f0       	push   $0xf012f713
f011c889:	e8 6d 56 fe ff       	call   f0101efb <execute_command>
f011c88e:	83 c4 10             	add    $0x10,%esp
f011c891:	e9 c0 00 00 00       	jmp    f011c956 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011c896:	83 ec 0c             	sub    $0xc,%esp
f011c899:	68 1a f7 12 f0       	push   $0xf012f71a
f011c89e:	e8 e8 46 fe ff       	call   f0100f8b <cprintf>
f011c8a3:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011c8a6:	e8 47 95 fe ff       	call   f0105df2 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011c8ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c8b2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011c8b9:	e9 87 00 00 00       	jmp    f011c945 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011c8be:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011c8c5:	eb 52                	jmp    f011c919 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011c8c7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c8ca:	8b 14 85 5c 40 5f f0 	mov    -0xfa0bfa4(,%eax,4),%edx
f011c8d1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011c8d4:	89 c8                	mov    %ecx,%eax
f011c8d6:	c1 e0 02             	shl    $0x2,%eax
f011c8d9:	01 c8                	add    %ecx,%eax
f011c8db:	01 c0                	add    %eax,%eax
f011c8dd:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011c8e0:	01 c8                	add    %ecx,%eax
f011c8e2:	8b 04 85 a0 71 61 f0 	mov    -0xf9e8e60(,%eax,4),%eax
f011c8e9:	83 ec 04             	sub    $0x4,%esp
f011c8ec:	52                   	push   %edx
f011c8ed:	ff 75 e0             	pushl  -0x20(%ebp)
f011c8f0:	50                   	push   %eax
f011c8f1:	e8 3d fd ff ff       	call   f011c633 <find_in_range>
f011c8f6:	83 c4 10             	add    $0x10,%esp
f011c8f9:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011c8fc:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011c900:	75 14                	jne    f011c916 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011c902:	83 ec 04             	sub    $0x4,%esp
f011c905:	68 2c f7 12 f0       	push   $0xf012f72c
f011c90a:	6a 7b                	push   $0x7b
f011c90c:	68 76 f6 12 f0       	push   $0xf012f676
f011c911:	e8 23 3a fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011c916:	ff 45 d8             	incl   -0x28(%ebp)
f011c919:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c91c:	89 d0                	mov    %edx,%eax
f011c91e:	c1 e0 02             	shl    $0x2,%eax
f011c921:	01 d0                	add    %edx,%eax
f011c923:	01 c0                	add    %eax,%eax
f011c925:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c928:	01 d0                	add    %edx,%eax
f011c92a:	8b 04 85 a0 71 61 f0 	mov    -0xf9e8e60(,%eax,4),%eax
f011c931:	85 c0                	test   %eax,%eax
f011c933:	75 92                	jne    f011c8c7 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011c935:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c938:	8b 04 85 5c 40 5f f0 	mov    -0xfa0bfa4(,%eax,4),%eax
f011c93f:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c942:	ff 45 dc             	incl   -0x24(%ebp)
f011c945:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011c949:	0f 8e 6f ff ff ff    	jle    f011c8be <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011c94f:	c6 05 dd cd 17 f0 00 	movb   $0x0,0xf017cddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011c956:	83 ec 0c             	sub    $0xc,%esp
f011c959:	68 60 f7 12 f0       	push   $0xf012f760
f011c95e:	e8 28 46 fe ff       	call   f0100f8b <cprintf>
f011c963:	83 c4 10             	add    $0x10,%esp
}
f011c966:	90                   	nop
f011c967:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c96a:	5b                   	pop    %ebx
f011c96b:	5e                   	pop    %esi
f011c96c:	5f                   	pop    %edi
f011c96d:	5d                   	pop    %ebp
f011c96e:	c3                   	ret    

f011c96f <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011c96f:	55                   	push   %ebp
f011c970:	89 e5                	mov    %esp,%ebp
f011c972:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011c975:	a0 dd cd 17 f0       	mov    0xf017cddd,%al
f011c97a:	84 c0                	test   %al,%al
f011c97c:	0f 84 50 01 00 00    	je     f011cad2 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011c982:	c6 05 dd cd 17 f0 00 	movb   $0x0,0xf017cddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011c989:	6a 00                	push   $0x0
f011c98b:	6a 00                	push   $0x0
f011c98d:	68 f4 01 00 00       	push   $0x1f4
f011c992:	68 55 f6 12 f0       	push   $0xf012f655
f011c997:	e8 f1 d7 fe ff       	call   f010a18d <env_create>
f011c99c:	83 c4 10             	add    $0x10,%esp
f011c99f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011c9a2:	6a 00                	push   $0x0
f011c9a4:	6a 00                	push   $0x0
f011c9a6:	68 f4 01 00 00       	push   $0x1f4
f011c9ab:	68 04 f8 12 f0       	push   $0xf012f804
f011c9b0:	e8 d8 d7 fe ff       	call   f010a18d <env_create>
f011c9b5:	83 c4 10             	add    $0x10,%esp
f011c9b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011c9bb:	6a 00                	push   $0x0
f011c9bd:	6a 00                	push   $0x0
f011c9bf:	68 f4 01 00 00       	push   $0x1f4
f011c9c4:	68 11 f8 12 f0       	push   $0xf012f811
f011c9c9:	e8 bf d7 fe ff       	call   f010a18d <env_create>
f011c9ce:	83 c4 10             	add    $0x10,%esp
f011c9d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011c9d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c9d8:	74 0c                	je     f011c9e6 <test_bsd_nice_1+0x77>
f011c9da:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011c9de:	74 06                	je     f011c9e6 <test_bsd_nice_1+0x77>
f011c9e0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011c9e4:	75 17                	jne    f011c9fd <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011c9e6:	83 ec 04             	sub    $0x4,%esp
f011c9e9:	68 5d f6 12 f0       	push   $0xf012f65d
f011c9ee:	68 8e 00 00 00       	push   $0x8e
f011c9f3:	68 76 f6 12 f0       	push   $0xf012f676
f011c9f8:	e8 3c 39 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011c9fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca00:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ca06:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011ca0b:	75 20                	jne    f011ca2d <test_bsd_nice_1+0xbe>
f011ca0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ca10:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ca16:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011ca1b:	75 10                	jne    f011ca2d <test_bsd_nice_1+0xbe>
f011ca1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ca20:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ca26:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011ca2b:	74 35                	je     f011ca62 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011ca2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ca30:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f011ca36:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ca39:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f011ca3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca42:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ca48:	83 ec 08             	sub    $0x8,%esp
f011ca4b:	51                   	push   %ecx
f011ca4c:	52                   	push   %edx
f011ca4d:	50                   	push   %eax
f011ca4e:	68 20 f8 12 f0       	push   $0xf012f820
f011ca53:	68 90 00 00 00       	push   $0x90
f011ca58:	68 76 f6 12 f0       	push   $0xf012f676
f011ca5d:	e8 d7 38 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011ca62:	83 ec 0c             	sub    $0xc,%esp
f011ca65:	ff 75 ec             	pushl  -0x14(%ebp)
f011ca68:	e8 4d 8c fe ff       	call   f01056ba <sched_new_env>
f011ca6d:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011ca70:	83 ec 0c             	sub    $0xc,%esp
f011ca73:	ff 75 e8             	pushl  -0x18(%ebp)
f011ca76:	e8 3f 8c fe ff       	call   f01056ba <sched_new_env>
f011ca7b:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011ca7e:	83 ec 0c             	sub    $0xc,%esp
f011ca81:	ff 75 e4             	pushl  -0x1c(%ebp)
f011ca84:	e8 31 8c fe ff       	call   f01056ba <sched_new_env>
f011ca89:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011ca8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ca8f:	8b 40 10             	mov    0x10(%eax),%eax
f011ca92:	a3 a0 71 61 f0       	mov    %eax,0xf06171a0
		prog_orders[1][0] = fibEnv->env_id;
f011ca97:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca9a:	8b 40 10             	mov    0x10(%eax),%eax
f011ca9d:	a3 c8 71 61 f0       	mov    %eax,0xf06171c8
		prog_orders[2][0] = fibposnEnv->env_id;
f011caa2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011caa5:	8b 40 10             	mov    0x10(%eax),%eax
f011caa8:	a3 f0 71 61 f0       	mov    %eax,0xf06171f0
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011caad:	83 ec 0c             	sub    $0xc,%esp
f011cab0:	68 c4 f6 12 f0       	push   $0xf012f6c4
f011cab5:	e8 d1 44 fe ff       	call   f0100f8b <cprintf>
f011caba:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011cabd:	83 ec 0c             	sub    $0xc,%esp
f011cac0:	68 13 f7 12 f0       	push   $0xf012f713
f011cac5:	e8 31 54 fe ff       	call   f0101efb <execute_command>
f011caca:	83 c4 10             	add    $0x10,%esp
f011cacd:	e9 9e 00 00 00       	jmp    f011cb70 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011cad2:	83 ec 0c             	sub    $0xc,%esp
f011cad5:	68 1a f7 12 f0       	push   $0xf012f71a
f011cada:	e8 ac 44 fe ff       	call   f0100f8b <cprintf>
f011cadf:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011cae2:	e8 0b 93 fe ff       	call   f0105df2 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011cae7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011caee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011caf5:	83 ec 0c             	sub    $0xc,%esp
f011caf8:	68 c0 42 5f f0       	push   $0xf05f42c0
f011cafd:	e8 8a 20 ff ff       	call   f010eb8c <acquire_spinlock>
f011cb02:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011cb05:	a1 4c 43 5f f0       	mov    0xf05f434c,%eax
f011cb0a:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011cb0d:	a1 44 43 5f f0       	mov    0xf05f4344,%eax
f011cb12:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011cb15:	eb 41                	jmp    f011cb58 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011cb17:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011cb1a:	89 d0                	mov    %edx,%eax
f011cb1c:	c1 e0 02             	shl    $0x2,%eax
f011cb1f:	01 d0                	add    %edx,%eax
f011cb21:	c1 e0 03             	shl    $0x3,%eax
f011cb24:	05 a0 71 61 f0       	add    $0xf06171a0,%eax
f011cb29:	8b 10                	mov    (%eax),%edx
f011cb2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011cb2e:	8b 40 10             	mov    0x10(%eax),%eax
f011cb31:	39 c2                	cmp    %eax,%edx
f011cb33:	74 17                	je     f011cb4c <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011cb35:	83 ec 04             	sub    $0x4,%esp
f011cb38:	68 2c f7 12 f0       	push   $0xf012f72c
f011cb3d:	68 ab 00 00 00       	push   $0xab
f011cb42:	68 76 f6 12 f0       	push   $0xf012f676
f011cb47:	e8 ed 37 fe ff       	call   f0100339 <_panic>
				i++;
f011cb4c:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011cb4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011cb52:	8b 40 0c             	mov    0xc(%eax),%eax
f011cb55:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011cb58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011cb5b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011cb5e:	7c b7                	jl     f011cb17 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011cb60:	83 ec 0c             	sub    $0xc,%esp
f011cb63:	68 c0 42 5f f0       	push   $0xf05f42c0
f011cb68:	e8 a6 20 ff ff       	call   f010ec13 <release_spinlock>
f011cb6d:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011cb70:	83 ec 0c             	sub    $0xc,%esp
f011cb73:	68 8c f8 12 f0       	push   $0xf012f88c
f011cb78:	e8 0e 44 fe ff       	call   f0100f8b <cprintf>
f011cb7d:	83 c4 10             	add    $0x10,%esp
}
f011cb80:	90                   	nop
f011cb81:	c9                   	leave  
f011cb82:	c3                   	ret    

f011cb83 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011cb83:	55                   	push   %ebp
f011cb84:	89 e5                	mov    %esp,%ebp
f011cb86:	57                   	push   %edi
f011cb87:	56                   	push   %esi
f011cb88:	53                   	push   %ebx
f011cb89:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011cb8c:	a0 dd cd 17 f0       	mov    0xf017cddd,%al
f011cb91:	84 c0                	test   %al,%al
f011cb93:	0f 84 ae 01 00 00    	je     f011cd47 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011cb99:	83 ec 0c             	sub    $0xc,%esp
f011cb9c:	6a 01                	push   $0x1
f011cb9e:	e8 fe 10 00 00       	call   f011dca1 <chksch>
f011cba3:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011cba6:	c6 05 dd cd 17 f0 00 	movb   $0x0,0xf017cddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011cbad:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011cbb0:	bb 10 f9 12 f0       	mov    $0xf012f910,%ebx
f011cbb5:	ba 05 00 00 00       	mov    $0x5,%edx
f011cbba:	89 c7                	mov    %eax,%edi
f011cbbc:	89 de                	mov    %ebx,%esi
f011cbbe:	89 d1                	mov    %edx,%ecx
f011cbc0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011cbc2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011cbc9:	e9 4a 01 00 00       	jmp    f011cd18 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011cbce:	6a 00                	push   $0x0
f011cbd0:	6a 00                	push   $0x0
f011cbd2:	68 10 27 00 00       	push   $0x2710
f011cbd7:	68 c8 f8 12 f0       	push   $0xf012f8c8
f011cbdc:	e8 ac d5 fe ff       	call   f010a18d <env_create>
f011cbe1:	83 c4 10             	add    $0x10,%esp
f011cbe4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011cbe7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011cbea:	b9 05 00 00 00       	mov    $0x5,%ecx
f011cbef:	99                   	cltd   
f011cbf0:	f7 f9                	idiv   %ecx
f011cbf2:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011cbf5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cbf8:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011cbfc:	83 ec 08             	sub    $0x8,%esp
f011cbff:	50                   	push   %eax
f011cc00:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cc03:	e8 1c 9a fe ff       	call   f0106624 <env_set_nice>
f011cc08:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011cc0b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011cc0f:	75 17                	jne    f011cc28 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011cc11:	83 ec 04             	sub    $0x4,%esp
f011cc14:	68 5d f6 12 f0       	push   $0xf012f65d
f011cc19:	68 c1 00 00 00       	push   $0xc1
f011cc1e:	68 76 f6 12 f0       	push   $0xf012f676
f011cc23:	e8 11 37 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011cc28:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc2b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011cc31:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011cc36:	74 17                	je     f011cc4f <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011cc38:	83 ec 04             	sub    $0x4,%esp
f011cc3b:	68 94 f6 12 f0       	push   $0xf012f694
f011cc40:	68 c3 00 00 00       	push   $0xc3
f011cc45:	68 76 f6 12 f0       	push   $0xf012f676
f011cc4a:	e8 ea 36 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011cc4f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cc52:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011cc56:	83 c0 0f             	add    $0xf,%eax
f011cc59:	83 f8 1e             	cmp    $0x1e,%eax
f011cc5c:	0f 87 a5 00 00 00    	ja     f011cd07 <test_bsd_nice_2+0x184>
f011cc62:	8b 04 85 24 f9 12 f0 	mov    -0xfed06dc(,%eax,4),%eax
f011cc69:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011cc6b:	a1 5c 40 5f f0       	mov    0xf05f405c,%eax
f011cc70:	8d 50 01             	lea    0x1(%eax),%edx
f011cc73:	89 15 5c 40 5f f0    	mov    %edx,0xf05f405c
f011cc79:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011cc7c:	8b 52 10             	mov    0x10(%edx),%edx
f011cc7f:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011cc86:	eb 7f                	jmp    f011cd07 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011cc88:	a1 60 40 5f f0       	mov    0xf05f4060,%eax
f011cc8d:	8d 50 01             	lea    0x1(%eax),%edx
f011cc90:	89 15 60 40 5f f0    	mov    %edx,0xf05f4060
f011cc96:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011cc99:	8b 52 10             	mov    0x10(%edx),%edx
f011cc9c:	83 c0 0a             	add    $0xa,%eax
f011cc9f:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011cca6:	eb 5f                	jmp    f011cd07 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011cca8:	a1 64 40 5f f0       	mov    0xf05f4064,%eax
f011ccad:	8d 50 01             	lea    0x1(%eax),%edx
f011ccb0:	89 15 64 40 5f f0    	mov    %edx,0xf05f4064
f011ccb6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ccb9:	8b 52 10             	mov    0x10(%edx),%edx
f011ccbc:	83 c0 14             	add    $0x14,%eax
f011ccbf:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011ccc6:	eb 3f                	jmp    f011cd07 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011ccc8:	a1 68 40 5f f0       	mov    0xf05f4068,%eax
f011cccd:	8d 50 01             	lea    0x1(%eax),%edx
f011ccd0:	89 15 68 40 5f f0    	mov    %edx,0xf05f4068
f011ccd6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ccd9:	8b 52 10             	mov    0x10(%edx),%edx
f011ccdc:	83 c0 1e             	add    $0x1e,%eax
f011ccdf:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011cce6:	eb 1f                	jmp    f011cd07 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011cce8:	a1 6c 40 5f f0       	mov    0xf05f406c,%eax
f011cced:	8d 50 01             	lea    0x1(%eax),%edx
f011ccf0:	89 15 6c 40 5f f0    	mov    %edx,0xf05f406c
f011ccf6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ccf9:	8b 52 10             	mov    0x10(%edx),%edx
f011ccfc:	83 c0 28             	add    $0x28,%eax
f011ccff:	89 14 85 a0 71 61 f0 	mov    %edx,-0xf9e8e60(,%eax,4)
				break;
f011cd06:	90                   	nop
			}
			sched_new_env(env);
f011cd07:	83 ec 0c             	sub    $0xc,%esp
f011cd0a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cd0d:	e8 a8 89 fe ff       	call   f01056ba <sched_new_env>
f011cd12:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011cd15:	ff 45 e4             	incl   -0x1c(%ebp)
f011cd18:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011cd1c:	0f 8e ac fe ff ff    	jle    f011cbce <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011cd22:	83 ec 0c             	sub    $0xc,%esp
f011cd25:	68 c4 f6 12 f0       	push   $0xf012f6c4
f011cd2a:	e8 5c 42 fe ff       	call   f0100f8b <cprintf>
f011cd2f:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011cd32:	83 ec 0c             	sub    $0xc,%esp
f011cd35:	68 13 f7 12 f0       	push   $0xf012f713
f011cd3a:	e8 bc 51 fe ff       	call   f0101efb <execute_command>
f011cd3f:	83 c4 10             	add    $0x10,%esp
f011cd42:	e9 d0 00 00 00       	jmp    f011ce17 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011cd47:	83 ec 0c             	sub    $0xc,%esp
f011cd4a:	6a 00                	push   $0x0
f011cd4c:	e8 50 0f 00 00       	call   f011dca1 <chksch>
f011cd51:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011cd54:	83 ec 0c             	sub    $0xc,%esp
f011cd57:	68 1a f7 12 f0       	push   $0xf012f71a
f011cd5c:	e8 2a 42 fe ff       	call   f0100f8b <cprintf>
f011cd61:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011cd64:	e8 89 90 fe ff       	call   f0105df2 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011cd69:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011cd70:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011cd77:	e9 8a 00 00 00       	jmp    f011ce06 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011cd7c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011cd83:	eb 55                	jmp    f011cdda <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011cd85:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cd88:	8b 14 85 5c 40 5f f0 	mov    -0xfa0bfa4(,%eax,4),%edx
f011cd8f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011cd92:	89 c8                	mov    %ecx,%eax
f011cd94:	c1 e0 02             	shl    $0x2,%eax
f011cd97:	01 c8                	add    %ecx,%eax
f011cd99:	01 c0                	add    %eax,%eax
f011cd9b:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011cd9e:	01 c8                	add    %ecx,%eax
f011cda0:	8b 04 85 a0 71 61 f0 	mov    -0xf9e8e60(,%eax,4),%eax
f011cda7:	83 ec 04             	sub    $0x4,%esp
f011cdaa:	52                   	push   %edx
f011cdab:	ff 75 e0             	pushl  -0x20(%ebp)
f011cdae:	50                   	push   %eax
f011cdaf:	e8 7f f8 ff ff       	call   f011c633 <find_in_range>
f011cdb4:	83 c4 10             	add    $0x10,%esp
f011cdb7:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011cdba:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011cdbe:	75 17                	jne    f011cdd7 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011cdc0:	83 ec 04             	sub    $0x4,%esp
f011cdc3:	68 2c f7 12 f0       	push   $0xf012f72c
f011cdc8:	68 ea 00 00 00       	push   $0xea
f011cdcd:	68 76 f6 12 f0       	push   $0xf012f676
f011cdd2:	e8 62 35 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011cdd7:	ff 45 d8             	incl   -0x28(%ebp)
f011cdda:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011cddd:	89 d0                	mov    %edx,%eax
f011cddf:	c1 e0 02             	shl    $0x2,%eax
f011cde2:	01 d0                	add    %edx,%eax
f011cde4:	01 c0                	add    %eax,%eax
f011cde6:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011cde9:	01 d0                	add    %edx,%eax
f011cdeb:	8b 04 85 a0 71 61 f0 	mov    -0xf9e8e60(,%eax,4),%eax
f011cdf2:	85 c0                	test   %eax,%eax
f011cdf4:	75 8f                	jne    f011cd85 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011cdf6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cdf9:	8b 04 85 5c 40 5f f0 	mov    -0xfa0bfa4(,%eax,4),%eax
f011ce00:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ce03:	ff 45 dc             	incl   -0x24(%ebp)
f011ce06:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011ce0a:	0f 8e 6c ff ff ff    	jle    f011cd7c <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011ce10:	c6 05 dd cd 17 f0 00 	movb   $0x0,0xf017cddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011ce17:	83 ec 0c             	sub    $0xc,%esp
f011ce1a:	68 d4 f8 12 f0       	push   $0xf012f8d4
f011ce1f:	e8 67 41 fe ff       	call   f0100f8b <cprintf>
f011ce24:	83 c4 10             	add    $0x10,%esp
}
f011ce27:	90                   	nop
f011ce28:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011ce2b:	5b                   	pop    %ebx
f011ce2c:	5e                   	pop    %esi
f011ce2d:	5f                   	pop    %edi
f011ce2e:	5d                   	pop    %ebp
f011ce2f:	c3                   	ret    

f011ce30 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011ce30:	55                   	push   %ebp
f011ce31:	89 e5                	mov    %esp,%ebp
f011ce33:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011ce36:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ce39:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011ce3c:	8b 45 08             	mov    0x8(%ebp),%eax
f011ce3f:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ce42:	89 10                	mov    %edx,(%eax)
}
f011ce44:	8b 45 08             	mov    0x8(%ebp),%eax
f011ce47:	c9                   	leave  
f011ce48:	c2 04 00             	ret    $0x4

f011ce4b <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011ce4b:	55                   	push   %ebp
f011ce4c:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011ce4e:	8b 45 08             	mov    0x8(%ebp),%eax
f011ce51:	85 c0                	test   %eax,%eax
f011ce53:	78 16                	js     f011ce6b <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011ce55:	8b 45 08             	mov    0x8(%ebp),%eax
f011ce58:	05 00 20 00 00       	add    $0x2000,%eax
f011ce5d:	85 c0                	test   %eax,%eax
f011ce5f:	79 05                	jns    f011ce66 <fix_round+0x1b>
f011ce61:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011ce66:	c1 f8 0e             	sar    $0xe,%eax
f011ce69:	eb 14                	jmp    f011ce7f <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011ce6b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ce6e:	2d 00 20 00 00       	sub    $0x2000,%eax
f011ce73:	85 c0                	test   %eax,%eax
f011ce75:	79 05                	jns    f011ce7c <fix_round+0x31>
f011ce77:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011ce7c:	c1 f8 0e             	sar    $0xe,%eax
}
f011ce7f:	5d                   	pop    %ebp
f011ce80:	c3                   	ret    

f011ce81 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011ce81:	55                   	push   %ebp
f011ce82:	89 e5                	mov    %esp,%ebp
f011ce84:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011ce87:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ce8b:	79 16                	jns    f011cea3 <fix_scale+0x22>
f011ce8d:	68 a0 f9 12 f0       	push   $0xf012f9a0
f011ce92:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011ce97:	6a 5a                	push   $0x5a
f011ce99:	68 bc f9 12 f0       	push   $0xf012f9bc
f011ce9e:	e8 96 34 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011cea3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011cea6:	0f af 45 10          	imul   0x10(%ebp),%eax
f011ceaa:	89 c2                	mov    %eax,%edx
f011ceac:	8b 45 08             	mov    0x8(%ebp),%eax
f011ceaf:	83 ec 08             	sub    $0x8,%esp
f011ceb2:	52                   	push   %edx
f011ceb3:	50                   	push   %eax
f011ceb4:	e8 77 ff ff ff       	call   f011ce30 <__mk_fix>
f011ceb9:	83 c4 0c             	add    $0xc,%esp
}
f011cebc:	8b 45 08             	mov    0x8(%ebp),%eax
f011cebf:	c9                   	leave  
f011cec0:	c2 04 00             	ret    $0x4

f011cec3 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011cec3:	55                   	push   %ebp
f011cec4:	89 e5                	mov    %esp,%ebp
f011cec6:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011cec9:	83 ec 08             	sub    $0x8,%esp
f011cecc:	68 d0 f9 12 f0       	push   $0xf012f9d0
f011ced1:	68 c0 4a 5f f0       	push   $0xf05f4ac0
f011ced6:	e8 80 1c ff ff       	call   f010eb5b <init_spinlock>
f011cedb:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011cede:	83 ec 0c             	sub    $0xc,%esp
f011cee1:	68 c0 4a 5f f0       	push   $0xf05f4ac0
f011cee6:	e8 a1 1c ff ff       	call   f010eb8c <acquire_spinlock>
f011ceeb:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011ceee:	c7 05 a8 41 5f f0 00 	movl   $0x0,0xf05f41a8
f011cef5:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011cef8:	83 ec 0c             	sub    $0xc,%esp
f011cefb:	68 c0 4a 5f f0       	push   $0xf05f4ac0
f011cf00:	e8 0e 1d ff ff       	call   f010ec13 <release_spinlock>
f011cf05:	83 c4 10             	add    $0x10,%esp
}
f011cf08:	90                   	nop
f011cf09:	c9                   	leave  
f011cf0a:	c3                   	ret    

f011cf0b <inctst>:
void inctst()
{
f011cf0b:	55                   	push   %ebp
f011cf0c:	89 e5                	mov    %esp,%ebp
f011cf0e:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011cf11:	83 ec 0c             	sub    $0xc,%esp
f011cf14:	68 c0 4a 5f f0       	push   $0xf05f4ac0
f011cf19:	e8 6e 1c ff ff       	call   f010eb8c <acquire_spinlock>
f011cf1e:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011cf21:	a1 a8 41 5f f0       	mov    0xf05f41a8,%eax
f011cf26:	40                   	inc    %eax
f011cf27:	a3 a8 41 5f f0       	mov    %eax,0xf05f41a8
	}
	release_spinlock(&tstcntlock);
f011cf2c:	83 ec 0c             	sub    $0xc,%esp
f011cf2f:	68 c0 4a 5f f0       	push   $0xf05f4ac0
f011cf34:	e8 da 1c ff ff       	call   f010ec13 <release_spinlock>
f011cf39:	83 c4 10             	add    $0x10,%esp
}
f011cf3c:	90                   	nop
f011cf3d:	c9                   	leave  
f011cf3e:	c3                   	ret    

f011cf3f <gettst>:
uint32 gettst()
{
f011cf3f:	55                   	push   %ebp
f011cf40:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011cf42:	a1 a8 41 5f f0       	mov    0xf05f41a8,%eax
}
f011cf47:	5d                   	pop    %ebp
f011cf48:	c3                   	ret    

f011cf49 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011cf49:	55                   	push   %ebp
f011cf4a:	89 e5                	mov    %esp,%ebp
f011cf4c:	83 ec 28             	sub    $0x28,%esp
f011cf4f:	8b 45 14             	mov    0x14(%ebp),%eax
f011cf52:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011cf55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011cf5c:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011cf60:	83 f8 65             	cmp    $0x65,%eax
f011cf63:	74 5d                	je     f011cfc2 <tst+0x79>
f011cf65:	83 f8 65             	cmp    $0x65,%eax
f011cf68:	7f 0a                	jg     f011cf74 <tst+0x2b>
f011cf6a:	83 f8 62             	cmp    $0x62,%eax
f011cf6d:	74 73                	je     f011cfe2 <tst+0x99>
f011cf6f:	e9 91 00 00 00       	jmp    f011d005 <tst+0xbc>
f011cf74:	83 f8 67             	cmp    $0x67,%eax
f011cf77:	74 29                	je     f011cfa2 <tst+0x59>
f011cf79:	83 f8 6c             	cmp    $0x6c,%eax
f011cf7c:	0f 85 83 00 00 00    	jne    f011d005 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011cf82:	8b 45 08             	mov    0x8(%ebp),%eax
f011cf85:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011cf88:	73 09                	jae    f011cf93 <tst+0x4a>
			chk = 1;
f011cf8a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011cf91:	eb 68                	jmp    f011cffb <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011cf93:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011cf97:	74 62                	je     f011cffb <tst+0xb2>
			chk = 1;
f011cf99:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011cfa0:	eb 59                	jmp    f011cffb <tst+0xb2>
	case 'g':
		if (n > v1)
f011cfa2:	8b 45 08             	mov    0x8(%ebp),%eax
f011cfa5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011cfa8:	76 09                	jbe    f011cfb3 <tst+0x6a>
			chk = 1;
f011cfaa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011cfb1:	eb 4b                	jmp    f011cffe <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011cfb3:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011cfb7:	74 45                	je     f011cffe <tst+0xb5>
			chk = 1;
f011cfb9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011cfc0:	eb 3c                	jmp    f011cffe <tst+0xb5>
	case 'e':
		if (n == v1)
f011cfc2:	8b 45 08             	mov    0x8(%ebp),%eax
f011cfc5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011cfc8:	75 09                	jne    f011cfd3 <tst+0x8a>
			chk = 1;
f011cfca:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011cfd1:	eb 2e                	jmp    f011d001 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011cfd3:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011cfd7:	74 28                	je     f011d001 <tst+0xb8>
			chk = 1;
f011cfd9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011cfe0:	eb 1f                	jmp    f011d001 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011cfe2:	8b 45 08             	mov    0x8(%ebp),%eax
f011cfe5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011cfe8:	72 1a                	jb     f011d004 <tst+0xbb>
f011cfea:	8b 45 08             	mov    0x8(%ebp),%eax
f011cfed:	3b 45 10             	cmp    0x10(%ebp),%eax
f011cff0:	77 12                	ja     f011d004 <tst+0xbb>
			chk = 1;
f011cff2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011cff9:	eb 09                	jmp    f011d004 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011cffb:	90                   	nop
f011cffc:	eb 07                	jmp    f011d005 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011cffe:	90                   	nop
f011cfff:	eb 04                	jmp    f011d005 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011d001:	90                   	nop
f011d002:	eb 01                	jmp    f011d005 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011d004:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011d005:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d009:	75 14                	jne    f011d01f <tst+0xd6>
f011d00b:	83 ec 04             	sub    $0x4,%esp
f011d00e:	68 dc f9 12 f0       	push   $0xf012f9dc
f011d013:	6a 48                	push   $0x48
f011d015:	68 ef f9 12 f0       	push   $0xf012f9ef
f011d01a:	e8 1a 33 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011d01f:	83 ec 0c             	sub    $0xc,%esp
f011d022:	68 c0 4a 5f f0       	push   $0xf05f4ac0
f011d027:	e8 60 1b ff ff       	call   f010eb8c <acquire_spinlock>
f011d02c:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011d02f:	a1 a8 41 5f f0       	mov    0xf05f41a8,%eax
f011d034:	40                   	inc    %eax
f011d035:	a3 a8 41 5f f0       	mov    %eax,0xf05f41a8
	}
	release_spinlock(&tstcntlock);
f011d03a:	83 ec 0c             	sub    $0xc,%esp
f011d03d:	68 c0 4a 5f f0       	push   $0xf05f4ac0
f011d042:	e8 cc 1b ff ff       	call   f010ec13 <release_spinlock>
f011d047:	83 c4 10             	add    $0x10,%esp

	return;
f011d04a:	90                   	nop
}
f011d04b:	c9                   	leave  
f011d04c:	c3                   	ret    

f011d04d <chktst>:

void chktst(uint32 n)
{
f011d04d:	55                   	push   %ebp
f011d04e:	89 e5                	mov    %esp,%ebp
f011d050:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011d053:	83 ec 0c             	sub    $0xc,%esp
f011d056:	68 c0 4a 5f f0       	push   $0xf05f4ac0
f011d05b:	e8 2c 1b ff ff       	call   f010eb8c <acquire_spinlock>
f011d060:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011d063:	a1 a8 41 5f f0       	mov    0xf05f41a8,%eax
f011d068:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011d06b:	83 ec 0c             	sub    $0xc,%esp
f011d06e:	68 c0 4a 5f f0       	push   $0xf05f4ac0
f011d073:	e8 9b 1b ff ff       	call   f010ec13 <release_spinlock>
f011d078:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011d07b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d07e:	3b 45 08             	cmp    0x8(%ebp),%eax
f011d081:	75 12                	jne    f011d095 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011d083:	83 ec 0c             	sub    $0xc,%esp
f011d086:	68 08 fa 12 f0       	push   $0xf012fa08
f011d08b:	e8 fb 3e fe ff       	call   f0100f8b <cprintf>
f011d090:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011d093:	eb 14                	jmp    f011d0a9 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011d095:	83 ec 04             	sub    $0x4,%esp
f011d098:	68 34 fa 12 f0       	push   $0xf012fa34
f011d09d:	6a 5e                	push   $0x5e
f011d09f:	68 ef f9 12 f0       	push   $0xf012f9ef
f011d0a4:	e8 90 32 fe ff       	call   f0100339 <_panic>
}
f011d0a9:	c9                   	leave  
f011d0aa:	c3                   	ret    

f011d0ab <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011d0ab:	55                   	push   %ebp
f011d0ac:	89 e5                	mov    %esp,%ebp
f011d0ae:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011d0b1:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011d0b5:	77 07                	ja     f011d0be <nearest_pow2_ceil+0x13>
f011d0b7:	b8 01 00 00 00       	mov    $0x1,%eax
f011d0bc:	eb 20                	jmp    f011d0de <nearest_pow2_ceil+0x33>
	int power = 2;
f011d0be:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011d0c5:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011d0c8:	eb 08                	jmp    f011d0d2 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011d0ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011d0cd:	01 c0                	add    %eax,%eax
f011d0cf:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011d0d2:	d1 6d 08             	shrl   0x8(%ebp)
f011d0d5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011d0d9:	75 ef                	jne    f011d0ca <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011d0db:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011d0de:	c9                   	leave  
f011d0df:	c3                   	ret    

f011d0e0 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011d0e0:	55                   	push   %ebp
f011d0e1:	89 e5                	mov    %esp,%ebp
f011d0e3:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011d0e6:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011d0ea:	77 07                	ja     f011d0f3 <log2_ceil+0x13>
f011d0ec:	b8 01 00 00 00       	mov    $0x1,%eax
f011d0f1:	eb 1b                	jmp    f011d10e <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011d0f3:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011d0fa:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011d0fd:	eb 03                	jmp    f011d102 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011d0ff:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011d102:	d1 6d 08             	shrl   0x8(%ebp)
f011d105:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011d109:	75 f4                	jne    f011d0ff <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011d10b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011d10e:	c9                   	leave  
f011d10f:	c3                   	ret    

f011d110 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011d110:	55                   	push   %ebp
f011d111:	89 e5                	mov    %esp,%ebp
f011d113:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011d116:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011d11d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d124:	eb 12                	jmp    f011d138 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011d126:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d129:	89 d0                	mov    %edx,%eax
f011d12b:	c1 e0 02             	shl    $0x2,%eax
f011d12e:	01 d0                	add    %edx,%eax
f011d130:	01 c0                	add    %eax,%eax
f011d132:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011d135:	ff 45 f0             	incl   -0x10(%ebp)
f011d138:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d13b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d13e:	7c e6                	jl     f011d126 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011d140:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011d143:	83 ec 04             	sub    $0x4,%esp
f011d146:	ff 75 f4             	pushl  -0xc(%ebp)
f011d149:	ff 75 08             	pushl  0x8(%ebp)
f011d14c:	50                   	push   %eax
f011d14d:	e8 2f fd ff ff       	call   f011ce81 <fix_scale>
f011d152:	83 c4 0c             	add    $0xc,%esp
f011d155:	83 ec 0c             	sub    $0xc,%esp
f011d158:	ff 75 dc             	pushl  -0x24(%ebp)
f011d15b:	e8 eb fc ff ff       	call   f011ce4b <fix_round>
f011d160:	83 c4 10             	add    $0x10,%esp
f011d163:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011d166:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d169:	99                   	cltd   
f011d16a:	f7 7d f4             	idivl  -0xc(%ebp)
f011d16d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011d170:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d173:	99                   	cltd   
f011d174:	f7 7d f4             	idivl  -0xc(%ebp)
f011d177:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011d17a:	83 ec 08             	sub    $0x8,%esp
f011d17d:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011d180:	50                   	push   %eax
f011d181:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d184:	e8 6a 1e 00 00       	call   f011eff3 <ltostr>
f011d189:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011d18c:	83 ec 08             	sub    $0x8,%esp
f011d18f:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011d192:	50                   	push   %eax
f011d193:	ff 75 e0             	pushl  -0x20(%ebp)
f011d196:	e8 58 1e 00 00       	call   f011eff3 <ltostr>
f011d19b:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011d19e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d1a1:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011d1a6:	f7 e9                	imul   %ecx
f011d1a8:	c1 fa 02             	sar    $0x2,%edx
f011d1ab:	89 c8                	mov    %ecx,%eax
f011d1ad:	c1 f8 1f             	sar    $0x1f,%eax
f011d1b0:	29 c2                	sub    %eax,%edx
f011d1b2:	89 d0                	mov    %edx,%eax
f011d1b4:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011d1b7:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011d1be:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011d1c5:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011d1cb:	eb 31                	jmp    f011d1fe <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011d1cd:	83 ec 04             	sub    $0x4,%esp
f011d1d0:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011d1d3:	50                   	push   %eax
f011d1d4:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011d1d7:	50                   	push   %eax
f011d1d8:	68 50 fa 12 f0       	push   $0xf012fa50
f011d1dd:	e8 ea 1e 00 00       	call   f011f0cc <strcconcat>
f011d1e2:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011d1e5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011d1e8:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011d1ed:	f7 e9                	imul   %ecx
f011d1ef:	c1 fa 02             	sar    $0x2,%edx
f011d1f2:	89 c8                	mov    %ecx,%eax
f011d1f4:	c1 f8 1f             	sar    $0x1f,%eax
f011d1f7:	29 c2                	sub    %eax,%edx
f011d1f9:	89 d0                	mov    %edx,%eax
f011d1fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011d1fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d201:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d204:	7c c7                	jl     f011d1cd <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011d206:	83 ec 04             	sub    $0x4,%esp
f011d209:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011d20c:	50                   	push   %eax
f011d20d:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011d210:	50                   	push   %eax
f011d211:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011d214:	50                   	push   %eax
f011d215:	e8 b2 1e 00 00       	call   f011f0cc <strcconcat>
f011d21a:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011d21d:	83 ec 04             	sub    $0x4,%esp
f011d220:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011d223:	50                   	push   %eax
f011d224:	68 52 fa 12 f0       	push   $0xf012fa52
f011d229:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011d22c:	50                   	push   %eax
f011d22d:	e8 9a 1e 00 00       	call   f011f0cc <strcconcat>
f011d232:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011d235:	83 ec 04             	sub    $0x4,%esp
f011d238:	ff 75 10             	pushl  0x10(%ebp)
f011d23b:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011d23e:	50                   	push   %eax
f011d23f:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011d242:	50                   	push   %eax
f011d243:	e8 84 1e 00 00       	call   f011f0cc <strcconcat>
f011d248:	83 c4 10             	add    $0x10,%esp

}
f011d24b:	90                   	nop
f011d24c:	c9                   	leave  
f011d24d:	c3                   	ret    

f011d24e <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011d24e:	55                   	push   %ebp
f011d24f:	89 e5                	mov    %esp,%ebp
f011d251:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011d257:	83 ec 0c             	sub    $0xc,%esp
f011d25a:	68 54 fa 12 f0       	push   $0xf012fa54
f011d25f:	e8 e9 18 00 00       	call   f011eb4d <strlen>
f011d264:	83 c4 10             	add    $0x10,%esp
f011d267:	83 ec 04             	sub    $0x4,%esp
f011d26a:	50                   	push   %eax
f011d26b:	68 54 fa 12 f0       	push   $0xf012fa54
f011d270:	ff 75 08             	pushl  0x8(%ebp)
f011d273:	e8 19 1a 00 00       	call   f011ec91 <strncmp>
f011d278:	83 c4 10             	add    $0x10,%esp
f011d27b:	85 c0                	test   %eax,%eax
f011d27d:	0f 85 8a 00 00 00    	jne    f011d30d <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011d283:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011d286:	50                   	push   %eax
f011d287:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011d28d:	50                   	push   %eax
f011d28e:	68 62 fa 12 f0       	push   $0xf012fa62
f011d293:	ff 75 08             	pushl  0x8(%ebp)
f011d296:	e8 c7 1e 00 00       	call   f011f162 <strsplit>
f011d29b:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011d29e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d2a4:	83 ec 04             	sub    $0x4,%esp
f011d2a7:	6a 0a                	push   $0xa
f011d2a9:	6a 00                	push   $0x0
f011d2ab:	50                   	push   %eax
f011d2ac:	e8 fc 1b 00 00       	call   f011eead <strtol>
f011d2b1:	83 c4 10             	add    $0x10,%esp
f011d2b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011d2b7:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011d2be:	83 ec 04             	sub    $0x4,%esp
f011d2c1:	6a 00                	push   $0x0
f011d2c3:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d2c6:	50                   	push   %eax
f011d2c7:	ff 75 e0             	pushl  -0x20(%ebp)
f011d2ca:	e8 8c d9 fe ff       	call   f010ac5b <envid2env>
f011d2cf:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011d2d2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d2d5:	8b 40 10             	mov    0x10(%eax),%eax
f011d2d8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011d2db:	74 19                	je     f011d2f6 <sys_utilities+0xa8>
f011d2dd:	68 64 fa 12 f0       	push   $0xf012fa64
f011d2e2:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011d2e7:	68 a4 00 00 00       	push   $0xa4
f011d2ec:	68 ef f9 12 f0       	push   $0xf012f9ef
f011d2f1:	e8 43 30 fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011d2f6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d2f9:	83 ec 08             	sub    $0x8,%esp
f011d2fc:	ff 75 0c             	pushl  0xc(%ebp)
f011d2ff:	50                   	push   %eax
f011d300:	e8 1f 93 fe ff       	call   f0106624 <env_set_nice>
f011d305:	83 c4 10             	add    $0x10,%esp
f011d308:	e9 12 04 00 00       	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011d30d:	83 ec 0c             	sub    $0xc,%esp
f011d310:	68 79 fa 12 f0       	push   $0xf012fa79
f011d315:	e8 33 18 00 00       	call   f011eb4d <strlen>
f011d31a:	83 c4 10             	add    $0x10,%esp
f011d31d:	83 ec 04             	sub    $0x4,%esp
f011d320:	50                   	push   %eax
f011d321:	68 79 fa 12 f0       	push   $0xf012fa79
f011d326:	ff 75 08             	pushl  0x8(%ebp)
f011d329:	e8 63 19 00 00       	call   f011ec91 <strncmp>
f011d32e:	83 c4 10             	add    $0x10,%esp
f011d331:	85 c0                	test   %eax,%eax
f011d333:	0f 85 a6 01 00 00    	jne    f011d4df <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011d339:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d33c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011d33f:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011d342:	50                   	push   %eax
f011d343:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011d349:	50                   	push   %eax
f011d34a:	68 62 fa 12 f0       	push   $0xf012fa62
f011d34f:	ff 75 08             	pushl  0x8(%ebp)
f011d352:	e8 0b 1e 00 00       	call   f011f162 <strsplit>
f011d357:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011d35a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d360:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011d363:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011d36a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011d371:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011d378:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d37b:	8b 00                	mov    (%eax),%eax
f011d37d:	85 c0                	test   %eax,%eax
f011d37f:	79 1c                	jns    f011d39d <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011d381:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011d388:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d38b:	8b 00                	mov    (%eax),%eax
f011d38d:	f7 d8                	neg    %eax
f011d38f:	89 c2                	mov    %eax,%edx
f011d391:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d394:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011d396:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011d39d:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011d3a4:	83 ec 0c             	sub    $0xc,%esp
f011d3a7:	68 c0 42 5f f0       	push   $0xf05f42c0
f011d3ac:	e8 db 17 ff ff       	call   f010eb8c <acquire_spinlock>
f011d3b1:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d3b4:	a1 4c 43 5f f0       	mov    0xf05f434c,%eax
f011d3b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d3bc:	a1 44 43 5f f0       	mov    0xf05f4344,%eax
f011d3c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011d3c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d3c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011d3ca:	eb 6c                	jmp    f011d438 <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011d3cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d3cf:	83 c0 20             	add    $0x20,%eax
f011d3d2:	83 ec 08             	sub    $0x8,%esp
f011d3d5:	ff 75 d8             	pushl  -0x28(%ebp)
f011d3d8:	50                   	push   %eax
f011d3d9:	e8 7b 18 00 00       	call   f011ec59 <strcmp>
f011d3de:	83 c4 10             	add    $0x10,%esp
f011d3e1:	85 c0                	test   %eax,%eax
f011d3e3:	75 46                	jne    f011d42b <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011d3e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d3e8:	8b 00                	mov    (%eax),%eax
f011d3ea:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d3ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d3f0:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011d3f2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d3f6:	74 14                	je     f011d40c <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011d3f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d3fb:	8b 40 10             	mov    0x10(%eax),%eax
f011d3fe:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d401:	7d 1d                	jge    f011d420 <sys_utilities+0x1d2>
					{
						success = 0;
f011d403:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011d40a:	eb 32                	jmp    f011d43e <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011d40c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d40f:	8b 40 10             	mov    0x10(%eax),%eax
f011d412:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d415:	7e 09                	jle    f011d420 <sys_utilities+0x1d2>
					{
						success = 0;
f011d417:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011d41e:	eb 1e                	jmp    f011d43e <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011d420:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d423:	8b 40 10             	mov    0x10(%eax),%eax
f011d426:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011d429:	eb 01                	jmp    f011d42c <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011d42b:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011d42c:	ff 4d e4             	decl   -0x1c(%ebp)
f011d42f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d432:	8b 40 0c             	mov    0xc(%eax),%eax
f011d435:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011d438:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d43c:	7f 8e                	jg     f011d3cc <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011d43e:	83 ec 0c             	sub    $0xc,%esp
f011d441:	68 c0 42 5f f0       	push   $0xf05f42c0
f011d446:	e8 c8 17 ff ff       	call   f010ec13 <release_spinlock>
f011d44b:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011d44e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d451:	8b 00                	mov    (%eax),%eax
f011d453:	85 c0                	test   %eax,%eax
f011d455:	75 06                	jne    f011d45d <sys_utilities+0x20f>
f011d457:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011d45b:	75 41                	jne    f011d49e <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011d45d:	83 ec 0c             	sub    $0xc,%esp
f011d460:	68 8c fa 12 f0       	push   $0xf012fa8c
f011d465:	e8 21 3b fe ff       	call   f0100f8b <cprintf>
f011d46a:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011d46d:	83 ec 08             	sub    $0x8,%esp
f011d470:	ff 75 d8             	pushl  -0x28(%ebp)
f011d473:	68 bc fa 12 f0       	push   $0xf012fabc
f011d478:	e8 0e 3b fe ff       	call   f0100f8b <cprintf>
f011d47d:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011d480:	83 ec 0c             	sub    $0xc,%esp
f011d483:	68 8c fa 12 f0       	push   $0xf012fa8c
f011d488:	e8 fe 3a fe ff       	call   f0100f8b <cprintf>
f011d48d:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011d490:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d493:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011d499:	e9 81 02 00 00       	jmp    f011d71f <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011d49e:	83 ec 0c             	sub    $0xc,%esp
f011d4a1:	68 dc fa 12 f0       	push   $0xf012fadc
f011d4a6:	e8 e0 3a fe ff       	call   f0100f8b <cprintf>
f011d4ab:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011d4ae:	83 ec 08             	sub    $0x8,%esp
f011d4b1:	ff 75 d8             	pushl  -0x28(%ebp)
f011d4b4:	68 14 fb 12 f0       	push   $0xf012fb14
f011d4b9:	e8 cd 3a fe ff       	call   f0100f8b <cprintf>
f011d4be:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011d4c1:	83 ec 0c             	sub    $0xc,%esp
f011d4c4:	68 dc fa 12 f0       	push   $0xf012fadc
f011d4c9:	e8 bd 3a fe ff       	call   f0100f8b <cprintf>
f011d4ce:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011d4d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d4d4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011d4da:	e9 40 02 00 00       	jmp    f011d71f <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011d4df:	83 ec 08             	sub    $0x8,%esp
f011d4e2:	68 37 fb 12 f0       	push   $0xf012fb37
f011d4e7:	ff 75 08             	pushl  0x8(%ebp)
f011d4ea:	e8 6a 17 00 00       	call   f011ec59 <strcmp>
f011d4ef:	83 c4 10             	add    $0x10,%esp
f011d4f2:	85 c0                	test   %eax,%eax
f011d4f4:	75 77                	jne    f011d56d <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011d4f6:	a1 e0 cd 17 f0       	mov    0xf017cde0,%eax
f011d4fb:	85 c0                	test   %eax,%eax
f011d4fd:	74 34                	je     f011d533 <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011d4ff:	c7 05 e0 cd 17 f0 00 	movl   $0x0,0xf017cde0
f011d506:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011d509:	83 ec 08             	sub    $0x8,%esp
f011d50c:	68 41 fb 12 f0       	push   $0xf012fb41
f011d511:	68 80 72 61 f0       	push   $0xf0617280
f011d516:	e8 31 1a ff ff       	call   f010ef4c <init_channel>
f011d51b:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011d51e:	83 ec 08             	sub    $0x8,%esp
f011d521:	68 4e fb 12 f0       	push   $0xf012fb4e
f011d526:	68 00 74 61 f0       	push   $0xf0617400
f011d52b:	e8 2b 16 ff ff       	call   f010eb5b <init_spinlock>
f011d530:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011d533:	83 ec 0c             	sub    $0xc,%esp
f011d536:	68 00 74 61 f0       	push   $0xf0617400
f011d53b:	e8 4c 16 ff ff       	call   f010eb8c <acquire_spinlock>
f011d540:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011d543:	83 ec 08             	sub    $0x8,%esp
f011d546:	68 00 74 61 f0       	push   $0xf0617400
f011d54b:	68 80 72 61 f0       	push   $0xf0617280
f011d550:	e8 24 1a ff ff       	call   f010ef79 <sleep>
f011d555:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011d558:	83 ec 0c             	sub    $0xc,%esp
f011d55b:	68 00 74 61 f0       	push   $0xf0617400
f011d560:	e8 ae 16 ff ff       	call   f010ec13 <release_spinlock>
f011d565:	83 c4 10             	add    $0x10,%esp
f011d568:	e9 b2 01 00 00       	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011d56d:	83 ec 08             	sub    $0x8,%esp
f011d570:	68 60 fb 12 f0       	push   $0xf012fb60
f011d575:	ff 75 08             	pushl  0x8(%ebp)
f011d578:	e8 dc 16 00 00       	call   f011ec59 <strcmp>
f011d57d:	83 c4 10             	add    $0x10,%esp
f011d580:	85 c0                	test   %eax,%eax
f011d582:	75 15                	jne    f011d599 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011d584:	83 ec 0c             	sub    $0xc,%esp
f011d587:	68 80 72 61 f0       	push   $0xf0617280
f011d58c:	e8 55 1a ff ff       	call   f010efe6 <wakeup_one>
f011d591:	83 c4 10             	add    $0x10,%esp
f011d594:	e9 86 01 00 00       	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011d599:	83 ec 08             	sub    $0x8,%esp
f011d59c:	68 6e fb 12 f0       	push   $0xf012fb6e
f011d5a1:	ff 75 08             	pushl  0x8(%ebp)
f011d5a4:	e8 b0 16 00 00       	call   f011ec59 <strcmp>
f011d5a9:	83 c4 10             	add    $0x10,%esp
f011d5ac:	85 c0                	test   %eax,%eax
f011d5ae:	75 15                	jne    f011d5c5 <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011d5b0:	83 ec 0c             	sub    $0xc,%esp
f011d5b3:	68 80 72 61 f0       	push   $0xf0617280
f011d5b8:	e8 ad 1a ff ff       	call   f010f06a <wakeup_all>
f011d5bd:	83 c4 10             	add    $0x10,%esp
f011d5c0:	e9 5a 01 00 00       	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011d5c5:	83 ec 08             	sub    $0x8,%esp
f011d5c8:	68 7c fb 12 f0       	push   $0xf012fb7c
f011d5cd:	ff 75 08             	pushl  0x8(%ebp)
f011d5d0:	e8 84 16 00 00       	call   f011ec59 <strcmp>
f011d5d5:	83 c4 10             	add    $0x10,%esp
f011d5d8:	85 c0                	test   %eax,%eax
f011d5da:	75 17                	jne    f011d5f3 <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011d5dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d5df:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011d5e2:	a1 8c 72 61 f0       	mov    0xf061728c,%eax
f011d5e7:	89 c2                	mov    %eax,%edx
f011d5e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d5ec:	89 10                	mov    %edx,(%eax)
f011d5ee:	e9 2c 01 00 00       	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011d5f3:	83 ec 08             	sub    $0x8,%esp
f011d5f6:	68 91 fb 12 f0       	push   $0xf012fb91
f011d5fb:	ff 75 08             	pushl  0x8(%ebp)
f011d5fe:	e8 56 16 00 00       	call   f011ec59 <strcmp>
f011d603:	83 c4 10             	add    $0x10,%esp
f011d606:	85 c0                	test   %eax,%eax
f011d608:	75 1a                	jne    f011d624 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011d60a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d60d:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011d610:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f011d615:	8b 40 0c             	mov    0xc(%eax),%eax
f011d618:	89 c2                	mov    %eax,%edx
f011d61a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d61d:	89 10                	mov    %edx,(%eax)
f011d61f:	e9 fb 00 00 00       	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011d624:	83 ec 08             	sub    $0x8,%esp
f011d627:	68 a7 fb 12 f0       	push   $0xf012fba7
f011d62c:	ff 75 08             	pushl  0x8(%ebp)
f011d62f:	e8 25 16 00 00       	call   f011ec59 <strcmp>
f011d634:	83 c4 10             	add    $0x10,%esp
f011d637:	85 c0                	test   %eax,%eax
f011d639:	75 3d                	jne    f011d678 <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011d63b:	a1 e4 cd 17 f0       	mov    0xf017cde4,%eax
f011d640:	85 c0                	test   %eax,%eax
f011d642:	74 1f                	je     f011d663 <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011d644:	c7 05 e4 cd 17 f0 00 	movl   $0x0,0xf017cde4
f011d64b:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011d64e:	83 ec 08             	sub    $0x8,%esp
f011d651:	68 bc fb 12 f0       	push   $0xf012fbbc
f011d656:	68 e0 72 61 f0       	push   $0xf06172e0
f011d65b:	e8 86 17 ff ff       	call   f010ede6 <init_sleeplock>
f011d660:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011d663:	83 ec 0c             	sub    $0xc,%esp
f011d666:	68 e0 72 61 f0       	push   $0xf06172e0
f011d66b:	e8 3a 18 ff ff       	call   f010eeaa <acquire_sleeplock>
f011d670:	83 c4 10             	add    $0x10,%esp
f011d673:	e9 a7 00 00 00       	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011d678:	83 ec 08             	sub    $0x8,%esp
f011d67b:	68 cc fb 12 f0       	push   $0xf012fbcc
f011d680:	ff 75 08             	pushl  0x8(%ebp)
f011d683:	e8 d1 15 00 00       	call   f011ec59 <strcmp>
f011d688:	83 c4 10             	add    $0x10,%esp
f011d68b:	85 c0                	test   %eax,%eax
f011d68d:	75 12                	jne    f011d6a1 <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011d68f:	83 ec 0c             	sub    $0xc,%esp
f011d692:	68 e0 72 61 f0       	push   $0xf06172e0
f011d697:	e8 68 18 ff ff       	call   f010ef04 <release_sleeplock>
f011d69c:	83 c4 10             	add    $0x10,%esp
f011d69f:	eb 7e                	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011d6a1:	83 ec 08             	sub    $0x8,%esp
f011d6a4:	68 e1 fb 12 f0       	push   $0xf012fbe1
f011d6a9:	ff 75 08             	pushl  0x8(%ebp)
f011d6ac:	e8 a8 15 00 00       	call   f011ec59 <strcmp>
f011d6b1:	83 c4 10             	add    $0x10,%esp
f011d6b4:	85 c0                	test   %eax,%eax
f011d6b6:	75 14                	jne    f011d6cc <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011d6b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d6bb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011d6be:	a1 60 73 61 f0       	mov    0xf0617360,%eax
f011d6c3:	89 c2                	mov    %eax,%edx
f011d6c5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d6c8:	89 10                	mov    %edx,(%eax)
f011d6ca:	eb 53                	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011d6cc:	83 ec 08             	sub    $0x8,%esp
f011d6cf:	68 f6 fb 12 f0       	push   $0xf012fbf6
f011d6d4:	ff 75 08             	pushl  0x8(%ebp)
f011d6d7:	e8 7d 15 00 00       	call   f011ec59 <strcmp>
f011d6dc:	83 c4 10             	add    $0x10,%esp
f011d6df:	85 c0                	test   %eax,%eax
f011d6e1:	75 13                	jne    f011d6f6 <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011d6e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d6e6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011d6e9:	8b 15 e0 72 61 f0    	mov    0xf06172e0,%edx
f011d6ef:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011d6f2:	89 10                	mov    %edx,(%eax)
f011d6f4:	eb 29                	jmp    f011d71f <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011d6f6:	83 ec 08             	sub    $0x8,%esp
f011d6f9:	68 07 fc 12 f0       	push   $0xf012fc07
f011d6fe:	ff 75 08             	pushl  0x8(%ebp)
f011d701:	e8 53 15 00 00       	call   f011ec59 <strcmp>
f011d706:	83 c4 10             	add    $0x10,%esp
f011d709:	85 c0                	test   %eax,%eax
f011d70b:	75 12                	jne    f011d71f <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011d70d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d710:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011d713:	a1 e4 73 61 f0       	mov    0xf06173e4,%eax
f011d718:	89 c2                	mov    %eax,%edx
f011d71a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d71d:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011d71f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011d723:	79 5b                	jns    f011d780 <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011d725:	83 ec 08             	sub    $0x8,%esp
f011d728:	68 18 fc 12 f0       	push   $0xf012fc18
f011d72d:	ff 75 08             	pushl  0x8(%ebp)
f011d730:	e8 24 15 00 00       	call   f011ec59 <strcmp>
f011d735:	83 c4 10             	add    $0x10,%esp
f011d738:	85 c0                	test   %eax,%eax
f011d73a:	75 44                	jne    f011d780 <sys_utilities+0x532>
		{
			switch (value)
f011d73c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d73f:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011d742:	74 07                	je     f011d74b <sys_utilities+0x4fd>
f011d744:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011d747:	74 19                	je     f011d762 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011d749:	eb 35                	jmp    f011d780 <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011d74b:	83 ec 0c             	sub    $0xc,%esp
f011d74e:	68 28 fc 12 f0       	push   $0xf012fc28
f011d753:	e8 33 38 fe ff       	call   f0100f8b <cprintf>
f011d758:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011d75b:	e8 83 0f ff ff       	call   f010e6e3 <setPageReplacmentAlgorithmFIFO>
				break;
f011d760:	eb 1e                	jmp    f011d780 <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011d762:	83 ec 0c             	sub    $0xc,%esp
f011d765:	68 98 fc 12 f0       	push   $0xf012fc98
f011d76a:	e8 1c 38 fe ff       	call   f0100f8b <cprintf>
f011d76f:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011d772:	83 ec 0c             	sub    $0xc,%esp
f011d775:	6a 02                	push   $0x2
f011d777:	e8 24 0f ff ff       	call   f010e6a0 <setPageReplacmentAlgorithmLRU>
f011d77c:	83 c4 10             	add    $0x10,%esp
				break;
f011d77f:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011d780:	90                   	nop
f011d781:	c9                   	leave  
f011d782:	c3                   	ret    

f011d783 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011d783:	55                   	push   %ebp
f011d784:	89 e5                	mov    %esp,%ebp
f011d786:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011d789:	8b 45 08             	mov    0x8(%ebp),%eax
f011d78c:	8b 00                	mov    (%eax),%eax
f011d78e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011d791:	8b 45 08             	mov    0x8(%ebp),%eax
f011d794:	8b 00                	mov    (%eax),%eax
f011d796:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011d799:	eb 52                	jmp    f011d7ed <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011d79b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d79e:	8b 00                	mov    (%eax),%eax
f011d7a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011d7a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d7a6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d7a9:	75 12                	jne    f011d7bd <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011d7ab:	83 ec 0c             	sub    $0xc,%esp
f011d7ae:	68 0c fd 12 f0       	push   $0xf012fd0c
f011d7b3:	e8 d3 37 fe ff       	call   f0100f8b <cprintf>
f011d7b8:	83 c4 10             	add    $0x10,%esp
			break;
f011d7bb:	eb 3f                	jmp    f011d7fc <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011d7bd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d7c1:	74 38                	je     f011d7fb <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011d7c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d7c6:	8b 00                	mov    (%eax),%eax
f011d7c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011d7cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d7ce:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d7d1:	75 12                	jne    f011d7e5 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011d7d3:	83 ec 0c             	sub    $0xc,%esp
f011d7d6:	68 28 fd 12 f0       	push   $0xf012fd28
f011d7db:	e8 ab 37 fe ff       	call   f0100f8b <cprintf>
f011d7e0:	83 c4 10             	add    $0x10,%esp
			break;
f011d7e3:	eb 17                	jmp    f011d7fc <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011d7e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d7e8:	8b 00                	mov    (%eax),%eax
f011d7ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011d7ed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d7f1:	74 09                	je     f011d7fc <detect_loop_in_FrameInfo_list+0x79>
f011d7f3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d7f7:	75 a2                	jne    f011d79b <detect_loop_in_FrameInfo_list+0x18>
f011d7f9:	eb 01                	jmp    f011d7fc <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011d7fb:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011d7fc:	83 ec 0c             	sub    $0xc,%esp
f011d7ff:	68 3f fd 12 f0       	push   $0xf012fd3f
f011d804:	e8 82 37 fe ff       	call   f0100f8b <cprintf>
f011d809:	83 c4 10             	add    $0x10,%esp
}
f011d80c:	90                   	nop
f011d80d:	c9                   	leave  
f011d80e:	c3                   	ret    

f011d80f <scarce_memory>:

void scarce_memory()
{
f011d80f:	55                   	push   %ebp
f011d810:	89 e5                	mov    %esp,%ebp
f011d812:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011d815:	a1 90 44 5f f0       	mov    0xf05f4490,%eax
f011d81a:	ba 64 00 00 00       	mov    $0x64,%edx
f011d81f:	29 c2                	sub    %eax,%edx
f011d821:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f011d826:	0f af c2             	imul   %edx,%eax
f011d829:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011d82e:	f7 e2                	mul    %edx
f011d830:	89 d0                	mov    %edx,%eax
f011d832:	c1 e8 05             	shr    $0x5,%eax
f011d835:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011d838:	a1 90 44 5f f0       	mov    0xf05f4490,%eax
f011d83d:	ba 64 00 00 00       	mov    $0x64,%edx
f011d842:	29 c2                	sub    %eax,%edx
f011d844:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f011d849:	89 d1                	mov    %edx,%ecx
f011d84b:	0f af c8             	imul   %eax,%ecx
f011d84e:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011d853:	f7 e1                	mul    %ecx
f011d855:	c1 ea 05             	shr    $0x5,%edx
f011d858:	89 d0                	mov    %edx,%eax
f011d85a:	c1 e0 02             	shl    $0x2,%eax
f011d85d:	01 d0                	add    %edx,%eax
f011d85f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011d866:	01 d0                	add    %edx,%eax
f011d868:	c1 e0 02             	shl    $0x2,%eax
f011d86b:	29 c1                	sub    %eax,%ecx
f011d86d:	89 ca                	mov    %ecx,%edx
f011d86f:	85 d2                	test   %edx,%edx
f011d871:	74 03                	je     f011d876 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011d873:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011d876:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011d87d:	83 ec 0c             	sub    $0xc,%esp
f011d880:	68 80 43 5f f0       	push   $0xf05f4380
f011d885:	e8 02 13 ff ff       	call   f010eb8c <acquire_spinlock>
f011d88a:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011d88d:	a1 6c 43 5f f0       	mov    0xf05f436c,%eax
f011d892:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011d895:	8b 15 58 45 5f f0    	mov    0xf05f4558,%edx
f011d89b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d89e:	29 c2                	sub    %eax,%edx
f011d8a0:	89 d0                	mov    %edx,%eax
f011d8a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011d8a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d8a8:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011d8ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011d8ae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011d8b5:	eb 12                	jmp    f011d8c9 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011d8b7:	83 ec 0c             	sub    $0xc,%esp
f011d8ba:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011d8bd:	50                   	push   %eax
f011d8be:	e8 84 a8 fe ff       	call   f0108147 <allocate_frame>
f011d8c3:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011d8c6:	ff 45 f0             	incl   -0x10(%ebp)
f011d8c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d8cc:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d8cf:	76 e6                	jbe    f011d8b7 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011d8d1:	83 ec 0c             	sub    $0xc,%esp
f011d8d4:	68 80 43 5f f0       	push   $0xf05f4380
f011d8d9:	e8 35 13 ff ff       	call   f010ec13 <release_spinlock>
f011d8de:	83 c4 10             	add    $0x10,%esp

}
f011d8e1:	90                   	nop
f011d8e2:	c9                   	leave  
f011d8e3:	c3                   	ret    

f011d8e4 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011d8e4:	55                   	push   %ebp
f011d8e5:	89 e5                	mov    %esp,%ebp
f011d8e7:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011d8ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011d8f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011d8f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011d8ff:	e8 07 d3 fe ff       	call   f010ac0b <get_cpu_proc>
f011d904:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011d907:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011d90b:	75 19                	jne    f011d926 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011d90d:	68 59 fd 12 f0       	push   $0xf012fd59
f011d912:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011d917:	68 79 01 00 00       	push   $0x179
f011d91c:	68 ef f9 12 f0       	push   $0xf012f9ef
f011d921:	e8 13 2a fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011d926:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011d92a:	0f 85 d6 01 00 00    	jne    f011db06 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011d930:	83 ec 0c             	sub    $0xc,%esp
f011d933:	68 c0 42 5f f0       	push   $0xf05f42c0
f011d938:	e8 4f 12 ff ff       	call   f010eb8c <acquire_spinlock>
f011d93d:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011d940:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011d947:	e9 d2 00 00 00       	jmp    f011da1e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011d94c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011d953:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f011d958:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011d95b:	c1 e2 04             	shl    $0x4,%edx
f011d95e:	01 d0                	add    %edx,%eax
f011d960:	8b 00                	mov    (%eax),%eax
f011d962:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011d965:	eb 7c                	jmp    f011d9e3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011d967:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d96a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011d970:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011d973:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d976:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011d97c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d97f:	0f af c2             	imul   %edx,%eax
f011d982:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011d987:	f7 e2                	mul    %edx
f011d989:	89 d0                	mov    %edx,%eax
f011d98b:	c1 e8 05             	shr    $0x5,%eax
f011d98e:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011d991:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d994:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011d99a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d99d:	89 d1                	mov    %edx,%ecx
f011d99f:	0f af c8             	imul   %eax,%ecx
f011d9a2:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011d9a7:	f7 e1                	mul    %ecx
f011d9a9:	c1 ea 05             	shr    $0x5,%edx
f011d9ac:	89 d0                	mov    %edx,%eax
f011d9ae:	c1 e0 02             	shl    $0x2,%eax
f011d9b1:	01 d0                	add    %edx,%eax
f011d9b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011d9ba:	01 d0                	add    %edx,%eax
f011d9bc:	c1 e0 02             	shl    $0x2,%eax
f011d9bf:	29 c1                	sub    %eax,%ecx
f011d9c1:	89 ca                	mov    %ecx,%edx
f011d9c3:	85 d2                	test   %edx,%edx
f011d9c5:	74 03                	je     f011d9ca <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011d9c7:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011d9ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d9cd:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011d9d0:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f011d9d5:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011d9d8:	c1 e2 04             	shl    $0x4,%edx
f011d9db:	01 d0                	add    %edx,%eax
f011d9dd:	8b 40 08             	mov    0x8(%eax),%eax
f011d9e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011d9e3:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f011d9e8:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011d9eb:	c1 e2 04             	shl    $0x4,%edx
f011d9ee:	01 d0                	add    %edx,%eax
f011d9f0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d9f4:	74 08                	je     f011d9fe <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011d9f6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011d9f9:	8b 52 08             	mov    0x8(%edx),%edx
f011d9fc:	eb 05                	jmp    f011da03 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011d9fe:	ba 00 00 00 00       	mov    $0x0,%edx
f011da03:	89 50 08             	mov    %edx,0x8(%eax)
f011da06:	8b 40 08             	mov    0x8(%eax),%eax
f011da09:	85 c0                	test   %eax,%eax
f011da0b:	0f 85 56 ff ff ff    	jne    f011d967 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011da11:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011da15:	0f 85 4c ff ff ff    	jne    f011d967 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011da1b:	ff 45 e8             	incl   -0x18(%ebp)
f011da1e:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f011da23:	0f b6 c0             	movzbl %al,%eax
f011da26:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011da29:	0f 8f 1d ff ff ff    	jg     f011d94c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011da2f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011da36:	a1 40 43 5f f0       	mov    0xf05f4340,%eax
f011da3b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011da3e:	eb 1a                	jmp    f011da5a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011da40:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011da43:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011da49:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011da4c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011da4f:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011da52:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f011da57:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011da5a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011da5e:	74 08                	je     f011da68 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011da60:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011da63:	8b 40 08             	mov    0x8(%eax),%eax
f011da66:	eb 05                	jmp    f011da6d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011da68:	b8 00 00 00 00       	mov    $0x0,%eax
f011da6d:	a3 48 43 5f f0       	mov    %eax,0xf05f4348
f011da72:	a1 48 43 5f f0       	mov    0xf05f4348,%eax
f011da77:	85 c0                	test   %eax,%eax
f011da79:	75 c5                	jne    f011da40 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011da7b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011da7f:	75 bf                	jne    f011da40 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011da81:	83 ec 0c             	sub    $0xc,%esp
f011da84:	68 c0 42 5f f0       	push   $0xf05f42c0
f011da89:	e8 85 11 ff ff       	call   f010ec13 <release_spinlock>
f011da8e:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011da91:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011da95:	0f 84 d4 00 00 00    	je     f011db6f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011da9b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011da9e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011daa4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011daa7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011daaa:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011dab0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011dab3:	0f af c2             	imul   %edx,%eax
f011dab6:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011dabb:	f7 e2                	mul    %edx
f011dabd:	89 d0                	mov    %edx,%eax
f011dabf:	c1 e8 05             	shr    $0x5,%eax
f011dac2:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011dac5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dac8:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011dace:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011dad1:	89 d1                	mov    %edx,%ecx
f011dad3:	0f af c8             	imul   %eax,%ecx
f011dad6:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011dadb:	f7 e1                	mul    %ecx
f011dadd:	c1 ea 05             	shr    $0x5,%edx
f011dae0:	89 d0                	mov    %edx,%eax
f011dae2:	c1 e0 02             	shl    $0x2,%eax
f011dae5:	01 d0                	add    %edx,%eax
f011dae7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011daee:	01 d0                	add    %edx,%eax
f011daf0:	c1 e0 02             	shl    $0x2,%eax
f011daf3:	29 c1                	sub    %eax,%ecx
f011daf5:	89 ca                	mov    %ecx,%edx
f011daf7:	85 d2                	test   %edx,%edx
f011daf9:	74 03                	je     f011dafe <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011dafb:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011dafe:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011db01:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011db04:	eb 69                	jmp    f011db6f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011db06:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011db09:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011db0f:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011db12:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011db15:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011db1b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011db1e:	0f af c2             	imul   %edx,%eax
f011db21:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011db26:	f7 e2                	mul    %edx
f011db28:	89 d0                	mov    %edx,%eax
f011db2a:	c1 e8 05             	shr    $0x5,%eax
f011db2d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011db30:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011db33:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011db39:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011db3c:	89 d1                	mov    %edx,%ecx
f011db3e:	0f af c8             	imul   %eax,%ecx
f011db41:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011db46:	f7 e1                	mul    %ecx
f011db48:	c1 ea 05             	shr    $0x5,%edx
f011db4b:	89 d0                	mov    %edx,%eax
f011db4d:	c1 e0 02             	shl    $0x2,%eax
f011db50:	01 d0                	add    %edx,%eax
f011db52:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011db59:	01 d0                	add    %edx,%eax
f011db5b:	c1 e0 02             	shl    $0x2,%eax
f011db5e:	29 c1                	sub    %eax,%ecx
f011db60:	89 ca                	mov    %ecx,%edx
f011db62:	85 d2                	test   %edx,%edx
f011db64:	74 03                	je     f011db69 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011db66:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011db69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011db6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011db6f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011db72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011db75:	01 c2                	add    %eax,%edx
f011db77:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011db7a:	01 d0                	add    %edx,%eax
}
f011db7c:	c9                   	leave  
f011db7d:	c3                   	ret    

f011db7e <schenv>:


void schenv()
{
f011db7e:	55                   	push   %ebp
f011db7f:	89 e5                	mov    %esp,%ebp
f011db81:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011db84:	c6 05 a0 4a 5f f0 00 	movb   $0x0,0xf05f4aa0
	__ne = NULL;
f011db8b:	c7 05 ac 47 5f f0 00 	movl   $0x0,0xf05f47ac
f011db92:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011db95:	83 ec 0c             	sub    $0xc,%esp
f011db98:	68 c0 42 5f f0       	push   $0xf05f42c0
f011db9d:	e8 ea 0f ff ff       	call   f010eb8c <acquire_spinlock>
f011dba2:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011dba5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011dbac:	eb 3f                	jmp    f011dbed <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011dbae:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f011dbb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dbb6:	c1 e2 04             	shl    $0x4,%edx
f011dbb9:	01 d0                	add    %edx,%eax
f011dbbb:	83 ec 0c             	sub    $0xc,%esp
f011dbbe:	50                   	push   %eax
f011dbbf:	e8 6c 73 fe ff       	call   f0104f30 <queue_size>
f011dbc4:	83 c4 10             	add    $0x10,%esp
f011dbc7:	85 c0                	test   %eax,%eax
f011dbc9:	74 1f                	je     f011dbea <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011dbcb:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f011dbd0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dbd3:	c1 e2 04             	shl    $0x4,%edx
f011dbd6:	01 d0                	add    %edx,%eax
f011dbd8:	8b 40 04             	mov    0x4(%eax),%eax
f011dbdb:	a3 ac 47 5f f0       	mov    %eax,0xf05f47ac
				__nl = i;
f011dbe0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dbe3:	a2 a0 4a 5f f0       	mov    %al,0xf05f4aa0
				break;
f011dbe8:	eb 10                	jmp    f011dbfa <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011dbea:	ff 45 f4             	incl   -0xc(%ebp)
f011dbed:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f011dbf2:	0f b6 c0             	movzbl %al,%eax
f011dbf5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011dbf8:	7f b4                	jg     f011dbae <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011dbfa:	83 ec 0c             	sub    $0xc,%esp
f011dbfd:	68 c0 42 5f f0       	push   $0xf05f42c0
f011dc02:	e8 0c 10 ff ff       	call   f010ec13 <release_spinlock>
f011dc07:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011dc0a:	e8 fc cf fe ff       	call   f010ac0b <get_cpu_proc>
f011dc0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011dc12:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011dc16:	0f 84 82 00 00 00    	je     f011dc9e <schenv+0x120>
	{
		if (__ne != NULL)
f011dc1c:	a1 ac 47 5f f0       	mov    0xf05f47ac,%eax
f011dc21:	85 c0                	test   %eax,%eax
f011dc23:	74 49                	je     f011dc6e <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011dc25:	a0 a1 42 5f f0       	mov    0xf05f42a1,%al
f011dc2a:	0f b6 c0             	movzbl %al,%eax
f011dc2d:	8d 50 01             	lea    0x1(%eax),%edx
f011dc30:	a0 a0 4a 5f f0       	mov    0xf05f4aa0,%al
f011dc35:	0f b6 c0             	movzbl %al,%eax
f011dc38:	39 c2                	cmp    %eax,%edx
f011dc3a:	7d 62                	jge    f011dc9e <schenv+0x120>
			{
				__ne = cur_env;
f011dc3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dc3f:	a3 ac 47 5f f0       	mov    %eax,0xf05f47ac
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011dc44:	a0 a1 42 5f f0       	mov    0xf05f42a1,%al
f011dc49:	0f b6 c0             	movzbl %al,%eax
f011dc4c:	8a 15 04 4a 5f f0    	mov    0xf05f4a04,%dl
f011dc52:	0f b6 d2             	movzbl %dl,%edx
f011dc55:	4a                   	dec    %edx
f011dc56:	39 d0                	cmp    %edx,%eax
f011dc58:	7d 08                	jge    f011dc62 <schenv+0xe4>
f011dc5a:	a0 a1 42 5f f0       	mov    0xf05f42a1,%al
f011dc5f:	40                   	inc    %eax
f011dc60:	eb 05                	jmp    f011dc67 <schenv+0xe9>
f011dc62:	a0 a1 42 5f f0       	mov    0xf05f42a1,%al
f011dc67:	a2 a0 4a 5f f0       	mov    %al,0xf05f4aa0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011dc6c:	eb 30                	jmp    f011dc9e <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011dc6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dc71:	a3 ac 47 5f f0       	mov    %eax,0xf05f47ac
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011dc76:	a0 a1 42 5f f0       	mov    0xf05f42a1,%al
f011dc7b:	0f b6 c0             	movzbl %al,%eax
f011dc7e:	8a 15 04 4a 5f f0    	mov    0xf05f4a04,%dl
f011dc84:	0f b6 d2             	movzbl %dl,%edx
f011dc87:	4a                   	dec    %edx
f011dc88:	39 d0                	cmp    %edx,%eax
f011dc8a:	7d 08                	jge    f011dc94 <schenv+0x116>
f011dc8c:	a0 a1 42 5f f0       	mov    0xf05f42a1,%al
f011dc91:	40                   	inc    %eax
f011dc92:	eb 05                	jmp    f011dc99 <schenv+0x11b>
f011dc94:	a0 a1 42 5f f0       	mov    0xf05f42a1,%al
f011dc99:	a2 a0 4a 5f f0       	mov    %al,0xf05f4aa0
		}
	}
}
f011dc9e:	90                   	nop
f011dc9f:	c9                   	leave  
f011dca0:	c3                   	ret    

f011dca1 <chksch>:

void chksch(uint8 onoff)
{
f011dca1:	55                   	push   %ebp
f011dca2:	89 e5                	mov    %esp,%ebp
f011dca4:	83 ec 18             	sub    $0x18,%esp
f011dca7:	8b 45 08             	mov    0x8(%ebp),%eax
f011dcaa:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011dcad:	e8 fe 89 fe ff       	call   f01066b0 <isSchedMethodBSD>
f011dcb2:	85 c0                	test   %eax,%eax
f011dcb4:	74 48                	je     f011dcfe <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011dcb6:	e8 a3 89 fe ff       	call   f010665e <get_load_average>
f011dcbb:	a3 28 4a 5f f0       	mov    %eax,0xf05f4a28
f011dcc0:	a1 28 4a 5f f0       	mov    0xf05f4a28,%eax
f011dcc5:	a3 5c 45 5f f0       	mov    %eax,0xf05f455c
		acquire_spinlock(&ProcessQueues.qlock);
f011dcca:	83 ec 0c             	sub    $0xc,%esp
f011dccd:	68 c0 42 5f f0       	push   $0xf05f42c0
f011dcd2:	e8 b5 0e ff ff       	call   f010eb8c <acquire_spinlock>
f011dcd7:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011dcda:	a1 4c 43 5f f0       	mov    0xf05f434c,%eax
f011dcdf:	a3 00 44 5f f0       	mov    %eax,0xf05f4400
		}
		release_spinlock(&ProcessQueues.qlock);
f011dce4:	83 ec 0c             	sub    $0xc,%esp
f011dce7:	68 c0 42 5f f0       	push   $0xf05f42c0
f011dcec:	e8 22 0f ff ff       	call   f010ec13 <release_spinlock>
f011dcf1:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011dcf4:	c7 05 bc 47 5f f0 01 	movl   $0x1,0xf05f47bc
f011dcfb:	00 00 00 
	}
	__chkstatus = onoff;
f011dcfe:	8a 45 f4             	mov    -0xc(%ebp),%al
f011dd01:	a2 a8 47 5f f0       	mov    %al,0xf05f47a8
}
f011dd06:	90                   	nop
f011dd07:	c9                   	leave  
f011dd08:	c3                   	ret    

f011dd09 <chk1>:
void chk1()
{
f011dd09:	55                   	push   %ebp
f011dd0a:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011dd0c:	90                   	nop
f011dd0d:	5d                   	pop    %ebp
f011dd0e:	c3                   	ret    

f011dd0f <chk2>:
void chk2(struct Env* __se)
{
f011dd0f:	55                   	push   %ebp
f011dd10:	89 e5                	mov    %esp,%ebp
f011dd12:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011dd15:	a0 a8 47 5f f0       	mov    0xf05f47a8,%al
f011dd1a:	84 c0                	test   %al,%al
f011dd1c:	0f 84 59 03 00 00    	je     f011e07b <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011dd22:	e8 89 89 fe ff       	call   f01066b0 <isSchedMethodBSD>
f011dd27:	85 c0                	test   %eax,%eax
f011dd29:	0f 84 4d 03 00 00    	je     f011e07c <chk2+0x36d>
	{
		__nla = get_load_average();
f011dd2f:	e8 2a 89 fe ff       	call   f010665e <get_load_average>
f011dd34:	a3 94 44 5f f0       	mov    %eax,0xf05f4494
		acquire_spinlock(&ProcessQueues.qlock);
f011dd39:	83 ec 0c             	sub    $0xc,%esp
f011dd3c:	68 c0 42 5f f0       	push   $0xf05f42c0
f011dd41:	e8 46 0e ff ff       	call   f010eb8c <acquire_spinlock>
f011dd46:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011dd49:	a1 4c 43 5f f0       	mov    0xf05f434c,%eax
f011dd4e:	a3 b0 47 5f f0       	mov    %eax,0xf05f47b0
		}
		release_spinlock(&ProcessQueues.qlock);
f011dd53:	83 ec 0c             	sub    $0xc,%esp
f011dd56:	68 c0 42 5f f0       	push   $0xf05f42c0
f011dd5b:	e8 b3 0e ff ff       	call   f010ec13 <release_spinlock>
f011dd60:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011dd63:	a1 bc 47 5f f0       	mov    0xf05f47bc,%eax
f011dd68:	85 c0                	test   %eax,%eax
f011dd6a:	74 72                	je     f011ddde <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011dd6c:	83 ec 0c             	sub    $0xc,%esp
f011dd6f:	68 c0 42 5f f0       	push   $0xf05f42c0
f011dd74:	e8 13 0e ff ff       	call   f010eb8c <acquire_spinlock>
f011dd79:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011dd7c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011dd80:	0f 95 c0             	setne  %al
f011dd83:	0f b6 c0             	movzbl %al,%eax
f011dd86:	a3 74 49 5f f0       	mov    %eax,0xf05f4974
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011dd8b:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f011dd90:	0f b6 c0             	movzbl %al,%eax
f011dd93:	48                   	dec    %eax
f011dd94:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011dd97:	eb 20                	jmp    f011ddb9 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011dd99:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f011dd9e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dda1:	c1 e2 04             	shl    $0x4,%edx
f011dda4:	01 d0                	add    %edx,%eax
f011dda6:	8b 40 0c             	mov    0xc(%eax),%eax
f011dda9:	8b 15 74 49 5f f0    	mov    0xf05f4974,%edx
f011ddaf:	01 d0                	add    %edx,%eax
f011ddb1:	a3 74 49 5f f0       	mov    %eax,0xf05f4974
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ddb6:	ff 4d f4             	decl   -0xc(%ebp)
f011ddb9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ddbd:	79 da                	jns    f011dd99 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011ddbf:	c7 05 bc 47 5f f0 00 	movl   $0x0,0xf05f47bc
f011ddc6:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011ddc9:	83 ec 0c             	sub    $0xc,%esp
f011ddcc:	68 c0 42 5f f0       	push   $0xf05f42c0
f011ddd1:	e8 3d 0e ff ff       	call   f010ec13 <release_spinlock>
f011ddd6:	83 c4 10             	add    $0x10,%esp
f011ddd9:	e9 91 02 00 00       	jmp    f011e06f <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011ddde:	8b 15 00 44 5f f0    	mov    0xf05f4400,%edx
f011dde4:	a1 b0 47 5f f0       	mov    0xf05f47b0,%eax
f011dde9:	39 c2                	cmp    %eax,%edx
f011ddeb:	74 63                	je     f011de50 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011dded:	83 ec 0c             	sub    $0xc,%esp
f011ddf0:	68 c0 42 5f f0       	push   $0xf05f42c0
f011ddf5:	e8 92 0d ff ff       	call   f010eb8c <acquire_spinlock>
f011ddfa:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011ddfd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011de01:	0f 95 c0             	setne  %al
f011de04:	0f b6 c0             	movzbl %al,%eax
f011de07:	a3 74 49 5f f0       	mov    %eax,0xf05f4974
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011de0c:	a0 04 4a 5f f0       	mov    0xf05f4a04,%al
f011de11:	0f b6 c0             	movzbl %al,%eax
f011de14:	48                   	dec    %eax
f011de15:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011de18:	eb 20                	jmp    f011de3a <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011de1a:	a1 50 43 5f f0       	mov    0xf05f4350,%eax
f011de1f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011de22:	c1 e2 04             	shl    $0x4,%edx
f011de25:	01 d0                	add    %edx,%eax
f011de27:	8b 40 0c             	mov    0xc(%eax),%eax
f011de2a:	8b 15 74 49 5f f0    	mov    0xf05f4974,%edx
f011de30:	01 d0                	add    %edx,%eax
f011de32:	a3 74 49 5f f0       	mov    %eax,0xf05f4974
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011de37:	ff 4d f0             	decl   -0x10(%ebp)
f011de3a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011de3e:	79 da                	jns    f011de1a <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011de40:	83 ec 0c             	sub    $0xc,%esp
f011de43:	68 c0 42 5f f0       	push   $0xf05f42c0
f011de48:	e8 c6 0d ff ff       	call   f010ec13 <release_spinlock>
f011de4d:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011de50:	e8 a2 87 fe ff       	call   f01065f7 <timer_ticks>
f011de55:	6a 00                	push   $0x0
f011de57:	68 e8 03 00 00       	push   $0x3e8
f011de5c:	52                   	push   %edx
f011de5d:	50                   	push   %eax
f011de5e:	e8 1d 32 00 00       	call   f0121080 <__moddi3>
f011de63:	83 c4 10             	add    $0x10,%esp
f011de66:	09 d0                	or     %edx,%eax
f011de68:	85 c0                	test   %eax,%eax
f011de6a:	75 32                	jne    f011de9e <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011de6c:	8b 15 5c 45 5f f0    	mov    0xf05f455c,%edx
f011de72:	a1 94 44 5f f0       	mov    0xf05f4494,%eax
f011de77:	39 c2                	cmp    %eax,%edx
f011de79:	75 19                	jne    f011de94 <chk2+0x185>
f011de7b:	68 69 fd 12 f0       	push   $0xf012fd69
f011de80:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011de85:	68 35 02 00 00       	push   $0x235
f011de8a:	68 ef f9 12 f0       	push   $0xf012f9ef
f011de8f:	e8 35 25 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011de94:	a1 94 44 5f f0       	mov    0xf05f4494,%eax
f011de99:	a3 5c 45 5f f0       	mov    %eax,0xf05f455c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011de9e:	e8 54 87 fe ff       	call   f01065f7 <timer_ticks>
f011dea3:	6a 00                	push   $0x0
f011dea5:	6a 64                	push   $0x64
f011dea7:	52                   	push   %edx
f011dea8:	50                   	push   %eax
f011dea9:	e8 d2 31 00 00       	call   f0121080 <__moddi3>
f011deae:	83 c4 10             	add    $0x10,%esp
f011deb1:	09 d0                	or     %edx,%eax
f011deb3:	85 c0                	test   %eax,%eax
f011deb5:	0f 85 b4 01 00 00    	jne    f011e06f <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011debb:	8b 0d 28 4a 5f f0    	mov    0xf05f4a28,%ecx
f011dec1:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011dec6:	f7 e9                	imul   %ecx
f011dec8:	c1 fa 05             	sar    $0x5,%edx
f011decb:	89 c8                	mov    %ecx,%eax
f011decd:	c1 f8 1f             	sar    $0x1f,%eax
f011ded0:	29 c2                	sub    %eax,%edx
f011ded2:	89 d0                	mov    %edx,%eax
f011ded4:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011ded7:	8b 0d 28 4a 5f f0    	mov    0xf05f4a28,%ecx
f011dedd:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011dee2:	f7 e9                	imul   %ecx
f011dee4:	c1 fa 05             	sar    $0x5,%edx
f011dee7:	89 c8                	mov    %ecx,%eax
f011dee9:	c1 f8 1f             	sar    $0x1f,%eax
f011deec:	29 c2                	sub    %eax,%edx
f011deee:	89 d0                	mov    %edx,%eax
f011def0:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011def3:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011def6:	89 d0                	mov    %edx,%eax
f011def8:	c1 e0 02             	shl    $0x2,%eax
f011defb:	01 d0                	add    %edx,%eax
f011defd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011df04:	01 d0                	add    %edx,%eax
f011df06:	c1 e0 02             	shl    $0x2,%eax
f011df09:	29 c1                	sub    %eax,%ecx
f011df0b:	89 c8                	mov    %ecx,%eax
f011df0d:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011df10:	8b 0d 94 44 5f f0    	mov    0xf05f4494,%ecx
f011df16:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011df1b:	f7 e9                	imul   %ecx
f011df1d:	c1 fa 05             	sar    $0x5,%edx
f011df20:	89 c8                	mov    %ecx,%eax
f011df22:	c1 f8 1f             	sar    $0x1f,%eax
f011df25:	29 c2                	sub    %eax,%edx
f011df27:	89 d0                	mov    %edx,%eax
f011df29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011df2c:	8b 0d 94 44 5f f0    	mov    0xf05f4494,%ecx
f011df32:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011df37:	f7 e9                	imul   %ecx
f011df39:	c1 fa 05             	sar    $0x5,%edx
f011df3c:	89 c8                	mov    %ecx,%eax
f011df3e:	c1 f8 1f             	sar    $0x1f,%eax
f011df41:	29 c2                	sub    %eax,%edx
f011df43:	89 d0                	mov    %edx,%eax
f011df45:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011df48:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011df4b:	89 d0                	mov    %edx,%eax
f011df4d:	c1 e0 02             	shl    $0x2,%eax
f011df50:	01 d0                	add    %edx,%eax
f011df52:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011df59:	01 d0                	add    %edx,%eax
f011df5b:	c1 e0 02             	shl    $0x2,%eax
f011df5e:	29 c1                	sub    %eax,%ecx
f011df60:	89 c8                	mov    %ecx,%eax
f011df62:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011df65:	8b 15 b0 47 5f f0    	mov    0xf05f47b0,%edx
f011df6b:	a1 00 44 5f f0       	mov    0xf05f4400,%eax
f011df70:	39 c2                	cmp    %eax,%edx
f011df72:	0f 85 ed 00 00 00    	jne    f011e065 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011df78:	a1 74 49 5f f0       	mov    0xf05f4974,%eax
f011df7d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011df80:	7e 5b                	jle    f011dfdd <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011df82:	a1 74 49 5f f0       	mov    0xf05f4974,%eax
f011df87:	83 ec 08             	sub    $0x8,%esp
f011df8a:	ff 75 e0             	pushl  -0x20(%ebp)
f011df8d:	ff 75 e4             	pushl  -0x1c(%ebp)
f011df90:	ff 75 e8             	pushl  -0x18(%ebp)
f011df93:	ff 75 ec             	pushl  -0x14(%ebp)
f011df96:	50                   	push   %eax
f011df97:	68 7c fd 12 f0       	push   $0xf012fd7c
f011df9c:	e8 ea 2f fe ff       	call   f0100f8b <cprintf>
f011dfa1:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011dfa4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dfa7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dfaa:	0f 8f b5 00 00 00    	jg     f011e065 <chk2+0x356>
f011dfb0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dfb3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dfb6:	75 0c                	jne    f011dfc4 <chk2+0x2b5>
f011dfb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dfbb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011dfbe:	0f 8d a1 00 00 00    	jge    f011e065 <chk2+0x356>
f011dfc4:	68 c4 fd 12 f0       	push   $0xf012fdc4
f011dfc9:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011dfce:	68 4a 02 00 00       	push   $0x24a
f011dfd3:	68 ef f9 12 f0       	push   $0xf012f9ef
f011dfd8:	e8 ec 23 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011dfdd:	a1 74 49 5f f0       	mov    0xf05f4974,%eax
f011dfe2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dfe5:	7d 53                	jge    f011e03a <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011dfe7:	a1 74 49 5f f0       	mov    0xf05f4974,%eax
f011dfec:	83 ec 08             	sub    $0x8,%esp
f011dfef:	ff 75 e0             	pushl  -0x20(%ebp)
f011dff2:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dff5:	ff 75 e8             	pushl  -0x18(%ebp)
f011dff8:	ff 75 ec             	pushl  -0x14(%ebp)
f011dffb:	50                   	push   %eax
f011dffc:	68 04 fe 12 f0       	push   $0xf012fe04
f011e001:	e8 85 2f fe ff       	call   f0100f8b <cprintf>
f011e006:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011e009:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e00c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e00f:	7c 54                	jl     f011e065 <chk2+0x356>
f011e011:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e014:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e017:	75 08                	jne    f011e021 <chk2+0x312>
f011e019:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e01c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e01f:	7e 44                	jle    f011e065 <chk2+0x356>
f011e021:	68 4c fe 12 f0       	push   $0xf012fe4c
f011e026:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011e02b:	68 50 02 00 00       	push   $0x250
f011e030:	68 ef f9 12 f0       	push   $0xf012f9ef
f011e035:	e8 8f 23 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011e03a:	a1 74 49 5f f0       	mov    0xf05f4974,%eax
f011e03f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e042:	75 21                	jne    f011e065 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011e044:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e047:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e04a:	74 19                	je     f011e065 <chk2+0x356>
f011e04c:	68 8c fe 12 f0       	push   $0xf012fe8c
f011e051:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011e056:	68 54 02 00 00       	push   $0x254
f011e05b:	68 ef f9 12 f0       	push   $0xf012f9ef
f011e060:	e8 64 23 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011e065:	a1 94 44 5f f0       	mov    0xf05f4494,%eax
f011e06a:	a3 28 4a 5f f0       	mov    %eax,0xf05f4a28
			}
		}
		__pnexit = __nnexit;
f011e06f:	a1 b0 47 5f f0       	mov    0xf05f47b0,%eax
f011e074:	a3 00 44 5f f0       	mov    %eax,0xf05f4400
f011e079:	eb 01                	jmp    f011e07c <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011e07b:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011e07c:	c9                   	leave  
f011e07d:	c3                   	ret    

f011e07e <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011e07e:	55                   	push   %ebp
f011e07f:	89 e5                	mov    %esp,%ebp
f011e081:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011e084:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e08b:	eb 40                	jmp    f011e0cd <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011e08d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e090:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011e096:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011e09b:	83 ec 08             	sub    $0x8,%esp
f011e09e:	52                   	push   %edx
f011e09f:	50                   	push   %eax
f011e0a0:	e8 af 01 00 00       	call   f011e254 <check_va2pa>
f011e0a5:	83 c4 10             	add    $0x10,%esp
f011e0a8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e0ab:	74 19                	je     f011e0c6 <check_boot_pgdir+0x48>
f011e0ad:	68 a0 fe 12 f0       	push   $0xf012fea0
f011e0b2:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011e0b7:	68 9b 02 00 00       	push   $0x29b
f011e0bc:	68 ef f9 12 f0       	push   $0xf012f9ef
f011e0c1:	e8 73 22 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011e0c6:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011e0cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e0d0:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011e0d6:	a1 78 49 5f f0       	mov    0xf05f4978,%eax
f011e0db:	39 c2                	cmp    %eax,%edx
f011e0dd:	72 ae                	jb     f011e08d <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011e0df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e0e6:	e9 81 00 00 00       	jmp    f011e16c <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011e0eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e0ee:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011e0f3:	85 c0                	test   %eax,%eax
f011e0f5:	74 6d                	je     f011e164 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011e0f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e0fa:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011e100:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011e105:	83 ec 08             	sub    $0x8,%esp
f011e108:	52                   	push   %edx
f011e109:	50                   	push   %eax
f011e10a:	e8 45 01 00 00       	call   f011e254 <check_va2pa>
f011e10f:	83 c4 10             	add    $0x10,%esp
f011e112:	c7 45 f0 00 40 17 f0 	movl   $0xf0174000,-0x10(%ebp)
f011e119:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011e120:	77 17                	ja     f011e139 <check_boot_pgdir+0xbb>
f011e122:	ff 75 f0             	pushl  -0x10(%ebp)
f011e125:	68 d8 fe 12 f0       	push   $0xf012fed8
f011e12a:	68 a9 02 00 00       	push   $0x2a9
f011e12f:	68 ef f9 12 f0       	push   $0xf012f9ef
f011e134:	e8 00 22 fe ff       	call   f0100339 <_panic>
f011e139:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011e13c:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011e142:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e145:	01 ca                	add    %ecx,%edx
f011e147:	39 d0                	cmp    %edx,%eax
f011e149:	74 1a                	je     f011e165 <check_boot_pgdir+0xe7>
f011e14b:	68 0c ff 12 f0       	push   $0xf012ff0c
f011e150:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011e155:	68 a9 02 00 00       	push   $0x2a9
f011e15a:	68 ef f9 12 f0       	push   $0xf012f9ef
f011e15f:	e8 d5 21 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011e164:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011e165:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011e16c:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011e173:	0f 86 72 ff ff ff    	jbe    f011e0eb <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011e179:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e180:	e9 af 00 00 00       	jmp    f011e234 <check_boot_pgdir+0x1b6>
		switch (i) {
f011e185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e188:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011e18d:	74 11                	je     f011e1a0 <check_boot_pgdir+0x122>
f011e18f:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011e194:	72 36                	jb     f011e1cc <check_boot_pgdir+0x14e>
f011e196:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011e19b:	83 f8 02             	cmp    $0x2,%eax
f011e19e:	77 2c                	ja     f011e1cc <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011e1a0:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011e1a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e1a8:	c1 e2 02             	shl    $0x2,%edx
f011e1ab:	01 d0                	add    %edx,%eax
f011e1ad:	8b 00                	mov    (%eax),%eax
f011e1af:	85 c0                	test   %eax,%eax
f011e1b1:	75 7a                	jne    f011e22d <check_boot_pgdir+0x1af>
f011e1b3:	68 92 ff 12 f0       	push   $0xf012ff92
f011e1b8:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011e1bd:	68 b4 02 00 00       	push   $0x2b4
f011e1c2:	68 ef f9 12 f0       	push   $0xf012f9ef
f011e1c7:	e8 6d 21 fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011e1cc:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011e1d3:	76 2c                	jbe    f011e201 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011e1d5:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011e1da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e1dd:	c1 e2 02             	shl    $0x2,%edx
f011e1e0:	01 d0                	add    %edx,%eax
f011e1e2:	8b 00                	mov    (%eax),%eax
f011e1e4:	85 c0                	test   %eax,%eax
f011e1e6:	75 48                	jne    f011e230 <check_boot_pgdir+0x1b2>
f011e1e8:	68 92 ff 12 f0       	push   $0xf012ff92
f011e1ed:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011e1f2:	68 b8 02 00 00       	push   $0x2b8
f011e1f7:	68 ef f9 12 f0       	push   $0xf012f9ef
f011e1fc:	e8 38 21 fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011e201:	a1 7c 49 5f f0       	mov    0xf05f497c,%eax
f011e206:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e209:	c1 e2 02             	shl    $0x2,%edx
f011e20c:	01 d0                	add    %edx,%eax
f011e20e:	8b 00                	mov    (%eax),%eax
f011e210:	85 c0                	test   %eax,%eax
f011e212:	74 1c                	je     f011e230 <check_boot_pgdir+0x1b2>
f011e214:	68 a8 ff 12 f0       	push   $0xf012ffa8
f011e219:	68 a7 f9 12 f0       	push   $0xf012f9a7
f011e21e:	68 ba 02 00 00       	push   $0x2ba
f011e223:	68 ef f9 12 f0       	push   $0xf012f9ef
f011e228:	e8 0c 21 fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011e22d:	90                   	nop
f011e22e:	eb 01                	jmp    f011e231 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011e230:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011e231:	ff 45 f4             	incl   -0xc(%ebp)
f011e234:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011e23b:	0f 86 44 ff ff ff    	jbe    f011e185 <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011e241:	83 ec 0c             	sub    $0xc,%esp
f011e244:	68 c4 ff 12 f0       	push   $0xf012ffc4
f011e249:	e8 3d 2d fe ff       	call   f0100f8b <cprintf>
f011e24e:	83 c4 10             	add    $0x10,%esp
}
f011e251:	90                   	nop
f011e252:	c9                   	leave  
f011e253:	c3                   	ret    

f011e254 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011e254:	55                   	push   %ebp
f011e255:	89 e5                	mov    %esp,%ebp
f011e257:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011e25a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e25d:	c1 e8 16             	shr    $0x16,%eax
f011e260:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e267:	8b 45 08             	mov    0x8(%ebp),%eax
f011e26a:	01 d0                	add    %edx,%eax
f011e26c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011e26f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e272:	8b 00                	mov    (%eax),%eax
f011e274:	83 e0 01             	and    $0x1,%eax
f011e277:	85 c0                	test   %eax,%eax
f011e279:	75 0a                	jne    f011e285 <check_va2pa+0x31>
		return ~0;
f011e27b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011e280:	e9 87 00 00 00       	jmp    f011e30c <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011e285:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e288:	8b 00                	mov    (%eax),%eax
f011e28a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e28f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e292:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e295:	c1 e8 0c             	shr    $0xc,%eax
f011e298:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e29b:	a1 58 45 5f f0       	mov    0xf05f4558,%eax
f011e2a0:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011e2a3:	72 17                	jb     f011e2bc <check_va2pa+0x68>
f011e2a5:	ff 75 f0             	pushl  -0x10(%ebp)
f011e2a8:	68 e8 ff 12 f0       	push   $0xf012ffe8
f011e2ad:	68 d0 02 00 00       	push   $0x2d0
f011e2b2:	68 ef f9 12 f0       	push   $0xf012f9ef
f011e2b7:	e8 7d 20 fe ff       	call   f0100339 <_panic>
f011e2bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e2bf:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011e2c4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011e2c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e2ca:	c1 e8 0c             	shr    $0xc,%eax
f011e2cd:	25 ff 03 00 00       	and    $0x3ff,%eax
f011e2d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e2d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e2dc:	01 d0                	add    %edx,%eax
f011e2de:	8b 00                	mov    (%eax),%eax
f011e2e0:	83 e0 01             	and    $0x1,%eax
f011e2e3:	85 c0                	test   %eax,%eax
f011e2e5:	75 07                	jne    f011e2ee <check_va2pa+0x9a>
		return ~0;
f011e2e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011e2ec:	eb 1e                	jmp    f011e30c <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011e2ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e2f1:	c1 e8 0c             	shr    $0xc,%eax
f011e2f4:	25 ff 03 00 00       	and    $0x3ff,%eax
f011e2f9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e300:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e303:	01 d0                	add    %edx,%eax
f011e305:	8b 00                	mov    (%eax),%eax
f011e307:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011e30c:	c9                   	leave  
f011e30d:	c3                   	ret    

f011e30e <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011e30e:	55                   	push   %ebp
f011e30f:	89 e5                	mov    %esp,%ebp
f011e311:	53                   	push   %ebx
f011e312:	83 ec 14             	sub    $0x14,%esp
f011e315:	8b 45 10             	mov    0x10(%ebp),%eax
f011e318:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e31b:	8b 45 14             	mov    0x14(%ebp),%eax
f011e31e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011e321:	8b 45 18             	mov    0x18(%ebp),%eax
f011e324:	ba 00 00 00 00       	mov    $0x0,%edx
f011e329:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011e32c:	77 55                	ja     f011e383 <printnum+0x75>
f011e32e:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011e331:	72 05                	jb     f011e338 <printnum+0x2a>
f011e333:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011e336:	77 4b                	ja     f011e383 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011e338:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011e33b:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011e33e:	8b 45 18             	mov    0x18(%ebp),%eax
f011e341:	ba 00 00 00 00       	mov    $0x0,%edx
f011e346:	52                   	push   %edx
f011e347:	50                   	push   %eax
f011e348:	ff 75 f4             	pushl  -0xc(%ebp)
f011e34b:	ff 75 f0             	pushl  -0x10(%ebp)
f011e34e:	e8 c5 2e 00 00       	call   f0121218 <__udivdi3>
f011e353:	83 c4 10             	add    $0x10,%esp
f011e356:	83 ec 04             	sub    $0x4,%esp
f011e359:	ff 75 20             	pushl  0x20(%ebp)
f011e35c:	53                   	push   %ebx
f011e35d:	ff 75 18             	pushl  0x18(%ebp)
f011e360:	52                   	push   %edx
f011e361:	50                   	push   %eax
f011e362:	ff 75 0c             	pushl  0xc(%ebp)
f011e365:	ff 75 08             	pushl  0x8(%ebp)
f011e368:	e8 a1 ff ff ff       	call   f011e30e <printnum>
f011e36d:	83 c4 20             	add    $0x20,%esp
f011e370:	eb 1a                	jmp    f011e38c <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011e372:	83 ec 08             	sub    $0x8,%esp
f011e375:	ff 75 0c             	pushl  0xc(%ebp)
f011e378:	ff 75 20             	pushl  0x20(%ebp)
f011e37b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e37e:	ff d0                	call   *%eax
f011e380:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011e383:	ff 4d 1c             	decl   0x1c(%ebp)
f011e386:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011e38a:	7f e6                	jg     f011e372 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011e38c:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011e38f:	bb 00 00 00 00       	mov    $0x0,%ebx
f011e394:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e397:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e39a:	53                   	push   %ebx
f011e39b:	51                   	push   %ecx
f011e39c:	52                   	push   %edx
f011e39d:	50                   	push   %eax
f011e39e:	e8 85 2f 00 00       	call   f0121328 <__umoddi3>
f011e3a3:	83 c4 10             	add    $0x10,%esp
f011e3a6:	05 34 02 13 f0       	add    $0xf0130234,%eax
f011e3ab:	8a 00                	mov    (%eax),%al
f011e3ad:	0f be c0             	movsbl %al,%eax
f011e3b0:	83 ec 08             	sub    $0x8,%esp
f011e3b3:	ff 75 0c             	pushl  0xc(%ebp)
f011e3b6:	50                   	push   %eax
f011e3b7:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3ba:	ff d0                	call   *%eax
f011e3bc:	83 c4 10             	add    $0x10,%esp
}
f011e3bf:	90                   	nop
f011e3c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011e3c3:	c9                   	leave  
f011e3c4:	c3                   	ret    

f011e3c5 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011e3c5:	55                   	push   %ebp
f011e3c6:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011e3c8:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011e3cc:	7e 1c                	jle    f011e3ea <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011e3ce:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3d1:	8b 00                	mov    (%eax),%eax
f011e3d3:	8d 50 08             	lea    0x8(%eax),%edx
f011e3d6:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3d9:	89 10                	mov    %edx,(%eax)
f011e3db:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3de:	8b 00                	mov    (%eax),%eax
f011e3e0:	83 e8 08             	sub    $0x8,%eax
f011e3e3:	8b 50 04             	mov    0x4(%eax),%edx
f011e3e6:	8b 00                	mov    (%eax),%eax
f011e3e8:	eb 40                	jmp    f011e42a <getuint+0x65>
	else if (lflag)
f011e3ea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e3ee:	74 1e                	je     f011e40e <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011e3f0:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3f3:	8b 00                	mov    (%eax),%eax
f011e3f5:	8d 50 04             	lea    0x4(%eax),%edx
f011e3f8:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3fb:	89 10                	mov    %edx,(%eax)
f011e3fd:	8b 45 08             	mov    0x8(%ebp),%eax
f011e400:	8b 00                	mov    (%eax),%eax
f011e402:	83 e8 04             	sub    $0x4,%eax
f011e405:	8b 00                	mov    (%eax),%eax
f011e407:	ba 00 00 00 00       	mov    $0x0,%edx
f011e40c:	eb 1c                	jmp    f011e42a <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011e40e:	8b 45 08             	mov    0x8(%ebp),%eax
f011e411:	8b 00                	mov    (%eax),%eax
f011e413:	8d 50 04             	lea    0x4(%eax),%edx
f011e416:	8b 45 08             	mov    0x8(%ebp),%eax
f011e419:	89 10                	mov    %edx,(%eax)
f011e41b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e41e:	8b 00                	mov    (%eax),%eax
f011e420:	83 e8 04             	sub    $0x4,%eax
f011e423:	8b 00                	mov    (%eax),%eax
f011e425:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011e42a:	5d                   	pop    %ebp
f011e42b:	c3                   	ret    

f011e42c <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011e42c:	55                   	push   %ebp
f011e42d:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011e42f:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011e433:	7e 1c                	jle    f011e451 <getint+0x25>
		return va_arg(*ap, long long);
f011e435:	8b 45 08             	mov    0x8(%ebp),%eax
f011e438:	8b 00                	mov    (%eax),%eax
f011e43a:	8d 50 08             	lea    0x8(%eax),%edx
f011e43d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e440:	89 10                	mov    %edx,(%eax)
f011e442:	8b 45 08             	mov    0x8(%ebp),%eax
f011e445:	8b 00                	mov    (%eax),%eax
f011e447:	83 e8 08             	sub    $0x8,%eax
f011e44a:	8b 50 04             	mov    0x4(%eax),%edx
f011e44d:	8b 00                	mov    (%eax),%eax
f011e44f:	eb 38                	jmp    f011e489 <getint+0x5d>
	else if (lflag)
f011e451:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e455:	74 1a                	je     f011e471 <getint+0x45>
		return va_arg(*ap, long);
f011e457:	8b 45 08             	mov    0x8(%ebp),%eax
f011e45a:	8b 00                	mov    (%eax),%eax
f011e45c:	8d 50 04             	lea    0x4(%eax),%edx
f011e45f:	8b 45 08             	mov    0x8(%ebp),%eax
f011e462:	89 10                	mov    %edx,(%eax)
f011e464:	8b 45 08             	mov    0x8(%ebp),%eax
f011e467:	8b 00                	mov    (%eax),%eax
f011e469:	83 e8 04             	sub    $0x4,%eax
f011e46c:	8b 00                	mov    (%eax),%eax
f011e46e:	99                   	cltd   
f011e46f:	eb 18                	jmp    f011e489 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011e471:	8b 45 08             	mov    0x8(%ebp),%eax
f011e474:	8b 00                	mov    (%eax),%eax
f011e476:	8d 50 04             	lea    0x4(%eax),%edx
f011e479:	8b 45 08             	mov    0x8(%ebp),%eax
f011e47c:	89 10                	mov    %edx,(%eax)
f011e47e:	8b 45 08             	mov    0x8(%ebp),%eax
f011e481:	8b 00                	mov    (%eax),%eax
f011e483:	83 e8 04             	sub    $0x4,%eax
f011e486:	8b 00                	mov    (%eax),%eax
f011e488:	99                   	cltd   
}
f011e489:	5d                   	pop    %ebp
f011e48a:	c3                   	ret    

f011e48b <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011e48b:	55                   	push   %ebp
f011e48c:	89 e5                	mov    %esp,%ebp
f011e48e:	56                   	push   %esi
f011e48f:	53                   	push   %ebx
f011e490:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011e493:	eb 17                	jmp    f011e4ac <vprintfmt+0x21>
			if (ch == '\0')
f011e495:	85 db                	test   %ebx,%ebx
f011e497:	0f 84 c1 03 00 00    	je     f011e85e <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011e49d:	83 ec 08             	sub    $0x8,%esp
f011e4a0:	ff 75 0c             	pushl  0xc(%ebp)
f011e4a3:	53                   	push   %ebx
f011e4a4:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4a7:	ff d0                	call   *%eax
f011e4a9:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011e4ac:	8b 45 10             	mov    0x10(%ebp),%eax
f011e4af:	8d 50 01             	lea    0x1(%eax),%edx
f011e4b2:	89 55 10             	mov    %edx,0x10(%ebp)
f011e4b5:	8a 00                	mov    (%eax),%al
f011e4b7:	0f b6 d8             	movzbl %al,%ebx
f011e4ba:	83 fb 25             	cmp    $0x25,%ebx
f011e4bd:	75 d6                	jne    f011e495 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011e4bf:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011e4c3:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011e4ca:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011e4d1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011e4d8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011e4df:	8b 45 10             	mov    0x10(%ebp),%eax
f011e4e2:	8d 50 01             	lea    0x1(%eax),%edx
f011e4e5:	89 55 10             	mov    %edx,0x10(%ebp)
f011e4e8:	8a 00                	mov    (%eax),%al
f011e4ea:	0f b6 d8             	movzbl %al,%ebx
f011e4ed:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011e4f0:	83 f8 5b             	cmp    $0x5b,%eax
f011e4f3:	0f 87 3d 03 00 00    	ja     f011e836 <vprintfmt+0x3ab>
f011e4f9:	8b 04 85 58 02 13 f0 	mov    -0xfecfda8(,%eax,4),%eax
f011e500:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011e502:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011e506:	eb d7                	jmp    f011e4df <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011e508:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011e50c:	eb d1                	jmp    f011e4df <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011e50e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011e515:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011e518:	89 d0                	mov    %edx,%eax
f011e51a:	c1 e0 02             	shl    $0x2,%eax
f011e51d:	01 d0                	add    %edx,%eax
f011e51f:	01 c0                	add    %eax,%eax
f011e521:	01 d8                	add    %ebx,%eax
f011e523:	83 e8 30             	sub    $0x30,%eax
f011e526:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011e529:	8b 45 10             	mov    0x10(%ebp),%eax
f011e52c:	8a 00                	mov    (%eax),%al
f011e52e:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011e531:	83 fb 2f             	cmp    $0x2f,%ebx
f011e534:	7e 3e                	jle    f011e574 <vprintfmt+0xe9>
f011e536:	83 fb 39             	cmp    $0x39,%ebx
f011e539:	7f 39                	jg     f011e574 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011e53b:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011e53e:	eb d5                	jmp    f011e515 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011e540:	8b 45 14             	mov    0x14(%ebp),%eax
f011e543:	83 c0 04             	add    $0x4,%eax
f011e546:	89 45 14             	mov    %eax,0x14(%ebp)
f011e549:	8b 45 14             	mov    0x14(%ebp),%eax
f011e54c:	83 e8 04             	sub    $0x4,%eax
f011e54f:	8b 00                	mov    (%eax),%eax
f011e551:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011e554:	eb 1f                	jmp    f011e575 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011e556:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e55a:	79 83                	jns    f011e4df <vprintfmt+0x54>
				width = 0;
f011e55c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011e563:	e9 77 ff ff ff       	jmp    f011e4df <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011e568:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011e56f:	e9 6b ff ff ff       	jmp    f011e4df <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011e574:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011e575:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e579:	0f 89 60 ff ff ff    	jns    f011e4df <vprintfmt+0x54>
				width = precision, precision = -1;
f011e57f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e582:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e585:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011e58c:	e9 4e ff ff ff       	jmp    f011e4df <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011e591:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011e594:	e9 46 ff ff ff       	jmp    f011e4df <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011e599:	8b 45 14             	mov    0x14(%ebp),%eax
f011e59c:	83 c0 04             	add    $0x4,%eax
f011e59f:	89 45 14             	mov    %eax,0x14(%ebp)
f011e5a2:	8b 45 14             	mov    0x14(%ebp),%eax
f011e5a5:	83 e8 04             	sub    $0x4,%eax
f011e5a8:	8b 00                	mov    (%eax),%eax
f011e5aa:	83 ec 08             	sub    $0x8,%esp
f011e5ad:	ff 75 0c             	pushl  0xc(%ebp)
f011e5b0:	50                   	push   %eax
f011e5b1:	8b 45 08             	mov    0x8(%ebp),%eax
f011e5b4:	ff d0                	call   *%eax
f011e5b6:	83 c4 10             	add    $0x10,%esp
			break;
f011e5b9:	e9 9b 02 00 00       	jmp    f011e859 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011e5be:	8b 45 14             	mov    0x14(%ebp),%eax
f011e5c1:	83 c0 04             	add    $0x4,%eax
f011e5c4:	89 45 14             	mov    %eax,0x14(%ebp)
f011e5c7:	8b 45 14             	mov    0x14(%ebp),%eax
f011e5ca:	83 e8 04             	sub    $0x4,%eax
f011e5cd:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011e5cf:	85 db                	test   %ebx,%ebx
f011e5d1:	79 02                	jns    f011e5d5 <vprintfmt+0x14a>
				err = -err;
f011e5d3:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011e5d5:	83 fb 64             	cmp    $0x64,%ebx
f011e5d8:	7f 0b                	jg     f011e5e5 <vprintfmt+0x15a>
f011e5da:	8b 34 9d a0 00 13 f0 	mov    -0xfecff60(,%ebx,4),%esi
f011e5e1:	85 f6                	test   %esi,%esi
f011e5e3:	75 19                	jne    f011e5fe <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011e5e5:	53                   	push   %ebx
f011e5e6:	68 45 02 13 f0       	push   $0xf0130245
f011e5eb:	ff 75 0c             	pushl  0xc(%ebp)
f011e5ee:	ff 75 08             	pushl  0x8(%ebp)
f011e5f1:	e8 70 02 00 00       	call   f011e866 <printfmt>
f011e5f6:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011e5f9:	e9 5b 02 00 00       	jmp    f011e859 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011e5fe:	56                   	push   %esi
f011e5ff:	68 4e 02 13 f0       	push   $0xf013024e
f011e604:	ff 75 0c             	pushl  0xc(%ebp)
f011e607:	ff 75 08             	pushl  0x8(%ebp)
f011e60a:	e8 57 02 00 00       	call   f011e866 <printfmt>
f011e60f:	83 c4 10             	add    $0x10,%esp
			break;
f011e612:	e9 42 02 00 00       	jmp    f011e859 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011e617:	8b 45 14             	mov    0x14(%ebp),%eax
f011e61a:	83 c0 04             	add    $0x4,%eax
f011e61d:	89 45 14             	mov    %eax,0x14(%ebp)
f011e620:	8b 45 14             	mov    0x14(%ebp),%eax
f011e623:	83 e8 04             	sub    $0x4,%eax
f011e626:	8b 30                	mov    (%eax),%esi
f011e628:	85 f6                	test   %esi,%esi
f011e62a:	75 05                	jne    f011e631 <vprintfmt+0x1a6>
				p = "(null)";
f011e62c:	be 51 02 13 f0       	mov    $0xf0130251,%esi
			if (width > 0 && padc != '-')
f011e631:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e635:	7e 6d                	jle    f011e6a4 <vprintfmt+0x219>
f011e637:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011e63b:	74 67                	je     f011e6a4 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011e63d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e640:	83 ec 08             	sub    $0x8,%esp
f011e643:	50                   	push   %eax
f011e644:	56                   	push   %esi
f011e645:	e8 26 05 00 00       	call   f011eb70 <strnlen>
f011e64a:	83 c4 10             	add    $0x10,%esp
f011e64d:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011e650:	eb 16                	jmp    f011e668 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011e652:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011e656:	83 ec 08             	sub    $0x8,%esp
f011e659:	ff 75 0c             	pushl  0xc(%ebp)
f011e65c:	50                   	push   %eax
f011e65d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e660:	ff d0                	call   *%eax
f011e662:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011e665:	ff 4d e4             	decl   -0x1c(%ebp)
f011e668:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e66c:	7f e4                	jg     f011e652 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011e66e:	eb 34                	jmp    f011e6a4 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011e670:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011e674:	74 1c                	je     f011e692 <vprintfmt+0x207>
f011e676:	83 fb 1f             	cmp    $0x1f,%ebx
f011e679:	7e 05                	jle    f011e680 <vprintfmt+0x1f5>
f011e67b:	83 fb 7e             	cmp    $0x7e,%ebx
f011e67e:	7e 12                	jle    f011e692 <vprintfmt+0x207>
					putch('?', putdat);
f011e680:	83 ec 08             	sub    $0x8,%esp
f011e683:	ff 75 0c             	pushl  0xc(%ebp)
f011e686:	6a 3f                	push   $0x3f
f011e688:	8b 45 08             	mov    0x8(%ebp),%eax
f011e68b:	ff d0                	call   *%eax
f011e68d:	83 c4 10             	add    $0x10,%esp
f011e690:	eb 0f                	jmp    f011e6a1 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011e692:	83 ec 08             	sub    $0x8,%esp
f011e695:	ff 75 0c             	pushl  0xc(%ebp)
f011e698:	53                   	push   %ebx
f011e699:	8b 45 08             	mov    0x8(%ebp),%eax
f011e69c:	ff d0                	call   *%eax
f011e69e:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011e6a1:	ff 4d e4             	decl   -0x1c(%ebp)
f011e6a4:	89 f0                	mov    %esi,%eax
f011e6a6:	8d 70 01             	lea    0x1(%eax),%esi
f011e6a9:	8a 00                	mov    (%eax),%al
f011e6ab:	0f be d8             	movsbl %al,%ebx
f011e6ae:	85 db                	test   %ebx,%ebx
f011e6b0:	74 24                	je     f011e6d6 <vprintfmt+0x24b>
f011e6b2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011e6b6:	78 b8                	js     f011e670 <vprintfmt+0x1e5>
f011e6b8:	ff 4d e0             	decl   -0x20(%ebp)
f011e6bb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011e6bf:	79 af                	jns    f011e670 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011e6c1:	eb 13                	jmp    f011e6d6 <vprintfmt+0x24b>
				putch(' ', putdat);
f011e6c3:	83 ec 08             	sub    $0x8,%esp
f011e6c6:	ff 75 0c             	pushl  0xc(%ebp)
f011e6c9:	6a 20                	push   $0x20
f011e6cb:	8b 45 08             	mov    0x8(%ebp),%eax
f011e6ce:	ff d0                	call   *%eax
f011e6d0:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011e6d3:	ff 4d e4             	decl   -0x1c(%ebp)
f011e6d6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e6da:	7f e7                	jg     f011e6c3 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011e6dc:	e9 78 01 00 00       	jmp    f011e859 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011e6e1:	83 ec 08             	sub    $0x8,%esp
f011e6e4:	ff 75 e8             	pushl  -0x18(%ebp)
f011e6e7:	8d 45 14             	lea    0x14(%ebp),%eax
f011e6ea:	50                   	push   %eax
f011e6eb:	e8 3c fd ff ff       	call   f011e42c <getint>
f011e6f0:	83 c4 10             	add    $0x10,%esp
f011e6f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e6f6:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011e6f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e6fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e6ff:	85 d2                	test   %edx,%edx
f011e701:	79 23                	jns    f011e726 <vprintfmt+0x29b>
				putch('-', putdat);
f011e703:	83 ec 08             	sub    $0x8,%esp
f011e706:	ff 75 0c             	pushl  0xc(%ebp)
f011e709:	6a 2d                	push   $0x2d
f011e70b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e70e:	ff d0                	call   *%eax
f011e710:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011e713:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e716:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e719:	f7 d8                	neg    %eax
f011e71b:	83 d2 00             	adc    $0x0,%edx
f011e71e:	f7 da                	neg    %edx
f011e720:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e723:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011e726:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011e72d:	e9 bc 00 00 00       	jmp    f011e7ee <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011e732:	83 ec 08             	sub    $0x8,%esp
f011e735:	ff 75 e8             	pushl  -0x18(%ebp)
f011e738:	8d 45 14             	lea    0x14(%ebp),%eax
f011e73b:	50                   	push   %eax
f011e73c:	e8 84 fc ff ff       	call   f011e3c5 <getuint>
f011e741:	83 c4 10             	add    $0x10,%esp
f011e744:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e747:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011e74a:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011e751:	e9 98 00 00 00       	jmp    f011e7ee <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011e756:	83 ec 08             	sub    $0x8,%esp
f011e759:	ff 75 0c             	pushl  0xc(%ebp)
f011e75c:	6a 58                	push   $0x58
f011e75e:	8b 45 08             	mov    0x8(%ebp),%eax
f011e761:	ff d0                	call   *%eax
f011e763:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011e766:	83 ec 08             	sub    $0x8,%esp
f011e769:	ff 75 0c             	pushl  0xc(%ebp)
f011e76c:	6a 58                	push   $0x58
f011e76e:	8b 45 08             	mov    0x8(%ebp),%eax
f011e771:	ff d0                	call   *%eax
f011e773:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011e776:	83 ec 08             	sub    $0x8,%esp
f011e779:	ff 75 0c             	pushl  0xc(%ebp)
f011e77c:	6a 58                	push   $0x58
f011e77e:	8b 45 08             	mov    0x8(%ebp),%eax
f011e781:	ff d0                	call   *%eax
f011e783:	83 c4 10             	add    $0x10,%esp
			break;
f011e786:	e9 ce 00 00 00       	jmp    f011e859 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011e78b:	83 ec 08             	sub    $0x8,%esp
f011e78e:	ff 75 0c             	pushl  0xc(%ebp)
f011e791:	6a 30                	push   $0x30
f011e793:	8b 45 08             	mov    0x8(%ebp),%eax
f011e796:	ff d0                	call   *%eax
f011e798:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011e79b:	83 ec 08             	sub    $0x8,%esp
f011e79e:	ff 75 0c             	pushl  0xc(%ebp)
f011e7a1:	6a 78                	push   $0x78
f011e7a3:	8b 45 08             	mov    0x8(%ebp),%eax
f011e7a6:	ff d0                	call   *%eax
f011e7a8:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011e7ab:	8b 45 14             	mov    0x14(%ebp),%eax
f011e7ae:	83 c0 04             	add    $0x4,%eax
f011e7b1:	89 45 14             	mov    %eax,0x14(%ebp)
f011e7b4:	8b 45 14             	mov    0x14(%ebp),%eax
f011e7b7:	83 e8 04             	sub    $0x4,%eax
f011e7ba:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011e7bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e7bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011e7c6:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011e7cd:	eb 1f                	jmp    f011e7ee <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011e7cf:	83 ec 08             	sub    $0x8,%esp
f011e7d2:	ff 75 e8             	pushl  -0x18(%ebp)
f011e7d5:	8d 45 14             	lea    0x14(%ebp),%eax
f011e7d8:	50                   	push   %eax
f011e7d9:	e8 e7 fb ff ff       	call   f011e3c5 <getuint>
f011e7de:	83 c4 10             	add    $0x10,%esp
f011e7e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e7e4:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011e7e7:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011e7ee:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011e7f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e7f5:	83 ec 04             	sub    $0x4,%esp
f011e7f8:	52                   	push   %edx
f011e7f9:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e7fc:	50                   	push   %eax
f011e7fd:	ff 75 f4             	pushl  -0xc(%ebp)
f011e800:	ff 75 f0             	pushl  -0x10(%ebp)
f011e803:	ff 75 0c             	pushl  0xc(%ebp)
f011e806:	ff 75 08             	pushl  0x8(%ebp)
f011e809:	e8 00 fb ff ff       	call   f011e30e <printnum>
f011e80e:	83 c4 20             	add    $0x20,%esp
			break;
f011e811:	eb 46                	jmp    f011e859 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011e813:	83 ec 08             	sub    $0x8,%esp
f011e816:	ff 75 0c             	pushl  0xc(%ebp)
f011e819:	53                   	push   %ebx
f011e81a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e81d:	ff d0                	call   *%eax
f011e81f:	83 c4 10             	add    $0x10,%esp
			break;
f011e822:	eb 35                	jmp    f011e859 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011e824:	c6 05 a0 42 5f f0 00 	movb   $0x0,0xf05f42a0
			break;
f011e82b:	eb 2c                	jmp    f011e859 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011e82d:	c6 05 a0 42 5f f0 01 	movb   $0x1,0xf05f42a0
			break;
f011e834:	eb 23                	jmp    f011e859 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011e836:	83 ec 08             	sub    $0x8,%esp
f011e839:	ff 75 0c             	pushl  0xc(%ebp)
f011e83c:	6a 25                	push   $0x25
f011e83e:	8b 45 08             	mov    0x8(%ebp),%eax
f011e841:	ff d0                	call   *%eax
f011e843:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011e846:	ff 4d 10             	decl   0x10(%ebp)
f011e849:	eb 03                	jmp    f011e84e <vprintfmt+0x3c3>
f011e84b:	ff 4d 10             	decl   0x10(%ebp)
f011e84e:	8b 45 10             	mov    0x10(%ebp),%eax
f011e851:	48                   	dec    %eax
f011e852:	8a 00                	mov    (%eax),%al
f011e854:	3c 25                	cmp    $0x25,%al
f011e856:	75 f3                	jne    f011e84b <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011e858:	90                   	nop
		}
	}
f011e859:	e9 35 fc ff ff       	jmp    f011e493 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011e85e:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011e85f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011e862:	5b                   	pop    %ebx
f011e863:	5e                   	pop    %esi
f011e864:	5d                   	pop    %ebp
f011e865:	c3                   	ret    

f011e866 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011e866:	55                   	push   %ebp
f011e867:	89 e5                	mov    %esp,%ebp
f011e869:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011e86c:	8d 45 10             	lea    0x10(%ebp),%eax
f011e86f:	83 c0 04             	add    $0x4,%eax
f011e872:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011e875:	8b 45 10             	mov    0x10(%ebp),%eax
f011e878:	ff 75 f4             	pushl  -0xc(%ebp)
f011e87b:	50                   	push   %eax
f011e87c:	ff 75 0c             	pushl  0xc(%ebp)
f011e87f:	ff 75 08             	pushl  0x8(%ebp)
f011e882:	e8 04 fc ff ff       	call   f011e48b <vprintfmt>
f011e887:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011e88a:	90                   	nop
f011e88b:	c9                   	leave  
f011e88c:	c3                   	ret    

f011e88d <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011e88d:	55                   	push   %ebp
f011e88e:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011e890:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e893:	8b 40 08             	mov    0x8(%eax),%eax
f011e896:	8d 50 01             	lea    0x1(%eax),%edx
f011e899:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e89c:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011e89f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e8a2:	8b 10                	mov    (%eax),%edx
f011e8a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e8a7:	8b 40 04             	mov    0x4(%eax),%eax
f011e8aa:	39 c2                	cmp    %eax,%edx
f011e8ac:	73 12                	jae    f011e8c0 <sprintputch+0x33>
		*b->buf++ = ch;
f011e8ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e8b1:	8b 00                	mov    (%eax),%eax
f011e8b3:	8d 48 01             	lea    0x1(%eax),%ecx
f011e8b6:	8b 55 0c             	mov    0xc(%ebp),%edx
f011e8b9:	89 0a                	mov    %ecx,(%edx)
f011e8bb:	8b 55 08             	mov    0x8(%ebp),%edx
f011e8be:	88 10                	mov    %dl,(%eax)
}
f011e8c0:	90                   	nop
f011e8c1:	5d                   	pop    %ebp
f011e8c2:	c3                   	ret    

f011e8c3 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011e8c3:	55                   	push   %ebp
f011e8c4:	89 e5                	mov    %esp,%ebp
f011e8c6:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011e8c9:	8b 45 08             	mov    0x8(%ebp),%eax
f011e8cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e8cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e8d2:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e8d5:	8b 45 08             	mov    0x8(%ebp),%eax
f011e8d8:	01 d0                	add    %edx,%eax
f011e8da:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e8dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011e8e4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e8e8:	74 06                	je     f011e8f0 <vsnprintf+0x2d>
f011e8ea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e8ee:	7f 07                	jg     f011e8f7 <vsnprintf+0x34>
		return -E_INVAL;
f011e8f0:	b8 03 00 00 00       	mov    $0x3,%eax
f011e8f5:	eb 20                	jmp    f011e917 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011e8f7:	ff 75 14             	pushl  0x14(%ebp)
f011e8fa:	ff 75 10             	pushl  0x10(%ebp)
f011e8fd:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011e900:	50                   	push   %eax
f011e901:	68 8d e8 11 f0       	push   $0xf011e88d
f011e906:	e8 80 fb ff ff       	call   f011e48b <vprintfmt>
f011e90b:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011e90e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e911:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011e914:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011e917:	c9                   	leave  
f011e918:	c3                   	ret    

f011e919 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011e919:	55                   	push   %ebp
f011e91a:	89 e5                	mov    %esp,%ebp
f011e91c:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011e91f:	8d 45 10             	lea    0x10(%ebp),%eax
f011e922:	83 c0 04             	add    $0x4,%eax
f011e925:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011e928:	8b 45 10             	mov    0x10(%ebp),%eax
f011e92b:	ff 75 f4             	pushl  -0xc(%ebp)
f011e92e:	50                   	push   %eax
f011e92f:	ff 75 0c             	pushl  0xc(%ebp)
f011e932:	ff 75 08             	pushl  0x8(%ebp)
f011e935:	e8 89 ff ff ff       	call   f011e8c3 <vsnprintf>
f011e93a:	83 c4 10             	add    $0x10,%esp
f011e93d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011e940:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011e943:	c9                   	leave  
f011e944:	c3                   	ret    

f011e945 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011e945:	55                   	push   %ebp
f011e946:	89 e5                	mov    %esp,%ebp
f011e948:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011e94b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e94f:	74 13                	je     f011e964 <readline+0x1f>
		cprintf("%s", prompt);
f011e951:	83 ec 08             	sub    $0x8,%esp
f011e954:	ff 75 08             	pushl  0x8(%ebp)
f011e957:	68 c8 03 13 f0       	push   $0xf01303c8
f011e95c:	e8 2a 26 fe ff       	call   f0100f8b <cprintf>
f011e961:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011e964:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011e96b:	83 ec 0c             	sub    $0xc,%esp
f011e96e:	6a 00                	push   $0x0
f011e970:	e8 23 25 fe ff       	call   f0100e98 <iscons>
f011e975:	83 c4 10             	add    $0x10,%esp
f011e978:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011e97b:	e8 ff 24 fe ff       	call   f0100e7f <getchar>
f011e980:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011e983:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e987:	79 22                	jns    f011e9ab <readline+0x66>
			if (c != -E_EOF)
f011e989:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011e98d:	0f 84 ad 00 00 00    	je     f011ea40 <readline+0xfb>
				cprintf("read error: %e\n", c);
f011e993:	83 ec 08             	sub    $0x8,%esp
f011e996:	ff 75 ec             	pushl  -0x14(%ebp)
f011e999:	68 cb 03 13 f0       	push   $0xf01303cb
f011e99e:	e8 e8 25 fe ff       	call   f0100f8b <cprintf>
f011e9a3:	83 c4 10             	add    $0x10,%esp
			break;
f011e9a6:	e9 95 00 00 00       	jmp    f011ea40 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011e9ab:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011e9af:	7e 34                	jle    f011e9e5 <readline+0xa0>
f011e9b1:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011e9b8:	7f 2b                	jg     f011e9e5 <readline+0xa0>
			if (echoing)
f011e9ba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e9be:	74 0e                	je     f011e9ce <readline+0x89>
				cputchar(c);
f011e9c0:	83 ec 0c             	sub    $0xc,%esp
f011e9c3:	ff 75 ec             	pushl  -0x14(%ebp)
f011e9c6:	e8 9d 24 fe ff       	call   f0100e68 <cputchar>
f011e9cb:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011e9ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e9d1:	8d 50 01             	lea    0x1(%eax),%edx
f011e9d4:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011e9d7:	89 c2                	mov    %eax,%edx
f011e9d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e9dc:	01 d0                	add    %edx,%eax
f011e9de:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011e9e1:	88 10                	mov    %dl,(%eax)
f011e9e3:	eb 56                	jmp    f011ea3b <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011e9e5:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011e9e9:	75 1f                	jne    f011ea0a <readline+0xc5>
f011e9eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e9ef:	7e 19                	jle    f011ea0a <readline+0xc5>
			if (echoing)
f011e9f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e9f5:	74 0e                	je     f011ea05 <readline+0xc0>
				cputchar(c);
f011e9f7:	83 ec 0c             	sub    $0xc,%esp
f011e9fa:	ff 75 ec             	pushl  -0x14(%ebp)
f011e9fd:	e8 66 24 fe ff       	call   f0100e68 <cputchar>
f011ea02:	83 c4 10             	add    $0x10,%esp

			i--;
f011ea05:	ff 4d f4             	decl   -0xc(%ebp)
f011ea08:	eb 31                	jmp    f011ea3b <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011ea0a:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011ea0e:	74 0a                	je     f011ea1a <readline+0xd5>
f011ea10:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011ea14:	0f 85 61 ff ff ff    	jne    f011e97b <readline+0x36>
			if (echoing)
f011ea1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ea1e:	74 0e                	je     f011ea2e <readline+0xe9>
				cputchar(c);
f011ea20:	83 ec 0c             	sub    $0xc,%esp
f011ea23:	ff 75 ec             	pushl  -0x14(%ebp)
f011ea26:	e8 3d 24 fe ff       	call   f0100e68 <cputchar>
f011ea2b:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011ea2e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ea31:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea34:	01 d0                	add    %edx,%eax
f011ea36:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011ea39:	eb 06                	jmp    f011ea41 <readline+0xfc>
		}
	}
f011ea3b:	e9 3b ff ff ff       	jmp    f011e97b <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011ea40:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011ea41:	90                   	nop
f011ea42:	c9                   	leave  
f011ea43:	c3                   	ret    

f011ea44 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011ea44:	55                   	push   %ebp
f011ea45:	89 e5                	mov    %esp,%ebp
f011ea47:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011ea4a:	e8 46 ee fe ff       	call   f010d895 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011ea4f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ea53:	74 13                	je     f011ea68 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011ea55:	83 ec 08             	sub    $0x8,%esp
f011ea58:	ff 75 08             	pushl  0x8(%ebp)
f011ea5b:	68 c8 03 13 f0       	push   $0xf01303c8
f011ea60:	e8 26 25 fe ff       	call   f0100f8b <cprintf>
f011ea65:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011ea68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011ea6f:	83 ec 0c             	sub    $0xc,%esp
f011ea72:	6a 00                	push   $0x0
f011ea74:	e8 1f 24 fe ff       	call   f0100e98 <iscons>
f011ea79:	83 c4 10             	add    $0x10,%esp
f011ea7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011ea7f:	e8 fb 23 fe ff       	call   f0100e7f <getchar>
f011ea84:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011ea87:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ea8b:	79 22                	jns    f011eaaf <atomic_readline+0x6b>
				if (c != -E_EOF)
f011ea8d:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011ea91:	0f 84 ad 00 00 00    	je     f011eb44 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011ea97:	83 ec 08             	sub    $0x8,%esp
f011ea9a:	ff 75 ec             	pushl  -0x14(%ebp)
f011ea9d:	68 cb 03 13 f0       	push   $0xf01303cb
f011eaa2:	e8 e4 24 fe ff       	call   f0100f8b <cprintf>
f011eaa7:	83 c4 10             	add    $0x10,%esp
				break;
f011eaaa:	e9 95 00 00 00       	jmp    f011eb44 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011eaaf:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011eab3:	7e 34                	jle    f011eae9 <atomic_readline+0xa5>
f011eab5:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011eabc:	7f 2b                	jg     f011eae9 <atomic_readline+0xa5>
				if (echoing)
f011eabe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011eac2:	74 0e                	je     f011ead2 <atomic_readline+0x8e>
					cputchar(c);
f011eac4:	83 ec 0c             	sub    $0xc,%esp
f011eac7:	ff 75 ec             	pushl  -0x14(%ebp)
f011eaca:	e8 99 23 fe ff       	call   f0100e68 <cputchar>
f011eacf:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011ead2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ead5:	8d 50 01             	lea    0x1(%eax),%edx
f011ead8:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011eadb:	89 c2                	mov    %eax,%edx
f011eadd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eae0:	01 d0                	add    %edx,%eax
f011eae2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011eae5:	88 10                	mov    %dl,(%eax)
f011eae7:	eb 56                	jmp    f011eb3f <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011eae9:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011eaed:	75 1f                	jne    f011eb0e <atomic_readline+0xca>
f011eaef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011eaf3:	7e 19                	jle    f011eb0e <atomic_readline+0xca>
				if (echoing)
f011eaf5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011eaf9:	74 0e                	je     f011eb09 <atomic_readline+0xc5>
					cputchar(c);
f011eafb:	83 ec 0c             	sub    $0xc,%esp
f011eafe:	ff 75 ec             	pushl  -0x14(%ebp)
f011eb01:	e8 62 23 fe ff       	call   f0100e68 <cputchar>
f011eb06:	83 c4 10             	add    $0x10,%esp
				i--;
f011eb09:	ff 4d f4             	decl   -0xc(%ebp)
f011eb0c:	eb 31                	jmp    f011eb3f <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011eb0e:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011eb12:	74 0a                	je     f011eb1e <atomic_readline+0xda>
f011eb14:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011eb18:	0f 85 61 ff ff ff    	jne    f011ea7f <atomic_readline+0x3b>
				if (echoing)
f011eb1e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011eb22:	74 0e                	je     f011eb32 <atomic_readline+0xee>
					cputchar(c);
f011eb24:	83 ec 0c             	sub    $0xc,%esp
f011eb27:	ff 75 ec             	pushl  -0x14(%ebp)
f011eb2a:	e8 39 23 fe ff       	call   f0100e68 <cputchar>
f011eb2f:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011eb32:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011eb35:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eb38:	01 d0                	add    %edx,%eax
f011eb3a:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011eb3d:	eb 06                	jmp    f011eb45 <atomic_readline+0x101>
			}
		}
f011eb3f:	e9 3b ff ff ff       	jmp    f011ea7f <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011eb44:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011eb45:	e8 59 ed fe ff       	call   f010d8a3 <sys_unlock_cons>
}
f011eb4a:	90                   	nop
f011eb4b:	c9                   	leave  
f011eb4c:	c3                   	ret    

f011eb4d <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011eb4d:	55                   	push   %ebp
f011eb4e:	89 e5                	mov    %esp,%ebp
f011eb50:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011eb53:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011eb5a:	eb 06                	jmp    f011eb62 <strlen+0x15>
		n++;
f011eb5c:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011eb5f:	ff 45 08             	incl   0x8(%ebp)
f011eb62:	8b 45 08             	mov    0x8(%ebp),%eax
f011eb65:	8a 00                	mov    (%eax),%al
f011eb67:	84 c0                	test   %al,%al
f011eb69:	75 f1                	jne    f011eb5c <strlen+0xf>
		n++;
	return n;
f011eb6b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011eb6e:	c9                   	leave  
f011eb6f:	c3                   	ret    

f011eb70 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011eb70:	55                   	push   %ebp
f011eb71:	89 e5                	mov    %esp,%ebp
f011eb73:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011eb76:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011eb7d:	eb 09                	jmp    f011eb88 <strnlen+0x18>
		n++;
f011eb7f:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011eb82:	ff 45 08             	incl   0x8(%ebp)
f011eb85:	ff 4d 0c             	decl   0xc(%ebp)
f011eb88:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011eb8c:	74 09                	je     f011eb97 <strnlen+0x27>
f011eb8e:	8b 45 08             	mov    0x8(%ebp),%eax
f011eb91:	8a 00                	mov    (%eax),%al
f011eb93:	84 c0                	test   %al,%al
f011eb95:	75 e8                	jne    f011eb7f <strnlen+0xf>
		n++;
	return n;
f011eb97:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011eb9a:	c9                   	leave  
f011eb9b:	c3                   	ret    

f011eb9c <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011eb9c:	55                   	push   %ebp
f011eb9d:	89 e5                	mov    %esp,%ebp
f011eb9f:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011eba2:	8b 45 08             	mov    0x8(%ebp),%eax
f011eba5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011eba8:	90                   	nop
f011eba9:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebac:	8d 50 01             	lea    0x1(%eax),%edx
f011ebaf:	89 55 08             	mov    %edx,0x8(%ebp)
f011ebb2:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ebb5:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ebb8:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ebbb:	8a 12                	mov    (%edx),%dl
f011ebbd:	88 10                	mov    %dl,(%eax)
f011ebbf:	8a 00                	mov    (%eax),%al
f011ebc1:	84 c0                	test   %al,%al
f011ebc3:	75 e4                	jne    f011eba9 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011ebc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ebc8:	c9                   	leave  
f011ebc9:	c3                   	ret    

f011ebca <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011ebca:	55                   	push   %ebp
f011ebcb:	89 e5                	mov    %esp,%ebp
f011ebcd:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011ebd0:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebd3:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011ebd6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ebdd:	eb 1f                	jmp    f011ebfe <strncpy+0x34>
		*dst++ = *src;
f011ebdf:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebe2:	8d 50 01             	lea    0x1(%eax),%edx
f011ebe5:	89 55 08             	mov    %edx,0x8(%ebp)
f011ebe8:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ebeb:	8a 12                	mov    (%edx),%dl
f011ebed:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011ebef:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ebf2:	8a 00                	mov    (%eax),%al
f011ebf4:	84 c0                	test   %al,%al
f011ebf6:	74 03                	je     f011ebfb <strncpy+0x31>
			src++;
f011ebf8:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011ebfb:	ff 45 fc             	incl   -0x4(%ebp)
f011ebfe:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ec01:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ec04:	72 d9                	jb     f011ebdf <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011ec06:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011ec09:	c9                   	leave  
f011ec0a:	c3                   	ret    

f011ec0b <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011ec0b:	55                   	push   %ebp
f011ec0c:	89 e5                	mov    %esp,%ebp
f011ec0e:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011ec11:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec14:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011ec17:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ec1b:	74 30                	je     f011ec4d <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011ec1d:	eb 16                	jmp    f011ec35 <strlcpy+0x2a>
			*dst++ = *src++;
f011ec1f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec22:	8d 50 01             	lea    0x1(%eax),%edx
f011ec25:	89 55 08             	mov    %edx,0x8(%ebp)
f011ec28:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ec2b:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ec2e:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ec31:	8a 12                	mov    (%edx),%dl
f011ec33:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011ec35:	ff 4d 10             	decl   0x10(%ebp)
f011ec38:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ec3c:	74 09                	je     f011ec47 <strlcpy+0x3c>
f011ec3e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ec41:	8a 00                	mov    (%eax),%al
f011ec43:	84 c0                	test   %al,%al
f011ec45:	75 d8                	jne    f011ec1f <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011ec47:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec4a:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011ec4d:	8b 55 08             	mov    0x8(%ebp),%edx
f011ec50:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ec53:	29 c2                	sub    %eax,%edx
f011ec55:	89 d0                	mov    %edx,%eax
}
f011ec57:	c9                   	leave  
f011ec58:	c3                   	ret    

f011ec59 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011ec59:	55                   	push   %ebp
f011ec5a:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011ec5c:	eb 06                	jmp    f011ec64 <strcmp+0xb>
		p++, q++;
f011ec5e:	ff 45 08             	incl   0x8(%ebp)
f011ec61:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011ec64:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec67:	8a 00                	mov    (%eax),%al
f011ec69:	84 c0                	test   %al,%al
f011ec6b:	74 0e                	je     f011ec7b <strcmp+0x22>
f011ec6d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec70:	8a 10                	mov    (%eax),%dl
f011ec72:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ec75:	8a 00                	mov    (%eax),%al
f011ec77:	38 c2                	cmp    %al,%dl
f011ec79:	74 e3                	je     f011ec5e <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011ec7b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec7e:	8a 00                	mov    (%eax),%al
f011ec80:	0f b6 d0             	movzbl %al,%edx
f011ec83:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ec86:	8a 00                	mov    (%eax),%al
f011ec88:	0f b6 c0             	movzbl %al,%eax
f011ec8b:	29 c2                	sub    %eax,%edx
f011ec8d:	89 d0                	mov    %edx,%eax
}
f011ec8f:	5d                   	pop    %ebp
f011ec90:	c3                   	ret    

f011ec91 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011ec91:	55                   	push   %ebp
f011ec92:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011ec94:	eb 09                	jmp    f011ec9f <strncmp+0xe>
		n--, p++, q++;
f011ec96:	ff 4d 10             	decl   0x10(%ebp)
f011ec99:	ff 45 08             	incl   0x8(%ebp)
f011ec9c:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011ec9f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011eca3:	74 17                	je     f011ecbc <strncmp+0x2b>
f011eca5:	8b 45 08             	mov    0x8(%ebp),%eax
f011eca8:	8a 00                	mov    (%eax),%al
f011ecaa:	84 c0                	test   %al,%al
f011ecac:	74 0e                	je     f011ecbc <strncmp+0x2b>
f011ecae:	8b 45 08             	mov    0x8(%ebp),%eax
f011ecb1:	8a 10                	mov    (%eax),%dl
f011ecb3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ecb6:	8a 00                	mov    (%eax),%al
f011ecb8:	38 c2                	cmp    %al,%dl
f011ecba:	74 da                	je     f011ec96 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011ecbc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ecc0:	75 07                	jne    f011ecc9 <strncmp+0x38>
		return 0;
f011ecc2:	b8 00 00 00 00       	mov    $0x0,%eax
f011ecc7:	eb 14                	jmp    f011ecdd <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011ecc9:	8b 45 08             	mov    0x8(%ebp),%eax
f011eccc:	8a 00                	mov    (%eax),%al
f011ecce:	0f b6 d0             	movzbl %al,%edx
f011ecd1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ecd4:	8a 00                	mov    (%eax),%al
f011ecd6:	0f b6 c0             	movzbl %al,%eax
f011ecd9:	29 c2                	sub    %eax,%edx
f011ecdb:	89 d0                	mov    %edx,%eax
}
f011ecdd:	5d                   	pop    %ebp
f011ecde:	c3                   	ret    

f011ecdf <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011ecdf:	55                   	push   %ebp
f011ece0:	89 e5                	mov    %esp,%ebp
f011ece2:	83 ec 04             	sub    $0x4,%esp
f011ece5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ece8:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011eceb:	eb 12                	jmp    f011ecff <strchr+0x20>
		if (*s == c)
f011eced:	8b 45 08             	mov    0x8(%ebp),%eax
f011ecf0:	8a 00                	mov    (%eax),%al
f011ecf2:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011ecf5:	75 05                	jne    f011ecfc <strchr+0x1d>
			return (char *) s;
f011ecf7:	8b 45 08             	mov    0x8(%ebp),%eax
f011ecfa:	eb 11                	jmp    f011ed0d <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011ecfc:	ff 45 08             	incl   0x8(%ebp)
f011ecff:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed02:	8a 00                	mov    (%eax),%al
f011ed04:	84 c0                	test   %al,%al
f011ed06:	75 e5                	jne    f011eced <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011ed08:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ed0d:	c9                   	leave  
f011ed0e:	c3                   	ret    

f011ed0f <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011ed0f:	55                   	push   %ebp
f011ed10:	89 e5                	mov    %esp,%ebp
f011ed12:	83 ec 04             	sub    $0x4,%esp
f011ed15:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed18:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011ed1b:	eb 0d                	jmp    f011ed2a <strfind+0x1b>
		if (*s == c)
f011ed1d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed20:	8a 00                	mov    (%eax),%al
f011ed22:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011ed25:	74 0e                	je     f011ed35 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011ed27:	ff 45 08             	incl   0x8(%ebp)
f011ed2a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed2d:	8a 00                	mov    (%eax),%al
f011ed2f:	84 c0                	test   %al,%al
f011ed31:	75 ea                	jne    f011ed1d <strfind+0xe>
f011ed33:	eb 01                	jmp    f011ed36 <strfind+0x27>
		if (*s == c)
			break;
f011ed35:	90                   	nop
	return (char *) s;
f011ed36:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ed39:	c9                   	leave  
f011ed3a:	c3                   	ret    

f011ed3b <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011ed3b:	55                   	push   %ebp
f011ed3c:	89 e5                	mov    %esp,%ebp
f011ed3e:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011ed41:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed44:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011ed47:	8b 45 10             	mov    0x10(%ebp),%eax
f011ed4a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011ed4d:	eb 0e                	jmp    f011ed5d <memset+0x22>
		*p++ = c;
f011ed4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ed52:	8d 50 01             	lea    0x1(%eax),%edx
f011ed55:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011ed58:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ed5b:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011ed5d:	ff 4d f8             	decl   -0x8(%ebp)
f011ed60:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011ed64:	79 e9                	jns    f011ed4f <memset+0x14>
		*p++ = c;

	return v;
f011ed66:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ed69:	c9                   	leave  
f011ed6a:	c3                   	ret    

f011ed6b <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011ed6b:	55                   	push   %ebp
f011ed6c:	89 e5                	mov    %esp,%ebp
f011ed6e:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011ed71:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed74:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ed77:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed7a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011ed7d:	eb 16                	jmp    f011ed95 <memcpy+0x2a>
		*d++ = *s++;
f011ed7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ed82:	8d 50 01             	lea    0x1(%eax),%edx
f011ed85:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ed88:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ed8b:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ed8e:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011ed91:	8a 12                	mov    (%edx),%dl
f011ed93:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011ed95:	8b 45 10             	mov    0x10(%ebp),%eax
f011ed98:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ed9b:	89 55 10             	mov    %edx,0x10(%ebp)
f011ed9e:	85 c0                	test   %eax,%eax
f011eda0:	75 dd                	jne    f011ed7f <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011eda2:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011eda5:	c9                   	leave  
f011eda6:	c3                   	ret    

f011eda7 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011eda7:	55                   	push   %ebp
f011eda8:	89 e5                	mov    %esp,%ebp
f011edaa:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011edad:	8b 45 0c             	mov    0xc(%ebp),%eax
f011edb0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011edb3:	8b 45 08             	mov    0x8(%ebp),%eax
f011edb6:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011edb9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011edbc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011edbf:	73 50                	jae    f011ee11 <memmove+0x6a>
f011edc1:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011edc4:	8b 45 10             	mov    0x10(%ebp),%eax
f011edc7:	01 d0                	add    %edx,%eax
f011edc9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011edcc:	76 43                	jbe    f011ee11 <memmove+0x6a>
		s += n;
f011edce:	8b 45 10             	mov    0x10(%ebp),%eax
f011edd1:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011edd4:	8b 45 10             	mov    0x10(%ebp),%eax
f011edd7:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011edda:	eb 10                	jmp    f011edec <memmove+0x45>
			*--d = *--s;
f011eddc:	ff 4d f8             	decl   -0x8(%ebp)
f011eddf:	ff 4d fc             	decl   -0x4(%ebp)
f011ede2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ede5:	8a 10                	mov    (%eax),%dl
f011ede7:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011edea:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011edec:	8b 45 10             	mov    0x10(%ebp),%eax
f011edef:	8d 50 ff             	lea    -0x1(%eax),%edx
f011edf2:	89 55 10             	mov    %edx,0x10(%ebp)
f011edf5:	85 c0                	test   %eax,%eax
f011edf7:	75 e3                	jne    f011eddc <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011edf9:	eb 23                	jmp    f011ee1e <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011edfb:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011edfe:	8d 50 01             	lea    0x1(%eax),%edx
f011ee01:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ee04:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ee07:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ee0a:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011ee0d:	8a 12                	mov    (%edx),%dl
f011ee0f:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011ee11:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee14:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ee17:	89 55 10             	mov    %edx,0x10(%ebp)
f011ee1a:	85 c0                	test   %eax,%eax
f011ee1c:	75 dd                	jne    f011edfb <memmove+0x54>
			*d++ = *s++;

	return dst;
f011ee1e:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ee21:	c9                   	leave  
f011ee22:	c3                   	ret    

f011ee23 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011ee23:	55                   	push   %ebp
f011ee24:	89 e5                	mov    %esp,%ebp
f011ee26:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011ee29:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee2c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011ee2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ee32:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011ee35:	eb 2a                	jmp    f011ee61 <memcmp+0x3e>
		if (*s1 != *s2)
f011ee37:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ee3a:	8a 10                	mov    (%eax),%dl
f011ee3c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ee3f:	8a 00                	mov    (%eax),%al
f011ee41:	38 c2                	cmp    %al,%dl
f011ee43:	74 16                	je     f011ee5b <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011ee45:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ee48:	8a 00                	mov    (%eax),%al
f011ee4a:	0f b6 d0             	movzbl %al,%edx
f011ee4d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ee50:	8a 00                	mov    (%eax),%al
f011ee52:	0f b6 c0             	movzbl %al,%eax
f011ee55:	29 c2                	sub    %eax,%edx
f011ee57:	89 d0                	mov    %edx,%eax
f011ee59:	eb 18                	jmp    f011ee73 <memcmp+0x50>
		s1++, s2++;
f011ee5b:	ff 45 fc             	incl   -0x4(%ebp)
f011ee5e:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011ee61:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee64:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ee67:	89 55 10             	mov    %edx,0x10(%ebp)
f011ee6a:	85 c0                	test   %eax,%eax
f011ee6c:	75 c9                	jne    f011ee37 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011ee6e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ee73:	c9                   	leave  
f011ee74:	c3                   	ret    

f011ee75 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011ee75:	55                   	push   %ebp
f011ee76:	89 e5                	mov    %esp,%ebp
f011ee78:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011ee7b:	8b 55 08             	mov    0x8(%ebp),%edx
f011ee7e:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee81:	01 d0                	add    %edx,%eax
f011ee83:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011ee86:	eb 15                	jmp    f011ee9d <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011ee88:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee8b:	8a 00                	mov    (%eax),%al
f011ee8d:	0f b6 d0             	movzbl %al,%edx
f011ee90:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ee93:	0f b6 c0             	movzbl %al,%eax
f011ee96:	39 c2                	cmp    %eax,%edx
f011ee98:	74 0d                	je     f011eea7 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011ee9a:	ff 45 08             	incl   0x8(%ebp)
f011ee9d:	8b 45 08             	mov    0x8(%ebp),%eax
f011eea0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011eea3:	72 e3                	jb     f011ee88 <memfind+0x13>
f011eea5:	eb 01                	jmp    f011eea8 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011eea7:	90                   	nop
	return (void *) s;
f011eea8:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011eeab:	c9                   	leave  
f011eeac:	c3                   	ret    

f011eead <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011eead:	55                   	push   %ebp
f011eeae:	89 e5                	mov    %esp,%ebp
f011eeb0:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011eeb3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011eeba:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011eec1:	eb 03                	jmp    f011eec6 <strtol+0x19>
		s++;
f011eec3:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011eec6:	8b 45 08             	mov    0x8(%ebp),%eax
f011eec9:	8a 00                	mov    (%eax),%al
f011eecb:	3c 20                	cmp    $0x20,%al
f011eecd:	74 f4                	je     f011eec3 <strtol+0x16>
f011eecf:	8b 45 08             	mov    0x8(%ebp),%eax
f011eed2:	8a 00                	mov    (%eax),%al
f011eed4:	3c 09                	cmp    $0x9,%al
f011eed6:	74 eb                	je     f011eec3 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011eed8:	8b 45 08             	mov    0x8(%ebp),%eax
f011eedb:	8a 00                	mov    (%eax),%al
f011eedd:	3c 2b                	cmp    $0x2b,%al
f011eedf:	75 05                	jne    f011eee6 <strtol+0x39>
		s++;
f011eee1:	ff 45 08             	incl   0x8(%ebp)
f011eee4:	eb 13                	jmp    f011eef9 <strtol+0x4c>
	else if (*s == '-')
f011eee6:	8b 45 08             	mov    0x8(%ebp),%eax
f011eee9:	8a 00                	mov    (%eax),%al
f011eeeb:	3c 2d                	cmp    $0x2d,%al
f011eeed:	75 0a                	jne    f011eef9 <strtol+0x4c>
		s++, neg = 1;
f011eeef:	ff 45 08             	incl   0x8(%ebp)
f011eef2:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011eef9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011eefd:	74 06                	je     f011ef05 <strtol+0x58>
f011eeff:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011ef03:	75 20                	jne    f011ef25 <strtol+0x78>
f011ef05:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef08:	8a 00                	mov    (%eax),%al
f011ef0a:	3c 30                	cmp    $0x30,%al
f011ef0c:	75 17                	jne    f011ef25 <strtol+0x78>
f011ef0e:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef11:	40                   	inc    %eax
f011ef12:	8a 00                	mov    (%eax),%al
f011ef14:	3c 78                	cmp    $0x78,%al
f011ef16:	75 0d                	jne    f011ef25 <strtol+0x78>
		s += 2, base = 16;
f011ef18:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011ef1c:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011ef23:	eb 28                	jmp    f011ef4d <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011ef25:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ef29:	75 15                	jne    f011ef40 <strtol+0x93>
f011ef2b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef2e:	8a 00                	mov    (%eax),%al
f011ef30:	3c 30                	cmp    $0x30,%al
f011ef32:	75 0c                	jne    f011ef40 <strtol+0x93>
		s++, base = 8;
f011ef34:	ff 45 08             	incl   0x8(%ebp)
f011ef37:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011ef3e:	eb 0d                	jmp    f011ef4d <strtol+0xa0>
	else if (base == 0)
f011ef40:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ef44:	75 07                	jne    f011ef4d <strtol+0xa0>
		base = 10;
f011ef46:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011ef4d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef50:	8a 00                	mov    (%eax),%al
f011ef52:	3c 2f                	cmp    $0x2f,%al
f011ef54:	7e 19                	jle    f011ef6f <strtol+0xc2>
f011ef56:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef59:	8a 00                	mov    (%eax),%al
f011ef5b:	3c 39                	cmp    $0x39,%al
f011ef5d:	7f 10                	jg     f011ef6f <strtol+0xc2>
			dig = *s - '0';
f011ef5f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef62:	8a 00                	mov    (%eax),%al
f011ef64:	0f be c0             	movsbl %al,%eax
f011ef67:	83 e8 30             	sub    $0x30,%eax
f011ef6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ef6d:	eb 42                	jmp    f011efb1 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011ef6f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef72:	8a 00                	mov    (%eax),%al
f011ef74:	3c 60                	cmp    $0x60,%al
f011ef76:	7e 19                	jle    f011ef91 <strtol+0xe4>
f011ef78:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef7b:	8a 00                	mov    (%eax),%al
f011ef7d:	3c 7a                	cmp    $0x7a,%al
f011ef7f:	7f 10                	jg     f011ef91 <strtol+0xe4>
			dig = *s - 'a' + 10;
f011ef81:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef84:	8a 00                	mov    (%eax),%al
f011ef86:	0f be c0             	movsbl %al,%eax
f011ef89:	83 e8 57             	sub    $0x57,%eax
f011ef8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ef8f:	eb 20                	jmp    f011efb1 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f011ef91:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef94:	8a 00                	mov    (%eax),%al
f011ef96:	3c 40                	cmp    $0x40,%al
f011ef98:	7e 39                	jle    f011efd3 <strtol+0x126>
f011ef9a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef9d:	8a 00                	mov    (%eax),%al
f011ef9f:	3c 5a                	cmp    $0x5a,%al
f011efa1:	7f 30                	jg     f011efd3 <strtol+0x126>
			dig = *s - 'A' + 10;
f011efa3:	8b 45 08             	mov    0x8(%ebp),%eax
f011efa6:	8a 00                	mov    (%eax),%al
f011efa8:	0f be c0             	movsbl %al,%eax
f011efab:	83 e8 37             	sub    $0x37,%eax
f011efae:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f011efb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011efb4:	3b 45 10             	cmp    0x10(%ebp),%eax
f011efb7:	7d 19                	jge    f011efd2 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f011efb9:	ff 45 08             	incl   0x8(%ebp)
f011efbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011efbf:	0f af 45 10          	imul   0x10(%ebp),%eax
f011efc3:	89 c2                	mov    %eax,%edx
f011efc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011efc8:	01 d0                	add    %edx,%eax
f011efca:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f011efcd:	e9 7b ff ff ff       	jmp    f011ef4d <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f011efd2:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f011efd3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011efd7:	74 08                	je     f011efe1 <strtol+0x134>
		*endptr = (char *) s;
f011efd9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011efdc:	8b 55 08             	mov    0x8(%ebp),%edx
f011efdf:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f011efe1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011efe5:	74 07                	je     f011efee <strtol+0x141>
f011efe7:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011efea:	f7 d8                	neg    %eax
f011efec:	eb 03                	jmp    f011eff1 <strtol+0x144>
f011efee:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011eff1:	c9                   	leave  
f011eff2:	c3                   	ret    

f011eff3 <ltostr>:

void
ltostr(long value, char *str)
{
f011eff3:	55                   	push   %ebp
f011eff4:	89 e5                	mov    %esp,%ebp
f011eff6:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f011eff9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f011f000:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f011f007:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f00b:	79 13                	jns    f011f020 <ltostr+0x2d>
	{
		neg = 1;
f011f00d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f011f014:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f017:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f011f01a:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f011f01d:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f011f020:	8b 45 08             	mov    0x8(%ebp),%eax
f011f023:	b9 0a 00 00 00       	mov    $0xa,%ecx
f011f028:	99                   	cltd   
f011f029:	f7 f9                	idiv   %ecx
f011f02b:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f011f02e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f031:	8d 50 01             	lea    0x1(%eax),%edx
f011f034:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011f037:	89 c2                	mov    %eax,%edx
f011f039:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f03c:	01 d0                	add    %edx,%eax
f011f03e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f041:	83 c2 30             	add    $0x30,%edx
f011f044:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f011f046:	8b 4d 08             	mov    0x8(%ebp),%ecx
f011f049:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011f04e:	f7 e9                	imul   %ecx
f011f050:	c1 fa 02             	sar    $0x2,%edx
f011f053:	89 c8                	mov    %ecx,%eax
f011f055:	c1 f8 1f             	sar    $0x1f,%eax
f011f058:	29 c2                	sub    %eax,%edx
f011f05a:	89 d0                	mov    %edx,%eax
f011f05c:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f011f05f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f063:	75 bb                	jne    f011f020 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f011f065:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f011f06c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f06f:	48                   	dec    %eax
f011f070:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f011f073:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011f077:	74 3d                	je     f011f0b6 <ltostr+0xc3>
		start = 1 ;
f011f079:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f011f080:	eb 34                	jmp    f011f0b6 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f011f082:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f085:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f088:	01 d0                	add    %edx,%eax
f011f08a:	8a 00                	mov    (%eax),%al
f011f08c:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f011f08f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f092:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f095:	01 c2                	add    %eax,%edx
f011f097:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f011f09a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f09d:	01 c8                	add    %ecx,%eax
f011f09f:	8a 00                	mov    (%eax),%al
f011f0a1:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f011f0a3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f0a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f0a9:	01 c2                	add    %eax,%edx
f011f0ab:	8a 45 eb             	mov    -0x15(%ebp),%al
f011f0ae:	88 02                	mov    %al,(%edx)
		start++ ;
f011f0b0:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f011f0b3:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f011f0b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f0b9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f0bc:	7c c4                	jl     f011f082 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f011f0be:	8b 55 f8             	mov    -0x8(%ebp),%edx
f011f0c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f0c4:	01 d0                	add    %edx,%eax
f011f0c6:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f011f0c9:	90                   	nop
f011f0ca:	c9                   	leave  
f011f0cb:	c3                   	ret    

f011f0cc <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f011f0cc:	55                   	push   %ebp
f011f0cd:	89 e5                	mov    %esp,%ebp
f011f0cf:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f011f0d2:	ff 75 08             	pushl  0x8(%ebp)
f011f0d5:	e8 73 fa ff ff       	call   f011eb4d <strlen>
f011f0da:	83 c4 04             	add    $0x4,%esp
f011f0dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f011f0e0:	ff 75 0c             	pushl  0xc(%ebp)
f011f0e3:	e8 65 fa ff ff       	call   f011eb4d <strlen>
f011f0e8:	83 c4 04             	add    $0x4,%esp
f011f0eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f011f0ee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f011f0f5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f0fc:	eb 17                	jmp    f011f115 <strcconcat+0x49>
		final[s] = str1[s] ;
f011f0fe:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f101:	8b 45 10             	mov    0x10(%ebp),%eax
f011f104:	01 c2                	add    %eax,%edx
f011f106:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011f109:	8b 45 08             	mov    0x8(%ebp),%eax
f011f10c:	01 c8                	add    %ecx,%eax
f011f10e:	8a 00                	mov    (%eax),%al
f011f110:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f011f112:	ff 45 fc             	incl   -0x4(%ebp)
f011f115:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f118:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f11b:	7c e1                	jl     f011f0fe <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f011f11d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f011f124:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f011f12b:	eb 1f                	jmp    f011f14c <strcconcat+0x80>
		final[s++] = str2[i] ;
f011f12d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f130:	8d 50 01             	lea    0x1(%eax),%edx
f011f133:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011f136:	89 c2                	mov    %eax,%edx
f011f138:	8b 45 10             	mov    0x10(%ebp),%eax
f011f13b:	01 c2                	add    %eax,%edx
f011f13d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011f140:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f143:	01 c8                	add    %ecx,%eax
f011f145:	8a 00                	mov    (%eax),%al
f011f147:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f011f149:	ff 45 f8             	incl   -0x8(%ebp)
f011f14c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f14f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f152:	7c d9                	jl     f011f12d <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f011f154:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f157:	8b 45 10             	mov    0x10(%ebp),%eax
f011f15a:	01 d0                	add    %edx,%eax
f011f15c:	c6 00 00             	movb   $0x0,(%eax)
}
f011f15f:	90                   	nop
f011f160:	c9                   	leave  
f011f161:	c3                   	ret    

f011f162 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f011f162:	55                   	push   %ebp
f011f163:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f011f165:	8b 45 14             	mov    0x14(%ebp),%eax
f011f168:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f011f16e:	8b 45 14             	mov    0x14(%ebp),%eax
f011f171:	8b 00                	mov    (%eax),%eax
f011f173:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f17a:	8b 45 10             	mov    0x10(%ebp),%eax
f011f17d:	01 d0                	add    %edx,%eax
f011f17f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011f185:	eb 0c                	jmp    f011f193 <strsplit+0x31>
			*string++ = 0;
f011f187:	8b 45 08             	mov    0x8(%ebp),%eax
f011f18a:	8d 50 01             	lea    0x1(%eax),%edx
f011f18d:	89 55 08             	mov    %edx,0x8(%ebp)
f011f190:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011f193:	8b 45 08             	mov    0x8(%ebp),%eax
f011f196:	8a 00                	mov    (%eax),%al
f011f198:	84 c0                	test   %al,%al
f011f19a:	74 18                	je     f011f1b4 <strsplit+0x52>
f011f19c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f19f:	8a 00                	mov    (%eax),%al
f011f1a1:	0f be c0             	movsbl %al,%eax
f011f1a4:	50                   	push   %eax
f011f1a5:	ff 75 0c             	pushl  0xc(%ebp)
f011f1a8:	e8 32 fb ff ff       	call   f011ecdf <strchr>
f011f1ad:	83 c4 08             	add    $0x8,%esp
f011f1b0:	85 c0                	test   %eax,%eax
f011f1b2:	75 d3                	jne    f011f187 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f011f1b4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1b7:	8a 00                	mov    (%eax),%al
f011f1b9:	84 c0                	test   %al,%al
f011f1bb:	74 5a                	je     f011f217 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f011f1bd:	8b 45 14             	mov    0x14(%ebp),%eax
f011f1c0:	8b 00                	mov    (%eax),%eax
f011f1c2:	83 f8 0f             	cmp    $0xf,%eax
f011f1c5:	75 07                	jne    f011f1ce <strsplit+0x6c>
		{
			return 0;
f011f1c7:	b8 00 00 00 00       	mov    $0x0,%eax
f011f1cc:	eb 66                	jmp    f011f234 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f011f1ce:	8b 45 14             	mov    0x14(%ebp),%eax
f011f1d1:	8b 00                	mov    (%eax),%eax
f011f1d3:	8d 48 01             	lea    0x1(%eax),%ecx
f011f1d6:	8b 55 14             	mov    0x14(%ebp),%edx
f011f1d9:	89 0a                	mov    %ecx,(%edx)
f011f1db:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f1e2:	8b 45 10             	mov    0x10(%ebp),%eax
f011f1e5:	01 c2                	add    %eax,%edx
f011f1e7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1ea:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f011f1ec:	eb 03                	jmp    f011f1f1 <strsplit+0x8f>
			string++;
f011f1ee:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f011f1f1:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1f4:	8a 00                	mov    (%eax),%al
f011f1f6:	84 c0                	test   %al,%al
f011f1f8:	74 8b                	je     f011f185 <strsplit+0x23>
f011f1fa:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1fd:	8a 00                	mov    (%eax),%al
f011f1ff:	0f be c0             	movsbl %al,%eax
f011f202:	50                   	push   %eax
f011f203:	ff 75 0c             	pushl  0xc(%ebp)
f011f206:	e8 d4 fa ff ff       	call   f011ecdf <strchr>
f011f20b:	83 c4 08             	add    $0x8,%esp
f011f20e:	85 c0                	test   %eax,%eax
f011f210:	74 dc                	je     f011f1ee <strsplit+0x8c>
			string++;
	}
f011f212:	e9 6e ff ff ff       	jmp    f011f185 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f011f217:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f011f218:	8b 45 14             	mov    0x14(%ebp),%eax
f011f21b:	8b 00                	mov    (%eax),%eax
f011f21d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f224:	8b 45 10             	mov    0x10(%ebp),%eax
f011f227:	01 d0                	add    %edx,%eax
f011f229:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f011f22f:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011f234:	c9                   	leave  
f011f235:	c3                   	ret    

f011f236 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f011f236:	55                   	push   %ebp
f011f237:	89 e5                	mov    %esp,%ebp
f011f239:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f011f23c:	83 ec 04             	sub    $0x4,%esp
f011f23f:	68 dc 03 13 f0       	push   $0xf01303dc
f011f244:	68 3f 01 00 00       	push   $0x13f
f011f249:	68 fe 03 13 f0       	push   $0xf01303fe
f011f24e:	e8 e6 10 fe ff       	call   f0100339 <_panic>

f011f253 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f011f253:	55                   	push   %ebp
f011f254:	89 e5                	mov    %esp,%ebp
f011f256:	83 ec 18             	sub    $0x18,%esp
f011f259:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011f260:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f263:	89 c2                	mov    %eax,%edx
f011f265:	ec                   	in     (%dx),%al
f011f266:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011f269:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011f26c:	0f b6 c0             	movzbl %al,%eax
f011f26f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f272:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f275:	25 c0 00 00 00       	and    $0xc0,%eax
f011f27a:	83 f8 40             	cmp    $0x40,%eax
f011f27d:	75 10                	jne    f011f28f <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f011f27f:	83 ec 0c             	sub    $0xc,%esp
f011f282:	68 c0 41 5f f0       	push   $0xf05f41c0
f011f287:	e8 5a fd fe ff       	call   f010efe6 <wakeup_one>
f011f28c:	83 c4 10             	add    $0x10,%esp
	}

}
f011f28f:	90                   	nop
f011f290:	c9                   	leave  
f011f291:	c3                   	ret    

f011f292 <ide_init>:

void ide_init()
{
f011f292:	55                   	push   %ebp
f011f293:	89 e5                	mov    %esp,%ebp
f011f295:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f011f298:	83 ec 08             	sub    $0x8,%esp
f011f29b:	68 53 f2 11 f0       	push   $0xf011f253
f011f2a0:	6a 0e                	push   $0xe
f011f2a2:	e8 f5 e0 fe ff       	call   f010d39c <irq_install_handler>
f011f2a7:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f011f2aa:	83 ec 08             	sub    $0x8,%esp
f011f2ad:	68 0c 04 13 f0       	push   $0xf013040c
f011f2b2:	68 c0 41 5f f0       	push   $0xf05f41c0
f011f2b7:	e8 90 fc fe ff       	call   f010ef4c <init_channel>
f011f2bc:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f011f2bf:	83 ec 08             	sub    $0x8,%esp
f011f2c2:	68 19 04 13 f0       	push   $0xf0130419
f011f2c7:	68 e0 47 5f f0       	push   $0xf05f47e0
f011f2cc:	e8 8a f8 fe ff       	call   f010eb5b <init_spinlock>
f011f2d1:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f011f2d4:	90                   	nop
f011f2d5:	c9                   	leave  
f011f2d6:	c3                   	ret    

f011f2d7 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f011f2d7:	55                   	push   %ebp
f011f2d8:	89 e5                	mov    %esp,%ebp
f011f2da:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011f2dd:	90                   	nop
f011f2de:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011f2e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f2e8:	89 c2                	mov    %eax,%edx
f011f2ea:	ec                   	in     (%dx),%al
f011f2eb:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011f2ee:	8a 45 ef             	mov    -0x11(%ebp),%al
f011f2f1:	0f b6 c0             	movzbl %al,%eax
f011f2f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f2f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f2fa:	25 c0 00 00 00       	and    $0xc0,%eax
f011f2ff:	83 f8 40             	cmp    $0x40,%eax
f011f302:	75 da                	jne    f011f2de <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f011f304:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f308:	74 24                	je     f011f32e <ide_wait_ready+0x57>
f011f30a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f30d:	83 e0 21             	and    $0x21,%eax
f011f310:	85 c0                	test   %eax,%eax
f011f312:	74 1a                	je     f011f32e <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f011f314:	83 ec 0c             	sub    $0xc,%esp
f011f317:	ff 75 f4             	pushl  -0xc(%ebp)
f011f31a:	ff 75 f4             	pushl  -0xc(%ebp)
f011f31d:	68 2c 04 13 f0       	push   $0xf013042c
f011f322:	6a 5d                	push   $0x5d
f011f324:	68 4f 04 13 f0       	push   $0xf013044f
f011f329:	e8 0b 10 fe ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f011f32e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f333:	c9                   	leave  
f011f334:	c3                   	ret    

f011f335 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f011f335:	55                   	push   %ebp
f011f336:	89 e5                	mov    %esp,%ebp
f011f338:	57                   	push   %edi
f011f339:	53                   	push   %ebx
f011f33a:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f011f33d:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011f344:	76 16                	jbe    f011f35c <ide_read+0x27>
f011f346:	68 5a 04 13 f0       	push   $0xf013045a
f011f34b:	68 67 04 13 f0       	push   $0xf0130467
f011f350:	6a 68                	push   $0x68
f011f352:	68 4f 04 13 f0       	push   $0xf013044f
f011f357:	e8 dd 0f fe ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f011f35c:	83 ec 0c             	sub    $0xc,%esp
f011f35f:	6a 00                	push   $0x0
f011f361:	e8 71 ff ff ff       	call   f011f2d7 <ide_wait_ready>
f011f366:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f011f369:	8b 45 10             	mov    0x10(%ebp),%eax
f011f36c:	0f b6 c0             	movzbl %al,%eax
f011f36f:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011f376:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011f379:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011f37c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f37f:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011f380:	8b 45 08             	mov    0x8(%ebp),%eax
f011f383:	0f b6 c0             	movzbl %al,%eax
f011f386:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011f38d:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011f390:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011f393:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f396:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011f397:	8b 45 08             	mov    0x8(%ebp),%eax
f011f39a:	c1 e8 08             	shr    $0x8,%eax
f011f39d:	0f b6 c0             	movzbl %al,%eax
f011f3a0:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011f3a7:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011f3aa:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011f3ad:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f3b0:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011f3b1:	8b 45 08             	mov    0x8(%ebp),%eax
f011f3b4:	c1 e8 10             	shr    $0x10,%eax
f011f3b7:	0f b6 c0             	movzbl %al,%eax
f011f3ba:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011f3c1:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011f3c4:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011f3c7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011f3ca:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011f3cb:	a1 70 40 5f f0       	mov    0xf05f4070,%eax
f011f3d0:	83 e0 01             	and    $0x1,%eax
f011f3d3:	c1 e0 04             	shl    $0x4,%eax
f011f3d6:	88 c2                	mov    %al,%dl
f011f3d8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f3db:	c1 e8 18             	shr    $0x18,%eax
f011f3de:	83 e0 0f             	and    $0xf,%eax
f011f3e1:	09 d0                	or     %edx,%eax
f011f3e3:	83 c8 e0             	or     $0xffffffe0,%eax
f011f3e6:	0f b6 c0             	movzbl %al,%eax
f011f3e9:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011f3f0:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011f3f3:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011f3f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f3f9:	ee                   	out    %al,(%dx)
f011f3fa:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011f401:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f011f405:	8a 45 d7             	mov    -0x29(%ebp),%al
f011f408:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011f40b:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011f40c:	eb 55                	jmp    f011f463 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f011f40e:	83 ec 0c             	sub    $0xc,%esp
f011f411:	6a 01                	push   $0x1
f011f413:	e8 bf fe ff ff       	call   f011f2d7 <ide_wait_ready>
f011f418:	83 c4 10             	add    $0x10,%esp
f011f41b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f41e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f422:	79 05                	jns    f011f429 <ide_read+0xf4>
			return r;
f011f424:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f427:	eb 45                	jmp    f011f46e <ide_read+0x139>
f011f429:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011f430:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f433:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011f436:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f011f43d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f440:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011f443:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011f446:	89 cb                	mov    %ecx,%ebx
f011f448:	89 df                	mov    %ebx,%edi
f011f44a:	89 c1                	mov    %eax,%ecx
f011f44c:	fc                   	cld    
f011f44d:	f2 6d                	repnz insl (%dx),%es:(%edi)
f011f44f:	89 c8                	mov    %ecx,%eax
f011f451:	89 fb                	mov    %edi,%ebx
f011f453:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011f456:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011f459:	ff 4d 10             	decl   0x10(%ebp)
f011f45c:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011f463:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f467:	75 a5                	jne    f011f40e <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f011f469:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f46e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f471:	5b                   	pop    %ebx
f011f472:	5f                   	pop    %edi
f011f473:	5d                   	pop    %ebp
f011f474:	c3                   	ret    

f011f475 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f011f475:	55                   	push   %ebp
f011f476:	89 e5                	mov    %esp,%ebp
f011f478:	56                   	push   %esi
f011f479:	53                   	push   %ebx
f011f47a:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f011f47d:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011f484:	76 19                	jbe    f011f49f <ide_write+0x2a>
f011f486:	68 5a 04 13 f0       	push   $0xf013045a
f011f48b:	68 67 04 13 f0       	push   $0xf0130467
f011f490:	68 82 00 00 00       	push   $0x82
f011f495:	68 4f 04 13 f0       	push   $0xf013044f
f011f49a:	e8 9a 0e fe ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f011f49f:	83 ec 0c             	sub    $0xc,%esp
f011f4a2:	6a 00                	push   $0x0
f011f4a4:	e8 2e fe ff ff       	call   f011f2d7 <ide_wait_ready>
f011f4a9:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f011f4ac:	8b 45 10             	mov    0x10(%ebp),%eax
f011f4af:	0f b6 c0             	movzbl %al,%eax
f011f4b2:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011f4b9:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011f4bc:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011f4bf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f4c2:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011f4c3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4c6:	0f b6 c0             	movzbl %al,%eax
f011f4c9:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011f4d0:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011f4d3:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011f4d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f4d9:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011f4da:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4dd:	c1 e8 08             	shr    $0x8,%eax
f011f4e0:	0f b6 c0             	movzbl %al,%eax
f011f4e3:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011f4ea:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011f4ed:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011f4f0:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f4f3:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011f4f4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4f7:	c1 e8 10             	shr    $0x10,%eax
f011f4fa:	0f b6 c0             	movzbl %al,%eax
f011f4fd:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011f504:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011f507:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011f50a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011f50d:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011f50e:	a1 70 40 5f f0       	mov    0xf05f4070,%eax
f011f513:	83 e0 01             	and    $0x1,%eax
f011f516:	c1 e0 04             	shl    $0x4,%eax
f011f519:	88 c2                	mov    %al,%dl
f011f51b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f51e:	c1 e8 18             	shr    $0x18,%eax
f011f521:	83 e0 0f             	and    $0xf,%eax
f011f524:	09 d0                	or     %edx,%eax
f011f526:	83 c8 e0             	or     $0xffffffe0,%eax
f011f529:	0f b6 c0             	movzbl %al,%eax
f011f52c:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011f533:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011f536:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011f539:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f53c:	ee                   	out    %al,(%dx)
f011f53d:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011f544:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f011f548:	8a 45 d7             	mov    -0x29(%ebp),%al
f011f54b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011f54e:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011f54f:	eb 55                	jmp    f011f5a6 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f011f551:	83 ec 0c             	sub    $0xc,%esp
f011f554:	6a 01                	push   $0x1
f011f556:	e8 7c fd ff ff       	call   f011f2d7 <ide_wait_ready>
f011f55b:	83 c4 10             	add    $0x10,%esp
f011f55e:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f561:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f565:	79 05                	jns    f011f56c <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f011f567:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f56a:	eb 45                	jmp    f011f5b1 <ide_write+0x13c>
f011f56c:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011f573:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f576:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011f579:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f011f580:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f583:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011f586:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011f589:	89 cb                	mov    %ecx,%ebx
f011f58b:	89 de                	mov    %ebx,%esi
f011f58d:	89 c1                	mov    %eax,%ecx
f011f58f:	fc                   	cld    
f011f590:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f011f592:	89 c8                	mov    %ecx,%eax
f011f594:	89 f3                	mov    %esi,%ebx
f011f596:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011f599:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011f59c:	ff 4d 10             	decl   0x10(%ebp)
f011f59f:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011f5a6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f5aa:	75 a5                	jne    f011f551 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f011f5ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f5b1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f5b4:	5b                   	pop    %ebx
f011f5b5:	5e                   	pop    %esi
f011f5b6:	5d                   	pop    %ebp
f011f5b7:	c3                   	ret    

f011f5b8 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f011f5b8:	55                   	push   %ebp
f011f5b9:	89 e5                	mov    %esp,%ebp
f011f5bb:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f011f5be:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5c1:	83 e8 04             	sub    $0x4,%eax
f011f5c4:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f011f5c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f5ca:	8b 00                	mov    (%eax),%eax
f011f5cc:	83 e0 fe             	and    $0xfffffffe,%eax
}
f011f5cf:	c9                   	leave  
f011f5d0:	c3                   	ret    

f011f5d1 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f011f5d1:	55                   	push   %ebp
f011f5d2:	89 e5                	mov    %esp,%ebp
f011f5d4:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f011f5d7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5da:	83 e8 04             	sub    $0x4,%eax
f011f5dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f011f5e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f5e3:	8b 00                	mov    (%eax),%eax
f011f5e5:	83 e0 01             	and    $0x1,%eax
f011f5e8:	85 c0                	test   %eax,%eax
f011f5ea:	0f 94 c0             	sete   %al
}
f011f5ed:	c9                   	leave  
f011f5ee:	c3                   	ret    

f011f5ef <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f011f5ef:	55                   	push   %ebp
f011f5f0:	89 e5                	mov    %esp,%ebp
f011f5f2:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f011f5f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f011f5fc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f5ff:	83 f8 02             	cmp    $0x2,%eax
f011f602:	74 2b                	je     f011f62f <alloc_block+0x40>
f011f604:	83 f8 02             	cmp    $0x2,%eax
f011f607:	7f 07                	jg     f011f610 <alloc_block+0x21>
f011f609:	83 f8 01             	cmp    $0x1,%eax
f011f60c:	74 0e                	je     f011f61c <alloc_block+0x2d>
f011f60e:	eb 58                	jmp    f011f668 <alloc_block+0x79>
f011f610:	83 f8 03             	cmp    $0x3,%eax
f011f613:	74 2d                	je     f011f642 <alloc_block+0x53>
f011f615:	83 f8 04             	cmp    $0x4,%eax
f011f618:	74 3b                	je     f011f655 <alloc_block+0x66>
f011f61a:	eb 4c                	jmp    f011f668 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f011f61c:	83 ec 0c             	sub    $0xc,%esp
f011f61f:	ff 75 08             	pushl  0x8(%ebp)
f011f622:	e8 3d 03 00 00       	call   f011f964 <alloc_block_FF>
f011f627:	83 c4 10             	add    $0x10,%esp
f011f62a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f62d:	eb 4a                	jmp    f011f679 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f011f62f:	83 ec 0c             	sub    $0xc,%esp
f011f632:	ff 75 08             	pushl  0x8(%ebp)
f011f635:	e8 26 1a 00 00       	call   f0121060 <alloc_block_NF>
f011f63a:	83 c4 10             	add    $0x10,%esp
f011f63d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f640:	eb 37                	jmp    f011f679 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f011f642:	83 ec 0c             	sub    $0xc,%esp
f011f645:	ff 75 08             	pushl  0x8(%ebp)
f011f648:	e8 d3 07 00 00       	call   f011fe20 <alloc_block_BF>
f011f64d:	83 c4 10             	add    $0x10,%esp
f011f650:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f653:	eb 24                	jmp    f011f679 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f011f655:	83 ec 0c             	sub    $0xc,%esp
f011f658:	ff 75 08             	pushl  0x8(%ebp)
f011f65b:	e8 e3 19 00 00       	call   f0121043 <alloc_block_WF>
f011f660:	83 c4 10             	add    $0x10,%esp
f011f663:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f666:	eb 11                	jmp    f011f679 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f011f668:	83 ec 0c             	sub    $0xc,%esp
f011f66b:	68 7c 04 13 f0       	push   $0xf013047c
f011f670:	e8 16 19 fe ff       	call   f0100f8b <cprintf>
f011f675:	83 c4 10             	add    $0x10,%esp
		break;
f011f678:	90                   	nop
	}
	return va;
f011f679:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011f67c:	c9                   	leave  
f011f67d:	c3                   	ret    

f011f67e <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f011f67e:	55                   	push   %ebp
f011f67f:	89 e5                	mov    %esp,%ebp
f011f681:	53                   	push   %ebx
f011f682:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f011f685:	83 ec 0c             	sub    $0xc,%esp
f011f688:	68 9c 04 13 f0       	push   $0xf013049c
f011f68d:	e8 f9 18 fe ff       	call   f0100f8b <cprintf>
f011f692:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f011f695:	83 ec 0c             	sub    $0xc,%esp
f011f698:	68 c7 04 13 f0       	push   $0xf01304c7
f011f69d:	e8 e9 18 fe ff       	call   f0100f8b <cprintf>
f011f6a2:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f011f6a5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f6ab:	eb 37                	jmp    f011f6e4 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f011f6ad:	83 ec 0c             	sub    $0xc,%esp
f011f6b0:	ff 75 f4             	pushl  -0xc(%ebp)
f011f6b3:	e8 19 ff ff ff       	call   f011f5d1 <is_free_block>
f011f6b8:	83 c4 10             	add    $0x10,%esp
f011f6bb:	0f be d8             	movsbl %al,%ebx
f011f6be:	83 ec 0c             	sub    $0xc,%esp
f011f6c1:	ff 75 f4             	pushl  -0xc(%ebp)
f011f6c4:	e8 ef fe ff ff       	call   f011f5b8 <get_block_size>
f011f6c9:	83 c4 10             	add    $0x10,%esp
f011f6cc:	83 ec 04             	sub    $0x4,%esp
f011f6cf:	53                   	push   %ebx
f011f6d0:	50                   	push   %eax
f011f6d1:	68 df 04 13 f0       	push   $0xf01304df
f011f6d6:	e8 b0 18 fe ff       	call   f0100f8b <cprintf>
f011f6db:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f011f6de:	8b 45 10             	mov    0x10(%ebp),%eax
f011f6e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f6e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f6e8:	74 07                	je     f011f6f1 <print_blocks_list+0x73>
f011f6ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f6ed:	8b 00                	mov    (%eax),%eax
f011f6ef:	eb 05                	jmp    f011f6f6 <print_blocks_list+0x78>
f011f6f1:	b8 00 00 00 00       	mov    $0x0,%eax
f011f6f6:	89 45 10             	mov    %eax,0x10(%ebp)
f011f6f9:	8b 45 10             	mov    0x10(%ebp),%eax
f011f6fc:	85 c0                	test   %eax,%eax
f011f6fe:	75 ad                	jne    f011f6ad <print_blocks_list+0x2f>
f011f700:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f704:	75 a7                	jne    f011f6ad <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f011f706:	83 ec 0c             	sub    $0xc,%esp
f011f709:	68 9c 04 13 f0       	push   $0xf013049c
f011f70e:	e8 78 18 fe ff       	call   f0100f8b <cprintf>
f011f713:	83 c4 10             	add    $0x10,%esp

}
f011f716:	90                   	nop
f011f717:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f71a:	c9                   	leave  
f011f71b:	c3                   	ret    

f011f71c <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f011f71c:	55                   	push   %ebp
f011f71d:	89 e5                	mov    %esp,%ebp
f011f71f:	57                   	push   %edi
f011f720:	56                   	push   %esi
f011f721:	53                   	push   %ebx
f011f722:	83 ec 1c             	sub    $0x1c,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f011f725:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f728:	83 e0 01             	and    $0x1,%eax
f011f72b:	85 c0                	test   %eax,%eax
f011f72d:	74 03                	je     f011f732 <initialize_dynamic_allocator+0x16>
f011f72f:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f011f732:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f736:	0f 84 ea 01 00 00    	je     f011f926 <initialize_dynamic_allocator+0x20a>
                return ;
            is_initialized = 1;
f011f73c:	c7 05 74 40 5f f0 01 	movl   $0x1,0xf05f4074
f011f743:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f011f746:	8b 55 08             	mov    0x8(%ebp),%edx
f011f749:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f74c:	01 d0                	add    %edx,%eax
f011f74e:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f011f753:	0f 87 d0 01 00 00    	ja     f011f929 <initialize_dynamic_allocator+0x20d>
        return;
    if(daStart < KERNEL_HEAP_START)
f011f759:	81 7d 08 ff ff ff f5 	cmpl   $0xf5ffffff,0x8(%ebp)
f011f760:	0f 86 c6 01 00 00    	jbe    f011f92c <initialize_dynamic_allocator+0x210>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f011f766:	8b 55 08             	mov    0x8(%ebp),%edx
f011f769:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f76c:	01 d0                	add    %edx,%eax
f011f76e:	83 e8 04             	sub    $0x4,%eax
f011f771:	a3 14 4a 5f f0       	mov    %eax,0xf05f4a14
     struct BlockElement * element = NULL;
f011f776:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f011f77d:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f011f782:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f785:	e9 87 00 00 00       	jmp    f011f811 <initialize_dynamic_allocator+0xf5>
     {
        LIST_REMOVE(&freeBlocksList,element);
f011f78a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f78e:	75 14                	jne    f011f7a4 <initialize_dynamic_allocator+0x88>
f011f790:	83 ec 04             	sub    $0x4,%esp
f011f793:	68 f7 04 13 f0       	push   $0xf01304f7
f011f798:	6a 79                	push   $0x79
f011f79a:	68 15 05 13 f0       	push   $0xf0130515
f011f79f:	e8 95 0b fe ff       	call   f0100339 <_panic>
f011f7a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f7a7:	8b 00                	mov    (%eax),%eax
f011f7a9:	85 c0                	test   %eax,%eax
f011f7ab:	74 10                	je     f011f7bd <initialize_dynamic_allocator+0xa1>
f011f7ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f7b0:	8b 00                	mov    (%eax),%eax
f011f7b2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011f7b5:	8b 52 04             	mov    0x4(%edx),%edx
f011f7b8:	89 50 04             	mov    %edx,0x4(%eax)
f011f7bb:	eb 0b                	jmp    f011f7c8 <initialize_dynamic_allocator+0xac>
f011f7bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f7c0:	8b 40 04             	mov    0x4(%eax),%eax
f011f7c3:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f011f7c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f7cb:	8b 40 04             	mov    0x4(%eax),%eax
f011f7ce:	85 c0                	test   %eax,%eax
f011f7d0:	74 0f                	je     f011f7e1 <initialize_dynamic_allocator+0xc5>
f011f7d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f7d5:	8b 40 04             	mov    0x4(%eax),%eax
f011f7d8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011f7db:	8b 12                	mov    (%edx),%edx
f011f7dd:	89 10                	mov    %edx,(%eax)
f011f7df:	eb 0a                	jmp    f011f7eb <initialize_dynamic_allocator+0xcf>
f011f7e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f7e4:	8b 00                	mov    (%eax),%eax
f011f7e6:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f011f7eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f7ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011f7f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f7f7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011f7fe:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f011f803:	48                   	dec    %eax
f011f804:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
        return;
    if(daStart < KERNEL_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f011f809:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f011f80e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f811:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f815:	74 07                	je     f011f81e <initialize_dynamic_allocator+0x102>
f011f817:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f81a:	8b 00                	mov    (%eax),%eax
f011f81c:	eb 05                	jmp    f011f823 <initialize_dynamic_allocator+0x107>
f011f81e:	b8 00 00 00 00       	mov    $0x0,%eax
f011f823:	a3 f8 43 5f f0       	mov    %eax,0xf05f43f8
f011f828:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f011f82d:	85 c0                	test   %eax,%eax
f011f82f:	0f 85 55 ff ff ff    	jne    f011f78a <initialize_dynamic_allocator+0x6e>
f011f835:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f839:	0f 85 4b ff ff ff    	jne    f011f78a <initialize_dynamic_allocator+0x6e>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f011f83f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f842:	89 45 e0             	mov    %eax,-0x20(%ebp)
    beg_block->info = 1;
f011f845:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f848:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f011f84e:	a1 14 4a 5f f0       	mov    0xf05f4a14,%eax
f011f853:	a3 50 48 5f f0       	mov    %eax,0xf05f4850
    end_block->info = 1;
f011f858:	a1 50 48 5f f0       	mov    0xf05f4850,%eax
f011f85d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f011f863:	8b 45 08             	mov    0x8(%ebp),%eax
f011f866:	83 c0 08             	add    $0x8,%eax
f011f869:	89 45 dc             	mov    %eax,-0x24(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f011f86c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f86f:	83 c0 04             	add    $0x4,%eax
f011f872:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f875:	83 ea 08             	sub    $0x8,%edx
f011f878:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f011f87a:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f87d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f880:	01 d0                	add    %edx,%eax
f011f882:	83 e8 08             	sub    $0x8,%eax
f011f885:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f888:	83 ea 08             	sub    $0x8,%edx
f011f88b:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f011f88d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f890:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f011f896:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f899:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f011f8a0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f8a4:	75 17                	jne    f011f8bd <initialize_dynamic_allocator+0x1a1>
f011f8a6:	83 ec 04             	sub    $0x4,%esp
f011f8a9:	68 30 05 13 f0       	push   $0xf0130530
f011f8ae:	68 90 00 00 00       	push   $0x90
f011f8b3:	68 15 05 13 f0       	push   $0xf0130515
f011f8b8:	e8 7c 0a fe ff       	call   f0100339 <_panic>
f011f8bd:	8b 15 f0 43 5f f0    	mov    0xf05f43f0,%edx
f011f8c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f8c6:	89 10                	mov    %edx,(%eax)
f011f8c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f8cb:	8b 00                	mov    (%eax),%eax
f011f8cd:	85 c0                	test   %eax,%eax
f011f8cf:	74 0d                	je     f011f8de <initialize_dynamic_allocator+0x1c2>
f011f8d1:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f011f8d6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011f8d9:	89 50 04             	mov    %edx,0x4(%eax)
f011f8dc:	eb 08                	jmp    f011f8e6 <initialize_dynamic_allocator+0x1ca>
f011f8de:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f8e1:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f011f8e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f8e9:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f011f8ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f8f1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011f8f8:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f011f8fd:	40                   	inc    %eax
f011f8fe:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
    print_blocks_list(freeBlocksList);
f011f903:	83 ec 10             	sub    $0x10,%esp
f011f906:	89 e0                	mov    %esp,%eax
f011f908:	89 c2                	mov    %eax,%edx
f011f90a:	bb f0 43 5f f0       	mov    $0xf05f43f0,%ebx
f011f90f:	b8 04 00 00 00       	mov    $0x4,%eax
f011f914:	89 d7                	mov    %edx,%edi
f011f916:	89 de                	mov    %ebx,%esi
f011f918:	89 c1                	mov    %eax,%ecx
f011f91a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011f91c:	e8 5d fd ff ff       	call   f011f67e <print_blocks_list>
f011f921:	83 c4 10             	add    $0x10,%esp
f011f924:	eb 07                	jmp    f011f92d <initialize_dynamic_allocator+0x211>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f011f926:	90                   	nop
f011f927:	eb 04                	jmp    f011f92d <initialize_dynamic_allocator+0x211>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f011f929:	90                   	nop
f011f92a:	eb 01                	jmp    f011f92d <initialize_dynamic_allocator+0x211>
    if(daStart < KERNEL_HEAP_START)
        return;
f011f92c:	90                   	nop
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
    print_blocks_list(freeBlocksList);
}
f011f92d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011f930:	5b                   	pop    %ebx
f011f931:	5e                   	pop    %esi
f011f932:	5f                   	pop    %edi
f011f933:	5d                   	pop    %ebp
f011f934:	c3                   	ret    

f011f935 <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f011f935:	55                   	push   %ebp
f011f936:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f011f938:	8b 45 10             	mov    0x10(%ebp),%eax
f011f93b:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f011f93e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f941:	8d 50 fc             	lea    -0x4(%eax),%edx
f011f944:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f947:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f011f949:	8b 45 08             	mov    0x8(%ebp),%eax
f011f94c:	83 e8 04             	sub    $0x4,%eax
f011f94f:	8b 00                	mov    (%eax),%eax
f011f951:	83 e0 fe             	and    $0xfffffffe,%eax
f011f954:	8d 50 f8             	lea    -0x8(%eax),%edx
f011f957:	8b 45 08             	mov    0x8(%ebp),%eax
f011f95a:	01 c2                	add    %eax,%edx
f011f95c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f95f:	89 02                	mov    %eax,(%edx)
}
f011f961:	90                   	nop
f011f962:	5d                   	pop    %ebp
f011f963:	c3                   	ret    

f011f964 <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f011f964:	55                   	push   %ebp
f011f965:	89 e5                	mov    %esp,%ebp
f011f967:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f011f96a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f96d:	83 e0 01             	and    $0x1,%eax
f011f970:	85 c0                	test   %eax,%eax
f011f972:	74 03                	je     f011f977 <alloc_block_FF+0x13>
f011f974:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f011f977:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f011f97b:	77 07                	ja     f011f984 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f011f97d:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f011f984:	a1 74 40 5f f0       	mov    0xf05f4074,%eax
f011f989:	85 c0                	test   %eax,%eax
f011f98b:	75 73                	jne    f011fa00 <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f011f98d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f990:	83 c0 10             	add    $0x10,%eax
f011f993:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f011f996:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f011f99d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f9a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f9a3:	01 d0                	add    %edx,%eax
f011f9a5:	48                   	dec    %eax
f011f9a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f9a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f9ac:	ba 00 00 00 00       	mov    $0x0,%edx
f011f9b1:	f7 75 ec             	divl   -0x14(%ebp)
f011f9b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f9b7:	29 d0                	sub    %edx,%eax
f011f9b9:	c1 e8 0c             	shr    $0xc,%eax
f011f9bc:	83 ec 0c             	sub    $0xc,%esp
f011f9bf:	50                   	push   %eax
f011f9c0:	e8 dc 92 fe ff       	call   f0108ca1 <sbrk>
f011f9c5:	83 c4 10             	add    $0x10,%esp
f011f9c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f011f9cb:	83 ec 0c             	sub    $0xc,%esp
f011f9ce:	6a 00                	push   $0x0
f011f9d0:	e8 cc 92 fe ff       	call   f0108ca1 <sbrk>
f011f9d5:	83 c4 10             	add    $0x10,%esp
f011f9d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f011f9db:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f9de:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f011f9e1:	83 ec 08             	sub    $0x8,%esp
f011f9e4:	50                   	push   %eax
f011f9e5:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f9e8:	e8 2f fd ff ff       	call   f011f71c <initialize_dynamic_allocator>
f011f9ed:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f011f9f0:	83 ec 0c             	sub    $0xc,%esp
f011f9f3:	68 53 05 13 f0       	push   $0xf0130553
f011f9f8:	e8 8e 15 fe ff       	call   f0100f8b <cprintf>
f011f9fd:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f011fa00:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fa04:	75 0a                	jne    f011fa10 <alloc_block_FF+0xac>
	        return NULL;
f011fa06:	b8 00 00 00 00       	mov    $0x0,%eax
f011fa0b:	e9 0e 04 00 00       	jmp    f011fe1e <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f011fa10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f011fa17:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f011fa1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fa1f:	e9 f3 02 00 00       	jmp    f011fd17 <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f011fa24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa27:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f011fa2a:	83 ec 0c             	sub    $0xc,%esp
f011fa2d:	ff 75 bc             	pushl  -0x44(%ebp)
f011fa30:	e8 83 fb ff ff       	call   f011f5b8 <get_block_size>
f011fa35:	83 c4 10             	add    $0x10,%esp
f011fa38:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f011fa3b:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa3e:	83 c0 08             	add    $0x8,%eax
f011fa41:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011fa44:	0f 87 c5 02 00 00    	ja     f011fd0f <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f011fa4a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa4d:	83 c0 18             	add    $0x18,%eax
f011fa50:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011fa53:	0f 87 19 02 00 00    	ja     f011fc72 <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f011fa59:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011fa5c:	2b 45 08             	sub    0x8(%ebp),%eax
f011fa5f:	83 e8 08             	sub    $0x8,%eax
f011fa62:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f011fa65:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa68:	8d 50 08             	lea    0x8(%eax),%edx
f011fa6b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011fa6e:	01 d0                	add    %edx,%eax
f011fa70:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f011fa73:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa76:	83 c0 08             	add    $0x8,%eax
f011fa79:	83 ec 04             	sub    $0x4,%esp
f011fa7c:	6a 01                	push   $0x1
f011fa7e:	50                   	push   %eax
f011fa7f:	ff 75 bc             	pushl  -0x44(%ebp)
f011fa82:	e8 ae fe ff ff       	call   f011f935 <set_block_data>
f011fa87:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f011fa8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa8d:	8b 40 04             	mov    0x4(%eax),%eax
f011fa90:	85 c0                	test   %eax,%eax
f011fa92:	75 68                	jne    f011fafc <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f011fa94:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f011fa98:	75 17                	jne    f011fab1 <alloc_block_FF+0x14d>
f011fa9a:	83 ec 04             	sub    $0x4,%esp
f011fa9d:	68 30 05 13 f0       	push   $0xf0130530
f011faa2:	68 d8 00 00 00       	push   $0xd8
f011faa7:	68 15 05 13 f0       	push   $0xf0130515
f011faac:	e8 88 08 fe ff       	call   f0100339 <_panic>
f011fab1:	8b 15 f0 43 5f f0    	mov    0xf05f43f0,%edx
f011fab7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011faba:	89 10                	mov    %edx,(%eax)
f011fabc:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fabf:	8b 00                	mov    (%eax),%eax
f011fac1:	85 c0                	test   %eax,%eax
f011fac3:	74 0d                	je     f011fad2 <alloc_block_FF+0x16e>
f011fac5:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f011faca:	8b 55 b0             	mov    -0x50(%ebp),%edx
f011facd:	89 50 04             	mov    %edx,0x4(%eax)
f011fad0:	eb 08                	jmp    f011fada <alloc_block_FF+0x176>
f011fad2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fad5:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f011fada:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fadd:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f011fae2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fae5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011faec:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f011faf1:	40                   	inc    %eax
f011faf2:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f011faf7:	e9 dc 00 00 00       	jmp    f011fbd8 <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f011fafc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011faff:	8b 00                	mov    (%eax),%eax
f011fb01:	85 c0                	test   %eax,%eax
f011fb03:	75 65                	jne    f011fb6a <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f011fb05:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f011fb09:	75 17                	jne    f011fb22 <alloc_block_FF+0x1be>
f011fb0b:	83 ec 04             	sub    $0x4,%esp
f011fb0e:	68 64 05 13 f0       	push   $0xf0130564
f011fb13:	68 dc 00 00 00       	push   $0xdc
f011fb18:	68 15 05 13 f0       	push   $0xf0130515
f011fb1d:	e8 17 08 fe ff       	call   f0100339 <_panic>
f011fb22:	8b 15 f4 43 5f f0    	mov    0xf05f43f4,%edx
f011fb28:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fb2b:	89 50 04             	mov    %edx,0x4(%eax)
f011fb2e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fb31:	8b 40 04             	mov    0x4(%eax),%eax
f011fb34:	85 c0                	test   %eax,%eax
f011fb36:	74 0c                	je     f011fb44 <alloc_block_FF+0x1e0>
f011fb38:	a1 f4 43 5f f0       	mov    0xf05f43f4,%eax
f011fb3d:	8b 55 b0             	mov    -0x50(%ebp),%edx
f011fb40:	89 10                	mov    %edx,(%eax)
f011fb42:	eb 08                	jmp    f011fb4c <alloc_block_FF+0x1e8>
f011fb44:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fb47:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f011fb4c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fb4f:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f011fb54:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fb57:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fb5d:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f011fb62:	40                   	inc    %eax
f011fb63:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f011fb68:	eb 6e                	jmp    f011fbd8 <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f011fb6a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fb6e:	74 06                	je     f011fb76 <alloc_block_FF+0x212>
f011fb70:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f011fb74:	75 17                	jne    f011fb8d <alloc_block_FF+0x229>
f011fb76:	83 ec 04             	sub    $0x4,%esp
f011fb79:	68 88 05 13 f0       	push   $0xf0130588
f011fb7e:	68 e0 00 00 00       	push   $0xe0
f011fb83:	68 15 05 13 f0       	push   $0xf0130515
f011fb88:	e8 ac 07 fe ff       	call   f0100339 <_panic>
f011fb8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb90:	8b 10                	mov    (%eax),%edx
f011fb92:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fb95:	89 10                	mov    %edx,(%eax)
f011fb97:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fb9a:	8b 00                	mov    (%eax),%eax
f011fb9c:	85 c0                	test   %eax,%eax
f011fb9e:	74 0b                	je     f011fbab <alloc_block_FF+0x247>
f011fba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fba3:	8b 00                	mov    (%eax),%eax
f011fba5:	8b 55 b0             	mov    -0x50(%ebp),%edx
f011fba8:	89 50 04             	mov    %edx,0x4(%eax)
f011fbab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fbae:	8b 55 b0             	mov    -0x50(%ebp),%edx
f011fbb1:	89 10                	mov    %edx,(%eax)
f011fbb3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fbb6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fbb9:	89 50 04             	mov    %edx,0x4(%eax)
f011fbbc:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fbbf:	8b 00                	mov    (%eax),%eax
f011fbc1:	85 c0                	test   %eax,%eax
f011fbc3:	75 08                	jne    f011fbcd <alloc_block_FF+0x269>
f011fbc5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011fbc8:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f011fbcd:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f011fbd2:	40                   	inc    %eax
f011fbd3:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
				}
				LIST_REMOVE(&freeBlocksList, blk);
f011fbd8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fbdc:	75 17                	jne    f011fbf5 <alloc_block_FF+0x291>
f011fbde:	83 ec 04             	sub    $0x4,%esp
f011fbe1:	68 f7 04 13 f0       	push   $0xf01304f7
f011fbe6:	68 e2 00 00 00       	push   $0xe2
f011fbeb:	68 15 05 13 f0       	push   $0xf0130515
f011fbf0:	e8 44 07 fe ff       	call   f0100339 <_panic>
f011fbf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fbf8:	8b 00                	mov    (%eax),%eax
f011fbfa:	85 c0                	test   %eax,%eax
f011fbfc:	74 10                	je     f011fc0e <alloc_block_FF+0x2aa>
f011fbfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc01:	8b 00                	mov    (%eax),%eax
f011fc03:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fc06:	8b 52 04             	mov    0x4(%edx),%edx
f011fc09:	89 50 04             	mov    %edx,0x4(%eax)
f011fc0c:	eb 0b                	jmp    f011fc19 <alloc_block_FF+0x2b5>
f011fc0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc11:	8b 40 04             	mov    0x4(%eax),%eax
f011fc14:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f011fc19:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc1c:	8b 40 04             	mov    0x4(%eax),%eax
f011fc1f:	85 c0                	test   %eax,%eax
f011fc21:	74 0f                	je     f011fc32 <alloc_block_FF+0x2ce>
f011fc23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc26:	8b 40 04             	mov    0x4(%eax),%eax
f011fc29:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fc2c:	8b 12                	mov    (%edx),%edx
f011fc2e:	89 10                	mov    %edx,(%eax)
f011fc30:	eb 0a                	jmp    f011fc3c <alloc_block_FF+0x2d8>
f011fc32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc35:	8b 00                	mov    (%eax),%eax
f011fc37:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f011fc3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc3f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fc45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc48:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fc4f:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f011fc54:	48                   	dec    %eax
f011fc55:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
				set_block_data(new_block_va, remaining_size, 0);
f011fc5a:	83 ec 04             	sub    $0x4,%esp
f011fc5d:	6a 00                	push   $0x0
f011fc5f:	ff 75 b4             	pushl  -0x4c(%ebp)
f011fc62:	ff 75 b0             	pushl  -0x50(%ebp)
f011fc65:	e8 cb fc ff ff       	call   f011f935 <set_block_data>
f011fc6a:	83 c4 10             	add    $0x10,%esp
f011fc6d:	e9 95 00 00 00       	jmp    f011fd07 <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f011fc72:	83 ec 04             	sub    $0x4,%esp
f011fc75:	6a 01                	push   $0x1
f011fc77:	ff 75 b8             	pushl  -0x48(%ebp)
f011fc7a:	ff 75 bc             	pushl  -0x44(%ebp)
f011fc7d:	e8 b3 fc ff ff       	call   f011f935 <set_block_data>
f011fc82:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f011fc85:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fc89:	75 17                	jne    f011fca2 <alloc_block_FF+0x33e>
f011fc8b:	83 ec 04             	sub    $0x4,%esp
f011fc8e:	68 f7 04 13 f0       	push   $0xf01304f7
f011fc93:	68 e9 00 00 00       	push   $0xe9
f011fc98:	68 15 05 13 f0       	push   $0xf0130515
f011fc9d:	e8 97 06 fe ff       	call   f0100339 <_panic>
f011fca2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fca5:	8b 00                	mov    (%eax),%eax
f011fca7:	85 c0                	test   %eax,%eax
f011fca9:	74 10                	je     f011fcbb <alloc_block_FF+0x357>
f011fcab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fcae:	8b 00                	mov    (%eax),%eax
f011fcb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fcb3:	8b 52 04             	mov    0x4(%edx),%edx
f011fcb6:	89 50 04             	mov    %edx,0x4(%eax)
f011fcb9:	eb 0b                	jmp    f011fcc6 <alloc_block_FF+0x362>
f011fcbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fcbe:	8b 40 04             	mov    0x4(%eax),%eax
f011fcc1:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f011fcc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fcc9:	8b 40 04             	mov    0x4(%eax),%eax
f011fccc:	85 c0                	test   %eax,%eax
f011fcce:	74 0f                	je     f011fcdf <alloc_block_FF+0x37b>
f011fcd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fcd3:	8b 40 04             	mov    0x4(%eax),%eax
f011fcd6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fcd9:	8b 12                	mov    (%edx),%edx
f011fcdb:	89 10                	mov    %edx,(%eax)
f011fcdd:	eb 0a                	jmp    f011fce9 <alloc_block_FF+0x385>
f011fcdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fce2:	8b 00                	mov    (%eax),%eax
f011fce4:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f011fce9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fcec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fcf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fcf5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fcfc:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f011fd01:	48                   	dec    %eax
f011fd02:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
	            }
	            return va;
f011fd07:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011fd0a:	e9 0f 01 00 00       	jmp    f011fe1e <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f011fd0f:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f011fd14:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fd17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fd1b:	74 07                	je     f011fd24 <alloc_block_FF+0x3c0>
f011fd1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fd20:	8b 00                	mov    (%eax),%eax
f011fd22:	eb 05                	jmp    f011fd29 <alloc_block_FF+0x3c5>
f011fd24:	b8 00 00 00 00       	mov    $0x0,%eax
f011fd29:	a3 f8 43 5f f0       	mov    %eax,0xf05f43f8
f011fd2e:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f011fd33:	85 c0                	test   %eax,%eax
f011fd35:	0f 85 e9 fc ff ff    	jne    f011fa24 <alloc_block_FF+0xc0>
f011fd3b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fd3f:	0f 85 df fc ff ff    	jne    f011fa24 <alloc_block_FF+0xc0>
	            }
	            return va;
	        }
	    }

	    uint32 required_size = size + 2 * sizeof(uint32);
f011fd45:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd48:	83 c0 08             	add    $0x8,%eax
f011fd4b:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f011fd4e:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f011fd55:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fd58:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011fd5b:	01 d0                	add    %edx,%eax
f011fd5d:	48                   	dec    %eax
f011fd5e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011fd61:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011fd64:	ba 00 00 00 00       	mov    $0x0,%edx
f011fd69:	f7 75 d8             	divl   -0x28(%ebp)
f011fd6c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011fd6f:	29 d0                	sub    %edx,%eax
f011fd71:	c1 e8 0c             	shr    $0xc,%eax
f011fd74:	83 ec 0c             	sub    $0xc,%esp
f011fd77:	50                   	push   %eax
f011fd78:	e8 24 8f fe ff       	call   f0108ca1 <sbrk>
f011fd7d:	83 c4 10             	add    $0x10,%esp
f011fd80:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f011fd83:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f011fd87:	75 0a                	jne    f011fd93 <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f011fd89:	b8 00 00 00 00       	mov    $0x0,%eax
f011fd8e:	e9 8b 00 00 00       	jmp    f011fe1e <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f011fd93:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f011fd9a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fd9d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fda0:	01 d0                	add    %edx,%eax
f011fda2:	48                   	dec    %eax
f011fda3:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011fda6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fda9:	ba 00 00 00 00       	mov    $0x0,%edx
f011fdae:	f7 75 cc             	divl   -0x34(%ebp)
f011fdb1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fdb4:	29 d0                	sub    %edx,%eax
f011fdb6:	8d 50 fc             	lea    -0x4(%eax),%edx
f011fdb9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011fdbc:	01 d0                	add    %edx,%eax
f011fdbe:	a3 50 48 5f f0       	mov    %eax,0xf05f4850
			end_block->info = 1;
f011fdc3:	a1 50 48 5f f0       	mov    0xf05f4850,%eax
f011fdc8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f011fdce:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f011fdd5:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fdd8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011fddb:	01 d0                	add    %edx,%eax
f011fddd:	48                   	dec    %eax
f011fdde:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011fde1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011fde4:	ba 00 00 00 00       	mov    $0x0,%edx
f011fde9:	f7 75 c4             	divl   -0x3c(%ebp)
f011fdec:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011fdef:	29 d0                	sub    %edx,%eax
f011fdf1:	83 ec 04             	sub    $0x4,%esp
f011fdf4:	6a 01                	push   $0x1
f011fdf6:	50                   	push   %eax
f011fdf7:	ff 75 d0             	pushl  -0x30(%ebp)
f011fdfa:	e8 36 fb ff ff       	call   f011f935 <set_block_data>
f011fdff:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f011fe02:	83 ec 0c             	sub    $0xc,%esp
f011fe05:	ff 75 d0             	pushl  -0x30(%ebp)
f011fe08:	e8 1b 0a 00 00       	call   f0120828 <free_block>
f011fe0d:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f011fe10:	83 ec 0c             	sub    $0xc,%esp
f011fe13:	ff 75 08             	pushl  0x8(%ebp)
f011fe16:	e8 49 fb ff ff       	call   f011f964 <alloc_block_FF>
f011fe1b:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f011fe1e:	c9                   	leave  
f011fe1f:	c3                   	ret    

f011fe20 <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f011fe20:	55                   	push   %ebp
f011fe21:	89 e5                	mov    %esp,%ebp
f011fe23:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f011fe26:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe29:	83 e0 01             	and    $0x1,%eax
f011fe2c:	85 c0                	test   %eax,%eax
f011fe2e:	74 03                	je     f011fe33 <alloc_block_BF+0x13>
f011fe30:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f011fe33:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f011fe37:	77 07                	ja     f011fe40 <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f011fe39:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f011fe40:	a1 74 40 5f f0       	mov    0xf05f4074,%eax
f011fe45:	85 c0                	test   %eax,%eax
f011fe47:	75 73                	jne    f011febc <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f011fe49:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe4c:	83 c0 10             	add    $0x10,%eax
f011fe4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f011fe52:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f011fe59:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011fe5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fe5f:	01 d0                	add    %edx,%eax
f011fe61:	48                   	dec    %eax
f011fe62:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011fe65:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fe68:	ba 00 00 00 00       	mov    $0x0,%edx
f011fe6d:	f7 75 e0             	divl   -0x20(%ebp)
f011fe70:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fe73:	29 d0                	sub    %edx,%eax
f011fe75:	c1 e8 0c             	shr    $0xc,%eax
f011fe78:	83 ec 0c             	sub    $0xc,%esp
f011fe7b:	50                   	push   %eax
f011fe7c:	e8 20 8e fe ff       	call   f0108ca1 <sbrk>
f011fe81:	83 c4 10             	add    $0x10,%esp
f011fe84:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f011fe87:	83 ec 0c             	sub    $0xc,%esp
f011fe8a:	6a 00                	push   $0x0
f011fe8c:	e8 10 8e fe ff       	call   f0108ca1 <sbrk>
f011fe91:	83 c4 10             	add    $0x10,%esp
f011fe94:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f011fe97:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011fe9a:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011fe9d:	83 ec 08             	sub    $0x8,%esp
f011fea0:	50                   	push   %eax
f011fea1:	ff 75 d8             	pushl  -0x28(%ebp)
f011fea4:	e8 73 f8 ff ff       	call   f011f71c <initialize_dynamic_allocator>
f011fea9:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f011feac:	83 ec 0c             	sub    $0xc,%esp
f011feaf:	68 53 05 13 f0       	push   $0xf0130553
f011feb4:	e8 d2 10 fe ff       	call   f0100f8b <cprintf>
f011feb9:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f011febc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f011fec3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f011feca:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f011fed1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f011fed8:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f011fedd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fee0:	e9 1d 01 00 00       	jmp    f0120002 <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f011fee5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fee8:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f011feeb:	83 ec 0c             	sub    $0xc,%esp
f011feee:	ff 75 a8             	pushl  -0x58(%ebp)
f011fef1:	e8 c2 f6 ff ff       	call   f011f5b8 <get_block_size>
f011fef6:	83 c4 10             	add    $0x10,%esp
f011fef9:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f011fefc:	8b 45 08             	mov    0x8(%ebp),%eax
f011feff:	83 c0 08             	add    $0x8,%eax
f011ff02:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ff05:	0f 87 ef 00 00 00    	ja     f011fffa <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f011ff0b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff0e:	83 c0 18             	add    $0x18,%eax
f011ff11:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ff14:	77 1d                	ja     f011ff33 <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f011ff16:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ff19:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ff1c:	0f 86 d8 00 00 00    	jbe    f011fffa <alloc_block_BF+0x1da>
				{
					best_va = va;
f011ff22:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011ff25:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f011ff28:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011ff2b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ff2e:	e9 c7 00 00 00       	jmp    f011fffa <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f011ff33:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff36:	83 c0 08             	add    $0x8,%eax
f011ff39:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ff3c:	0f 85 9d 00 00 00    	jne    f011ffdf <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f011ff42:	83 ec 04             	sub    $0x4,%esp
f011ff45:	6a 01                	push   $0x1
f011ff47:	ff 75 a4             	pushl  -0x5c(%ebp)
f011ff4a:	ff 75 a8             	pushl  -0x58(%ebp)
f011ff4d:	e8 e3 f9 ff ff       	call   f011f935 <set_block_data>
f011ff52:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f011ff55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ff59:	75 17                	jne    f011ff72 <alloc_block_BF+0x152>
f011ff5b:	83 ec 04             	sub    $0x4,%esp
f011ff5e:	68 f7 04 13 f0       	push   $0xf01304f7
f011ff63:	68 2e 01 00 00       	push   $0x12e
f011ff68:	68 15 05 13 f0       	push   $0xf0130515
f011ff6d:	e8 c7 03 fe ff       	call   f0100339 <_panic>
f011ff72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ff75:	8b 00                	mov    (%eax),%eax
f011ff77:	85 c0                	test   %eax,%eax
f011ff79:	74 10                	je     f011ff8b <alloc_block_BF+0x16b>
f011ff7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ff7e:	8b 00                	mov    (%eax),%eax
f011ff80:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ff83:	8b 52 04             	mov    0x4(%edx),%edx
f011ff86:	89 50 04             	mov    %edx,0x4(%eax)
f011ff89:	eb 0b                	jmp    f011ff96 <alloc_block_BF+0x176>
f011ff8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ff8e:	8b 40 04             	mov    0x4(%eax),%eax
f011ff91:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f011ff96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ff99:	8b 40 04             	mov    0x4(%eax),%eax
f011ff9c:	85 c0                	test   %eax,%eax
f011ff9e:	74 0f                	je     f011ffaf <alloc_block_BF+0x18f>
f011ffa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ffa3:	8b 40 04             	mov    0x4(%eax),%eax
f011ffa6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ffa9:	8b 12                	mov    (%edx),%edx
f011ffab:	89 10                	mov    %edx,(%eax)
f011ffad:	eb 0a                	jmp    f011ffb9 <alloc_block_BF+0x199>
f011ffaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ffb2:	8b 00                	mov    (%eax),%eax
f011ffb4:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f011ffb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ffbc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011ffc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ffc5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011ffcc:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f011ffd1:	48                   	dec    %eax
f011ffd2:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
					return va;
f011ffd7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011ffda:	e9 24 04 00 00       	jmp    f0120403 <alloc_block_BF+0x5e3>
				}
				else
				{
					if (best_blk_size > blk_size)
f011ffdf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ffe2:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ffe5:	76 13                	jbe    f011fffa <alloc_block_BF+0x1da>
					{
						internal = 1;
f011ffe7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f011ffee:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011fff1:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f011fff4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011fff7:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f011fffa:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f011ffff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120002:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120006:	74 07                	je     f012000f <alloc_block_BF+0x1ef>
f0120008:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012000b:	8b 00                	mov    (%eax),%eax
f012000d:	eb 05                	jmp    f0120014 <alloc_block_BF+0x1f4>
f012000f:	b8 00 00 00 00       	mov    $0x0,%eax
f0120014:	a3 f8 43 5f f0       	mov    %eax,0xf05f43f8
f0120019:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f012001e:	85 c0                	test   %eax,%eax
f0120020:	0f 85 bf fe ff ff    	jne    f011fee5 <alloc_block_BF+0xc5>
f0120026:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012002a:	0f 85 b5 fe ff ff    	jne    f011fee5 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f0120030:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120034:	0f 84 26 02 00 00    	je     f0120260 <alloc_block_BF+0x440>
f012003a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f012003e:	0f 85 1c 02 00 00    	jne    f0120260 <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f0120044:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120047:	2b 45 08             	sub    0x8(%ebp),%eax
f012004a:	83 e8 08             	sub    $0x8,%eax
f012004d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f0120050:	8b 45 08             	mov    0x8(%ebp),%eax
f0120053:	8d 50 08             	lea    0x8(%eax),%edx
f0120056:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120059:	01 d0                	add    %edx,%eax
f012005b:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f012005e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120061:	83 c0 08             	add    $0x8,%eax
f0120064:	83 ec 04             	sub    $0x4,%esp
f0120067:	6a 01                	push   $0x1
f0120069:	50                   	push   %eax
f012006a:	ff 75 f0             	pushl  -0x10(%ebp)
f012006d:	e8 c3 f8 ff ff       	call   f011f935 <set_block_data>
f0120072:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f0120075:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120078:	8b 40 04             	mov    0x4(%eax),%eax
f012007b:	85 c0                	test   %eax,%eax
f012007d:	75 68                	jne    f01200e7 <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f012007f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0120083:	75 17                	jne    f012009c <alloc_block_BF+0x27c>
f0120085:	83 ec 04             	sub    $0x4,%esp
f0120088:	68 30 05 13 f0       	push   $0xf0130530
f012008d:	68 47 01 00 00       	push   $0x147
f0120092:	68 15 05 13 f0       	push   $0xf0130515
f0120097:	e8 9d 02 fe ff       	call   f0100339 <_panic>
f012009c:	8b 15 f0 43 5f f0    	mov    0xf05f43f0,%edx
f01200a2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01200a5:	89 10                	mov    %edx,(%eax)
f01200a7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01200aa:	8b 00                	mov    (%eax),%eax
f01200ac:	85 c0                	test   %eax,%eax
f01200ae:	74 0d                	je     f01200bd <alloc_block_BF+0x29d>
f01200b0:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f01200b5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01200b8:	89 50 04             	mov    %edx,0x4(%eax)
f01200bb:	eb 08                	jmp    f01200c5 <alloc_block_BF+0x2a5>
f01200bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01200c0:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f01200c5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01200c8:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f01200cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01200d0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01200d7:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f01200dc:	40                   	inc    %eax
f01200dd:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f01200e2:	e9 dc 00 00 00       	jmp    f01201c3 <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f01200e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01200ea:	8b 00                	mov    (%eax),%eax
f01200ec:	85 c0                	test   %eax,%eax
f01200ee:	75 65                	jne    f0120155 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f01200f0:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01200f4:	75 17                	jne    f012010d <alloc_block_BF+0x2ed>
f01200f6:	83 ec 04             	sub    $0x4,%esp
f01200f9:	68 64 05 13 f0       	push   $0xf0130564
f01200fe:	68 4c 01 00 00       	push   $0x14c
f0120103:	68 15 05 13 f0       	push   $0xf0130515
f0120108:	e8 2c 02 fe ff       	call   f0100339 <_panic>
f012010d:	8b 15 f4 43 5f f0    	mov    0xf05f43f4,%edx
f0120113:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120116:	89 50 04             	mov    %edx,0x4(%eax)
f0120119:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012011c:	8b 40 04             	mov    0x4(%eax),%eax
f012011f:	85 c0                	test   %eax,%eax
f0120121:	74 0c                	je     f012012f <alloc_block_BF+0x30f>
f0120123:	a1 f4 43 5f f0       	mov    0xf05f43f4,%eax
f0120128:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012012b:	89 10                	mov    %edx,(%eax)
f012012d:	eb 08                	jmp    f0120137 <alloc_block_BF+0x317>
f012012f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120132:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120137:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012013a:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f012013f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120142:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120148:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f012014d:	40                   	inc    %eax
f012014e:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f0120153:	eb 6e                	jmp    f01201c3 <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f0120155:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120159:	74 06                	je     f0120161 <alloc_block_BF+0x341>
f012015b:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f012015f:	75 17                	jne    f0120178 <alloc_block_BF+0x358>
f0120161:	83 ec 04             	sub    $0x4,%esp
f0120164:	68 88 05 13 f0       	push   $0xf0130588
f0120169:	68 51 01 00 00       	push   $0x151
f012016e:	68 15 05 13 f0       	push   $0xf0130515
f0120173:	e8 c1 01 fe ff       	call   f0100339 <_panic>
f0120178:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012017b:	8b 10                	mov    (%eax),%edx
f012017d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120180:	89 10                	mov    %edx,(%eax)
f0120182:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120185:	8b 00                	mov    (%eax),%eax
f0120187:	85 c0                	test   %eax,%eax
f0120189:	74 0b                	je     f0120196 <alloc_block_BF+0x376>
f012018b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012018e:	8b 00                	mov    (%eax),%eax
f0120190:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120193:	89 50 04             	mov    %edx,0x4(%eax)
f0120196:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120199:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012019c:	89 10                	mov    %edx,(%eax)
f012019e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01201a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01201a4:	89 50 04             	mov    %edx,0x4(%eax)
f01201a7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01201aa:	8b 00                	mov    (%eax),%eax
f01201ac:	85 c0                	test   %eax,%eax
f01201ae:	75 08                	jne    f01201b8 <alloc_block_BF+0x398>
f01201b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01201b3:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f01201b8:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f01201bd:	40                   	inc    %eax
f01201be:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f01201c3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01201c7:	75 17                	jne    f01201e0 <alloc_block_BF+0x3c0>
f01201c9:	83 ec 04             	sub    $0x4,%esp
f01201cc:	68 f7 04 13 f0       	push   $0xf01304f7
f01201d1:	68 53 01 00 00       	push   $0x153
f01201d6:	68 15 05 13 f0       	push   $0xf0130515
f01201db:	e8 59 01 fe ff       	call   f0100339 <_panic>
f01201e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01201e3:	8b 00                	mov    (%eax),%eax
f01201e5:	85 c0                	test   %eax,%eax
f01201e7:	74 10                	je     f01201f9 <alloc_block_BF+0x3d9>
f01201e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01201ec:	8b 00                	mov    (%eax),%eax
f01201ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01201f1:	8b 52 04             	mov    0x4(%edx),%edx
f01201f4:	89 50 04             	mov    %edx,0x4(%eax)
f01201f7:	eb 0b                	jmp    f0120204 <alloc_block_BF+0x3e4>
f01201f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01201fc:	8b 40 04             	mov    0x4(%eax),%eax
f01201ff:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120204:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120207:	8b 40 04             	mov    0x4(%eax),%eax
f012020a:	85 c0                	test   %eax,%eax
f012020c:	74 0f                	je     f012021d <alloc_block_BF+0x3fd>
f012020e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120211:	8b 40 04             	mov    0x4(%eax),%eax
f0120214:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120217:	8b 12                	mov    (%edx),%edx
f0120219:	89 10                	mov    %edx,(%eax)
f012021b:	eb 0a                	jmp    f0120227 <alloc_block_BF+0x407>
f012021d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120220:	8b 00                	mov    (%eax),%eax
f0120222:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120227:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012022a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120230:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120233:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012023a:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f012023f:	48                   	dec    %eax
f0120240:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
			set_block_data(new_block_va, remaining_size, 0);
f0120245:	83 ec 04             	sub    $0x4,%esp
f0120248:	6a 00                	push   $0x0
f012024a:	ff 75 d0             	pushl  -0x30(%ebp)
f012024d:	ff 75 cc             	pushl  -0x34(%ebp)
f0120250:	e8 e0 f6 ff ff       	call   f011f935 <set_block_data>
f0120255:	83 c4 10             	add    $0x10,%esp
			return best_va;
f0120258:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012025b:	e9 a3 01 00 00       	jmp    f0120403 <alloc_block_BF+0x5e3>
	}
	else if(internal == 1)
f0120260:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0120264:	0f 85 9d 00 00 00    	jne    f0120307 <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f012026a:	83 ec 04             	sub    $0x4,%esp
f012026d:	6a 01                	push   $0x1
f012026f:	ff 75 ec             	pushl  -0x14(%ebp)
f0120272:	ff 75 f0             	pushl  -0x10(%ebp)
f0120275:	e8 bb f6 ff ff       	call   f011f935 <set_block_data>
f012027a:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f012027d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120281:	75 17                	jne    f012029a <alloc_block_BF+0x47a>
f0120283:	83 ec 04             	sub    $0x4,%esp
f0120286:	68 f7 04 13 f0       	push   $0xf01304f7
f012028b:	68 5a 01 00 00       	push   $0x15a
f0120290:	68 15 05 13 f0       	push   $0xf0130515
f0120295:	e8 9f 00 fe ff       	call   f0100339 <_panic>
f012029a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012029d:	8b 00                	mov    (%eax),%eax
f012029f:	85 c0                	test   %eax,%eax
f01202a1:	74 10                	je     f01202b3 <alloc_block_BF+0x493>
f01202a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202a6:	8b 00                	mov    (%eax),%eax
f01202a8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01202ab:	8b 52 04             	mov    0x4(%edx),%edx
f01202ae:	89 50 04             	mov    %edx,0x4(%eax)
f01202b1:	eb 0b                	jmp    f01202be <alloc_block_BF+0x49e>
f01202b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202b6:	8b 40 04             	mov    0x4(%eax),%eax
f01202b9:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f01202be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202c1:	8b 40 04             	mov    0x4(%eax),%eax
f01202c4:	85 c0                	test   %eax,%eax
f01202c6:	74 0f                	je     f01202d7 <alloc_block_BF+0x4b7>
f01202c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202cb:	8b 40 04             	mov    0x4(%eax),%eax
f01202ce:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01202d1:	8b 12                	mov    (%edx),%edx
f01202d3:	89 10                	mov    %edx,(%eax)
f01202d5:	eb 0a                	jmp    f01202e1 <alloc_block_BF+0x4c1>
f01202d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202da:	8b 00                	mov    (%eax),%eax
f01202dc:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f01202e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202e4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01202ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202ed:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01202f4:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f01202f9:	48                   	dec    %eax
f01202fa:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
		return best_va;
f01202ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120302:	e9 fc 00 00 00       	jmp    f0120403 <alloc_block_BF+0x5e3>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f0120307:	8b 45 08             	mov    0x8(%ebp),%eax
f012030a:	83 c0 08             	add    $0x8,%eax
f012030d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0120310:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120317:	8b 55 c8             	mov    -0x38(%ebp),%edx
f012031a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012031d:	01 d0                	add    %edx,%eax
f012031f:	48                   	dec    %eax
f0120320:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0120323:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120326:	ba 00 00 00 00       	mov    $0x0,%edx
f012032b:	f7 75 c4             	divl   -0x3c(%ebp)
f012032e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120331:	29 d0                	sub    %edx,%eax
f0120333:	c1 e8 0c             	shr    $0xc,%eax
f0120336:	83 ec 0c             	sub    $0xc,%esp
f0120339:	50                   	push   %eax
f012033a:	e8 62 89 fe ff       	call   f0108ca1 <sbrk>
f012033f:	83 c4 10             	add    $0x10,%esp
f0120342:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f0120345:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f0120349:	75 0a                	jne    f0120355 <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f012034b:	b8 00 00 00 00       	mov    $0x0,%eax
f0120350:	e9 ae 00 00 00       	jmp    f0120403 <alloc_block_BF+0x5e3>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0120355:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f012035c:	8b 55 c8             	mov    -0x38(%ebp),%edx
f012035f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120362:	01 d0                	add    %edx,%eax
f0120364:	48                   	dec    %eax
f0120365:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0120368:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f012036b:	ba 00 00 00 00       	mov    $0x0,%edx
f0120370:	f7 75 b8             	divl   -0x48(%ebp)
f0120373:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0120376:	29 d0                	sub    %edx,%eax
f0120378:	8d 50 fc             	lea    -0x4(%eax),%edx
f012037b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f012037e:	01 d0                	add    %edx,%eax
f0120380:	a3 50 48 5f f0       	mov    %eax,0xf05f4850
				end_block->info = 1;
f0120385:	a1 50 48 5f f0       	mov    0xf05f4850,%eax
f012038a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				cprintf("251\n");
f0120390:	83 ec 0c             	sub    $0xc,%esp
f0120393:	68 bc 05 13 f0       	push   $0xf01305bc
f0120398:	e8 ee 0b fe ff       	call   f0100f8b <cprintf>
f012039d:	83 c4 10             	add    $0x10,%esp
			cprintf("address : %x\n",new_mem);
f01203a0:	83 ec 08             	sub    $0x8,%esp
f01203a3:	ff 75 bc             	pushl  -0x44(%ebp)
f01203a6:	68 c1 05 13 f0       	push   $0xf01305c1
f01203ab:	e8 db 0b fe ff       	call   f0100f8b <cprintf>
f01203b0:	83 c4 10             	add    $0x10,%esp
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f01203b3:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f01203ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01203bd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01203c0:	01 d0                	add    %edx,%eax
f01203c2:	48                   	dec    %eax
f01203c3:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01203c6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01203c9:	ba 00 00 00 00       	mov    $0x0,%edx
f01203ce:	f7 75 b0             	divl   -0x50(%ebp)
f01203d1:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01203d4:	29 d0                	sub    %edx,%eax
f01203d6:	83 ec 04             	sub    $0x4,%esp
f01203d9:	6a 01                	push   $0x1
f01203db:	50                   	push   %eax
f01203dc:	ff 75 bc             	pushl  -0x44(%ebp)
f01203df:	e8 51 f5 ff ff       	call   f011f935 <set_block_data>
f01203e4:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f01203e7:	83 ec 0c             	sub    $0xc,%esp
f01203ea:	ff 75 bc             	pushl  -0x44(%ebp)
f01203ed:	e8 36 04 00 00       	call   f0120828 <free_block>
f01203f2:	83 c4 10             	add    $0x10,%esp
			return alloc_block_FF(size);
f01203f5:	83 ec 0c             	sub    $0xc,%esp
f01203f8:	ff 75 08             	pushl  0x8(%ebp)
f01203fb:	e8 64 f5 ff ff       	call   f011f964 <alloc_block_FF>
f0120400:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f0120403:	c9                   	leave  
f0120404:	c3                   	ret    

f0120405 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f0120405:	55                   	push   %ebp
f0120406:	89 e5                	mov    %esp,%ebp
f0120408:	53                   	push   %ebx
f0120409:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f012040c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0120413:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f012041a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012041e:	74 1e                	je     f012043e <merging+0x39>
f0120420:	ff 75 08             	pushl  0x8(%ebp)
f0120423:	e8 90 f1 ff ff       	call   f011f5b8 <get_block_size>
f0120428:	83 c4 04             	add    $0x4,%esp
f012042b:	89 c2                	mov    %eax,%edx
f012042d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120430:	01 d0                	add    %edx,%eax
f0120432:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120435:	75 07                	jne    f012043e <merging+0x39>
		prev_is_free = 1;
f0120437:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f012043e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120442:	74 1e                	je     f0120462 <merging+0x5d>
f0120444:	ff 75 10             	pushl  0x10(%ebp)
f0120447:	e8 6c f1 ff ff       	call   f011f5b8 <get_block_size>
f012044c:	83 c4 04             	add    $0x4,%esp
f012044f:	89 c2                	mov    %eax,%edx
f0120451:	8b 45 10             	mov    0x10(%ebp),%eax
f0120454:	01 d0                	add    %edx,%eax
f0120456:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120459:	75 07                	jne    f0120462 <merging+0x5d>
		next_is_free = 1;
f012045b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f0120462:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120466:	0f 84 cc 00 00 00    	je     f0120538 <merging+0x133>
f012046c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120470:	0f 84 c2 00 00 00    	je     f0120538 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f0120476:	ff 75 08             	pushl  0x8(%ebp)
f0120479:	e8 3a f1 ff ff       	call   f011f5b8 <get_block_size>
f012047e:	83 c4 04             	add    $0x4,%esp
f0120481:	89 c3                	mov    %eax,%ebx
f0120483:	ff 75 10             	pushl  0x10(%ebp)
f0120486:	e8 2d f1 ff ff       	call   f011f5b8 <get_block_size>
f012048b:	83 c4 04             	add    $0x4,%esp
f012048e:	01 c3                	add    %eax,%ebx
f0120490:	ff 75 0c             	pushl  0xc(%ebp)
f0120493:	e8 20 f1 ff ff       	call   f011f5b8 <get_block_size>
f0120498:	83 c4 04             	add    $0x4,%esp
f012049b:	01 d8                	add    %ebx,%eax
f012049d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01204a0:	6a 00                	push   $0x0
f01204a2:	ff 75 ec             	pushl  -0x14(%ebp)
f01204a5:	ff 75 08             	pushl  0x8(%ebp)
f01204a8:	e8 88 f4 ff ff       	call   f011f935 <set_block_data>
f01204ad:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f01204b0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01204b4:	75 17                	jne    f01204cd <merging+0xc8>
f01204b6:	83 ec 04             	sub    $0x4,%esp
f01204b9:	68 f7 04 13 f0       	push   $0xf01304f7
f01204be:	68 7f 01 00 00       	push   $0x17f
f01204c3:	68 15 05 13 f0       	push   $0xf0130515
f01204c8:	e8 6c fe fd ff       	call   f0100339 <_panic>
f01204cd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204d0:	8b 00                	mov    (%eax),%eax
f01204d2:	85 c0                	test   %eax,%eax
f01204d4:	74 10                	je     f01204e6 <merging+0xe1>
f01204d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204d9:	8b 00                	mov    (%eax),%eax
f01204db:	8b 55 0c             	mov    0xc(%ebp),%edx
f01204de:	8b 52 04             	mov    0x4(%edx),%edx
f01204e1:	89 50 04             	mov    %edx,0x4(%eax)
f01204e4:	eb 0b                	jmp    f01204f1 <merging+0xec>
f01204e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204e9:	8b 40 04             	mov    0x4(%eax),%eax
f01204ec:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f01204f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204f4:	8b 40 04             	mov    0x4(%eax),%eax
f01204f7:	85 c0                	test   %eax,%eax
f01204f9:	74 0f                	je     f012050a <merging+0x105>
f01204fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204fe:	8b 40 04             	mov    0x4(%eax),%eax
f0120501:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120504:	8b 12                	mov    (%edx),%edx
f0120506:	89 10                	mov    %edx,(%eax)
f0120508:	eb 0a                	jmp    f0120514 <merging+0x10f>
f012050a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012050d:	8b 00                	mov    (%eax),%eax
f012050f:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120514:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120517:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012051d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120520:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120527:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f012052c:	48                   	dec    %eax
f012052d:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f0120532:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0120533:	e9 ea 02 00 00       	jmp    f0120822 <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0120538:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012053c:	74 3b                	je     f0120579 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f012053e:	83 ec 0c             	sub    $0xc,%esp
f0120541:	ff 75 08             	pushl  0x8(%ebp)
f0120544:	e8 6f f0 ff ff       	call   f011f5b8 <get_block_size>
f0120549:	83 c4 10             	add    $0x10,%esp
f012054c:	89 c3                	mov    %eax,%ebx
f012054e:	83 ec 0c             	sub    $0xc,%esp
f0120551:	ff 75 10             	pushl  0x10(%ebp)
f0120554:	e8 5f f0 ff ff       	call   f011f5b8 <get_block_size>
f0120559:	83 c4 10             	add    $0x10,%esp
f012055c:	01 d8                	add    %ebx,%eax
f012055e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0120561:	83 ec 04             	sub    $0x4,%esp
f0120564:	6a 00                	push   $0x0
f0120566:	ff 75 e8             	pushl  -0x18(%ebp)
f0120569:	ff 75 08             	pushl  0x8(%ebp)
f012056c:	e8 c4 f3 ff ff       	call   f011f935 <set_block_data>
f0120571:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0120574:	e9 a9 02 00 00       	jmp    f0120822 <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f0120579:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012057d:	0f 84 2d 01 00 00    	je     f01206b0 <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f0120583:	83 ec 0c             	sub    $0xc,%esp
f0120586:	ff 75 10             	pushl  0x10(%ebp)
f0120589:	e8 2a f0 ff ff       	call   f011f5b8 <get_block_size>
f012058e:	83 c4 10             	add    $0x10,%esp
f0120591:	89 c3                	mov    %eax,%ebx
f0120593:	83 ec 0c             	sub    $0xc,%esp
f0120596:	ff 75 0c             	pushl  0xc(%ebp)
f0120599:	e8 1a f0 ff ff       	call   f011f5b8 <get_block_size>
f012059e:	83 c4 10             	add    $0x10,%esp
f01205a1:	01 d8                	add    %ebx,%eax
f01205a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f01205a6:	83 ec 04             	sub    $0x4,%esp
f01205a9:	6a 00                	push   $0x0
f01205ab:	ff 75 e4             	pushl  -0x1c(%ebp)
f01205ae:	ff 75 10             	pushl  0x10(%ebp)
f01205b1:	e8 7f f3 ff ff       	call   f011f935 <set_block_data>
f01205b6:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f01205b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01205bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f01205bf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01205c3:	74 06                	je     f01205cb <merging+0x1c6>
f01205c5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01205c9:	75 17                	jne    f01205e2 <merging+0x1dd>
f01205cb:	83 ec 04             	sub    $0x4,%esp
f01205ce:	68 d0 05 13 f0       	push   $0xf01305d0
f01205d3:	68 8f 01 00 00       	push   $0x18f
f01205d8:	68 15 05 13 f0       	push   $0xf0130515
f01205dd:	e8 57 fd fd ff       	call   f0100339 <_panic>
f01205e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01205e5:	8b 50 04             	mov    0x4(%eax),%edx
f01205e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01205eb:	89 50 04             	mov    %edx,0x4(%eax)
f01205ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01205f1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01205f4:	89 10                	mov    %edx,(%eax)
f01205f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01205f9:	8b 40 04             	mov    0x4(%eax),%eax
f01205fc:	85 c0                	test   %eax,%eax
f01205fe:	74 0d                	je     f012060d <merging+0x208>
f0120600:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120603:	8b 40 04             	mov    0x4(%eax),%eax
f0120606:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120609:	89 10                	mov    %edx,(%eax)
f012060b:	eb 08                	jmp    f0120615 <merging+0x210>
f012060d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120610:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120615:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120618:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012061b:	89 50 04             	mov    %edx,0x4(%eax)
f012061e:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120623:	40                   	inc    %eax
f0120624:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
		LIST_REMOVE(&freeBlocksList, next_block);
f0120629:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012062d:	75 17                	jne    f0120646 <merging+0x241>
f012062f:	83 ec 04             	sub    $0x4,%esp
f0120632:	68 f7 04 13 f0       	push   $0xf01304f7
f0120637:	68 90 01 00 00       	push   $0x190
f012063c:	68 15 05 13 f0       	push   $0xf0130515
f0120641:	e8 f3 fc fd ff       	call   f0100339 <_panic>
f0120646:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120649:	8b 00                	mov    (%eax),%eax
f012064b:	85 c0                	test   %eax,%eax
f012064d:	74 10                	je     f012065f <merging+0x25a>
f012064f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120652:	8b 00                	mov    (%eax),%eax
f0120654:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120657:	8b 52 04             	mov    0x4(%edx),%edx
f012065a:	89 50 04             	mov    %edx,0x4(%eax)
f012065d:	eb 0b                	jmp    f012066a <merging+0x265>
f012065f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120662:	8b 40 04             	mov    0x4(%eax),%eax
f0120665:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f012066a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012066d:	8b 40 04             	mov    0x4(%eax),%eax
f0120670:	85 c0                	test   %eax,%eax
f0120672:	74 0f                	je     f0120683 <merging+0x27e>
f0120674:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120677:	8b 40 04             	mov    0x4(%eax),%eax
f012067a:	8b 55 0c             	mov    0xc(%ebp),%edx
f012067d:	8b 12                	mov    (%edx),%edx
f012067f:	89 10                	mov    %edx,(%eax)
f0120681:	eb 0a                	jmp    f012068d <merging+0x288>
f0120683:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120686:	8b 00                	mov    (%eax),%eax
f0120688:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f012068d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120690:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120696:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120699:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01206a0:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f01206a5:	48                   	dec    %eax
f01206a6:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01206ab:	e9 72 01 00 00       	jmp    f0120822 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f01206b0:	8b 45 10             	mov    0x10(%ebp),%eax
f01206b3:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f01206b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01206ba:	74 79                	je     f0120735 <merging+0x330>
f01206bc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01206c0:	74 73                	je     f0120735 <merging+0x330>
f01206c2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01206c6:	74 06                	je     f01206ce <merging+0x2c9>
f01206c8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01206cc:	75 17                	jne    f01206e5 <merging+0x2e0>
f01206ce:	83 ec 04             	sub    $0x4,%esp
f01206d1:	68 88 05 13 f0       	push   $0xf0130588
f01206d6:	68 96 01 00 00       	push   $0x196
f01206db:	68 15 05 13 f0       	push   $0xf0130515
f01206e0:	e8 54 fc fd ff       	call   f0100339 <_panic>
f01206e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01206e8:	8b 10                	mov    (%eax),%edx
f01206ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01206ed:	89 10                	mov    %edx,(%eax)
f01206ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01206f2:	8b 00                	mov    (%eax),%eax
f01206f4:	85 c0                	test   %eax,%eax
f01206f6:	74 0b                	je     f0120703 <merging+0x2fe>
f01206f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01206fb:	8b 00                	mov    (%eax),%eax
f01206fd:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120700:	89 50 04             	mov    %edx,0x4(%eax)
f0120703:	8b 45 08             	mov    0x8(%ebp),%eax
f0120706:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120709:	89 10                	mov    %edx,(%eax)
f012070b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012070e:	8b 55 08             	mov    0x8(%ebp),%edx
f0120711:	89 50 04             	mov    %edx,0x4(%eax)
f0120714:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120717:	8b 00                	mov    (%eax),%eax
f0120719:	85 c0                	test   %eax,%eax
f012071b:	75 08                	jne    f0120725 <merging+0x320>
f012071d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120720:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120725:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f012072a:	40                   	inc    %eax
f012072b:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f0120730:	e9 ce 00 00 00       	jmp    f0120803 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0120735:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120739:	74 65                	je     f01207a0 <merging+0x39b>
f012073b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012073f:	75 17                	jne    f0120758 <merging+0x353>
f0120741:	83 ec 04             	sub    $0x4,%esp
f0120744:	68 64 05 13 f0       	push   $0xf0130564
f0120749:	68 97 01 00 00       	push   $0x197
f012074e:	68 15 05 13 f0       	push   $0xf0130515
f0120753:	e8 e1 fb fd ff       	call   f0100339 <_panic>
f0120758:	8b 15 f4 43 5f f0    	mov    0xf05f43f4,%edx
f012075e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120761:	89 50 04             	mov    %edx,0x4(%eax)
f0120764:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120767:	8b 40 04             	mov    0x4(%eax),%eax
f012076a:	85 c0                	test   %eax,%eax
f012076c:	74 0c                	je     f012077a <merging+0x375>
f012076e:	a1 f4 43 5f f0       	mov    0xf05f43f4,%eax
f0120773:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120776:	89 10                	mov    %edx,(%eax)
f0120778:	eb 08                	jmp    f0120782 <merging+0x37d>
f012077a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012077d:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120782:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120785:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f012078a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012078d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120793:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120798:	40                   	inc    %eax
f0120799:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f012079e:	eb 63                	jmp    f0120803 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f01207a0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01207a4:	75 17                	jne    f01207bd <merging+0x3b8>
f01207a6:	83 ec 04             	sub    $0x4,%esp
f01207a9:	68 30 05 13 f0       	push   $0xf0130530
f01207ae:	68 9a 01 00 00       	push   $0x19a
f01207b3:	68 15 05 13 f0       	push   $0xf0130515
f01207b8:	e8 7c fb fd ff       	call   f0100339 <_panic>
f01207bd:	8b 15 f0 43 5f f0    	mov    0xf05f43f0,%edx
f01207c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207c6:	89 10                	mov    %edx,(%eax)
f01207c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207cb:	8b 00                	mov    (%eax),%eax
f01207cd:	85 c0                	test   %eax,%eax
f01207cf:	74 0d                	je     f01207de <merging+0x3d9>
f01207d1:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f01207d6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01207d9:	89 50 04             	mov    %edx,0x4(%eax)
f01207dc:	eb 08                	jmp    f01207e6 <merging+0x3e1>
f01207de:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207e1:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f01207e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207e9:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f01207ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207f1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01207f8:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f01207fd:	40                   	inc    %eax
f01207fe:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
		}
		set_block_data(va, get_block_size(va), 0);
f0120803:	83 ec 0c             	sub    $0xc,%esp
f0120806:	ff 75 10             	pushl  0x10(%ebp)
f0120809:	e8 aa ed ff ff       	call   f011f5b8 <get_block_size>
f012080e:	83 c4 10             	add    $0x10,%esp
f0120811:	83 ec 04             	sub    $0x4,%esp
f0120814:	6a 00                	push   $0x0
f0120816:	50                   	push   %eax
f0120817:	ff 75 10             	pushl  0x10(%ebp)
f012081a:	e8 16 f1 ff ff       	call   f011f935 <set_block_data>
f012081f:	83 c4 10             	add    $0x10,%esp
	}
}
f0120822:	90                   	nop
f0120823:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0120826:	c9                   	leave  
f0120827:	c3                   	ret    

f0120828 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0120828:	55                   	push   %ebp
f0120829:	89 e5                	mov    %esp,%ebp
f012082b:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f012082e:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f0120833:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0120836:	a1 f4 43 5f f0       	mov    0xf05f43f4,%eax
f012083b:	3b 45 08             	cmp    0x8(%ebp),%eax
f012083e:	73 1b                	jae    f012085b <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f0120840:	a1 f4 43 5f f0       	mov    0xf05f43f4,%eax
f0120845:	83 ec 04             	sub    $0x4,%esp
f0120848:	ff 75 08             	pushl  0x8(%ebp)
f012084b:	6a 00                	push   $0x0
f012084d:	50                   	push   %eax
f012084e:	e8 b2 fb ff ff       	call   f0120405 <merging>
f0120853:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0120856:	e9 8b 00 00 00       	jmp    f01208e6 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f012085b:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f0120860:	3b 45 08             	cmp    0x8(%ebp),%eax
f0120863:	76 18                	jbe    f012087d <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f0120865:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f012086a:	83 ec 04             	sub    $0x4,%esp
f012086d:	ff 75 08             	pushl  0x8(%ebp)
f0120870:	50                   	push   %eax
f0120871:	6a 00                	push   $0x0
f0120873:	e8 8d fb ff ff       	call   f0120405 <merging>
f0120878:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f012087b:	eb 69                	jmp    f01208e6 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f012087d:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f0120882:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120885:	eb 39                	jmp    f01208c0 <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f0120887:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012088a:	3b 45 08             	cmp    0x8(%ebp),%eax
f012088d:	73 29                	jae    f01208b8 <free_block+0x90>
f012088f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120892:	8b 00                	mov    (%eax),%eax
f0120894:	3b 45 08             	cmp    0x8(%ebp),%eax
f0120897:	76 1f                	jbe    f01208b8 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f0120899:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012089c:	8b 00                	mov    (%eax),%eax
f012089e:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f01208a1:	83 ec 04             	sub    $0x4,%esp
f01208a4:	ff 75 08             	pushl  0x8(%ebp)
f01208a7:	ff 75 f0             	pushl  -0x10(%ebp)
f01208aa:	ff 75 f4             	pushl  -0xc(%ebp)
f01208ad:	e8 53 fb ff ff       	call   f0120405 <merging>
f01208b2:	83 c4 10             	add    $0x10,%esp
			break;
f01208b5:	90                   	nop
		}
	}
}
f01208b6:	eb 2e                	jmp    f01208e6 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f01208b8:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f01208bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01208c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01208c4:	74 07                	je     f01208cd <free_block+0xa5>
f01208c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208c9:	8b 00                	mov    (%eax),%eax
f01208cb:	eb 05                	jmp    f01208d2 <free_block+0xaa>
f01208cd:	b8 00 00 00 00       	mov    $0x0,%eax
f01208d2:	a3 f8 43 5f f0       	mov    %eax,0xf05f43f8
f01208d7:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f01208dc:	85 c0                	test   %eax,%eax
f01208de:	75 a7                	jne    f0120887 <free_block+0x5f>
f01208e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01208e4:	75 a1                	jne    f0120887 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01208e6:	90                   	nop
f01208e7:	c9                   	leave  
f01208e8:	c3                   	ret    

f01208e9 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f01208e9:	55                   	push   %ebp
f01208ea:	89 e5                	mov    %esp,%ebp
f01208ec:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f01208ef:	ff 75 08             	pushl  0x8(%ebp)
f01208f2:	e8 c1 ec ff ff       	call   f011f5b8 <get_block_size>
f01208f7:	83 c4 04             	add    $0x4,%esp
f01208fa:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f01208fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120904:	eb 17                	jmp    f012091d <copy_data+0x34>
f0120906:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120909:	8b 45 0c             	mov    0xc(%ebp),%eax
f012090c:	01 c2                	add    %eax,%edx
f012090e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0120911:	8b 45 08             	mov    0x8(%ebp),%eax
f0120914:	01 c8                	add    %ecx,%eax
f0120916:	8a 00                	mov    (%eax),%al
f0120918:	88 02                	mov    %al,(%edx)
f012091a:	ff 45 fc             	incl   -0x4(%ebp)
f012091d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120920:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0120923:	72 e1                	jb     f0120906 <copy_data+0x1d>
}
f0120925:	90                   	nop
f0120926:	c9                   	leave  
f0120927:	c3                   	ret    

f0120928 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0120928:	55                   	push   %ebp
f0120929:	89 e5                	mov    %esp,%ebp
f012092b:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f012092e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120932:	75 23                	jne    f0120957 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0120934:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120938:	74 13                	je     f012094d <realloc_block_FF+0x25>
f012093a:	83 ec 0c             	sub    $0xc,%esp
f012093d:	ff 75 0c             	pushl  0xc(%ebp)
f0120940:	e8 1f f0 ff ff       	call   f011f964 <alloc_block_FF>
f0120945:	83 c4 10             	add    $0x10,%esp
f0120948:	e9 f4 06 00 00       	jmp    f0121041 <realloc_block_FF+0x719>
		return NULL;
f012094d:	b8 00 00 00 00       	mov    $0x0,%eax
f0120952:	e9 ea 06 00 00       	jmp    f0121041 <realloc_block_FF+0x719>
	}

	if(new_size == 0)
f0120957:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012095b:	75 18                	jne    f0120975 <realloc_block_FF+0x4d>
	{
		free_block(va);
f012095d:	83 ec 0c             	sub    $0xc,%esp
f0120960:	ff 75 08             	pushl  0x8(%ebp)
f0120963:	e8 c0 fe ff ff       	call   f0120828 <free_block>
f0120968:	83 c4 10             	add    $0x10,%esp
		return NULL;
f012096b:	b8 00 00 00 00       	mov    $0x0,%eax
f0120970:	e9 cc 06 00 00       	jmp    f0121041 <realloc_block_FF+0x719>
	}


	if(new_size < 8) new_size = 8;
f0120975:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f0120979:	77 07                	ja     f0120982 <realloc_block_FF+0x5a>
f012097b:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f0120982:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120985:	83 e0 01             	and    $0x1,%eax
f0120988:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f012098b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012098e:	83 c0 08             	add    $0x8,%eax
f0120991:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f0120994:	83 ec 0c             	sub    $0xc,%esp
f0120997:	ff 75 08             	pushl  0x8(%ebp)
f012099a:	e8 19 ec ff ff       	call   f011f5b8 <get_block_size>
f012099f:	83 c4 10             	add    $0x10,%esp
f01209a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f01209a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209a8:	83 e8 08             	sub    $0x8,%eax
f01209ab:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f01209ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01209b1:	83 e8 04             	sub    $0x4,%eax
f01209b4:	8b 00                	mov    (%eax),%eax
f01209b6:	83 e0 fe             	and    $0xfffffffe,%eax
f01209b9:	89 c2                	mov    %eax,%edx
f01209bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01209be:	01 d0                	add    %edx,%eax
f01209c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f01209c3:	83 ec 0c             	sub    $0xc,%esp
f01209c6:	ff 75 e4             	pushl  -0x1c(%ebp)
f01209c9:	e8 ea eb ff ff       	call   f011f5b8 <get_block_size>
f01209ce:	83 c4 10             	add    $0x10,%esp
f01209d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f01209d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01209d7:	83 e8 08             	sub    $0x8,%eax
f01209da:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f01209dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209e0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01209e3:	75 08                	jne    f01209ed <realloc_block_FF+0xc5>
	{
		 return va;
f01209e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01209e8:	e9 54 06 00 00       	jmp    f0121041 <realloc_block_FF+0x719>

	}


	if(new_size < cur_size)
f01209ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209f0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01209f3:	0f 83 e5 03 00 00    	jae    f0120dde <realloc_block_FF+0x4b6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f01209f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01209fc:	2b 45 0c             	sub    0xc(%ebp),%eax
f01209ff:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0120a02:	83 ec 0c             	sub    $0xc,%esp
f0120a05:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120a08:	e8 c4 eb ff ff       	call   f011f5d1 <is_free_block>
f0120a0d:	83 c4 10             	add    $0x10,%esp
f0120a10:	84 c0                	test   %al,%al
f0120a12:	0f 84 3b 01 00 00    	je     f0120b53 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0120a18:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120a1b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0120a1e:	01 d0                	add    %edx,%eax
f0120a20:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0120a23:	83 ec 04             	sub    $0x4,%esp
f0120a26:	6a 01                	push   $0x1
f0120a28:	ff 75 f0             	pushl  -0x10(%ebp)
f0120a2b:	ff 75 08             	pushl  0x8(%ebp)
f0120a2e:	e8 02 ef ff ff       	call   f011f935 <set_block_data>
f0120a33:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0120a36:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a39:	83 e8 04             	sub    $0x4,%eax
f0120a3c:	8b 00                	mov    (%eax),%eax
f0120a3e:	83 e0 fe             	and    $0xfffffffe,%eax
f0120a41:	89 c2                	mov    %eax,%edx
f0120a43:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a46:	01 d0                	add    %edx,%eax
f0120a48:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f0120a4b:	83 ec 04             	sub    $0x4,%esp
f0120a4e:	6a 00                	push   $0x0
f0120a50:	ff 75 cc             	pushl  -0x34(%ebp)
f0120a53:	ff 75 c8             	pushl  -0x38(%ebp)
f0120a56:	e8 da ee ff ff       	call   f011f935 <set_block_data>
f0120a5b:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0120a5e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120a62:	74 06                	je     f0120a6a <realloc_block_FF+0x142>
f0120a64:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0120a68:	75 17                	jne    f0120a81 <realloc_block_FF+0x159>
f0120a6a:	83 ec 04             	sub    $0x4,%esp
f0120a6d:	68 88 05 13 f0       	push   $0xf0130588
f0120a72:	68 f8 01 00 00       	push   $0x1f8
f0120a77:	68 15 05 13 f0       	push   $0xf0130515
f0120a7c:	e8 b8 f8 fd ff       	call   f0100339 <_panic>
f0120a81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120a84:	8b 10                	mov    (%eax),%edx
f0120a86:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120a89:	89 10                	mov    %edx,(%eax)
f0120a8b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120a8e:	8b 00                	mov    (%eax),%eax
f0120a90:	85 c0                	test   %eax,%eax
f0120a92:	74 0b                	je     f0120a9f <realloc_block_FF+0x177>
f0120a94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120a97:	8b 00                	mov    (%eax),%eax
f0120a99:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120a9c:	89 50 04             	mov    %edx,0x4(%eax)
f0120a9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120aa2:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120aa5:	89 10                	mov    %edx,(%eax)
f0120aa7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120aaa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120aad:	89 50 04             	mov    %edx,0x4(%eax)
f0120ab0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120ab3:	8b 00                	mov    (%eax),%eax
f0120ab5:	85 c0                	test   %eax,%eax
f0120ab7:	75 08                	jne    f0120ac1 <realloc_block_FF+0x199>
f0120ab9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120abc:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120ac1:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120ac6:	40                   	inc    %eax
f0120ac7:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0120acc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120ad0:	75 17                	jne    f0120ae9 <realloc_block_FF+0x1c1>
f0120ad2:	83 ec 04             	sub    $0x4,%esp
f0120ad5:	68 f7 04 13 f0       	push   $0xf01304f7
f0120ada:	68 f9 01 00 00       	push   $0x1f9
f0120adf:	68 15 05 13 f0       	push   $0xf0130515
f0120ae4:	e8 50 f8 fd ff       	call   f0100339 <_panic>
f0120ae9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120aec:	8b 00                	mov    (%eax),%eax
f0120aee:	85 c0                	test   %eax,%eax
f0120af0:	74 10                	je     f0120b02 <realloc_block_FF+0x1da>
f0120af2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120af5:	8b 00                	mov    (%eax),%eax
f0120af7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120afa:	8b 52 04             	mov    0x4(%edx),%edx
f0120afd:	89 50 04             	mov    %edx,0x4(%eax)
f0120b00:	eb 0b                	jmp    f0120b0d <realloc_block_FF+0x1e5>
f0120b02:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b05:	8b 40 04             	mov    0x4(%eax),%eax
f0120b08:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120b0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b10:	8b 40 04             	mov    0x4(%eax),%eax
f0120b13:	85 c0                	test   %eax,%eax
f0120b15:	74 0f                	je     f0120b26 <realloc_block_FF+0x1fe>
f0120b17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b1a:	8b 40 04             	mov    0x4(%eax),%eax
f0120b1d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120b20:	8b 12                	mov    (%edx),%edx
f0120b22:	89 10                	mov    %edx,(%eax)
f0120b24:	eb 0a                	jmp    f0120b30 <realloc_block_FF+0x208>
f0120b26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b29:	8b 00                	mov    (%eax),%eax
f0120b2b:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120b30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b33:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120b39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120b3c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120b43:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120b48:	48                   	dec    %eax
f0120b49:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f0120b4e:	e9 83 02 00 00       	jmp    f0120dd6 <realloc_block_FF+0x4ae>
		}
		else
		{
			if(remaining_size>=16)
f0120b53:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f0120b57:	0f 86 69 02 00 00    	jbe    f0120dc6 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f0120b5d:	83 ec 04             	sub    $0x4,%esp
f0120b60:	6a 01                	push   $0x1
f0120b62:	ff 75 f0             	pushl  -0x10(%ebp)
f0120b65:	ff 75 08             	pushl  0x8(%ebp)
f0120b68:	e8 c8 ed ff ff       	call   f011f935 <set_block_data>
f0120b6d:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0120b70:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b73:	83 e8 04             	sub    $0x4,%eax
f0120b76:	8b 00                	mov    (%eax),%eax
f0120b78:	83 e0 fe             	and    $0xfffffffe,%eax
f0120b7b:	89 c2                	mov    %eax,%edx
f0120b7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b80:	01 d0                	add    %edx,%eax
f0120b82:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f0120b85:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120b8a:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f0120b8d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0120b91:	75 68                	jne    f0120bfb <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0120b93:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0120b97:	75 17                	jne    f0120bb0 <realloc_block_FF+0x288>
f0120b99:	83 ec 04             	sub    $0x4,%esp
f0120b9c:	68 30 05 13 f0       	push   $0xf0130530
f0120ba1:	68 08 02 00 00       	push   $0x208
f0120ba6:	68 15 05 13 f0       	push   $0xf0130515
f0120bab:	e8 89 f7 fd ff       	call   f0100339 <_panic>
f0120bb0:	8b 15 f0 43 5f f0    	mov    0xf05f43f0,%edx
f0120bb6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120bb9:	89 10                	mov    %edx,(%eax)
f0120bbb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120bbe:	8b 00                	mov    (%eax),%eax
f0120bc0:	85 c0                	test   %eax,%eax
f0120bc2:	74 0d                	je     f0120bd1 <realloc_block_FF+0x2a9>
f0120bc4:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f0120bc9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120bcc:	89 50 04             	mov    %edx,0x4(%eax)
f0120bcf:	eb 08                	jmp    f0120bd9 <realloc_block_FF+0x2b1>
f0120bd1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120bd4:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120bd9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120bdc:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120be1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120be4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120beb:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120bf0:	40                   	inc    %eax
f0120bf1:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f0120bf6:	e9 b0 01 00 00       	jmp    f0120dab <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f0120bfb:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f0120c00:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0120c03:	76 68                	jbe    f0120c6d <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0120c05:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0120c09:	75 17                	jne    f0120c22 <realloc_block_FF+0x2fa>
f0120c0b:	83 ec 04             	sub    $0x4,%esp
f0120c0e:	68 30 05 13 f0       	push   $0xf0130530
f0120c13:	68 0d 02 00 00       	push   $0x20d
f0120c18:	68 15 05 13 f0       	push   $0xf0130515
f0120c1d:	e8 17 f7 fd ff       	call   f0100339 <_panic>
f0120c22:	8b 15 f0 43 5f f0    	mov    0xf05f43f0,%edx
f0120c28:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120c2b:	89 10                	mov    %edx,(%eax)
f0120c2d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120c30:	8b 00                	mov    (%eax),%eax
f0120c32:	85 c0                	test   %eax,%eax
f0120c34:	74 0d                	je     f0120c43 <realloc_block_FF+0x31b>
f0120c36:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f0120c3b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120c3e:	89 50 04             	mov    %edx,0x4(%eax)
f0120c41:	eb 08                	jmp    f0120c4b <realloc_block_FF+0x323>
f0120c43:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120c46:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120c4b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120c4e:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120c53:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120c56:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120c5d:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120c62:	40                   	inc    %eax
f0120c63:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f0120c68:	e9 3e 01 00 00       	jmp    f0120dab <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f0120c6d:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f0120c72:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0120c75:	73 68                	jae    f0120cdf <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f0120c77:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0120c7b:	75 17                	jne    f0120c94 <realloc_block_FF+0x36c>
f0120c7d:	83 ec 04             	sub    $0x4,%esp
f0120c80:	68 64 05 13 f0       	push   $0xf0130564
f0120c85:	68 12 02 00 00       	push   $0x212
f0120c8a:	68 15 05 13 f0       	push   $0xf0130515
f0120c8f:	e8 a5 f6 fd ff       	call   f0100339 <_panic>
f0120c94:	8b 15 f4 43 5f f0    	mov    0xf05f43f4,%edx
f0120c9a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120c9d:	89 50 04             	mov    %edx,0x4(%eax)
f0120ca0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120ca3:	8b 40 04             	mov    0x4(%eax),%eax
f0120ca6:	85 c0                	test   %eax,%eax
f0120ca8:	74 0c                	je     f0120cb6 <realloc_block_FF+0x38e>
f0120caa:	a1 f4 43 5f f0       	mov    0xf05f43f4,%eax
f0120caf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120cb2:	89 10                	mov    %edx,(%eax)
f0120cb4:	eb 08                	jmp    f0120cbe <realloc_block_FF+0x396>
f0120cb6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120cb9:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120cbe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120cc1:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120cc6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120cc9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120ccf:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120cd4:	40                   	inc    %eax
f0120cd5:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
f0120cda:	e9 cc 00 00 00       	jmp    f0120dab <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f0120cdf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0120ce6:	a1 f0 43 5f f0       	mov    0xf05f43f0,%eax
f0120ceb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120cee:	e9 8a 00 00 00       	jmp    f0120d7d <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0120cf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cf6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0120cf9:	73 7a                	jae    f0120d75 <realloc_block_FF+0x44d>
f0120cfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cfe:	8b 00                	mov    (%eax),%eax
f0120d00:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0120d03:	73 70                	jae    f0120d75 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0120d05:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120d09:	74 06                	je     f0120d11 <realloc_block_FF+0x3e9>
f0120d0b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0120d0f:	75 17                	jne    f0120d28 <realloc_block_FF+0x400>
f0120d11:	83 ec 04             	sub    $0x4,%esp
f0120d14:	68 88 05 13 f0       	push   $0xf0130588
f0120d19:	68 1c 02 00 00       	push   $0x21c
f0120d1e:	68 15 05 13 f0       	push   $0xf0130515
f0120d23:	e8 11 f6 fd ff       	call   f0100339 <_panic>
f0120d28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d2b:	8b 10                	mov    (%eax),%edx
f0120d2d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120d30:	89 10                	mov    %edx,(%eax)
f0120d32:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120d35:	8b 00                	mov    (%eax),%eax
f0120d37:	85 c0                	test   %eax,%eax
f0120d39:	74 0b                	je     f0120d46 <realloc_block_FF+0x41e>
f0120d3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d3e:	8b 00                	mov    (%eax),%eax
f0120d40:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120d43:	89 50 04             	mov    %edx,0x4(%eax)
f0120d46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d49:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120d4c:	89 10                	mov    %edx,(%eax)
f0120d4e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120d51:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d54:	89 50 04             	mov    %edx,0x4(%eax)
f0120d57:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120d5a:	8b 00                	mov    (%eax),%eax
f0120d5c:	85 c0                	test   %eax,%eax
f0120d5e:	75 08                	jne    f0120d68 <realloc_block_FF+0x440>
f0120d60:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120d63:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120d68:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120d6d:	40                   	inc    %eax
f0120d6e:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
							break;
f0120d73:	eb 36                	jmp    f0120dab <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f0120d75:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f0120d7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120d7d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120d81:	74 07                	je     f0120d8a <realloc_block_FF+0x462>
f0120d83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d86:	8b 00                	mov    (%eax),%eax
f0120d88:	eb 05                	jmp    f0120d8f <realloc_block_FF+0x467>
f0120d8a:	b8 00 00 00 00       	mov    $0x0,%eax
f0120d8f:	a3 f8 43 5f f0       	mov    %eax,0xf05f43f8
f0120d94:	a1 f8 43 5f f0       	mov    0xf05f43f8,%eax
f0120d99:	85 c0                	test   %eax,%eax
f0120d9b:	0f 85 52 ff ff ff    	jne    f0120cf3 <realloc_block_FF+0x3cb>
f0120da1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120da5:	0f 85 48 ff ff ff    	jne    f0120cf3 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f0120dab:	83 ec 04             	sub    $0x4,%esp
f0120dae:	6a 00                	push   $0x0
f0120db0:	ff 75 d8             	pushl  -0x28(%ebp)
f0120db3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0120db6:	e8 7a eb ff ff       	call   f011f935 <set_block_data>
f0120dbb:	83 c4 10             	add    $0x10,%esp
				return va;
f0120dbe:	8b 45 08             	mov    0x8(%ebp),%eax
f0120dc1:	e9 7b 02 00 00       	jmp    f0121041 <realloc_block_FF+0x719>
			}
			cprintf("16\n");
f0120dc6:	83 ec 0c             	sub    $0xc,%esp
f0120dc9:	68 05 06 13 f0       	push   $0xf0130605
f0120dce:	e8 b8 01 fe ff       	call   f0100f8b <cprintf>
f0120dd3:	83 c4 10             	add    $0x10,%esp
		}
		return va;
f0120dd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0120dd9:	e9 63 02 00 00       	jmp    f0121041 <realloc_block_FF+0x719>
	}

	if(new_size > cur_size)
f0120dde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120de1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0120de4:	0f 86 4d 02 00 00    	jbe    f0121037 <realloc_block_FF+0x70f>
	{
		if(is_free_block(next_va))
f0120dea:	83 ec 0c             	sub    $0xc,%esp
f0120ded:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120df0:	e8 dc e7 ff ff       	call   f011f5d1 <is_free_block>
f0120df5:	83 c4 10             	add    $0x10,%esp
f0120df8:	84 c0                	test   %al,%al
f0120dfa:	0f 84 37 02 00 00    	je     f0121037 <realloc_block_FF+0x70f>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f0120e00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e03:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0120e06:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0120e09:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120e0c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0120e0f:	76 38                	jbe    f0120e49 <realloc_block_FF+0x521>
			{
				free_block(va); //set it free
f0120e11:	83 ec 0c             	sub    $0xc,%esp
f0120e14:	ff 75 08             	pushl  0x8(%ebp)
f0120e17:	e8 0c fa ff ff       	call   f0120828 <free_block>
f0120e1c:	83 c4 10             	add    $0x10,%esp
				void *new_va = alloc_block_FF(new_size); //new allocation
f0120e1f:	83 ec 0c             	sub    $0xc,%esp
f0120e22:	ff 75 0c             	pushl  0xc(%ebp)
f0120e25:	e8 3a eb ff ff       	call   f011f964 <alloc_block_FF>
f0120e2a:	83 c4 10             	add    $0x10,%esp
f0120e2d:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f0120e30:	83 ec 08             	sub    $0x8,%esp
f0120e33:	ff 75 c0             	pushl  -0x40(%ebp)
f0120e36:	ff 75 08             	pushl  0x8(%ebp)
f0120e39:	e8 ab fa ff ff       	call   f01208e9 <copy_data>
f0120e3e:	83 c4 10             	add    $0x10,%esp
				return new_va;
f0120e41:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120e44:	e9 f8 01 00 00       	jmp    f0121041 <realloc_block_FF+0x719>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f0120e49:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120e4c:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f0120e4f:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f0120e52:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f0120e56:	0f 87 a0 00 00 00    	ja     f0120efc <realloc_block_FF+0x5d4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f0120e5c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120e60:	75 17                	jne    f0120e79 <realloc_block_FF+0x551>
f0120e62:	83 ec 04             	sub    $0x4,%esp
f0120e65:	68 f7 04 13 f0       	push   $0xf01304f7
f0120e6a:	68 3a 02 00 00       	push   $0x23a
f0120e6f:	68 15 05 13 f0       	push   $0xf0130515
f0120e74:	e8 c0 f4 fd ff       	call   f0100339 <_panic>
f0120e79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120e7c:	8b 00                	mov    (%eax),%eax
f0120e7e:	85 c0                	test   %eax,%eax
f0120e80:	74 10                	je     f0120e92 <realloc_block_FF+0x56a>
f0120e82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120e85:	8b 00                	mov    (%eax),%eax
f0120e87:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120e8a:	8b 52 04             	mov    0x4(%edx),%edx
f0120e8d:	89 50 04             	mov    %edx,0x4(%eax)
f0120e90:	eb 0b                	jmp    f0120e9d <realloc_block_FF+0x575>
f0120e92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120e95:	8b 40 04             	mov    0x4(%eax),%eax
f0120e98:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120e9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120ea0:	8b 40 04             	mov    0x4(%eax),%eax
f0120ea3:	85 c0                	test   %eax,%eax
f0120ea5:	74 0f                	je     f0120eb6 <realloc_block_FF+0x58e>
f0120ea7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120eaa:	8b 40 04             	mov    0x4(%eax),%eax
f0120ead:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120eb0:	8b 12                	mov    (%edx),%edx
f0120eb2:	89 10                	mov    %edx,(%eax)
f0120eb4:	eb 0a                	jmp    f0120ec0 <realloc_block_FF+0x598>
f0120eb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120eb9:	8b 00                	mov    (%eax),%eax
f0120ebb:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0120ec0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120ec3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120ec9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120ecc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120ed3:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120ed8:	48                   	dec    %eax
f0120ed9:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f0120ede:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120ee1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120ee4:	01 d0                	add    %edx,%eax
f0120ee6:	83 ec 04             	sub    $0x4,%esp
f0120ee9:	6a 01                	push   $0x1
f0120eeb:	50                   	push   %eax
f0120eec:	ff 75 08             	pushl  0x8(%ebp)
f0120eef:	e8 41 ea ff ff       	call   f011f935 <set_block_data>
f0120ef4:	83 c4 10             	add    $0x10,%esp
f0120ef7:	e9 36 01 00 00       	jmp    f0121032 <realloc_block_FF+0x70a>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f0120efc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120eff:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120f02:	01 d0                	add    %edx,%eax
f0120f04:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0120f07:	83 ec 04             	sub    $0x4,%esp
f0120f0a:	6a 01                	push   $0x1
f0120f0c:	ff 75 f0             	pushl  -0x10(%ebp)
f0120f0f:	ff 75 08             	pushl  0x8(%ebp)
f0120f12:	e8 1e ea ff ff       	call   f011f935 <set_block_data>
f0120f17:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0120f1a:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f1d:	83 e8 04             	sub    $0x4,%eax
f0120f20:	8b 00                	mov    (%eax),%eax
f0120f22:	83 e0 fe             	and    $0xfffffffe,%eax
f0120f25:	89 c2                	mov    %eax,%edx
f0120f27:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f2a:	01 d0                	add    %edx,%eax
f0120f2c:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0120f2f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120f33:	74 06                	je     f0120f3b <realloc_block_FF+0x613>
f0120f35:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0120f39:	75 17                	jne    f0120f52 <realloc_block_FF+0x62a>
f0120f3b:	83 ec 04             	sub    $0x4,%esp
f0120f3e:	68 88 05 13 f0       	push   $0xf0130588
f0120f43:	68 46 02 00 00       	push   $0x246
f0120f48:	68 15 05 13 f0       	push   $0xf0130515
f0120f4d:	e8 e7 f3 fd ff       	call   f0100339 <_panic>
f0120f52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120f55:	8b 10                	mov    (%eax),%edx
f0120f57:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120f5a:	89 10                	mov    %edx,(%eax)
f0120f5c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120f5f:	8b 00                	mov    (%eax),%eax
f0120f61:	85 c0                	test   %eax,%eax
f0120f63:	74 0b                	je     f0120f70 <realloc_block_FF+0x648>
f0120f65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120f68:	8b 00                	mov    (%eax),%eax
f0120f6a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0120f6d:	89 50 04             	mov    %edx,0x4(%eax)
f0120f70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120f73:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0120f76:	89 10                	mov    %edx,(%eax)
f0120f78:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120f7b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120f7e:	89 50 04             	mov    %edx,0x4(%eax)
f0120f81:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120f84:	8b 00                	mov    (%eax),%eax
f0120f86:	85 c0                	test   %eax,%eax
f0120f88:	75 08                	jne    f0120f92 <realloc_block_FF+0x66a>
f0120f8a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120f8d:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120f92:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0120f97:	40                   	inc    %eax
f0120f98:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0120f9d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120fa1:	75 17                	jne    f0120fba <realloc_block_FF+0x692>
f0120fa3:	83 ec 04             	sub    $0x4,%esp
f0120fa6:	68 f7 04 13 f0       	push   $0xf01304f7
f0120fab:	68 47 02 00 00       	push   $0x247
f0120fb0:	68 15 05 13 f0       	push   $0xf0130515
f0120fb5:	e8 7f f3 fd ff       	call   f0100339 <_panic>
f0120fba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120fbd:	8b 00                	mov    (%eax),%eax
f0120fbf:	85 c0                	test   %eax,%eax
f0120fc1:	74 10                	je     f0120fd3 <realloc_block_FF+0x6ab>
f0120fc3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120fc6:	8b 00                	mov    (%eax),%eax
f0120fc8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120fcb:	8b 52 04             	mov    0x4(%edx),%edx
f0120fce:	89 50 04             	mov    %edx,0x4(%eax)
f0120fd1:	eb 0b                	jmp    f0120fde <realloc_block_FF+0x6b6>
f0120fd3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120fd6:	8b 40 04             	mov    0x4(%eax),%eax
f0120fd9:	a3 f4 43 5f f0       	mov    %eax,0xf05f43f4
f0120fde:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120fe1:	8b 40 04             	mov    0x4(%eax),%eax
f0120fe4:	85 c0                	test   %eax,%eax
f0120fe6:	74 0f                	je     f0120ff7 <realloc_block_FF+0x6cf>
f0120fe8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120feb:	8b 40 04             	mov    0x4(%eax),%eax
f0120fee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120ff1:	8b 12                	mov    (%edx),%edx
f0120ff3:	89 10                	mov    %edx,(%eax)
f0120ff5:	eb 0a                	jmp    f0121001 <realloc_block_FF+0x6d9>
f0120ff7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120ffa:	8b 00                	mov    (%eax),%eax
f0120ffc:	a3 f0 43 5f f0       	mov    %eax,0xf05f43f0
f0121001:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121004:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012100a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012100d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121014:	a1 fc 43 5f f0       	mov    0xf05f43fc,%eax
f0121019:	48                   	dec    %eax
f012101a:	a3 fc 43 5f f0       	mov    %eax,0xf05f43fc
				set_block_data(next_new_va, remaining_size, 0);
f012101f:	83 ec 04             	sub    $0x4,%esp
f0121022:	6a 00                	push   $0x0
f0121024:	ff 75 bc             	pushl  -0x44(%ebp)
f0121027:	ff 75 b8             	pushl  -0x48(%ebp)
f012102a:	e8 06 e9 ff ff       	call   f011f935 <set_block_data>
f012102f:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f0121032:	8b 45 08             	mov    0x8(%ebp),%eax
f0121035:	eb 0a                	jmp    f0121041 <realloc_block_FF+0x719>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f0121037:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f012103e:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0121041:	c9                   	leave  
f0121042:	c3                   	ret    

f0121043 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0121043:	55                   	push   %ebp
f0121044:	89 e5                	mov    %esp,%ebp
f0121046:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0121049:	83 ec 04             	sub    $0x4,%esp
f012104c:	68 0c 06 13 f0       	push   $0xf013060c
f0121051:	68 5a 02 00 00       	push   $0x25a
f0121056:	68 15 05 13 f0       	push   $0xf0130515
f012105b:	e8 d9 f2 fd ff       	call   f0100339 <_panic>

f0121060 <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0121060:	55                   	push   %ebp
f0121061:	89 e5                	mov    %esp,%ebp
f0121063:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0121066:	83 ec 04             	sub    $0x4,%esp
f0121069:	68 34 06 13 f0       	push   $0xf0130634
f012106e:	68 63 02 00 00       	push   $0x263
f0121073:	68 15 05 13 f0       	push   $0xf0130515
f0121078:	e8 bc f2 fd ff       	call   f0100339 <_panic>
f012107d:	66 90                	xchg   %ax,%ax
f012107f:	90                   	nop

f0121080 <__moddi3>:
f0121080:	55                   	push   %ebp
f0121081:	57                   	push   %edi
f0121082:	56                   	push   %esi
f0121083:	53                   	push   %ebx
f0121084:	83 ec 2c             	sub    $0x2c,%esp
f0121087:	8b 74 24 40          	mov    0x40(%esp),%esi
f012108b:	8b 7c 24 44          	mov    0x44(%esp),%edi
f012108f:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0121093:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0121097:	89 d8                	mov    %ebx,%eax
f0121099:	85 ff                	test   %edi,%edi
f012109b:	0f 88 d3 00 00 00    	js     f0121174 <__moddi3+0xf4>
f01210a1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f01210a8:	00 
f01210a9:	85 c0                	test   %eax,%eax
f01210ab:	0f 88 ab 00 00 00    	js     f012115c <__moddi3+0xdc>
f01210b1:	89 0c 24             	mov    %ecx,(%esp)
f01210b4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f01210b8:	89 74 24 10          	mov    %esi,0x10(%esp)
f01210bc:	89 fb                	mov    %edi,%ebx
f01210be:	8b 14 24             	mov    (%esp),%edx
f01210c1:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f01210c5:	89 d0                	mov    %edx,%eax
f01210c7:	89 54 24 18          	mov    %edx,0x18(%esp)
f01210cb:	89 ca                	mov    %ecx,%edx
f01210cd:	8b 0c 24             	mov    (%esp),%ecx
f01210d0:	89 34 24             	mov    %esi,(%esp)
f01210d3:	89 7c 24 14          	mov    %edi,0x14(%esp)
f01210d7:	85 d2                	test   %edx,%edx
f01210d9:	75 15                	jne    f01210f0 <__moddi3+0x70>
f01210db:	89 c7                	mov    %eax,%edi
f01210dd:	39 d8                	cmp    %ebx,%eax
f01210df:	76 5b                	jbe    f012113c <__moddi3+0xbc>
f01210e1:	89 f0                	mov    %esi,%eax
f01210e3:	89 da                	mov    %ebx,%edx
f01210e5:	f7 f7                	div    %edi
f01210e7:	89 d3                	mov    %edx,%ebx
f01210e9:	89 d8                	mov    %ebx,%eax
f01210eb:	31 d2                	xor    %edx,%edx
f01210ed:	eb 09                	jmp    f01210f8 <__moddi3+0x78>
f01210ef:	90                   	nop
f01210f0:	39 fa                	cmp    %edi,%edx
f01210f2:	76 1c                	jbe    f0121110 <__moddi3+0x90>
f01210f4:	89 f0                	mov    %esi,%eax
f01210f6:	89 fa                	mov    %edi,%edx
f01210f8:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f01210fc:	85 c9                	test   %ecx,%ecx
f01210fe:	74 07                	je     f0121107 <__moddi3+0x87>
f0121100:	f7 d8                	neg    %eax
f0121102:	83 d2 00             	adc    $0x0,%edx
f0121105:	f7 da                	neg    %edx
f0121107:	83 c4 2c             	add    $0x2c,%esp
f012110a:	5b                   	pop    %ebx
f012110b:	5e                   	pop    %esi
f012110c:	5f                   	pop    %edi
f012110d:	5d                   	pop    %ebp
f012110e:	c3                   	ret    
f012110f:	90                   	nop
f0121110:	0f bd c2             	bsr    %edx,%eax
f0121113:	83 f0 1f             	xor    $0x1f,%eax
f0121116:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f012111a:	75 6c                	jne    f0121188 <__moddi3+0x108>
f012111c:	39 fa                	cmp    %edi,%edx
f012111e:	72 05                	jb     f0121125 <__moddi3+0xa5>
f0121120:	3b 0c 24             	cmp    (%esp),%ecx
f0121123:	77 0e                	ja     f0121133 <__moddi3+0xb3>
f0121125:	8b 34 24             	mov    (%esp),%esi
f0121128:	29 ce                	sub    %ecx,%esi
f012112a:	19 d3                	sbb    %edx,%ebx
f012112c:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0121130:	89 34 24             	mov    %esi,(%esp)
f0121133:	8b 04 24             	mov    (%esp),%eax
f0121136:	8b 54 24 14          	mov    0x14(%esp),%edx
f012113a:	eb bc                	jmp    f01210f8 <__moddi3+0x78>
f012113c:	85 c9                	test   %ecx,%ecx
f012113e:	75 0b                	jne    f012114b <__moddi3+0xcb>
f0121140:	b8 01 00 00 00       	mov    $0x1,%eax
f0121145:	31 d2                	xor    %edx,%edx
f0121147:	f7 f1                	div    %ecx
f0121149:	89 c1                	mov    %eax,%ecx
f012114b:	89 d8                	mov    %ebx,%eax
f012114d:	31 d2                	xor    %edx,%edx
f012114f:	f7 f1                	div    %ecx
f0121151:	8b 04 24             	mov    (%esp),%eax
f0121154:	f7 f1                	div    %ecx
f0121156:	89 d3                	mov    %edx,%ebx
f0121158:	eb 8f                	jmp    f01210e9 <__moddi3+0x69>
f012115a:	66 90                	xchg   %ax,%ax
f012115c:	89 c8                	mov    %ecx,%eax
f012115e:	89 da                	mov    %ebx,%edx
f0121160:	f7 d8                	neg    %eax
f0121162:	83 d2 00             	adc    $0x0,%edx
f0121165:	f7 da                	neg    %edx
f0121167:	89 04 24             	mov    %eax,(%esp)
f012116a:	89 54 24 04          	mov    %edx,0x4(%esp)
f012116e:	e9 45 ff ff ff       	jmp    f01210b8 <__moddi3+0x38>
f0121173:	90                   	nop
f0121174:	f7 de                	neg    %esi
f0121176:	83 d7 00             	adc    $0x0,%edi
f0121179:	f7 df                	neg    %edi
f012117b:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0121182:	ff 
f0121183:	e9 21 ff ff ff       	jmp    f01210a9 <__moddi3+0x29>
f0121188:	b8 20 00 00 00       	mov    $0x20,%eax
f012118d:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0121191:	29 f8                	sub    %edi,%eax
f0121193:	89 c6                	mov    %eax,%esi
f0121195:	89 44 24 14          	mov    %eax,0x14(%esp)
f0121199:	89 f9                	mov    %edi,%ecx
f012119b:	d3 e2                	shl    %cl,%edx
f012119d:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f01211a1:	89 e8                	mov    %ebp,%eax
f01211a3:	89 f1                	mov    %esi,%ecx
f01211a5:	d3 e8                	shr    %cl,%eax
f01211a7:	09 d0                	or     %edx,%eax
f01211a9:	89 04 24             	mov    %eax,(%esp)
f01211ac:	89 ea                	mov    %ebp,%edx
f01211ae:	89 f9                	mov    %edi,%ecx
f01211b0:	d3 e2                	shl    %cl,%edx
f01211b2:	89 d7                	mov    %edx,%edi
f01211b4:	89 da                	mov    %ebx,%edx
f01211b6:	d3 e2                	shl    %cl,%edx
f01211b8:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f01211bc:	d3 e5                	shl    %cl,%ebp
f01211be:	8b 44 24 10          	mov    0x10(%esp),%eax
f01211c2:	89 f1                	mov    %esi,%ecx
f01211c4:	d3 e8                	shr    %cl,%eax
f01211c6:	09 d0                	or     %edx,%eax
f01211c8:	d3 eb                	shr    %cl,%ebx
f01211ca:	89 da                	mov    %ebx,%edx
f01211cc:	f7 34 24             	divl   (%esp)
f01211cf:	89 d3                	mov    %edx,%ebx
f01211d1:	f7 e7                	mul    %edi
f01211d3:	89 c6                	mov    %eax,%esi
f01211d5:	89 d1                	mov    %edx,%ecx
f01211d7:	39 d3                	cmp    %edx,%ebx
f01211d9:	72 29                	jb     f0121204 <__moddi3+0x184>
f01211db:	74 33                	je     f0121210 <__moddi3+0x190>
f01211dd:	89 e8                	mov    %ebp,%eax
f01211df:	29 f0                	sub    %esi,%eax
f01211e1:	19 cb                	sbb    %ecx,%ebx
f01211e3:	89 de                	mov    %ebx,%esi
f01211e5:	8a 4c 24 14          	mov    0x14(%esp),%cl
f01211e9:	d3 e6                	shl    %cl,%esi
f01211eb:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01211ef:	89 f9                	mov    %edi,%ecx
f01211f1:	d3 e8                	shr    %cl,%eax
f01211f3:	09 c6                	or     %eax,%esi
f01211f5:	89 f0                	mov    %esi,%eax
f01211f7:	89 f9                	mov    %edi,%ecx
f01211f9:	d3 eb                	shr    %cl,%ebx
f01211fb:	89 da                	mov    %ebx,%edx
f01211fd:	e9 f6 fe ff ff       	jmp    f01210f8 <__moddi3+0x78>
f0121202:	66 90                	xchg   %ax,%ax
f0121204:	29 f8                	sub    %edi,%eax
f0121206:	1b 14 24             	sbb    (%esp),%edx
f0121209:	89 d1                	mov    %edx,%ecx
f012120b:	89 c6                	mov    %eax,%esi
f012120d:	eb ce                	jmp    f01211dd <__moddi3+0x15d>
f012120f:	90                   	nop
f0121210:	39 c5                	cmp    %eax,%ebp
f0121212:	72 f0                	jb     f0121204 <__moddi3+0x184>
f0121214:	89 d9                	mov    %ebx,%ecx
f0121216:	eb c5                	jmp    f01211dd <__moddi3+0x15d>

f0121218 <__udivdi3>:
f0121218:	55                   	push   %ebp
f0121219:	57                   	push   %edi
f012121a:	56                   	push   %esi
f012121b:	53                   	push   %ebx
f012121c:	83 ec 1c             	sub    $0x1c,%esp
f012121f:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0121223:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0121227:	8b 7c 24 38          	mov    0x38(%esp),%edi
f012122b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f012122f:	89 ca                	mov    %ecx,%edx
f0121231:	89 f8                	mov    %edi,%eax
f0121233:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0121237:	85 f6                	test   %esi,%esi
f0121239:	75 2d                	jne    f0121268 <__udivdi3+0x50>
f012123b:	39 cf                	cmp    %ecx,%edi
f012123d:	77 65                	ja     f01212a4 <__udivdi3+0x8c>
f012123f:	89 fd                	mov    %edi,%ebp
f0121241:	85 ff                	test   %edi,%edi
f0121243:	75 0b                	jne    f0121250 <__udivdi3+0x38>
f0121245:	b8 01 00 00 00       	mov    $0x1,%eax
f012124a:	31 d2                	xor    %edx,%edx
f012124c:	f7 f7                	div    %edi
f012124e:	89 c5                	mov    %eax,%ebp
f0121250:	31 d2                	xor    %edx,%edx
f0121252:	89 c8                	mov    %ecx,%eax
f0121254:	f7 f5                	div    %ebp
f0121256:	89 c1                	mov    %eax,%ecx
f0121258:	89 d8                	mov    %ebx,%eax
f012125a:	f7 f5                	div    %ebp
f012125c:	89 cf                	mov    %ecx,%edi
f012125e:	89 fa                	mov    %edi,%edx
f0121260:	83 c4 1c             	add    $0x1c,%esp
f0121263:	5b                   	pop    %ebx
f0121264:	5e                   	pop    %esi
f0121265:	5f                   	pop    %edi
f0121266:	5d                   	pop    %ebp
f0121267:	c3                   	ret    
f0121268:	39 ce                	cmp    %ecx,%esi
f012126a:	77 28                	ja     f0121294 <__udivdi3+0x7c>
f012126c:	0f bd fe             	bsr    %esi,%edi
f012126f:	83 f7 1f             	xor    $0x1f,%edi
f0121272:	75 40                	jne    f01212b4 <__udivdi3+0x9c>
f0121274:	39 ce                	cmp    %ecx,%esi
f0121276:	72 0a                	jb     f0121282 <__udivdi3+0x6a>
f0121278:	3b 44 24 08          	cmp    0x8(%esp),%eax
f012127c:	0f 87 9e 00 00 00    	ja     f0121320 <__udivdi3+0x108>
f0121282:	b8 01 00 00 00       	mov    $0x1,%eax
f0121287:	89 fa                	mov    %edi,%edx
f0121289:	83 c4 1c             	add    $0x1c,%esp
f012128c:	5b                   	pop    %ebx
f012128d:	5e                   	pop    %esi
f012128e:	5f                   	pop    %edi
f012128f:	5d                   	pop    %ebp
f0121290:	c3                   	ret    
f0121291:	8d 76 00             	lea    0x0(%esi),%esi
f0121294:	31 ff                	xor    %edi,%edi
f0121296:	31 c0                	xor    %eax,%eax
f0121298:	89 fa                	mov    %edi,%edx
f012129a:	83 c4 1c             	add    $0x1c,%esp
f012129d:	5b                   	pop    %ebx
f012129e:	5e                   	pop    %esi
f012129f:	5f                   	pop    %edi
f01212a0:	5d                   	pop    %ebp
f01212a1:	c3                   	ret    
f01212a2:	66 90                	xchg   %ax,%ax
f01212a4:	89 d8                	mov    %ebx,%eax
f01212a6:	f7 f7                	div    %edi
f01212a8:	31 ff                	xor    %edi,%edi
f01212aa:	89 fa                	mov    %edi,%edx
f01212ac:	83 c4 1c             	add    $0x1c,%esp
f01212af:	5b                   	pop    %ebx
f01212b0:	5e                   	pop    %esi
f01212b1:	5f                   	pop    %edi
f01212b2:	5d                   	pop    %ebp
f01212b3:	c3                   	ret    
f01212b4:	bd 20 00 00 00       	mov    $0x20,%ebp
f01212b9:	89 eb                	mov    %ebp,%ebx
f01212bb:	29 fb                	sub    %edi,%ebx
f01212bd:	89 f9                	mov    %edi,%ecx
f01212bf:	d3 e6                	shl    %cl,%esi
f01212c1:	89 c5                	mov    %eax,%ebp
f01212c3:	88 d9                	mov    %bl,%cl
f01212c5:	d3 ed                	shr    %cl,%ebp
f01212c7:	89 e9                	mov    %ebp,%ecx
f01212c9:	09 f1                	or     %esi,%ecx
f01212cb:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f01212cf:	89 f9                	mov    %edi,%ecx
f01212d1:	d3 e0                	shl    %cl,%eax
f01212d3:	89 c5                	mov    %eax,%ebp
f01212d5:	89 d6                	mov    %edx,%esi
f01212d7:	88 d9                	mov    %bl,%cl
f01212d9:	d3 ee                	shr    %cl,%esi
f01212db:	89 f9                	mov    %edi,%ecx
f01212dd:	d3 e2                	shl    %cl,%edx
f01212df:	8b 44 24 08          	mov    0x8(%esp),%eax
f01212e3:	88 d9                	mov    %bl,%cl
f01212e5:	d3 e8                	shr    %cl,%eax
f01212e7:	09 c2                	or     %eax,%edx
f01212e9:	89 d0                	mov    %edx,%eax
f01212eb:	89 f2                	mov    %esi,%edx
f01212ed:	f7 74 24 0c          	divl   0xc(%esp)
f01212f1:	89 d6                	mov    %edx,%esi
f01212f3:	89 c3                	mov    %eax,%ebx
f01212f5:	f7 e5                	mul    %ebp
f01212f7:	39 d6                	cmp    %edx,%esi
f01212f9:	72 19                	jb     f0121314 <__udivdi3+0xfc>
f01212fb:	74 0b                	je     f0121308 <__udivdi3+0xf0>
f01212fd:	89 d8                	mov    %ebx,%eax
f01212ff:	31 ff                	xor    %edi,%edi
f0121301:	e9 58 ff ff ff       	jmp    f012125e <__udivdi3+0x46>
f0121306:	66 90                	xchg   %ax,%ax
f0121308:	8b 54 24 08          	mov    0x8(%esp),%edx
f012130c:	89 f9                	mov    %edi,%ecx
f012130e:	d3 e2                	shl    %cl,%edx
f0121310:	39 c2                	cmp    %eax,%edx
f0121312:	73 e9                	jae    f01212fd <__udivdi3+0xe5>
f0121314:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0121317:	31 ff                	xor    %edi,%edi
f0121319:	e9 40 ff ff ff       	jmp    f012125e <__udivdi3+0x46>
f012131e:	66 90                	xchg   %ax,%ax
f0121320:	31 c0                	xor    %eax,%eax
f0121322:	e9 37 ff ff ff       	jmp    f012125e <__udivdi3+0x46>
f0121327:	90                   	nop

f0121328 <__umoddi3>:
f0121328:	55                   	push   %ebp
f0121329:	57                   	push   %edi
f012132a:	56                   	push   %esi
f012132b:	53                   	push   %ebx
f012132c:	83 ec 1c             	sub    $0x1c,%esp
f012132f:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f0121333:	8b 74 24 34          	mov    0x34(%esp),%esi
f0121337:	8b 7c 24 38          	mov    0x38(%esp),%edi
f012133b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f012133f:	89 44 24 0c          	mov    %eax,0xc(%esp)
f0121343:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0121347:	89 f3                	mov    %esi,%ebx
f0121349:	89 fa                	mov    %edi,%edx
f012134b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f012134f:	89 34 24             	mov    %esi,(%esp)
f0121352:	85 c0                	test   %eax,%eax
f0121354:	75 1a                	jne    f0121370 <__umoddi3+0x48>
f0121356:	39 f7                	cmp    %esi,%edi
f0121358:	0f 86 a2 00 00 00    	jbe    f0121400 <__umoddi3+0xd8>
f012135e:	89 c8                	mov    %ecx,%eax
f0121360:	89 f2                	mov    %esi,%edx
f0121362:	f7 f7                	div    %edi
f0121364:	89 d0                	mov    %edx,%eax
f0121366:	31 d2                	xor    %edx,%edx
f0121368:	83 c4 1c             	add    $0x1c,%esp
f012136b:	5b                   	pop    %ebx
f012136c:	5e                   	pop    %esi
f012136d:	5f                   	pop    %edi
f012136e:	5d                   	pop    %ebp
f012136f:	c3                   	ret    
f0121370:	39 f0                	cmp    %esi,%eax
f0121372:	0f 87 ac 00 00 00    	ja     f0121424 <__umoddi3+0xfc>
f0121378:	0f bd e8             	bsr    %eax,%ebp
f012137b:	83 f5 1f             	xor    $0x1f,%ebp
f012137e:	0f 84 ac 00 00 00    	je     f0121430 <__umoddi3+0x108>
f0121384:	bf 20 00 00 00       	mov    $0x20,%edi
f0121389:	29 ef                	sub    %ebp,%edi
f012138b:	89 fe                	mov    %edi,%esi
f012138d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0121391:	89 e9                	mov    %ebp,%ecx
f0121393:	d3 e0                	shl    %cl,%eax
f0121395:	89 d7                	mov    %edx,%edi
f0121397:	89 f1                	mov    %esi,%ecx
f0121399:	d3 ef                	shr    %cl,%edi
f012139b:	09 c7                	or     %eax,%edi
f012139d:	89 e9                	mov    %ebp,%ecx
f012139f:	d3 e2                	shl    %cl,%edx
f01213a1:	89 14 24             	mov    %edx,(%esp)
f01213a4:	89 d8                	mov    %ebx,%eax
f01213a6:	d3 e0                	shl    %cl,%eax
f01213a8:	89 c2                	mov    %eax,%edx
f01213aa:	8b 44 24 08          	mov    0x8(%esp),%eax
f01213ae:	d3 e0                	shl    %cl,%eax
f01213b0:	89 44 24 04          	mov    %eax,0x4(%esp)
f01213b4:	8b 44 24 08          	mov    0x8(%esp),%eax
f01213b8:	89 f1                	mov    %esi,%ecx
f01213ba:	d3 e8                	shr    %cl,%eax
f01213bc:	09 d0                	or     %edx,%eax
f01213be:	d3 eb                	shr    %cl,%ebx
f01213c0:	89 da                	mov    %ebx,%edx
f01213c2:	f7 f7                	div    %edi
f01213c4:	89 d3                	mov    %edx,%ebx
f01213c6:	f7 24 24             	mull   (%esp)
f01213c9:	89 c6                	mov    %eax,%esi
f01213cb:	89 d1                	mov    %edx,%ecx
f01213cd:	39 d3                	cmp    %edx,%ebx
f01213cf:	0f 82 87 00 00 00    	jb     f012145c <__umoddi3+0x134>
f01213d5:	0f 84 91 00 00 00    	je     f012146c <__umoddi3+0x144>
f01213db:	8b 54 24 04          	mov    0x4(%esp),%edx
f01213df:	29 f2                	sub    %esi,%edx
f01213e1:	19 cb                	sbb    %ecx,%ebx
f01213e3:	89 d8                	mov    %ebx,%eax
f01213e5:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f01213e9:	d3 e0                	shl    %cl,%eax
f01213eb:	89 e9                	mov    %ebp,%ecx
f01213ed:	d3 ea                	shr    %cl,%edx
f01213ef:	09 d0                	or     %edx,%eax
f01213f1:	89 e9                	mov    %ebp,%ecx
f01213f3:	d3 eb                	shr    %cl,%ebx
f01213f5:	89 da                	mov    %ebx,%edx
f01213f7:	83 c4 1c             	add    $0x1c,%esp
f01213fa:	5b                   	pop    %ebx
f01213fb:	5e                   	pop    %esi
f01213fc:	5f                   	pop    %edi
f01213fd:	5d                   	pop    %ebp
f01213fe:	c3                   	ret    
f01213ff:	90                   	nop
f0121400:	89 fd                	mov    %edi,%ebp
f0121402:	85 ff                	test   %edi,%edi
f0121404:	75 0b                	jne    f0121411 <__umoddi3+0xe9>
f0121406:	b8 01 00 00 00       	mov    $0x1,%eax
f012140b:	31 d2                	xor    %edx,%edx
f012140d:	f7 f7                	div    %edi
f012140f:	89 c5                	mov    %eax,%ebp
f0121411:	89 f0                	mov    %esi,%eax
f0121413:	31 d2                	xor    %edx,%edx
f0121415:	f7 f5                	div    %ebp
f0121417:	89 c8                	mov    %ecx,%eax
f0121419:	f7 f5                	div    %ebp
f012141b:	89 d0                	mov    %edx,%eax
f012141d:	e9 44 ff ff ff       	jmp    f0121366 <__umoddi3+0x3e>
f0121422:	66 90                	xchg   %ax,%ax
f0121424:	89 c8                	mov    %ecx,%eax
f0121426:	89 f2                	mov    %esi,%edx
f0121428:	83 c4 1c             	add    $0x1c,%esp
f012142b:	5b                   	pop    %ebx
f012142c:	5e                   	pop    %esi
f012142d:	5f                   	pop    %edi
f012142e:	5d                   	pop    %ebp
f012142f:	c3                   	ret    
f0121430:	3b 04 24             	cmp    (%esp),%eax
f0121433:	72 06                	jb     f012143b <__umoddi3+0x113>
f0121435:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0121439:	77 0f                	ja     f012144a <__umoddi3+0x122>
f012143b:	89 f2                	mov    %esi,%edx
f012143d:	29 f9                	sub    %edi,%ecx
f012143f:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f0121443:	89 14 24             	mov    %edx,(%esp)
f0121446:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f012144a:	8b 44 24 04          	mov    0x4(%esp),%eax
f012144e:	8b 14 24             	mov    (%esp),%edx
f0121451:	83 c4 1c             	add    $0x1c,%esp
f0121454:	5b                   	pop    %ebx
f0121455:	5e                   	pop    %esi
f0121456:	5f                   	pop    %edi
f0121457:	5d                   	pop    %ebp
f0121458:	c3                   	ret    
f0121459:	8d 76 00             	lea    0x0(%esi),%esi
f012145c:	2b 04 24             	sub    (%esp),%eax
f012145f:	19 fa                	sbb    %edi,%edx
f0121461:	89 d1                	mov    %edx,%ecx
f0121463:	89 c6                	mov    %eax,%esi
f0121465:	e9 71 ff ff ff       	jmp    f01213db <__umoddi3+0xb3>
f012146a:	66 90                	xchg   %ax,%ax
f012146c:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0121470:	72 ea                	jb     f012145c <__umoddi3+0x134>
f0121472:	89 d9                	mov    %ebx,%ecx
f0121474:	e9 62 ff ff ff       	jmp    f01213db <__umoddi3+0xb3>
