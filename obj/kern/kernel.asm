
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 00 18 00 	lgdtl  0x180018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 00 18 f0       	mov    $0xf0180000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 18 f6 b1 f0 01 	movl   $0x1,0xf0b1f618
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 64 f5 b1 f0 01 	movl   $0x1,0xf0b1f564
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba d0 22 6b f2       	mov    $0xf26b22d0,%edx
f010006a:	b8 3c 63 6f f0       	mov    $0xf06f633c,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 3c 63 6f f0       	push   $0xf06f633c
f010007e:	e8 cd 00 02 00       	call   f0120150 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 40 28 12 f0       	push   $0xf0122840
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 87 28 12 f0       	push   $0xf0122887
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 9b 28 12 f0       	push   $0xf012289b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 af 28 12 f0       	push   $0xf01228af
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 67 73 00 00       	call   f0107441 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 bb 28 12 f0       	push   $0xf01228bb
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 c3 28 12 f0       	push   $0xf01228c3
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 ac 7c 00 00       	call   f0107dae <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 4d 78 00 00       	call   f0107954 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 ed 7f 00 00       	call   f01080f9 <initialize_paging>
		sharing_init();
f010010c:	e8 5e 8c 00 00       	call   f0108d6f <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 48 94 00 00       	call   f0109570 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 e9 f7 00 00       	call   f010f919 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 d2 f8 00 00       	call   f010fa16 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 ad f8 00 00       	call   f010f9fe <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 cd f8 00 00       	call   f010fa2e <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 3e 05 02 00       	call   f01206a7 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 d1 28 12 f0       	push   $0xf01228d1
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 53 af 00 00       	call   f010b0d1 <env_init>
		ts_init();
f010017e:	e8 37 d1 00 00       	call   f010d2ba <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 bb 28 12 f0       	push   $0xf01228bb
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 e4 28 12 f0       	push   $0xf01228e4
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 85 6f 00 00       	call   f010712d <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 0d 29 12 f0       	push   $0xf012290d
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 5d 71 00 00       	call   f010731f <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 23 29 12 f0       	push   $0xf0122923
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 40 71 00 00       	call   f010731f <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 40 29 12 f0       	push   $0xf0122940
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 23 71 00 00       	call   f010731f <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 5f 29 12 f0       	push   $0xf012295f
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 7c 29 12 f0       	push   $0xf012297c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 c2 4b 00 00       	call   f0104de6 <kclock_init>
		sched_init() ;
f0100224:	e8 b8 67 00 00       	call   f01069e1 <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 a0 29 12 f0       	push   $0xf01229a0
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 00 18 f0       	mov    $0xf0180000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 c0 29 12 f0       	push   $0xf01229c0
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 e4 29 12 f0       	push   $0xf01229e4
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 dc f8 f1 f0 00 	movl   $0x0,0xf0f1f8dc
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 2c 2a 12 f0       	push   $0xf0122a2c
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 58 2a 12 f0       	push   $0xf0122a58
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 7d 2a 12 f0       	push   $0xf0122a7d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 84 2a 12 f0       	push   $0xf0122a84
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 cc 2a 12 f0       	push   $0xf0122acc
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 14 2b 12 f0       	push   $0xf0122b14
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 cc 2a 12 f0       	push   $0xf0122acc
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 84 2a 12 f0       	push   $0xf0122a84
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 59 2b 12 f0       	push   $0xf0122b59
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 e1 b9 00 00       	call   f010bd25 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 40 63 6f f0       	mov    %eax,0xf06f6340

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 60 2b 12 f0       	push   $0xf0122b60
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 85 2b 12 f0       	push   $0xf0122b85
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 3d b9 00 00       	call   f010bce3 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 87 2b 12 f0       	push   $0xf0122b87
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 40 63 6f f0       	mov    %eax,0xf06f6340

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 91 2b 12 f0       	push   $0xf0122b91
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 85 2b 12 f0       	push   $0xf0122b85
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 dd 70 00 00       	call   f01074fa <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 15 70 00 00       	call   f0107437 <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 16 71 00 00       	call   f010754c <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 ff 62 00 00       	call   f0106740 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 df b8 00 00       	call   f010bd25 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 84 b8 00 00       	call   f010bce3 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 40 63 6f f0       	mov    %eax,0xf06f6340

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 91 2b 12 f0       	push   $0xf0122b91
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 85 2b 12 f0       	push   $0xf0122b85
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 6d b8 00 00       	call   f010bd25 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 12 b8 00 00       	call   f010bce3 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 aa 2b 12 f0       	push   $0xf0122baa
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 85 2b 12 f0       	push   $0xf0122b85
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 64 63 6f f0       	mov    0xf06f6364,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 c8 2b 12 f0       	push   $0xf0122bc8
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 64 63 6f f0       	mov    %eax,0xf06f6364
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 49 df 00 00       	call   f010e5be <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 68 63 6f f0 b4 	movl   $0x3b4,0xf06f6368
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 68 63 6f f0 d4 	movl   $0x3d4,0xf06f6368
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 6c 63 6f f0       	mov    %eax,0xf06f636c
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 6c 63 6f f0    	mov    0xf06f636c,%edx
f010087a:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
		text_length = 0;
f01008a6:	c7 05 60 63 6f f0 00 	movl   $0x0,0xf06f6360
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d 70 63 6f f0 	mov    0xf06f6370,%cx
f01008b7:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d 6c 63 6f f0    	mov    0xf06f636c,%ecx
f0100972:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 70 63 6f f0 	mov    %dx,0xf06f6370
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 60 63 6f f0    	mov    0xf06f6360,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 60 63 6f f0       	mov    0xf06f6360,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 60 63 6f f0       	mov    %eax,0xf06f6360
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 6c 63 6f f0       	mov    0xf06f636c,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 6c 63 6f f0       	mov    0xf06f636c,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 95 f7 01 00       	call   f0120180 <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 6c 63 6f f0    	mov    0xf06f636c,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 70 63 6f f0    	mov    %ax,0xf06f6370
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 68 63 6f f0    	mov    0xf06f6368,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 68 63 6f f0       	mov    0xf06f6368,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 68 63 6f f0    	mov    0xf06f6368,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 88 65 6f f0       	mov    %eax,0xf06f6588
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 00 18 f0    	mov    -0xfe7ffe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 88 65 6f f0       	mov    %eax,0xf06f6588
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 88 65 6f f0       	mov    %eax,0xf06f6588
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 00 18 f0    	mov    -0xfe7ffe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 88 65 6f f0       	mov    %eax,0xf06f6588
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 01 18 f0    	mov    -0xfe7fee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 88 65 6f f0       	mov    %eax,0xf06f6588

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 05 18 f0 	mov    -0xfe7fae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 60 63 6f f0       	mov    0xf06f6360,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 60 63 6f f0    	mov    0xf06f6360,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 60 63 6f f0       	mov    0xf06f6360,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 60 63 6f f0       	mov    %eax,0xf06f6360
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 70 63 6f f0    	mov    0xf06f6370,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 6c 63 6f f0    	mov    0xf06f636c,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 6c 63 6f f0       	mov    0xf06f636c,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 60 63 6f f0       	mov    0xf06f6360,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 88 65 6f f0       	mov    0xf06f6588,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 db 2b 12 f0       	push   $0xf0122bdb
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 a9 d8 00 00       	call   f010e5be <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 84 65 6f f0       	mov    0xf06f6584,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 84 65 6f f0    	mov    %edx,0xf06f6584
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 80 63 6f f0    	mov    %dl,-0xf909c80(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 84 65 6f f0       	mov    0xf06f6584,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 84 65 6f f0 00 	movl   $0x0,0xf06f6584
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 80 65 6f f0    	mov    0xf06f6580,%edx
f0100d7f:	a1 84 65 6f f0       	mov    0xf06f6584,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 80 65 6f f0       	mov    0xf06f6580,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 80 65 6f f0    	mov    %edx,0xf06f6580
f0100d96:	8a 80 80 63 6f f0    	mov    -0xf909c80(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 80 65 6f f0       	mov    0xf06f6580,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 80 65 6f f0 00 	movl   $0x0,0xf06f6580
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 80 65 6f f0    	mov    0xf06f6580,%edx
f0100dd0:	a1 84 65 6f f0       	mov    0xf06f6584,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 80 65 6f f0       	mov    0xf06f6580,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 80 65 6f f0    	mov    %edx,0xf06f6580
f0100de7:	8a 80 80 63 6f f0    	mov    -0xf909c80(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 80 65 6f f0       	mov    0xf06f6580,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 80 65 6f f0 00 	movl   $0x0,0xf06f6580
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 64 63 6f f0       	mov    0xf06f6364,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 e7 2b 12 f0       	push   $0xf0122be7
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ed 3f 00 00       	call   f0104ea8 <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 64 ae 00 00       	call   f010bd25 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 04 2c 12 f0       	push   $0xf0122c04
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 2b 2c 12 f0       	push   $0xf0122c2b
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 a6 3f 00 00       	call   f0104ea8 <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 1d ae 00 00       	call   f010bd25 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 40 2c 12 f0       	push   $0xf0122c40
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 2b 2c 12 f0       	push   $0xf0122c2b
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 1d e9 01 00       	call   f011f8a0 <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 64 65 00 00       	call   f01074fa <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 96 65 00 00       	call   f010754c <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 a0 89 f3 f0       	add    $0xf0f389a0,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 6a ef 01 00       	call   f011ff62 <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 c0 d9 f3 f0       	push   $0xf0f3d9c0
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 6d f1 01 00       	call   f0120180 <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 a0 89 f3 f0       	add    $0xf0f389a0,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 a0 89 f3 f0       	add    $0xf0f389a0,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 a8 ee 01 00       	call   f011ff62 <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 c0 d9 f3 f0       	push   $0xf0f3d9c0
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 ab f0 01 00       	call   f0120180 <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 a0 f9 f1 f0       	add    $0xf0f1f9a0,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 e8 ef 01 00       	call   f0120150 <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 6c 2c 12 f0       	push   $0xf0122c6c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 6f 2c 12 f0       	push   $0xf0122c6f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 a0 f9 f1 f0       	push   $0xf0f1f9a0
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 8d ec 01 00       	call   f011ff62 <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 a2 ec 01 00       	call   f011ffb1 <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 45 ec 01 00       	call   f011ff62 <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 7f 2c 12 f0       	push   $0xf0122c7f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 20 f2 01 00       	call   f0120577 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 84 2c 12 f0       	push   $0xf0122c84
f010137e:	50                   	push   %eax
f010137f:	e8 ea ec 01 00       	call   f012006e <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 88 2c 12 f0       	push   $0xf0122c88
f0101399:	50                   	push   %eax
f010139a:	e8 cf ec 01 00       	call   f012006e <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 8d 2c 12 f0       	push   $0xf0122c8d
f01013b4:	50                   	push   %eax
f01013b5:	e8 b4 ec 01 00       	call   f012006e <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 8d 2c 12 f0       	push   $0xf0122c8d
f01013d5:	50                   	push   %eax
f01013d6:	e8 93 ec 01 00       	call   f012006e <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 3b eb 01 00       	call   f011ff62 <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 3d eb 01 00       	call   f011ffb1 <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 1c eb 01 00       	call   f011ffb1 <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 99 ea 01 00       	call   f011ff62 <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 b4 eb 01 00       	call   f01200a6 <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 e9 e9 01 00       	call   f011ff62 <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 a0 f9 f1 f0       	add    $0xf0f1f9a0,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 b4 eb 01 00       	call   f0120150 <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 a0 f9 f1 f0    	add    $0xf0f1f9a0,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 1f ea 01 00       	call   f011ffdf <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 5f e9 01 00       	call   f011ff62 <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d 48 0d 18 f0    	mov    0xf0180d48,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 77 ea 01 00       	call   f01200a6 <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 c2 e8 01 00       	call   f011ff62 <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d 48 0d 18 f0    	mov    0xf0180d48,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d 48 0d 18 f0    	mov    0xf0180d48,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 62 e8 01 00       	call   f011ff62 <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 a0 f9 f1 f0       	add    $0xf0f1f9a0,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 2d ea 01 00       	call   f0120150 <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 a0 f9 f1 f0    	add    $0xf0f1f9a0,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 98 e8 01 00       	call   f011ffdf <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 da e7 01 00       	call   f011ff62 <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 f5 e8 01 00       	call   f01200a6 <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 40 e7 01 00       	call   f011ff62 <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 e6 e6 01 00       	call   f011ff62 <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 a0 f9 f1 f0       	add    $0xf0f1f9a0,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 b1 e8 01 00       	call   f0120150 <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 a0 f9 f1 f0    	add    $0xf0f1f9a0,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 1c e7 01 00       	call   f011ffdf <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 14 0e 18 f0       	mov    0xf0180e14,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 a0 f9 f1 f0       	add    $0xf0f1f9a0,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 a0 f9 f1 f0       	push   $0xf0f1f9a0
f0101929:	e8 34 e6 01 00       	call   f011ff62 <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 db e5 01 00       	call   f011ff62 <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 c8 e5 01 00       	call   f011ff62 <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 a0 f9 f1 f0    	lea    -0xf0e0660(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 a0 f9 f1 f0       	add    $0xf0f1f9a0,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 6d e5 01 00       	call   f011ff62 <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 a0 89 f3 f0    	lea    -0xf0c7660(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 a0 89 f3 f0       	add    $0xf0f389a0,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 62 e5 01 00       	call   f0120180 <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 a0 d5 f3 f0       	push   $0xf0f3d5a0
f0101c3a:	e8 41 e5 01 00       	call   f0120180 <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 a0 89 f3 f0       	add    $0xf0f389a0,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 11 e4 01 00       	call   f012006e <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 05 18 f0       	mov    %eax,0xf0180530
f0101c6f:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 a0 89 f3 f0       	add    $0xf0f389a0,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 f3 e4 01 00       	call   f0120180 <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 dc f8 f1 f0       	mov    0xf0f1f8dc,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 97 2c 12 f0       	mov    $0xf0122c97,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 97 30 12 f0       	mov    $0xf0123097,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 97 34 12 f0       	mov    $0xf0123497,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 dc f8 f1 f0 00 	movl   $0x0,0xf0f1f8dc
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 58 f8 f1 f0 00 	movl   $0x0,0xf0f1f858
f0101d59:	00 00 00 
f0101d5c:	c7 05 5c f8 f1 f0 00 	movl   $0x0,0xf0f1f85c
f0101d63:	00 00 00 
f0101d66:	c7 05 64 f8 f1 f0 00 	movl   $0x0,0xf0f1f864
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 ca e3 01 00       	call   f0120150 <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 91 2c 12 f0       	push   $0xf0122c91
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 d3 a1 00 00       	call   f010bfb2 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 53 56 00 00       	call   f0107437 <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 80 f9 f1 f0       	mov    %eax,0xf0f1f980
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 a0 d9 f3 f0       	mov    %eax,0xf0f3d9a0
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 80 f9 f1 f0       	mov    0xf0f1f980,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 80 f9 f1 f0    	mov    %edx,0xf0f1f980
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 a0 d9 f3 f0       	mov    0xf0f3d9a0,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 a0 d9 f3 f0       	mov    %eax,0xf0f3d9a0
f0101e98:	a1 a0 d9 f3 f0       	mov    0xf0f3d9a0,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 80 f9 f1 f0       	mov    %eax,0xf0f1f980
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 a0 d9 f3 f0       	mov    %eax,0xf0f3d9a0
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 80 f9 f1 f0       	mov    0xf0f1f980,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 80 f9 f1 f0    	mov    %edx,0xf0f1f980
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 a0 d9 f3 f0       	mov    0xf0f3d9a0,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 a0 d9 f3 f0       	mov    %eax,0xf0f3d9a0
f0101ed4:	a1 a0 d9 f3 f0       	mov    0xf0f3d9a0,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 7f 2c 12 f0       	push   $0xf0122c7f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 61 e6 01 00       	call   f0120577 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 97 38 12 f0       	push   $0xf0123897
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 64 f8 f1 f0       	mov    0xf0f1f864,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 b0 38 12 f0       	push   $0xf01238b0
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 01 39 12 f0       	push   $0xf0123901
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 58 f8 f1 f0       	mov    0xf0f1f858,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 1c 39 12 f0       	push   $0xf012391c
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 64 f8 f1 f0       	mov    0xf0f1f864,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 4c 39 12 f0       	push   $0xf012394c
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 01 39 12 f0       	push   $0xf0123901
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 58 f8 f1 f0       	mov    0xf0f1f858,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 76 39 12 f0       	push   $0xf0123976
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 60 f8 f1 f0       	mov    0xf0f1f860,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 60 f8 f1 f0       	mov    %eax,0xf0f1f860
f010203b:	a1 60 f8 f1 f0       	mov    0xf0f1f860,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 80 39 12 f0       	push   $0xf0123980
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 58 f8 f1 f0       	mov    0xf0f1f858,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 e3 39 12 f0       	push   $0xf01239e3
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 ec 39 12 f0       	push   $0xf01239ec
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 60 f8 f1 f0       	mov    0xf0f1f860,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 60 f8 f1 f0       	mov    %eax,0xf0f1f860
f010218b:	a1 60 f8 f1 f0       	mov    0xf0f1f860,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 05 18 f0       	add    $0xf0180548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 58 f8 f1 f0       	mov    0xf0f1f858,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 f4 39 12 f0       	push   $0xf01239f4
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 01 39 12 f0       	push   $0xf0123901
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 5c f8 f1 f0       	mov    %eax,0xf0f1f85c
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 58 f8 f1 f0       	mov    %eax,0xf0f1f858
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 64 f8 f1 f0       	mov    0xf0f1f864,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 64 f8 f1 f0       	mov    %eax,0xf0f1f864

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 60 f8 f1 f0       	mov    0xf0f1f860,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 60 f8 f1 f0       	mov    %eax,0xf0f1f860
f0102292:	a1 60 f8 f1 f0       	mov    0xf0f1f860,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 90 dd 01 00       	call   f012006e <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c 05 18 f0       	add    $0xf018054c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c 05 18 f0       	add    $0xf018054c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 58 f8 f1 f0    	mov    0xf0f1f858,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 05 18 f0       	add    $0xf0180550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 58 f8 f1 f0    	mov    0xf0f1f858,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010238d:	a3 5c f8 f1 f0       	mov    %eax,0xf0f1f85c
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01023a3:	a3 58 f8 f1 f0       	mov    %eax,0xf0f1f858
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 05 18 f0       	add    $0xf0180554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 64 f8 f1 f0       	mov    0xf0f1f864,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 64 f8 f1 f0       	mov    %eax,0xf0f1f864
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 58 f8 f1 f0    	mov    0xf0f1f858,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 58 f8 f1 f0    	mov    0xf0f1f858,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010248c:	a3 5c f8 f1 f0       	mov    %eax,0xf0f1f85c
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01024a2:	a3 58 f8 f1 f0       	mov    %eax,0xf0f1f858
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 05 18 f0       	add    $0xf0180554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 64 f8 f1 f0       	mov    0xf0f1f864,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 64 f8 f1 f0       	mov    %eax,0xf0f1f864
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 18 f6 b1 f0 00 	movl   $0x0,0xf0b1f618
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 18 f6 b1 f0 01 	movl   $0x1,0xf0b1f618
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 18 f6 b1 f0 02 	movl   $0x2,0xf0b1f618
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 18 f6 b1 f0 03 	movl   $0x3,0xf0b1f618
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 18 f6 b1 f0 04 	movl   $0x4,0xf0b1f618
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 64 f5 b1 f0 01 	movl   $0x1,0xf0b1f564
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 64 f5 b1 f0 02 	movl   $0x2,0xf0b1f564
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 64 f5 b1 f0 03 	movl   $0x3,0xf0b1f564
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 64 f5 b1 f0 04 	movl   $0x4,0xf0b1f564
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 14 3a 12 f0       	push   $0xf0123a14
f0102662:	6a 56                	push   $0x56
f0102664:	68 3c 3a 12 f0       	push   $0xf0123a3c
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 05 18 f0       	add    $0xf0180544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 73 43 12 f0       	push   $0xf0124373
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 7c 43 12 f0       	push   $0xf012437c
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d 48 0d 18 f0    	mov    0xf0180d48,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d 48 0d 18 f0    	mov    0xf0180d48,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 91 43 12 f0       	push   $0xf0124391
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 ad 43 12 f0       	push   $0xf01243ad
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 c8 43 12 f0       	push   $0xf01243c8
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 2d 28 12 00       	mov    $0x12282d,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 2d 28 12 f0       	push   $0xf012282d
f010278e:	68 04 44 12 f0       	push   $0xf0124404
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 3c 63 6f 00       	mov    $0x6f633c,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 3c 63 6f f0       	push   $0xf06f633c
f01027a9:	68 40 44 12 f0       	push   $0xf0124440
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 d0 22 6b 02       	mov    $0x26b22d0,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 d0 22 6b f2       	push   $0xf26b22d0
f01027c4:	68 88 44 12 f0       	push   $0xf0124488
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 d0 22 6b f2       	mov    $0xf26b22d0,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 c4 44 12 f0       	push   $0xf01244c4
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 98 da 01 00       	call   f01202c2 <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 57 da 01 00       	call   f01202c2 <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 ec 94 00 00       	call   f010bd75 <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 21 da 01 00       	call   f01202c2 <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 f0 44 12 f0       	push   $0xf01244f0
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 9b d9 01 00       	call   f01202c2 <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 18 d6 01 00       	call   f011ff62 <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 1d d9 01 00       	call   f01202c2 <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 1a 45 12 f0       	push   $0xf012451a
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 d1 d8 01 00       	call   f01202c2 <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 66 93 00 00       	call   f010bd75 <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 9b d8 01 00       	call   f01202c2 <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 1a 45 12 f0       	push   $0xf012451a
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 34 45 12 f0       	push   $0xf0124534
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 0a d8 01 00       	call   f01202c2 <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 5e 45 12 f0       	push   $0xf012455e
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 61 45 12 f0       	push   $0xf0124561
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 ad d7 01 00       	call   f01202c2 <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 42 92 00 00       	call   f010bd75 <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 77 d7 01 00       	call   f01202c2 <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 5c d7 01 00       	call   f01202c2 <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 63 45 12 f0       	push   $0xf0124563
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 c0 d6 01 00       	call   f01202c2 <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 55 91 00 00       	call   f010bd75 <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 79 d6 01 00       	call   f01202c2 <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 8d 6f 00 00       	call   f0109c12 <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 fe 6d 00 00       	call   f0109a8f <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 76 59 00 00       	call   f0108631 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 74 45 12 f0       	push   $0xf0124574
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 84 d5 01 00       	call   f01202c2 <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 19 90 00 00       	call   f010bd75 <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 3d d5 01 00       	call   f01202c2 <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 46 57 00 00       	call   f01084dd <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 9e 45 12 f0       	push   $0xf012459e
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 d2 5b 00 00       	call   f01089aa <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 b8 45 12 f0       	push   $0xf01245b8
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 43 5b 00 00       	call   f01089aa <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 07 5e 00 00       	call   f0108c8c <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 fc 45 12 f0       	push   $0xf01245fc
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 30 f7 b1 f0       	mov    0xf0b1f730,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 54 46 12 f0       	push   $0xf0124654
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)
	int PRIRRSchedPriority = 0;				//arg#5 default
f0102ef6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102efd:	8b 45 08             	mov    0x8(%ebp),%eax
f0102f00:	83 f8 04             	cmp    $0x4,%eax
f0102f03:	0f 84 c3 00 00 00    	je     f0102fcc <CreateEnv+0xf8>
f0102f09:	83 f8 05             	cmp    $0x5,%eax
f0102f0c:	74 0e                	je     f0102f1c <CreateEnv+0x48>
f0102f0e:	83 f8 03             	cmp    $0x3,%eax
f0102f11:	0f 84 4a 01 00 00    	je     f0103061 <CreateEnv+0x18d>
f0102f17:	e9 8d 01 00 00       	jmp    f01030a9 <CreateEnv+0x1d5>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f1c:	83 ec 0c             	sub    $0xc,%esp
f0102f1f:	6a 02                	push   $0x2
f0102f21:	e8 3b ca 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f0102f26:	83 c4 10             	add    $0x10,%esp
f0102f29:	85 c0                	test   %eax,%eax
f0102f2b:	75 1a                	jne    f0102f47 <CreateEnv+0x73>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f2d:	83 ec 0c             	sub    $0xc,%esp
f0102f30:	68 90 46 12 f0       	push   $0xf0124690
f0102f35:	e8 51 e0 ff ff       	call   f0100f8b <cprintf>
f0102f3a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f3d:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f42:	e9 7b 02 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			if (isSchedMethodBSD())
f0102f47:	e8 6f 3a 00 00       	call   f01069bb <isSchedMethodBSD>
f0102f4c:	85 c0                	test   %eax,%eax
f0102f4e:	74 1d                	je     f0102f6d <CreateEnv+0x99>
				BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f50:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f53:	83 c0 10             	add    $0x10,%eax
f0102f56:	8b 00                	mov    (%eax),%eax
f0102f58:	83 ec 04             	sub    $0x4,%esp
f0102f5b:	6a 0a                	push   $0xa
f0102f5d:	6a 00                	push   $0x0
f0102f5f:	50                   	push   %eax
f0102f60:	e8 5d d3 01 00       	call   f01202c2 <strtol>
f0102f65:	83 c4 10             	add    $0x10,%esp
f0102f68:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102f6b:	eb 24                	jmp    f0102f91 <CreateEnv+0xbd>
			else if (isSchedMethodPRIRR())
f0102f6d:	e8 5c 3a 00 00       	call   f01069ce <isSchedMethodPRIRR>
f0102f72:	85 c0                	test   %eax,%eax
f0102f74:	74 1b                	je     f0102f91 <CreateEnv+0xbd>
				PRIRRSchedPriority = strtol(arguments[4], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 10             	add    $0x10,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 37 d3 01 00       	call   f01202c2 <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 e8             	mov    %eax,-0x18(%ebp)

			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f94:	83 c0 0c             	add    $0xc,%eax
f0102f97:	8b 00                	mov    (%eax),%eax
f0102f99:	83 ec 04             	sub    $0x4,%esp
f0102f9c:	6a 0a                	push   $0xa
f0102f9e:	6a 00                	push   $0x0
f0102fa0:	50                   	push   %eax
f0102fa1:	e8 1c d3 01 00       	call   f01202c2 <strtol>
f0102fa6:	83 c4 10             	add    $0x10,%esp
f0102fa9:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fac:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faf:	83 c0 08             	add    $0x8,%eax
f0102fb2:	8b 00                	mov    (%eax),%eax
f0102fb4:	83 ec 04             	sub    $0x4,%esp
f0102fb7:	6a 0a                	push   $0xa
f0102fb9:	6a 00                	push   $0x0
f0102fbb:	50                   	push   %eax
f0102fbc:	e8 01 d3 01 00       	call   f01202c2 <strtol>
f0102fc1:	83 c4 10             	add    $0x10,%esp
f0102fc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102fc7:	e9 f7 00 00 00       	jmp    f01030c3 <CreateEnv+0x1ef>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102fcc:	83 ec 0c             	sub    $0xc,%esp
f0102fcf:	6a 02                	push   $0x2
f0102fd1:	e8 8b c9 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f0102fd6:	83 c4 10             	add    $0x10,%esp
f0102fd9:	85 c0                	test   %eax,%eax
f0102fdb:	75 4c                	jne    f0103029 <CreateEnv+0x155>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				if (isSchedMethodBSD())
f0102fdd:	e8 d9 39 00 00       	call   f01069bb <isSchedMethodBSD>
f0102fe2:	85 c0                	test   %eax,%eax
f0102fe4:	74 1d                	je     f0103003 <CreateEnv+0x12f>
					BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fe6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe9:	83 c0 0c             	add    $0xc,%eax
f0102fec:	8b 00                	mov    (%eax),%eax
f0102fee:	83 ec 04             	sub    $0x4,%esp
f0102ff1:	6a 0a                	push   $0xa
f0102ff3:	6a 00                	push   $0x0
f0102ff5:	50                   	push   %eax
f0102ff6:	e8 c7 d2 01 00       	call   f01202c2 <strtol>
f0102ffb:	83 c4 10             	add    $0x10,%esp
f0102ffe:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103001:	eb 41                	jmp    f0103044 <CreateEnv+0x170>
				else if (isSchedMethodPRIRR())
f0103003:	e8 c6 39 00 00       	call   f01069ce <isSchedMethodPRIRR>
f0103008:	85 c0                	test   %eax,%eax
f010300a:	74 38                	je     f0103044 <CreateEnv+0x170>
					PRIRRSchedPriority = strtol(arguments[3], NULL, 10);			}
f010300c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010300f:	83 c0 0c             	add    $0xc,%eax
f0103012:	8b 00                	mov    (%eax),%eax
f0103014:	83 ec 04             	sub    $0x4,%esp
f0103017:	6a 0a                	push   $0xa
f0103019:	6a 00                	push   $0x0
f010301b:	50                   	push   %eax
f010301c:	e8 a1 d2 01 00       	call   f01202c2 <strtol>
f0103021:	83 c4 10             	add    $0x10,%esp
f0103024:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0103027:	eb 1b                	jmp    f0103044 <CreateEnv+0x170>
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103029:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302c:	83 c0 0c             	add    $0xc,%eax
f010302f:	8b 00                	mov    (%eax),%eax
f0103031:	83 ec 04             	sub    $0x4,%esp
f0103034:	6a 0a                	push   $0xa
f0103036:	6a 00                	push   $0x0
f0103038:	50                   	push   %eax
f0103039:	e8 84 d2 01 00       	call   f01202c2 <strtol>
f010303e:	83 c4 10             	add    $0x10,%esp
f0103041:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103044:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103047:	83 c0 08             	add    $0x8,%eax
f010304a:	8b 00                	mov    (%eax),%eax
f010304c:	83 ec 04             	sub    $0x4,%esp
f010304f:	6a 0a                	push   $0xa
f0103051:	6a 00                	push   $0x0
f0103053:	50                   	push   %eax
f0103054:	e8 69 d2 01 00       	call   f01202c2 <strtol>
f0103059:	83 c4 10             	add    $0x10,%esp
f010305c:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f010305f:	eb 62                	jmp    f01030c3 <CreateEnv+0x1ef>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103061:	83 ec 0c             	sub    $0xc,%esp
f0103064:	6a 02                	push   $0x2
f0103066:	e8 f6 c8 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010306b:	83 c4 10             	add    $0x10,%esp
f010306e:	85 c0                	test   %eax,%eax
f0103070:	74 1a                	je     f010308c <CreateEnv+0x1b8>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f0103072:	83 ec 0c             	sub    $0xc,%esp
f0103075:	68 3c 47 12 f0       	push   $0xf012473c
f010307a:	e8 0c df ff ff       	call   f0100f8b <cprintf>
f010307f:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103082:	b8 00 00 00 00       	mov    $0x0,%eax
f0103087:	e9 36 01 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f010308c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010308f:	83 c0 08             	add    $0x8,%eax
f0103092:	8b 00                	mov    (%eax),%eax
f0103094:	83 ec 04             	sub    $0x4,%esp
f0103097:	6a 0a                	push   $0xa
f0103099:	6a 00                	push   $0x0
f010309b:	50                   	push   %eax
f010309c:	e8 21 d2 01 00       	call   f01202c2 <strtol>
f01030a1:	83 c4 10             	add    $0x10,%esp
f01030a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f01030a7:	eb 1a                	jmp    f01030c3 <CreateEnv+0x1ef>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f01030a9:	83 ec 0c             	sub    $0xc,%esp
f01030ac:	68 cc 47 12 f0       	push   $0xf01247cc
f01030b1:	e8 d5 de ff ff       	call   f0100f8b <cprintf>
f01030b6:	83 c4 10             	add    $0x10,%esp
			return NULL;
f01030b9:	b8 00 00 00 00       	mov    $0x0,%eax
f01030be:	e9 ff 00 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01030c3:	83 ec 0c             	sub    $0xc,%esp
f01030c6:	6a 02                	push   $0x2
f01030c8:	e8 94 c8 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f01030cd:	83 c4 10             	add    $0x10,%esp
f01030d0:	85 c0                	test   %eax,%eax
f01030d2:	74 23                	je     f01030f7 <CreateEnv+0x223>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f01030d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030d7:	48                   	dec    %eax
f01030d8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01030db:	73 1a                	jae    f01030f7 <CreateEnv+0x223>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f01030dd:	83 ec 0c             	sub    $0xc,%esp
f01030e0:	68 64 48 12 f0       	push   $0xf0124864
f01030e5:	e8 a1 de ff ff       	call   f0100f8b <cprintf>
f01030ea:	83 c4 10             	add    $0x10,%esp
				return NULL;
f01030ed:	b8 00 00 00 00       	mov    $0x0,%eax
f01030f2:	e9 cb 00 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030f7:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01030fb:	76 19                	jbe    f0103116 <CreateEnv+0x242>
f01030fd:	68 bc 48 12 f0       	push   $0xf01248bc
f0103102:	68 01 49 12 f0       	push   $0xf0124901
f0103107:	68 af 01 00 00       	push   $0x1af
f010310c:	68 16 49 12 f0       	push   $0xf0124916
f0103111:	e8 23 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103116:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f010311a:	76 19                	jbe    f0103135 <CreateEnv+0x261>
f010311c:	68 bc 48 12 f0       	push   $0xf01248bc
f0103121:	68 01 49 12 f0       	push   $0xf0124901
f0103126:	68 cd 01 00 00       	push   $0x1cd
f010312b:	68 16 49 12 f0       	push   $0xf0124916
f0103130:	e8 04 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0103135:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103138:	83 c0 04             	add    $0x4,%eax
f010313b:	8b 00                	mov    (%eax),%eax
f010313d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103140:	ff 75 f0             	pushl  -0x10(%ebp)
f0103143:	ff 75 f4             	pushl  -0xc(%ebp)
f0103146:	50                   	push   %eax
f0103147:	e8 5b 81 00 00       	call   f010b2a7 <env_create>
f010314c:	83 c4 10             	add    $0x10,%esp
f010314f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (BSDSchedNiceVal != -100)
f0103152:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f0103156:	74 49                	je     f01031a1 <CreateEnv+0x2cd>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0103158:	83 ec 08             	sub    $0x8,%esp
f010315b:	ff 75 ec             	pushl  -0x14(%ebp)
f010315e:	68 2a 49 12 f0       	push   $0xf012492a
f0103163:	e8 23 de ff ff       	call   f0100f8b <cprintf>
f0103168:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f010316b:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010316f:	7c 06                	jl     f0103177 <CreateEnv+0x2a3>
f0103171:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103175:	7e 19                	jle    f0103190 <CreateEnv+0x2bc>
f0103177:	68 3c 49 12 f0       	push   $0xf012493c
f010317c:	68 01 49 12 f0       	push   $0xf0124901
f0103181:	68 d2 01 00 00       	push   $0x1d2
f0103186:	68 16 49 12 f0       	push   $0xf0124916
f010318b:	e8 a9 d1 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0103190:	83 ec 08             	sub    $0x8,%esp
f0103193:	ff 75 ec             	pushl  -0x14(%ebp)
f0103196:	ff 75 e0             	pushl  -0x20(%ebp)
f0103199:	e8 53 37 00 00       	call   f01068f1 <env_set_nice>
f010319e:	83 c4 10             	add    $0x10,%esp
	}
	if (isSchedMethodPRIRR())
f01031a1:	e8 28 38 00 00       	call   f01069ce <isSchedMethodPRIRR>
f01031a6:	85 c0                	test   %eax,%eax
f01031a8:	74 15                	je     f01031bf <CreateEnv+0x2eb>
		env_set_priority(env->env_id, PRIRRSchedPriority);
f01031aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01031ad:	8b 40 10             	mov    0x10(%eax),%eax
f01031b0:	83 ec 08             	sub    $0x8,%esp
f01031b3:	ff 75 e8             	pushl  -0x18(%ebp)
f01031b6:	50                   	push   %eax
f01031b7:	e8 8c 37 00 00       	call   f0106948 <env_set_priority>
f01031bc:	83 c4 10             	add    $0x10,%esp

	return env;
f01031bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f01031c2:	c9                   	leave  
f01031c3:	c3                   	ret    

f01031c4 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f01031c4:	55                   	push   %ebp
f01031c5:	89 e5                	mov    %esp,%ebp
f01031c7:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ca:	83 ec 08             	sub    $0x8,%esp
f01031cd:	ff 75 0c             	pushl  0xc(%ebp)
f01031d0:	ff 75 08             	pushl  0x8(%ebp)
f01031d3:	e8 fc fc ff ff       	call   f0102ed4 <CreateEnv>
f01031d8:	83 c4 10             	add    $0x10,%esp
f01031db:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f01031de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01031e2:	75 07                	jne    f01031eb <command_run_program+0x27>
f01031e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01031e9:	eb 46                	jmp    f0103231 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f01031eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031ee:	8b 40 10             	mov    0x10(%eax),%eax
f01031f1:	83 ec 08             	sub    $0x8,%esp
f01031f4:	50                   	push   %eax
f01031f5:	68 6c 49 12 f0       	push   $0xf012496c
f01031fa:	e8 8c dd ff ff       	call   f0100f8b <cprintf>
f01031ff:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0103202:	83 ec 0c             	sub    $0xc,%esp
f0103205:	ff 75 f4             	pushl  -0xc(%ebp)
f0103208:	e8 7a 27 00 00       	call   f0105987 <sched_new_env>
f010320d:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0103210:	c7 05 30 f7 b1 f0 00 	movl   $0x0,0xf0b1f730
f0103217:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f010321a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321d:	8b 40 10             	mov    0x10(%eax),%eax
f0103220:	83 ec 0c             	sub    $0xc,%esp
f0103223:	50                   	push   %eax
f0103224:	e8 b4 27 00 00       	call   f01059dd <sched_run_env>
f0103229:	83 c4 10             	add    $0x10,%esp

	return 0;
f010322c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103231:	c9                   	leave  
f0103232:	c3                   	ret    

f0103233 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0103233:	55                   	push   %ebp
f0103234:	89 e5                	mov    %esp,%ebp
f0103236:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103239:	8b 45 0c             	mov    0xc(%ebp),%eax
f010323c:	83 c0 04             	add    $0x4,%eax
f010323f:	8b 00                	mov    (%eax),%eax
f0103241:	83 ec 04             	sub    $0x4,%esp
f0103244:	6a 0a                	push   $0xa
f0103246:	6a 00                	push   $0x0
f0103248:	50                   	push   %eax
f0103249:	e8 74 d0 01 00       	call   f01202c2 <strtol>
f010324e:	83 c4 10             	add    $0x10,%esp
f0103251:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103257:	83 ec 0c             	sub    $0xc,%esp
f010325a:	50                   	push   %eax
f010325b:	e8 c3 2a 00 00       	call   f0105d23 <sched_kill_env>
f0103260:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103263:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103268:	c9                   	leave  
f0103269:	c3                   	ret    

f010326a <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f010326a:	55                   	push   %ebp
f010326b:	89 e5                	mov    %esp,%ebp
f010326d:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103270:	83 ec 08             	sub    $0x8,%esp
f0103273:	ff 75 0c             	pushl  0xc(%ebp)
f0103276:	ff 75 08             	pushl  0x8(%ebp)
f0103279:	e8 56 fc ff ff       	call   f0102ed4 <CreateEnv>
f010327e:	83 c4 10             	add    $0x10,%esp
f0103281:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103284:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103288:	75 07                	jne    f0103291 <commnad_load_env+0x27>
		return 0 ;
f010328a:	b8 00 00 00 00       	mov    $0x0,%eax
f010328f:	eb 2a                	jmp    f01032bb <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103291:	83 ec 0c             	sub    $0xc,%esp
f0103294:	ff 75 f4             	pushl  -0xc(%ebp)
f0103297:	e8 eb 26 00 00       	call   f0105987 <sched_new_env>
f010329c:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010329f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01032a2:	8b 40 10             	mov    0x10(%eax),%eax
f01032a5:	83 ec 08             	sub    $0x8,%esp
f01032a8:	50                   	push   %eax
f01032a9:	68 6c 49 12 f0       	push   $0xf012496c
f01032ae:	e8 d8 dc ff ff       	call   f0100f8b <cprintf>
f01032b3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01032b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032bb:	c9                   	leave  
f01032bc:	c3                   	ret    

f01032bd <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f01032bd:	55                   	push   %ebp
f01032be:	89 e5                	mov    %esp,%ebp
f01032c0:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f01032c3:	c7 05 30 f7 b1 f0 00 	movl   $0x0,0xf0b1f730
f01032ca:	00 00 00 
	sched_run_all();
f01032cd:	e8 0e 30 00 00       	call   f01062e0 <sched_run_all>

	return 0 ;
f01032d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032d7:	c9                   	leave  
f01032d8:	c3                   	ret    

f01032d9 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f01032d9:	55                   	push   %ebp
f01032da:	89 e5                	mov    %esp,%ebp
f01032dc:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f01032df:	e8 db 2d 00 00       	call   f01060bf <sched_print_all>

	return 0 ;
f01032e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032e9:	c9                   	leave  
f01032ea:	c3                   	ret    

f01032eb <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f01032eb:	55                   	push   %ebp
f01032ec:	89 e5                	mov    %esp,%ebp
f01032ee:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f01032f1:	e8 7f 30 00 00       	call   f0106375 <sched_kill_all>

	return 0 ;
f01032f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032fb:	c9                   	leave  
f01032fc:	c3                   	ret    

f01032fd <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f01032fd:	55                   	push   %ebp
f01032fe:	89 e5                	mov    %esp,%ebp
f0103300:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103303:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103307:	7f 1a                	jg     f0103323 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103309:	83 ec 0c             	sub    $0xc,%esp
f010330c:	68 84 49 12 f0       	push   $0xf0124984
f0103311:	e8 75 dc ff ff       	call   f0100f8b <cprintf>
f0103316:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103319:	b8 00 00 00 00       	mov    $0x0,%eax
f010331e:	e9 83 00 00 00       	jmp    f01033a6 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0103323:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103326:	83 c0 04             	add    $0x4,%eax
f0103329:	8b 00                	mov    (%eax),%eax
f010332b:	83 ec 04             	sub    $0x4,%esp
f010332e:	6a 0a                	push   $0xa
f0103330:	6a 00                	push   $0x0
f0103332:	50                   	push   %eax
f0103333:	e8 8a cf 01 00       	call   f01202c2 <strtol>
f0103338:	83 c4 10             	add    $0x10,%esp
f010333b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f010333e:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103342:	75 20                	jne    f0103364 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103344:	83 ec 0c             	sub    $0xc,%esp
f0103347:	ff 75 f4             	pushl  -0xc(%ebp)
f010334a:	e8 87 c5 00 00       	call   f010f8d6 <setPageReplacmentAlgorithmLRU>
f010334f:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0103352:	83 ec 0c             	sub    $0xc,%esp
f0103355:	68 e4 49 12 f0       	push   $0xf01249e4
f010335a:	e8 2c dc ff ff       	call   f0100f8b <cprintf>
f010335f:	83 c4 10             	add    $0x10,%esp
f0103362:	eb 3d                	jmp    f01033a1 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0103364:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0103368:	75 20                	jne    f010338a <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f010336a:	83 ec 0c             	sub    $0xc,%esp
f010336d:	ff 75 f4             	pushl  -0xc(%ebp)
f0103370:	e8 61 c5 00 00       	call   f010f8d6 <setPageReplacmentAlgorithmLRU>
f0103375:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0103378:	83 ec 0c             	sub    $0xc,%esp
f010337b:	68 28 4a 12 f0       	push   $0xf0124a28
f0103380:	e8 06 dc ff ff       	call   f0100f8b <cprintf>
f0103385:	83 c4 10             	add    $0x10,%esp
f0103388:	eb 17                	jmp    f01033a1 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f010338a:	83 ec 0c             	sub    $0xc,%esp
f010338d:	68 68 4a 12 f0       	push   $0xf0124a68
f0103392:	e8 f4 db ff ff       	call   f0100f8b <cprintf>
f0103397:	83 c4 10             	add    $0x10,%esp
		return 0;
f010339a:	b8 00 00 00 00       	mov    $0x0,%eax
f010339f:	eb 05                	jmp    f01033a6 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f01033a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033a6:	c9                   	leave  
f01033a7:	c3                   	ret    

f01033a8 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f01033a8:	55                   	push   %ebp
f01033a9:	89 e5                	mov    %esp,%ebp
f01033ab:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f01033ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033b1:	83 c0 04             	add    $0x4,%eax
f01033b4:	8b 00                	mov    (%eax),%eax
f01033b6:	83 ec 04             	sub    $0x4,%esp
f01033b9:	6a 0a                	push   $0xa
f01033bb:	6a 00                	push   $0x0
f01033bd:	50                   	push   %eax
f01033be:	e8 ff ce 01 00       	call   f01202c2 <strtol>
f01033c3:	83 c4 10             	add    $0x10,%esp
f01033c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint8 type = strtol(arguments[2], NULL, 10);
f01033c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033cc:	83 c0 08             	add    $0x8,%eax
f01033cf:	8b 00                	mov    (%eax),%eax
f01033d1:	83 ec 04             	sub    $0x4,%esp
f01033d4:	6a 0a                	push   $0xa
f01033d6:	6a 00                	push   $0x0
f01033d8:	50                   	push   %eax
f01033d9:	e8 e4 ce 01 00       	call   f01202c2 <strtol>
f01033de:	83 c4 10             	add    $0x10,%esp
f01033e1:	88 45 f3             	mov    %al,-0xd(%ebp)
	if (PageWSMaxSweeps <= 0)
f01033e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01033e8:	75 17                	jne    f0103401 <command_set_page_rep_nthCLOCK+0x59>
	{
		cprintf("Invalid number of sweeps! it should be +ve.\n");
f01033ea:	83 ec 0c             	sub    $0xc,%esp
f01033ed:	68 bc 4a 12 f0       	push   $0xf0124abc
f01033f2:	e8 94 db ff ff       	call   f0100f8b <cprintf>
f01033f7:	83 c4 10             	add    $0x10,%esp
		return 0;
f01033fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01033ff:	eb 4b                	jmp    f010344c <command_set_page_rep_nthCLOCK+0xa4>
	}
	if (type == 1)		PageWSMaxSweeps = PageWSMaxSweeps * 1;
f0103401:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
f0103405:	74 22                	je     f0103429 <command_set_page_rep_nthCLOCK+0x81>
	else if (type == 2)	PageWSMaxSweeps = PageWSMaxSweeps * -1;
f0103407:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
f010340b:	75 05                	jne    f0103412 <command_set_page_rep_nthCLOCK+0x6a>
f010340d:	f7 5d f4             	negl   -0xc(%ebp)
f0103410:	eb 17                	jmp    f0103429 <command_set_page_rep_nthCLOCK+0x81>
	else
	{
		cprintf("Invalid type!\n	type=1: NORMAL Ver. type=2: MODIFIED Ver.\n");
f0103412:	83 ec 0c             	sub    $0xc,%esp
f0103415:	68 ec 4a 12 f0       	push   $0xf0124aec
f010341a:	e8 6c db ff ff       	call   f0100f8b <cprintf>
f010341f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103422:	b8 00 00 00 00       	mov    $0x0,%eax
f0103427:	eb 23                	jmp    f010344c <command_set_page_rep_nthCLOCK+0xa4>
	}
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103429:	83 ec 0c             	sub    $0xc,%esp
f010342c:	ff 75 f4             	pushl  -0xc(%ebp)
f010342f:	e8 15 c5 00 00       	call   f010f949 <setPageReplacmentAlgorithmNchanceCLOCK>
f0103434:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103437:	83 ec 0c             	sub    $0xc,%esp
f010343a:	68 28 4b 12 f0       	push   $0xf0124b28
f010343f:	e8 47 db ff ff       	call   f0100f8b <cprintf>
f0103444:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103447:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010344c:	c9                   	leave  
f010344d:	c3                   	ret    

f010344e <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010344e:	55                   	push   %ebp
f010344f:	89 e5                	mov    %esp,%ebp
f0103451:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103454:	e8 b0 c4 00 00       	call   f010f909 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103459:	83 ec 0c             	sub    $0xc,%esp
f010345c:	68 5c 4b 12 f0       	push   $0xf0124b5c
f0103461:	e8 25 db ff ff       	call   f0100f8b <cprintf>
f0103466:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103469:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010346e:	c9                   	leave  
f010346f:	c3                   	ret    

f0103470 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f0103470:	55                   	push   %ebp
f0103471:	89 e5                	mov    %esp,%ebp
f0103473:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103476:	e8 9e c4 00 00       	call   f010f919 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f010347b:	83 ec 0c             	sub    $0xc,%esp
f010347e:	68 88 4b 12 f0       	push   $0xf0124b88
f0103483:	e8 03 db ff ff       	call   f0100f8b <cprintf>
f0103488:	83 c4 10             	add    $0x10,%esp
	return 0;
f010348b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103490:	c9                   	leave  
f0103491:	c3                   	ret    

f0103492 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f0103492:	55                   	push   %ebp
f0103493:	89 e5                	mov    %esp,%ebp
f0103495:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f0103498:	e8 8c c4 00 00       	call   f010f929 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f010349d:	83 ec 0c             	sub    $0xc,%esp
f01034a0:	68 b0 4b 12 f0       	push   $0xf0124bb0
f01034a5:	e8 e1 da ff ff       	call   f0100f8b <cprintf>
f01034aa:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034b2:	c9                   	leave  
f01034b3:	c3                   	ret    

f01034b4 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01034b4:	55                   	push   %ebp
f01034b5:	89 e5                	mov    %esp,%ebp
f01034b7:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01034ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034bd:	83 c0 04             	add    $0x4,%eax
f01034c0:	8b 00                	mov    (%eax),%eax
f01034c2:	83 ec 04             	sub    $0x4,%esp
f01034c5:	6a 0a                	push   $0xa
f01034c7:	6a 00                	push   $0x0
f01034c9:	50                   	push   %eax
f01034ca:	e8 f3 cd 01 00       	call   f01202c2 <strtol>
f01034cf:	83 c4 10             	add    $0x10,%esp
f01034d2:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01034d5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01034d9:	83 ec 0c             	sub    $0xc,%esp
f01034dc:	50                   	push   %eax
f01034dd:	e8 7f 37 00 00       	call   f0106c61 <sched_init_RR>
f01034e2:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f01034e5:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f01034ea:	8a 00                	mov    (%eax),%al
f01034ec:	0f b6 c0             	movzbl %al,%eax
f01034ef:	83 ec 08             	sub    $0x8,%esp
f01034f2:	50                   	push   %eax
f01034f3:	68 e4 4b 12 f0       	push   $0xf0124be4
f01034f8:	e8 8e da ff ff       	call   f0100f8b <cprintf>
f01034fd:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103500:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103505:	c9                   	leave  
f0103506:	c3                   	ret    

f0103507 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103507:	55                   	push   %ebp
f0103508:	89 e5                	mov    %esp,%ebp
f010350a:	53                   	push   %ebx
f010350b:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010350e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103511:	83 c0 04             	add    $0x4,%eax
f0103514:	8b 00                	mov    (%eax),%eax
f0103516:	83 ec 04             	sub    $0x4,%esp
f0103519:	6a 0a                	push   $0xa
f010351b:	6a 00                	push   $0x0
f010351d:	50                   	push   %eax
f010351e:	e8 9f cd 01 00       	call   f01202c2 <strtol>
f0103523:	83 c4 10             	add    $0x10,%esp
f0103526:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103529:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0103530:	eb 2e                	jmp    f0103560 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0103532:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103535:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103538:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010353b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103542:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103545:	01 d0                	add    %edx,%eax
f0103547:	8b 00                	mov    (%eax),%eax
f0103549:	83 ec 04             	sub    $0x4,%esp
f010354c:	6a 0a                	push   $0xa
f010354e:	6a 00                	push   $0x0
f0103550:	50                   	push   %eax
f0103551:	e8 6c cd 01 00       	call   f01202c2 <strtol>
f0103556:	83 c4 10             	add    $0x10,%esp
f0103559:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010355d:	ff 45 f4             	incl   -0xc(%ebp)
f0103560:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103563:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103566:	7c ca                	jl     f0103532 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103568:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f010356c:	83 ec 08             	sub    $0x8,%esp
f010356f:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f0103572:	52                   	push   %edx
f0103573:	50                   	push   %eax
f0103574:	e8 96 37 00 00       	call   f0106d0f <sched_init_MLFQ>
f0103579:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f010357c:	83 ec 0c             	sub    $0xc,%esp
f010357f:	68 1c 4c 12 f0       	push   $0xf0124c1c
f0103584:	e8 02 da ff ff       	call   f0100f8b <cprintf>
f0103589:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010358c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103593:	eb 24                	jmp    f01035b9 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f0103595:	8b 15 44 f4 b1 f0    	mov    0xf0b1f444,%edx
f010359b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010359e:	01 d0                	add    %edx,%eax
f01035a0:	8a 00                	mov    (%eax),%al
f01035a2:	0f b6 c0             	movzbl %al,%eax
f01035a5:	83 ec 08             	sub    $0x8,%esp
f01035a8:	50                   	push   %eax
f01035a9:	68 49 4c 12 f0       	push   $0xf0124c49
f01035ae:	e8 d8 d9 ff ff       	call   f0100f8b <cprintf>
f01035b3:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01035b6:	ff 45 f0             	incl   -0x10(%ebp)
f01035b9:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f01035be:	0f b6 c0             	movzbl %al,%eax
f01035c1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01035c4:	7f cf                	jg     f0103595 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01035c6:	83 ec 0c             	sub    $0xc,%esp
f01035c9:	68 61 45 12 f0       	push   $0xf0124561
f01035ce:	e8 b8 d9 ff ff       	call   f0100f8b <cprintf>
f01035d3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01035d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01035de:	c9                   	leave  
f01035df:	c3                   	ret    

f01035e0 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01035e0:	55                   	push   %ebp
f01035e1:	89 e5                	mov    %esp,%ebp
f01035e3:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01035e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01035e9:	83 c0 04             	add    $0x4,%eax
f01035ec:	8b 00                	mov    (%eax),%eax
f01035ee:	83 ec 04             	sub    $0x4,%esp
f01035f1:	6a 0a                	push   $0xa
f01035f3:	6a 00                	push   $0x0
f01035f5:	50                   	push   %eax
f01035f6:	e8 c7 cc 01 00       	call   f01202c2 <strtol>
f01035fb:	83 c4 10             	add    $0x10,%esp
f01035fe:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0103601:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103604:	83 c0 08             	add    $0x8,%eax
f0103607:	8b 00                	mov    (%eax),%eax
f0103609:	83 ec 04             	sub    $0x4,%esp
f010360c:	6a 0a                	push   $0xa
f010360e:	6a 00                	push   $0x0
f0103610:	50                   	push   %eax
f0103611:	e8 ac cc 01 00       	call   f01202c2 <strtol>
f0103616:	83 c4 10             	add    $0x10,%esp
f0103619:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f010361c:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103620:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103624:	83 ec 08             	sub    $0x8,%esp
f0103627:	52                   	push   %edx
f0103628:	50                   	push   %eax
f0103629:	e8 09 37 00 00       	call   f0106d37 <sched_init_BSD>
f010362e:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f0103631:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103635:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103639:	83 ec 04             	sub    $0x4,%esp
f010363c:	52                   	push   %edx
f010363d:	50                   	push   %eax
f010363e:	68 50 4c 12 f0       	push   $0xf0124c50
f0103643:	e8 43 d9 ff ff       	call   f0100f8b <cprintf>
f0103648:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010364b:	83 ec 0c             	sub    $0xc,%esp
f010364e:	68 61 45 12 f0       	push   $0xf0124561
f0103653:	e8 33 d9 ff ff       	call   f0100f8b <cprintf>
f0103658:	83 c4 10             	add    $0x10,%esp
	return 0;
f010365b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103660:	c9                   	leave  
f0103661:	c3                   	ret    

f0103662 <command_set_starve_thresh>:
int command_set_starve_thresh(int number_of_arguments, char **arguments)
{
f0103662:	55                   	push   %ebp
f0103663:	89 e5                	mov    %esp,%ebp
f0103665:	83 ec 18             	sub    $0x18,%esp
	uint32 starvationThresh = strtol(arguments[1], NULL, 10);
f0103668:	8b 45 0c             	mov    0xc(%ebp),%eax
f010366b:	83 c0 04             	add    $0x4,%eax
f010366e:	8b 00                	mov    (%eax),%eax
f0103670:	83 ec 04             	sub    $0x4,%esp
f0103673:	6a 0a                	push   $0xa
f0103675:	6a 00                	push   $0x0
f0103677:	50                   	push   %eax
f0103678:	e8 45 cc 01 00       	call   f01202c2 <strtol>
f010367d:	83 c4 10             	add    $0x10,%esp
f0103680:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sched_set_starv_thresh(starvationThresh);
f0103683:	83 ec 0c             	sub    $0xc,%esp
f0103686:	ff 75 f4             	pushl  -0xc(%ebp)
f0103689:	e8 eb 32 00 00       	call   f0106979 <sched_set_starv_thresh>
f010368e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103691:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103696:	c9                   	leave  
f0103697:	c3                   	ret    

f0103698 <command_set_priority>:
int command_set_priority(int number_of_arguments, char **arguments)
{
f0103698:	55                   	push   %ebp
f0103699:	89 e5                	mov    %esp,%ebp
f010369b:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010369e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036a1:	83 c0 04             	add    $0x4,%eax
f01036a4:	8b 00                	mov    (%eax),%eax
f01036a6:	83 ec 04             	sub    $0x4,%esp
f01036a9:	6a 0a                	push   $0xa
f01036ab:	6a 00                	push   $0x0
f01036ad:	50                   	push   %eax
f01036ae:	e8 0f cc 01 00       	call   f01202c2 <strtol>
f01036b3:	83 c4 10             	add    $0x10,%esp
f01036b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int32 priority = strtol(arguments[2],NULL, 10);
f01036b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036bc:	83 c0 08             	add    $0x8,%eax
f01036bf:	8b 00                	mov    (%eax),%eax
f01036c1:	83 ec 04             	sub    $0x4,%esp
f01036c4:	6a 0a                	push   $0xa
f01036c6:	6a 00                	push   $0x0
f01036c8:	50                   	push   %eax
f01036c9:	e8 f4 cb 01 00       	call   f01202c2 <strtol>
f01036ce:	83 c4 10             	add    $0x10,%esp
f01036d1:	89 45 f0             	mov    %eax,-0x10(%ebp)

	env_set_priority(envId, priority);
f01036d4:	83 ec 08             	sub    $0x8,%esp
f01036d7:	ff 75 f0             	pushl  -0x10(%ebp)
f01036da:	ff 75 f4             	pushl  -0xc(%ebp)
f01036dd:	e8 66 32 00 00       	call   f0106948 <env_set_priority>
f01036e2:	83 c4 10             	add    $0x10,%esp

	return 0;
f01036e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036ea:	c9                   	leave  
f01036eb:	c3                   	ret    

f01036ec <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01036ec:	55                   	push   %ebp
f01036ed:	89 e5                	mov    %esp,%ebp
f01036ef:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01036f2:	e8 b1 32 00 00       	call   f01069a8 <isSchedMethodMLFQ>
f01036f7:	85 c0                	test   %eax,%eax
f01036f9:	74 5f                	je     f010375a <command_print_sch_method+0x6e>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01036fb:	83 ec 0c             	sub    $0xc,%esp
f01036fe:	68 8c 4c 12 f0       	push   $0xf0124c8c
f0103703:	e8 83 d8 ff ff       	call   f0100f8b <cprintf>
f0103708:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010370b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103712:	eb 24                	jmp    f0103738 <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f0103714:	8b 15 44 f4 b1 f0    	mov    0xf0b1f444,%edx
f010371a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010371d:	01 d0                	add    %edx,%eax
f010371f:	8a 00                	mov    (%eax),%al
f0103721:	0f b6 c0             	movzbl %al,%eax
f0103724:	83 ec 08             	sub    $0x8,%esp
f0103727:	50                   	push   %eax
f0103728:	68 49 4c 12 f0       	push   $0xf0124c49
f010372d:	e8 59 d8 ff ff       	call   f0100f8b <cprintf>
f0103732:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0103735:	ff 45 f4             	incl   -0xc(%ebp)
f0103738:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f010373d:	0f b6 c0             	movzbl %al,%eax
f0103740:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103743:	7f cf                	jg     f0103714 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f0103745:	83 ec 0c             	sub    $0xc,%esp
f0103748:	68 61 45 12 f0       	push   $0xf0124561
f010374d:	e8 39 d8 ff ff       	call   f0100f8b <cprintf>
f0103752:	83 c4 10             	add    $0x10,%esp
f0103755:	e9 94 00 00 00       	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else if (isSchedMethodRR())
f010375a:	e8 37 32 00 00       	call   f0106996 <isSchedMethodRR>
f010375f:	85 c0                	test   %eax,%eax
f0103761:	74 1d                	je     f0103780 <command_print_sch_method+0x94>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f0103763:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0103768:	8a 00                	mov    (%eax),%al
f010376a:	0f b6 c0             	movzbl %al,%eax
f010376d:	83 ec 08             	sub    $0x8,%esp
f0103770:	50                   	push   %eax
f0103771:	68 c0 4c 12 f0       	push   $0xf0124cc0
f0103776:	e8 10 d8 ff ff       	call   f0100f8b <cprintf>
f010377b:	83 c4 10             	add    $0x10,%esp
f010377e:	eb 6e                	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else if (isSchedMethodBSD())
f0103780:	e8 36 32 00 00       	call   f01069bb <isSchedMethodBSD>
f0103785:	85 c0                	test   %eax,%eax
f0103787:	74 26                	je     f01037af <command_print_sch_method+0xc3>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103789:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f010378e:	8a 00                	mov    (%eax),%al
f0103790:	0f b6 d0             	movzbl %al,%edx
f0103793:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f0103798:	0f b6 c0             	movzbl %al,%eax
f010379b:	83 ec 04             	sub    $0x4,%esp
f010379e:	52                   	push   %edx
f010379f:	50                   	push   %eax
f01037a0:	68 50 4c 12 f0       	push   $0xf0124c50
f01037a5:	e8 e1 d7 ff ff       	call   f0100f8b <cprintf>
f01037aa:	83 c4 10             	add    $0x10,%esp
f01037ad:	eb 3f                	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else if (isSchedMethodPRIRR())
f01037af:	e8 1a 32 00 00       	call   f01069ce <isSchedMethodPRIRR>
f01037b4:	85 c0                	test   %eax,%eax
f01037b6:	74 26                	je     f01037de <command_print_sch_method+0xf2>
	{
		cprintf("Scheduler is now set to PRIORITY RR with %d priorities & quantum = %d\n", num_of_ready_queues, quantums[0]);
f01037b8:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f01037bd:	8a 00                	mov    (%eax),%al
f01037bf:	0f b6 d0             	movzbl %al,%edx
f01037c2:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f01037c7:	0f b6 c0             	movzbl %al,%eax
f01037ca:	83 ec 04             	sub    $0x4,%esp
f01037cd:	52                   	push   %edx
f01037ce:	50                   	push   %eax
f01037cf:	68 fc 4c 12 f0       	push   $0xf0124cfc
f01037d4:	e8 b2 d7 ff ff       	call   f0100f8b <cprintf>
f01037d9:	83 c4 10             	add    $0x10,%esp
f01037dc:	eb 10                	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01037de:	83 ec 0c             	sub    $0xc,%esp
f01037e1:	68 44 4d 12 f0       	push   $0xf0124d44
f01037e6:	e8 a0 d7 ff ff       	call   f0100f8b <cprintf>
f01037eb:	83 c4 10             	add    $0x10,%esp

	return 0;
f01037ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037f3:	c9                   	leave  
f01037f4:	c3                   	ret    

f01037f5 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01037f5:	55                   	push   %ebp
f01037f6:	89 e5                	mov    %esp,%ebp
f01037f8:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01037fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01037fe:	83 c0 04             	add    $0x4,%eax
f0103801:	8b 00                	mov    (%eax),%eax
f0103803:	83 ec 04             	sub    $0x4,%esp
f0103806:	6a 0a                	push   $0xa
f0103808:	6a 00                	push   $0x0
f010380a:	50                   	push   %eax
f010380b:	e8 b2 ca 01 00       	call   f01202c2 <strtol>
f0103810:	83 c4 10             	add    $0x10,%esp
f0103813:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103816:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103819:	0f b6 c0             	movzbl %al,%eax
f010381c:	83 ec 0c             	sub    $0xc,%esp
f010381f:	50                   	push   %eax
f0103820:	e8 91 b8 01 00       	call   f011f0b6 <chksch>
f0103825:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103828:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010382c:	75 12                	jne    f0103840 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010382e:	83 ec 0c             	sub    $0xc,%esp
f0103831:	68 6c 4d 12 f0       	push   $0xf0124d6c
f0103836:	e8 50 d7 ff ff       	call   f0100f8b <cprintf>
f010383b:	83 c4 10             	add    $0x10,%esp
f010383e:	eb 16                	jmp    f0103856 <command_sch_test+0x61>
	else if (status == 1)
f0103840:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103844:	75 10                	jne    f0103856 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f0103846:	83 ec 0c             	sub    $0xc,%esp
f0103849:	68 94 4d 12 f0       	push   $0xf0124d94
f010384e:	e8 38 d7 ff ff       	call   f0100f8b <cprintf>
f0103853:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103856:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010385b:	c9                   	leave  
f010385c:	c3                   	ret    

f010385d <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f010385d:	55                   	push   %ebp
f010385e:	89 e5                	mov    %esp,%ebp
f0103860:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f0103863:	e8 0f c1 00 00       	call   f010f977 <isPageReplacmentAlgorithmCLOCK>
f0103868:	85 c0                	test   %eax,%eax
f010386a:	74 15                	je     f0103881 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f010386c:	83 ec 0c             	sub    $0xc,%esp
f010386f:	68 b8 4d 12 f0       	push   $0xf0124db8
f0103874:	e8 12 d7 ff ff       	call   f0100f8b <cprintf>
f0103879:	83 c4 10             	add    $0x10,%esp
f010387c:	e9 e1 00 00 00       	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0103881:	83 ec 0c             	sub    $0xc,%esp
f0103884:	6a 01                	push   $0x1
f0103886:	e8 d6 c0 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010388b:	83 c4 10             	add    $0x10,%esp
f010388e:	85 c0                	test   %eax,%eax
f0103890:	74 15                	je     f01038a7 <command_print_page_rep+0x4a>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0103892:	83 ec 0c             	sub    $0xc,%esp
f0103895:	68 e0 4d 12 f0       	push   $0xf0124de0
f010389a:	e8 ec d6 ff ff       	call   f0100f8b <cprintf>
f010389f:	83 c4 10             	add    $0x10,%esp
f01038a2:	e9 bb 00 00 00       	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01038a7:	83 ec 0c             	sub    $0xc,%esp
f01038aa:	6a 02                	push   $0x2
f01038ac:	e8 b0 c0 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f01038b1:	83 c4 10             	add    $0x10,%esp
f01038b4:	85 c0                	test   %eax,%eax
f01038b6:	74 15                	je     f01038cd <command_print_page_rep+0x70>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f01038b8:	83 ec 0c             	sub    $0xc,%esp
f01038bb:	68 20 4e 12 f0       	push   $0xf0124e20
f01038c0:	e8 c6 d6 ff ff       	call   f0100f8b <cprintf>
f01038c5:	83 c4 10             	add    $0x10,%esp
f01038c8:	e9 95 00 00 00       	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmFIFO())
f01038cd:	e8 c0 c0 00 00       	call   f010f992 <isPageReplacmentAlgorithmFIFO>
f01038d2:	85 c0                	test   %eax,%eax
f01038d4:	74 12                	je     f01038e8 <command_print_page_rep+0x8b>
		cprintf("Page replacement algorithm is FIFO\n");
f01038d6:	83 ec 0c             	sub    $0xc,%esp
f01038d9:	68 5c 4e 12 f0       	push   $0xf0124e5c
f01038de:	e8 a8 d6 ff ff       	call   f0100f8b <cprintf>
f01038e3:	83 c4 10             	add    $0x10,%esp
f01038e6:	eb 7a                	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01038e8:	e8 c0 c0 00 00       	call   f010f9ad <isPageReplacmentAlgorithmModifiedCLOCK>
f01038ed:	85 c0                	test   %eax,%eax
f01038ef:	74 12                	je     f0103903 <command_print_page_rep+0xa6>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01038f1:	83 ec 0c             	sub    $0xc,%esp
f01038f4:	68 80 4e 12 f0       	push   $0xf0124e80
f01038f9:	e8 8d d6 ff ff       	call   f0100f8b <cprintf>
f01038fe:	83 c4 10             	add    $0x10,%esp
f0103901:	eb 5f                	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmNchanceCLOCK())
f0103903:	e8 db c0 00 00       	call   f010f9e3 <isPageReplacmentAlgorithmNchanceCLOCK>
f0103908:	85 c0                	test   %eax,%eax
f010390a:	74 46                	je     f0103952 <command_print_page_rep+0xf5>
	{
		cprintf("Page replacement algorithm is Nth Chance CLOCK ");
f010390c:	83 ec 0c             	sub    $0xc,%esp
f010390f:	68 b0 4e 12 f0       	push   $0xf0124eb0
f0103914:	e8 72 d6 ff ff       	call   f0100f8b <cprintf>
f0103919:	83 c4 10             	add    $0x10,%esp
		if (page_WS_max_sweeps > 0)			cprintf("[NORMAL ver]\n");
f010391c:	a1 14 f1 71 f0       	mov    0xf071f114,%eax
f0103921:	85 c0                	test   %eax,%eax
f0103923:	7e 12                	jle    f0103937 <command_print_page_rep+0xda>
f0103925:	83 ec 0c             	sub    $0xc,%esp
f0103928:	68 e0 4e 12 f0       	push   $0xf0124ee0
f010392d:	e8 59 d6 ff ff       	call   f0100f8b <cprintf>
f0103932:	83 c4 10             	add    $0x10,%esp
f0103935:	eb 2b                	jmp    f0103962 <command_print_page_rep+0x105>
		else if (page_WS_max_sweeps < 0)	cprintf("[MODIFIED ver]\n");
f0103937:	a1 14 f1 71 f0       	mov    0xf071f114,%eax
f010393c:	85 c0                	test   %eax,%eax
f010393e:	79 22                	jns    f0103962 <command_print_page_rep+0x105>
f0103940:	83 ec 0c             	sub    $0xc,%esp
f0103943:	68 ee 4e 12 f0       	push   $0xf0124eee
f0103948:	e8 3e d6 ff ff       	call   f0100f8b <cprintf>
f010394d:	83 c4 10             	add    $0x10,%esp
f0103950:	eb 10                	jmp    f0103962 <command_print_page_rep+0x105>
	}
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f0103952:	83 ec 0c             	sub    $0xc,%esp
f0103955:	68 00 4f 12 f0       	push   $0xf0124f00
f010395a:	e8 2c d6 ff ff       	call   f0100f8b <cprintf>
f010395f:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103962:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103967:	c9                   	leave  
f0103968:	c3                   	ret    

f0103969 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103969:	55                   	push   %ebp
f010396a:	89 e5                	mov    %esp,%ebp
f010396c:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010396f:	e8 3b ec ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103974:	83 ec 0c             	sub    $0xc,%esp
f0103977:	68 2c 4f 12 f0       	push   $0xf0124f2c
f010397c:	e8 0a d6 ff ff       	call   f0100f8b <cprintf>
f0103981:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103984:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103989:	c9                   	leave  
f010398a:	c3                   	ret    

f010398b <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f010398b:	55                   	push   %ebp
f010398c:	89 e5                	mov    %esp,%ebp
f010398e:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f0103991:	e8 29 ec ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f0103996:	83 ec 0c             	sub    $0xc,%esp
f0103999:	68 5c 4f 12 f0       	push   $0xf0124f5c
f010399e:	e8 e8 d5 ff ff       	call   f0100f8b <cprintf>
f01039a3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039ab:	c9                   	leave  
f01039ac:	c3                   	ret    

f01039ad <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01039ad:	55                   	push   %ebp
f01039ae:	89 e5                	mov    %esp,%ebp
f01039b0:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01039b3:	e8 17 ec ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01039b8:	83 ec 0c             	sub    $0xc,%esp
f01039bb:	68 8c 4f 12 f0       	push   $0xf0124f8c
f01039c0:	e8 c6 d5 ff ff       	call   f0100f8b <cprintf>
f01039c5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039cd:	c9                   	leave  
f01039ce:	c3                   	ret    

f01039cf <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01039cf:	55                   	push   %ebp
f01039d0:	89 e5                	mov    %esp,%ebp
f01039d2:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01039d5:	e8 05 ec ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01039da:	83 ec 0c             	sub    $0xc,%esp
f01039dd:	68 bc 4f 12 f0       	push   $0xf0124fbc
f01039e2:	e8 a4 d5 ff ff       	call   f0100f8b <cprintf>
f01039e7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039ef:	c9                   	leave  
f01039f0:	c3                   	ret    

f01039f1 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01039f1:	55                   	push   %ebp
f01039f2:	89 e5                	mov    %esp,%ebp
f01039f4:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f01039f7:	e8 f3 eb ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f01039fc:	84 c0                	test   %al,%al
f01039fe:	74 12                	je     f0103a12 <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0103a00:	83 ec 0c             	sub    $0xc,%esp
f0103a03:	68 ec 4f 12 f0       	push   $0xf0124fec
f0103a08:	e8 7e d5 ff ff       	call   f0100f8b <cprintf>
f0103a0d:	83 c4 10             	add    $0x10,%esp
f0103a10:	eb 61                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f0103a12:	e8 ed eb ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103a17:	84 c0                	test   %al,%al
f0103a19:	74 12                	je     f0103a2d <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103a1b:	83 ec 0c             	sub    $0xc,%esp
f0103a1e:	68 18 50 12 f0       	push   $0xf0125018
f0103a23:	e8 63 d5 ff ff       	call   f0100f8b <cprintf>
f0103a28:	83 c4 10             	add    $0x10,%esp
f0103a2b:	eb 46                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103a2d:	e8 e7 eb ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f0103a32:	84 c0                	test   %al,%al
f0103a34:	74 12                	je     f0103a48 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103a36:	83 ec 0c             	sub    $0xc,%esp
f0103a39:	68 44 50 12 f0       	push   $0xf0125044
f0103a3e:	e8 48 d5 ff ff       	call   f0100f8b <cprintf>
f0103a43:	83 c4 10             	add    $0x10,%esp
f0103a46:	eb 2b                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103a48:	e8 e1 eb ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103a4d:	84 c0                	test   %al,%al
f0103a4f:	74 12                	je     f0103a63 <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f0103a51:	83 ec 0c             	sub    $0xc,%esp
f0103a54:	68 70 50 12 f0       	push   $0xf0125070
f0103a59:	e8 2d d5 ff ff       	call   f0100f8b <cprintf>
f0103a5e:	83 c4 10             	add    $0x10,%esp
f0103a61:	eb 10                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f0103a63:	83 ec 0c             	sub    $0xc,%esp
f0103a66:	68 9c 50 12 f0       	push   $0xf012509c
f0103a6b:	e8 1b d5 ff ff       	call   f0100f8b <cprintf>
f0103a70:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103a73:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a78:	c9                   	leave  
f0103a79:	c3                   	ret    

f0103a7a <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103a7a:	55                   	push   %ebp
f0103a7b:	89 e5                	mov    %esp,%ebp
f0103a7d:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f0103a80:	e8 72 ea ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103a85:	83 ec 0c             	sub    $0xc,%esp
f0103a88:	68 c8 50 12 f0       	push   $0xf01250c8
f0103a8d:	e8 f9 d4 ff ff       	call   f0100f8b <cprintf>
f0103a92:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a95:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a9a:	c9                   	leave  
f0103a9b:	c3                   	ret    

f0103a9c <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103a9c:	55                   	push   %ebp
f0103a9d:	89 e5                	mov    %esp,%ebp
f0103a9f:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f0103aa2:	e8 60 ea ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103aa7:	83 ec 0c             	sub    $0xc,%esp
f0103aaa:	68 c8 50 12 f0       	push   $0xf01250c8
f0103aaf:	e8 d7 d4 ff ff       	call   f0100f8b <cprintf>
f0103ab4:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ab7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103abc:	c9                   	leave  
f0103abd:	c3                   	ret    

f0103abe <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103abe:	55                   	push   %ebp
f0103abf:	89 e5                	mov    %esp,%ebp
f0103ac1:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f0103ac4:	e8 4e ea ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0103ac9:	83 ec 0c             	sub    $0xc,%esp
f0103acc:	68 fc 50 12 f0       	push   $0xf01250fc
f0103ad1:	e8 b5 d4 ff ff       	call   f0100f8b <cprintf>
f0103ad6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ad9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ade:	c9                   	leave  
f0103adf:	c3                   	ret    

f0103ae0 <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103ae0:	55                   	push   %ebp
f0103ae1:	89 e5                	mov    %esp,%ebp
f0103ae3:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f0103ae6:	e8 3c ea ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f0103aeb:	83 ec 0c             	sub    $0xc,%esp
f0103aee:	68 2c 51 12 f0       	push   $0xf012512c
f0103af3:	e8 93 d4 ff ff       	call   f0100f8b <cprintf>
f0103af8:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103afb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b00:	c9                   	leave  
f0103b01:	c3                   	ret    

f0103b02 <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0103b02:	55                   	push   %ebp
f0103b03:	89 e5                	mov    %esp,%ebp
f0103b05:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103b08:	e8 2a ea ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103b0d:	83 ec 0c             	sub    $0xc,%esp
f0103b10:	68 5c 51 12 f0       	push   $0xf012515c
f0103b15:	e8 71 d4 ff ff       	call   f0100f8b <cprintf>
f0103b1a:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b1d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b22:	c9                   	leave  
f0103b23:	c3                   	ret    

f0103b24 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103b24:	55                   	push   %ebp
f0103b25:	89 e5                	mov    %esp,%ebp
f0103b27:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103b2a:	e8 18 ea ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f0103b2f:	84 c0                	test   %al,%al
f0103b31:	74 12                	je     f0103b45 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f0103b33:	83 ec 0c             	sub    $0xc,%esp
f0103b36:	68 90 51 12 f0       	push   $0xf0125190
f0103b3b:	e8 4b d4 ff ff       	call   f0100f8b <cprintf>
f0103b40:	83 c4 10             	add    $0x10,%esp
f0103b43:	eb 7c                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103b45:	e8 11 ea ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103b4a:	84 c0                	test   %al,%al
f0103b4c:	74 12                	je     f0103b60 <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0103b4e:	83 ec 0c             	sub    $0xc,%esp
f0103b51:	68 cc 51 12 f0       	push   $0xf01251cc
f0103b56:	e8 30 d4 ff ff       	call   f0100f8b <cprintf>
f0103b5b:	83 c4 10             	add    $0x10,%esp
f0103b5e:	eb 61                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f0103b60:	e8 0b ea ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103b65:	84 c0                	test   %al,%al
f0103b67:	74 12                	je     f0103b7b <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103b69:	83 ec 0c             	sub    $0xc,%esp
f0103b6c:	68 fc 51 12 f0       	push   $0xf01251fc
f0103b71:	e8 15 d4 ff ff       	call   f0100f8b <cprintf>
f0103b76:	83 c4 10             	add    $0x10,%esp
f0103b79:	eb 46                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103b7b:	e8 05 ea ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f0103b80:	84 c0                	test   %al,%al
f0103b82:	74 12                	je     f0103b96 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103b84:	83 ec 0c             	sub    $0xc,%esp
f0103b87:	68 28 52 12 f0       	push   $0xf0125228
f0103b8c:	e8 fa d3 ff ff       	call   f0100f8b <cprintf>
f0103b91:	83 c4 10             	add    $0x10,%esp
f0103b94:	eb 2b                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f0103b96:	e8 ff e9 ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f0103b9b:	84 c0                	test   %al,%al
f0103b9d:	74 12                	je     f0103bb1 <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0103b9f:	83 ec 0c             	sub    $0xc,%esp
f0103ba2:	68 54 52 12 f0       	push   $0xf0125254
f0103ba7:	e8 df d3 ff ff       	call   f0100f8b <cprintf>
f0103bac:	83 c4 10             	add    $0x10,%esp
f0103baf:	eb 10                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f0103bb1:	83 ec 0c             	sub    $0xc,%esp
f0103bb4:	68 84 52 12 f0       	push   $0xf0125284
f0103bb9:	e8 cd d3 ff ff       	call   f0100f8b <cprintf>
f0103bbe:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103bc1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bc6:	c9                   	leave  
f0103bc7:	c3                   	ret    

f0103bc8 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103bc8:	55                   	push   %ebp
f0103bc9:	89 e5                	mov    %esp,%ebp
f0103bcb:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103bce:	e8 51 be 00 00       	call   f010fa24 <isBufferingEnabled>
f0103bd3:	84 c0                	test   %al,%al
f0103bd5:	75 12                	jne    f0103be9 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103bd7:	83 ec 0c             	sub    $0xc,%esp
f0103bda:	68 b4 52 12 f0       	push   $0xf01252b4
f0103bdf:	e8 a7 d3 ff ff       	call   f0100f8b <cprintf>
f0103be4:	83 c4 10             	add    $0x10,%esp
f0103be7:	eb 1d                	jmp    f0103c06 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0103be9:	83 ec 0c             	sub    $0xc,%esp
f0103bec:	6a 00                	push   $0x0
f0103bee:	e8 0b be 00 00       	call   f010f9fe <enableModifiedBuffer>
f0103bf3:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103bf6:	83 ec 0c             	sub    $0xc,%esp
f0103bf9:	68 f0 52 12 f0       	push   $0xf01252f0
f0103bfe:	e8 88 d3 ff ff       	call   f0100f8b <cprintf>
f0103c03:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103c06:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c0b:	c9                   	leave  
f0103c0c:	c3                   	ret    

f0103c0d <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103c0d:	55                   	push   %ebp
f0103c0e:	89 e5                	mov    %esp,%ebp
f0103c10:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103c13:	e8 0c be 00 00       	call   f010fa24 <isBufferingEnabled>
f0103c18:	84 c0                	test   %al,%al
f0103c1a:	75 12                	jne    f0103c2e <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103c1c:	83 ec 0c             	sub    $0xc,%esp
f0103c1f:	68 b4 52 12 f0       	push   $0xf01252b4
f0103c24:	e8 62 d3 ff ff       	call   f0100f8b <cprintf>
f0103c29:	83 c4 10             	add    $0x10,%esp
f0103c2c:	eb 1d                	jmp    f0103c4b <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103c2e:	83 ec 0c             	sub    $0xc,%esp
f0103c31:	6a 01                	push   $0x1
f0103c33:	e8 c6 bd 00 00       	call   f010f9fe <enableModifiedBuffer>
f0103c38:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103c3b:	83 ec 0c             	sub    $0xc,%esp
f0103c3e:	68 14 53 12 f0       	push   $0xf0125314
f0103c43:	e8 43 d3 ff ff       	call   f0100f8b <cprintf>
f0103c48:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103c4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c50:	c9                   	leave  
f0103c51:	c3                   	ret    

f0103c52 <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103c52:	55                   	push   %ebp
f0103c53:	89 e5                	mov    %esp,%ebp
f0103c55:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103c58:	83 ec 0c             	sub    $0xc,%esp
f0103c5b:	6a 00                	push   $0x0
f0103c5d:	e8 b4 bd 00 00       	call   f010fa16 <enableBuffering>
f0103c62:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103c65:	83 ec 0c             	sub    $0xc,%esp
f0103c68:	6a 00                	push   $0x0
f0103c6a:	e8 8f bd 00 00       	call   f010f9fe <enableModifiedBuffer>
f0103c6f:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103c72:	83 ec 0c             	sub    $0xc,%esp
f0103c75:	68 34 53 12 f0       	push   $0xf0125334
f0103c7a:	e8 0c d3 ff ff       	call   f0100f8b <cprintf>
f0103c7f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103c82:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c87:	c9                   	leave  
f0103c88:	c3                   	ret    

f0103c89 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103c89:	55                   	push   %ebp
f0103c8a:	89 e5                	mov    %esp,%ebp
f0103c8c:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103c8f:	83 ec 0c             	sub    $0xc,%esp
f0103c92:	6a 01                	push   $0x1
f0103c94:	e8 7d bd 00 00       	call   f010fa16 <enableBuffering>
f0103c99:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103c9c:	83 ec 0c             	sub    $0xc,%esp
f0103c9f:	6a 01                	push   $0x1
f0103ca1:	e8 58 bd 00 00       	call   f010f9fe <enableModifiedBuffer>
f0103ca6:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ca9:	e8 8e bd 00 00       	call   f010fa3c <getModifiedBufferLength>
f0103cae:	85 c0                	test   %eax,%eax
f0103cb0:	75 59                	jne    f0103d0b <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103cb2:	83 ec 0c             	sub    $0xc,%esp
f0103cb5:	68 50 53 12 f0       	push   $0xf0125350
f0103cba:	e8 cc d2 ff ff       	call   f0100f8b <cprintf>
f0103cbf:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103cc2:	83 ec 08             	sub    $0x8,%esp
f0103cc5:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103cc8:	50                   	push   %eax
f0103cc9:	68 80 53 12 f0       	push   $0xf0125380
f0103cce:	e8 87 c0 01 00       	call   f011fd5a <readline>
f0103cd3:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103cd6:	83 ec 04             	sub    $0x4,%esp
f0103cd9:	6a 0a                	push   $0xa
f0103cdb:	6a 00                	push   $0x0
f0103cdd:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ce0:	50                   	push   %eax
f0103ce1:	e8 dc c5 01 00       	call   f01202c2 <strtol>
f0103ce6:	83 c4 10             	add    $0x10,%esp
f0103ce9:	83 ec 0c             	sub    $0xc,%esp
f0103cec:	50                   	push   %eax
f0103ced:	e8 3c bd 00 00       	call   f010fa2e <setModifiedBufferLength>
f0103cf2:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103cf5:	e8 42 bd 00 00       	call   f010fa3c <getModifiedBufferLength>
f0103cfa:	83 ec 08             	sub    $0x8,%esp
f0103cfd:	50                   	push   %eax
f0103cfe:	68 ac 53 12 f0       	push   $0xf01253ac
f0103d03:	e8 83 d2 ff ff       	call   f0100f8b <cprintf>
f0103d08:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103d0b:	83 ec 0c             	sub    $0xc,%esp
f0103d0e:	68 d1 53 12 f0       	push   $0xf01253d1
f0103d13:	e8 73 d2 ff ff       	call   f0100f8b <cprintf>
f0103d18:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103d1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d20:	c9                   	leave  
f0103d21:	c3                   	ret    

f0103d22 <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103d22:	55                   	push   %ebp
f0103d23:	89 e5                	mov    %esp,%ebp
f0103d25:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103d28:	e8 f7 bc 00 00       	call   f010fa24 <isBufferingEnabled>
f0103d2d:	84 c0                	test   %al,%al
f0103d2f:	75 12                	jne    f0103d43 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103d31:	83 ec 0c             	sub    $0xc,%esp
f0103d34:	68 ec 53 12 f0       	push   $0xf01253ec
f0103d39:	e8 4d d2 ff ff       	call   f0100f8b <cprintf>
f0103d3e:	83 c4 10             	add    $0x10,%esp
f0103d41:	eb 19                	jmp    f0103d5c <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103d43:	e8 c4 bc 00 00       	call   f010fa0c <isModifiedBufferEnabled>
f0103d48:	84 c0                	test   %al,%al
f0103d4a:	75 10                	jne    f0103d5c <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103d4c:	83 ec 0c             	sub    $0xc,%esp
f0103d4f:	68 3c 54 12 f0       	push   $0xf012543c
f0103d54:	e8 32 d2 ff ff       	call   f0100f8b <cprintf>
f0103d59:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103d5c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d5f:	83 c0 04             	add    $0x4,%eax
f0103d62:	8b 00                	mov    (%eax),%eax
f0103d64:	83 ec 04             	sub    $0x4,%esp
f0103d67:	6a 0a                	push   $0xa
f0103d69:	6a 00                	push   $0x0
f0103d6b:	50                   	push   %eax
f0103d6c:	e8 51 c5 01 00       	call   f01202c2 <strtol>
f0103d71:	83 c4 10             	add    $0x10,%esp
f0103d74:	83 ec 0c             	sub    $0xc,%esp
f0103d77:	50                   	push   %eax
f0103d78:	e8 b1 bc 00 00       	call   f010fa2e <setModifiedBufferLength>
f0103d7d:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103d80:	e8 b7 bc 00 00       	call   f010fa3c <getModifiedBufferLength>
f0103d85:	83 ec 08             	sub    $0x8,%esp
f0103d88:	50                   	push   %eax
f0103d89:	68 ac 53 12 f0       	push   $0xf01253ac
f0103d8e:	e8 f8 d1 ff ff       	call   f0100f8b <cprintf>
f0103d93:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103d96:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d9b:	c9                   	leave  
f0103d9c:	c3                   	ret    

f0103d9d <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103d9d:	55                   	push   %ebp
f0103d9e:	89 e5                	mov    %esp,%ebp
f0103da0:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103da3:	e8 7c bc 00 00       	call   f010fa24 <isBufferingEnabled>
f0103da8:	84 c0                	test   %al,%al
f0103daa:	75 12                	jne    f0103dbe <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103dac:	83 ec 0c             	sub    $0xc,%esp
f0103daf:	68 ec 53 12 f0       	push   $0xf01253ec
f0103db4:	e8 d2 d1 ff ff       	call   f0100f8b <cprintf>
f0103db9:	83 c4 10             	add    $0x10,%esp
f0103dbc:	eb 19                	jmp    f0103dd7 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103dbe:	e8 49 bc 00 00       	call   f010fa0c <isModifiedBufferEnabled>
f0103dc3:	84 c0                	test   %al,%al
f0103dc5:	75 10                	jne    f0103dd7 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103dc7:	83 ec 0c             	sub    $0xc,%esp
f0103dca:	68 3c 54 12 f0       	push   $0xf012543c
f0103dcf:	e8 b7 d1 ff ff       	call   f0100f8b <cprintf>
f0103dd4:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103dd7:	e8 60 bc 00 00       	call   f010fa3c <getModifiedBufferLength>
f0103ddc:	83 ec 08             	sub    $0x8,%esp
f0103ddf:	50                   	push   %eax
f0103de0:	68 82 54 12 f0       	push   $0xf0125482
f0103de5:	e8 a1 d1 ff ff       	call   f0100f8b <cprintf>
f0103dea:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ded:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103df2:	c9                   	leave  
f0103df3:	c3                   	ret    

f0103df4 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103df4:	55                   	push   %ebp
f0103df5:	89 e5                	mov    %esp,%ebp
f0103df7:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103dfa:	83 ec 08             	sub    $0x8,%esp
f0103dfd:	ff 75 0c             	pushl  0xc(%ebp)
f0103e00:	ff 75 08             	pushl  0x8(%ebp)
f0103e03:	e8 93 c7 00 00       	call   f011059b <tst_handler>
f0103e08:	83 c4 10             	add    $0x10,%esp
}
f0103e0b:	c9                   	leave  
f0103e0c:	c3                   	ret    

f0103e0d <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103e0d:	55                   	push   %ebp
f0103e0e:	89 e5                	mov    %esp,%ebp
f0103e10:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103e13:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e16:	05 00 14 00 00       	add    $0x1400,%eax
f0103e1b:	c1 e0 03             	shl    $0x3,%eax
f0103e1e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103e21:	83 ec 04             	sub    $0x4,%esp
f0103e24:	6a 08                	push   $0x8
f0103e26:	ff 75 0c             	pushl  0xc(%ebp)
f0103e29:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e2c:	e8 19 c9 01 00       	call   f012074a <ide_read>
f0103e31:	83 c4 10             	add    $0x10,%esp
f0103e34:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103e37:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103e3a:	c9                   	leave  
f0103e3b:	c3                   	ret    

f0103e3c <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103e3c:	55                   	push   %ebp
f0103e3d:	89 e5                	mov    %esp,%ebp
f0103e3f:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103e42:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e45:	05 00 14 00 00       	add    $0x1400,%eax
f0103e4a:	c1 e0 03             	shl    $0x3,%eax
f0103e4d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103e50:	83 ec 04             	sub    $0x4,%esp
f0103e53:	6a 08                	push   $0x8
f0103e55:	ff 75 0c             	pushl  0xc(%ebp)
f0103e58:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e5b:	e8 2a ca 01 00       	call   f012088a <ide_write>
f0103e60:	83 c4 10             	add    $0x10,%esp
f0103e63:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103e66:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e6a:	74 14                	je     f0103e80 <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103e6c:	83 ec 04             	sub    $0x4,%esp
f0103e6f:	68 a0 54 12 f0       	push   $0xf01254a0
f0103e74:	6a 2f                	push   $0x2f
f0103e76:	68 b7 54 12 f0       	push   $0xf01254b7
f0103e7b:	e8 b9 c4 ff ff       	call   f0100339 <_panic>
	return success;
f0103e80:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103e83:	c9                   	leave  
f0103e84:	c3                   	ret    

f0103e85 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103e85:	55                   	push   %ebp
f0103e86:	89 e5                	mov    %esp,%ebp
f0103e88:	53                   	push   %ebx
f0103e89:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103e8c:	c7 05 c0 f7 f1 f0 00 	movl   $0x0,0xf0f1f7c0
f0103e93:	00 00 00 
f0103e96:	c7 05 c4 f7 f1 f0 00 	movl   $0x0,0xf0f1f7c4
f0103e9d:	00 00 00 
f0103ea0:	c7 05 cc f7 f1 f0 00 	movl   $0x0,0xf0f1f7cc
f0103ea7:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103eaa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103eb1:	e9 e8 00 00 00       	jmp    f0103f9e <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103eb6:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103ebc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ebf:	89 d0                	mov    %edx,%eax
f0103ec1:	01 c0                	add    %eax,%eax
f0103ec3:	01 d0                	add    %edx,%eax
f0103ec5:	c1 e0 03             	shl    $0x3,%eax
f0103ec8:	01 c8                	add    %ecx,%eax
f0103eca:	83 ec 0c             	sub    $0xc,%esp
f0103ecd:	50                   	push   %eax
f0103ece:	e8 ef 45 00 00       	call   f01084c2 <initialize_frame_info>
f0103ed3:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ed6:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103edc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103edf:	89 d0                	mov    %edx,%eax
f0103ee1:	01 c0                	add    %eax,%eax
f0103ee3:	01 d0                	add    %edx,%eax
f0103ee5:	c1 e0 03             	shl    $0x3,%eax
f0103ee8:	01 c8                	add    %ecx,%eax
f0103eea:	85 c0                	test   %eax,%eax
f0103eec:	75 14                	jne    f0103f02 <initialize_disk_page_file+0x7d>
f0103eee:	83 ec 04             	sub    $0x4,%esp
f0103ef1:	68 d4 54 12 f0       	push   $0xf01254d4
f0103ef6:	6a 56                	push   $0x56
f0103ef8:	68 b7 54 12 f0       	push   $0xf01254b7
f0103efd:	e8 37 c4 ff ff       	call   f0100339 <_panic>
f0103f02:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103f08:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f0b:	89 d0                	mov    %edx,%eax
f0103f0d:	01 c0                	add    %eax,%eax
f0103f0f:	01 d0                	add    %edx,%eax
f0103f11:	c1 e0 03             	shl    $0x3,%eax
f0103f14:	01 c8                	add    %ecx,%eax
f0103f16:	8b 15 c0 f7 f1 f0    	mov    0xf0f1f7c0,%edx
f0103f1c:	89 10                	mov    %edx,(%eax)
f0103f1e:	8b 00                	mov    (%eax),%eax
f0103f20:	85 c0                	test   %eax,%eax
f0103f22:	74 1f                	je     f0103f43 <initialize_disk_page_file+0xbe>
f0103f24:	8b 15 c0 f7 f1 f0    	mov    0xf0f1f7c0,%edx
f0103f2a:	8b 1d 40 ee 71 f0    	mov    0xf071ee40,%ebx
f0103f30:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103f33:	89 c8                	mov    %ecx,%eax
f0103f35:	01 c0                	add    %eax,%eax
f0103f37:	01 c8                	add    %ecx,%eax
f0103f39:	c1 e0 03             	shl    $0x3,%eax
f0103f3c:	01 d8                	add    %ebx,%eax
f0103f3e:	89 42 04             	mov    %eax,0x4(%edx)
f0103f41:	eb 19                	jmp    f0103f5c <initialize_disk_page_file+0xd7>
f0103f43:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103f49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f4c:	89 d0                	mov    %edx,%eax
f0103f4e:	01 c0                	add    %eax,%eax
f0103f50:	01 d0                	add    %edx,%eax
f0103f52:	c1 e0 03             	shl    $0x3,%eax
f0103f55:	01 c8                	add    %ecx,%eax
f0103f57:	a3 c4 f7 f1 f0       	mov    %eax,0xf0f1f7c4
f0103f5c:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103f62:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f65:	89 d0                	mov    %edx,%eax
f0103f67:	01 c0                	add    %eax,%eax
f0103f69:	01 d0                	add    %edx,%eax
f0103f6b:	c1 e0 03             	shl    $0x3,%eax
f0103f6e:	01 c8                	add    %ecx,%eax
f0103f70:	a3 c0 f7 f1 f0       	mov    %eax,0xf0f1f7c0
f0103f75:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0103f7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f7e:	89 d0                	mov    %edx,%eax
f0103f80:	01 c0                	add    %eax,%eax
f0103f82:	01 d0                	add    %edx,%eax
f0103f84:	c1 e0 03             	shl    $0x3,%eax
f0103f87:	01 c8                	add    %ecx,%eax
f0103f89:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103f90:	a1 cc f7 f1 f0       	mov    0xf0f1f7cc,%eax
f0103f95:	40                   	inc    %eax
f0103f96:	a3 cc f7 f1 f0       	mov    %eax,0xf0f1f7cc
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103f9b:	ff 45 f4             	incl   -0xc(%ebp)
f0103f9e:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103fa5:	0f 8e 0b ff ff ff    	jle    f0103eb6 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103fab:	90                   	nop
f0103fac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103faf:	c9                   	leave  
f0103fb0:	c3                   	ret    

f0103fb1 <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103fb1:	55                   	push   %ebp
f0103fb2:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103fb4:	8b 45 08             	mov    0x8(%ebp),%eax
f0103fb7:	8b 15 40 ee 71 f0    	mov    0xf071ee40,%edx
f0103fbd:	29 d0                	sub    %edx,%eax
f0103fbf:	c1 f8 03             	sar    $0x3,%eax
f0103fc2:	89 c2                	mov    %eax,%edx
f0103fc4:	89 d0                	mov    %edx,%eax
f0103fc6:	c1 e0 02             	shl    $0x2,%eax
f0103fc9:	01 d0                	add    %edx,%eax
f0103fcb:	c1 e0 02             	shl    $0x2,%eax
f0103fce:	01 d0                	add    %edx,%eax
f0103fd0:	c1 e0 02             	shl    $0x2,%eax
f0103fd3:	01 d0                	add    %edx,%eax
f0103fd5:	89 c1                	mov    %eax,%ecx
f0103fd7:	c1 e1 08             	shl    $0x8,%ecx
f0103fda:	01 c8                	add    %ecx,%eax
f0103fdc:	89 c1                	mov    %eax,%ecx
f0103fde:	c1 e1 10             	shl    $0x10,%ecx
f0103fe1:	01 c8                	add    %ecx,%eax
f0103fe3:	01 c0                	add    %eax,%eax
f0103fe5:	01 d0                	add    %edx,%eax
}
f0103fe7:	5d                   	pop    %ebp
f0103fe8:	c3                   	ret    

f0103fe9 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103fe9:	55                   	push   %ebp
f0103fea:	89 e5                	mov    %esp,%ebp
f0103fec:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103fef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ff6:	83 ec 0c             	sub    $0xc,%esp
f0103ff9:	68 d0 f7 f1 f0       	push   $0xf0f1f7d0
f0103ffe:	e8 b1 bf 00 00       	call   f010ffb4 <acquire_spinlock>
f0104003:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0104006:	a1 c0 f7 f1 f0       	mov    0xf0f1f7c0,%eax
f010400b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f010400e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104012:	75 0c                	jne    f0104020 <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0104014:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f010401b:	e9 a2 00 00 00       	jmp    f01040c2 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0104020:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104024:	75 14                	jne    f010403a <allocate_disk_frame+0x51>
f0104026:	83 ec 04             	sub    $0x4,%esp
f0104029:	68 f7 54 12 f0       	push   $0xf01254f7
f010402e:	6a 7b                	push   $0x7b
f0104030:	68 b7 54 12 f0       	push   $0xf01254b7
f0104035:	e8 ff c2 ff ff       	call   f0100339 <_panic>
f010403a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010403d:	8b 00                	mov    (%eax),%eax
f010403f:	85 c0                	test   %eax,%eax
f0104041:	74 10                	je     f0104053 <allocate_disk_frame+0x6a>
f0104043:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104046:	8b 00                	mov    (%eax),%eax
f0104048:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010404b:	8b 52 04             	mov    0x4(%edx),%edx
f010404e:	89 50 04             	mov    %edx,0x4(%eax)
f0104051:	eb 0b                	jmp    f010405e <allocate_disk_frame+0x75>
f0104053:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104056:	8b 40 04             	mov    0x4(%eax),%eax
f0104059:	a3 c4 f7 f1 f0       	mov    %eax,0xf0f1f7c4
f010405e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104061:	8b 40 04             	mov    0x4(%eax),%eax
f0104064:	85 c0                	test   %eax,%eax
f0104066:	74 0f                	je     f0104077 <allocate_disk_frame+0x8e>
f0104068:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010406b:	8b 40 04             	mov    0x4(%eax),%eax
f010406e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104071:	8b 12                	mov    (%edx),%edx
f0104073:	89 10                	mov    %edx,(%eax)
f0104075:	eb 0a                	jmp    f0104081 <allocate_disk_frame+0x98>
f0104077:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010407a:	8b 00                	mov    (%eax),%eax
f010407c:	a3 c0 f7 f1 f0       	mov    %eax,0xf0f1f7c0
f0104081:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104084:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010408a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010408d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104094:	a1 cc f7 f1 f0       	mov    0xf0f1f7cc,%eax
f0104099:	48                   	dec    %eax
f010409a:	a3 cc f7 f1 f0       	mov    %eax,0xf0f1f7cc
			initialize_frame_info(ptr_frame_info);
f010409f:	83 ec 0c             	sub    $0xc,%esp
f01040a2:	ff 75 f0             	pushl  -0x10(%ebp)
f01040a5:	e8 18 44 00 00       	call   f01084c2 <initialize_frame_info>
f01040aa:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f01040ad:	83 ec 0c             	sub    $0xc,%esp
f01040b0:	ff 75 f0             	pushl  -0x10(%ebp)
f01040b3:	e8 f9 fe ff ff       	call   f0103fb1 <to_disk_frame_number>
f01040b8:	83 c4 10             	add    $0x10,%esp
f01040bb:	89 c2                	mov    %eax,%edx
f01040bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01040c0:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01040c2:	83 ec 0c             	sub    $0xc,%esp
f01040c5:	68 d0 f7 f1 f0       	push   $0xf0f1f7d0
f01040ca:	e8 6c bf 00 00       	call   f011003b <release_spinlock>
f01040cf:	83 c4 10             	add    $0x10,%esp

	return ret;
f01040d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01040d5:	c9                   	leave  
f01040d6:	c3                   	ret    

f01040d7 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f01040d7:	55                   	push   %ebp
f01040d8:	89 e5                	mov    %esp,%ebp
f01040da:	53                   	push   %ebx
f01040db:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f01040de:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01040e2:	0f 84 ea 00 00 00    	je     f01041d2 <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f01040e8:	83 ec 0c             	sub    $0xc,%esp
f01040eb:	68 d0 f7 f1 f0       	push   $0xf0f1f7d0
f01040f0:	e8 bf be 00 00       	call   f010ffb4 <acquire_spinlock>
f01040f5:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f01040f8:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f01040fe:	8b 55 08             	mov    0x8(%ebp),%edx
f0104101:	89 d0                	mov    %edx,%eax
f0104103:	01 c0                	add    %eax,%eax
f0104105:	01 d0                	add    %edx,%eax
f0104107:	c1 e0 03             	shl    $0x3,%eax
f010410a:	01 c8                	add    %ecx,%eax
f010410c:	85 c0                	test   %eax,%eax
f010410e:	75 17                	jne    f0104127 <free_disk_frame+0x50>
f0104110:	83 ec 04             	sub    $0x4,%esp
f0104113:	68 d4 54 12 f0       	push   $0xf01254d4
f0104118:	68 8e 00 00 00       	push   $0x8e
f010411d:	68 b7 54 12 f0       	push   $0xf01254b7
f0104122:	e8 12 c2 ff ff       	call   f0100339 <_panic>
f0104127:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f010412d:	8b 55 08             	mov    0x8(%ebp),%edx
f0104130:	89 d0                	mov    %edx,%eax
f0104132:	01 c0                	add    %eax,%eax
f0104134:	01 d0                	add    %edx,%eax
f0104136:	c1 e0 03             	shl    $0x3,%eax
f0104139:	01 c8                	add    %ecx,%eax
f010413b:	8b 15 c0 f7 f1 f0    	mov    0xf0f1f7c0,%edx
f0104141:	89 10                	mov    %edx,(%eax)
f0104143:	8b 00                	mov    (%eax),%eax
f0104145:	85 c0                	test   %eax,%eax
f0104147:	74 1f                	je     f0104168 <free_disk_frame+0x91>
f0104149:	8b 15 c0 f7 f1 f0    	mov    0xf0f1f7c0,%edx
f010414f:	8b 1d 40 ee 71 f0    	mov    0xf071ee40,%ebx
f0104155:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0104158:	89 c8                	mov    %ecx,%eax
f010415a:	01 c0                	add    %eax,%eax
f010415c:	01 c8                	add    %ecx,%eax
f010415e:	c1 e0 03             	shl    $0x3,%eax
f0104161:	01 d8                	add    %ebx,%eax
f0104163:	89 42 04             	mov    %eax,0x4(%edx)
f0104166:	eb 19                	jmp    f0104181 <free_disk_frame+0xaa>
f0104168:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f010416e:	8b 55 08             	mov    0x8(%ebp),%edx
f0104171:	89 d0                	mov    %edx,%eax
f0104173:	01 c0                	add    %eax,%eax
f0104175:	01 d0                	add    %edx,%eax
f0104177:	c1 e0 03             	shl    $0x3,%eax
f010417a:	01 c8                	add    %ecx,%eax
f010417c:	a3 c4 f7 f1 f0       	mov    %eax,0xf0f1f7c4
f0104181:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f0104187:	8b 55 08             	mov    0x8(%ebp),%edx
f010418a:	89 d0                	mov    %edx,%eax
f010418c:	01 c0                	add    %eax,%eax
f010418e:	01 d0                	add    %edx,%eax
f0104190:	c1 e0 03             	shl    $0x3,%eax
f0104193:	01 c8                	add    %ecx,%eax
f0104195:	a3 c0 f7 f1 f0       	mov    %eax,0xf0f1f7c0
f010419a:	8b 0d 40 ee 71 f0    	mov    0xf071ee40,%ecx
f01041a0:	8b 55 08             	mov    0x8(%ebp),%edx
f01041a3:	89 d0                	mov    %edx,%eax
f01041a5:	01 c0                	add    %eax,%eax
f01041a7:	01 d0                	add    %edx,%eax
f01041a9:	c1 e0 03             	shl    $0x3,%eax
f01041ac:	01 c8                	add    %ecx,%eax
f01041ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01041b5:	a1 cc f7 f1 f0       	mov    0xf0f1f7cc,%eax
f01041ba:	40                   	inc    %eax
f01041bb:	a3 cc f7 f1 f0       	mov    %eax,0xf0f1f7cc
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01041c0:	83 ec 0c             	sub    $0xc,%esp
f01041c3:	68 d0 f7 f1 f0       	push   $0xf0f1f7d0
f01041c8:	e8 6e be 00 00       	call   f011003b <release_spinlock>
f01041cd:	83 c4 10             	add    $0x10,%esp
f01041d0:	eb 01                	jmp    f01041d3 <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f01041d2:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f01041d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01041d6:	c9                   	leave  
f01041d7:	c3                   	ret    

f01041d8 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f01041d8:	55                   	push   %ebp
f01041d9:	89 e5                	mov    %esp,%ebp
f01041db:	53                   	push   %ebx
f01041dc:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f01041df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01041e2:	c1 e8 16             	shr    $0x16,%eax
f01041e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01041ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01041ef:	01 d0                	add    %edx,%eax
f01041f1:	8b 00                	mov    (%eax),%eax
f01041f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01041f6:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01041fd:	77 1d                	ja     f010421c <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f01041ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104202:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104207:	83 ec 0c             	sub    $0xc,%esp
f010420a:	50                   	push   %eax
f010420b:	e8 02 5a 00 00       	call   f0109c12 <kheap_virtual_address>
f0104210:	83 c4 10             	add    $0x10,%esp
f0104213:	89 c2                	mov    %eax,%edx
f0104215:	8b 45 14             	mov    0x14(%ebp),%eax
f0104218:	89 10                	mov    %edx,(%eax)
f010421a:	eb 44                	jmp    f0104260 <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f010421c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010421f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104224:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104227:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010422a:	c1 e8 0c             	shr    $0xc,%eax
f010422d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0104230:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0104235:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104238:	72 17                	jb     f0104251 <get_disk_page_table+0x79>
f010423a:	ff 75 f0             	pushl  -0x10(%ebp)
f010423d:	68 18 55 12 f0       	push   $0xf0125518
f0104242:	68 9d 00 00 00       	push   $0x9d
f0104247:	68 b7 54 12 f0       	push   $0xf01254b7
f010424c:	e8 e8 c0 ff ff       	call   f0100339 <_panic>
f0104251:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104254:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104259:	89 c2                	mov    %eax,%edx
f010425b:	8b 45 14             	mov    0x14(%ebp),%eax
f010425e:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0104260:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104264:	0f 85 80 00 00 00    	jne    f01042ea <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f010426a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010426e:	74 6a                	je     f01042da <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f0104270:	83 ec 0c             	sub    $0xc,%esp
f0104273:	68 00 10 00 00       	push   $0x1000
f0104278:	e8 52 55 00 00       	call   f01097cf <kmalloc>
f010427d:	83 c4 10             	add    $0x10,%esp
f0104280:	89 c2                	mov    %eax,%edx
f0104282:	8b 45 14             	mov    0x14(%ebp),%eax
f0104285:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104287:	8b 45 14             	mov    0x14(%ebp),%eax
f010428a:	8b 00                	mov    (%eax),%eax
f010428c:	85 c0                	test   %eax,%eax
f010428e:	75 07                	jne    f0104297 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f0104290:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f0104295:	eb 58                	jmp    f01042ef <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f0104297:	8b 45 0c             	mov    0xc(%ebp),%eax
f010429a:	c1 e8 16             	shr    $0x16,%eax
f010429d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01042a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01042a7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01042aa:	8b 45 14             	mov    0x14(%ebp),%eax
f01042ad:	8b 00                	mov    (%eax),%eax
f01042af:	83 ec 0c             	sub    $0xc,%esp
f01042b2:	50                   	push   %eax
f01042b3:	e8 fd 58 00 00       	call   f0109bb5 <kheap_physical_address>
f01042b8:	83 c4 10             	add    $0x10,%esp
f01042bb:	83 c8 01             	or     $0x1,%eax
f01042be:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01042c0:	8b 45 14             	mov    0x14(%ebp),%eax
f01042c3:	8b 00                	mov    (%eax),%eax
f01042c5:	83 ec 04             	sub    $0x4,%esp
f01042c8:	68 00 10 00 00       	push   $0x1000
f01042cd:	6a 00                	push   $0x0
f01042cf:	50                   	push   %eax
f01042d0:	e8 7b be 01 00       	call   f0120150 <memset>
f01042d5:	83 c4 10             	add    $0x10,%esp
f01042d8:	eb 10                	jmp    f01042ea <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01042da:	8b 45 14             	mov    0x14(%ebp),%eax
f01042dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01042e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01042e8:	eb 05                	jmp    f01042ef <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01042ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01042ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01042f2:	c9                   	leave  
f01042f3:	c3                   	ret    

f01042f4 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f01042f4:	55                   	push   %ebp
f01042f5:	89 e5                	mov    %esp,%ebp
f01042f7:	83 ec 28             	sub    $0x28,%esp
f01042fa:	8b 45 10             	mov    0x10(%ebp),%eax
f01042fd:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f0104300:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104304:	74 72                	je     f0104378 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104306:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f010430d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104310:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104315:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104318:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010431b:	ba 00 00 00 00       	mov    $0x0,%edx
f0104320:	f7 75 f4             	divl   -0xc(%ebp)
f0104323:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104326:	29 d0                	sub    %edx,%eax
f0104328:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010432b:	73 2f                	jae    f010435c <pf_add_empty_env_page+0x68>
f010432d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104330:	8b 50 6c             	mov    0x6c(%eax),%edx
f0104333:	b8 00 00 00 00       	mov    $0x0,%eax
f0104338:	29 d0                	sub    %edx,%eax
f010433a:	c1 e0 0c             	shl    $0xc,%eax
f010433d:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0104342:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104345:	76 15                	jbe    f010435c <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104347:	8b 45 08             	mov    0x8(%ebp),%eax
f010434a:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104350:	8d 50 01             	lea    0x1(%eax),%edx
f0104353:	8b 45 08             	mov    0x8(%ebp),%eax
f0104356:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f010435c:	a1 1c f6 b1 f0       	mov    0xf0b1f61c,%eax
f0104361:	83 ec 04             	sub    $0x4,%esp
f0104364:	50                   	push   %eax
f0104365:	ff 75 0c             	pushl  0xc(%ebp)
f0104368:	ff 75 08             	pushl  0x8(%ebp)
f010436b:	e8 b5 00 00 00       	call   f0104425 <pf_add_env_page>
f0104370:	83 c4 10             	add    $0x10,%esp
f0104373:	e9 ab 00 00 00       	jmp    f0104423 <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104378:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010437f:	76 19                	jbe    f010439a <pf_add_empty_env_page+0xa6>
f0104381:	68 48 55 12 f0       	push   $0xf0125548
f0104386:	68 6e 55 12 f0       	push   $0xf012556e
f010438b:	68 dc 00 00 00       	push   $0xdc
f0104390:	68 b7 54 12 f0       	push   $0xf01254b7
f0104395:	e8 9f bf ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010439a:	8b 45 08             	mov    0x8(%ebp),%eax
f010439d:	83 e8 80             	sub    $0xffffff80,%eax
f01043a0:	83 ec 08             	sub    $0x8,%esp
f01043a3:	50                   	push   %eax
f01043a4:	ff 75 08             	pushl  0x8(%ebp)
f01043a7:	e8 c2 05 00 00       	call   f010496e <get_disk_page_directory>
f01043ac:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01043af:	8b 45 08             	mov    0x8(%ebp),%eax
f01043b2:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01043b8:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01043bb:	52                   	push   %edx
f01043bc:	6a 01                	push   $0x1
f01043be:	ff 75 0c             	pushl  0xc(%ebp)
f01043c1:	50                   	push   %eax
f01043c2:	e8 11 fe ff ff       	call   f01041d8 <get_disk_page_table>
f01043c7:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01043ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043cd:	8b 55 0c             	mov    0xc(%ebp),%edx
f01043d0:	c1 ea 0c             	shr    $0xc,%edx
f01043d3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01043d9:	c1 e2 02             	shl    $0x2,%edx
f01043dc:	01 d0                	add    %edx,%eax
f01043de:	8b 00                	mov    (%eax),%eax
f01043e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01043e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01043e6:	85 c0                	test   %eax,%eax
f01043e8:	75 34                	jne    f010441e <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01043ea:	83 ec 0c             	sub    $0xc,%esp
f01043ed:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01043f0:	50                   	push   %eax
f01043f1:	e8 f3 fb ff ff       	call   f0103fe9 <allocate_disk_frame>
f01043f6:	83 c4 10             	add    $0x10,%esp
f01043f9:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01043fc:	75 07                	jne    f0104405 <pf_add_empty_env_page+0x111>
f01043fe:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104403:	eb 1e                	jmp    f0104423 <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104405:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104408:	8b 55 0c             	mov    0xc(%ebp),%edx
f010440b:	c1 ea 0c             	shr    $0xc,%edx
f010440e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104414:	c1 e2 02             	shl    $0x2,%edx
f0104417:	01 c2                	add    %eax,%edx
f0104419:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010441c:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010441e:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0104423:	c9                   	leave  
f0104424:	c3                   	ret    

f0104425 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104425:	55                   	push   %ebp
f0104426:	89 e5                	mov    %esp,%ebp
f0104428:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010442b:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104432:	76 19                	jbe    f010444d <pf_add_env_page+0x28>
f0104434:	68 48 55 12 f0       	push   $0xf0125548
f0104439:	68 6e 55 12 f0       	push   $0xf012556e
f010443e:	68 f1 00 00 00       	push   $0xf1
f0104443:	68 b7 54 12 f0       	push   $0xf01254b7
f0104448:	e8 ec be ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010444d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104450:	83 e8 80             	sub    $0xffffff80,%eax
f0104453:	83 ec 08             	sub    $0x8,%esp
f0104456:	50                   	push   %eax
f0104457:	ff 75 08             	pushl  0x8(%ebp)
f010445a:	e8 0f 05 00 00       	call   f010496e <get_disk_page_directory>
f010445f:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0104462:	8b 45 08             	mov    0x8(%ebp),%eax
f0104465:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010446b:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010446e:	52                   	push   %edx
f010446f:	6a 01                	push   $0x1
f0104471:	ff 75 0c             	pushl  0xc(%ebp)
f0104474:	50                   	push   %eax
f0104475:	e8 5e fd ff ff       	call   f01041d8 <get_disk_page_table>
f010447a:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010447d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104480:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104483:	c1 ea 0c             	shr    $0xc,%edx
f0104486:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010448c:	c1 e2 02             	shl    $0x2,%edx
f010448f:	01 d0                	add    %edx,%eax
f0104491:	8b 00                	mov    (%eax),%eax
f0104493:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f0104496:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104499:	85 c0                	test   %eax,%eax
f010449b:	75 34                	jne    f01044d1 <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010449d:	83 ec 0c             	sub    $0xc,%esp
f01044a0:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01044a3:	50                   	push   %eax
f01044a4:	e8 40 fb ff ff       	call   f0103fe9 <allocate_disk_frame>
f01044a9:	83 c4 10             	add    $0x10,%esp
f01044ac:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01044af:	75 07                	jne    f01044b8 <pf_add_env_page+0x93>
f01044b1:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01044b6:	eb 31                	jmp    f01044e9 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01044b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01044bb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01044be:	c1 ea 0c             	shr    $0xc,%edx
f01044c1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044c7:	c1 e2 02             	shl    $0x2,%edx
f01044ca:	01 c2                	add    %eax,%edx
f01044cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01044cf:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01044d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01044d4:	83 ec 08             	sub    $0x8,%esp
f01044d7:	ff 75 10             	pushl  0x10(%ebp)
f01044da:	50                   	push   %eax
f01044db:	e8 5c f9 ff ff       	call   f0103e3c <write_disk_page>
f01044e0:	83 c4 10             	add    $0x10,%esp
f01044e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01044e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01044e9:	c9                   	leave  
f01044ea:	c3                   	ret    

f01044eb <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01044eb:	55                   	push   %ebp
f01044ec:	89 e5                	mov    %esp,%ebp
f01044ee:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01044f1:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01044f8:	76 19                	jbe    f0104513 <pf_update_env_page+0x28>
f01044fa:	68 48 55 12 f0       	push   $0xf0125548
f01044ff:	68 6e 55 12 f0       	push   $0xf012556e
f0104504:	68 13 01 00 00       	push   $0x113
f0104509:	68 b7 54 12 f0       	push   $0xf01254b7
f010450e:	e8 26 be ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104513:	8b 45 08             	mov    0x8(%ebp),%eax
f0104516:	83 e8 80             	sub    $0xffffff80,%eax
f0104519:	83 ec 08             	sub    $0x8,%esp
f010451c:	50                   	push   %eax
f010451d:	ff 75 08             	pushl  0x8(%ebp)
f0104520:	e8 49 04 00 00       	call   f010496e <get_disk_page_directory>
f0104525:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104528:	8b 45 08             	mov    0x8(%ebp),%eax
f010452b:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104531:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0104534:	52                   	push   %edx
f0104535:	6a 00                	push   $0x0
f0104537:	ff 75 0c             	pushl  0xc(%ebp)
f010453a:	50                   	push   %eax
f010453b:	e8 98 fc ff ff       	call   f01041d8 <get_disk_page_table>
f0104540:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0104543:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104546:	85 c0                	test   %eax,%eax
f0104548:	74 29                	je     f0104573 <pf_update_env_page+0x88>
f010454a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010454d:	85 c0                	test   %eax,%eax
f010454f:	0f 84 bf 00 00 00    	je     f0104614 <pf_update_env_page+0x129>
f0104555:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104558:	8b 55 0c             	mov    0xc(%ebp),%edx
f010455b:	c1 ea 0c             	shr    $0xc,%edx
f010455e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104564:	c1 e2 02             	shl    $0x2,%edx
f0104567:	01 d0                	add    %edx,%eax
f0104569:	8b 00                	mov    (%eax),%eax
f010456b:	85 c0                	test   %eax,%eax
f010456d:	0f 85 a1 00 00 00    	jne    f0104614 <pf_update_env_page+0x129>
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f0104573:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104576:	85 c0                	test   %eax,%eax
f0104578:	79 09                	jns    f0104583 <pf_update_env_page+0x98>
f010457a:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f0104581:	76 30                	jbe    f01045b3 <pf_update_env_page+0xc8>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f0104583:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f010458a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010458d:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104592:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104595:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104598:	ba 00 00 00 00       	mov    $0x0,%edx
f010459d:	f7 75 f4             	divl   -0xc(%ebp)
f01045a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045a3:	29 d0                	sub    %edx,%eax

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f01045a5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01045a8:	77 53                	ja     f01045fd <pf_update_env_page+0x112>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f01045aa:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f01045b1:	77 4a                	ja     f01045fd <pf_update_env_page+0x112>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, virtual_address, 0);
f01045b3:	83 ec 04             	sub    $0x4,%esp
f01045b6:	6a 00                	push   $0x0
f01045b8:	ff 75 0c             	pushl  0xc(%ebp)
f01045bb:	ff 75 08             	pushl  0x8(%ebp)
f01045be:	e8 31 fd ff ff       	call   f01042f4 <pf_add_empty_env_page>
f01045c3:	83 c4 10             	add    $0x10,%esp
f01045c6:	89 45 ec             	mov    %eax,-0x14(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01045c9:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%ebp)
f01045cd:	75 17                	jne    f01045e6 <pf_update_env_page+0xfb>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01045cf:	83 ec 04             	sub    $0x4,%esp
f01045d2:	68 84 55 12 f0       	push   $0xf0125584
f01045d7:	68 43 01 00 00       	push   $0x143
f01045dc:	68 b7 54 12 f0       	push   $0xf01254b7
f01045e1:	e8 53 bd ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01045e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01045e9:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f01045ef:	8d 50 01             	lea    0x1(%eax),%edx
f01045f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01045f5:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f01045fb:	eb 17                	jmp    f0104614 <pf_update_env_page+0x129>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f01045fd:	83 ec 04             	sub    $0x4,%esp
f0104600:	68 d0 55 12 f0       	push   $0xf01255d0
f0104605:	68 4c 01 00 00       	push   $0x14c
f010460a:	68 b7 54 12 f0       	push   $0xf01254b7
f010460f:	e8 25 bd ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104614:	8b 45 08             	mov    0x8(%ebp),%eax
f0104617:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010461d:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0104620:	52                   	push   %edx
f0104621:	6a 00                	push   $0x0
f0104623:	ff 75 0c             	pushl  0xc(%ebp)
f0104626:	50                   	push   %eax
f0104627:	e8 ac fb ff ff       	call   f01041d8 <get_disk_page_table>
f010462c:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010462f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104632:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104635:	c1 ea 0c             	shr    $0xc,%edx
f0104638:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010463e:	c1 e2 02             	shl    $0x2,%edx
f0104641:	01 d0                	add    %edx,%eax
f0104643:	8b 00                	mov    (%eax),%eax
f0104645:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//FIX'24 (el7): due to concurrency issues in 1-1 thread model, using the USER_LIMIT as a temp loc
		//				will lead to concurrency problems since it's shared among processes.
		//				Instead, use PGFLTEMP as a local temporarily page at user space for this mapping
		//				to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, (uint32)PGFLTEMP, 0);
f0104648:	8b 45 08             	mov    0x8(%ebp),%eax
f010464b:	8b 40 64             	mov    0x64(%eax),%eax
f010464e:	6a 00                	push   $0x0
f0104650:	68 00 f0 3f 00       	push   $0x3ff000
f0104655:	ff 75 10             	pushl  0x10(%ebp)
f0104658:	50                   	push   %eax
f0104659:	e8 4c 43 00 00       	call   f01089aa <map_frame>
f010465e:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN((uint32)PGFLTEMP, PAGE_SIZE));
f0104661:	c7 45 e4 00 f0 3f 00 	movl   $0x3ff000,-0x1c(%ebp)
f0104668:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010466b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104670:	83 ec 08             	sub    $0x8,%esp
f0104673:	50                   	push   %eax
f0104674:	ff 75 e8             	pushl  -0x18(%ebp)
f0104677:	e8 c0 f7 ff ff       	call   f0103e3c <write_disk_page>
f010467c:	83 c4 10             	add    $0x10,%esp
f010467f:	89 45 ec             	mov    %eax,-0x14(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104682:	8b 45 10             	mov    0x10(%ebp),%eax
f0104685:	8b 40 08             	mov    0x8(%eax),%eax
f0104688:	40                   	inc    %eax
f0104689:	8b 55 10             	mov    0x10(%ebp),%edx
f010468c:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, (uint32)PGFLTEMP);
f0104690:	8b 45 08             	mov    0x8(%ebp),%eax
f0104693:	8b 40 64             	mov    0x64(%eax),%eax
f0104696:	83 ec 08             	sub    $0x8,%esp
f0104699:	68 00 f0 3f 00       	push   $0x3ff000
f010469e:	50                   	push   %eax
f010469f:	e8 66 44 00 00       	call   f0108b0a <unmap_frame>
f01046a4:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01046a7:	8b 45 10             	mov    0x10(%ebp),%eax
f01046aa:	8b 40 08             	mov    0x8(%eax),%eax
f01046ad:	48                   	dec    %eax
f01046ae:	8b 55 10             	mov    0x10(%ebp),%edx
f01046b1:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01046b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01046b8:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01046be:	8d 50 01             	lea    0x1(%eax),%edx
f01046c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01046c4:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01046ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01046cd:	c9                   	leave  
f01046ce:	c3                   	ret    

f01046cf <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01046cf:	55                   	push   %ebp
f01046d0:	89 e5                	mov    %esp,%ebp
f01046d2:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01046d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01046d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01046db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01046de:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01046e3:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01046e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01046e9:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046ef:	85 c0                	test   %eax,%eax
f01046f1:	75 0a                	jne    f01046fd <pf_read_env_page+0x2e>
f01046f3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01046f8:	e9 93 00 00 00       	jmp    f0104790 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f01046fd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104700:	8b 45 08             	mov    0x8(%ebp),%eax
f0104703:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104709:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010470c:	51                   	push   %ecx
f010470d:	6a 00                	push   $0x0
f010470f:	52                   	push   %edx
f0104710:	50                   	push   %eax
f0104711:	e8 c2 fa ff ff       	call   f01041d8 <get_disk_page_table>
f0104716:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104719:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010471c:	85 c0                	test   %eax,%eax
f010471e:	75 07                	jne    f0104727 <pf_read_env_page+0x58>
f0104720:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104725:	eb 69                	jmp    f0104790 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104727:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010472a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010472d:	c1 ea 0c             	shr    $0xc,%edx
f0104730:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104736:	c1 e2 02             	shl    $0x2,%edx
f0104739:	01 d0                	add    %edx,%eax
f010473b:	8b 00                	mov    (%eax),%eax
f010473d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104740:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104744:	75 07                	jne    f010474d <pf_read_env_page+0x7e>
f0104746:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010474b:	eb 43                	jmp    f0104790 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010474d:	83 ec 08             	sub    $0x8,%esp
f0104750:	ff 75 0c             	pushl  0xc(%ebp)
f0104753:	ff 75 f0             	pushl  -0x10(%ebp)
f0104756:	e8 b2 f6 ff ff       	call   f0103e0d <read_disk_page>
f010475b:	83 c4 10             	add    $0x10,%esp
f010475e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104761:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104764:	8b 45 08             	mov    0x8(%ebp),%eax
f0104767:	8b 40 64             	mov    0x64(%eax),%eax
f010476a:	6a 40                	push   $0x40
f010476c:	6a 00                	push   $0x0
f010476e:	52                   	push   %edx
f010476f:	50                   	push   %eax
f0104770:	e8 34 58 00 00       	call   f0109fa9 <pt_set_page_permissions>
f0104775:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f0104778:	8b 45 08             	mov    0x8(%ebp),%eax
f010477b:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104781:	8d 50 01             	lea    0x1(%eax),%edx
f0104784:	8b 45 08             	mov    0x8(%ebp),%eax
f0104787:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010478d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104790:	c9                   	leave  
f0104791:	c3                   	ret    

f0104792 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0104792:	55                   	push   %ebp
f0104793:	89 e5                	mov    %esp,%ebp
f0104795:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104798:	8b 45 08             	mov    0x8(%ebp),%eax
f010479b:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01047a1:	85 c0                	test   %eax,%eax
f01047a3:	74 65                	je     f010480a <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01047a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01047a8:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01047ae:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01047b1:	52                   	push   %edx
f01047b2:	6a 00                	push   $0x0
f01047b4:	ff 75 0c             	pushl  0xc(%ebp)
f01047b7:	50                   	push   %eax
f01047b8:	e8 1b fa ff ff       	call   f01041d8 <get_disk_page_table>
f01047bd:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01047c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047c3:	85 c0                	test   %eax,%eax
f01047c5:	74 46                	je     f010480d <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01047c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047ca:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047cd:	c1 ea 0c             	shr    $0xc,%edx
f01047d0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01047d6:	c1 e2 02             	shl    $0x2,%edx
f01047d9:	01 d0                	add    %edx,%eax
f01047db:	8b 00                	mov    (%eax),%eax
f01047dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01047e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047e3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047e6:	c1 ea 0c             	shr    $0xc,%edx
f01047e9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01047ef:	c1 e2 02             	shl    $0x2,%edx
f01047f2:	01 d0                	add    %edx,%eax
f01047f4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01047fa:	83 ec 0c             	sub    $0xc,%esp
f01047fd:	ff 75 f4             	pushl  -0xc(%ebp)
f0104800:	e8 d2 f8 ff ff       	call   f01040d7 <free_disk_frame>
f0104805:	83 c4 10             	add    $0x10,%esp
f0104808:	eb 04                	jmp    f010480e <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010480a:	90                   	nop
f010480b:	eb 01                	jmp    f010480e <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010480d:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f010480e:	c9                   	leave  
f010480f:	c3                   	ret    

f0104810 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104810:	55                   	push   %ebp
f0104811:	89 e5                	mov    %esp,%ebp
f0104813:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104816:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010481d:	e9 c1 00 00 00       	jmp    f01048e3 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104822:	8b 45 08             	mov    0x8(%ebp),%eax
f0104825:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010482b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010482e:	c1 e2 02             	shl    $0x2,%edx
f0104831:	01 d0                	add    %edx,%eax
f0104833:	8b 00                	mov    (%eax),%eax
f0104835:	83 e0 01             	and    $0x1,%eax
f0104838:	85 c0                	test   %eax,%eax
f010483a:	0f 84 9f 00 00 00    	je     f01048df <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104840:	8b 45 08             	mov    0x8(%ebp),%eax
f0104843:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104849:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010484c:	c1 e2 02             	shl    $0x2,%edx
f010484f:	01 d0                	add    %edx,%eax
f0104851:	8b 00                	mov    (%eax),%eax
f0104853:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104858:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010485b:	83 ec 0c             	sub    $0xc,%esp
f010485e:	ff 75 ec             	pushl  -0x14(%ebp)
f0104861:	e8 ac 53 00 00       	call   f0109c12 <kheap_virtual_address>
f0104866:	83 c4 10             	add    $0x10,%esp
f0104869:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010486c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104873:	eb 3a                	jmp    f01048af <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104875:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104878:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010487f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104882:	01 d0                	add    %edx,%eax
f0104884:	8b 00                	mov    (%eax),%eax
f0104886:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f0104889:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010488c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104893:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104896:	01 d0                	add    %edx,%eax
f0104898:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f010489e:	83 ec 0c             	sub    $0xc,%esp
f01048a1:	ff 75 e4             	pushl  -0x1c(%ebp)
f01048a4:	e8 2e f8 ff ff       	call   f01040d7 <free_disk_frame>
f01048a9:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01048ac:	ff 45 f0             	incl   -0x10(%ebp)
f01048af:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01048b6:	76 bd                	jbe    f0104875 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01048b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01048bb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01048c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01048c4:	c1 e2 02             	shl    $0x2,%edx
f01048c7:	01 d0                	add    %edx,%eax
f01048c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01048cf:	83 ec 0c             	sub    $0xc,%esp
f01048d2:	ff 75 e8             	pushl  -0x18(%ebp)
f01048d5:	e8 b5 51 00 00       	call   f0109a8f <kfree>
f01048da:	83 c4 10             	add    $0x10,%esp
f01048dd:	eb 01                	jmp    f01048e0 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01048df:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01048e0:	ff 45 f4             	incl   -0xc(%ebp)
f01048e3:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01048ea:	0f 86 32 ff ff ff    	jbe    f0104822 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f01048f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01048f3:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01048f9:	83 ec 0c             	sub    $0xc,%esp
f01048fc:	50                   	push   %eax
f01048fd:	e8 8d 51 00 00       	call   f0109a8f <kfree>
f0104902:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104905:	8b 45 08             	mov    0x8(%ebp),%eax
f0104908:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010490f:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104912:	8b 45 08             	mov    0x8(%ebp),%eax
f0104915:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010491c:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f010491f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104922:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104928:	85 c0                	test   %eax,%eax
f010492a:	74 3f                	je     f010496b <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010492c:	83 ec 0c             	sub    $0xc,%esp
f010492f:	ff 75 08             	pushl  0x8(%ebp)
f0104932:	e8 14 03 00 00       	call   f0104c4b <__pf_remove_env_all_tables>
f0104937:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010493a:	8b 45 08             	mov    0x8(%ebp),%eax
f010493d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104943:	83 ec 0c             	sub    $0xc,%esp
f0104946:	50                   	push   %eax
f0104947:	e8 43 51 00 00       	call   f0109a8f <kfree>
f010494c:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f010494f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104952:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f0104959:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010495c:	8b 45 08             	mov    0x8(%ebp),%eax
f010495f:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104966:	00 00 00 
f0104969:	eb 01                	jmp    f010496c <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010496b:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010496c:	c9                   	leave  
f010496d:	c3                   	ret    

f010496e <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f010496e:	55                   	push   %ebp
f010496f:	89 e5                	mov    %esp,%ebp
f0104971:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104974:	8b 45 08             	mov    0x8(%ebp),%eax
f0104977:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010497d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104980:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104982:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104985:	8b 00                	mov    (%eax),%eax
f0104987:	85 c0                	test   %eax,%eax
f0104989:	75 5b                	jne    f01049e6 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010498b:	83 ec 0c             	sub    $0xc,%esp
f010498e:	68 00 10 00 00       	push   $0x1000
f0104993:	e8 37 4e 00 00       	call   f01097cf <kmalloc>
f0104998:	83 c4 10             	add    $0x10,%esp
f010499b:	89 c2                	mov    %eax,%edx
f010499d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049a0:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01049a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049a5:	8b 00                	mov    (%eax),%eax
f01049a7:	85 c0                	test   %eax,%eax
f01049a9:	75 07                	jne    f01049b2 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01049ab:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01049b0:	eb 39                	jmp    f01049eb <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01049b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049b5:	8b 00                	mov    (%eax),%eax
f01049b7:	83 ec 0c             	sub    $0xc,%esp
f01049ba:	50                   	push   %eax
f01049bb:	e8 f5 51 00 00       	call   f0109bb5 <kheap_physical_address>
f01049c0:	83 c4 10             	add    $0x10,%esp
f01049c3:	89 c2                	mov    %eax,%edx
f01049c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01049c8:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01049ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049d1:	8b 00                	mov    (%eax),%eax
f01049d3:	83 ec 04             	sub    $0x4,%esp
f01049d6:	68 00 10 00 00       	push   $0x1000
f01049db:	6a 00                	push   $0x0
f01049dd:	50                   	push   %eax
f01049de:	e8 6d b7 01 00       	call   f0120150 <memset>
f01049e3:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01049e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049eb:	c9                   	leave  
f01049ec:	c3                   	ret    

f01049ed <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01049ed:	55                   	push   %ebp
f01049ee:	89 e5                	mov    %esp,%ebp
f01049f0:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f01049f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f01049fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a01:	eb 7e                	jmp    f0104a81 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104a03:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a06:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104a0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a0f:	c1 e2 02             	shl    $0x2,%edx
f0104a12:	01 d0                	add    %edx,%eax
f0104a14:	8b 00                	mov    (%eax),%eax
f0104a16:	83 e0 01             	and    $0x1,%eax
f0104a19:	85 c0                	test   %eax,%eax
f0104a1b:	74 60                	je     f0104a7d <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f0104a1d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a20:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104a26:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a29:	c1 e2 02             	shl    $0x2,%edx
f0104a2c:	01 d0                	add    %edx,%eax
f0104a2e:	8b 00                	mov    (%eax),%eax
f0104a30:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104a35:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f0104a38:	83 ec 0c             	sub    $0xc,%esp
f0104a3b:	ff 75 e8             	pushl  -0x18(%ebp)
f0104a3e:	e8 cf 51 00 00       	call   f0109c12 <kheap_virtual_address>
f0104a43:	83 c4 10             	add    $0x10,%esp
f0104a46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104a49:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104a50:	eb 20                	jmp    f0104a72 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104a52:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104a55:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104a5f:	01 d0                	add    %edx,%eax
f0104a61:	8b 00                	mov    (%eax),%eax
f0104a63:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104a66:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0104a6a:	74 03                	je     f0104a6f <pf_calculate_allocated_pages+0x82>
				counter ++;
f0104a6c:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104a6f:	ff 45 ec             	incl   -0x14(%ebp)
f0104a72:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f0104a79:	76 d7                	jbe    f0104a52 <pf_calculate_allocated_pages+0x65>
f0104a7b:	eb 01                	jmp    f0104a7e <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0104a7d:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104a7e:	ff 45 f4             	incl   -0xc(%ebp)
f0104a81:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104a88:	0f 86 75 ff ff ff    	jbe    f0104a03 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0104a8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a91:	c9                   	leave  
f0104a92:	c3                   	ret    

f0104a93 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104a93:	55                   	push   %ebp
f0104a94:	89 e5                	mov    %esp,%ebp
f0104a96:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f0104a99:	83 ec 0c             	sub    $0xc,%esp
f0104a9c:	68 d0 f7 f1 f0       	push   $0xf0f1f7d0
f0104aa1:	e8 0e b5 00 00       	call   f010ffb4 <acquire_spinlock>
f0104aa6:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f0104aa9:	a1 cc f7 f1 f0       	mov    0xf0f1f7cc,%eax
f0104aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0104ab1:	83 ec 0c             	sub    $0xc,%esp
f0104ab4:	68 d0 f7 f1 f0       	push   $0xf0f1f7d0
f0104ab9:	e8 7d b5 00 00       	call   f011003b <release_spinlock>
f0104abe:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0104ac1:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0104ac4:	c9                   	leave  
f0104ac5:	c3                   	ret    

f0104ac6 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104ac6:	55                   	push   %ebp
f0104ac7:	89 e5                	mov    %esp,%ebp
f0104ac9:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0104acc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104acf:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f0104ad5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ad8:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f0104ada:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104add:	8b 00                	mov    (%eax),%eax
f0104adf:	85 c0                	test   %eax,%eax
f0104ae1:	75 5b                	jne    f0104b3e <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f0104ae3:	83 ec 0c             	sub    $0xc,%esp
f0104ae6:	68 00 10 00 00       	push   $0x1000
f0104aeb:	e8 df 4c 00 00       	call   f01097cf <kmalloc>
f0104af0:	83 c4 10             	add    $0x10,%esp
f0104af3:	89 c2                	mov    %eax,%edx
f0104af5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104af8:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f0104afa:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104afd:	8b 00                	mov    (%eax),%eax
f0104aff:	85 c0                	test   %eax,%eax
f0104b01:	75 07                	jne    f0104b0a <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104b03:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f0104b08:	eb 39                	jmp    f0104b43 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f0104b0a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b0d:	8b 00                	mov    (%eax),%eax
f0104b0f:	83 ec 0c             	sub    $0xc,%esp
f0104b12:	50                   	push   %eax
f0104b13:	e8 9d 50 00 00       	call   f0109bb5 <kheap_physical_address>
f0104b18:	83 c4 10             	add    $0x10,%esp
f0104b1b:	89 c2                	mov    %eax,%edx
f0104b1d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b20:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104b26:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b29:	8b 00                	mov    (%eax),%eax
f0104b2b:	83 ec 04             	sub    $0x4,%esp
f0104b2e:	68 00 10 00 00       	push   $0x1000
f0104b33:	6a 00                	push   $0x0
f0104b35:	50                   	push   %eax
f0104b36:	e8 15 b6 01 00       	call   f0120150 <memset>
f0104b3b:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104b3e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b43:	c9                   	leave  
f0104b44:	c3                   	ret    

f0104b45 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104b45:	55                   	push   %ebp
f0104b46:	89 e5                	mov    %esp,%ebp
f0104b48:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f0104b4b:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104b52:	76 19                	jbe    f0104b6d <__pf_write_env_table+0x28>
f0104b54:	68 48 55 12 f0       	push   $0xf0125548
f0104b59:	68 6e 55 12 f0       	push   $0xf012556e
f0104b5e:	68 96 02 00 00       	push   $0x296
f0104b63:	68 b7 54 12 f0       	push   $0xf01254b7
f0104b68:	e8 cc b7 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f0104b6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b70:	05 88 00 00 00       	add    $0x88,%eax
f0104b75:	83 ec 08             	sub    $0x8,%esp
f0104b78:	50                   	push   %eax
f0104b79:	ff 75 08             	pushl  0x8(%ebp)
f0104b7c:	e8 45 ff ff ff       	call   f0104ac6 <get_disk_table_directory>
f0104b81:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104b84:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b87:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b8d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b90:	c1 ea 16             	shr    $0x16,%edx
f0104b93:	c1 e2 02             	shl    $0x2,%edx
f0104b96:	01 d0                	add    %edx,%eax
f0104b98:	8b 00                	mov    (%eax),%eax
f0104b9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0104b9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ba0:	85 c0                	test   %eax,%eax
f0104ba2:	75 34                	jne    f0104bd8 <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0104ba4:	83 ec 0c             	sub    $0xc,%esp
f0104ba7:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0104baa:	50                   	push   %eax
f0104bab:	e8 39 f4 ff ff       	call   f0103fe9 <allocate_disk_frame>
f0104bb0:	83 c4 10             	add    $0x10,%esp
f0104bb3:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104bb6:	75 07                	jne    f0104bbf <__pf_write_env_table+0x7a>
f0104bb8:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104bbd:	eb 31                	jmp    f0104bf0 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f0104bbf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bc2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104bc8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104bcb:	c1 ea 16             	shr    $0x16,%edx
f0104bce:	c1 e2 02             	shl    $0x2,%edx
f0104bd1:	01 c2                	add    %eax,%edx
f0104bd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104bd6:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f0104bd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104bdb:	83 ec 08             	sub    $0x8,%esp
f0104bde:	ff 75 10             	pushl  0x10(%ebp)
f0104be1:	50                   	push   %eax
f0104be2:	e8 55 f2 ff ff       	call   f0103e3c <write_disk_page>
f0104be7:	83 c4 10             	add    $0x10,%esp
f0104bea:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0104bed:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104bf0:	c9                   	leave  
f0104bf1:	c3                   	ret    

f0104bf2 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104bf2:	55                   	push   %ebp
f0104bf3:	89 e5                	mov    %esp,%ebp
f0104bf5:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104bf8:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bfb:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c01:	85 c0                	test   %eax,%eax
f0104c03:	75 07                	jne    f0104c0c <__pf_read_env_table+0x1a>
f0104c05:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104c0a:	eb 3d                	jmp    f0104c49 <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104c0c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c0f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c15:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104c18:	c1 ea 16             	shr    $0x16,%edx
f0104c1b:	c1 e2 02             	shl    $0x2,%edx
f0104c1e:	01 d0                	add    %edx,%eax
f0104c20:	8b 00                	mov    (%eax),%eax
f0104c22:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104c25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104c29:	75 07                	jne    f0104c32 <__pf_read_env_table+0x40>
f0104c2b:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104c30:	eb 17                	jmp    f0104c49 <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104c32:	83 ec 08             	sub    $0x8,%esp
f0104c35:	ff 75 10             	pushl  0x10(%ebp)
f0104c38:	ff 75 f4             	pushl  -0xc(%ebp)
f0104c3b:	e8 cd f1 ff ff       	call   f0103e0d <read_disk_page>
f0104c40:	83 c4 10             	add    $0x10,%esp
f0104c43:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104c46:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104c49:	c9                   	leave  
f0104c4a:	c3                   	ret    

f0104c4b <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104c4b:	55                   	push   %ebp
f0104c4c:	89 e5                	mov    %esp,%ebp
f0104c4e:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104c51:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c54:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c5a:	85 c0                	test   %eax,%eax
f0104c5c:	74 52                	je     f0104cb0 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104c5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104c65:	eb 3e                	jmp    f0104ca5 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104c67:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c6a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c70:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c73:	c1 e2 02             	shl    $0x2,%edx
f0104c76:	01 d0                	add    %edx,%eax
f0104c78:	8b 00                	mov    (%eax),%eax
f0104c7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104c7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c80:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c86:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c89:	c1 e2 02             	shl    $0x2,%edx
f0104c8c:	01 d0                	add    %edx,%eax
f0104c8e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104c94:	83 ec 0c             	sub    $0xc,%esp
f0104c97:	ff 75 f0             	pushl  -0x10(%ebp)
f0104c9a:	e8 38 f4 ff ff       	call   f01040d7 <free_disk_frame>
f0104c9f:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ca2:	ff 45 f4             	incl   -0xc(%ebp)
f0104ca5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104cac:	76 b9                	jbe    f0104c67 <__pf_remove_env_all_tables+0x1c>
f0104cae:	eb 01                	jmp    f0104cb1 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104cb0:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104cb1:	c9                   	leave  
f0104cb2:	c3                   	ret    

f0104cb3 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104cb3:	55                   	push   %ebp
f0104cb4:	89 e5                	mov    %esp,%ebp
f0104cb6:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104cb9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104cbd:	75 10                	jne    f0104ccf <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104cbf:	83 ec 0c             	sub    $0xc,%esp
f0104cc2:	68 4c 56 12 f0       	push   $0xf012564c
f0104cc7:	e8 bf c2 ff ff       	call   f0100f8b <cprintf>
f0104ccc:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ccf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cd2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104cd8:	85 c0                	test   %eax,%eax
f0104cda:	74 43                	je     f0104d1f <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104cdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cdf:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104ce5:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104ce8:	c1 ea 16             	shr    $0x16,%edx
f0104ceb:	c1 e2 02             	shl    $0x2,%edx
f0104cee:	01 d0                	add    %edx,%eax
f0104cf0:	8b 00                	mov    (%eax),%eax
f0104cf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104cf5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cf8:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104cfe:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104d01:	c1 ea 16             	shr    $0x16,%edx
f0104d04:	c1 e2 02             	shl    $0x2,%edx
f0104d07:	01 d0                	add    %edx,%eax
f0104d09:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104d0f:	83 ec 0c             	sub    $0xc,%esp
f0104d12:	ff 75 f4             	pushl  -0xc(%ebp)
f0104d15:	e8 bd f3 ff ff       	call   f01040d7 <free_disk_frame>
f0104d1a:	83 c4 10             	add    $0x10,%esp
f0104d1d:	eb 01                	jmp    f0104d20 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104d1f:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104d20:	c9                   	leave  
f0104d21:	c3                   	ret    

f0104d22 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104d22:	55                   	push   %ebp
f0104d23:	89 e5                	mov    %esp,%ebp
f0104d25:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104d28:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104d2f:	eb 1f                	jmp    f0104d50 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104d31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d34:	83 ec 04             	sub    $0x4,%esp
f0104d37:	6a 08                	push   $0x8
f0104d39:	ff 75 08             	pushl  0x8(%ebp)
f0104d3c:	50                   	push   %eax
f0104d3d:	e8 48 bb 01 00       	call   f012088a <ide_write>
f0104d42:	83 c4 10             	add    $0x10,%esp
f0104d45:	85 c0                	test   %eax,%eax
f0104d47:	75 12                	jne    f0104d5b <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104d49:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104d50:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104d57:	7e d8                	jle    f0104d31 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104d59:	eb 01                	jmp    f0104d5c <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104d5b:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104d5c:	90                   	nop
f0104d5d:	c9                   	leave  
f0104d5e:	c3                   	ret    

f0104d5f <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104d5f:	55                   	push   %ebp
  pushl %eax
f0104d60:	50                   	push   %eax
  pushl %ebx
f0104d61:	53                   	push   %ebx
  pushl %ecx
f0104d62:	51                   	push   %ecx
  pushl %edx
f0104d63:	52                   	push   %edx
  pushl %esi
f0104d64:	56                   	push   %esi
  pushl %edi
f0104d65:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104d66:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104d6a:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104d6e:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104d70:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104d72:	5f                   	pop    %edi
  popl %esi
f0104d73:	5e                   	pop    %esi
  popl %edx
f0104d74:	5a                   	pop    %edx
  popl %ecx
f0104d75:	59                   	pop    %ecx
  popl %ebx
f0104d76:	5b                   	pop    %ebx
  popl %eax
f0104d77:	58                   	pop    %eax
  popl %ebp
f0104d78:	5d                   	pop    %ebp
  ret
f0104d79:	c3                   	ret    

f0104d7a <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104d7a:	55                   	push   %ebp
f0104d7b:	89 e5                	mov    %esp,%ebp
f0104d7d:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104d80:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d83:	0f b6 c0             	movzbl %al,%eax
f0104d86:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104d8d:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104d90:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104d93:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104d96:	ee                   	out    %al,(%dx)
f0104d97:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104d9e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104da1:	89 c2                	mov    %eax,%edx
f0104da3:	ec                   	in     (%dx),%al
f0104da4:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104da7:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104daa:	0f b6 c0             	movzbl %al,%eax
}
f0104dad:	c9                   	leave  
f0104dae:	c3                   	ret    

f0104daf <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104daf:	55                   	push   %ebp
f0104db0:	89 e5                	mov    %esp,%ebp
f0104db2:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104db5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104db8:	0f b6 c0             	movzbl %al,%eax
f0104dbb:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104dc2:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104dc5:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104dc8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104dcb:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104dcc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104dcf:	0f b6 c0             	movzbl %al,%eax
f0104dd2:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104dd9:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104ddc:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104ddf:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104de2:	ee                   	out    %al,(%dx)
}
f0104de3:	90                   	nop
f0104de4:	c9                   	leave  
f0104de5:	c3                   	ret    

f0104de6 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104de6:	55                   	push   %ebp
f0104de7:	89 e5                	mov    %esp,%ebp
f0104de9:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104dec:	c7 05 28 f7 b1 f0 00 	movl   $0x0,0xf0b1f728
f0104df3:	00 00 00 
f0104df6:	c7 05 2c f7 b1 f0 00 	movl   $0x0,0xf0b1f72c
f0104dfd:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104e00:	83 ec 08             	sub    $0x8,%esp
f0104e03:	68 ea 6e 10 f0       	push   $0xf0106eea
f0104e08:	6a 00                	push   $0x0
f0104e0a:	e8 af 97 00 00       	call   f010e5be <irq_install_handler>
f0104e0f:	83 c4 10             	add    $0x10,%esp
}
f0104e12:	90                   	nop
f0104e13:	c9                   	leave  
f0104e14:	c3                   	ret    

f0104e15 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104e15:	55                   	push   %ebp
f0104e16:	89 e5                	mov    %esp,%ebp
f0104e18:	53                   	push   %ebx
f0104e19:	83 ec 24             	sub    $0x24,%esp
f0104e1c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e1f:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104e22:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e29:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e2d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e30:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e33:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104e34:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104e38:	77 48                	ja     f0104e82 <kclock_start+0x6d>
f0104e3a:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104e41:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104e45:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e48:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e4b:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104e4c:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104e50:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104e55:	99                   	cltd   
f0104e56:	f7 fb                	idiv   %ebx
f0104e58:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104e5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104e62:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104e67:	99                   	cltd   
f0104e68:	f7 fb                	idiv   %ebx
f0104e6a:	89 c3                	mov    %eax,%ebx
f0104e6c:	89 c8                	mov    %ecx,%eax
f0104e6e:	99                   	cltd   
f0104e6f:	f7 fb                	idiv   %ebx
f0104e71:	0f b7 c0             	movzwl %ax,%eax
f0104e74:	83 ec 0c             	sub    $0xc,%esp
f0104e77:	50                   	push   %eax
f0104e78:	e8 b3 01 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0104e7d:	83 c4 10             	add    $0x10,%esp
f0104e80:	eb 13                	jmp    f0104e95 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e82:	6a 35                	push   $0x35
f0104e84:	68 70 56 12 f0       	push   $0xf0125670
f0104e89:	6a 41                	push   $0x41
f0104e8b:	68 cc 56 12 f0       	push   $0xf01256cc
f0104e90:	e8 a4 b4 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104e95:	83 ec 0c             	sub    $0xc,%esp
f0104e98:	6a 00                	push   $0x0
f0104e9a:	e8 80 24 00 00       	call   f010731f <irq_clear_mask>
f0104e9f:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104ea2:	90                   	nop
f0104ea3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104ea6:	c9                   	leave  
f0104ea7:	c3                   	ret    

f0104ea8 <kclock_stop>:

void
kclock_stop(void)
{
f0104ea8:	55                   	push   %ebp
f0104ea9:	89 e5                	mov    %esp,%ebp
f0104eab:	83 ec 18             	sub    $0x18,%esp
f0104eae:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104eb5:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104eb9:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104ebc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104ebf:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104ec0:	83 ec 0c             	sub    $0xc,%esp
f0104ec3:	6a 00                	push   $0x0
f0104ec5:	e8 e0 23 00 00       	call   f01072aa <irq_set_mask>
f0104eca:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104ecd:	90                   	nop
f0104ece:	c9                   	leave  
f0104ecf:	c3                   	ret    

f0104ed0 <kclock_resume>:

void
kclock_resume(void)
{
f0104ed0:	55                   	push   %ebp
f0104ed1:	89 e5                	mov    %esp,%ebp
f0104ed3:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ed6:	e8 f5 01 00 00       	call   f01050d0 <kclock_read_cnt0_latch>
f0104edb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104edf:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104ee4:	77 06                	ja     f0104eec <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104ee6:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104eec:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104ef0:	83 e0 01             	and    $0x1,%eax
f0104ef3:	66 85 c0             	test   %ax,%ax
f0104ef6:	74 09                	je     f0104f01 <kclock_resume+0x31>
		cnt0++;
f0104ef8:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104efc:	40                   	inc    %eax
f0104efd:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104f01:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104f08:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104f0c:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104f0f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104f12:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104f13:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104f17:	83 ec 0c             	sub    $0xc,%esp
f0104f1a:	50                   	push   %eax
f0104f1b:	e8 10 01 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0104f20:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104f23:	83 ec 0c             	sub    $0xc,%esp
f0104f26:	6a 00                	push   $0x0
f0104f28:	e8 f2 23 00 00       	call   f010731f <irq_clear_mask>
f0104f2d:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104f30:	90                   	nop
f0104f31:	c9                   	leave  
f0104f32:	c3                   	ret    

f0104f33 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104f33:	55                   	push   %ebp
f0104f34:	89 e5                	mov    %esp,%ebp
f0104f36:	83 ec 28             	sub    $0x28,%esp
f0104f39:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f3c:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104f3f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f46:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104f4a:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104f4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f50:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104f51:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104f55:	83 ec 0c             	sub    $0xc,%esp
f0104f58:	50                   	push   %eax
f0104f59:	e8 d2 00 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0104f5e:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104f61:	83 ec 0c             	sub    $0xc,%esp
f0104f64:	6a 00                	push   $0x0
f0104f66:	e8 b4 23 00 00       	call   f010731f <irq_clear_mask>
f0104f6b:	83 c4 10             	add    $0x10,%esp
}
f0104f6e:	90                   	nop
f0104f6f:	c9                   	leave  
f0104f70:	c3                   	ret    

f0104f71 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104f71:	55                   	push   %ebp
f0104f72:	89 e5                	mov    %esp,%ebp
f0104f74:	56                   	push   %esi
f0104f75:	53                   	push   %ebx
f0104f76:	83 ec 20             	sub    $0x20,%esp
f0104f79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7c:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104f7f:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104f83:	0f 87 8a 00 00 00    	ja     f0105013 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104f89:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104f8d:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104f92:	99                   	cltd   
f0104f93:	f7 fe                	idiv   %esi
f0104f95:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104f9b:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104f9f:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104fa4:	99                   	cltd   
f0104fa5:	f7 fb                	idiv   %ebx
f0104fa7:	89 c6                	mov    %eax,%esi
f0104fa9:	89 c8                	mov    %ecx,%eax
f0104fab:	99                   	cltd   
f0104fac:	f7 fe                	idiv   %esi
f0104fae:	89 c3                	mov    %eax,%ebx
f0104fb0:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104fb4:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104fb9:	99                   	cltd   
f0104fba:	f7 f9                	idiv   %ecx
f0104fbc:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104fc2:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104fc6:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104fcb:	99                   	cltd   
f0104fcc:	f7 fe                	idiv   %esi
f0104fce:	89 c6                	mov    %eax,%esi
f0104fd0:	89 c8                	mov    %ecx,%eax
f0104fd2:	99                   	cltd   
f0104fd3:	f7 fe                	idiv   %esi
f0104fd5:	25 01 00 00 80       	and    $0x80000001,%eax
f0104fda:	85 c0                	test   %eax,%eax
f0104fdc:	79 05                	jns    f0104fe3 <kclock_set_quantum+0x72>
f0104fde:	48                   	dec    %eax
f0104fdf:	83 c8 fe             	or     $0xfffffffe,%eax
f0104fe2:	40                   	inc    %eax
f0104fe3:	01 d8                	add    %ebx,%eax
f0104fe5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104fe8:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104fef:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104ff3:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104ff6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104ff9:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ffd:	0f b7 c0             	movzwl %ax,%eax
f0105000:	83 ec 0c             	sub    $0xc,%esp
f0105003:	50                   	push   %eax
f0105004:	e8 27 00 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0105009:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f010500c:	e8 97 fe ff ff       	call   f0104ea8 <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0105011:	eb 16                	jmp    f0105029 <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105013:	6a 35                	push   $0x35
f0105015:	68 70 56 12 f0       	push   $0xf0125670
f010501a:	68 ea 00 00 00       	push   $0xea
f010501f:	68 cc 56 12 f0       	push   $0xf01256cc
f0105024:	e8 10 b3 ff ff       	call   f0100339 <_panic>
	}
}
f0105029:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010502c:	5b                   	pop    %ebx
f010502d:	5e                   	pop    %esi
f010502e:	5d                   	pop    %ebp
f010502f:	c3                   	ret    

f0105030 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0105030:	55                   	push   %ebp
f0105031:	89 e5                	mov    %esp,%ebp
f0105033:	83 ec 28             	sub    $0x28,%esp
f0105036:	8b 45 08             	mov    0x8(%ebp),%eax
f0105039:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f010503d:	e8 b8 24 00 00       	call   f01074fa <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0105042:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105045:	0f b6 c0             	movzbl %al,%eax
f0105048:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f010504f:	88 45 ee             	mov    %al,-0x12(%ebp)
f0105052:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105055:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105058:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0105059:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010505c:	66 c1 e8 08          	shr    $0x8,%ax
f0105060:	0f b6 c0             	movzbl %al,%eax
f0105063:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f010506a:	88 45 ef             	mov    %al,-0x11(%ebp)
f010506d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105070:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105073:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0105074:	e8 d3 24 00 00       	call   f010754c <popcli>

}
f0105079:	90                   	nop
f010507a:	c9                   	leave  
f010507b:	c3                   	ret    

f010507c <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f010507c:	55                   	push   %ebp
f010507d:	89 e5                	mov    %esp,%ebp
f010507f:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0105082:	e8 73 24 00 00       	call   f01074fa <pushcli>
f0105087:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010508e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105091:	89 c2                	mov    %eax,%edx
f0105093:	ec                   	in     (%dx),%al
f0105094:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0105097:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f010509a:	88 45 f7             	mov    %al,-0x9(%ebp)
f010509d:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01050a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01050a7:	89 c2                	mov    %eax,%edx
f01050a9:	ec                   	in     (%dx),%al
f01050aa:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f01050ad:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f01050b0:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f01050b3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01050b7:	c1 e0 08             	shl    $0x8,%eax
f01050ba:	89 c2                	mov    %eax,%edx
f01050bc:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01050c0:	09 d0                	or     %edx,%eax
f01050c2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f01050c6:	e8 81 24 00 00       	call   f010754c <popcli>
	return cnt0 ;
f01050cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01050ce:	c9                   	leave  
f01050cf:	c3                   	ret    

f01050d0 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f01050d0:	55                   	push   %ebp
f01050d1:	89 e5                	mov    %esp,%ebp
f01050d3:	83 ec 30             	sub    $0x30,%esp
f01050d6:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01050dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01050e0:	89 c2                	mov    %eax,%edx
f01050e2:	ec                   	in     (%dx),%al
f01050e3:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f01050e6:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f01050e9:	88 45 ff             	mov    %al,-0x1(%ebp)
f01050ec:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f01050f3:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01050f7:	8a 45 dc             	mov    -0x24(%ebp),%al
f01050fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050fd:	ee                   	out    %al,(%dx)
f01050fe:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105105:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105108:	89 c2                	mov    %eax,%edx
f010510a:	ec                   	in     (%dx),%al
f010510b:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f010510e:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105111:	88 45 f3             	mov    %al,-0xd(%ebp)
f0105114:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010511b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010511e:	89 c2                	mov    %eax,%edx
f0105120:	ec                   	in     (%dx),%al
f0105121:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0105124:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105127:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f010512a:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f010512e:	c1 e0 08             	shl    $0x8,%eax
f0105131:	89 c2                	mov    %eax,%edx
f0105133:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0105137:	09 d0                	or     %edx,%eax
f0105139:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f010513d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105141:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0105148:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010514b:	8a 45 df             	mov    -0x21(%ebp),%al
f010514e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105151:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0105152:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0105155:	c9                   	leave  
f0105156:	c3                   	ret    

f0105157 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0105157:	55                   	push   %ebp
f0105158:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f010515a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010515e:	74 1d                	je     f010517d <init_queue+0x26>
	{
		LIST_INIT(queue);
f0105160:	8b 45 08             	mov    0x8(%ebp),%eax
f0105163:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105169:	8b 45 08             	mov    0x8(%ebp),%eax
f010516c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105173:	8b 45 08             	mov    0x8(%ebp),%eax
f0105176:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f010517d:	90                   	nop
f010517e:	5d                   	pop    %ebp
f010517f:	c3                   	ret    

f0105180 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0105180:	55                   	push   %ebp
f0105181:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105183:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105187:	74 08                	je     f0105191 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0105189:	8b 45 08             	mov    0x8(%ebp),%eax
f010518c:	8b 40 0c             	mov    0xc(%eax),%eax
f010518f:	eb 05                	jmp    f0105196 <queue_size+0x16>
	}
	else
	{
		return 0;
f0105191:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0105196:	5d                   	pop    %ebp
f0105197:	c3                   	ret    

f0105198 <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0105198:	55                   	push   %ebp
f0105199:	89 e5                	mov    %esp,%ebp
f010519b:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010519e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051a2:	75 16                	jne    f01051ba <enqueue+0x22>
f01051a4:	68 e0 56 12 f0       	push   $0xf01256e0
f01051a9:	68 ee 56 12 f0       	push   $0xf01256ee
f01051ae:	6a 34                	push   $0x34
f01051b0:	68 03 57 12 f0       	push   $0xf0125703
f01051b5:	e8 7f b1 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f01051ba:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01051be:	74 66                	je     f0105226 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f01051c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01051c4:	75 14                	jne    f01051da <enqueue+0x42>
f01051c6:	83 ec 04             	sub    $0x4,%esp
f01051c9:	68 1c 57 12 f0       	push   $0xf012571c
f01051ce:	6a 37                	push   $0x37
f01051d0:	68 03 57 12 f0       	push   $0xf0125703
f01051d5:	e8 5f b1 ff ff       	call   f0100339 <_panic>
f01051da:	8b 45 08             	mov    0x8(%ebp),%eax
f01051dd:	8b 10                	mov    (%eax),%edx
f01051df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051e2:	89 50 08             	mov    %edx,0x8(%eax)
f01051e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051e8:	8b 40 08             	mov    0x8(%eax),%eax
f01051eb:	85 c0                	test   %eax,%eax
f01051ed:	74 0d                	je     f01051fc <enqueue+0x64>
f01051ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01051f2:	8b 00                	mov    (%eax),%eax
f01051f4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01051f7:	89 50 0c             	mov    %edx,0xc(%eax)
f01051fa:	eb 09                	jmp    f0105205 <enqueue+0x6d>
f01051fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01051ff:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105202:	89 50 04             	mov    %edx,0x4(%eax)
f0105205:	8b 45 08             	mov    0x8(%ebp),%eax
f0105208:	8b 55 0c             	mov    0xc(%ebp),%edx
f010520b:	89 10                	mov    %edx,(%eax)
f010520d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105210:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105217:	8b 45 08             	mov    0x8(%ebp),%eax
f010521a:	8b 40 0c             	mov    0xc(%eax),%eax
f010521d:	8d 50 01             	lea    0x1(%eax),%edx
f0105220:	8b 45 08             	mov    0x8(%ebp),%eax
f0105223:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105226:	90                   	nop
f0105227:	c9                   	leave  
f0105228:	c3                   	ret    

f0105229 <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0105229:	55                   	push   %ebp
f010522a:	89 e5                	mov    %esp,%ebp
f010522c:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f010522f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105233:	75 0a                	jne    f010523f <dequeue+0x16>
f0105235:	b8 00 00 00 00       	mov    $0x0,%eax
f010523a:	e9 a0 00 00 00       	jmp    f01052df <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f010523f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105242:	8b 40 04             	mov    0x4(%eax),%eax
f0105245:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0105248:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010524c:	0f 84 8a 00 00 00    	je     f01052dc <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105252:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105256:	75 14                	jne    f010526c <dequeue+0x43>
f0105258:	83 ec 04             	sub    $0x4,%esp
f010525b:	68 3f 57 12 f0       	push   $0xf012573f
f0105260:	6a 44                	push   $0x44
f0105262:	68 03 57 12 f0       	push   $0xf0125703
f0105267:	e8 cd b0 ff ff       	call   f0100339 <_panic>
f010526c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010526f:	8b 40 08             	mov    0x8(%eax),%eax
f0105272:	85 c0                	test   %eax,%eax
f0105274:	74 11                	je     f0105287 <dequeue+0x5e>
f0105276:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105279:	8b 40 08             	mov    0x8(%eax),%eax
f010527c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010527f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105282:	89 50 0c             	mov    %edx,0xc(%eax)
f0105285:	eb 0c                	jmp    f0105293 <dequeue+0x6a>
f0105287:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010528a:	8b 50 0c             	mov    0xc(%eax),%edx
f010528d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105290:	89 50 04             	mov    %edx,0x4(%eax)
f0105293:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105296:	8b 40 0c             	mov    0xc(%eax),%eax
f0105299:	85 c0                	test   %eax,%eax
f010529b:	74 11                	je     f01052ae <dequeue+0x85>
f010529d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052a0:	8b 40 0c             	mov    0xc(%eax),%eax
f01052a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01052a6:	8b 52 08             	mov    0x8(%edx),%edx
f01052a9:	89 50 08             	mov    %edx,0x8(%eax)
f01052ac:	eb 0b                	jmp    f01052b9 <dequeue+0x90>
f01052ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052b1:	8b 50 08             	mov    0x8(%eax),%edx
f01052b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01052b7:	89 10                	mov    %edx,(%eax)
f01052b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052bc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01052c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052c6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01052cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01052d0:	8b 40 0c             	mov    0xc(%eax),%eax
f01052d3:	8d 50 ff             	lea    -0x1(%eax),%edx
f01052d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052d9:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01052dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01052df:	c9                   	leave  
f01052e0:	c3                   	ret    

f01052e1 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01052e1:	55                   	push   %ebp
f01052e2:	89 e5                	mov    %esp,%ebp
f01052e4:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01052e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052eb:	75 16                	jne    f0105303 <remove_from_queue+0x22>
f01052ed:	68 e0 56 12 f0       	push   $0xf01256e0
f01052f2:	68 ee 56 12 f0       	push   $0xf01256ee
f01052f7:	6a 4e                	push   $0x4e
f01052f9:	68 03 57 12 f0       	push   $0xf0125703
f01052fe:	e8 36 b0 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105303:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105307:	0f 84 8a 00 00 00    	je     f0105397 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010530d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105311:	75 14                	jne    f0105327 <remove_from_queue+0x46>
f0105313:	83 ec 04             	sub    $0x4,%esp
f0105316:	68 3f 57 12 f0       	push   $0xf012573f
f010531b:	6a 52                	push   $0x52
f010531d:	68 03 57 12 f0       	push   $0xf0125703
f0105322:	e8 12 b0 ff ff       	call   f0100339 <_panic>
f0105327:	8b 45 0c             	mov    0xc(%ebp),%eax
f010532a:	8b 40 08             	mov    0x8(%eax),%eax
f010532d:	85 c0                	test   %eax,%eax
f010532f:	74 11                	je     f0105342 <remove_from_queue+0x61>
f0105331:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105334:	8b 40 08             	mov    0x8(%eax),%eax
f0105337:	8b 55 0c             	mov    0xc(%ebp),%edx
f010533a:	8b 52 0c             	mov    0xc(%edx),%edx
f010533d:	89 50 0c             	mov    %edx,0xc(%eax)
f0105340:	eb 0c                	jmp    f010534e <remove_from_queue+0x6d>
f0105342:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105345:	8b 50 0c             	mov    0xc(%eax),%edx
f0105348:	8b 45 08             	mov    0x8(%ebp),%eax
f010534b:	89 50 04             	mov    %edx,0x4(%eax)
f010534e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105351:	8b 40 0c             	mov    0xc(%eax),%eax
f0105354:	85 c0                	test   %eax,%eax
f0105356:	74 11                	je     f0105369 <remove_from_queue+0x88>
f0105358:	8b 45 0c             	mov    0xc(%ebp),%eax
f010535b:	8b 40 0c             	mov    0xc(%eax),%eax
f010535e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105361:	8b 52 08             	mov    0x8(%edx),%edx
f0105364:	89 50 08             	mov    %edx,0x8(%eax)
f0105367:	eb 0b                	jmp    f0105374 <remove_from_queue+0x93>
f0105369:	8b 45 0c             	mov    0xc(%ebp),%eax
f010536c:	8b 50 08             	mov    0x8(%eax),%edx
f010536f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105372:	89 10                	mov    %edx,(%eax)
f0105374:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105377:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010537e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105381:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105388:	8b 45 08             	mov    0x8(%ebp),%eax
f010538b:	8b 40 0c             	mov    0xc(%eax),%eax
f010538e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105391:	8b 45 08             	mov    0x8(%ebp),%eax
f0105394:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105397:	90                   	nop
f0105398:	c9                   	leave  
f0105399:	c3                   	ret    

f010539a <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010539a:	55                   	push   %ebp
f010539b:	89 e5                	mov    %esp,%ebp
f010539d:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01053a0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01053a4:	75 07                	jne    f01053ad <find_env_in_queue+0x13>
f01053a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01053ab:	eb 58                	jmp    f0105405 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01053ad:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01053b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053b7:	8b 00                	mov    (%eax),%eax
f01053b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01053bc:	eb 19                	jmp    f01053d7 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01053be:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053c1:	8b 40 10             	mov    0x10(%eax),%eax
f01053c4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01053c7:	75 05                	jne    f01053ce <find_env_in_queue+0x34>
		{
			return ptr_env;
f01053c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053cc:	eb 37                	jmp    f0105405 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01053ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d1:	8b 40 08             	mov    0x8(%eax),%eax
f01053d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01053d7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01053db:	74 08                	je     f01053e5 <find_env_in_queue+0x4b>
f01053dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053e0:	8b 40 08             	mov    0x8(%eax),%eax
f01053e3:	eb 05                	jmp    f01053ea <find_env_in_queue+0x50>
f01053e5:	b8 00 00 00 00       	mov    $0x0,%eax
f01053ea:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ed:	89 42 08             	mov    %eax,0x8(%edx)
f01053f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f3:	8b 40 08             	mov    0x8(%eax),%eax
f01053f6:	85 c0                	test   %eax,%eax
f01053f8:	75 c4                	jne    f01053be <find_env_in_queue+0x24>
f01053fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01053fe:	75 be                	jne    f01053be <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105400:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105405:	c9                   	leave  
f0105406:	c3                   	ret    

f0105407 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105407:	55                   	push   %ebp
f0105408:	89 e5                	mov    %esp,%ebp
f010540a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010540d:	83 ec 0c             	sub    $0xc,%esp
f0105410:	68 80 f0 71 f0       	push   $0xf071f080
f0105415:	e8 9a ab 00 00       	call   f010ffb4 <acquire_spinlock>
f010541a:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010541d:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105422:	85 c0                	test   %eax,%eax
f0105424:	74 11                	je     f0105437 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105426:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010542b:	83 ec 0c             	sub    $0xc,%esp
f010542e:	50                   	push   %eax
f010542f:	e8 5b 46 00 00       	call   f0109a8f <kfree>
f0105434:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105437:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f010543c:	85 c0                	test   %eax,%eax
f010543e:	74 11                	je     f0105451 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105440:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0105445:	83 ec 0c             	sub    $0xc,%esp
f0105448:	50                   	push   %eax
f0105449:	e8 41 46 00 00       	call   f0109a8f <kfree>
f010544e:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105451:	83 ec 0c             	sub    $0xc,%esp
f0105454:	68 80 f0 71 f0       	push   $0xf071f080
f0105459:	e8 dd ab 00 00       	call   f011003b <release_spinlock>
f010545e:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105461:	90                   	nop
f0105462:	c9                   	leave  
f0105463:	c3                   	ret    

f0105464 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105464:	55                   	push   %ebp
f0105465:	89 e5                	mov    %esp,%ebp
f0105467:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010546a:	83 ec 0c             	sub    $0xc,%esp
f010546d:	68 80 f0 71 f0       	push   $0xf071f080
f0105472:	e8 56 ad 00 00       	call   f01101cd <holding_spinlock>
f0105477:	83 c4 10             	add    $0x10,%esp
f010547a:	85 c0                	test   %eax,%eax
f010547c:	75 17                	jne    f0105495 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010547e:	83 ec 04             	sub    $0x4,%esp
f0105481:	68 60 57 12 f0       	push   $0xf0125760
f0105486:	68 85 00 00 00       	push   $0x85
f010548b:	68 03 57 12 f0       	push   $0xf0125703
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105495:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105499:	75 19                	jne    f01054b4 <sched_insert_ready0+0x50>
f010549b:	68 a1 57 12 f0       	push   $0xf01257a1
f01054a0:	68 ee 56 12 f0       	push   $0xf01256ee
f01054a5:	68 88 00 00 00       	push   $0x88
f01054aa:	68 03 57 12 f0       	push   $0xf0125703
f01054af:	e8 85 ae ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01054b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01054b7:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01054be:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01054c3:	83 ec 08             	sub    $0x8,%esp
f01054c6:	ff 75 08             	pushl  0x8(%ebp)
f01054c9:	50                   	push   %eax
f01054ca:	e8 c9 fc ff ff       	call   f0105198 <enqueue>
f01054cf:	83 c4 10             	add    $0x10,%esp
	}
}
f01054d2:	90                   	nop
f01054d3:	c9                   	leave  
f01054d4:	c3                   	ret    

f01054d5 <sched_insert_ready>:

//============================================================
// [2] Insert the given Env in the priority-based Ready Queue:
//============================================================
void sched_insert_ready(struct Env* env)
{
f01054d5:	55                   	push   %ebp
f01054d6:	89 e5                	mov    %esp,%ebp
f01054d8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054db:	83 ec 0c             	sub    $0xc,%esp
f01054de:	68 80 f0 71 f0       	push   $0xf071f080
f01054e3:	e8 e5 ac 00 00       	call   f01101cd <holding_spinlock>
f01054e8:	83 c4 10             	add    $0x10,%esp
f01054eb:	85 c0                	test   %eax,%eax
f01054ed:	75 17                	jne    f0105506 <sched_insert_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054ef:	83 ec 04             	sub    $0x4,%esp
f01054f2:	68 60 57 12 f0       	push   $0xf0125760
f01054f7:	68 97 00 00 00       	push   $0x97
f01054fc:	68 03 57 12 f0       	push   $0xf0125703
f0105501:	e8 33 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105506:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010550a:	75 19                	jne    f0105525 <sched_insert_ready+0x50>
f010550c:	68 a1 57 12 f0       	push   $0xf01257a1
f0105511:	68 ee 56 12 f0       	push   $0xf01256ee
f0105516:	68 9a 00 00 00       	push   $0x9a
f010551b:	68 03 57 12 f0       	push   $0xf0125703
f0105520:	e8 14 ae ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0105525:	8b 45 08             	mov    0x8(%ebp),%eax
f0105528:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[env->priority]), env);
f010552f:	8b 15 10 f1 71 f0    	mov    0xf071f110,%edx
f0105535:	8b 45 08             	mov    0x8(%ebp),%eax
f0105538:	8b 40 1c             	mov    0x1c(%eax),%eax
f010553b:	c1 e0 04             	shl    $0x4,%eax
f010553e:	01 d0                	add    %edx,%eax
f0105540:	83 ec 08             	sub    $0x8,%esp
f0105543:	ff 75 08             	pushl  0x8(%ebp)
f0105546:	50                   	push   %eax
f0105547:	e8 4c fc ff ff       	call   f0105198 <enqueue>
f010554c:	83 c4 10             	add    $0x10,%esp
	}
}
f010554f:	90                   	nop
f0105550:	c9                   	leave  
f0105551:	c3                   	ret    

f0105552 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0105552:	55                   	push   %ebp
f0105553:	89 e5                	mov    %esp,%ebp
f0105555:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105558:	83 ec 0c             	sub    $0xc,%esp
f010555b:	68 80 f0 71 f0       	push   $0xf071f080
f0105560:	e8 68 ac 00 00       	call   f01101cd <holding_spinlock>
f0105565:	83 c4 10             	add    $0x10,%esp
f0105568:	85 c0                	test   %eax,%eax
f010556a:	75 17                	jne    f0105583 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010556c:	83 ec 04             	sub    $0x4,%esp
f010556f:	68 60 57 12 f0       	push   $0xf0125760
f0105574:	68 a9 00 00 00       	push   $0xa9
f0105579:	68 03 57 12 f0       	push   $0xf0125703
f010557e:	e8 b6 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105583:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105587:	74 0b                	je     f0105594 <sched_remove_ready+0x42>
f0105589:	8b 45 08             	mov    0x8(%ebp),%eax
f010558c:	8b 40 18             	mov    0x18(%eax),%eax
f010558f:	83 f8 01             	cmp    $0x1,%eax
f0105592:	74 19                	je     f01055ad <sched_remove_ready+0x5b>
f0105594:	68 b0 57 12 f0       	push   $0xf01257b0
f0105599:	68 ee 56 12 f0       	push   $0xf01256ee
f010559e:	68 ac 00 00 00       	push   $0xac
f01055a3:	68 03 57 12 f0       	push   $0xf0125703
f01055a8:	e8 8c ad ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01055ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01055b4:	e9 e4 00 00 00       	jmp    f010569d <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01055b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01055bc:	8b 40 10             	mov    0x10(%eax),%eax
f01055bf:	89 c2                	mov    %eax,%edx
f01055c1:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01055c6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01055c9:	c1 e1 04             	shl    $0x4,%ecx
f01055cc:	01 c8                	add    %ecx,%eax
f01055ce:	83 ec 08             	sub    $0x8,%esp
f01055d1:	52                   	push   %edx
f01055d2:	50                   	push   %eax
f01055d3:	e8 c2 fd ff ff       	call   f010539a <find_env_in_queue>
f01055d8:	83 c4 10             	add    $0x10,%esp
f01055db:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01055de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01055e2:	0f 84 b2 00 00 00    	je     f010569a <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01055e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055ec:	75 17                	jne    f0105605 <sched_remove_ready+0xb3>
f01055ee:	83 ec 04             	sub    $0x4,%esp
f01055f1:	68 3f 57 12 f0       	push   $0xf012573f
f01055f6:	68 b3 00 00 00       	push   $0xb3
f01055fb:	68 03 57 12 f0       	push   $0xf0125703
f0105600:	e8 34 ad ff ff       	call   f0100339 <_panic>
f0105605:	8b 45 08             	mov    0x8(%ebp),%eax
f0105608:	8b 40 08             	mov    0x8(%eax),%eax
f010560b:	85 c0                	test   %eax,%eax
f010560d:	74 11                	je     f0105620 <sched_remove_ready+0xce>
f010560f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105612:	8b 40 08             	mov    0x8(%eax),%eax
f0105615:	8b 55 08             	mov    0x8(%ebp),%edx
f0105618:	8b 52 0c             	mov    0xc(%edx),%edx
f010561b:	89 50 0c             	mov    %edx,0xc(%eax)
f010561e:	eb 16                	jmp    f0105636 <sched_remove_ready+0xe4>
f0105620:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105625:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105628:	c1 e2 04             	shl    $0x4,%edx
f010562b:	01 c2                	add    %eax,%edx
f010562d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105630:	8b 40 0c             	mov    0xc(%eax),%eax
f0105633:	89 42 04             	mov    %eax,0x4(%edx)
f0105636:	8b 45 08             	mov    0x8(%ebp),%eax
f0105639:	8b 40 0c             	mov    0xc(%eax),%eax
f010563c:	85 c0                	test   %eax,%eax
f010563e:	74 11                	je     f0105651 <sched_remove_ready+0xff>
f0105640:	8b 45 08             	mov    0x8(%ebp),%eax
f0105643:	8b 40 0c             	mov    0xc(%eax),%eax
f0105646:	8b 55 08             	mov    0x8(%ebp),%edx
f0105649:	8b 52 08             	mov    0x8(%edx),%edx
f010564c:	89 50 08             	mov    %edx,0x8(%eax)
f010564f:	eb 15                	jmp    f0105666 <sched_remove_ready+0x114>
f0105651:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105656:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105659:	c1 e2 04             	shl    $0x4,%edx
f010565c:	01 c2                	add    %eax,%edx
f010565e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105661:	8b 40 08             	mov    0x8(%eax),%eax
f0105664:	89 02                	mov    %eax,(%edx)
f0105666:	8b 45 08             	mov    0x8(%ebp),%eax
f0105669:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105670:	8b 45 08             	mov    0x8(%ebp),%eax
f0105673:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010567a:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010567f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105682:	c1 e2 04             	shl    $0x4,%edx
f0105685:	01 d0                	add    %edx,%eax
f0105687:	8b 50 0c             	mov    0xc(%eax),%edx
f010568a:	4a                   	dec    %edx
f010568b:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f010568e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105691:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f0105698:	eb 14                	jmp    f01056ae <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010569a:	ff 45 f4             	incl   -0xc(%ebp)
f010569d:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f01056a2:	0f b6 c0             	movzbl %al,%eax
f01056a5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01056a8:	0f 8f 0b ff ff ff    	jg     f01055b9 <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01056ae:	c9                   	leave  
f01056af:	c3                   	ret    

f01056b0 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01056b0:	55                   	push   %ebp
f01056b1:	89 e5                	mov    %esp,%ebp
f01056b3:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01056b6:	83 ec 0c             	sub    $0xc,%esp
f01056b9:	68 80 f0 71 f0       	push   $0xf071f080
f01056be:	e8 0a ab 00 00       	call   f01101cd <holding_spinlock>
f01056c3:	83 c4 10             	add    $0x10,%esp
f01056c6:	85 c0                	test   %eax,%eax
f01056c8:	75 17                	jne    f01056e1 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01056ca:	83 ec 04             	sub    $0x4,%esp
f01056cd:	68 60 57 12 f0       	push   $0xf0125760
f01056d2:	68 c2 00 00 00       	push   $0xc2
f01056d7:	68 03 57 12 f0       	push   $0xf0125703
f01056dc:	e8 58 ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01056e1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01056e5:	75 19                	jne    f0105700 <sched_insert_new+0x50>
f01056e7:	68 a1 57 12 f0       	push   $0xf01257a1
f01056ec:	68 ee 56 12 f0       	push   $0xf01256ee
f01056f1:	68 c5 00 00 00       	push   $0xc5
f01056f6:	68 03 57 12 f0       	push   $0xf0125703
f01056fb:	e8 39 ac ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105700:	8b 45 08             	mov    0x8(%ebp),%eax
f0105703:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010570a:	83 ec 08             	sub    $0x8,%esp
f010570d:	ff 75 08             	pushl  0x8(%ebp)
f0105710:	68 f0 f0 71 f0       	push   $0xf071f0f0
f0105715:	e8 7e fa ff ff       	call   f0105198 <enqueue>
f010571a:	83 c4 10             	add    $0x10,%esp
	}
}
f010571d:	90                   	nop
f010571e:	c9                   	leave  
f010571f:	c3                   	ret    

f0105720 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0105720:	55                   	push   %ebp
f0105721:	89 e5                	mov    %esp,%ebp
f0105723:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105726:	83 ec 0c             	sub    $0xc,%esp
f0105729:	68 80 f0 71 f0       	push   $0xf071f080
f010572e:	e8 9a aa 00 00       	call   f01101cd <holding_spinlock>
f0105733:	83 c4 10             	add    $0x10,%esp
f0105736:	85 c0                	test   %eax,%eax
f0105738:	75 17                	jne    f0105751 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010573a:	83 ec 04             	sub    $0x4,%esp
f010573d:	68 60 57 12 f0       	push   $0xf0125760
f0105742:	68 d3 00 00 00       	push   $0xd3
f0105747:	68 03 57 12 f0       	push   $0xf0125703
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0105751:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105755:	74 0b                	je     f0105762 <sched_remove_new+0x42>
f0105757:	8b 45 08             	mov    0x8(%ebp),%eax
f010575a:	8b 40 18             	mov    0x18(%eax),%eax
f010575d:	83 f8 04             	cmp    $0x4,%eax
f0105760:	74 19                	je     f010577b <sched_remove_new+0x5b>
f0105762:	68 dc 57 12 f0       	push   $0xf01257dc
f0105767:	68 ee 56 12 f0       	push   $0xf01256ee
f010576c:	68 d6 00 00 00       	push   $0xd6
f0105771:	68 03 57 12 f0       	push   $0xf0125703
f0105776:	e8 be ab ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f010577b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010577f:	75 17                	jne    f0105798 <sched_remove_new+0x78>
f0105781:	83 ec 04             	sub    $0x4,%esp
f0105784:	68 3f 57 12 f0       	push   $0xf012573f
f0105789:	68 d8 00 00 00       	push   $0xd8
f010578e:	68 03 57 12 f0       	push   $0xf0125703
f0105793:	e8 a1 ab ff ff       	call   f0100339 <_panic>
f0105798:	8b 45 08             	mov    0x8(%ebp),%eax
f010579b:	8b 40 08             	mov    0x8(%eax),%eax
f010579e:	85 c0                	test   %eax,%eax
f01057a0:	74 11                	je     f01057b3 <sched_remove_new+0x93>
f01057a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01057a5:	8b 40 08             	mov    0x8(%eax),%eax
f01057a8:	8b 55 08             	mov    0x8(%ebp),%edx
f01057ab:	8b 52 0c             	mov    0xc(%edx),%edx
f01057ae:	89 50 0c             	mov    %edx,0xc(%eax)
f01057b1:	eb 0b                	jmp    f01057be <sched_remove_new+0x9e>
f01057b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01057b6:	8b 40 0c             	mov    0xc(%eax),%eax
f01057b9:	a3 f4 f0 71 f0       	mov    %eax,0xf071f0f4
f01057be:	8b 45 08             	mov    0x8(%ebp),%eax
f01057c1:	8b 40 0c             	mov    0xc(%eax),%eax
f01057c4:	85 c0                	test   %eax,%eax
f01057c6:	74 11                	je     f01057d9 <sched_remove_new+0xb9>
f01057c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01057cb:	8b 40 0c             	mov    0xc(%eax),%eax
f01057ce:	8b 55 08             	mov    0x8(%ebp),%edx
f01057d1:	8b 52 08             	mov    0x8(%edx),%edx
f01057d4:	89 50 08             	mov    %edx,0x8(%eax)
f01057d7:	eb 0b                	jmp    f01057e4 <sched_remove_new+0xc4>
f01057d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01057dc:	8b 40 08             	mov    0x8(%eax),%eax
f01057df:	a3 f0 f0 71 f0       	mov    %eax,0xf071f0f0
f01057e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01057e7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01057ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01057f1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01057f8:	a1 fc f0 71 f0       	mov    0xf071f0fc,%eax
f01057fd:	48                   	dec    %eax
f01057fe:	a3 fc f0 71 f0       	mov    %eax,0xf071f0fc
		env->env_status = ENV_UNKNOWN;
f0105803:	8b 45 08             	mov    0x8(%ebp),%eax
f0105806:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f010580d:	90                   	nop
f010580e:	c9                   	leave  
f010580f:	c3                   	ret    

f0105810 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0105810:	55                   	push   %ebp
f0105811:	89 e5                	mov    %esp,%ebp
f0105813:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 80 f0 71 f0       	push   $0xf071f080
f010581e:	e8 aa a9 00 00       	call   f01101cd <holding_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
f0105826:	85 c0                	test   %eax,%eax
f0105828:	75 17                	jne    f0105841 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010582a:	83 ec 04             	sub    $0x4,%esp
f010582d:	68 60 57 12 f0       	push   $0xf0125760
f0105832:	68 e4 00 00 00       	push   $0xe4
f0105837:	68 03 57 12 f0       	push   $0xf0125703
f010583c:	e8 f8 aa ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105841:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105845:	75 19                	jne    f0105860 <sched_insert_exit+0x50>
f0105847:	68 a1 57 12 f0       	push   $0xf01257a1
f010584c:	68 ee 56 12 f0       	push   $0xf01256ee
f0105851:	68 e7 00 00 00       	push   $0xe7
f0105856:	68 03 57 12 f0       	push   $0xf0125703
f010585b:	e8 d9 aa ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0105860:	e8 bf a1 00 00       	call   f010fa24 <isBufferingEnabled>
f0105865:	84 c0                	test   %al,%al
f0105867:	74 0e                	je     f0105877 <sched_insert_exit+0x67>
f0105869:	83 ec 0c             	sub    $0xc,%esp
f010586c:	ff 75 08             	pushl  0x8(%ebp)
f010586f:	e8 33 77 00 00       	call   f010cfa7 <cleanup_buffers>
f0105874:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f0105877:	8b 45 08             	mov    0x8(%ebp),%eax
f010587a:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105881:	83 ec 08             	sub    $0x8,%esp
f0105884:	ff 75 08             	pushl  0x8(%ebp)
f0105887:	68 00 f1 71 f0       	push   $0xf071f100
f010588c:	e8 07 f9 ff ff       	call   f0105198 <enqueue>
f0105891:	83 c4 10             	add    $0x10,%esp
	}
}
f0105894:	90                   	nop
f0105895:	c9                   	leave  
f0105896:	c3                   	ret    

f0105897 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f0105897:	55                   	push   %ebp
f0105898:	89 e5                	mov    %esp,%ebp
f010589a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010589d:	83 ec 0c             	sub    $0xc,%esp
f01058a0:	68 80 f0 71 f0       	push   $0xf071f080
f01058a5:	e8 23 a9 00 00       	call   f01101cd <holding_spinlock>
f01058aa:	83 c4 10             	add    $0x10,%esp
f01058ad:	85 c0                	test   %eax,%eax
f01058af:	75 17                	jne    f01058c8 <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01058b1:	83 ec 04             	sub    $0x4,%esp
f01058b4:	68 60 57 12 f0       	push   $0xf0125760
f01058b9:	68 f5 00 00 00       	push   $0xf5
f01058be:	68 03 57 12 f0       	push   $0xf0125703
f01058c3:	e8 71 aa ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01058c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01058cc:	74 0b                	je     f01058d9 <sched_remove_exit+0x42>
f01058ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01058d1:	8b 40 18             	mov    0x18(%eax),%eax
f01058d4:	83 f8 05             	cmp    $0x5,%eax
f01058d7:	74 19                	je     f01058f2 <sched_remove_exit+0x5b>
f01058d9:	68 08 58 12 f0       	push   $0xf0125808
f01058de:	68 ee 56 12 f0       	push   $0xf01256ee
f01058e3:	68 f8 00 00 00       	push   $0xf8
f01058e8:	68 03 57 12 f0       	push   $0xf0125703
f01058ed:	e8 47 aa ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f01058f2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01058f6:	75 17                	jne    f010590f <sched_remove_exit+0x78>
f01058f8:	83 ec 04             	sub    $0x4,%esp
f01058fb:	68 3f 57 12 f0       	push   $0xf012573f
f0105900:	68 fa 00 00 00       	push   $0xfa
f0105905:	68 03 57 12 f0       	push   $0xf0125703
f010590a:	e8 2a aa ff ff       	call   f0100339 <_panic>
f010590f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105912:	8b 40 08             	mov    0x8(%eax),%eax
f0105915:	85 c0                	test   %eax,%eax
f0105917:	74 11                	je     f010592a <sched_remove_exit+0x93>
f0105919:	8b 45 08             	mov    0x8(%ebp),%eax
f010591c:	8b 40 08             	mov    0x8(%eax),%eax
f010591f:	8b 55 08             	mov    0x8(%ebp),%edx
f0105922:	8b 52 0c             	mov    0xc(%edx),%edx
f0105925:	89 50 0c             	mov    %edx,0xc(%eax)
f0105928:	eb 0b                	jmp    f0105935 <sched_remove_exit+0x9e>
f010592a:	8b 45 08             	mov    0x8(%ebp),%eax
f010592d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105930:	a3 04 f1 71 f0       	mov    %eax,0xf071f104
f0105935:	8b 45 08             	mov    0x8(%ebp),%eax
f0105938:	8b 40 0c             	mov    0xc(%eax),%eax
f010593b:	85 c0                	test   %eax,%eax
f010593d:	74 11                	je     f0105950 <sched_remove_exit+0xb9>
f010593f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105942:	8b 40 0c             	mov    0xc(%eax),%eax
f0105945:	8b 55 08             	mov    0x8(%ebp),%edx
f0105948:	8b 52 08             	mov    0x8(%edx),%edx
f010594b:	89 50 08             	mov    %edx,0x8(%eax)
f010594e:	eb 0b                	jmp    f010595b <sched_remove_exit+0xc4>
f0105950:	8b 45 08             	mov    0x8(%ebp),%eax
f0105953:	8b 40 08             	mov    0x8(%eax),%eax
f0105956:	a3 00 f1 71 f0       	mov    %eax,0xf071f100
f010595b:	8b 45 08             	mov    0x8(%ebp),%eax
f010595e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105965:	8b 45 08             	mov    0x8(%ebp),%eax
f0105968:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010596f:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f0105974:	48                   	dec    %eax
f0105975:	a3 0c f1 71 f0       	mov    %eax,0xf071f10c
		env->env_status = ENV_UNKNOWN;
f010597a:	8b 45 08             	mov    0x8(%ebp),%eax
f010597d:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105984:	90                   	nop
f0105985:	c9                   	leave  
f0105986:	c3                   	ret    

f0105987 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f0105987:	55                   	push   %ebp
f0105988:	89 e5                	mov    %esp,%ebp
f010598a:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010598d:	83 ec 0c             	sub    $0xc,%esp
f0105990:	68 80 f0 71 f0       	push   $0xf071f080
f0105995:	e8 1a a6 00 00       	call   f010ffb4 <acquire_spinlock>
f010599a:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f010599d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01059a1:	75 19                	jne    f01059bc <sched_new_env+0x35>
f01059a3:	68 33 58 12 f0       	push   $0xf0125833
f01059a8:	68 ee 56 12 f0       	push   $0xf01256ee
f01059ad:	68 08 01 00 00       	push   $0x108
f01059b2:	68 03 57 12 f0       	push   $0xf0125703
f01059b7:	e8 7d a9 ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f01059bc:	83 ec 0c             	sub    $0xc,%esp
f01059bf:	ff 75 08             	pushl  0x8(%ebp)
f01059c2:	e8 e9 fc ff ff       	call   f01056b0 <sched_insert_new>
f01059c7:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01059ca:	83 ec 0c             	sub    $0xc,%esp
f01059cd:	68 80 f0 71 f0       	push   $0xf071f080
f01059d2:	e8 64 a6 00 00       	call   f011003b <release_spinlock>
f01059d7:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01059da:	90                   	nop
f01059db:	c9                   	leave  
f01059dc:	c3                   	ret    

f01059dd <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01059dd:	55                   	push   %ebp
f01059de:	89 e5                	mov    %esp,%ebp
f01059e0:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01059e3:	83 ec 0c             	sub    $0xc,%esp
f01059e6:	68 80 f0 71 f0       	push   $0xf071f080
f01059eb:	e8 c4 a5 00 00       	call   f010ffb4 <acquire_spinlock>
f01059f0:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01059f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01059fa:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f01059ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a02:	eb 53                	jmp    f0105a57 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105a04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a07:	8b 40 10             	mov    0x10(%eax),%eax
f0105a0a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a0d:	75 40                	jne    f0105a4f <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0105a0f:	83 ec 0c             	sub    $0xc,%esp
f0105a12:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a15:	e8 06 fd ff ff       	call   f0105720 <sched_remove_new>
f0105a1a:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready(ptr_env);
f0105a1d:	83 ec 0c             	sub    $0xc,%esp
f0105a20:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a23:	e8 ad fa ff ff       	call   f01054d5 <sched_insert_ready>
f0105a28:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f0105a2b:	e8 07 1a 00 00       	call   f0107437 <mycpu>
f0105a30:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105a36:	85 c0                	test   %eax,%eax
f0105a38:	75 46                	jne    f0105a80 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a3a:	83 ec 0c             	sub    $0xc,%esp
f0105a3d:	68 80 f0 71 f0       	push   $0xf071f080
f0105a42:	e8 f4 a5 00 00       	call   f011003b <release_spinlock>
f0105a47:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f0105a4a:	e8 f6 0f 00 00       	call   f0106a45 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105a4f:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105a54:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a5b:	74 08                	je     f0105a65 <sched_run_env+0x88>
f0105a5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a60:	8b 40 08             	mov    0x8(%eax),%eax
f0105a63:	eb 05                	jmp    f0105a6a <sched_run_env+0x8d>
f0105a65:	b8 00 00 00 00       	mov    $0x0,%eax
f0105a6a:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f0105a6f:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105a74:	85 c0                	test   %eax,%eax
f0105a76:	75 8c                	jne    f0105a04 <sched_run_env+0x27>
f0105a78:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a7c:	75 86                	jne    f0105a04 <sched_run_env+0x27>
f0105a7e:	eb 01                	jmp    f0105a81 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105a80:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	68 80 f0 71 f0       	push   $0xf071f080
f0105a89:	e8 ad a5 00 00       	call   f011003b <release_spinlock>
f0105a8e:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105a91:	90                   	nop
f0105a92:	c9                   	leave  
f0105a93:	c3                   	ret    

f0105a94 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105a94:	55                   	push   %ebp
f0105a95:	89 e5                	mov    %esp,%ebp
f0105a97:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f0105a9a:	83 ec 0c             	sub    $0xc,%esp
f0105a9d:	68 80 f0 71 f0       	push   $0xf071f080
f0105aa2:	e8 26 a7 00 00       	call   f01101cd <holding_spinlock>
f0105aa7:	83 c4 10             	add    $0x10,%esp
f0105aaa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105aad:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105ab1:	75 10                	jne    f0105ac3 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105ab3:	83 ec 0c             	sub    $0xc,%esp
f0105ab6:	68 80 f0 71 f0       	push   $0xf071f080
f0105abb:	e8 f4 a4 00 00       	call   f010ffb4 <acquire_spinlock>
f0105ac0:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105ac3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105aca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105ad1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ad5:	75 59                	jne    f0105b30 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ad7:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f0105adc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105adf:	eb 28                	jmp    f0105b09 <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105ae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ae4:	8b 40 10             	mov    0x10(%eax),%eax
f0105ae7:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105aea:	75 15                	jne    f0105b01 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105aec:	83 ec 0c             	sub    $0xc,%esp
f0105aef:	ff 75 f4             	pushl  -0xc(%ebp)
f0105af2:	e8 29 fc ff ff       	call   f0105720 <sched_remove_new>
f0105af7:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105afa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b01:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105b06:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b0d:	74 08                	je     f0105b17 <sched_exit_env+0x83>
f0105b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b12:	8b 40 08             	mov    0x8(%eax),%eax
f0105b15:	eb 05                	jmp    f0105b1c <sched_exit_env+0x88>
f0105b17:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b1c:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f0105b21:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105b26:	85 c0                	test   %eax,%eax
f0105b28:	75 b7                	jne    f0105ae1 <sched_exit_env+0x4d>
f0105b2a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b2e:	75 b1                	jne    f0105ae1 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0105b30:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b34:	0f 85 67 01 00 00    	jne    f0105ca1 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b41:	e9 47 01 00 00       	jmp    f0105c8d <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b46:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105b4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b4e:	c1 e2 04             	shl    $0x4,%edx
f0105b51:	01 d0                	add    %edx,%eax
f0105b53:	8b 00                	mov    (%eax),%eax
f0105b55:	85 c0                	test   %eax,%eax
f0105b57:	0f 84 27 01 00 00    	je     f0105c84 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f0105b5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b64:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105b69:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b6c:	c1 e2 04             	shl    $0x4,%edx
f0105b6f:	01 d0                	add    %edx,%eax
f0105b71:	8b 00                	mov    (%eax),%eax
f0105b73:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b76:	e9 d1 00 00 00       	jmp    f0105c4c <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b7e:	8b 40 10             	mov    0x10(%eax),%eax
f0105b81:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b84:	0f 85 af 00 00 00    	jne    f0105c39 <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105b8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b8e:	75 17                	jne    f0105ba7 <sched_exit_env+0x113>
f0105b90:	83 ec 04             	sub    $0x4,%esp
f0105b93:	68 3f 57 12 f0       	push   $0xf012573f
f0105b98:	68 56 01 00 00       	push   $0x156
f0105b9d:	68 03 57 12 f0       	push   $0xf0125703
f0105ba2:	e8 92 a7 ff ff       	call   f0100339 <_panic>
f0105ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105baa:	8b 40 08             	mov    0x8(%eax),%eax
f0105bad:	85 c0                	test   %eax,%eax
f0105baf:	74 11                	je     f0105bc2 <sched_exit_env+0x12e>
f0105bb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb4:	8b 40 08             	mov    0x8(%eax),%eax
f0105bb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bba:	8b 52 0c             	mov    0xc(%edx),%edx
f0105bbd:	89 50 0c             	mov    %edx,0xc(%eax)
f0105bc0:	eb 16                	jmp    f0105bd8 <sched_exit_env+0x144>
f0105bc2:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105bc7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bca:	c1 e2 04             	shl    $0x4,%edx
f0105bcd:	01 c2                	add    %eax,%edx
f0105bcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bd2:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bd5:	89 42 04             	mov    %eax,0x4(%edx)
f0105bd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bdb:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bde:	85 c0                	test   %eax,%eax
f0105be0:	74 11                	je     f0105bf3 <sched_exit_env+0x15f>
f0105be2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105be5:	8b 40 0c             	mov    0xc(%eax),%eax
f0105be8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105beb:	8b 52 08             	mov    0x8(%edx),%edx
f0105bee:	89 50 08             	mov    %edx,0x8(%eax)
f0105bf1:	eb 15                	jmp    f0105c08 <sched_exit_env+0x174>
f0105bf3:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105bf8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bfb:	c1 e2 04             	shl    $0x4,%edx
f0105bfe:	01 c2                	add    %eax,%edx
f0105c00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c03:	8b 40 08             	mov    0x8(%eax),%eax
f0105c06:	89 02                	mov    %eax,(%edx)
f0105c08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c0b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c15:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c1c:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105c21:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c24:	c1 e2 04             	shl    $0x4,%edx
f0105c27:	01 d0                	add    %edx,%eax
f0105c29:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c2c:	4a                   	dec    %edx
f0105c2d:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c30:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c37:	eb 4b                	jmp    f0105c84 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c39:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105c3e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c41:	c1 e2 04             	shl    $0x4,%edx
f0105c44:	01 d0                	add    %edx,%eax
f0105c46:	8b 40 08             	mov    0x8(%eax),%eax
f0105c49:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c4c:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105c51:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c54:	c1 e2 04             	shl    $0x4,%edx
f0105c57:	01 d0                	add    %edx,%eax
f0105c59:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c5d:	74 08                	je     f0105c67 <sched_exit_env+0x1d3>
f0105c5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c62:	8b 52 08             	mov    0x8(%edx),%edx
f0105c65:	eb 05                	jmp    f0105c6c <sched_exit_env+0x1d8>
f0105c67:	ba 00 00 00 00       	mov    $0x0,%edx
f0105c6c:	89 50 08             	mov    %edx,0x8(%eax)
f0105c6f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c72:	85 c0                	test   %eax,%eax
f0105c74:	0f 85 01 ff ff ff    	jne    f0105b7b <sched_exit_env+0xe7>
f0105c7a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c7e:	0f 85 f7 fe ff ff    	jne    f0105b7b <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105c84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c88:	75 16                	jne    f0105ca0 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105c8a:	ff 45 ec             	incl   -0x14(%ebp)
f0105c8d:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f0105c92:	0f b6 c0             	movzbl %al,%eax
f0105c95:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105c98:	0f 8f a8 fe ff ff    	jg     f0105b46 <sched_exit_env+0xb2>
f0105c9e:	eb 01                	jmp    f0105ca1 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105ca0:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105ca1:	e8 7f 60 00 00       	call   f010bd25 <get_cpu_proc>
f0105ca6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105ca9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105cad:	75 19                	jne    f0105cc8 <sched_exit_env+0x234>
f0105caf:	68 3b 58 12 f0       	push   $0xf012583b
f0105cb4:	68 ee 56 12 f0       	push   $0xf01256ee
f0105cb9:	68 60 01 00 00       	push   $0x160
f0105cbe:	68 03 57 12 f0       	push   $0xf0125703
f0105cc3:	e8 71 a6 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105cc8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ccc:	75 18                	jne    f0105ce6 <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105cce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cd1:	8b 40 10             	mov    0x10(%eax),%eax
f0105cd4:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105cd7:	75 0d                	jne    f0105ce6 <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105cd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105cdf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105ce6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cea:	74 1e                	je     f0105d0a <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105cec:	83 ec 0c             	sub    $0xc,%esp
f0105cef:	ff 75 f4             	pushl  -0xc(%ebp)
f0105cf2:	e8 19 fb ff ff       	call   f0105810 <sched_insert_exit>
f0105cf7:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105cfa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cfd:	8b 40 10             	mov    0x10(%eax),%eax
f0105d00:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d03:	75 05                	jne    f0105d0a <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105d05:	e8 9c 61 00 00       	call   f010bea6 <sched>
		}
	}
	if (!lock_already_held)
f0105d0a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105d0e:	75 10                	jne    f0105d20 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105d10:	83 ec 0c             	sub    $0xc,%esp
f0105d13:	68 80 f0 71 f0       	push   $0xf071f080
f0105d18:	e8 1e a3 00 00       	call   f011003b <release_spinlock>
f0105d1d:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105d20:	90                   	nop
f0105d21:	c9                   	leave  
f0105d22:	c3                   	ret    

f0105d23 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105d23:	55                   	push   %ebp
f0105d24:	89 e5                	mov    %esp,%ebp
f0105d26:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d29:	83 ec 0c             	sub    $0xc,%esp
f0105d2c:	68 80 f0 71 f0       	push   $0xf071f080
f0105d31:	e8 7e a2 00 00       	call   f010ffb4 <acquire_spinlock>
f0105d36:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105d39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105d40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105d47:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d4b:	75 79                	jne    f0105dc6 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105d4d:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f0105d52:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d55:	eb 48                	jmp    f0105d9f <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105d57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d5a:	8b 40 10             	mov    0x10(%eax),%eax
f0105d5d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d60:	75 35                	jne    f0105d97 <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d65:	8d 50 20             	lea    0x20(%eax),%edx
f0105d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d6b:	8b 40 10             	mov    0x10(%eax),%eax
f0105d6e:	83 ec 04             	sub    $0x4,%esp
f0105d71:	52                   	push   %edx
f0105d72:	50                   	push   %eax
f0105d73:	68 4c 58 12 f0       	push   $0xf012584c
f0105d78:	e8 0e b2 ff ff       	call   f0100f8b <cprintf>
f0105d7d:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105d80:	83 ec 0c             	sub    $0xc,%esp
f0105d83:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d86:	e8 95 f9 ff ff       	call   f0105720 <sched_remove_new>
f0105d8b:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d8e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d95:	eb 2f                	jmp    f0105dc6 <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105d97:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105d9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d9f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105da3:	74 08                	je     f0105dad <sched_kill_env+0x8a>
f0105da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105da8:	8b 40 08             	mov    0x8(%eax),%eax
f0105dab:	eb 05                	jmp    f0105db2 <sched_kill_env+0x8f>
f0105dad:	b8 00 00 00 00       	mov    $0x0,%eax
f0105db2:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f0105db7:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0105dbc:	85 c0                	test   %eax,%eax
f0105dbe:	75 97                	jne    f0105d57 <sched_kill_env+0x34>
f0105dc0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105dc4:	75 91                	jne    f0105d57 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105dc6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105dca:	0f 85 85 01 00 00    	jne    f0105f55 <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105dd0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105dd7:	e9 65 01 00 00       	jmp    f0105f41 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105ddc:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105de1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105de4:	c1 e2 04             	shl    $0x4,%edx
f0105de7:	01 d0                	add    %edx,%eax
f0105de9:	8b 00                	mov    (%eax),%eax
f0105deb:	85 c0                	test   %eax,%eax
f0105ded:	0f 84 45 01 00 00    	je     f0105f38 <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105df3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105dfa:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105dff:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105e02:	c1 e2 04             	shl    $0x4,%edx
f0105e05:	01 d0                	add    %edx,%eax
f0105e07:	8b 00                	mov    (%eax),%eax
f0105e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e0c:	e9 ef 00 00 00       	jmp    f0105f00 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105e11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e14:	8b 40 10             	mov    0x10(%eax),%eax
f0105e17:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105e1a:	0f 85 cd 00 00 00    	jne    f0105eed <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105e20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e23:	8d 50 20             	lea    0x20(%eax),%edx
f0105e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e29:	8b 40 10             	mov    0x10(%eax),%eax
f0105e2c:	ff 75 ec             	pushl  -0x14(%ebp)
f0105e2f:	52                   	push   %edx
f0105e30:	50                   	push   %eax
f0105e31:	68 74 58 12 f0       	push   $0xf0125874
f0105e36:	e8 50 b1 ff ff       	call   f0100f8b <cprintf>
f0105e3b:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105e3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e42:	75 17                	jne    f0105e5b <sched_kill_env+0x138>
f0105e44:	83 ec 04             	sub    $0x4,%esp
f0105e47:	68 3f 57 12 f0       	push   $0xf012573f
f0105e4c:	68 a3 01 00 00       	push   $0x1a3
f0105e51:	68 03 57 12 f0       	push   $0xf0125703
f0105e56:	e8 de a4 ff ff       	call   f0100339 <_panic>
f0105e5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e5e:	8b 40 08             	mov    0x8(%eax),%eax
f0105e61:	85 c0                	test   %eax,%eax
f0105e63:	74 11                	je     f0105e76 <sched_kill_env+0x153>
f0105e65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e68:	8b 40 08             	mov    0x8(%eax),%eax
f0105e6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e6e:	8b 52 0c             	mov    0xc(%edx),%edx
f0105e71:	89 50 0c             	mov    %edx,0xc(%eax)
f0105e74:	eb 16                	jmp    f0105e8c <sched_kill_env+0x169>
f0105e76:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105e7b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105e7e:	c1 e2 04             	shl    $0x4,%edx
f0105e81:	01 c2                	add    %eax,%edx
f0105e83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e86:	8b 40 0c             	mov    0xc(%eax),%eax
f0105e89:	89 42 04             	mov    %eax,0x4(%edx)
f0105e8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e8f:	8b 40 0c             	mov    0xc(%eax),%eax
f0105e92:	85 c0                	test   %eax,%eax
f0105e94:	74 11                	je     f0105ea7 <sched_kill_env+0x184>
f0105e96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e99:	8b 40 0c             	mov    0xc(%eax),%eax
f0105e9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e9f:	8b 52 08             	mov    0x8(%edx),%edx
f0105ea2:	89 50 08             	mov    %edx,0x8(%eax)
f0105ea5:	eb 15                	jmp    f0105ebc <sched_kill_env+0x199>
f0105ea7:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105eac:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105eaf:	c1 e2 04             	shl    $0x4,%edx
f0105eb2:	01 c2                	add    %eax,%edx
f0105eb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105eb7:	8b 40 08             	mov    0x8(%eax),%eax
f0105eba:	89 02                	mov    %eax,(%edx)
f0105ebc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105ec6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ec9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105ed0:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105ed5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ed8:	c1 e2 04             	shl    $0x4,%edx
f0105edb:	01 d0                	add    %edx,%eax
f0105edd:	8b 50 0c             	mov    0xc(%eax),%edx
f0105ee0:	4a                   	dec    %edx
f0105ee1:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105ee4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105eeb:	eb 4b                	jmp    f0105f38 <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105eed:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105ef2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ef5:	c1 e2 04             	shl    $0x4,%edx
f0105ef8:	01 d0                	add    %edx,%eax
f0105efa:	8b 40 08             	mov    0x8(%eax),%eax
f0105efd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f00:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0105f05:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105f08:	c1 e2 04             	shl    $0x4,%edx
f0105f0b:	01 d0                	add    %edx,%eax
f0105f0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f11:	74 08                	je     f0105f1b <sched_kill_env+0x1f8>
f0105f13:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f16:	8b 52 08             	mov    0x8(%edx),%edx
f0105f19:	eb 05                	jmp    f0105f20 <sched_kill_env+0x1fd>
f0105f1b:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f20:	89 50 08             	mov    %edx,0x8(%eax)
f0105f23:	8b 40 08             	mov    0x8(%eax),%eax
f0105f26:	85 c0                	test   %eax,%eax
f0105f28:	0f 85 e3 fe ff ff    	jne    f0105e11 <sched_kill_env+0xee>
f0105f2e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f32:	0f 85 d9 fe ff ff    	jne    f0105e11 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105f38:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105f3c:	75 16                	jne    f0105f54 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105f3e:	ff 45 ec             	incl   -0x14(%ebp)
f0105f41:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f0105f46:	0f b6 c0             	movzbl %al,%eax
f0105f49:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105f4c:	0f 8f 8a fe ff ff    	jg     f0105ddc <sched_kill_env+0xb9>
f0105f52:	eb 01                	jmp    f0105f55 <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105f54:	90                   	nop
		}
	}
	if (!found)
f0105f55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105f59:	0f 85 80 00 00 00    	jne    f0105fdf <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105f5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105f66:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0105f6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f6e:	eb 48                	jmp    f0105fb8 <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105f70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f73:	8b 40 10             	mov    0x10(%eax),%eax
f0105f76:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105f79:	75 35                	jne    f0105fb0 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105f7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f7e:	8d 50 20             	lea    0x20(%eax),%edx
f0105f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f84:	8b 40 10             	mov    0x10(%eax),%eax
f0105f87:	83 ec 04             	sub    $0x4,%esp
f0105f8a:	52                   	push   %edx
f0105f8b:	50                   	push   %eax
f0105f8c:	68 a0 58 12 f0       	push   $0xf01258a0
f0105f91:	e8 f5 af ff ff       	call   f0100f8b <cprintf>
f0105f96:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105f99:	83 ec 0c             	sub    $0xc,%esp
f0105f9c:	ff 75 f4             	pushl  -0xc(%ebp)
f0105f9f:	e8 f3 f8 ff ff       	call   f0105897 <sched_remove_exit>
f0105fa4:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105fa7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105fae:	eb 2f                	jmp    f0105fdf <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105fb0:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0105fb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fb8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fbc:	74 08                	je     f0105fc6 <sched_kill_env+0x2a3>
f0105fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fc1:	8b 40 08             	mov    0x8(%eax),%eax
f0105fc4:	eb 05                	jmp    f0105fcb <sched_kill_env+0x2a8>
f0105fc6:	b8 00 00 00 00       	mov    $0x0,%eax
f0105fcb:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f0105fd0:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0105fd5:	85 c0                	test   %eax,%eax
f0105fd7:	75 97                	jne    f0105f70 <sched_kill_env+0x24d>
f0105fd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fdd:	75 91                	jne    f0105f70 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105fdf:	83 ec 0c             	sub    $0xc,%esp
f0105fe2:	68 80 f0 71 f0       	push   $0xf071f080
f0105fe7:	e8 4f a0 00 00       	call   f011003b <release_spinlock>
f0105fec:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105fef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ff3:	74 23                	je     f0106018 <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105ff5:	83 ec 0c             	sub    $0xc,%esp
f0105ff8:	ff 75 f4             	pushl  -0xc(%ebp)
f0105ffb:	e8 dd 5c 00 00       	call   f010bcdd <env_free>
f0106000:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0106003:	83 ec 0c             	sub    $0xc,%esp
f0106006:	68 c6 58 12 f0       	push   $0xf01258c6
f010600b:	e8 7b af ff ff       	call   f0100f8b <cprintf>
f0106010:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0106013:	e9 a4 00 00 00       	jmp    f01060bc <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0106018:	e8 08 5d 00 00       	call   f010bd25 <get_cpu_proc>
f010601d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0106020:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106024:	75 19                	jne    f010603f <sched_kill_env+0x31c>
f0106026:	68 3b 58 12 f0       	push   $0xf012583b
f010602b:	68 ee 56 12 f0       	push   $0xf01256ee
f0106030:	68 c5 01 00 00       	push   $0x1c5
f0106035:	68 03 57 12 f0       	push   $0xf0125703
f010603a:	e8 fa a2 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f010603f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106042:	8b 40 10             	mov    0x10(%eax),%eax
f0106045:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106048:	75 72                	jne    f01060bc <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f010604a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010604d:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0106050:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106053:	8b 40 18             	mov    0x18(%eax),%eax
f0106056:	83 f8 02             	cmp    $0x2,%eax
f0106059:	74 19                	je     f0106074 <sched_kill_env+0x351>
f010605b:	68 cc 58 12 f0       	push   $0xf01258cc
f0106060:	68 ee 56 12 f0       	push   $0xf01256ee
f0106065:	68 ca 01 00 00       	push   $0x1ca
f010606a:	68 03 57 12 f0       	push   $0xf0125703
f010606f:	e8 c5 a2 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106074:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106077:	8d 50 20             	lea    0x20(%eax),%edx
f010607a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010607d:	8b 40 10             	mov    0x10(%eax),%eax
f0106080:	83 ec 04             	sub    $0x4,%esp
f0106083:	52                   	push   %edx
f0106084:	50                   	push   %eax
f0106085:	68 f0 58 12 f0       	push   $0xf01258f0
f010608a:	e8 fc ae ff ff       	call   f0100f8b <cprintf>
f010608f:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106092:	83 ec 0c             	sub    $0xc,%esp
f0106095:	ff 75 f4             	pushl  -0xc(%ebp)
f0106098:	e8 40 5c 00 00       	call   f010bcdd <env_free>
f010609d:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01060a0:	83 ec 0c             	sub    $0xc,%esp
f01060a3:	68 c6 58 12 f0       	push   $0xf01258c6
f01060a8:	e8 de ae ff ff       	call   f0100f8b <cprintf>
f01060ad:	83 c4 10             	add    $0x10,%esp
			found = 1;
f01060b0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f01060b7:	e8 ea 5d 00 00       	call   f010bea6 <sched>
		}
	}

}
f01060bc:	90                   	nop
f01060bd:	c9                   	leave  
f01060be:	c3                   	ret    

f01060bf <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f01060bf:	55                   	push   %ebp
f01060c0:	89 e5                	mov    %esp,%ebp
f01060c2:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060c5:	83 ec 0c             	sub    $0xc,%esp
f01060c8:	68 80 f0 71 f0       	push   $0xf071f080
f01060cd:	e8 e2 9e 00 00       	call   f010ffb4 <acquire_spinlock>
f01060d2:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01060d5:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f01060da:	85 c0                	test   %eax,%eax
f01060dc:	74 69                	je     f0106147 <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f01060de:	83 ec 0c             	sub    $0xc,%esp
f01060e1:	68 1c 59 12 f0       	push   $0xf012591c
f01060e6:	e8 a0 ae ff ff       	call   f0100f8b <cprintf>
f01060eb:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01060ee:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f01060f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01060f6:	eb 26                	jmp    f010611e <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f01060f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060fb:	8d 50 20             	lea    0x20(%eax),%edx
f01060fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106101:	8b 40 10             	mov    0x10(%eax),%eax
f0106104:	83 ec 04             	sub    $0x4,%esp
f0106107:	52                   	push   %edx
f0106108:	50                   	push   %eax
f0106109:	68 3e 59 12 f0       	push   $0xf012593e
f010610e:	e8 78 ae ff ff       	call   f0100f8b <cprintf>
f0106113:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106116:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f010611b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010611e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106122:	74 08                	je     f010612c <sched_print_all+0x6d>
f0106124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106127:	8b 40 08             	mov    0x8(%eax),%eax
f010612a:	eb 05                	jmp    f0106131 <sched_print_all+0x72>
f010612c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106131:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f0106136:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f010613b:	85 c0                	test   %eax,%eax
f010613d:	75 b9                	jne    f01060f8 <sched_print_all+0x39>
f010613f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106143:	75 b3                	jne    f01060f8 <sched_print_all+0x39>
f0106145:	eb 10                	jmp    f0106157 <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0106147:	83 ec 0c             	sub    $0xc,%esp
f010614a:	68 48 59 12 f0       	push   $0xf0125948
f010614f:	e8 37 ae ff ff       	call   f0100f8b <cprintf>
f0106154:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106157:	83 ec 0c             	sub    $0xc,%esp
f010615a:	68 64 59 12 f0       	push   $0xf0125964
f010615f:	e8 27 ae ff ff       	call   f0100f8b <cprintf>
f0106164:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106167:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010616e:	e9 c7 00 00 00       	jmp    f010623a <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106173:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106178:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010617b:	c1 e2 04             	shl    $0x4,%edx
f010617e:	01 d0                	add    %edx,%eax
f0106180:	8b 00                	mov    (%eax),%eax
f0106182:	85 c0                	test   %eax,%eax
f0106184:	0f 84 8a 00 00 00    	je     f0106214 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f010618a:	83 ec 08             	sub    $0x8,%esp
f010618d:	ff 75 f0             	pushl  -0x10(%ebp)
f0106190:	68 98 59 12 f0       	push   $0xf0125998
f0106195:	e8 f1 ad ff ff       	call   f0100f8b <cprintf>
f010619a:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010619d:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01061a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061a5:	c1 e2 04             	shl    $0x4,%edx
f01061a8:	01 d0                	add    %edx,%eax
f01061aa:	8b 00                	mov    (%eax),%eax
f01061ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061af:	eb 31                	jmp    f01061e2 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f01061b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061b4:	8d 50 20             	lea    0x20(%eax),%edx
f01061b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061ba:	8b 40 10             	mov    0x10(%eax),%eax
f01061bd:	83 ec 04             	sub    $0x4,%esp
f01061c0:	52                   	push   %edx
f01061c1:	50                   	push   %eax
f01061c2:	68 3e 59 12 f0       	push   $0xf012593e
f01061c7:	e8 bf ad ff ff       	call   f0100f8b <cprintf>
f01061cc:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01061cf:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01061d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061d7:	c1 e2 04             	shl    $0x4,%edx
f01061da:	01 d0                	add    %edx,%eax
f01061dc:	8b 40 08             	mov    0x8(%eax),%eax
f01061df:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061e2:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01061e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061ea:	c1 e2 04             	shl    $0x4,%edx
f01061ed:	01 d0                	add    %edx,%eax
f01061ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061f3:	74 08                	je     f01061fd <sched_print_all+0x13e>
f01061f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01061f8:	8b 52 08             	mov    0x8(%edx),%edx
f01061fb:	eb 05                	jmp    f0106202 <sched_print_all+0x143>
f01061fd:	ba 00 00 00 00       	mov    $0x0,%edx
f0106202:	89 50 08             	mov    %edx,0x8(%eax)
f0106205:	8b 40 08             	mov    0x8(%eax),%eax
f0106208:	85 c0                	test   %eax,%eax
f010620a:	75 a5                	jne    f01061b1 <sched_print_all+0xf2>
f010620c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106210:	75 9f                	jne    f01061b1 <sched_print_all+0xf2>
f0106212:	eb 13                	jmp    f0106227 <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0106214:	83 ec 08             	sub    $0x8,%esp
f0106217:	ff 75 f0             	pushl  -0x10(%ebp)
f010621a:	68 c0 59 12 f0       	push   $0xf01259c0
f010621f:	e8 67 ad ff ff       	call   f0100f8b <cprintf>
f0106224:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106227:	83 ec 0c             	sub    $0xc,%esp
f010622a:	68 64 59 12 f0       	push   $0xf0125964
f010622f:	e8 57 ad ff ff       	call   f0100f8b <cprintf>
f0106234:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106237:	ff 45 f0             	incl   -0x10(%ebp)
f010623a:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f010623f:	0f b6 c0             	movzbl %al,%eax
f0106242:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106245:	0f 8f 28 ff ff ff    	jg     f0106173 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f010624b:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0106250:	85 c0                	test   %eax,%eax
f0106252:	74 69                	je     f01062bd <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0106254:	83 ec 0c             	sub    $0xc,%esp
f0106257:	68 e4 59 12 f0       	push   $0xf01259e4
f010625c:	e8 2a ad ff ff       	call   f0100f8b <cprintf>
f0106261:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106264:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0106269:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010626c:	eb 26                	jmp    f0106294 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f010626e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106271:	8d 50 20             	lea    0x20(%eax),%edx
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 10             	mov    0x10(%eax),%eax
f010627a:	83 ec 04             	sub    $0x4,%esp
f010627d:	52                   	push   %edx
f010627e:	50                   	push   %eax
f010627f:	68 3e 59 12 f0       	push   $0xf012593e
f0106284:	e8 02 ad ff ff       	call   f0100f8b <cprintf>
f0106289:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f010628c:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0106291:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106294:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106298:	74 08                	je     f01062a2 <sched_print_all+0x1e3>
f010629a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629d:	8b 40 08             	mov    0x8(%eax),%eax
f01062a0:	eb 05                	jmp    f01062a7 <sched_print_all+0x1e8>
f01062a2:	b8 00 00 00 00       	mov    $0x0,%eax
f01062a7:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f01062ac:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f01062b1:	85 c0                	test   %eax,%eax
f01062b3:	75 b9                	jne    f010626e <sched_print_all+0x1af>
f01062b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062b9:	75 b3                	jne    f010626e <sched_print_all+0x1af>
f01062bb:	eb 10                	jmp    f01062cd <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01062bd:	83 ec 0c             	sub    $0xc,%esp
f01062c0:	68 06 5a 12 f0       	push   $0xf0125a06
f01062c5:	e8 c1 ac ff ff       	call   f0100f8b <cprintf>
f01062ca:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01062cd:	83 ec 0c             	sub    $0xc,%esp
f01062d0:	68 80 f0 71 f0       	push   $0xf071f080
f01062d5:	e8 61 9d 00 00       	call   f011003b <release_spinlock>
f01062da:	83 c4 10             	add    $0x10,%esp
}
f01062dd:	90                   	nop
f01062de:	c9                   	leave  
f01062df:	c3                   	ret    

f01062e0 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f01062e0:	55                   	push   %ebp
f01062e1:	89 e5                	mov    %esp,%ebp
f01062e3:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01062e6:	83 ec 0c             	sub    $0xc,%esp
f01062e9:	68 80 f0 71 f0       	push   $0xf071f080
f01062ee:	e8 c1 9c 00 00       	call   f010ffb4 <acquire_spinlock>
f01062f3:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01062f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f01062fd:	a1 fc f0 71 f0       	mov    0xf071f0fc,%eax
f0106302:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f0106305:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010630c:	eb 24                	jmp    f0106332 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f010630e:	83 ec 0c             	sub    $0xc,%esp
f0106311:	68 f0 f0 71 f0       	push   $0xf071f0f0
f0106316:	e8 0e ef ff ff       	call   f0105229 <dequeue>
f010631b:	83 c4 10             	add    $0x10,%esp
f010631e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready(ptr_env);
f0106321:	83 ec 0c             	sub    $0xc,%esp
f0106324:	ff 75 f0             	pushl  -0x10(%ebp)
f0106327:	e8 a9 f1 ff ff       	call   f01054d5 <sched_insert_ready>
f010632c:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f010632f:	ff 45 f4             	incl   -0xc(%ebp)
f0106332:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106335:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0106338:	7c d4                	jl     f010630e <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010633a:	83 ec 0c             	sub    $0xc,%esp
f010633d:	68 80 f0 71 f0       	push   $0xf071f080
f0106342:	e8 f4 9c 00 00       	call   f011003b <release_spinlock>
f0106347:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f010634a:	e8 e8 10 00 00       	call   f0107437 <mycpu>
f010634f:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0106355:	85 c0                	test   %eax,%eax
f0106357:	75 05                	jne    f010635e <sched_run_all+0x7e>
		fos_scheduler();
f0106359:	e8 e7 06 00 00       	call   f0106a45 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f010635e:	83 ec 04             	sub    $0x4,%esp
f0106361:	68 24 5a 12 f0       	push   $0xf0125a24
f0106366:	68 27 02 00 00       	push   $0x227
f010636b:	68 03 57 12 f0       	push   $0xf0125703
f0106370:	e8 c4 9f ff ff       	call   f0100339 <_panic>

f0106375 <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f0106375:	55                   	push   %ebp
f0106376:	89 e5                	mov    %esp,%ebp
f0106378:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010637b:	83 ec 0c             	sub    $0xc,%esp
f010637e:	68 80 f0 71 f0       	push   $0xf071f080
f0106383:	e8 2c 9c 00 00       	call   f010ffb4 <acquire_spinlock>
f0106388:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f010638b:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f0106390:	85 c0                	test   %eax,%eax
f0106392:	0f 84 95 00 00 00    	je     f010642d <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f0106398:	83 ec 0c             	sub    $0xc,%esp
f010639b:	68 60 5a 12 f0       	push   $0xf0125a60
f01063a0:	e8 e6 ab ff ff       	call   f0100f8b <cprintf>
f01063a5:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01063a8:	a1 f0 f0 71 f0       	mov    0xf071f0f0,%eax
f01063ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063b0:	eb 52                	jmp    f0106404 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063b5:	8d 50 20             	lea    0x20(%eax),%edx
f01063b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bb:	8b 40 10             	mov    0x10(%eax),%eax
f01063be:	83 ec 04             	sub    $0x4,%esp
f01063c1:	52                   	push   %edx
f01063c2:	50                   	push   %eax
f01063c3:	68 8c 5a 12 f0       	push   $0xf0125a8c
f01063c8:	e8 be ab ff ff       	call   f0100f8b <cprintf>
f01063cd:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01063d0:	83 ec 0c             	sub    $0xc,%esp
f01063d3:	ff 75 f4             	pushl  -0xc(%ebp)
f01063d6:	e8 45 f3 ff ff       	call   f0105720 <sched_remove_new>
f01063db:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063de:	83 ec 0c             	sub    $0xc,%esp
f01063e1:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e4:	e8 f4 58 00 00       	call   f010bcdd <env_free>
f01063e9:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063ec:	83 ec 0c             	sub    $0xc,%esp
f01063ef:	68 c6 58 12 f0       	push   $0xf01258c6
f01063f4:	e8 92 ab ff ff       	call   f0100f8b <cprintf>
f01063f9:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01063fc:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0106401:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106404:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106408:	74 08                	je     f0106412 <sched_kill_all+0x9d>
f010640a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010640d:	8b 40 08             	mov    0x8(%eax),%eax
f0106410:	eb 05                	jmp    f0106417 <sched_kill_all+0xa2>
f0106412:	b8 00 00 00 00       	mov    $0x0,%eax
f0106417:	a3 f8 f0 71 f0       	mov    %eax,0xf071f0f8
f010641c:	a1 f8 f0 71 f0       	mov    0xf071f0f8,%eax
f0106421:	85 c0                	test   %eax,%eax
f0106423:	75 8d                	jne    f01063b2 <sched_kill_all+0x3d>
f0106425:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106429:	75 87                	jne    f01063b2 <sched_kill_all+0x3d>
f010642b:	eb 10                	jmp    f010643d <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f010642d:	83 ec 0c             	sub    $0xc,%esp
f0106430:	68 9f 5a 12 f0       	push   $0xf0125a9f
f0106435:	e8 51 ab ff ff       	call   f0100f8b <cprintf>
f010643a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f010643d:	83 ec 0c             	sub    $0xc,%esp
f0106440:	68 64 59 12 f0       	push   $0xf0125964
f0106445:	e8 41 ab ff ff       	call   f0100f8b <cprintf>
f010644a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010644d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106454:	e9 96 01 00 00       	jmp    f01065ef <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106459:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010645e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106461:	c1 e2 04             	shl    $0x4,%edx
f0106464:	01 d0                	add    %edx,%eax
f0106466:	8b 00                	mov    (%eax),%eax
f0106468:	85 c0                	test   %eax,%eax
f010646a:	0f 84 59 01 00 00    	je     f01065c9 <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106470:	83 ec 08             	sub    $0x8,%esp
f0106473:	ff 75 f0             	pushl  -0x10(%ebp)
f0106476:	68 bc 5a 12 f0       	push   $0xf0125abc
f010647b:	e8 0b ab ff ff       	call   f0100f8b <cprintf>
f0106480:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106483:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106488:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010648b:	c1 e2 04             	shl    $0x4,%edx
f010648e:	01 d0                	add    %edx,%eax
f0106490:	8b 00                	mov    (%eax),%eax
f0106492:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106495:	e9 f5 00 00 00       	jmp    f010658f <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010649a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010649d:	8d 50 20             	lea    0x20(%eax),%edx
f01064a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064a3:	8b 40 10             	mov    0x10(%eax),%eax
f01064a6:	83 ec 04             	sub    $0x4,%esp
f01064a9:	52                   	push   %edx
f01064aa:	50                   	push   %eax
f01064ab:	68 8c 5a 12 f0       	push   $0xf0125a8c
f01064b0:	e8 d6 aa ff ff       	call   f0100f8b <cprintf>
f01064b5:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01064b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01064bc:	75 17                	jne    f01064d5 <sched_kill_all+0x160>
f01064be:	83 ec 04             	sub    $0x4,%esp
f01064c1:	68 3f 57 12 f0       	push   $0xf012573f
f01064c6:	68 49 02 00 00       	push   $0x249
f01064cb:	68 03 57 12 f0       	push   $0xf0125703
f01064d0:	e8 64 9e ff ff       	call   f0100339 <_panic>
f01064d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064d8:	8b 40 08             	mov    0x8(%eax),%eax
f01064db:	85 c0                	test   %eax,%eax
f01064dd:	74 11                	je     f01064f0 <sched_kill_all+0x17b>
f01064df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064e2:	8b 40 08             	mov    0x8(%eax),%eax
f01064e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01064e8:	8b 52 0c             	mov    0xc(%edx),%edx
f01064eb:	89 50 0c             	mov    %edx,0xc(%eax)
f01064ee:	eb 16                	jmp    f0106506 <sched_kill_all+0x191>
f01064f0:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01064f5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01064f8:	c1 e2 04             	shl    $0x4,%edx
f01064fb:	01 c2                	add    %eax,%edx
f01064fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106500:	8b 40 0c             	mov    0xc(%eax),%eax
f0106503:	89 42 04             	mov    %eax,0x4(%edx)
f0106506:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106509:	8b 40 0c             	mov    0xc(%eax),%eax
f010650c:	85 c0                	test   %eax,%eax
f010650e:	74 11                	je     f0106521 <sched_kill_all+0x1ac>
f0106510:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106513:	8b 40 0c             	mov    0xc(%eax),%eax
f0106516:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106519:	8b 52 08             	mov    0x8(%edx),%edx
f010651c:	89 50 08             	mov    %edx,0x8(%eax)
f010651f:	eb 15                	jmp    f0106536 <sched_kill_all+0x1c1>
f0106521:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106526:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106529:	c1 e2 04             	shl    $0x4,%edx
f010652c:	01 c2                	add    %eax,%edx
f010652e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106531:	8b 40 08             	mov    0x8(%eax),%eax
f0106534:	89 02                	mov    %eax,(%edx)
f0106536:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106539:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106540:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106543:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010654a:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010654f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106552:	c1 e2 04             	shl    $0x4,%edx
f0106555:	01 d0                	add    %edx,%eax
f0106557:	8b 50 0c             	mov    0xc(%eax),%edx
f010655a:	4a                   	dec    %edx
f010655b:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f010655e:	83 ec 0c             	sub    $0xc,%esp
f0106561:	ff 75 f4             	pushl  -0xc(%ebp)
f0106564:	e8 74 57 00 00       	call   f010bcdd <env_free>
f0106569:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f010656c:	83 ec 0c             	sub    $0xc,%esp
f010656f:	68 c6 58 12 f0       	push   $0xf01258c6
f0106574:	e8 12 aa ff ff       	call   f0100f8b <cprintf>
f0106579:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010657c:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106581:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106584:	c1 e2 04             	shl    $0x4,%edx
f0106587:	01 d0                	add    %edx,%eax
f0106589:	8b 40 08             	mov    0x8(%eax),%eax
f010658c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010658f:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106594:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106597:	c1 e2 04             	shl    $0x4,%edx
f010659a:	01 d0                	add    %edx,%eax
f010659c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065a0:	74 08                	je     f01065aa <sched_kill_all+0x235>
f01065a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01065a5:	8b 52 08             	mov    0x8(%edx),%edx
f01065a8:	eb 05                	jmp    f01065af <sched_kill_all+0x23a>
f01065aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01065af:	89 50 08             	mov    %edx,0x8(%eax)
f01065b2:	8b 40 08             	mov    0x8(%eax),%eax
f01065b5:	85 c0                	test   %eax,%eax
f01065b7:	0f 85 dd fe ff ff    	jne    f010649a <sched_kill_all+0x125>
f01065bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065c1:	0f 85 d3 fe ff ff    	jne    f010649a <sched_kill_all+0x125>
f01065c7:	eb 13                	jmp    f01065dc <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01065c9:	83 ec 08             	sub    $0x8,%esp
f01065cc:	ff 75 f0             	pushl  -0x10(%ebp)
f01065cf:	68 c0 59 12 f0       	push   $0xf01259c0
f01065d4:	e8 b2 a9 ff ff       	call   f0100f8b <cprintf>
f01065d9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f01065dc:	83 ec 0c             	sub    $0xc,%esp
f01065df:	68 64 59 12 f0       	push   $0xf0125964
f01065e4:	e8 a2 a9 ff ff       	call   f0100f8b <cprintf>
f01065e9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01065ec:	ff 45 f0             	incl   -0x10(%ebp)
f01065ef:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f01065f4:	0f b6 c0             	movzbl %al,%eax
f01065f7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01065fa:	0f 8f 59 fe ff ff    	jg     f0106459 <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106600:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0106605:	85 c0                	test   %eax,%eax
f0106607:	0f 84 95 00 00 00    	je     f01066a2 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f010660d:	83 ec 0c             	sub    $0xc,%esp
f0106610:	68 f0 5a 12 f0       	push   $0xf0125af0
f0106615:	e8 71 a9 ff ff       	call   f0100f8b <cprintf>
f010661a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f010661d:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f0106622:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106625:	eb 52                	jmp    f0106679 <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106627:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010662a:	8d 50 20             	lea    0x20(%eax),%edx
f010662d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106630:	8b 40 10             	mov    0x10(%eax),%eax
f0106633:	83 ec 04             	sub    $0x4,%esp
f0106636:	52                   	push   %edx
f0106637:	50                   	push   %eax
f0106638:	68 8c 5a 12 f0       	push   $0xf0125a8c
f010663d:	e8 49 a9 ff ff       	call   f0100f8b <cprintf>
f0106642:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f0106645:	83 ec 0c             	sub    $0xc,%esp
f0106648:	ff 75 f4             	pushl  -0xc(%ebp)
f010664b:	e8 47 f2 ff ff       	call   f0105897 <sched_remove_exit>
f0106650:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106653:	83 ec 0c             	sub    $0xc,%esp
f0106656:	ff 75 f4             	pushl  -0xc(%ebp)
f0106659:	e8 7f 56 00 00       	call   f010bcdd <env_free>
f010665e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106661:	83 ec 0c             	sub    $0xc,%esp
f0106664:	68 c6 58 12 f0       	push   $0xf01258c6
f0106669:	e8 1d a9 ff ff       	call   f0100f8b <cprintf>
f010666e:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106671:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0106676:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106679:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010667d:	74 08                	je     f0106687 <sched_kill_all+0x312>
f010667f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106682:	8b 40 08             	mov    0x8(%eax),%eax
f0106685:	eb 05                	jmp    f010668c <sched_kill_all+0x317>
f0106687:	b8 00 00 00 00       	mov    $0x0,%eax
f010668c:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f0106691:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0106696:	85 c0                	test   %eax,%eax
f0106698:	75 8d                	jne    f0106627 <sched_kill_all+0x2b2>
f010669a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010669e:	75 87                	jne    f0106627 <sched_kill_all+0x2b2>
f01066a0:	eb 10                	jmp    f01066b2 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01066a2:	83 ec 0c             	sub    $0xc,%esp
f01066a5:	68 06 5a 12 f0       	push   $0xf0125a06
f01066aa:	e8 dc a8 ff ff       	call   f0100f8b <cprintf>
f01066af:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01066b2:	e8 6e 56 00 00       	call   f010bd25 <get_cpu_proc>
f01066b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01066ba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01066be:	74 6b                	je     f010672b <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01066c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01066c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01066c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066c9:	8b 40 18             	mov    0x18(%eax),%eax
f01066cc:	83 f8 02             	cmp    $0x2,%eax
f01066cf:	74 19                	je     f01066ea <sched_kill_all+0x375>
f01066d1:	68 cc 58 12 f0       	push   $0xf01258cc
f01066d6:	68 ee 56 12 f0       	push   $0xf01256ee
f01066db:	68 69 02 00 00       	push   $0x269
f01066e0:	68 03 57 12 f0       	push   $0xf0125703
f01066e5:	e8 4f 9c ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01066ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066ed:	8d 50 20             	lea    0x20(%eax),%edx
f01066f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066f3:	8b 40 10             	mov    0x10(%eax),%eax
f01066f6:	83 ec 04             	sub    $0x4,%esp
f01066f9:	52                   	push   %edx
f01066fa:	50                   	push   %eax
f01066fb:	68 f0 58 12 f0       	push   $0xf01258f0
f0106700:	e8 86 a8 ff ff       	call   f0100f8b <cprintf>
f0106705:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f0106708:	83 ec 0c             	sub    $0xc,%esp
f010670b:	ff 75 f4             	pushl  -0xc(%ebp)
f010670e:	e8 ca 55 00 00       	call   f010bcdd <env_free>
f0106713:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0106716:	83 ec 0c             	sub    $0xc,%esp
f0106719:	68 c6 58 12 f0       	push   $0xf01258c6
f010671e:	e8 68 a8 ff ff       	call   f0100f8b <cprintf>
f0106723:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f0106726:	e8 7b 57 00 00       	call   f010bea6 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010672b:	83 ec 0c             	sub    $0xc,%esp
f010672e:	68 80 f0 71 f0       	push   $0xf071f080
f0106733:	e8 03 99 00 00       	call   f011003b <release_spinlock>
f0106738:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f010673b:	e8 82 b6 ff ff       	call   f0101dc2 <get_into_prompt>

f0106740 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0106740:	55                   	push   %ebp
f0106741:	89 e5                	mov    %esp,%ebp
f0106743:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106746:	83 ec 0c             	sub    $0xc,%esp
f0106749:	68 80 f0 71 f0       	push   $0xf071f080
f010674e:	e8 61 98 00 00       	call   f010ffb4 <acquire_spinlock>
f0106753:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106756:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010675d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106764:	e9 37 01 00 00       	jmp    f01068a0 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106769:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010676e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106771:	c1 e2 04             	shl    $0x4,%edx
f0106774:	01 d0                	add    %edx,%eax
f0106776:	8b 00                	mov    (%eax),%eax
f0106778:	85 c0                	test   %eax,%eax
f010677a:	0f 84 1d 01 00 00    	je     f010689d <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106780:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106787:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010678c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010678f:	c1 e2 04             	shl    $0x4,%edx
f0106792:	01 d0                	add    %edx,%eax
f0106794:	8b 00                	mov    (%eax),%eax
f0106796:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106799:	e9 c7 00 00 00       	jmp    f0106865 <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010679e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01067a2:	75 17                	jne    f01067bb <sched_exit_all_ready_envs+0x7b>
f01067a4:	83 ec 04             	sub    $0x4,%esp
f01067a7:	68 3f 57 12 f0       	push   $0xf012573f
f01067ac:	68 8b 02 00 00       	push   $0x28b
f01067b1:	68 03 57 12 f0       	push   $0xf0125703
f01067b6:	e8 7e 9b ff ff       	call   f0100339 <_panic>
f01067bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067be:	8b 40 08             	mov    0x8(%eax),%eax
f01067c1:	85 c0                	test   %eax,%eax
f01067c3:	74 11                	je     f01067d6 <sched_exit_all_ready_envs+0x96>
f01067c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067c8:	8b 40 08             	mov    0x8(%eax),%eax
f01067cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01067ce:	8b 52 0c             	mov    0xc(%edx),%edx
f01067d1:	89 50 0c             	mov    %edx,0xc(%eax)
f01067d4:	eb 16                	jmp    f01067ec <sched_exit_all_ready_envs+0xac>
f01067d6:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f01067db:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01067de:	c1 e2 04             	shl    $0x4,%edx
f01067e1:	01 c2                	add    %eax,%edx
f01067e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067e6:	8b 40 0c             	mov    0xc(%eax),%eax
f01067e9:	89 42 04             	mov    %eax,0x4(%edx)
f01067ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067ef:	8b 40 0c             	mov    0xc(%eax),%eax
f01067f2:	85 c0                	test   %eax,%eax
f01067f4:	74 11                	je     f0106807 <sched_exit_all_ready_envs+0xc7>
f01067f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067f9:	8b 40 0c             	mov    0xc(%eax),%eax
f01067fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01067ff:	8b 52 08             	mov    0x8(%edx),%edx
f0106802:	89 50 08             	mov    %edx,0x8(%eax)
f0106805:	eb 15                	jmp    f010681c <sched_exit_all_ready_envs+0xdc>
f0106807:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010680c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010680f:	c1 e2 04             	shl    $0x4,%edx
f0106812:	01 c2                	add    %eax,%edx
f0106814:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106817:	8b 40 08             	mov    0x8(%eax),%eax
f010681a:	89 02                	mov    %eax,(%edx)
f010681c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010681f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106826:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106829:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106830:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106835:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106838:	c1 e2 04             	shl    $0x4,%edx
f010683b:	01 d0                	add    %edx,%eax
f010683d:	8b 50 0c             	mov    0xc(%eax),%edx
f0106840:	4a                   	dec    %edx
f0106841:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f0106844:	83 ec 0c             	sub    $0xc,%esp
f0106847:	ff 75 f4             	pushl  -0xc(%ebp)
f010684a:	e8 c1 ef ff ff       	call   f0105810 <sched_insert_exit>
f010684f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106852:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106857:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010685a:	c1 e2 04             	shl    $0x4,%edx
f010685d:	01 d0                	add    %edx,%eax
f010685f:	8b 40 08             	mov    0x8(%eax),%eax
f0106862:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106865:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f010686a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010686d:	c1 e2 04             	shl    $0x4,%edx
f0106870:	01 d0                	add    %edx,%eax
f0106872:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106876:	74 08                	je     f0106880 <sched_exit_all_ready_envs+0x140>
f0106878:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010687b:	8b 52 08             	mov    0x8(%edx),%edx
f010687e:	eb 05                	jmp    f0106885 <sched_exit_all_ready_envs+0x145>
f0106880:	ba 00 00 00 00       	mov    $0x0,%edx
f0106885:	89 50 08             	mov    %edx,0x8(%eax)
f0106888:	8b 40 08             	mov    0x8(%eax),%eax
f010688b:	85 c0                	test   %eax,%eax
f010688d:	0f 85 0b ff ff ff    	jne    f010679e <sched_exit_all_ready_envs+0x5e>
f0106893:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106897:	0f 85 01 ff ff ff    	jne    f010679e <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010689d:	ff 45 f0             	incl   -0x10(%ebp)
f01068a0:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f01068a5:	0f b6 c0             	movzbl %al,%eax
f01068a8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01068ab:	0f 8f b8 fe ff ff    	jg     f0106769 <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01068b1:	83 ec 0c             	sub    $0xc,%esp
f01068b4:	68 80 f0 71 f0       	push   $0xf071f080
f01068b9:	e8 7d 97 00 00       	call   f011003b <release_spinlock>
f01068be:	83 c4 10             	add    $0x10,%esp
}
f01068c1:	90                   	nop
f01068c2:	c9                   	leave  
f01068c3:	c3                   	ret    

f01068c4 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01068c4:	55                   	push   %ebp
f01068c5:	89 e5                	mov    %esp,%ebp
	return ticks;
f01068c7:	a1 28 f7 b1 f0       	mov    0xf0b1f728,%eax
f01068cc:	8b 15 2c f7 b1 f0    	mov    0xf0b1f72c,%edx
}
f01068d2:	5d                   	pop    %ebp
f01068d3:	c3                   	ret    

f01068d4 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01068d4:	55                   	push   %ebp
f01068d5:	89 e5                	mov    %esp,%ebp
f01068d7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01068da:	83 ec 04             	sub    $0x4,%esp
f01068dd:	68 1c 5b 12 f0       	push   $0xf0125b1c
f01068e2:	68 9e 02 00 00       	push   $0x29e
f01068e7:	68 03 57 12 f0       	push   $0xf0125703
f01068ec:	e8 48 9a ff ff       	call   f0100339 <_panic>

f01068f1 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f01068f1:	55                   	push   %ebp
f01068f2:	89 e5                	mov    %esp,%ebp
f01068f4:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01068f7:	83 ec 04             	sub    $0x4,%esp
f01068fa:	68 1c 5b 12 f0       	push   $0xf0125b1c
f01068ff:	68 a6 02 00 00       	push   $0x2a6
f0106904:	68 03 57 12 f0       	push   $0xf0125703
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>

f010690e <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f010690e:	55                   	push   %ebp
f010690f:	89 e5                	mov    %esp,%ebp
f0106911:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106914:	83 ec 04             	sub    $0x4,%esp
f0106917:	68 1c 5b 12 f0       	push   $0xf0125b1c
f010691c:	68 ae 02 00 00       	push   $0x2ae
f0106921:	68 03 57 12 f0       	push   $0xf0125703
f0106926:	e8 0e 9a ff ff       	call   f0100339 <_panic>

f010692b <get_load_average>:
}
int get_load_average()
{
f010692b:	55                   	push   %ebp
f010692c:	89 e5                	mov    %esp,%ebp
f010692e:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106931:	83 ec 04             	sub    $0x4,%esp
f0106934:	68 1c 5b 12 f0       	push   $0xf0125b1c
f0106939:	68 b6 02 00 00       	push   $0x2b6
f010693e:	68 03 57 12 f0       	push   $0xf0125703
f0106943:	e8 f1 99 ff ff       	call   f0100339 <_panic>

f0106948 <env_set_priority>:
//==================================================================================//

/*2024*/
/********* for Priority RR Scheduler *************/
void env_set_priority(int envID, int priority)
{
f0106948:	55                   	push   %ebp
f0106949:	89 e5                	mov    %esp,%ebp
f010694b:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS3 - #06] [3] PRIORITY RR Scheduler - env_set_priority

	//Get the process of the given ID
	struct Env* proc ;
	envid2env(envID, &proc, 0);
f010694e:	83 ec 04             	sub    $0x4,%esp
f0106951:	6a 00                	push   $0x0
f0106953:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0106956:	50                   	push   %eax
f0106957:	ff 75 08             	pushl  0x8(%ebp)
f010695a:	e8 16 54 00 00       	call   f010bd75 <envid2env>
f010695f:	83 c4 10             	add    $0x10,%esp

	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106962:	83 ec 04             	sub    $0x4,%esp
f0106965:	68 1c 5b 12 f0       	push   $0xf0125b1c
f010696a:	68 c8 02 00 00       	push   $0x2c8
f010696f:	68 03 57 12 f0       	push   $0xf0125703
f0106974:	e8 c0 99 ff ff       	call   f0100339 <_panic>

f0106979 <sched_set_starv_thresh>:
}

void sched_set_starv_thresh(uint32 starvThresh)
{
f0106979:	55                   	push   %ebp
f010697a:	89 e5                	mov    %esp,%ebp
f010697c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS3 - #06] [3] PRIORITY RR Scheduler - sched_set_starv_thresh
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010697f:	83 ec 04             	sub    $0x4,%esp
f0106982:	68 1c 5b 12 f0       	push   $0xf0125b1c
f0106987:	68 d0 02 00 00       	push   $0x2d0
f010698c:	68 03 57 12 f0       	push   $0xf0125703
f0106991:	e8 a3 99 ff ff       	call   f0100339 <_panic>

f0106996 <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){return (scheduler_method == SCH_RR);}
f0106996:	55                   	push   %ebp
f0106997:	89 e5                	mov    %esp,%ebp
f0106999:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f010699e:	85 c0                	test   %eax,%eax
f01069a0:	0f 94 c0             	sete   %al
f01069a3:	0f b6 c0             	movzbl %al,%eax
f01069a6:	5d                   	pop    %ebp
f01069a7:	c3                   	ret    

f01069a8 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){return (scheduler_method == SCH_MLFQ); }
f01069a8:	55                   	push   %ebp
f01069a9:	89 e5                	mov    %esp,%ebp
f01069ab:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f01069b0:	83 f8 01             	cmp    $0x1,%eax
f01069b3:	0f 94 c0             	sete   %al
f01069b6:	0f b6 c0             	movzbl %al,%eax
f01069b9:	5d                   	pop    %ebp
f01069ba:	c3                   	ret    

f01069bb <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){return(scheduler_method == SCH_BSD); }
f01069bb:	55                   	push   %ebp
f01069bc:	89 e5                	mov    %esp,%ebp
f01069be:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f01069c3:	83 f8 02             	cmp    $0x2,%eax
f01069c6:	0f 94 c0             	sete   %al
f01069c9:	0f b6 c0             	movzbl %al,%eax
f01069cc:	5d                   	pop    %ebp
f01069cd:	c3                   	ret    

f01069ce <isSchedMethodPRIRR>:
uint32 isSchedMethodPRIRR(){return(scheduler_method == SCH_PRIRR); }
f01069ce:	55                   	push   %ebp
f01069cf:	89 e5                	mov    %esp,%ebp
f01069d1:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f01069d6:	83 f8 03             	cmp    $0x3,%eax
f01069d9:	0f 94 c0             	sete   %al
f01069dc:	0f b6 c0             	movzbl %al,%eax
f01069df:	5d                   	pop    %ebp
f01069e0:	c3                   	ret    

f01069e1 <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f01069e1:	55                   	push   %ebp
f01069e2:	89 e5                	mov    %esp,%ebp
f01069e4:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f01069e7:	c7 05 58 f2 b1 f0 00 	movl   $0x0,0xf0b1f258
f01069ee:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f01069f1:	83 ec 0c             	sub    $0xc,%esp
f01069f4:	6a 0a                	push   $0xa
f01069f6:	e8 66 02 00 00       	call   f0106c61 <sched_init_RR>
f01069fb:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	68 f0 f0 71 f0       	push   $0xf071f0f0
f0106a06:	e8 4c e7 ff ff       	call   f0105157 <init_queue>
f0106a0b:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f0106a0e:	83 ec 0c             	sub    $0xc,%esp
f0106a11:	68 00 f1 71 f0       	push   $0xf071f100
f0106a16:	e8 3c e7 ff ff       	call   f0105157 <init_queue>
f0106a1b:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0106a1e:	e8 14 0a 00 00       	call   f0107437 <mycpu>
f0106a23:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a2a:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106a2d:	83 ec 08             	sub    $0x8,%esp
f0106a30:	68 30 5b 12 f0       	push   $0xf0125b30
f0106a35:	68 80 f0 71 f0       	push   $0xf071f080
f0106a3a:	e8 44 95 00 00       	call   f010ff83 <init_spinlock>
f0106a3f:	83 c4 10             	add    $0x10,%esp
}
f0106a42:	90                   	nop
f0106a43:	c9                   	leave  
f0106a44:	c3                   	ret    

f0106a45 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106a45:	55                   	push   %ebp
f0106a46:	89 e5                	mov    %esp,%ebp
f0106a48:	53                   	push   %ebx
f0106a49:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106a4c:	9c                   	pushf  
f0106a4d:	58                   	pop    %eax
f0106a4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0106a51:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f0106a54:	25 00 02 00 00       	and    $0x200,%eax
f0106a59:	85 c0                	test   %eax,%eax
f0106a5b:	74 14                	je     f0106a71 <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f0106a5d:	83 ec 04             	sub    $0x4,%esp
f0106a60:	68 44 5b 12 f0       	push   $0xf0125b44
f0106a65:	6a 3a                	push   $0x3a
f0106a67:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106a6c:	e8 c8 98 ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f0106a71:	e8 c1 09 00 00       	call   f0107437 <mycpu>
f0106a76:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f0106a79:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106a7c:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0106a83:	00 00 00 

	chk1();
f0106a86:	e8 93 86 01 00       	call   f011f11e <chk1>
	c->scheduler_status = SCH_STARTED;
f0106a8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106a8e:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0106a95:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106a98:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f0106a9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106aa6:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106aa7:	83 ec 0c             	sub    $0xc,%esp
f0106aaa:	68 80 f0 71 f0       	push   $0xf071f080
f0106aaf:	e8 00 95 00 00       	call   f010ffb4 <acquire_spinlock>
f0106ab4:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106ab7:	a1 74 f5 b1 f0       	mov    0xf0b1f574,%eax
f0106abc:	8b 04 85 7c 09 18 f0 	mov    -0xfe7f684(,%eax,4),%eax
f0106ac3:	ff d0                	call   *%eax
f0106ac5:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106ac8:	e8 58 52 00 00       	call   f010bd25 <get_cpu_proc>
f0106acd:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f0106ad0:	83 ec 0c             	sub    $0xc,%esp
f0106ad3:	ff 75 e8             	pushl  -0x18(%ebp)
f0106ad6:	e8 73 52 00 00       	call   f010bd4e <set_cpu_proc>
f0106adb:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f0106ade:	83 ec 0c             	sub    $0xc,%esp
f0106ae1:	ff 75 e8             	pushl  -0x18(%ebp)
f0106ae4:	e8 3b 86 01 00       	call   f011f124 <chk2>
f0106ae9:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106aec:	83 ec 0c             	sub    $0xc,%esp
f0106aef:	ff 75 e0             	pushl  -0x20(%ebp)
f0106af2:	e8 57 52 00 00       	call   f010bd4e <set_cpu_proc>
f0106af7:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106afa:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106afe:	0f 84 dc 00 00 00    	je     f0106be0 <fos_scheduler+0x19b>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106b04:	83 ec 0c             	sub    $0xc,%esp
f0106b07:	ff 75 e8             	pushl  -0x18(%ebp)
f0106b0a:	e8 3f 52 00 00       	call   f010bd4e <set_cpu_proc>
f0106b0f:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f0106b12:	83 ec 0c             	sub    $0xc,%esp
f0106b15:	ff 75 e8             	pushl  -0x18(%ebp)
f0106b18:	e8 ac 54 00 00       	call   f010bfc9 <switchuvm>
f0106b1d:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f0106b20:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106b23:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106b2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106b2d:	8b 40 04             	mov    0x4(%eax),%eax
f0106b30:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106b33:	83 c2 04             	add    $0x4,%edx
f0106b36:	83 ec 08             	sub    $0x8,%esp
f0106b39:	50                   	push   %eax
f0106b3a:	52                   	push   %edx
f0106b3b:	e8 1f e2 ff ff       	call   f0104d5f <context_switch>
f0106b40:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106b43:	9c                   	pushf  
f0106b44:	58                   	pop    %eax
f0106b45:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106b48:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106b4b:	25 00 02 00 00       	and    $0x200,%eax
f0106b50:	85 c0                	test   %eax,%eax
f0106b52:	74 14                	je     f0106b68 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f0106b54:	83 ec 04             	sub    $0x4,%esp
f0106b57:	68 8c 5b 12 f0       	push   $0xf0125b8c
f0106b5c:	6a 77                	push   $0x77
f0106b5e:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106b63:	e8 d1 97 ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f0106b68:	e8 3b e3 ff ff       	call   f0104ea8 <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f0106b6d:	e8 b3 51 00 00       	call   f010bd25 <get_cpu_proc>
f0106b72:	89 c2                	mov    %eax,%edx
f0106b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106b77:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106b7d:	39 c2                	cmp    %eax,%edx
f0106b7f:	74 19                	je     f0106b9a <fos_scheduler+0x155>
f0106b81:	68 c3 5b 12 f0       	push   $0xf0125bc3
f0106b86:	68 dd 5b 12 f0       	push   $0xf0125bdd
f0106b8b:	68 80 00 00 00       	push   $0x80
f0106b90:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106b95:	e8 9f 97 ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f0106b9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106b9d:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106ba3:	8b 40 18             	mov    0x18(%eax),%eax
f0106ba6:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f0106ba9:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106bad:	75 19                	jne    f0106bc8 <fos_scheduler+0x183>
f0106baf:	68 f2 5b 12 f0       	push   $0xf0125bf2
f0106bb4:	68 dd 5b 12 f0       	push   $0xf0125bdd
f0106bb9:	68 82 00 00 00       	push   $0x82
f0106bbe:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106bc3:	e8 71 97 ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f0106bc8:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106bcc:	74 12                	je     f0106be0 <fos_scheduler+0x19b>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106bce:	e8 df 53 00 00       	call   f010bfb2 <switchkvm>
					set_cpu_proc(NULL);
f0106bd3:	83 ec 0c             	sub    $0xc,%esp
f0106bd6:	6a 00                	push   $0x0
f0106bd8:	e8 71 51 00 00       	call   f010bd4e <set_cpu_proc>
f0106bdd:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106be0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106be4:	0f 85 cd fe ff ff    	jne    f0106ab7 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106bea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106bf1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106bf8:	eb 3e                	jmp    f0106c38 <fos_scheduler+0x1f3>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106bfa:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f0106c00:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106c03:	89 d0                	mov    %edx,%eax
f0106c05:	c1 e0 03             	shl    $0x3,%eax
f0106c08:	01 d0                	add    %edx,%eax
f0106c0a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106c11:	01 d8                	add    %ebx,%eax
f0106c13:	01 c0                	add    %eax,%eax
f0106c15:	01 d0                	add    %edx,%eax
f0106c17:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106c1e:	01 d8                	add    %ebx,%eax
f0106c20:	01 d0                	add    %edx,%eax
f0106c22:	01 c8                	add    %ecx,%eax
f0106c24:	8b 40 18             	mov    0x18(%eax),%eax
f0106c27:	83 f8 03             	cmp    $0x3,%eax
f0106c2a:	75 09                	jne    f0106c35 <fos_scheduler+0x1f0>
			{
				is_any_blocked = 1;
f0106c2c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106c33:	eb 0d                	jmp    f0106c42 <fos_scheduler+0x1fd>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0106c35:	ff 45 f0             	incl   -0x10(%ebp)
f0106c38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106c3b:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106c40:	76 b8                	jbe    f0106bfa <fos_scheduler+0x1b5>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106c42:	83 ec 0c             	sub    $0xc,%esp
f0106c45:	68 80 f0 71 f0       	push   $0xf071f080
f0106c4a:	e8 ec 93 00 00       	call   f011003b <release_spinlock>
f0106c4f:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106c52:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c56:	0f 8f 4a fe ff ff    	jg     f0106aa6 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f0106c5c:	e8 61 b1 ff ff       	call   f0101dc2 <get_into_prompt>

f0106c61 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f0106c61:	55                   	push   %ebp
f0106c62:	89 e5                	mov    %esp,%ebp
f0106c64:	83 ec 28             	sub    $0x28,%esp
f0106c67:	8b 45 08             	mov    0x8(%ebp),%eax
f0106c6a:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f0106c6d:	c6 05 44 f8 f1 f0 01 	movb   $0x1,0xf0f1f844
#if USE_KHEAP
	sched_delete_ready_queues();
f0106c74:	e8 8e e7 ff ff       	call   f0105407 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f0106c79:	83 ec 0c             	sub    $0xc,%esp
f0106c7c:	6a 10                	push   $0x10
f0106c7e:	e8 4c 2b 00 00       	call   f01097cf <kmalloc>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	a3 10 f1 71 f0       	mov    %eax,0xf071f110
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0106c8b:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f0106c90:	0f b6 c0             	movzbl %al,%eax
f0106c93:	83 ec 0c             	sub    $0xc,%esp
f0106c96:	50                   	push   %eax
f0106c97:	e8 33 2b 00 00       	call   f01097cf <kmalloc>
f0106c9c:	83 c4 10             	add    $0x10,%esp
f0106c9f:	a3 44 f4 b1 f0       	mov    %eax,0xf0b1f444
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f0106ca4:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0106ca9:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0106cac:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0106cae:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0106cb3:	8a 00                	mov    (%eax),%al
f0106cb5:	0f b6 c0             	movzbl %al,%eax
f0106cb8:	83 ec 0c             	sub    $0xc,%esp
f0106cbb:	50                   	push   %eax
f0106cbc:	e8 b0 e2 ff ff       	call   f0104f71 <kclock_set_quantum>
f0106cc1:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106cc4:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106cc9:	83 ec 0c             	sub    $0xc,%esp
f0106ccc:	50                   	push   %eax
f0106ccd:	e8 85 e4 ff ff       	call   f0105157 <init_queue>
f0106cd2:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106cd5:	e8 f6 e3 ff ff       	call   f01050d0 <kclock_read_cnt0_latch>
f0106cda:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106cde:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106ce2:	83 ec 08             	sub    $0x8,%esp
f0106ce5:	50                   	push   %eax
f0106ce6:	68 08 5c 12 f0       	push   $0xf0125c08
f0106ceb:	e8 9b a2 ff ff       	call   f0100f8b <cprintf>
f0106cf0:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106cf3:	e8 3f 07 00 00       	call   f0107437 <mycpu>
f0106cf8:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106cff:	00 00 00 
	scheduler_method = SCH_RR;
f0106d02:	c7 05 74 f5 b1 f0 00 	movl   $0x0,0xf0b1f574
f0106d09:	00 00 00 
	//=========================================
	//=========================================
}
f0106d0c:	90                   	nop
f0106d0d:	c9                   	leave  
f0106d0e:	c3                   	ret    

f0106d0f <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106d0f:	55                   	push   %ebp
f0106d10:	89 e5                	mov    %esp,%ebp
f0106d12:	83 ec 18             	sub    $0x18,%esp
f0106d15:	8b 45 08             	mov    0x8(%ebp),%eax
f0106d18:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106d1b:	e8 e7 e6 ff ff       	call   f0105407 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106d20:	83 ec 04             	sub    $0x4,%esp
f0106d23:	68 30 5c 12 f0       	push   $0xf0125c30
f0106d28:	68 d1 00 00 00       	push   $0xd1
f0106d2d:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106d32:	e8 02 96 ff ff       	call   f0100339 <_panic>

f0106d37 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106d37:	55                   	push   %ebp
f0106d38:	89 e5                	mov    %esp,%ebp
f0106d3a:	83 ec 18             	sub    $0x18,%esp
f0106d3d:	8b 55 08             	mov    0x8(%ebp),%edx
f0106d40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106d43:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106d46:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106d49:	83 ec 04             	sub    $0x4,%esp
f0106d4c:	68 30 5c 12 f0       	push   $0xf0125c30
f0106d51:	68 e7 00 00 00       	push   $0xe7
f0106d56:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106d5b:	e8 d9 95 ff ff       	call   f0100339 <_panic>

f0106d60 <sched_init_PRIRR>:

//======================================
// [6] Initialize PRIORITY RR Scheduler:
//======================================
void sched_init_PRIRR(uint8 numOfPriorities, uint8 quantum, uint32 starvThresh)
{
f0106d60:	55                   	push   %ebp
f0106d61:	89 e5                	mov    %esp,%ebp
f0106d63:	83 ec 18             	sub    $0x18,%esp
f0106d66:	8b 55 08             	mov    0x8(%ebp),%edx
f0106d69:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106d6c:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106d6f:	88 45 f0             	mov    %al,-0x10(%ebp)
	//TODO: [PROJECT'24.MS3 - #07] [3] PRIORITY RR Scheduler - sched_init_PRIRR
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106d72:	83 ec 04             	sub    $0x4,%esp
f0106d75:	68 30 5c 12 f0       	push   $0xf0125c30
f0106d7a:	68 fc 00 00 00       	push   $0xfc
f0106d7f:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106d84:	e8 b0 95 ff ff       	call   f0100339 <_panic>

f0106d89 <fos_scheduler_RR>:

//=========================
// [7] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106d89:	55                   	push   %ebp
f0106d8a:	89 e5                	mov    %esp,%ebp
f0106d8c:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106d8f:	83 ec 0c             	sub    $0xc,%esp
f0106d92:	68 80 f0 71 f0       	push   $0xf071f080
f0106d97:	e8 31 94 00 00       	call   f01101cd <holding_spinlock>
f0106d9c:	83 c4 10             	add    $0x10,%esp
f0106d9f:	85 c0                	test   %eax,%eax
f0106da1:	75 17                	jne    f0106dba <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106da3:	83 ec 04             	sub    $0x4,%esp
f0106da6:	68 44 5c 12 f0       	push   $0xf0125c44
f0106dab:	68 1c 01 00 00       	push   $0x11c
f0106db0:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106db5:	e8 7f 95 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106dba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106dc1:	e8 5f 4f 00 00       	call   f010bd25 <get_cpu_proc>
f0106dc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106dc9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106dcd:	74 14                	je     f0106de3 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106dcf:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106dd4:	83 ec 08             	sub    $0x8,%esp
f0106dd7:	ff 75 f0             	pushl  -0x10(%ebp)
f0106dda:	50                   	push   %eax
f0106ddb:	e8 b8 e3 ff ff       	call   f0105198 <enqueue>
f0106de0:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106de3:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f0106de8:	83 ec 0c             	sub    $0xc,%esp
f0106deb:	50                   	push   %eax
f0106dec:	e8 38 e4 ff ff       	call   f0105229 <dequeue>
f0106df1:	83 c4 10             	add    $0x10,%esp
f0106df4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106df7:	a1 44 f4 b1 f0       	mov    0xf0b1f444,%eax
f0106dfc:	8a 00                	mov    (%eax),%al
f0106dfe:	0f b6 c0             	movzbl %al,%eax
f0106e01:	83 ec 0c             	sub    $0xc,%esp
f0106e04:	50                   	push   %eax
f0106e05:	e8 67 e1 ff ff       	call   f0104f71 <kclock_set_quantum>
f0106e0a:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106e0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106e10:	c9                   	leave  
f0106e11:	c3                   	ret    

f0106e12 <fos_scheduler_MLFQ>:

//=========================
// [8] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106e12:	55                   	push   %ebp
f0106e13:	89 e5                	mov    %esp,%ebp
f0106e15:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106e18:	83 ec 0c             	sub    $0xc,%esp
f0106e1b:	68 80 f0 71 f0       	push   $0xf071f080
f0106e20:	e8 a8 93 00 00       	call   f01101cd <holding_spinlock>
f0106e25:	83 c4 10             	add    $0x10,%esp
f0106e28:	85 c0                	test   %eax,%eax
f0106e2a:	75 17                	jne    f0106e43 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106e2c:	83 ec 04             	sub    $0x4,%esp
f0106e2f:	68 90 5c 12 f0       	push   $0xf0125c90
f0106e34:	68 3b 01 00 00       	push   $0x13b
f0106e39:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106e3e:	e8 f6 94 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106e43:	83 ec 04             	sub    $0x4,%esp
f0106e46:	68 30 5c 12 f0       	push   $0xf0125c30
f0106e4b:	68 41 01 00 00       	push   $0x141
f0106e50:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106e55:	e8 df 94 ff ff       	call   f0100339 <_panic>

f0106e5a <fos_scheduler_BSD>:

//=========================
// [9] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106e5a:	55                   	push   %ebp
f0106e5b:	89 e5                	mov    %esp,%ebp
f0106e5d:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106e60:	83 ec 0c             	sub    $0xc,%esp
f0106e63:	68 80 f0 71 f0       	push   $0xf071f080
f0106e68:	e8 60 93 00 00       	call   f01101cd <holding_spinlock>
f0106e6d:	83 c4 10             	add    $0x10,%esp
f0106e70:	85 c0                	test   %eax,%eax
f0106e72:	75 17                	jne    f0106e8b <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106e74:	83 ec 04             	sub    $0x4,%esp
f0106e77:	68 e0 5c 12 f0       	push   $0xf0125ce0
f0106e7c:	68 4c 01 00 00       	push   $0x14c
f0106e81:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106e86:	e8 ae 94 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106e8b:	83 ec 04             	sub    $0x4,%esp
f0106e8e:	68 30 5c 12 f0       	push   $0xf0125c30
f0106e93:	68 52 01 00 00       	push   $0x152
f0106e98:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106e9d:	e8 97 94 ff ff       	call   f0100339 <_panic>

f0106ea2 <fos_scheduler_PRIRR>:
}
//=============================
// [10] PRIORITY RR Scheduler:
//=============================
struct Env* fos_scheduler_PRIRR()
{
f0106ea2:	55                   	push   %ebp
f0106ea3:	89 e5                	mov    %esp,%ebp
f0106ea5:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106ea8:	83 ec 0c             	sub    $0xc,%esp
f0106eab:	68 80 f0 71 f0       	push   $0xf071f080
f0106eb0:	e8 18 93 00 00       	call   f01101cd <holding_spinlock>
f0106eb5:	83 c4 10             	add    $0x10,%esp
f0106eb8:	85 c0                	test   %eax,%eax
f0106eba:	75 17                	jne    f0106ed3 <fos_scheduler_PRIRR+0x31>
		panic("fos_scheduler_PRIRR: q.lock is not held by this CPU while it's expected to be.");
f0106ebc:	83 ec 04             	sub    $0x4,%esp
f0106ebf:	68 30 5d 12 f0       	push   $0xf0125d30
f0106ec4:	68 5c 01 00 00       	push   $0x15c
f0106ec9:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106ece:	e8 66 94 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	//TODO: [PROJECT'24.MS3 - #08] [3] PRIORITY RR Scheduler - fos_scheduler_PRIRR
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ed3:	83 ec 04             	sub    $0x4,%esp
f0106ed6:	68 30 5c 12 f0       	push   $0xf0125c30
f0106edb:	68 61 01 00 00       	push   $0x161
f0106ee0:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106ee5:	e8 4f 94 ff ff       	call   f0100339 <_panic>

f0106eea <clock_interrupt_handler>:
//========================================
// [11] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106eea:	55                   	push   %ebp
f0106eeb:	89 e5                	mov    %esp,%ebp
f0106eed:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodPRIRR())
f0106ef0:	e8 d9 fa ff ff       	call   f01069ce <isSchedMethodPRIRR>
f0106ef5:	85 c0                	test   %eax,%eax
f0106ef7:	74 17                	je     f0106f10 <clock_interrupt_handler+0x26>
	{
		//TODO: [PROJECT'24.MS3 - #09] [3] PRIORITY RR Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106ef9:	83 ec 04             	sub    $0x4,%esp
f0106efc:	68 30 5c 12 f0       	push   $0xf0125c30
f0106f01:	68 6f 01 00 00       	push   $0x16f
f0106f06:	68 7a 5b 12 f0       	push   $0xf0125b7a
f0106f0b:	e8 29 94 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106f10:	a1 28 f7 b1 f0       	mov    0xf0b1f728,%eax
f0106f15:	8b 15 2c f7 b1 f0    	mov    0xf0b1f72c,%edx
f0106f1b:	83 c0 01             	add    $0x1,%eax
f0106f1e:	83 d2 00             	adc    $0x0,%edx
f0106f21:	a3 28 f7 b1 f0       	mov    %eax,0xf0b1f728
f0106f26:	89 15 2c f7 b1 f0    	mov    %edx,0xf0b1f72c
	struct Env* p = get_cpu_proc();
f0106f2c:	e8 f4 4d 00 00       	call   f010bd25 <get_cpu_proc>
f0106f31:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106f34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f38:	74 30                	je     f0106f6a <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106f3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f3d:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106f43:	8d 50 01             	lea    0x1(%eax),%edx
f0106f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f49:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106f4f:	83 ec 0c             	sub    $0xc,%esp
f0106f52:	6a 01                	push   $0x1
f0106f54:	e8 08 8a 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f0106f59:	83 c4 10             	add    $0x10,%esp
f0106f5c:	85 c0                	test   %eax,%eax
f0106f5e:	74 05                	je     f0106f65 <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106f60:	e8 08 00 00 00       	call   f0106f6d <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106f65:	e8 dd 4e 00 00       	call   f010be47 <yield>
	}
	/*****************************************/
}
f0106f6a:	90                   	nop
f0106f6b:	c9                   	leave  
f0106f6c:	c3                   	ret    

f0106f6d <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106f6d:	55                   	push   %ebp
f0106f6e:	89 e5                	mov    %esp,%ebp
f0106f70:	53                   	push   %ebx
f0106f71:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106f74:	e8 ac 4d 00 00       	call   f010bd25 <get_cpu_proc>
f0106f79:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106f7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106f80:	0f 84 a1 01 00 00    	je     f0107127 <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106f86:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f89:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106f8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106f92:	eb 78                	jmp    f010700c <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106f94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f97:	8b 00                	mov    (%eax),%eax
f0106f99:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106f9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f9f:	8b 40 64             	mov    0x64(%eax),%eax
f0106fa2:	83 ec 08             	sub    $0x8,%esp
f0106fa5:	ff 75 e8             	pushl  -0x18(%ebp)
f0106fa8:	50                   	push   %eax
f0106fa9:	e8 bf 30 00 00       	call   f010a06d <pt_get_page_permissions>
f0106fae:	83 c4 10             	add    $0x10,%esp
f0106fb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	8b 40 08             	mov    0x8(%eax),%eax
f0106fba:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106fbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106fc0:	83 e0 20             	and    $0x20,%eax
f0106fc3:	85 c0                	test   %eax,%eax
f0106fc5:	74 2b                	je     f0106ff2 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106fc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106fca:	c1 e8 02             	shr    $0x2,%eax
f0106fcd:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106fd2:	89 c2                	mov    %eax,%edx
f0106fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fd7:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106fda:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106fdd:	8b 40 64             	mov    0x64(%eax),%eax
f0106fe0:	6a 20                	push   $0x20
f0106fe2:	6a 00                	push   $0x0
f0106fe4:	ff 75 e8             	pushl  -0x18(%ebp)
f0106fe7:	50                   	push   %eax
f0106fe8:	e8 bc 2f 00 00       	call   f0109fa9 <pt_set_page_permissions>
f0106fed:	83 c4 10             	add    $0x10,%esp
f0106ff0:	eb 0e                	jmp    f0107000 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106ff2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106ff5:	c1 e8 02             	shr    $0x2,%eax
f0106ff8:	89 c2                	mov    %eax,%edx
f0106ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ffd:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0107000:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107003:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0107009:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010700c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107010:	74 08                	je     f010701a <update_WS_time_stamps+0xad>
f0107012:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107015:	8b 40 10             	mov    0x10(%eax),%eax
f0107018:	eb 05                	jmp    f010701f <update_WS_time_stamps+0xb2>
f010701a:	b8 00 00 00 00       	mov    $0x0,%eax
f010701f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107022:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0107028:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010702b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0107031:	85 c0                	test   %eax,%eax
f0107033:	0f 85 5b ff ff ff    	jne    f0106f94 <update_WS_time_stamps+0x27>
f0107039:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010703d:	0f 85 51 ff ff ff    	jne    f0106f94 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0107043:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010704a:	e9 ce 00 00 00       	jmp    f010711d <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f010704f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0107052:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107055:	89 d0                	mov    %edx,%eax
f0107057:	01 c0                	add    %eax,%eax
f0107059:	01 d0                	add    %edx,%eax
f010705b:	c1 e0 03             	shl    $0x3,%eax
f010705e:	01 c8                	add    %ecx,%eax
f0107060:	05 b0 00 00 00       	add    $0xb0,%eax
f0107065:	8a 00                	mov    (%eax),%al
f0107067:	3c 01                	cmp    $0x1,%al
f0107069:	0f 84 ab 00 00 00    	je     f010711a <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f010706f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0107072:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107075:	89 d0                	mov    %edx,%eax
f0107077:	01 c0                	add    %eax,%eax
f0107079:	01 d0                	add    %edx,%eax
f010707b:	c1 e0 03             	shl    $0x3,%eax
f010707e:	01 c8                	add    %ecx,%eax
f0107080:	05 ac 00 00 00       	add    $0xac,%eax
f0107085:	8b 00                	mov    (%eax),%eax
f0107087:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f010708a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010708d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107090:	89 d0                	mov    %edx,%eax
f0107092:	01 c0                	add    %eax,%eax
f0107094:	01 d0                	add    %edx,%eax
f0107096:	c1 e0 03             	shl    $0x3,%eax
f0107099:	01 c8                	add    %ecx,%eax
f010709b:	05 b4 00 00 00       	add    $0xb4,%eax
f01070a0:	8b 00                	mov    (%eax),%eax
f01070a2:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f01070a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01070a8:	8b 40 64             	mov    0x64(%eax),%eax
f01070ab:	83 ec 08             	sub    $0x8,%esp
f01070ae:	ff 75 dc             	pushl  -0x24(%ebp)
f01070b1:	50                   	push   %eax
f01070b2:	e8 92 30 00 00       	call   f010a149 <pd_is_table_used>
f01070b7:	83 c4 10             	add    $0x10,%esp
f01070ba:	85 c0                	test   %eax,%eax
f01070bc:	74 3c                	je     f01070fa <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f01070be:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01070c1:	c1 e8 02             	shr    $0x2,%eax
f01070c4:	0d 00 00 00 80       	or     $0x80000000,%eax
f01070c9:	89 c1                	mov    %eax,%ecx
f01070cb:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01070ce:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01070d1:	89 d0                	mov    %edx,%eax
f01070d3:	01 c0                	add    %eax,%eax
f01070d5:	01 d0                	add    %edx,%eax
f01070d7:	c1 e0 03             	shl    $0x3,%eax
f01070da:	01 d8                	add    %ebx,%eax
f01070dc:	05 b4 00 00 00       	add    $0xb4,%eax
f01070e1:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f01070e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01070e6:	8b 40 64             	mov    0x64(%eax),%eax
f01070e9:	83 ec 08             	sub    $0x8,%esp
f01070ec:	ff 75 dc             	pushl  -0x24(%ebp)
f01070ef:	50                   	push   %eax
f01070f0:	e8 78 30 00 00       	call   f010a16d <pd_set_table_unused>
f01070f5:	83 c4 10             	add    $0x10,%esp
f01070f8:	eb 20                	jmp    f010711a <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f01070fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01070fd:	c1 e8 02             	shr    $0x2,%eax
f0107100:	89 c1                	mov    %eax,%ecx
f0107102:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0107105:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107108:	89 d0                	mov    %edx,%eax
f010710a:	01 c0                	add    %eax,%eax
f010710c:	01 d0                	add    %edx,%eax
f010710e:	c1 e0 03             	shl    $0x3,%eax
f0107111:	01 d8                	add    %ebx,%eax
f0107113:	05 b4 00 00 00       	add    $0xb4,%eax
f0107118:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f010711a:	ff 45 f0             	incl   -0x10(%ebp)
f010711d:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0107121:	0f 8e 28 ff ff ff    	jle    f010704f <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0107127:	90                   	nop
f0107128:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010712b:	c9                   	leave  
f010712c:	c3                   	ret    

f010712d <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f010712d:	55                   	push   %ebp
f010712e:	89 e5                	mov    %esp,%ebp
f0107130:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0107133:	c7 05 8c 65 6f f0 01 	movl   $0x1,0xf06f658c
f010713a:	00 00 00 
f010713d:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0107144:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107148:	8a 45 b2             	mov    -0x4e(%ebp),%al
f010714b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010714e:	ee                   	out    %al,(%dx)
f010714f:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0107156:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f010715a:	8a 45 b3             	mov    -0x4d(%ebp),%al
f010715d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107160:	ee                   	out    %al,(%dx)
f0107161:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0107168:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f010716c:	8a 45 b4             	mov    -0x4c(%ebp),%al
f010716f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107172:	ee                   	out    %al,(%dx)
f0107173:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f010717a:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f010717e:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0107181:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107184:	ee                   	out    %al,(%dx)
f0107185:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f010718c:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0107190:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0107193:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107196:	ee                   	out    %al,(%dx)
f0107197:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f010719e:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f01071a2:	8a 45 b7             	mov    -0x49(%ebp),%al
f01071a5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01071a8:	ee                   	out    %al,(%dx)
f01071a9:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f01071b0:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f01071b4:	8a 45 b8             	mov    -0x48(%ebp),%al
f01071b7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01071ba:	ee                   	out    %al,(%dx)
f01071bb:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f01071c2:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f01071c6:	8a 45 b9             	mov    -0x47(%ebp),%al
f01071c9:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01071cc:	ee                   	out    %al,(%dx)
f01071cd:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f01071d4:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f01071d8:	8a 45 ba             	mov    -0x46(%ebp),%al
f01071db:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01071de:	ee                   	out    %al,(%dx)
f01071df:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f01071e6:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f01071ea:	8a 45 bb             	mov    -0x45(%ebp),%al
f01071ed:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01071f0:	ee                   	out    %al,(%dx)
f01071f1:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f01071f8:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f01071fc:	8a 45 bc             	mov    -0x44(%ebp),%al
f01071ff:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0107202:	ee                   	out    %al,(%dx)
f0107203:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f010720a:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f010720e:	8a 45 bd             	mov    -0x43(%ebp),%al
f0107211:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0107214:	ee                   	out    %al,(%dx)
f0107215:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f010721c:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0107220:	8a 45 be             	mov    -0x42(%ebp),%al
f0107223:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0107226:	ee                   	out    %al,(%dx)
f0107227:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f010722e:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0107232:	8a 45 bf             	mov    -0x41(%ebp),%al
f0107235:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0107238:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0107239:	66 a1 8c 09 18 f0    	mov    0xf018098c,%ax
f010723f:	66 83 f8 ff          	cmp    $0xffff,%ax
f0107243:	74 15                	je     f010725a <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0107245:	66 a1 8c 09 18 f0    	mov    0xf018098c,%ax
f010724b:	0f b7 c0             	movzwl %ax,%eax
f010724e:	83 ec 0c             	sub    $0xc,%esp
f0107251:	50                   	push   %eax
f0107252:	e8 06 00 00 00       	call   f010725d <irq_setmask_8259A>
f0107257:	83 c4 10             	add    $0x10,%esp
}
f010725a:	90                   	nop
f010725b:	c9                   	leave  
f010725c:	c3                   	ret    

f010725d <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f010725d:	55                   	push   %ebp
f010725e:	89 e5                	mov    %esp,%ebp
f0107260:	83 ec 14             	sub    $0x14,%esp
f0107263:	8b 45 08             	mov    0x8(%ebp),%eax
f0107266:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f010726a:	a1 8c 65 6f f0       	mov    0xf06f658c,%eax
f010726f:	85 c0                	test   %eax,%eax
f0107271:	74 34                	je     f01072a7 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0107273:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107276:	0f b6 c0             	movzbl %al,%eax
f0107279:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0107280:	88 45 f6             	mov    %al,-0xa(%ebp)
f0107283:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107286:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107289:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f010728a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010728d:	66 c1 e8 08          	shr    $0x8,%ax
f0107291:	0f b6 c0             	movzbl %al,%eax
f0107294:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f010729b:	88 45 f7             	mov    %al,-0x9(%ebp)
f010729e:	8a 45 f7             	mov    -0x9(%ebp),%al
f01072a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01072a4:	ee                   	out    %al,(%dx)
f01072a5:	eb 01                	jmp    f01072a8 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f01072a7:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f01072a8:	c9                   	leave  
f01072a9:	c3                   	ret    

f01072aa <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f01072aa:	55                   	push   %ebp
f01072ab:	89 e5                	mov    %esp,%ebp
f01072ad:	53                   	push   %ebx
f01072ae:	83 ec 14             	sub    $0x14,%esp
f01072b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01072b4:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f01072b7:	a1 8c 65 6f f0       	mov    0xf06f658c,%eax
f01072bc:	85 c0                	test   %eax,%eax
f01072be:	74 58                	je     f0107318 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f01072c0:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f01072c4:	77 08                	ja     f01072ce <irq_set_mask+0x24>
		port = PIC1_DATA;
f01072c6:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f01072cc:	eb 0a                	jmp    f01072d8 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f01072ce:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f01072d4:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f01072d8:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01072dc:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01072df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e2:	89 c2                	mov    %eax,%edx
f01072e4:	ec                   	in     (%dx),%al
f01072e5:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f01072e8:	8a 45 ee             	mov    -0x12(%ebp),%al
f01072eb:	88 c2                	mov    %al,%dl
f01072ed:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01072f1:	bb 01 00 00 00       	mov    $0x1,%ebx
f01072f6:	88 c1                	mov    %al,%cl
f01072f8:	d3 e3                	shl    %cl,%ebx
f01072fa:	89 d8                	mov    %ebx,%eax
f01072fc:	09 d0                	or     %edx,%eax
f01072fe:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107301:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107305:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107309:	89 55 f0             	mov    %edx,-0x10(%ebp)
f010730c:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010730f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107312:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107315:	ee                   	out    %al,(%dx)
f0107316:	eb 01                	jmp    f0107319 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107318:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0107319:	83 c4 14             	add    $0x14,%esp
f010731c:	5b                   	pop    %ebx
f010731d:	5d                   	pop    %ebp
f010731e:	c3                   	ret    

f010731f <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f010731f:	55                   	push   %ebp
f0107320:	89 e5                	mov    %esp,%ebp
f0107322:	53                   	push   %ebx
f0107323:	83 ec 14             	sub    $0x14,%esp
f0107326:	8b 45 08             	mov    0x8(%ebp),%eax
f0107329:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f010732c:	a1 8c 65 6f f0       	mov    0xf06f658c,%eax
f0107331:	85 c0                	test   %eax,%eax
f0107333:	74 5a                	je     f010738f <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107335:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107339:	77 08                	ja     f0107343 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f010733b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107341:	eb 0a                	jmp    f010734d <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107343:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107349:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f010734d:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107351:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107354:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107357:	89 c2                	mov    %eax,%edx
f0107359:	ec                   	in     (%dx),%al
f010735a:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f010735d:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107360:	88 c2                	mov    %al,%dl
f0107362:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107366:	bb 01 00 00 00       	mov    $0x1,%ebx
f010736b:	88 c1                	mov    %al,%cl
f010736d:	d3 e3                	shl    %cl,%ebx
f010736f:	89 d8                	mov    %ebx,%eax
f0107371:	f7 d0                	not    %eax
f0107373:	21 d0                	and    %edx,%eax
f0107375:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107378:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f010737c:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107380:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107383:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107386:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107389:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010738c:	ee                   	out    %al,(%dx)
f010738d:	eb 01                	jmp    f0107390 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f010738f:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107390:	83 c4 14             	add    $0x14,%esp
f0107393:	5b                   	pop    %ebx
f0107394:	5d                   	pop    %ebp
f0107395:	c3                   	ret    

f0107396 <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107396:	55                   	push   %ebp
f0107397:	89 e5                	mov    %esp,%ebp
f0107399:	53                   	push   %ebx
f010739a:	83 ec 14             	sub    $0x14,%esp
f010739d:	8b 45 08             	mov    0x8(%ebp),%eax
f01073a0:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f01073a3:	a1 8c 65 6f f0       	mov    0xf06f658c,%eax
f01073a8:	85 c0                	test   %eax,%eax
f01073aa:	75 07                	jne    f01073b3 <irq_get_mask+0x1d>
		return -1;
f01073ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01073b1:	eb 45                	jmp    f01073f8 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f01073b3:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f01073b7:	77 08                	ja     f01073c1 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f01073b9:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f01073bf:	eb 0a                	jmp    f01073cb <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f01073c1:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f01073c7:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01073cb:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01073cf:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01073d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d5:	89 c2                	mov    %eax,%edx
f01073d7:	ec                   	in     (%dx),%al
f01073d8:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01073db:	8a 45 f3             	mov    -0xd(%ebp),%al
f01073de:	88 c2                	mov    %al,%dl
f01073e0:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01073e4:	bb 01 00 00 00       	mov    $0x1,%ebx
f01073e9:	88 c1                	mov    %al,%cl
f01073eb:	d3 e3                	shl    %cl,%ebx
f01073ed:	89 d8                	mov    %ebx,%eax
f01073ef:	21 d0                	and    %edx,%eax
f01073f1:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01073f4:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01073f8:	83 c4 14             	add    $0x14,%esp
f01073fb:	5b                   	pop    %ebx
f01073fc:	5d                   	pop    %ebp
f01073fd:	c3                   	ret    

f01073fe <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01073fe:	55                   	push   %ebp
f01073ff:	89 e5                	mov    %esp,%ebp
f0107401:	83 ec 14             	sub    $0x14,%esp
f0107404:	8b 45 08             	mov    0x8(%ebp),%eax
f0107407:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f010740a:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f010740e:	76 12                	jbe    f0107422 <pic_sendEOI+0x24>
f0107410:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0107417:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010741b:	8a 45 f7             	mov    -0x9(%ebp),%al
f010741e:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0107421:	ee                   	out    %al,(%dx)
f0107422:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0107429:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f010742d:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107430:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107433:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107434:	90                   	nop
f0107435:	c9                   	leave  
f0107436:	c3                   	ret    

f0107437 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f0107437:	55                   	push   %ebp
f0107438:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010743a:	b8 60 f2 b1 f0       	mov    $0xf0b1f260,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f010743f:	5d                   	pop    %ebp
f0107440:	c3                   	ret    

f0107441 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107441:	55                   	push   %ebp
f0107442:	89 e5                	mov    %esp,%ebp
f0107444:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f0107447:	e8 eb ff ff ff       	call   f0107437 <mycpu>
f010744c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f010744f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107452:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107459:	00 00 00 
  c->ncli = 0;
f010745c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010745f:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0107466:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107469:	9c                   	pushf  
f010746a:	58                   	pop    %eax
f010746b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010746e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107471:	25 00 02 00 00       	and    $0x200,%eax
f0107476:	85 c0                	test   %eax,%eax
f0107478:	0f 95 c0             	setne  %al
f010747b:	0f b6 d0             	movzbl %al,%edx
f010747e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107481:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0107487:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107491:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107494:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f010749b:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f010749e:	8b 45 08             	mov    0x8(%ebp),%eax
f01074a1:	40                   	inc    %eax
f01074a2:	c1 e0 0f             	shl    $0xf,%eax
f01074a5:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01074aa:	29 c2                	sub    %eax,%edx
f01074ac:	89 d0                	mov    %edx,%eax
f01074ae:	89 c2                	mov    %eax,%edx
f01074b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b3:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f01074b6:	e8 18 01 00 00       	call   f01075d3 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f01074bb:	e8 35 5f 00 00       	call   f010d3f5 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f01074c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c3:	83 c0 0c             	add    $0xc,%eax
f01074c6:	83 ec 04             	sub    $0x4,%esp
f01074c9:	6a 68                	push   $0x68
f01074cb:	6a 00                	push   $0x0
f01074cd:	50                   	push   %eax
f01074ce:	e8 7d 8c 01 00       	call   f0120150 <memset>
f01074d3:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01074d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d9:	05 a4 00 00 00       	add    $0xa4,%eax
f01074de:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01074e1:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01074e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01074eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01074ee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01074f1:	f0 87 02             	lock xchg %eax,(%edx)
f01074f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01074f7:	90                   	nop
f01074f8:	c9                   	leave  
f01074f9:	c3                   	ret    

f01074fa <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01074fa:	55                   	push   %ebp
f01074fb:	89 e5                	mov    %esp,%ebp
f01074fd:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107500:	9c                   	pushf  
f0107501:	58                   	pop    %eax
f0107502:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f0107505:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f0107508:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010750b:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f010750c:	e8 26 ff ff ff       	call   f0107437 <mycpu>
f0107511:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f0107514:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107517:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010751d:	85 c0                	test   %eax,%eax
f010751f:	75 13                	jne    f0107534 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f0107521:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107524:	25 00 02 00 00       	and    $0x200,%eax
f0107529:	89 c2                	mov    %eax,%edx
f010752b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010752e:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107534:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107537:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010753d:	8d 50 01             	lea    0x1(%eax),%edx
f0107540:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107543:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f0107549:	90                   	nop
f010754a:	c9                   	leave  
f010754b:	c3                   	ret    

f010754c <popcli>:

void popcli(void)
{
f010754c:	55                   	push   %ebp
f010754d:	89 e5                	mov    %esp,%ebp
f010754f:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107552:	9c                   	pushf  
f0107553:	58                   	pop    %eax
f0107554:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107557:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010755a:	25 00 02 00 00       	and    $0x200,%eax
f010755f:	85 c0                	test   %eax,%eax
f0107561:	74 14                	je     f0107577 <popcli+0x2b>
    panic("popcli - interruptible");
f0107563:	83 ec 04             	sub    $0x4,%esp
f0107566:	68 7f 5d 12 f0       	push   $0xf0125d7f
f010756b:	6a 5e                	push   $0x5e
f010756d:	68 96 5d 12 f0       	push   $0xf0125d96
f0107572:	e8 c2 8d ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f0107577:	e8 bb fe ff ff       	call   f0107437 <mycpu>
f010757c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f010757f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107582:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107588:	8d 50 ff             	lea    -0x1(%eax),%edx
f010758b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010758e:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010759d:	85 c0                	test   %eax,%eax
f010759f:	79 14                	jns    f01075b5 <popcli+0x69>
    panic("popcli");
f01075a1:	83 ec 04             	sub    $0x4,%esp
f01075a4:	68 a5 5d 12 f0       	push   $0xf0125da5
f01075a9:	6a 61                	push   $0x61
f01075ab:	68 96 5d 12 f0       	push   $0xf0125d96
f01075b0:	e8 84 8d ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f01075b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075b8:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01075be:	85 c0                	test   %eax,%eax
f01075c0:	75 0e                	jne    f01075d0 <popcli+0x84>
f01075c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075c5:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01075cb:	85 c0                	test   %eax,%eax
f01075cd:	74 01                	je     f01075d0 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01075cf:	fb                   	sti    
    sti();
}
f01075d0:	90                   	nop
f01075d1:	c9                   	leave  
f01075d2:	c3                   	ret    

f01075d3 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01075d3:	55                   	push   %ebp
f01075d4:	89 e5                	mov    %esp,%ebp
f01075d6:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01075d9:	e8 1c ff ff ff       	call   f01074fa <pushcli>

	c = mycpu();
f01075de:	e8 54 fe ff ff       	call   f0107437 <mycpu>
f01075e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01075e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075e9:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01075f0:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01075f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075fa:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f0107609:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760c:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f0107613:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107616:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010761c:	83 e2 f0             	and    $0xfffffff0,%edx
f010761f:	83 ca 0a             	or     $0xa,%edx
f0107622:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107628:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010762b:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107631:	83 ca 10             	or     $0x10,%edx
f0107634:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010763a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010763d:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107643:	83 e2 9f             	and    $0xffffff9f,%edx
f0107646:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010764c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010764f:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107655:	83 ca 80             	or     $0xffffff80,%edx
f0107658:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010765e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107661:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107667:	83 ca 0f             	or     $0xf,%edx
f010766a:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107670:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107673:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107679:	83 e2 ef             	and    $0xffffffef,%edx
f010767c:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107682:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107685:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010768b:	83 e2 df             	and    $0xffffffdf,%edx
f010768e:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107694:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107697:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010769d:	83 ca 40             	or     $0x40,%edx
f01076a0:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01076a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076a9:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01076af:	83 ca 80             	or     $0xffffff80,%edx
f01076b2:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01076b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076bb:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f01076c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076c5:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01076cc:	ff ff 
f01076ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d1:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01076d8:	00 00 
f01076da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076dd:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01076e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076e7:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01076ed:	83 e2 f0             	and    $0xfffffff0,%edx
f01076f0:	83 ca 02             	or     $0x2,%edx
f01076f3:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01076f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076fc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107702:	83 ca 10             	or     $0x10,%edx
f0107705:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010770b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010770e:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107714:	83 e2 9f             	and    $0xffffff9f,%edx
f0107717:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010771d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107720:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107726:	83 ca 80             	or     $0xffffff80,%edx
f0107729:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010772f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107732:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107738:	83 ca 0f             	or     $0xf,%edx
f010773b:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107741:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107744:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010774a:	83 e2 ef             	and    $0xffffffef,%edx
f010774d:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107753:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107756:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010775c:	83 e2 df             	and    $0xffffffdf,%edx
f010775f:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107765:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107768:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010776e:	83 ca 40             	or     $0x40,%edx
f0107771:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107777:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010777a:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107780:	83 ca 80             	or     $0xffffff80,%edx
f0107783:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107789:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010778c:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107793:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107796:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f010779d:	ff ff 
f010779f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077a2:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f01077a9:	00 00 
f01077ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077ae:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f01077b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077b8:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077be:	83 e2 f0             	and    $0xfffffff0,%edx
f01077c1:	83 ca 0a             	or     $0xa,%edx
f01077c4:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01077ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077cd:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077d3:	83 ca 10             	or     $0x10,%edx
f01077d6:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01077dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077df:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077e5:	83 ca 60             	or     $0x60,%edx
f01077e8:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01077ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077f1:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077f7:	83 ca 80             	or     $0xffffff80,%edx
f01077fa:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107800:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107803:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107809:	83 ca 0f             	or     $0xf,%edx
f010780c:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107812:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107815:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010781b:	83 e2 ef             	and    $0xffffffef,%edx
f010781e:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107824:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107827:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010782d:	83 e2 df             	and    $0xffffffdf,%edx
f0107830:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107836:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107839:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010783f:	83 ca 40             	or     $0x40,%edx
f0107842:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107848:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010784b:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107851:	83 ca 80             	or     $0xffffff80,%edx
f0107854:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010785a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010785d:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107864:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107867:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f010786e:	ff ff 
f0107870:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107873:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010787a:	00 00 
f010787c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010787f:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f0107886:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107889:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010788f:	83 e2 f0             	and    $0xfffffff0,%edx
f0107892:	83 ca 02             	or     $0x2,%edx
f0107895:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f010789b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010789e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01078a4:	83 ca 10             	or     $0x10,%edx
f01078a7:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01078ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078b0:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01078b6:	83 ca 60             	or     $0x60,%edx
f01078b9:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01078bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078c2:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01078c8:	83 ca 80             	or     $0xffffff80,%edx
f01078cb:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01078d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078d4:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01078da:	83 ca 0f             	or     $0xf,%edx
f01078dd:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01078e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078e6:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01078ec:	83 e2 ef             	and    $0xffffffef,%edx
f01078ef:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01078f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078f8:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01078fe:	83 e2 df             	and    $0xffffffdf,%edx
f0107901:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107907:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010790a:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107910:	83 ca 40             	or     $0x40,%edx
f0107913:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107919:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010791c:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107922:	83 ca 80             	or     $0xffffff80,%edx
f0107925:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010792b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010792e:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f0107935:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107938:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f010793f:	00 00 00 
f0107942:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f0107949:	00 00 00 

	popcli();	//enable interrupt
f010794c:	e8 fb fb ff ff       	call   f010754c <popcli>


}
f0107951:	90                   	nop
f0107952:	c9                   	leave  
f0107953:	c3                   	ret    

f0107954 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107954:	55                   	push   %ebp
f0107955:	89 e5                	mov    %esp,%ebp
f0107957:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010795a:	83 ec 08             	sub    $0x8,%esp
f010795d:	68 00 10 00 00       	push   $0x1000
f0107962:	68 00 10 00 00       	push   $0x1000
f0107967:	e8 42 02 00 00       	call   f0107bae <boot_allocate_space>
f010796c:	83 c4 10             	add    $0x10,%esp
f010796f:	a3 b4 f7 f1 f0       	mov    %eax,0xf0f1f7b4
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107974:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107979:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010797c:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107983:	77 14                	ja     f0107999 <initialize_kernel_VM+0x45>
f0107985:	ff 75 e0             	pushl  -0x20(%ebp)
f0107988:	68 ac 5d 12 f0       	push   $0xf0125dac
f010798d:	6a 57                	push   $0x57
f010798f:	68 e0 5d 12 f0       	push   $0xf0125de0
f0107994:	e8 a0 89 ff ff       	call   f0100339 <_panic>
f0107999:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010799c:	05 00 00 00 10       	add    $0x10000000,%eax
f01079a1:	a3 e4 f8 f1 f0       	mov    %eax,0xf0f1f8e4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f01079a6:	c7 45 dc 00 80 17 f0 	movl   $0xf0178000,-0x24(%ebp)
f01079ad:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01079b4:	77 14                	ja     f01079ca <initialize_kernel_VM+0x76>
f01079b6:	ff 75 dc             	pushl  -0x24(%ebp)
f01079b9:	68 ac 5d 12 f0       	push   $0xf0125dac
f01079be:	6a 63                	push   $0x63
f01079c0:	68 e0 5d 12 f0       	push   $0xf0125de0
f01079c5:	e8 6f 89 ff ff       	call   f0100339 <_panic>
f01079ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01079cd:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01079d3:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01079d8:	83 ec 0c             	sub    $0xc,%esp
f01079db:	6a 02                	push   $0x2
f01079dd:	52                   	push   %edx
f01079de:	68 00 80 00 00       	push   $0x8000
f01079e3:	68 00 80 bf ef       	push   $0xefbf8000
f01079e8:	50                   	push   %eax
f01079e9:	e8 34 02 00 00       	call   f0107c22 <boot_map_range>
f01079ee:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01079f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01079f8:	eb 24                	jmp    f0107a1e <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01079fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079fd:	40                   	inc    %eax
f01079fe:	c1 e0 0f             	shl    $0xf,%eax
f0107a01:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107a06:	29 c2                	sub    %eax,%edx
f0107a08:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107a0d:	6a 01                	push   $0x1
f0107a0f:	6a 00                	push   $0x0
f0107a11:	52                   	push   %edx
f0107a12:	50                   	push   %eax
f0107a13:	e8 91 25 00 00       	call   f0109fa9 <pt_set_page_permissions>
f0107a18:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0107a1b:	ff 45 f4             	incl   -0xc(%ebp)
f0107a1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107a22:	7e d6                	jle    f01079fa <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f0107a24:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107a2b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107a32:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107a39:	eb 25                	jmp    f0107a60 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107a3b:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107a3e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107a41:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107a46:	83 ec 04             	sub    $0x4,%esp
f0107a49:	6a 01                	push   $0x1
f0107a4b:	52                   	push   %edx
f0107a4c:	50                   	push   %eax
f0107a4d:	e8 44 02 00 00       	call   f0107c96 <boot_get_page_table>
f0107a52:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107a55:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107a5c:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107a60:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107a64:	72 d5                	jb     f0107a3b <initialize_kernel_VM+0xe7>
f0107a66:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107a6a:	77 06                	ja     f0107a72 <initialize_kernel_VM+0x11e>
f0107a6c:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107a70:	76 c9                	jbe    f0107a3b <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107a72:	8b 15 18 f3 b1 f0    	mov    0xf0b1f318,%edx
f0107a78:	89 d0                	mov    %edx,%eax
f0107a7a:	01 c0                	add    %eax,%eax
f0107a7c:	01 d0                	add    %edx,%eax
f0107a7e:	c1 e0 03             	shl    $0x3,%eax
f0107a81:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107a84:	83 ec 08             	sub    $0x8,%esp
f0107a87:	68 00 10 00 00       	push   $0x1000
f0107a8c:	ff 75 d8             	pushl  -0x28(%ebp)
f0107a8f:	e8 1a 01 00 00       	call   f0107bae <boot_allocate_space>
f0107a94:	83 c4 10             	add    $0x10,%esp
f0107a97:	a3 80 f5 b1 f0       	mov    %eax,0xf0b1f580
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107a9c:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107aa3:	83 ec 08             	sub    $0x8,%esp
f0107aa6:	68 00 10 00 00       	push   $0x1000
f0107aab:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107aae:	e8 fb 00 00 00       	call   f0107bae <boot_allocate_space>
f0107ab3:	83 c4 10             	add    $0x10,%esp
f0107ab6:	a3 40 ee 71 f0       	mov    %eax,0xf071ee40
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107abb:	e8 05 05 00 00       	call   f0107fc5 <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107ac0:	83 ec 0c             	sub    $0xc,%esp
f0107ac3:	68 ca 02 00 00       	push   $0x2ca
f0107ac8:	e8 f3 69 01 00       	call   f011e4c0 <nearest_pow2_ceil>
f0107acd:	83 c4 10             	add    $0x10,%esp
f0107ad0:	83 ec 04             	sub    $0x4,%esp
f0107ad3:	50                   	push   %eax
f0107ad4:	68 ca 02 00 00       	push   $0x2ca
f0107ad9:	68 00 5e 12 f0       	push   $0xf0125e00
f0107ade:	e8 a8 94 ff ff       	call   f0100f8b <cprintf>
f0107ae3:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f0107ae6:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0107aed:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107af0:	83 ec 08             	sub    $0x8,%esp
f0107af3:	68 00 10 00 00       	push   $0x1000
f0107af8:	50                   	push   %eax
f0107af9:	e8 b0 00 00 00       	call   f0107bae <boot_allocate_space>
f0107afe:	83 c4 10             	add    $0x10,%esp
f0107b01:	a3 90 65 6f f0       	mov    %eax,0xf06f6590
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f0107b06:	a1 90 65 6f f0       	mov    0xf06f6590,%eax
f0107b0b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0107b0e:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f0107b15:	77 17                	ja     f0107b2e <initialize_kernel_VM+0x1da>
f0107b17:	ff 75 cc             	pushl  -0x34(%ebp)
f0107b1a:	68 ac 5d 12 f0       	push   $0xf0125dac
f0107b1f:	68 b1 00 00 00       	push   $0xb1
f0107b24:	68 e0 5d 12 f0       	push   $0xf0125de0
f0107b29:	e8 0b 88 ff ff       	call   f0100339 <_panic>
f0107b2e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107b31:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0107b37:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0107b3a:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107b3f:	83 ec 0c             	sub    $0xc,%esp
f0107b42:	6a 04                	push   $0x4
f0107b44:	51                   	push   %ecx
f0107b45:	52                   	push   %edx
f0107b46:	68 00 00 c0 ee       	push   $0xeec00000
f0107b4b:	50                   	push   %eax
f0107b4c:	e8 d1 00 00 00       	call   f0107c22 <boot_map_range>
f0107b51:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107b54:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107b59:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107b5e:	8b 15 b4 f7 f1 f0    	mov    0xf0f1f7b4,%edx
f0107b64:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f0107b6a:	8b 12                	mov    (%edx),%edx
f0107b6c:	83 ca 05             	or     $0x5,%edx
f0107b6f:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107b71:	a1 b0 f7 f1 f0       	mov    0xf0f1f7b0,%eax
f0107b76:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107b7c:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107b81:	83 ec 0c             	sub    $0xc,%esp
f0107b84:	6a 02                	push   $0x2
f0107b86:	6a 00                	push   $0x0
f0107b88:	52                   	push   %edx
f0107b89:	68 00 00 00 f0       	push   $0xf0000000
f0107b8e:	50                   	push   %eax
f0107b8f:	e8 8e 00 00 00       	call   f0107c22 <boot_map_range>
f0107b94:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0107b97:	e8 f7 78 01 00       	call   f011f493 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107b9c:	c7 05 50 f2 b1 f0 19 	movl   $0x19,0xf0b1f250
f0107ba3:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f0107ba6:	e8 e6 02 00 00       	call   f0107e91 <turn_on_paging>
}
f0107bab:	90                   	nop
f0107bac:	c9                   	leave  
f0107bad:	c3                   	ret    

f0107bae <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107bae:	55                   	push   %ebp
f0107baf:	89 e5                	mov    %esp,%ebp
f0107bb1:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107bb4:	a1 b0 f7 f1 f0       	mov    0xf0f1f7b0,%eax
f0107bb9:	85 c0                	test   %eax,%eax
f0107bbb:	75 0a                	jne    f0107bc7 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107bbd:	c7 05 b0 f7 f1 f0 d0 	movl   $0xf26b22d0,0xf0f1f7b0
f0107bc4:	22 6b f2 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0107bc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107bca:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107bcd:	a1 b0 f7 f1 f0       	mov    0xf0f1f7b0,%eax
f0107bd2:	89 c2                	mov    %eax,%edx
f0107bd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bd7:	01 d0                	add    %edx,%eax
f0107bd9:	48                   	dec    %eax
f0107bda:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107bdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107be0:	ba 00 00 00 00       	mov    $0x0,%edx
f0107be5:	f7 75 f4             	divl   -0xc(%ebp)
f0107be8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107beb:	29 d0                	sub    %edx,%eax
f0107bed:	a3 b0 f7 f1 f0       	mov    %eax,0xf0f1f7b0

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f0107bf2:	a1 b0 f7 f1 f0       	mov    0xf0f1f7b0,%eax
f0107bf7:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0107bfa:	8b 15 b0 f7 f1 f0    	mov    0xf0f1f7b0,%edx
f0107c00:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c03:	01 d0                	add    %edx,%eax
f0107c05:	a3 b0 f7 f1 f0       	mov    %eax,0xf0f1f7b0

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0107c0a:	83 ec 04             	sub    $0x4,%esp
f0107c0d:	ff 75 08             	pushl  0x8(%ebp)
f0107c10:	6a 00                	push   $0x0
f0107c12:	ff 75 ec             	pushl  -0x14(%ebp)
f0107c15:	e8 36 85 01 00       	call   f0120150 <memset>
f0107c1a:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0107c1d:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f0107c20:	c9                   	leave  
f0107c21:	c3                   	ret    

f0107c22 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f0107c22:	55                   	push   %ebp
f0107c23:	89 e5                	mov    %esp,%ebp
f0107c25:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f0107c28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107c2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107c36:	eb 53                	jmp    f0107c8b <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f0107c38:	83 ec 04             	sub    $0x4,%esp
f0107c3b:	6a 01                	push   $0x1
f0107c3d:	ff 75 0c             	pushl  0xc(%ebp)
f0107c40:	ff 75 08             	pushl  0x8(%ebp)
f0107c43:	e8 4e 00 00 00       	call   f0107c96 <boot_get_page_table>
f0107c48:	83 c4 10             	add    $0x10,%esp
f0107c4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107c4e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107c51:	c1 e8 0c             	shr    $0xc,%eax
f0107c54:	25 ff 03 00 00       	and    $0x3ff,%eax
f0107c59:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107c5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c5f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107c66:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107c69:	01 c2                	add    %eax,%edx
f0107c6b:	8b 45 18             	mov    0x18(%ebp),%eax
f0107c6e:	0b 45 14             	or     0x14(%ebp),%eax
f0107c71:	83 c8 01             	or     $0x1,%eax
f0107c74:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f0107c76:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107c7d:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107c84:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107c8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c8e:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107c91:	72 a5                	jb     f0107c38 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107c93:	90                   	nop
f0107c94:	c9                   	leave  
f0107c95:	c3                   	ret    

f0107c96 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0107c96:	55                   	push   %ebp
f0107c97:	89 e5                	mov    %esp,%ebp
f0107c99:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107c9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107c9f:	c1 e8 16             	shr    $0x16,%eax
f0107ca2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f0107ca5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ca8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107caf:	8b 45 08             	mov    0x8(%ebp),%eax
f0107cb2:	01 d0                	add    %edx,%eax
f0107cb4:	8b 00                	mov    (%eax),%eax
f0107cb6:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0107cb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107cbc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107cc1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107cc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107cc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0107cca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107ccd:	c1 e8 0c             	shr    $0xc,%eax
f0107cd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107cd3:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0107cd8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0107cdb:	72 17                	jb     f0107cf4 <boot_get_page_table+0x5e>
f0107cdd:	ff 75 e8             	pushl  -0x18(%ebp)
f0107ce0:	68 28 5e 12 f0       	push   $0xf0125e28
f0107ce5:	68 33 01 00 00       	push   $0x133
f0107cea:	68 e0 5d 12 f0       	push   $0xf0125de0
f0107cef:	e8 45 86 ff ff       	call   f0100339 <_panic>
f0107cf4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107cf7:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0107cfc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0107cff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107d03:	75 72                	jne    f0107d77 <boot_get_page_table+0xe1>
	{
		if (create)
f0107d05:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0107d09:	74 65                	je     f0107d70 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0107d0b:	83 ec 08             	sub    $0x8,%esp
f0107d0e:	68 00 10 00 00       	push   $0x1000
f0107d13:	68 00 10 00 00       	push   $0x1000
f0107d18:	e8 91 fe ff ff       	call   f0107bae <boot_allocate_space>
f0107d1d:	83 c4 10             	add    $0x10,%esp
f0107d20:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f0107d23:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d26:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107d29:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107d30:	77 17                	ja     f0107d49 <boot_get_page_table+0xb3>
f0107d32:	ff 75 dc             	pushl  -0x24(%ebp)
f0107d35:	68 ac 5d 12 f0       	push   $0xf0125dac
f0107d3a:	68 39 01 00 00       	push   $0x139
f0107d3f:	68 e0 5d 12 f0       	push   $0xf0125de0
f0107d44:	e8 f0 85 ff ff       	call   f0100339 <_panic>
f0107d49:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107d4c:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d51:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107d57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107d5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d61:	01 d0                	add    %edx,%eax
f0107d63:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107d66:	83 ca 03             	or     $0x3,%edx
f0107d69:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107d6b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d6e:	eb 0a                	jmp    f0107d7a <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107d70:	b8 00 00 00 00       	mov    $0x0,%eax
f0107d75:	eb 03                	jmp    f0107d7a <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107d77:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107d7a:	c9                   	leave  
f0107d7b:	c3                   	ret    

f0107d7c <nvram_read>:


int nvram_read(int r)
{
f0107d7c:	55                   	push   %ebp
f0107d7d:	89 e5                	mov    %esp,%ebp
f0107d7f:	53                   	push   %ebx
f0107d80:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107d83:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d86:	83 ec 0c             	sub    $0xc,%esp
f0107d89:	50                   	push   %eax
f0107d8a:	e8 eb cf ff ff       	call   f0104d7a <mc146818_read>
f0107d8f:	83 c4 10             	add    $0x10,%esp
f0107d92:	89 c3                	mov    %eax,%ebx
f0107d94:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d97:	40                   	inc    %eax
f0107d98:	83 ec 0c             	sub    $0xc,%esp
f0107d9b:	50                   	push   %eax
f0107d9c:	e8 d9 cf ff ff       	call   f0104d7a <mc146818_read>
f0107da1:	83 c4 10             	add    $0x10,%esp
f0107da4:	c1 e0 08             	shl    $0x8,%eax
f0107da7:	09 d8                	or     %ebx,%eax
}
f0107da9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107dac:	c9                   	leave  
f0107dad:	c3                   	ret    

f0107dae <detect_memory>:

void detect_memory()
{
f0107dae:	55                   	push   %ebp
f0107daf:	89 e5                	mov    %esp,%ebp
f0107db1:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107db4:	83 ec 0c             	sub    $0xc,%esp
f0107db7:	6a 15                	push   $0x15
f0107db9:	e8 be ff ff ff       	call   f0107d7c <nvram_read>
f0107dbe:	83 c4 10             	add    $0x10,%esp
f0107dc1:	c1 e0 0a             	shl    $0xa,%eax
f0107dc4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107dc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107dca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107dcf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107dd2:	83 ec 0c             	sub    $0xc,%esp
f0107dd5:	6a 17                	push   $0x17
f0107dd7:	e8 a0 ff ff ff       	call   f0107d7c <nvram_read>
f0107ddc:	83 c4 10             	add    $0x10,%esp
f0107ddf:	c1 e0 0a             	shl    $0xa,%eax
f0107de2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107de5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107de8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ded:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107df0:	83 ec 0c             	sub    $0xc,%esp
f0107df3:	6a 34                	push   $0x34
f0107df5:	e8 82 ff ff ff       	call   f0107d7c <nvram_read>
f0107dfa:	83 c4 10             	add    $0x10,%esp
f0107dfd:	c1 e0 10             	shl    $0x10,%eax
f0107e00:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107e03:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107e06:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107e0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107e0e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107e12:	74 18                	je     f0107e2c <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107e14:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107e17:	05 00 00 00 01       	add    $0x1000000,%eax
f0107e1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107e1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e22:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107e27:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107e2a:	eb 19                	jmp    f0107e45 <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107e30:	74 0d                	je     f0107e3f <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107e32:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e35:	05 00 00 10 00       	add    $0x100000,%eax
f0107e3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107e3d:	eb 06                	jmp    f0107e45 <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107e3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e42:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107e45:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107e4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e4f:	c1 e8 0c             	shr    $0xc,%eax
f0107e52:	a3 18 f3 b1 f0       	mov    %eax,0xf0b1f318

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e5a:	c1 e8 0a             	shr    $0xa,%eax
f0107e5d:	83 ec 08             	sub    $0x8,%esp
f0107e60:	50                   	push   %eax
f0107e61:	68 58 5e 12 f0       	push   $0xf0125e58
f0107e66:	e8 20 91 ff ff       	call   f0100f8b <cprintf>
f0107e6b:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107e6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e71:	c1 e8 0a             	shr    $0xa,%eax
f0107e74:	89 c2                	mov    %eax,%edx
f0107e76:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107e79:	c1 e8 0a             	shr    $0xa,%eax
f0107e7c:	83 ec 04             	sub    $0x4,%esp
f0107e7f:	52                   	push   %edx
f0107e80:	50                   	push   %eax
f0107e81:	68 7b 5e 12 f0       	push   $0xf0125e7b
f0107e86:	e8 00 91 ff ff       	call   f0100f8b <cprintf>
f0107e8b:	83 c4 10             	add    $0x10,%esp
}
f0107e8e:	90                   	nop
f0107e8f:	c9                   	leave  
f0107e90:	c3                   	ret    

f0107e91 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107e91:	55                   	push   %ebp
f0107e92:	89 e5                	mov    %esp,%ebp
f0107e94:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107e97:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107e9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107ea5:	eb 24                	jmp    f0107ecb <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107ea7:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107eac:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107eaf:	c1 e2 02             	shl    $0x2,%edx
f0107eb2:	01 c2                	add    %eax,%edx
f0107eb4:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107eb9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107ebc:	c1 e1 02             	shl    $0x2,%ecx
f0107ebf:	01 c8                	add    %ecx,%eax
f0107ec1:	8b 00                	mov    (%eax),%eax
f0107ec3:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107ec5:	ff 45 f4             	incl   -0xc(%ebp)
f0107ec8:	ff 45 f0             	incl   -0x10(%ebp)
f0107ecb:	a1 b0 f7 f1 f0       	mov    0xf0f1f7b0,%eax
f0107ed0:	c1 e8 16             	shr    $0x16,%eax
f0107ed3:	89 c2                	mov    %eax,%edx
f0107ed5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ed8:	39 c2                	cmp    %eax,%edx
f0107eda:	77 cb                	ja     f0107ea7 <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107edc:	a1 e4 f8 f1 f0       	mov    0xf0f1f8e4,%eax
f0107ee1:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107ee4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107ee7:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107eea:	0f 20 c0             	mov    %cr0,%eax
f0107eed:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107ef0:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107ef3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107ef6:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107efd:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107f01:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107f04:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107f0a:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107f0d:	e8 e8 f5 ff ff       	call   f01074fa <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107f12:	e8 20 f5 ff ff       	call   f0107437 <mycpu>
f0107f17:	83 c0 74             	add    $0x74,%eax
f0107f1a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107f1d:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107f24:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107f27:	48                   	dec    %eax
f0107f28:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107f2c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107f2f:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107f33:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107f36:	c1 e8 10             	shr    $0x10,%eax
f0107f39:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107f3d:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107f40:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107f43:	e8 04 f6 ff ff       	call   f010754c <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107f48:	b8 23 00 00 00       	mov    $0x23,%eax
f0107f4d:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107f4f:	b8 23 00 00 00       	mov    $0x23,%eax
f0107f54:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107f56:	b8 10 00 00 00       	mov    $0x10,%eax
f0107f5b:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107f5d:	b8 10 00 00 00       	mov    $0x10,%eax
f0107f62:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107f64:	b8 10 00 00 00       	mov    $0x10,%eax
f0107f69:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107f6b:	ea 72 7f 10 f0 08 00 	ljmp   $0x8,$0xf0107f72
	asm volatile("lldt %%ax" :: "a" (0));
f0107f72:	b8 00 00 00 00       	mov    $0x0,%eax
f0107f77:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107f7a:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107f81:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107f88:	eb 19                	jmp    f0107fa3 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107f8a:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107f8f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107f92:	c1 e2 02             	shl    $0x2,%edx
f0107f95:	01 d0                	add    %edx,%eax
f0107f97:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107f9d:	ff 45 ec             	incl   -0x14(%ebp)
f0107fa0:	ff 45 e8             	incl   -0x18(%ebp)
f0107fa3:	a1 b0 f7 f1 f0       	mov    0xf0f1f7b0,%eax
f0107fa8:	c1 e8 16             	shr    $0x16,%eax
f0107fab:	89 c2                	mov    %eax,%edx
f0107fad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107fb0:	39 c2                	cmp    %eax,%edx
f0107fb2:	77 d6                	ja     f0107f8a <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107fb4:	a1 e4 f8 f1 f0       	mov    0xf0f1f8e4,%eax
f0107fb9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107fbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107fbf:	0f 22 d8             	mov    %eax,%cr3

}
f0107fc2:	90                   	nop
f0107fc3:	c9                   	leave  
f0107fc4:	c3                   	ret    

f0107fc5 <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107fc5:	55                   	push   %ebp
f0107fc6:	89 e5                	mov    %esp,%ebp
f0107fc8:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107fcb:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0107fd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107fd3:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107fda:	77 17                	ja     f0107ff3 <setup_listing_to_all_page_tables_entries+0x2e>
f0107fdc:	ff 75 f4             	pushl  -0xc(%ebp)
f0107fdf:	68 ac 5d 12 f0       	push   $0xf0125dac
f0107fe4:	68 cf 01 00 00       	push   $0x1cf
f0107fe9:	68 e0 5d 12 f0       	push   $0xf0125de0
f0107fee:	e8 46 83 ff ff       	call   f0100339 <_panic>
f0107ff3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ff6:	05 00 00 00 10       	add    $0x10000000,%eax
f0107ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107ffe:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0108003:	05 fc 0e 00 00       	add    $0xefc,%eax
f0108008:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010800b:	83 ca 03             	or     $0x3,%edx
f010800e:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0108010:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0108015:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010801b:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0108020:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108023:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f010802a:	77 17                	ja     f0108043 <setup_listing_to_all_page_tables_entries+0x7e>
f010802c:	ff 75 ec             	pushl  -0x14(%ebp)
f010802f:	68 ac 5d 12 f0       	push   $0xf0125dac
f0108034:	68 d4 01 00 00       	push   $0x1d4
f0108039:	68 e0 5d 12 f0       	push   $0xf0125de0
f010803e:	e8 f6 82 ff ff       	call   f0100339 <_panic>
f0108043:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108046:	05 00 00 00 10       	add    $0x10000000,%eax
f010804b:	83 c8 05             	or     $0x5,%eax
f010804e:	89 02                	mov    %eax,(%edx)

}
f0108050:	90                   	nop
f0108051:	c9                   	leave  
f0108052:	c3                   	ret    

f0108053 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108053:	55                   	push   %ebp
f0108054:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108056:	8b 45 08             	mov    0x8(%ebp),%eax
f0108059:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f010805f:	29 d0                	sub    %edx,%eax
f0108061:	c1 f8 03             	sar    $0x3,%eax
f0108064:	89 c2                	mov    %eax,%edx
f0108066:	89 d0                	mov    %edx,%eax
f0108068:	c1 e0 02             	shl    $0x2,%eax
f010806b:	01 d0                	add    %edx,%eax
f010806d:	c1 e0 02             	shl    $0x2,%eax
f0108070:	01 d0                	add    %edx,%eax
f0108072:	c1 e0 02             	shl    $0x2,%eax
f0108075:	01 d0                	add    %edx,%eax
f0108077:	89 c1                	mov    %eax,%ecx
f0108079:	c1 e1 08             	shl    $0x8,%ecx
f010807c:	01 c8                	add    %ecx,%eax
f010807e:	89 c1                	mov    %eax,%ecx
f0108080:	c1 e1 10             	shl    $0x10,%ecx
f0108083:	01 c8                	add    %ecx,%eax
f0108085:	01 c0                	add    %eax,%eax
f0108087:	01 d0                	add    %edx,%eax
}
f0108089:	5d                   	pop    %ebp
f010808a:	c3                   	ret    

f010808b <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010808b:	55                   	push   %ebp
f010808c:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010808e:	ff 75 08             	pushl  0x8(%ebp)
f0108091:	e8 bd ff ff ff       	call   f0108053 <to_frame_number>
f0108096:	83 c4 04             	add    $0x4,%esp
f0108099:	c1 e0 0c             	shl    $0xc,%eax
}
f010809c:	c9                   	leave  
f010809d:	c3                   	ret    

f010809e <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f010809e:	55                   	push   %ebp
f010809f:	89 e5                	mov    %esp,%ebp
f01080a1:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f01080a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01080a7:	c1 e8 0c             	shr    $0xc,%eax
f01080aa:	89 c2                	mov    %eax,%edx
f01080ac:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f01080b1:	39 c2                	cmp    %eax,%edx
f01080b3:	72 14                	jb     f01080c9 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f01080b5:	83 ec 04             	sub    $0x4,%esp
f01080b8:	68 98 5e 12 f0       	push   $0xf0125e98
f01080bd:	6a 56                	push   $0x56
f01080bf:	68 bd 5e 12 f0       	push   $0xf0125ebd
f01080c4:	e8 70 82 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f01080c9:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f01080cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01080d2:	c1 e8 0c             	shr    $0xc,%eax
f01080d5:	89 c1                	mov    %eax,%ecx
f01080d7:	89 c8                	mov    %ecx,%eax
f01080d9:	01 c0                	add    %eax,%eax
f01080db:	01 c8                	add    %ecx,%eax
f01080dd:	c1 e0 03             	shl    $0x3,%eax
f01080e0:	01 d0                	add    %edx,%eax
}
f01080e2:	c9                   	leave  
f01080e3:	c3                   	ret    

f01080e4 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f01080e4:	55                   	push   %ebp
f01080e5:	89 e5                	mov    %esp,%ebp
f01080e7:	83 ec 10             	sub    $0x10,%esp
f01080ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01080ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f01080f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01080f3:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f01080f6:	90                   	nop
f01080f7:	c9                   	leave  
f01080f8:	c3                   	ret    

f01080f9 <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f01080f9:	55                   	push   %ebp
f01080fa:	89 e5                	mov    %esp,%ebp
f01080fc:	53                   	push   %ebx
f01080fd:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0108100:	c7 05 20 f1 b1 f0 00 	movl   $0x0,0xf0b1f120
f0108107:	00 00 00 
f010810a:	c7 05 24 f1 b1 f0 00 	movl   $0x0,0xf0b1f124
f0108111:	00 00 00 
f0108114:	c7 05 2c f1 b1 f0 00 	movl   $0x0,0xf0b1f12c
f010811b:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f010811e:	c7 05 30 f1 b1 f0 00 	movl   $0x0,0xf0b1f130
f0108125:	00 00 00 
f0108128:	c7 05 34 f1 b1 f0 00 	movl   $0x0,0xf0b1f134
f010812f:	00 00 00 
f0108132:	c7 05 3c f1 b1 f0 00 	movl   $0x0,0xf0b1f13c
f0108139:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f010813c:	83 ec 08             	sub    $0x8,%esp
f010813f:	68 d7 5e 12 f0       	push   $0xf0125ed7
f0108144:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108149:	e8 35 7e 00 00       	call   f010ff83 <init_spinlock>
f010814e:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0108151:	a1 80 f5 b1 f0       	mov    0xf0b1f580,%eax
f0108156:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f010815c:	a1 80 f5 b1 f0       	mov    0xf0b1f580,%eax
f0108161:	83 c0 18             	add    $0x18,%eax
f0108164:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f010816a:	a1 80 f5 b1 f0       	mov    0xf0b1f580,%eax
f010816f:	83 c0 30             	add    $0x30,%eax
f0108172:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0108178:	c7 05 1c f6 b1 f0 00 	movl   $0xf0001000,0xf0b1f61c
f010817f:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0108182:	c7 05 4c f8 f1 f0 00 	movl   $0xf0002000,0xf0f1f84c
f0108189:	20 00 f0 
	i =0;
f010818c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0108193:	eb 1f                	jmp    f01081b4 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0108195:	8b 15 1c f6 b1 f0    	mov    0xf0b1f61c,%edx
f010819b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010819e:	01 d0                	add    %edx,%eax
f01081a0:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f01081a3:	8b 15 4c f8 f1 f0    	mov    0xf0f1f84c,%edx
f01081a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081ac:	01 d0                	add    %edx,%eax
f01081ae:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f01081b1:	ff 45 f4             	incl   -0xc(%ebp)
f01081b4:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f01081bb:	7e d8                	jle    f0108195 <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f01081bd:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f01081c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01081c7:	05 ff ff 09 00       	add    $0x9ffff,%eax
f01081cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01081cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01081d2:	ba 00 00 00 00       	mov    $0x0,%edx
f01081d7:	f7 75 f0             	divl   -0x10(%ebp)
f01081da:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01081dd:	29 d0                	sub    %edx,%eax
f01081df:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f01081e2:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f01081e9:	e9 e8 00 00 00       	jmp    f01082d6 <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f01081ee:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01081f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01081f7:	89 d0                	mov    %edx,%eax
f01081f9:	01 c0                	add    %eax,%eax
f01081fb:	01 d0                	add    %edx,%eax
f01081fd:	c1 e0 03             	shl    $0x3,%eax
f0108200:	01 c8                	add    %ecx,%eax
f0108202:	83 ec 0c             	sub    $0xc,%esp
f0108205:	50                   	push   %eax
f0108206:	e8 b7 02 00 00       	call   f01084c2 <initialize_frame_info>
f010820b:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f010820e:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108214:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108217:	89 d0                	mov    %edx,%eax
f0108219:	01 c0                	add    %eax,%eax
f010821b:	01 d0                	add    %edx,%eax
f010821d:	c1 e0 03             	shl    $0x3,%eax
f0108220:	01 c8                	add    %ecx,%eax
f0108222:	85 c0                	test   %eax,%eax
f0108224:	75 14                	jne    f010823a <initialize_paging+0x141>
f0108226:	83 ec 04             	sub    $0x4,%esp
f0108229:	68 e8 5e 12 f0       	push   $0xf0125ee8
f010822e:	6a 60                	push   $0x60
f0108230:	68 0b 5f 12 f0       	push   $0xf0125f0b
f0108235:	e8 ff 80 ff ff       	call   f0100339 <_panic>
f010823a:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108240:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108243:	89 d0                	mov    %edx,%eax
f0108245:	01 c0                	add    %eax,%eax
f0108247:	01 d0                	add    %edx,%eax
f0108249:	c1 e0 03             	shl    $0x3,%eax
f010824c:	01 c8                	add    %ecx,%eax
f010824e:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108254:	89 10                	mov    %edx,(%eax)
f0108256:	8b 00                	mov    (%eax),%eax
f0108258:	85 c0                	test   %eax,%eax
f010825a:	74 1f                	je     f010827b <initialize_paging+0x182>
f010825c:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108262:	8b 1d 80 f5 b1 f0    	mov    0xf0b1f580,%ebx
f0108268:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010826b:	89 c8                	mov    %ecx,%eax
f010826d:	01 c0                	add    %eax,%eax
f010826f:	01 c8                	add    %ecx,%eax
f0108271:	c1 e0 03             	shl    $0x3,%eax
f0108274:	01 d8                	add    %ebx,%eax
f0108276:	89 42 04             	mov    %eax,0x4(%edx)
f0108279:	eb 19                	jmp    f0108294 <initialize_paging+0x19b>
f010827b:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108281:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108284:	89 d0                	mov    %edx,%eax
f0108286:	01 c0                	add    %eax,%eax
f0108288:	01 d0                	add    %edx,%eax
f010828a:	c1 e0 03             	shl    $0x3,%eax
f010828d:	01 c8                	add    %ecx,%eax
f010828f:	a3 24 f1 b1 f0       	mov    %eax,0xf0b1f124
f0108294:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f010829a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010829d:	89 d0                	mov    %edx,%eax
f010829f:	01 c0                	add    %eax,%eax
f01082a1:	01 d0                	add    %edx,%eax
f01082a3:	c1 e0 03             	shl    $0x3,%eax
f01082a6:	01 c8                	add    %ecx,%eax
f01082a8:	a3 20 f1 b1 f0       	mov    %eax,0xf0b1f120
f01082ad:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01082b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01082b6:	89 d0                	mov    %edx,%eax
f01082b8:	01 c0                	add    %eax,%eax
f01082ba:	01 d0                	add    %edx,%eax
f01082bc:	c1 e0 03             	shl    $0x3,%eax
f01082bf:	01 c8                	add    %ecx,%eax
f01082c1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082c8:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f01082cd:	40                   	inc    %eax
f01082ce:	a3 2c f1 b1 f0       	mov    %eax,0xf0b1f12c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f01082d3:	ff 45 f4             	incl   -0xc(%ebp)
f01082d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01082d9:	85 c0                	test   %eax,%eax
f01082db:	79 05                	jns    f01082e2 <initialize_paging+0x1e9>
f01082dd:	05 ff 0f 00 00       	add    $0xfff,%eax
f01082e2:	c1 f8 0c             	sar    $0xc,%eax
f01082e5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01082e8:	0f 8f 00 ff ff ff    	jg     f01081ee <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f01082ee:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f01082f5:	eb 1d                	jmp    f0108314 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f01082f7:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01082fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108300:	89 d0                	mov    %edx,%eax
f0108302:	01 c0                	add    %eax,%eax
f0108304:	01 d0                	add    %edx,%eax
f0108306:	c1 e0 03             	shl    $0x3,%eax
f0108309:	01 c8                	add    %ecx,%eax
f010830b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108311:	ff 45 f4             	incl   -0xc(%ebp)
f0108314:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f010831b:	7e da                	jle    f01082f7 <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f010831d:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108324:	a1 b0 f7 f1 f0       	mov    0xf0f1f7b0,%eax
f0108329:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010832c:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108333:	77 14                	ja     f0108349 <initialize_paging+0x250>
f0108335:	ff 75 e0             	pushl  -0x20(%ebp)
f0108338:	68 28 5f 12 f0       	push   $0xf0125f28
f010833d:	6a 68                	push   $0x68
f010833f:	68 0b 5f 12 f0       	push   $0xf0125f0b
f0108344:	e8 f0 7f ff ff       	call   f0100339 <_panic>
f0108349:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010834c:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108352:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108355:	01 d0                	add    %edx,%eax
f0108357:	48                   	dec    %eax
f0108358:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010835b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010835e:	ba 00 00 00 00       	mov    $0x0,%edx
f0108363:	f7 75 e4             	divl   -0x1c(%ebp)
f0108366:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108369:	29 d0                	sub    %edx,%eax
f010836b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f010836e:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0108375:	eb 1d                	jmp    f0108394 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f0108377:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f010837d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108380:	89 d0                	mov    %edx,%eax
f0108382:	01 c0                	add    %eax,%eax
f0108384:	01 d0                	add    %edx,%eax
f0108386:	c1 e0 03             	shl    $0x3,%eax
f0108389:	01 c8                	add    %ecx,%eax
f010838b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108391:	ff 45 f4             	incl   -0xc(%ebp)
f0108394:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108397:	85 c0                	test   %eax,%eax
f0108399:	79 05                	jns    f01083a0 <initialize_paging+0x2a7>
f010839b:	05 ff 0f 00 00       	add    $0xfff,%eax
f01083a0:	c1 f8 0c             	sar    $0xc,%eax
f01083a3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01083a6:	7f cf                	jg     f0108377 <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f01083a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01083ab:	85 c0                	test   %eax,%eax
f01083ad:	79 05                	jns    f01083b4 <initialize_paging+0x2bb>
f01083af:	05 ff 0f 00 00       	add    $0xfff,%eax
f01083b4:	c1 f8 0c             	sar    $0xc,%eax
f01083b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01083ba:	e9 e8 00 00 00       	jmp    f01084a7 <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f01083bf:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01083c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01083c8:	89 d0                	mov    %edx,%eax
f01083ca:	01 c0                	add    %eax,%eax
f01083cc:	01 d0                	add    %edx,%eax
f01083ce:	c1 e0 03             	shl    $0x3,%eax
f01083d1:	01 c8                	add    %ecx,%eax
f01083d3:	83 ec 0c             	sub    $0xc,%esp
f01083d6:	50                   	push   %eax
f01083d7:	e8 e6 00 00 00       	call   f01084c2 <initialize_frame_info>
f01083dc:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01083df:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f01083e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01083e8:	89 d0                	mov    %edx,%eax
f01083ea:	01 c0                	add    %eax,%eax
f01083ec:	01 d0                	add    %edx,%eax
f01083ee:	c1 e0 03             	shl    $0x3,%eax
f01083f1:	01 c8                	add    %ecx,%eax
f01083f3:	85 c0                	test   %eax,%eax
f01083f5:	75 14                	jne    f010840b <initialize_paging+0x312>
f01083f7:	83 ec 04             	sub    $0x4,%esp
f01083fa:	68 e8 5e 12 f0       	push   $0xf0125ee8
f01083ff:	6a 74                	push   $0x74
f0108401:	68 0b 5f 12 f0       	push   $0xf0125f0b
f0108406:	e8 2e 7f ff ff       	call   f0100339 <_panic>
f010840b:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108411:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108414:	89 d0                	mov    %edx,%eax
f0108416:	01 c0                	add    %eax,%eax
f0108418:	01 d0                	add    %edx,%eax
f010841a:	c1 e0 03             	shl    $0x3,%eax
f010841d:	01 c8                	add    %ecx,%eax
f010841f:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108425:	89 10                	mov    %edx,(%eax)
f0108427:	8b 00                	mov    (%eax),%eax
f0108429:	85 c0                	test   %eax,%eax
f010842b:	74 1f                	je     f010844c <initialize_paging+0x353>
f010842d:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108433:	8b 1d 80 f5 b1 f0    	mov    0xf0b1f580,%ebx
f0108439:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010843c:	89 c8                	mov    %ecx,%eax
f010843e:	01 c0                	add    %eax,%eax
f0108440:	01 c8                	add    %ecx,%eax
f0108442:	c1 e0 03             	shl    $0x3,%eax
f0108445:	01 d8                	add    %ebx,%eax
f0108447:	89 42 04             	mov    %eax,0x4(%edx)
f010844a:	eb 19                	jmp    f0108465 <initialize_paging+0x36c>
f010844c:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108452:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108455:	89 d0                	mov    %edx,%eax
f0108457:	01 c0                	add    %eax,%eax
f0108459:	01 d0                	add    %edx,%eax
f010845b:	c1 e0 03             	shl    $0x3,%eax
f010845e:	01 c8                	add    %ecx,%eax
f0108460:	a3 24 f1 b1 f0       	mov    %eax,0xf0b1f124
f0108465:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f010846b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010846e:	89 d0                	mov    %edx,%eax
f0108470:	01 c0                	add    %eax,%eax
f0108472:	01 d0                	add    %edx,%eax
f0108474:	c1 e0 03             	shl    $0x3,%eax
f0108477:	01 c8                	add    %ecx,%eax
f0108479:	a3 20 f1 b1 f0       	mov    %eax,0xf0b1f120
f010847e:	8b 0d 80 f5 b1 f0    	mov    0xf0b1f580,%ecx
f0108484:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108487:	89 d0                	mov    %edx,%eax
f0108489:	01 c0                	add    %eax,%eax
f010848b:	01 d0                	add    %edx,%eax
f010848d:	c1 e0 03             	shl    $0x3,%eax
f0108490:	01 c8                	add    %ecx,%eax
f0108492:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108499:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f010849e:	40                   	inc    %eax
f010849f:	a3 2c f1 b1 f0       	mov    %eax,0xf0b1f12c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f01084a4:	ff 45 f4             	incl   -0xc(%ebp)
f01084a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01084aa:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f01084af:	39 c2                	cmp    %eax,%edx
f01084b1:	0f 82 08 ff ff ff    	jb     f01083bf <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f01084b7:	e8 c9 b9 ff ff       	call   f0103e85 <initialize_disk_page_file>
}
f01084bc:	90                   	nop
f01084bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01084c0:	c9                   	leave  
f01084c1:	c3                   	ret    

f01084c2 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f01084c2:	55                   	push   %ebp
f01084c3:	89 e5                	mov    %esp,%ebp
f01084c5:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f01084c8:	83 ec 04             	sub    $0x4,%esp
f01084cb:	6a 18                	push   $0x18
f01084cd:	6a 00                	push   $0x0
f01084cf:	ff 75 08             	pushl  0x8(%ebp)
f01084d2:	e8 79 7c 01 00       	call   f0120150 <memset>
f01084d7:	83 c4 10             	add    $0x10,%esp
}
f01084da:	90                   	nop
f01084db:	c9                   	leave  
f01084dc:	c3                   	ret    

f01084dd <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01084dd:	55                   	push   %ebp
f01084de:	89 e5                	mov    %esp,%ebp
f01084e0:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01084e3:	83 ec 0c             	sub    $0xc,%esp
f01084e6:	68 40 f1 b1 f0       	push   $0xf0b1f140
f01084eb:	e8 dd 7c 00 00       	call   f01101cd <holding_spinlock>
f01084f0:	83 c4 10             	add    $0x10,%esp
f01084f3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01084f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01084fa:	75 10                	jne    f010850c <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01084fc:	83 ec 0c             	sub    $0xc,%esp
f01084ff:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108504:	e8 ab 7a 00 00       	call   f010ffb4 <acquire_spinlock>
f0108509:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f010850c:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108512:	8b 45 08             	mov    0x8(%ebp),%eax
f0108515:	89 10                	mov    %edx,(%eax)
	int c = 0;
f0108517:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f010851e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108521:	8b 00                	mov    (%eax),%eax
f0108523:	85 c0                	test   %eax,%eax
f0108525:	75 17                	jne    f010853e <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f0108527:	83 ec 04             	sub    $0x4,%esp
f010852a:	68 5c 5f 12 f0       	push   $0xf0125f5c
f010852f:	68 a2 00 00 00       	push   $0xa2
f0108534:	68 0b 5f 12 f0       	push   $0xf0125f0b
f0108539:	e8 fb 7d ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f010853e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108541:	8b 00                	mov    (%eax),%eax
f0108543:	85 c0                	test   %eax,%eax
f0108545:	75 17                	jne    f010855e <allocate_frame+0x81>
f0108547:	83 ec 04             	sub    $0x4,%esp
f010854a:	68 a9 5f 12 f0       	push   $0xf0125fa9
f010854f:	68 a8 00 00 00       	push   $0xa8
f0108554:	68 0b 5f 12 f0       	push   $0xf0125f0b
f0108559:	e8 db 7d ff ff       	call   f0100339 <_panic>
f010855e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108561:	8b 00                	mov    (%eax),%eax
f0108563:	8b 00                	mov    (%eax),%eax
f0108565:	85 c0                	test   %eax,%eax
f0108567:	74 14                	je     f010857d <allocate_frame+0xa0>
f0108569:	8b 45 08             	mov    0x8(%ebp),%eax
f010856c:	8b 00                	mov    (%eax),%eax
f010856e:	8b 00                	mov    (%eax),%eax
f0108570:	8b 55 08             	mov    0x8(%ebp),%edx
f0108573:	8b 12                	mov    (%edx),%edx
f0108575:	8b 52 04             	mov    0x4(%edx),%edx
f0108578:	89 50 04             	mov    %edx,0x4(%eax)
f010857b:	eb 0d                	jmp    f010858a <allocate_frame+0xad>
f010857d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108580:	8b 00                	mov    (%eax),%eax
f0108582:	8b 40 04             	mov    0x4(%eax),%eax
f0108585:	a3 24 f1 b1 f0       	mov    %eax,0xf0b1f124
f010858a:	8b 45 08             	mov    0x8(%ebp),%eax
f010858d:	8b 00                	mov    (%eax),%eax
f010858f:	8b 40 04             	mov    0x4(%eax),%eax
f0108592:	85 c0                	test   %eax,%eax
f0108594:	74 13                	je     f01085a9 <allocate_frame+0xcc>
f0108596:	8b 45 08             	mov    0x8(%ebp),%eax
f0108599:	8b 00                	mov    (%eax),%eax
f010859b:	8b 40 04             	mov    0x4(%eax),%eax
f010859e:	8b 55 08             	mov    0x8(%ebp),%edx
f01085a1:	8b 12                	mov    (%edx),%edx
f01085a3:	8b 12                	mov    (%edx),%edx
f01085a5:	89 10                	mov    %edx,(%eax)
f01085a7:	eb 0c                	jmp    f01085b5 <allocate_frame+0xd8>
f01085a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01085ac:	8b 00                	mov    (%eax),%eax
f01085ae:	8b 00                	mov    (%eax),%eax
f01085b0:	a3 20 f1 b1 f0       	mov    %eax,0xf0b1f120
f01085b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01085b8:	8b 00                	mov    (%eax),%eax
f01085ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01085c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01085c3:	8b 00                	mov    (%eax),%eax
f01085c5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01085cc:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f01085d1:	48                   	dec    %eax
f01085d2:	a3 2c f1 b1 f0       	mov    %eax,0xf0b1f12c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01085d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01085da:	8b 00                	mov    (%eax),%eax
f01085dc:	8a 40 14             	mov    0x14(%eax),%al
f01085df:	84 c0                	test   %al,%al
f01085e1:	74 20                	je     f0108603 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01085e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01085e6:	8b 00                	mov    (%eax),%eax
f01085e8:	8b 50 10             	mov    0x10(%eax),%edx
f01085eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01085ee:	8b 00                	mov    (%eax),%eax
f01085f0:	8b 40 0c             	mov    0xc(%eax),%eax
f01085f3:	8b 40 64             	mov    0x64(%eax),%eax
f01085f6:	83 ec 08             	sub    $0x8,%esp
f01085f9:	52                   	push   %edx
f01085fa:	50                   	push   %eax
f01085fb:	e8 b6 1a 00 00       	call   f010a0b6 <pt_clear_page_table_entry>
f0108600:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f0108603:	8b 45 08             	mov    0x8(%ebp),%eax
f0108606:	8b 00                	mov    (%eax),%eax
f0108608:	83 ec 0c             	sub    $0xc,%esp
f010860b:	50                   	push   %eax
f010860c:	e8 b1 fe ff ff       	call   f01084c2 <initialize_frame_info>
f0108611:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f0108614:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108618:	75 10                	jne    f010862a <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010861a:	83 ec 0c             	sub    $0xc,%esp
f010861d:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108622:	e8 14 7a 00 00       	call   f011003b <release_spinlock>
f0108627:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f010862a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010862f:	c9                   	leave  
f0108630:	c3                   	ret    

f0108631 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108631:	55                   	push   %ebp
f0108632:	89 e5                	mov    %esp,%ebp
f0108634:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f0108637:	83 ec 0c             	sub    $0xc,%esp
f010863a:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010863f:	e8 89 7b 00 00       	call   f01101cd <holding_spinlock>
f0108644:	83 c4 10             	add    $0x10,%esp
f0108647:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010864a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010864e:	75 10                	jne    f0108660 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108650:	83 ec 0c             	sub    $0xc,%esp
f0108653:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108658:	e8 57 79 00 00       	call   f010ffb4 <acquire_spinlock>
f010865d:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108660:	83 ec 0c             	sub    $0xc,%esp
f0108663:	ff 75 08             	pushl  0x8(%ebp)
f0108666:	e8 57 fe ff ff       	call   f01084c2 <initialize_frame_info>
f010866b:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f010866e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108672:	75 17                	jne    f010868b <free_frame+0x5a>
f0108674:	83 ec 04             	sub    $0x4,%esp
f0108677:	68 e8 5e 12 f0       	push   $0xf0125ee8
f010867c:	68 cf 00 00 00       	push   $0xcf
f0108681:	68 0b 5f 12 f0       	push   $0xf0125f0b
f0108686:	e8 ae 7c ff ff       	call   f0100339 <_panic>
f010868b:	8b 15 20 f1 b1 f0    	mov    0xf0b1f120,%edx
f0108691:	8b 45 08             	mov    0x8(%ebp),%eax
f0108694:	89 10                	mov    %edx,(%eax)
f0108696:	8b 45 08             	mov    0x8(%ebp),%eax
f0108699:	8b 00                	mov    (%eax),%eax
f010869b:	85 c0                	test   %eax,%eax
f010869d:	74 0d                	je     f01086ac <free_frame+0x7b>
f010869f:	a1 20 f1 b1 f0       	mov    0xf0b1f120,%eax
f01086a4:	8b 55 08             	mov    0x8(%ebp),%edx
f01086a7:	89 50 04             	mov    %edx,0x4(%eax)
f01086aa:	eb 08                	jmp    f01086b4 <free_frame+0x83>
f01086ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01086af:	a3 24 f1 b1 f0       	mov    %eax,0xf0b1f124
f01086b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01086b7:	a3 20 f1 b1 f0       	mov    %eax,0xf0b1f120
f01086bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01086bf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01086c6:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f01086cb:	40                   	inc    %eax
f01086cc:	a3 2c f1 b1 f0       	mov    %eax,0xf0b1f12c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01086d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01086d5:	75 10                	jne    f01086e7 <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01086d7:	83 ec 0c             	sub    $0xc,%esp
f01086da:	68 40 f1 b1 f0       	push   $0xf0b1f140
f01086df:	e8 57 79 00 00       	call   f011003b <release_spinlock>
f01086e4:	83 c4 10             	add    $0x10,%esp
	}
}
f01086e7:	90                   	nop
f01086e8:	c9                   	leave  
f01086e9:	c3                   	ret    

f01086ea <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01086ea:	55                   	push   %ebp
f01086eb:	89 e5                	mov    %esp,%ebp
f01086ed:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01086f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01086f3:	8b 40 08             	mov    0x8(%eax),%eax
f01086f6:	48                   	dec    %eax
f01086f7:	8b 55 08             	mov    0x8(%ebp),%edx
f01086fa:	66 89 42 08          	mov    %ax,0x8(%edx)
f01086fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0108701:	8b 40 08             	mov    0x8(%eax),%eax
f0108704:	66 85 c0             	test   %ax,%ax
f0108707:	75 0e                	jne    f0108717 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0108709:	83 ec 0c             	sub    $0xc,%esp
f010870c:	ff 75 08             	pushl  0x8(%ebp)
f010870f:	e8 1d ff ff ff       	call   f0108631 <free_frame>
f0108714:	83 c4 10             	add    $0x10,%esp
}
f0108717:	90                   	nop
f0108718:	c9                   	leave  
f0108719:	c3                   	ret    

f010871a <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f010871a:	55                   	push   %ebp
f010871b:	89 e5                	mov    %esp,%ebp
f010871d:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108720:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108723:	c1 e8 16             	shr    $0x16,%eax
f0108726:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010872d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0108737:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010873a:	83 e0 01             	and    $0x1,%eax
f010873d:	85 c0                	test   %eax,%eax
f010873f:	74 74                	je     f01087b5 <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108741:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108748:	77 1d                	ja     f0108767 <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010874a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010874d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108752:	83 ec 0c             	sub    $0xc,%esp
f0108755:	50                   	push   %eax
f0108756:	e8 b7 14 00 00       	call   f0109c12 <kheap_virtual_address>
f010875b:	83 c4 10             	add    $0x10,%esp
f010875e:	89 c2                	mov    %eax,%edx
f0108760:	8b 45 10             	mov    0x10(%ebp),%eax
f0108763:	89 10                	mov    %edx,(%eax)
f0108765:	eb 44                	jmp    f01087ab <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108767:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010876a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010876f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108772:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108775:	c1 e8 0c             	shr    $0xc,%eax
f0108778:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010877b:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0108780:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108783:	72 17                	jb     f010879c <get_page_table+0x82>
f0108785:	ff 75 f0             	pushl  -0x10(%ebp)
f0108788:	68 c8 5f 12 f0       	push   $0xf0125fc8
f010878d:	68 fb 00 00 00       	push   $0xfb
f0108792:	68 0b 5f 12 f0       	push   $0xf0125f0b
f0108797:	e8 9d 7b ff ff       	call   f0100339 <_panic>
f010879c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010879f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01087a4:	89 c2                	mov    %eax,%edx
f01087a6:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a9:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f01087ab:	b8 00 00 00 00       	mov    $0x0,%eax
f01087b0:	e9 b9 00 00 00       	jmp    f010886e <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f01087b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01087b9:	0f 84 a1 00 00 00    	je     f0108860 <get_page_table+0x146>
f01087bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087c2:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f01087c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01087c8:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01087cb:	83 ec 0c             	sub    $0xc,%esp
f01087ce:	6a 00                	push   $0x0
f01087d0:	e8 71 72 00 00       	call   f010fa46 <fault_handler>
f01087d5:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01087d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087db:	c1 e8 16             	shr    $0x16,%eax
f01087de:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01087e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01087e8:	01 d0                	add    %edx,%eax
f01087ea:	8b 00                	mov    (%eax),%eax
f01087ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01087ef:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01087f6:	77 1d                	ja     f0108815 <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01087f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087fb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108800:	83 ec 0c             	sub    $0xc,%esp
f0108803:	50                   	push   %eax
f0108804:	e8 09 14 00 00       	call   f0109c12 <kheap_virtual_address>
f0108809:	83 c4 10             	add    $0x10,%esp
f010880c:	89 c2                	mov    %eax,%edx
f010880e:	8b 45 10             	mov    0x10(%ebp),%eax
f0108811:	89 10                	mov    %edx,(%eax)
f0108813:	eb 44                	jmp    f0108859 <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108815:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108818:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010881d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108820:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108823:	c1 e8 0c             	shr    $0xc,%eax
f0108826:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108829:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f010882e:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108831:	72 17                	jb     f010884a <get_page_table+0x130>
f0108833:	ff 75 e8             	pushl  -0x18(%ebp)
f0108836:	68 c8 5f 12 f0       	push   $0xf0125fc8
f010883b:	68 13 01 00 00       	push   $0x113
f0108840:	68 0b 5f 12 f0       	push   $0xf0125f0b
f0108845:	e8 ef 7a ff ff       	call   f0100339 <_panic>
f010884a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010884d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108852:	89 c2                	mov    %eax,%edx
f0108854:	8b 45 10             	mov    0x10(%ebp),%eax
f0108857:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f0108859:	b8 00 00 00 00       	mov    $0x0,%eax
f010885e:	eb 0e                	jmp    f010886e <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108860:	8b 45 10             	mov    0x10(%ebp),%eax
f0108863:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f0108869:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f010886e:	c9                   	leave  
f010886f:	c3                   	ret    

f0108870 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108870:	55                   	push   %ebp
f0108871:	89 e5                	mov    %esp,%ebp
f0108873:	53                   	push   %ebx
f0108874:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f0108877:	83 ec 0c             	sub    $0xc,%esp
f010887a:	68 00 10 00 00       	push   $0x1000
f010887f:	e8 4b 0f 00 00       	call   f01097cf <kmalloc>
f0108884:	83 c4 10             	add    $0x10,%esp
f0108887:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010888a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010888e:	75 17                	jne    f01088a7 <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108890:	83 ec 04             	sub    $0x4,%esp
f0108893:	68 f7 5f 12 f0       	push   $0xf0125ff7
f0108898:	68 33 01 00 00       	push   $0x133
f010889d:	68 0b 5f 12 f0       	push   $0xf0125f0b
f01088a2:	e8 92 7a ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01088a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01088aa:	c1 e8 16             	shr    $0x16,%eax
f01088ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088b7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01088ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088bd:	83 ec 0c             	sub    $0xc,%esp
f01088c0:	50                   	push   %eax
f01088c1:	e8 ef 12 00 00       	call   f0109bb5 <kheap_physical_address>
f01088c6:	83 c4 10             	add    $0x10,%esp
f01088c9:	83 c8 07             	or     $0x7,%eax
f01088cc:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01088ce:	83 ec 04             	sub    $0x4,%esp
f01088d1:	68 00 10 00 00       	push   $0x1000
f01088d6:	6a 00                	push   $0x0
f01088d8:	ff 75 f4             	pushl  -0xc(%ebp)
f01088db:	e8 70 78 01 00       	call   f0120150 <memset>
f01088e0:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01088e3:	0f 20 d8             	mov    %cr3,%eax
f01088e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01088e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01088ec:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01088ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01088f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01088f5:	c9                   	leave  
f01088f6:	c3                   	ret    

f01088f7 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01088f7:	55                   	push   %ebp
f01088f8:	89 e5                	mov    %esp,%ebp
f01088fa:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01088fd:	83 ec 0c             	sub    $0xc,%esp
f0108900:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0108903:	50                   	push   %eax
f0108904:	e8 d4 fb ff ff       	call   f01084dd <allocate_frame>
f0108909:	83 c4 10             	add    $0x10,%esp
f010890c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f010890f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108912:	83 ec 0c             	sub    $0xc,%esp
f0108915:	50                   	push   %eax
f0108916:	e8 70 f7 ff ff       	call   f010808b <to_physical_address>
f010891b:	83 c4 10             	add    $0x10,%esp
f010891e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0108921:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108924:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108927:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010892a:	c1 e8 0c             	shr    $0xc,%eax
f010892d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108930:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0108935:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108938:	72 17                	jb     f0108951 <__static_cpt+0x5a>
f010893a:	ff 75 ec             	pushl  -0x14(%ebp)
f010893d:	68 c8 5f 12 f0       	push   $0xf0125fc8
f0108942:	68 4e 01 00 00       	push   $0x14e
f0108947:	68 0b 5f 12 f0       	push   $0xf0125f0b
f010894c:	e8 e8 79 ff ff       	call   f0100339 <_panic>
f0108951:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108954:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108959:	89 c2                	mov    %eax,%edx
f010895b:	8b 45 10             	mov    0x10(%ebp),%eax
f010895e:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108960:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108963:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f0108969:	8b 45 0c             	mov    0xc(%ebp),%eax
f010896c:	c1 e8 16             	shr    $0x16,%eax
f010896f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108976:	8b 45 08             	mov    0x8(%ebp),%eax
f0108979:	01 d0                	add    %edx,%eax
f010897b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010897e:	83 ca 07             	or     $0x7,%edx
f0108981:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108983:	8b 45 10             	mov    0x10(%ebp),%eax
f0108986:	8b 00                	mov    (%eax),%eax
f0108988:	83 ec 04             	sub    $0x4,%esp
f010898b:	68 00 10 00 00       	push   $0x1000
f0108990:	6a 00                	push   $0x0
f0108992:	50                   	push   %eax
f0108993:	e8 b8 77 01 00       	call   f0120150 <memset>
f0108998:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010899b:	0f 20 d8             	mov    %cr3,%eax
f010899e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01089a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089a4:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01089a7:	90                   	nop
f01089a8:	c9                   	leave  
f01089a9:	c3                   	ret    

f01089aa <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01089aa:	55                   	push   %ebp
f01089ab:	89 e5                	mov    %esp,%ebp
f01089ad:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01089b0:	ff 75 0c             	pushl  0xc(%ebp)
f01089b3:	e8 d3 f6 ff ff       	call   f010808b <to_physical_address>
f01089b8:	83 c4 04             	add    $0x4,%esp
f01089bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f01089be:	83 ec 04             	sub    $0x4,%esp
f01089c1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f01089c4:	50                   	push   %eax
f01089c5:	ff 75 10             	pushl  0x10(%ebp)
f01089c8:	ff 75 08             	pushl  0x8(%ebp)
f01089cb:	e8 4a fd ff ff       	call   f010871a <get_page_table>
f01089d0:	83 c4 10             	add    $0x10,%esp
f01089d3:	83 f8 01             	cmp    $0x1,%eax
f01089d6:	75 1b                	jne    f01089f3 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01089d8:	83 ec 08             	sub    $0x8,%esp
f01089db:	ff 75 10             	pushl  0x10(%ebp)
f01089de:	ff 75 08             	pushl  0x8(%ebp)
f01089e1:	e8 8a fe ff ff       	call   f0108870 <create_page_table>
f01089e6:	83 c4 10             	add    $0x10,%esp
f01089e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01089ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01089f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089f6:	8b 55 10             	mov    0x10(%ebp),%edx
f01089f9:	c1 ea 0c             	shr    $0xc,%edx
f01089fc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108a02:	c1 e2 02             	shl    $0x2,%edx
f0108a05:	01 d0                	add    %edx,%eax
f0108a07:	8b 00                	mov    (%eax),%eax
f0108a09:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108a0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108a0f:	83 e0 01             	and    $0x1,%eax
f0108a12:	85 c0                	test   %eax,%eax
f0108a14:	74 25                	je     f0108a3b <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0108a16:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108a19:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108a1e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108a21:	75 07                	jne    f0108a2a <map_frame+0x80>
			return 0;
f0108a23:	b8 00 00 00 00       	mov    $0x0,%eax
f0108a28:	eb 68                	jmp    f0108a92 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0108a2a:	83 ec 08             	sub    $0x8,%esp
f0108a2d:	ff 75 10             	pushl  0x10(%ebp)
f0108a30:	ff 75 08             	pushl  0x8(%ebp)
f0108a33:	e8 d2 00 00 00       	call   f0108b0a <unmap_frame>
f0108a38:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108a3e:	8b 40 08             	mov    0x8(%eax),%eax
f0108a41:	40                   	inc    %eax
f0108a42:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108a45:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108a49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108a4c:	8b 55 10             	mov    0x10(%ebp),%edx
f0108a4f:	c1 ea 0c             	shr    $0xc,%edx
f0108a52:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108a58:	c1 e2 02             	shl    $0x2,%edx
f0108a5b:	01 d0                	add    %edx,%eax
f0108a5d:	8b 00                	mov    (%eax),%eax
f0108a5f:	25 00 0e 00 00       	and    $0xe00,%eax
f0108a64:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f0108a67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108a6a:	8b 55 10             	mov    0x10(%ebp),%edx
f0108a6d:	c1 ea 0c             	shr    $0xc,%edx
f0108a70:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108a76:	c1 e2 02             	shl    $0x2,%edx
f0108a79:	01 c2                	add    %eax,%edx
f0108a7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a7e:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108a81:	89 c1                	mov    %eax,%ecx
f0108a83:	8b 45 14             	mov    0x14(%ebp),%eax
f0108a86:	09 c8                	or     %ecx,%eax
f0108a88:	83 c8 01             	or     $0x1,%eax
f0108a8b:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108a8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108a92:	c9                   	leave  
f0108a93:	c3                   	ret    

f0108a94 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108a94:	55                   	push   %ebp
f0108a95:	89 e5                	mov    %esp,%ebp
f0108a97:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f0108a9a:	83 ec 04             	sub    $0x4,%esp
f0108a9d:	ff 75 10             	pushl  0x10(%ebp)
f0108aa0:	ff 75 0c             	pushl  0xc(%ebp)
f0108aa3:	ff 75 08             	pushl  0x8(%ebp)
f0108aa6:	e8 6f fc ff ff       	call   f010871a <get_page_table>
f0108aab:	83 c4 10             	add    $0x10,%esp
f0108aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108ab1:	8b 45 10             	mov    0x10(%ebp),%eax
f0108ab4:	8b 00                	mov    (%eax),%eax
f0108ab6:	85 c0                	test   %eax,%eax
f0108ab8:	74 49                	je     f0108b03 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f0108aba:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108abd:	c1 e8 0c             	shr    $0xc,%eax
f0108ac0:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108ac5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0108ac8:	8b 45 10             	mov    0x10(%ebp),%eax
f0108acb:	8b 00                	mov    (%eax),%eax
f0108acd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108ad0:	c1 e2 02             	shl    $0x2,%edx
f0108ad3:	01 d0                	add    %edx,%eax
f0108ad5:	8b 00                	mov    (%eax),%eax
f0108ad7:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f0108ada:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108add:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108ae2:	85 c0                	test   %eax,%eax
f0108ae4:	74 16                	je     f0108afc <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f0108ae6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ae9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108aee:	83 ec 0c             	sub    $0xc,%esp
f0108af1:	50                   	push   %eax
f0108af2:	e8 a7 f5 ff ff       	call   f010809e <to_frame_info>
f0108af7:	83 c4 10             	add    $0x10,%esp
f0108afa:	eb 0c                	jmp    f0108b08 <get_frame_info+0x74>
		}
		return 0;
f0108afc:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b01:	eb 05                	jmp    f0108b08 <get_frame_info+0x74>
	}
	return 0;
f0108b03:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108b08:	c9                   	leave  
f0108b09:	c3                   	ret    

f0108b0a <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0108b0a:	55                   	push   %ebp
f0108b0b:	89 e5                	mov    %esp,%ebp
f0108b0d:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0108b10:	83 ec 04             	sub    $0x4,%esp
f0108b13:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0108b16:	50                   	push   %eax
f0108b17:	ff 75 0c             	pushl  0xc(%ebp)
f0108b1a:	ff 75 08             	pushl  0x8(%ebp)
f0108b1d:	e8 72 ff ff ff       	call   f0108a94 <get_frame_info>
f0108b22:	83 c4 10             	add    $0x10,%esp
f0108b25:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f0108b28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108b2c:	74 7d                	je     f0108bab <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108b2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b31:	8a 40 14             	mov    0x14(%eax),%al
f0108b34:	84 c0                	test   %al,%al
f0108b36:	74 1c                	je     f0108b54 <unmap_frame+0x4a>
f0108b38:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108b3f:	77 13                	ja     f0108b54 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108b41:	83 ec 08             	sub    $0x8,%esp
f0108b44:	ff 75 0c             	pushl  0xc(%ebp)
f0108b47:	68 14 60 12 f0       	push   $0xf0126014
f0108b4c:	e8 3a 84 ff ff       	call   f0100f8b <cprintf>
f0108b51:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108b54:	83 ec 0c             	sub    $0xc,%esp
f0108b57:	ff 75 f4             	pushl  -0xc(%ebp)
f0108b5a:	e8 8b fb ff ff       	call   f01086ea <decrement_references>
f0108b5f:	83 c4 10             	add    $0x10,%esp
		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108b62:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b65:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b68:	c1 ea 0c             	shr    $0xc,%edx
f0108b6b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b71:	c1 e2 02             	shl    $0x2,%edx
f0108b74:	01 d0                	add    %edx,%eax
f0108b76:	8b 00                	mov    (%eax),%eax
f0108b78:	25 00 0e 00 00       	and    $0xe00,%eax
f0108b7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108b80:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b83:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b86:	c1 ea 0c             	shr    $0xc,%edx
f0108b89:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b8f:	c1 e2 02             	shl    $0x2,%edx
f0108b92:	01 c2                	add    %eax,%edx
f0108b94:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b97:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f0108b99:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108b9c:	83 ec 08             	sub    $0x8,%esp
f0108b9f:	50                   	push   %eax
f0108ba0:	ff 75 08             	pushl  0x8(%ebp)
f0108ba3:	e8 3c f5 ff ff       	call   f01080e4 <tlb_invalidate>
f0108ba8:	83 c4 10             	add    $0x10,%esp
	}
}
f0108bab:	90                   	nop
f0108bac:	c9                   	leave  
f0108bad:	c3                   	ret    

f0108bae <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108bae:	55                   	push   %ebp
f0108baf:	89 e5                	mov    %esp,%ebp
f0108bb1:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108bb4:	ff 75 0c             	pushl  0xc(%ebp)
f0108bb7:	e8 cf f4 ff ff       	call   f010808b <to_physical_address>
f0108bbc:	83 c4 04             	add    $0x4,%esp
f0108bbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108bc2:	8b 45 10             	mov    0x10(%ebp),%eax
f0108bc5:	c1 e8 16             	shr    $0x16,%eax
f0108bc8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108bcf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108bd2:	01 d0                	add    %edx,%eax
f0108bd4:	8b 00                	mov    (%eax),%eax
f0108bd6:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108bd9:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0108be0:	77 19                	ja     f0108bfb <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108be2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108be5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108bea:	83 ec 0c             	sub    $0xc,%esp
f0108bed:	50                   	push   %eax
f0108bee:	e8 1f 10 00 00       	call   f0109c12 <kheap_virtual_address>
f0108bf3:	83 c4 10             	add    $0x10,%esp
f0108bf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108bf9:	eb 40                	jmp    f0108c3b <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108bfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108bfe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108c03:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108c06:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108c09:	c1 e8 0c             	shr    $0xc,%eax
f0108c0c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108c0f:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0108c14:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108c17:	72 17                	jb     f0108c30 <loadtime_map_frame+0x82>
f0108c19:	ff 75 e8             	pushl  -0x18(%ebp)
f0108c1c:	68 c8 5f 12 f0       	push   $0xf0125fc8
f0108c21:	68 f9 01 00 00       	push   $0x1f9
f0108c26:	68 0b 5f 12 f0       	push   $0xf0125f0b
f0108c2b:	e8 09 77 ff ff       	call   f0100339 <_panic>
f0108c30:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108c33:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108c38:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108c3b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108c3f:	75 14                	jne    f0108c55 <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108c41:	83 ec 08             	sub    $0x8,%esp
f0108c44:	ff 75 10             	pushl  0x10(%ebp)
f0108c47:	ff 75 08             	pushl  0x8(%ebp)
f0108c4a:	e8 21 fc ff ff       	call   f0108870 <create_page_table>
f0108c4f:	83 c4 10             	add    $0x10,%esp
f0108c52:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f0108c55:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c58:	8b 40 08             	mov    0x8(%eax),%eax
f0108c5b:	40                   	inc    %eax
f0108c5c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c5f:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108c63:	8b 45 10             	mov    0x10(%ebp),%eax
f0108c66:	c1 e8 0c             	shr    $0xc,%eax
f0108c69:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108c6e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c78:	01 c2                	add    %eax,%edx
f0108c7a:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c7d:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108c80:	83 c8 01             	or     $0x1,%eax
f0108c83:	89 02                	mov    %eax,(%edx)

	return 0;
f0108c85:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c8a:	c9                   	leave  
f0108c8b:	c3                   	ret    

f0108c8c <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108c8c:	55                   	push   %ebp
f0108c8d:	89 e5                	mov    %esp,%ebp
f0108c8f:	57                   	push   %edi
f0108c90:	56                   	push   %esi
f0108c91:	53                   	push   %ebx
f0108c92:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f0108c95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108c9c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108ca3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f0108caa:	83 ec 0c             	sub    $0xc,%esp
f0108cad:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108cb2:	e8 16 75 00 00       	call   f01101cd <holding_spinlock>
f0108cb7:	83 c4 10             	add    $0x10,%esp
f0108cba:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108cbd:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108cc1:	75 10                	jne    f0108cd3 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108cc3:	83 ec 0c             	sub    $0xc,%esp
f0108cc6:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108ccb:	e8 e4 72 00 00       	call   f010ffb4 <acquire_spinlock>
f0108cd0:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108cd3:	a1 20 f1 b1 f0       	mov    0xf0b1f120,%eax
f0108cd8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108cdb:	eb 1a                	jmp    f0108cf7 <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0108cdd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108ce0:	8a 40 14             	mov    0x14(%eax),%al
f0108ce3:	84 c0                	test   %al,%al
f0108ce5:	74 05                	je     f0108cec <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f0108ce7:	ff 45 dc             	incl   -0x24(%ebp)
f0108cea:	eb 03                	jmp    f0108cef <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0108cec:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108cef:	a1 28 f1 b1 f0       	mov    0xf0b1f128,%eax
f0108cf4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108cf7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108cfb:	74 07                	je     f0108d04 <calculate_available_frames+0x78>
f0108cfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108d00:	8b 00                	mov    (%eax),%eax
f0108d02:	eb 05                	jmp    f0108d09 <calculate_available_frames+0x7d>
f0108d04:	b8 00 00 00 00       	mov    $0x0,%eax
f0108d09:	a3 28 f1 b1 f0       	mov    %eax,0xf0b1f128
f0108d0e:	a1 28 f1 b1 f0       	mov    0xf0b1f128,%eax
f0108d13:	85 c0                	test   %eax,%eax
f0108d15:	75 c6                	jne    f0108cdd <calculate_available_frames+0x51>
f0108d17:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108d1b:	75 c0                	jne    f0108cdd <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0108d1d:	a1 3c f1 b1 f0       	mov    0xf0b1f13c,%eax
f0108d22:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f0108d25:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108d29:	75 10                	jne    f0108d3b <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108d2b:	83 ec 0c             	sub    $0xc,%esp
f0108d2e:	68 40 f1 b1 f0       	push   $0xf0b1f140
f0108d33:	e8 03 73 00 00       	call   f011003b <release_spinlock>
f0108d38:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108d3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108d3e:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108d41:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d44:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108d47:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108d4a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108d4d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d50:	89 c3                	mov    %eax,%ebx
f0108d52:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108d55:	ba 03 00 00 00       	mov    $0x3,%edx
f0108d5a:	89 df                	mov    %ebx,%edi
f0108d5c:	89 c6                	mov    %eax,%esi
f0108d5e:	89 d1                	mov    %edx,%ecx
f0108d60:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108d62:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d65:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108d68:	5b                   	pop    %ebx
f0108d69:	5e                   	pop    %esi
f0108d6a:	5f                   	pop    %edi
f0108d6b:	5d                   	pop    %ebp
f0108d6c:	c2 04 00             	ret    $0x4

f0108d6f <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108d6f:	55                   	push   %ebp
f0108d70:	89 e5                	mov    %esp,%ebp
f0108d72:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108d75:	c7 05 e0 ef 71 f0 00 	movl   $0x0,0xf071efe0
f0108d7c:	00 00 00 
f0108d7f:	c7 05 e4 ef 71 f0 00 	movl   $0x0,0xf071efe4
f0108d86:	00 00 00 
f0108d89:	c7 05 ec ef 71 f0 00 	movl   $0x0,0xf071efec
f0108d90:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108d93:	83 ec 08             	sub    $0x8,%esp
f0108d96:	68 44 60 12 f0       	push   $0xf0126044
f0108d9b:	68 f0 ef 71 f0       	push   $0xf071eff0
f0108da0:	e8 de 71 00 00       	call   f010ff83 <init_spinlock>
f0108da5:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108da8:	90                   	nop
f0108da9:	c9                   	leave  
f0108daa:	c3                   	ret    

f0108dab <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108dab:	55                   	push   %ebp
f0108dac:	89 e5                	mov    %esp,%ebp
f0108dae:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108db1:	83 ec 08             	sub    $0x8,%esp
f0108db4:	ff 75 0c             	pushl  0xc(%ebp)
f0108db7:	ff 75 08             	pushl  0x8(%ebp)
f0108dba:	e8 4b 01 00 00       	call   f0108f0a <get_share>
f0108dbf:	83 c4 10             	add    $0x10,%esp
f0108dc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108dc5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108dc9:	75 07                	jne    f0108dd2 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108dcb:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108dd0:	eb 06                	jmp    f0108dd8 <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108dd5:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108dd8:	c9                   	leave  
f0108dd9:	c3                   	ret    

f0108dda <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108dda:	55                   	push   %ebp
f0108ddb:	89 e5                	mov    %esp,%ebp
f0108ddd:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108de0:	8b 15 2c f1 b1 f0    	mov    0xf0b1f12c,%edx
f0108de6:	8b 45 08             	mov    0x8(%ebp),%eax
f0108de9:	39 c2                	cmp    %eax,%edx
f0108deb:	73 07                	jae    f0108df4 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ded:	b8 00 00 00 00       	mov    $0x0,%eax
f0108df2:	eb 3c                	jmp    f0108e30 <create_frames_storage+0x56>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo * ));
f0108df4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108df7:	c1 e0 02             	shl    $0x2,%eax
f0108dfa:	83 ec 0c             	sub    $0xc,%esp
f0108dfd:	50                   	push   %eax
f0108dfe:	e8 cc 09 00 00       	call   f01097cf <kmalloc>
f0108e03:	83 c4 10             	add    $0x10,%esp
f0108e06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108e09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108e0d:	75 07                	jne    f0108e16 <create_frames_storage+0x3c>
f0108e0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0108e14:	eb 1a                	jmp    f0108e30 <create_frames_storage+0x56>
	 // Initialize the FrameInfo struct to zero
	 memset(frames_storage, 0, numOfFrames * sizeof(struct FrameInfo *));
f0108e16:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e19:	c1 e0 02             	shl    $0x2,%eax
f0108e1c:	83 ec 04             	sub    $0x4,%esp
f0108e1f:	50                   	push   %eax
f0108e20:	6a 00                	push   $0x0
f0108e22:	ff 75 f4             	pushl  -0xc(%ebp)
f0108e25:	e8 26 73 01 00       	call   f0120150 <memset>
f0108e2a:	83 c4 10             	add    $0x10,%esp
	return frames_storage;
f0108e2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108e30:	c9                   	leave  
f0108e31:	c3                   	ret    

f0108e32 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108e32:	55                   	push   %ebp
f0108e33:	89 e5                	mov    %esp,%ebp
f0108e35:	83 ec 28             	sub    $0x28,%esp
f0108e38:	8b 45 14             	mov    0x14(%ebp),%eax
f0108e3b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108e3e:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108e45:	8b 55 10             	mov    0x10(%ebp),%edx
f0108e48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e4b:	01 d0                	add    %edx,%eax
f0108e4d:	48                   	dec    %eax
f0108e4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108e51:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e54:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e59:	f7 75 f4             	divl   -0xc(%ebp)
f0108e5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e5f:	29 d0                	sub    %edx,%eax
f0108e61:	c1 e8 0c             	shr    $0xc,%eax
f0108e64:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share));
f0108e67:	83 ec 0c             	sub    $0xc,%esp
f0108e6a:	6a 60                	push   $0x60
f0108e6c:	e8 5e 09 00 00       	call   f01097cf <kmalloc>
f0108e71:	83 c4 10             	add    $0x10,%esp
f0108e74:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share==NULL) return NULL;
f0108e77:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108e7b:	75 0a                	jne    f0108e87 <create_share+0x55>
f0108e7d:	b8 00 00 00 00       	mov    $0x0,%eax
f0108e82:	e9 81 00 00 00       	jmp    f0108f08 <create_share+0xd6>
	created_share->references=1;
f0108e87:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e8a:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)(((int)created_share << 1)>>1); //mask
f0108e91:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e94:	01 c0                	add    %eax,%eax
f0108e96:	d1 f8                	sar    %eax
f0108e98:	89 c2                	mov    %eax,%edx
f0108e9a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e9d:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108e9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ea2:	83 ec 0c             	sub    $0xc,%esp
f0108ea5:	50                   	push   %eax
f0108ea6:	e8 2f ff ff ff       	call   f0108dda <create_frames_storage>
f0108eab:	83 c4 10             	add    $0x10,%esp
f0108eae:	89 c2                	mov    %eax,%edx
f0108eb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108eb3:	89 50 54             	mov    %edx,0x54(%eax)
	if(created_share->framesStorage==NULL)
f0108eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108eb9:	8b 40 54             	mov    0x54(%eax),%eax
f0108ebc:	85 c0                	test   %eax,%eax
f0108ebe:	75 15                	jne    f0108ed5 <create_share+0xa3>
	{
			kfree((void*)created_share);
f0108ec0:	83 ec 0c             	sub    $0xc,%esp
f0108ec3:	ff 75 e8             	pushl  -0x18(%ebp)
f0108ec6:	e8 c4 0b 00 00       	call   f0109a8f <kfree>
f0108ecb:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0108ece:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ed3:	eb 33                	jmp    f0108f08 <create_share+0xd6>
	}
	created_share->ownerID=ownerID;
f0108ed5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ed8:	8b 55 08             	mov    0x8(%ebp),%edx
f0108edb:	89 50 04             	mov    %edx,0x4(%eax)
	strcpy(created_share->name, shareName);
f0108ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ee1:	83 c0 08             	add    $0x8,%eax
f0108ee4:	83 ec 08             	sub    $0x8,%esp
f0108ee7:	ff 75 0c             	pushl  0xc(%ebp)
f0108eea:	50                   	push   %eax
f0108eeb:	e8 c1 70 01 00       	call   f011ffb1 <strcpy>
f0108ef0:	83 c4 10             	add    $0x10,%esp
	created_share->size=size;
f0108ef3:	8b 55 10             	mov    0x10(%ebp),%edx
f0108ef6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ef9:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108efc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108eff:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108f02:	88 50 50             	mov    %dl,0x50(%eax)
	return created_share;
f0108f05:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0108f08:	c9                   	leave  
f0108f09:	c3                   	ret    

f0108f0a <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108f0a:	55                   	push   %ebp
f0108f0b:	89 e5                	mov    %esp,%ebp
f0108f0d:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108f10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&AllShares.shareslock);
f0108f17:	83 ec 0c             	sub    $0xc,%esp
f0108f1a:	68 f0 ef 71 f0       	push   $0xf071eff0
f0108f1f:	e8 90 70 00 00       	call   f010ffb4 <acquire_spinlock>
f0108f24:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108f27:	a1 e0 ef 71 f0       	mov    0xf071efe0,%eax
f0108f2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f2f:	eb 41                	jmp    f0108f72 <get_share+0x68>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f34:	8b 40 04             	mov    0x4(%eax),%eax
f0108f37:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108f3a:	75 2e                	jne    f0108f6a <get_share+0x60>
f0108f3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f3f:	83 c0 08             	add    $0x8,%eax
f0108f42:	83 ec 08             	sub    $0x8,%esp
f0108f45:	ff 75 0c             	pushl  0xc(%ebp)
f0108f48:	50                   	push   %eax
f0108f49:	e8 20 71 01 00       	call   f012006e <strcmp>
f0108f4e:	83 c4 10             	add    $0x10,%esp
f0108f51:	85 c0                	test   %eax,%eax
f0108f53:	75 15                	jne    f0108f6a <get_share+0x60>
		{
			release_spinlock(&AllShares.shareslock);
f0108f55:	83 ec 0c             	sub    $0xc,%esp
f0108f58:	68 f0 ef 71 f0       	push   $0xf071eff0
f0108f5d:	e8 d9 70 00 00       	call   f011003b <release_spinlock>
f0108f62:	83 c4 10             	add    $0x10,%esp
			return founded;
f0108f65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f68:	eb 44                	jmp    f0108fae <get_share+0xa4>
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	acquire_spinlock(&AllShares.shareslock);
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108f6a:	a1 e8 ef 71 f0       	mov    0xf071efe8,%eax
f0108f6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108f76:	74 08                	je     f0108f80 <get_share+0x76>
f0108f78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f7b:	8b 40 58             	mov    0x58(%eax),%eax
f0108f7e:	eb 05                	jmp    f0108f85 <get_share+0x7b>
f0108f80:	b8 00 00 00 00       	mov    $0x0,%eax
f0108f85:	a3 e8 ef 71 f0       	mov    %eax,0xf071efe8
f0108f8a:	a1 e8 ef 71 f0       	mov    0xf071efe8,%eax
f0108f8f:	85 c0                	test   %eax,%eax
f0108f91:	75 9e                	jne    f0108f31 <get_share+0x27>
f0108f93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108f97:	75 98                	jne    f0108f31 <get_share+0x27>
		{
			release_spinlock(&AllShares.shareslock);
			return founded;
		}
	}
	release_spinlock(&AllShares.shareslock);
f0108f99:	83 ec 0c             	sub    $0xc,%esp
f0108f9c:	68 f0 ef 71 f0       	push   $0xf071eff0
f0108fa1:	e8 95 70 00 00       	call   f011003b <release_spinlock>
f0108fa6:	83 c4 10             	add    $0x10,%esp
	return NULL;
f0108fa9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108fae:	c9                   	leave  
f0108faf:	c3                   	ret    

f0108fb0 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108fb0:	55                   	push   %ebp
f0108fb1:	89 e5                	mov    %esp,%ebp
f0108fb3:	83 ec 48             	sub    $0x48,%esp
f0108fb6:	8b 45 14             	mov    0x14(%ebp),%eax
f0108fb9:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108fbc:	e8 64 2d 00 00       	call   f010bd25 <get_cpu_proc>
f0108fc1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108fc4:	83 ec 08             	sub    $0x8,%esp
f0108fc7:	ff 75 0c             	pushl  0xc(%ebp)
f0108fca:	ff 75 08             	pushl  0x8(%ebp)
f0108fcd:	e8 38 ff ff ff       	call   f0108f0a <get_share>
f0108fd2:	83 c4 10             	add    $0x10,%esp
f0108fd5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108fd8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108fdc:	74 0a                	je     f0108fe8 <createSharedObject+0x38>
f0108fde:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108fe3:	e9 59 01 00 00       	jmp    f0109141 <createSharedObject+0x191>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108fe8:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108fec:	50                   	push   %eax
f0108fed:	ff 75 10             	pushl  0x10(%ebp)
f0108ff0:	ff 75 0c             	pushl  0xc(%ebp)
f0108ff3:	ff 75 08             	pushl  0x8(%ebp)
f0108ff6:	e8 37 fe ff ff       	call   f0108e32 <create_share>
f0108ffb:	83 c4 10             	add    $0x10,%esp
f0108ffe:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0109001:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109005:	75 0a                	jne    f0109011 <createSharedObject+0x61>
f0109007:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f010900c:	e9 30 01 00 00       	jmp    f0109141 <createSharedObject+0x191>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0109011:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0109018:	8b 55 10             	mov    0x10(%ebp),%edx
f010901b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010901e:	01 d0                	add    %edx,%eax
f0109020:	48                   	dec    %eax
f0109021:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0109024:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109027:	ba 00 00 00 00       	mov    $0x0,%edx
f010902c:	f7 75 e4             	divl   -0x1c(%ebp)
f010902f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109032:	29 d0                	sub    %edx,%eax
f0109034:	c1 e8 0c             	shr    $0xc,%eax
f0109037:	89 45 dc             	mov    %eax,-0x24(%ebp)
	for (int k = 0; k < num_pages; k++)
f010903a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109041:	eb 6c                	jmp    f01090af <createSharedObject+0xff>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0109043:	83 ec 0c             	sub    $0xc,%esp
f0109046:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0109049:	50                   	push   %eax
f010904a:	e8 8e f4 ff ff       	call   f01084dd <allocate_frame>
f010904f:	83 c4 10             	add    $0x10,%esp
f0109052:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret == 0)
f0109055:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0109059:	75 3d                	jne    f0109098 <createSharedObject+0xe8>
		{
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
f010905b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010905e:	c1 e0 0c             	shl    $0xc,%eax
f0109061:	89 c2                	mov    %eax,%edx
f0109063:	8b 45 18             	mov    0x18(%ebp),%eax
f0109066:	01 d0                	add    %edx,%eax
f0109068:	89 c1                	mov    %eax,%ecx
f010906a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010906d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109070:	8b 40 64             	mov    0x64(%eax),%eax
f0109073:	6a 06                	push   $0x6
f0109075:	51                   	push   %ecx
f0109076:	52                   	push   %edx
f0109077:	50                   	push   %eax
f0109078:	e8 2d f9 ff ff       	call   f01089aa <map_frame>
f010907d:	83 c4 10             	add    $0x10,%esp
			created_share->framesStorage[k] = ptr_frame_info;
f0109080:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109083:	8b 40 54             	mov    0x54(%eax),%eax
f0109086:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109089:	c1 e2 02             	shl    $0x2,%edx
f010908c:	01 c2                	add    %eax,%edx
f010908e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109091:	89 02                	mov    %eax,(%edx)
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f0109093:	ff 45 f4             	incl   -0xc(%ebp)
f0109096:	eb 17                	jmp    f01090af <createSharedObject+0xff>
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
			created_share->framesStorage[k] = ptr_frame_info;
		}
		else
		{
			panic("No Memory");
f0109098:	83 ec 04             	sub    $0x4,%esp
f010909b:	68 50 60 12 f0       	push   $0xf0126050
f01090a0:	68 a5 00 00 00       	push   $0xa5
f01090a5:	68 5c 60 12 f0       	push   $0xf012605c
f01090aa:	e8 8a 72 ff ff       	call   f0100339 <_panic>
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f01090af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01090b2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01090b5:	72 8c                	jb     f0109043 <createSharedObject+0x93>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f01090b7:	83 ec 0c             	sub    $0xc,%esp
f01090ba:	68 f0 ef 71 f0       	push   $0xf071eff0
f01090bf:	e8 f0 6e 00 00       	call   f010ffb4 <acquire_spinlock>
f01090c4:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f01090c7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01090cb:	75 17                	jne    f01090e4 <createSharedObject+0x134>
f01090cd:	83 ec 04             	sub    $0x4,%esp
f01090d0:	68 80 60 12 f0       	push   $0xf0126080
f01090d5:	68 aa 00 00 00       	push   $0xaa
f01090da:	68 5c 60 12 f0       	push   $0xf012605c
f01090df:	e8 55 72 ff ff       	call   f0100339 <_panic>
f01090e4:	8b 15 e4 ef 71 f0    	mov    0xf071efe4,%edx
f01090ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01090ed:	89 50 5c             	mov    %edx,0x5c(%eax)
f01090f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01090f3:	8b 40 5c             	mov    0x5c(%eax),%eax
f01090f6:	85 c0                	test   %eax,%eax
f01090f8:	74 0d                	je     f0109107 <createSharedObject+0x157>
f01090fa:	a1 e4 ef 71 f0       	mov    0xf071efe4,%eax
f01090ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0109102:	89 50 58             	mov    %edx,0x58(%eax)
f0109105:	eb 08                	jmp    f010910f <createSharedObject+0x15f>
f0109107:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010910a:	a3 e0 ef 71 f0       	mov    %eax,0xf071efe0
f010910f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109112:	a3 e4 ef 71 f0       	mov    %eax,0xf071efe4
f0109117:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010911a:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0109121:	a1 ec ef 71 f0       	mov    0xf071efec,%eax
f0109126:	40                   	inc    %eax
f0109127:	a3 ec ef 71 f0       	mov    %eax,0xf071efec
	release_spinlock(&AllShares.shareslock);
f010912c:	83 ec 0c             	sub    $0xc,%esp
f010912f:	68 f0 ef 71 f0       	push   $0xf071eff0
f0109134:	e8 02 6f 00 00       	call   f011003b <release_spinlock>
f0109139:	83 c4 10             	add    $0x10,%esp
	return created_share->ID;
f010913c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010913f:	8b 00                	mov    (%eax),%eax
}
f0109141:	c9                   	leave  
f0109142:	c3                   	ret    

f0109143 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0109143:	55                   	push   %ebp
f0109144:	89 e5                	mov    %esp,%ebp
f0109146:	53                   	push   %ebx
f0109147:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f010914a:	e8 d6 2b 00 00       	call   f010bd25 <get_cpu_proc>
f010914f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share * shared_obj = get_share(ownerID,shareName);
f0109152:	83 ec 08             	sub    $0x8,%esp
f0109155:	ff 75 0c             	pushl  0xc(%ebp)
f0109158:	ff 75 08             	pushl  0x8(%ebp)
f010915b:	e8 aa fd ff ff       	call   f0108f0a <get_share>
f0109160:	83 c4 10             	add    $0x10,%esp
f0109163:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
f0109166:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010916a:	75 0a                	jne    f0109176 <getSharedObject+0x33>
f010916c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0109171:	e9 a0 00 00 00       	jmp    f0109216 <getSharedObject+0xd3>
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
f0109176:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010917d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109180:	8b 40 48             	mov    0x48(%eax),%eax
f0109183:	89 c2                	mov    %eax,%edx
f0109185:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109188:	01 d0                	add    %edx,%eax
f010918a:	48                   	dec    %eax
f010918b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010918e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109191:	ba 00 00 00 00       	mov    $0x0,%edx
f0109196:	f7 75 e8             	divl   -0x18(%ebp)
f0109199:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010919c:	29 d0                	sub    %edx,%eax
f010919e:	85 c0                	test   %eax,%eax
f01091a0:	79 05                	jns    f01091a7 <getSharedObject+0x64>
f01091a2:	05 ff 0f 00 00       	add    $0xfff,%eax
f01091a7:	c1 f8 0c             	sar    $0xc,%eax
f01091aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for(int i = 0 ;i< numOfFrames ;i++)
f01091ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01091b4:	eb 44                	jmp    f01091fa <getSharedObject+0xb7>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
f01091b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01091b9:	8a 40 50             	mov    0x50(%eax),%al
f01091bc:	0f b6 c0             	movzbl %al,%eax
f01091bf:	01 c0                	add    %eax,%eax
f01091c1:	83 c8 04             	or     $0x4,%eax
f01091c4:	89 c3                	mov    %eax,%ebx
f01091c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091c9:	c1 e0 0c             	shl    $0xc,%eax
f01091cc:	89 c2                	mov    %eax,%edx
f01091ce:	8b 45 10             	mov    0x10(%ebp),%eax
f01091d1:	01 d0                	add    %edx,%eax
f01091d3:	89 c1                	mov    %eax,%ecx
f01091d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01091d8:	8b 40 54             	mov    0x54(%eax),%eax
f01091db:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01091de:	c1 e2 02             	shl    $0x2,%edx
f01091e1:	01 d0                	add    %edx,%eax
f01091e3:	8b 10                	mov    (%eax),%edx
f01091e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091e8:	8b 40 64             	mov    0x64(%eax),%eax
f01091eb:	53                   	push   %ebx
f01091ec:	51                   	push   %ecx
f01091ed:	52                   	push   %edx
f01091ee:	50                   	push   %eax
f01091ef:	e8 b6 f7 ff ff       	call   f01089aa <map_frame>
f01091f4:	83 c4 10             	add    $0x10,%esp

	struct Env* myenv = get_cpu_proc(); //The calling environment
	struct Share * shared_obj = get_share(ownerID,shareName);
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0 ;i< numOfFrames ;i++)
f01091f7:	ff 45 f4             	incl   -0xc(%ebp)
f01091fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091fd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0109200:	72 b4                	jb     f01091b6 <getSharedObject+0x73>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
	}
	shared_obj->references++;
f0109202:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109205:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109208:	8d 50 01             	lea    0x1(%eax),%edx
f010920b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010920e:	89 50 4c             	mov    %edx,0x4c(%eax)
	return shared_obj->ID;
f0109211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109214:	8b 00                	mov    (%eax),%eax
}
f0109216:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109219:	c9                   	leave  
f010921a:	c3                   	ret    

f010921b <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f010921b:	55                   	push   %ebp
f010921c:	89 e5                	mov    %esp,%ebp
f010921e:	83 ec 08             	sub    $0x8,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0109221:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109225:	0f 84 ca 00 00 00    	je     f01092f5 <free_share+0xda>
    acquire_spinlock(&AllShares.shareslock);
f010922b:	83 ec 0c             	sub    $0xc,%esp
f010922e:	68 f0 ef 71 f0       	push   $0xf071eff0
f0109233:	e8 7c 6d 00 00       	call   f010ffb4 <acquire_spinlock>
f0109238:	83 c4 10             	add    $0x10,%esp
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
f010923b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010923f:	75 17                	jne    f0109258 <free_share+0x3d>
f0109241:	83 ec 04             	sub    $0x4,%esp
f0109244:	68 a3 60 12 f0       	push   $0xf01260a3
f0109249:	68 d7 00 00 00       	push   $0xd7
f010924e:	68 5c 60 12 f0       	push   $0xf012605c
f0109253:	e8 e1 70 ff ff       	call   f0100339 <_panic>
f0109258:	8b 45 08             	mov    0x8(%ebp),%eax
f010925b:	8b 40 58             	mov    0x58(%eax),%eax
f010925e:	85 c0                	test   %eax,%eax
f0109260:	74 11                	je     f0109273 <free_share+0x58>
f0109262:	8b 45 08             	mov    0x8(%ebp),%eax
f0109265:	8b 40 58             	mov    0x58(%eax),%eax
f0109268:	8b 55 08             	mov    0x8(%ebp),%edx
f010926b:	8b 52 5c             	mov    0x5c(%edx),%edx
f010926e:	89 50 5c             	mov    %edx,0x5c(%eax)
f0109271:	eb 0b                	jmp    f010927e <free_share+0x63>
f0109273:	8b 45 08             	mov    0x8(%ebp),%eax
f0109276:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109279:	a3 e4 ef 71 f0       	mov    %eax,0xf071efe4
f010927e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109281:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109284:	85 c0                	test   %eax,%eax
f0109286:	74 11                	je     f0109299 <free_share+0x7e>
f0109288:	8b 45 08             	mov    0x8(%ebp),%eax
f010928b:	8b 40 5c             	mov    0x5c(%eax),%eax
f010928e:	8b 55 08             	mov    0x8(%ebp),%edx
f0109291:	8b 52 58             	mov    0x58(%edx),%edx
f0109294:	89 50 58             	mov    %edx,0x58(%eax)
f0109297:	eb 0b                	jmp    f01092a4 <free_share+0x89>
f0109299:	8b 45 08             	mov    0x8(%ebp),%eax
f010929c:	8b 40 58             	mov    0x58(%eax),%eax
f010929f:	a3 e0 ef 71 f0       	mov    %eax,0xf071efe0
f01092a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01092a7:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f01092ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01092b1:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f01092b8:	a1 ec ef 71 f0       	mov    0xf071efec,%eax
f01092bd:	48                   	dec    %eax
f01092be:	a3 ec ef 71 f0       	mov    %eax,0xf071efec
    release_spinlock(&AllShares.shareslock);
f01092c3:	83 ec 0c             	sub    $0xc,%esp
f01092c6:	68 f0 ef 71 f0       	push   $0xf071eff0
f01092cb:	e8 6b 6d 00 00       	call   f011003b <release_spinlock>
f01092d0:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare->framesStorage);
f01092d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01092d6:	8b 40 54             	mov    0x54(%eax),%eax
f01092d9:	83 ec 0c             	sub    $0xc,%esp
f01092dc:	50                   	push   %eax
f01092dd:	e8 ad 07 00 00       	call   f0109a8f <kfree>
f01092e2:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare);
f01092e5:	83 ec 0c             	sub    $0xc,%esp
f01092e8:	ff 75 08             	pushl  0x8(%ebp)
f01092eb:	e8 9f 07 00 00       	call   f0109a8f <kfree>
f01092f0:	83 c4 10             	add    $0x10,%esp
f01092f3:	eb 01                	jmp    f01092f6 <free_share+0xdb>
{
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f01092f5:	90                   	nop
    acquire_spinlock(&AllShares.shareslock);
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
    release_spinlock(&AllShares.shareslock);
    kfree((void*)ptrShare->framesStorage);
    kfree((void*)ptrShare);
}
f01092f6:	c9                   	leave  
f01092f7:	c3                   	ret    

f01092f8 <get_Share_id>:
//========================
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
f01092f8:	55                   	push   %ebp
f01092f9:	89 e5                	mov    %esp,%ebp
f01092fb:	83 ec 18             	sub    $0x18,%esp
    struct Share* founded = NULL;
f01092fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        acquire_spinlock(&AllShares.shareslock);
f0109305:	83 ec 0c             	sub    $0xc,%esp
f0109308:	68 f0 ef 71 f0       	push   $0xf071eff0
f010930d:	e8 a2 6c 00 00       	call   f010ffb4 <acquire_spinlock>
f0109312:	83 c4 10             	add    $0x10,%esp
        LIST_FOREACH(founded, &AllShares.shares_list) {
f0109315:	a1 e0 ef 71 f0       	mov    0xf071efe0,%eax
f010931a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010931d:	eb 27                	jmp    f0109346 <get_Share_id+0x4e>
            if(founded->ID == sharedObjectID)
f010931f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109322:	8b 00                	mov    (%eax),%eax
f0109324:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109327:	75 15                	jne    f010933e <get_Share_id+0x46>
            {
                release_spinlock(&AllShares.shareslock);
f0109329:	83 ec 0c             	sub    $0xc,%esp
f010932c:	68 f0 ef 71 f0       	push   $0xf071eff0
f0109331:	e8 05 6d 00 00       	call   f011003b <release_spinlock>
f0109336:	83 c4 10             	add    $0x10,%esp
                return founded;
f0109339:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010933c:	eb 44                	jmp    f0109382 <get_Share_id+0x8a>
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
    struct Share* founded = NULL;
        acquire_spinlock(&AllShares.shareslock);
        LIST_FOREACH(founded, &AllShares.shares_list) {
f010933e:	a1 e8 ef 71 f0       	mov    0xf071efe8,%eax
f0109343:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109346:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010934a:	74 08                	je     f0109354 <get_Share_id+0x5c>
f010934c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010934f:	8b 40 58             	mov    0x58(%eax),%eax
f0109352:	eb 05                	jmp    f0109359 <get_Share_id+0x61>
f0109354:	b8 00 00 00 00       	mov    $0x0,%eax
f0109359:	a3 e8 ef 71 f0       	mov    %eax,0xf071efe8
f010935e:	a1 e8 ef 71 f0       	mov    0xf071efe8,%eax
f0109363:	85 c0                	test   %eax,%eax
f0109365:	75 b8                	jne    f010931f <get_Share_id+0x27>
f0109367:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010936b:	75 b2                	jne    f010931f <get_Share_id+0x27>
            {
                release_spinlock(&AllShares.shareslock);
                return founded;
            }
        }
        release_spinlock(&AllShares.shareslock);
f010936d:	83 ec 0c             	sub    $0xc,%esp
f0109370:	68 f0 ef 71 f0       	push   $0xf071eff0
f0109375:	e8 c1 6c 00 00       	call   f011003b <release_spinlock>
f010937a:	83 c4 10             	add    $0x10,%esp
        return NULL;
f010937d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109382:	c9                   	leave  
f0109383:	c3                   	ret    

f0109384 <freeSharedObject>:

int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0109384:	55                   	push   %ebp
f0109385:	89 e5                	mov    %esp,%ebp
f0109387:	83 ec 38             	sub    $0x38,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
    //panic("freeSharedObject is not implemented yet");
    //Your Code is Here...
		struct Env* myenv = get_cpu_proc();
f010938a:	e8 96 29 00 00       	call   f010bd25 <get_cpu_proc>
f010938f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
f0109392:	83 ec 08             	sub    $0x8,%esp
f0109395:	ff 75 0c             	pushl  0xc(%ebp)
f0109398:	ff 75 08             	pushl  0x8(%ebp)
f010939b:	e8 58 ff ff ff       	call   f01092f8 <get_Share_id>
f01093a0:	83 c4 10             	add    $0x10,%esp
f01093a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(ptr_share == NULL) return -1;
f01093a6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01093aa:	75 0a                	jne    f01093b6 <freeSharedObject+0x32>
f01093ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01093b1:	e9 43 01 00 00       	jmp    f01094f9 <freeSharedObject+0x175>
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
f01093b6:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f01093bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01093c0:	8b 40 48             	mov    0x48(%eax),%eax
f01093c3:	89 c2                	mov    %eax,%edx
f01093c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01093c8:	01 d0                	add    %edx,%eax
f01093ca:	48                   	dec    %eax
f01093cb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01093ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01093d1:	ba 00 00 00 00       	mov    $0x0,%edx
f01093d6:	f7 75 e0             	divl   -0x20(%ebp)
f01093d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01093dc:	29 d0                	sub    %edx,%eax
f01093de:	85 c0                	test   %eax,%eax
f01093e0:	79 05                	jns    f01093e7 <freeSharedObject+0x63>
f01093e2:	05 ff 0f 00 00       	add    $0xfff,%eax
f01093e7:	c1 f8 0c             	sar    $0xc,%eax
f01093ea:	89 45 d8             	mov    %eax,-0x28(%ebp)
        uint32* ptr_page_table;

        for(int k = 0;k<no_of_pages;k++)
f01093ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01093f4:	e9 bc 00 00 00       	jmp    f01094b5 <freeSharedObject+0x131>
		{

			int ret = get_page_table(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)), &ptr_page_table);
f01093f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093fc:	c1 e0 0c             	shl    $0xc,%eax
f01093ff:	89 c2                	mov    %eax,%edx
f0109401:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109404:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109407:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010940a:	8b 40 64             	mov    0x64(%eax),%eax
f010940d:	83 ec 04             	sub    $0x4,%esp
f0109410:	8d 55 cc             	lea    -0x34(%ebp),%edx
f0109413:	52                   	push   %edx
f0109414:	51                   	push   %ecx
f0109415:	50                   	push   %eax
f0109416:	e8 ff f2 ff ff       	call   f010871a <get_page_table>
f010941b:	83 c4 10             	add    $0x10,%esp
f010941e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			unmap_frame(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)));
f0109421:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109424:	c1 e0 0c             	shl    $0xc,%eax
f0109427:	89 c2                	mov    %eax,%edx
f0109429:	8b 45 0c             	mov    0xc(%ebp),%eax
f010942c:	01 c2                	add    %eax,%edx
f010942e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109431:	8b 40 64             	mov    0x64(%eax),%eax
f0109434:	83 ec 08             	sub    $0x8,%esp
f0109437:	52                   	push   %edx
f0109438:	50                   	push   %eax
f0109439:	e8 cc f6 ff ff       	call   f0108b0a <unmap_frame>
f010943e:	83 c4 10             	add    $0x10,%esp
			bool isFree = 1;
f0109441:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			for(int i=0;i<1024;i++)
f0109448:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010944f:	eb 22                	jmp    f0109473 <freeSharedObject+0xef>
			{

				if((EXTRACT_ADDRESS(ptr_page_table[i])) != 0){
f0109451:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109454:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109457:	c1 e2 02             	shl    $0x2,%edx
f010945a:	01 d0                	add    %edx,%eax
f010945c:	8b 00                	mov    (%eax),%eax
f010945e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109463:	85 c0                	test   %eax,%eax
f0109465:	74 09                	je     f0109470 <freeSharedObject+0xec>
					isFree = 0;
f0109467:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					break;
f010946e:	eb 0c                	jmp    f010947c <freeSharedObject+0xf8>
		{

			int ret = get_page_table(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)), &ptr_page_table);
			unmap_frame(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)));
			bool isFree = 1;
			for(int i=0;i<1024;i++)
f0109470:	ff 45 ec             	incl   -0x14(%ebp)
f0109473:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010947a:	7e d5                	jle    f0109451 <freeSharedObject+0xcd>
					isFree = 0;
					break;
				}
			}

			if(isFree)
f010947c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109480:	74 30                	je     f01094b2 <freeSharedObject+0x12e>
			{
				kfree((void*)ptr_page_table);
f0109482:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109485:	83 ec 0c             	sub    $0xc,%esp
f0109488:	50                   	push   %eax
f0109489:	e8 01 06 00 00       	call   f0109a8f <kfree>
f010948e:	83 c4 10             	add    $0x10,%esp
				myenv->env_page_directory[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))] = 0;
f0109491:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109494:	8b 40 64             	mov    0x64(%eax),%eax
f0109497:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010949a:	c1 e2 0c             	shl    $0xc,%edx
f010949d:	89 d1                	mov    %edx,%ecx
f010949f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01094a2:	01 ca                	add    %ecx,%edx
f01094a4:	c1 ea 16             	shr    $0x16,%edx
f01094a7:	c1 e2 02             	shl    $0x2,%edx
f01094aa:	01 d0                	add    %edx,%eax
f01094ac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
        if(ptr_share == NULL) return -1;
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
        uint32* ptr_page_table;

        for(int k = 0;k<no_of_pages;k++)
f01094b2:	ff 45 f4             	incl   -0xc(%ebp)
f01094b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094b8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01094bb:	0f 82 38 ff ff ff    	jb     f01093f9 <freeSharedObject+0x75>
			}




        ptr_share->references--;
f01094c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094c4:	8b 40 4c             	mov    0x4c(%eax),%eax
f01094c7:	8d 50 ff             	lea    -0x1(%eax),%edx
f01094ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094cd:	89 50 4c             	mov    %edx,0x4c(%eax)

        if(ptr_share->references < 1){
f01094d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094d3:	8b 40 4c             	mov    0x4c(%eax),%eax
f01094d6:	85 c0                	test   %eax,%eax
f01094d8:	75 0e                	jne    f01094e8 <freeSharedObject+0x164>
            free_share(ptr_share);
f01094da:	83 ec 0c             	sub    $0xc,%esp
f01094dd:	ff 75 e4             	pushl  -0x1c(%ebp)
f01094e0:	e8 36 fd ff ff       	call   f010921b <free_share>
f01094e5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01094e8:	0f 20 d8             	mov    %cr3,%eax
f01094eb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01094ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01094f1:	0f 22 d8             	mov    %eax,%cr3
        }
        tlbflush();
        return 0;
f01094f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01094f9:	c9                   	leave  
f01094fa:	c3                   	ret    

f01094fb <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01094fb:	55                   	push   %ebp
f01094fc:	89 e5                	mov    %esp,%ebp
f01094fe:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0109503:	83 f8 01             	cmp    $0x1,%eax
f0109506:	75 04                	jne    f010950c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0109508:	b0 01                	mov    $0x1,%al
f010950a:	eb 02                	jmp    f010950e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010950c:	b0 00                	mov    $0x0,%al
f010950e:	5d                   	pop    %ebp
f010950f:	c3                   	ret    

f0109510 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0109510:	55                   	push   %ebp
f0109511:	89 e5                	mov    %esp,%ebp
f0109513:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0109518:	83 f8 02             	cmp    $0x2,%eax
f010951b:	75 04                	jne    f0109521 <isKHeapPlacementStrategyBESTFIT+0x11>
f010951d:	b0 01                	mov    $0x1,%al
f010951f:	eb 02                	jmp    f0109523 <isKHeapPlacementStrategyBESTFIT+0x13>
f0109521:	b0 00                	mov    $0x0,%al
f0109523:	5d                   	pop    %ebp
f0109524:	c3                   	ret    

f0109525 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0109525:	55                   	push   %ebp
f0109526:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0109528:	8b 45 08             	mov    0x8(%ebp),%eax
f010952b:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f0109531:	29 d0                	sub    %edx,%eax
f0109533:	c1 f8 03             	sar    $0x3,%eax
f0109536:	89 c2                	mov    %eax,%edx
f0109538:	89 d0                	mov    %edx,%eax
f010953a:	c1 e0 02             	shl    $0x2,%eax
f010953d:	01 d0                	add    %edx,%eax
f010953f:	c1 e0 02             	shl    $0x2,%eax
f0109542:	01 d0                	add    %edx,%eax
f0109544:	c1 e0 02             	shl    $0x2,%eax
f0109547:	01 d0                	add    %edx,%eax
f0109549:	89 c1                	mov    %eax,%ecx
f010954b:	c1 e1 08             	shl    $0x8,%ecx
f010954e:	01 c8                	add    %ecx,%eax
f0109550:	89 c1                	mov    %eax,%ecx
f0109552:	c1 e1 10             	shl    $0x10,%ecx
f0109555:	01 c8                	add    %ecx,%eax
f0109557:	01 c0                	add    %eax,%eax
f0109559:	01 d0                	add    %edx,%eax
}
f010955b:	5d                   	pop    %ebp
f010955c:	c3                   	ret    

f010955d <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010955d:	55                   	push   %ebp
f010955e:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0109560:	ff 75 08             	pushl  0x8(%ebp)
f0109563:	e8 bd ff ff ff       	call   f0109525 <to_frame_number>
f0109568:	83 c4 04             	add    $0x4,%esp
f010956b:	c1 e0 0c             	shl    $0xc,%eax
}
f010956e:	c9                   	leave  
f010956f:	c3                   	ret    

f0109570 <initialize_kheap_dynamic_allocator>:




int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0109570:	55                   	push   %ebp
f0109571:	89 e5                	mov    %esp,%ebp
f0109573:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");

	init_spinlock(&kheaplock,"kheaplock");
f0109576:	83 ec 08             	sub    $0x8,%esp
f0109579:	68 c4 60 12 f0       	push   $0xf01260c4
f010957e:	68 40 f7 f1 f0       	push   $0xf0f1f740
f0109583:	e8 fb 69 00 00       	call   f010ff83 <init_spinlock>
f0109588:	83 c4 10             	add    $0x10,%esp

	start = daStart;
f010958b:	8b 45 08             	mov    0x8(%ebp),%eax
f010958e:	a3 48 f8 f1 f0       	mov    %eax,0xf0f1f848
	hard_limit = daLimit;
f0109593:	8b 45 10             	mov    0x10(%ebp),%eax
f0109596:	a3 14 f6 b1 f0       	mov    %eax,0xf0b1f614
	brk = daStart + initSizeToAllocate;
f010959b:	8b 55 08             	mov    0x8(%ebp),%edx
f010959e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095a1:	01 d0                	add    %edx,%eax
f01095a3:	a3 40 f8 f1 f0       	mov    %eax,0xf0f1f840

	if(brk > daLimit) panic("exceeds Limit");
f01095a8:	a1 40 f8 f1 f0       	mov    0xf0f1f840,%eax
f01095ad:	3b 45 10             	cmp    0x10(%ebp),%eax
f01095b0:	76 14                	jbe    f01095c6 <initialize_kheap_dynamic_allocator+0x56>
f01095b2:	83 ec 04             	sub    $0x4,%esp
f01095b5:	68 ce 60 12 f0       	push   $0xf01260ce
f01095ba:	6a 1e                	push   $0x1e
f01095bc:	68 dc 60 12 f0       	push   $0xf01260dc
f01095c1:	e8 73 6d ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f01095c6:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f01095cd:	8b 45 10             	mov    0x10(%ebp),%eax
f01095d0:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f01095d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f01095d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095dc:	c1 e8 0c             	shr    $0xc,%eax
f01095df:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f01095e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01095e9:	e9 8a 00 00 00       	jmp    f0109678 <initialize_kheap_dynamic_allocator+0x108>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f01095ee:	83 ec 0c             	sub    $0xc,%esp
f01095f1:	8d 45 d8             	lea    -0x28(%ebp),%eax
f01095f4:	50                   	push   %eax
f01095f5:	e8 e3 ee ff ff       	call   f01084dd <allocate_frame>
f01095fa:	83 c4 10             	add    $0x10,%esp
f01095fd:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f0109600:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f0109604:	74 5e                	je     f0109664 <initialize_kheap_dynamic_allocator+0xf4>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f0109606:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109609:	c1 e0 0c             	shl    $0xc,%eax
f010960c:	89 c2                	mov    %eax,%edx
f010960e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109611:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109614:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0109617:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f010961c:	6a 02                	push   $0x2
f010961e:	51                   	push   %ecx
f010961f:	52                   	push   %edx
f0109620:	50                   	push   %eax
f0109621:	e8 84 f3 ff ff       	call   f01089aa <map_frame>
f0109626:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f0109629:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010962c:	c1 e0 0c             	shl    $0xc,%eax
f010962f:	89 c2                	mov    %eax,%edx
f0109631:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109634:	01 d0                	add    %edx,%eax
f0109636:	83 ec 0c             	sub    $0xc,%esp
f0109639:	50                   	push   %eax
f010963a:	e8 76 05 00 00       	call   f0109bb5 <kheap_physical_address>
f010963f:	83 c4 10             	add    $0x10,%esp
f0109642:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f0109645:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109648:	c1 e8 0c             	shr    $0xc,%eax
f010964b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010964e:	c1 e2 0c             	shl    $0xc,%edx
f0109651:	89 d1                	mov    %edx,%ecx
f0109653:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109656:	01 ca                	add    %ecx,%edx
f0109658:	89 14 85 40 f7 b1 f0 	mov    %edx,-0xf4e08c0(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f010965f:	ff 45 f4             	incl   -0xc(%ebp)
f0109662:	eb 14                	jmp    f0109678 <initialize_kheap_dynamic_allocator+0x108>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f0109664:	83 ec 04             	sub    $0x4,%esp
f0109667:	68 ed 60 12 f0       	push   $0xf01260ed
f010966c:	6a 33                	push   $0x33
f010966e:	68 dc 60 12 f0       	push   $0xf01260dc
f0109673:	e8 c1 6c ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0109678:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010967b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010967e:	0f 82 6a ff ff ff    	jb     f01095ee <initialize_kheap_dynamic_allocator+0x7e>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f0109684:	83 ec 08             	sub    $0x8,%esp
f0109687:	ff 75 0c             	pushl  0xc(%ebp)
f010968a:	ff 75 08             	pushl  0x8(%ebp)
f010968d:	e8 9f 74 01 00       	call   f0120b31 <initialize_dynamic_allocator>
f0109692:	83 c4 10             	add    $0x10,%esp

	return 0;
f0109695:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010969a:	c9                   	leave  
f010969b:	c3                   	ret    

f010969c <sbrk>:

void* sbrk(int numOfPages)
{
f010969c:	55                   	push   %ebp
f010969d:	89 e5                	mov    %esp,%ebp
f010969f:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f01096a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01096a6:	0f 8e d6 00 00 00    	jle    f0109782 <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f01096ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01096af:	c1 e0 0c             	shl    $0xc,%eax
f01096b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f01096b5:	a1 40 f8 f1 f0       	mov    0xf0f1f840,%eax
f01096ba:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f01096bd:	8b 15 40 f8 f1 f0    	mov    0xf0f1f840,%edx
f01096c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096c6:	01 c2                	add    %eax,%edx
f01096c8:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f01096cd:	39 c2                	cmp    %eax,%edx
f01096cf:	76 0a                	jbe    f01096db <sbrk+0x3f>
f01096d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01096d6:	e9 b9 00 00 00       	jmp    f0109794 <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f01096db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01096e2:	eb 7d                	jmp    f0109761 <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f01096e4:	83 ec 0c             	sub    $0xc,%esp
f01096e7:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01096ea:	50                   	push   %eax
f01096eb:	e8 ed ed ff ff       	call   f01084dd <allocate_frame>
f01096f0:	83 c4 10             	add    $0x10,%esp
f01096f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f01096f6:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f01096fa:	74 5e                	je     f010975a <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f01096fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01096ff:	c1 e0 0c             	shl    $0xc,%eax
f0109702:	89 c2                	mov    %eax,%edx
f0109704:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109707:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010970a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010970d:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0109712:	6a 02                	push   $0x2
f0109714:	51                   	push   %ecx
f0109715:	52                   	push   %edx
f0109716:	50                   	push   %eax
f0109717:	e8 8e f2 ff ff       	call   f01089aa <map_frame>
f010971c:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f010971f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109722:	c1 e0 0c             	shl    $0xc,%eax
f0109725:	89 c2                	mov    %eax,%edx
f0109727:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010972a:	01 d0                	add    %edx,%eax
f010972c:	83 ec 0c             	sub    $0xc,%esp
f010972f:	50                   	push   %eax
f0109730:	e8 80 04 00 00       	call   f0109bb5 <kheap_physical_address>
f0109735:	83 c4 10             	add    $0x10,%esp
f0109738:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f010973b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010973e:	c1 e8 0c             	shr    $0xc,%eax
f0109741:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109744:	c1 e2 0c             	shl    $0xc,%edx
f0109747:	89 d1                	mov    %edx,%ecx
f0109749:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010974c:	01 ca                	add    %ecx,%edx
f010974e:	89 14 85 40 f7 b1 f0 	mov    %edx,-0xf4e08c0(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109755:	ff 45 f4             	incl   -0xc(%ebp)
f0109758:	eb 07                	jmp    f0109761 <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f010975a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010975f:	eb 33                	jmp    f0109794 <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109761:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109764:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109767:	0f 8c 77 ff ff ff    	jl     f01096e4 <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f010976d:	8b 15 40 f8 f1 f0    	mov    0xf0f1f840,%edx
f0109773:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109776:	01 d0                	add    %edx,%eax
f0109778:	a3 40 f8 f1 f0       	mov    %eax,0xf0f1f840
		return (void *)prev_brk;
f010977d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109780:	eb 12                	jmp    f0109794 <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f0109782:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109786:	75 07                	jne    f010978f <sbrk+0xf3>
	{
		return (void *) brk;
f0109788:	a1 40 f8 f1 f0       	mov    0xf0f1f840,%eax
f010978d:	eb 05                	jmp    f0109794 <sbrk+0xf8>
	}

	return (void *)-1;
f010978f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0109794:	c9                   	leave  
f0109795:	c3                   	ret    

f0109796 <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f0109796:	55                   	push   %ebp
f0109797:	89 e5                	mov    %esp,%ebp
f0109799:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f010979c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f01097a3:	83 ec 04             	sub    $0x4,%esp
f01097a6:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01097a9:	50                   	push   %eax
f01097aa:	ff 75 0c             	pushl  0xc(%ebp)
f01097ad:	ff 75 08             	pushl  0x8(%ebp)
f01097b0:	e8 df f2 ff ff       	call   f0108a94 <get_frame_info>
f01097b5:	83 c4 10             	add    $0x10,%esp
f01097b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f01097bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01097bf:	75 07                	jne    f01097c8 <isPageAllocated+0x32>
f01097c1:	b8 00 00 00 00       	mov    $0x0,%eax
f01097c6:	eb 05                	jmp    f01097cd <isPageAllocated+0x37>
	return 1;
f01097c8:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01097cd:	c9                   	leave  
f01097ce:	c3                   	ret    

f01097cf <kmalloc>:




void *kmalloc(unsigned int size)
{
f01097cf:	55                   	push   %ebp
f01097d0:	89 e5                	mov    %esp,%ebp
f01097d2:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f01097d5:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01097dc:	8b 55 08             	mov    0x8(%ebp),%edx
f01097df:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01097e2:	01 d0                	add    %edx,%eax
f01097e4:	48                   	dec    %eax
f01097e5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01097e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01097eb:	ba 00 00 00 00       	mov    $0x0,%edx
f01097f0:	f7 75 d8             	divl   -0x28(%ebp)
f01097f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01097f6:	29 d0                	sub    %edx,%eax
f01097f8:	c1 e8 0c             	shr    $0xc,%eax
f01097fb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f01097fe:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0109805:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f010980a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010980d:	29 c2                	sub    %eax,%edx
f010980f:	89 d0                	mov    %edx,%eax
f0109811:	48                   	dec    %eax
f0109812:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0109815:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109818:	ba 00 00 00 00       	mov    $0x0,%edx
f010981d:	f7 75 cc             	divl   -0x34(%ebp)
f0109820:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109823:	29 d0                	sub    %edx,%eax
f0109825:	c1 e8 0c             	shr    $0xc,%eax
f0109828:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f010982b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&kheaplock);
f0109832:	83 ec 0c             	sub    $0xc,%esp
f0109835:	68 40 f7 f1 f0       	push   $0xf0f1f740
f010983a:	e8 75 67 00 00       	call   f010ffb4 <acquire_spinlock>
f010983f:	83 c4 10             	add    $0x10,%esp
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109842:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0109849:	77 42                	ja     f010988d <kmalloc+0xbe>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f010984b:	e8 ab fc ff ff       	call   f01094fb <isKHeapPlacementStrategyFIRSTFIT>
f0109850:	84 c0                	test   %al,%al
f0109852:	74 16                	je     f010986a <kmalloc+0x9b>
			ptr = alloc_block_FF(size);
f0109854:	83 ec 0c             	sub    $0xc,%esp
f0109857:	ff 75 08             	pushl  0x8(%ebp)
f010985a:	e8 ee 74 01 00       	call   f0120d4d <alloc_block_FF>
f010985f:	83 c4 10             	add    $0x10,%esp
f0109862:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109865:	e9 10 02 00 00       	jmp    f0109a7a <kmalloc+0x2ab>
		else if (isKHeapPlacementStrategyBESTFIT())
f010986a:	e8 a1 fc ff ff       	call   f0109510 <isKHeapPlacementStrategyBESTFIT>
f010986f:	84 c0                	test   %al,%al
f0109871:	0f 84 03 02 00 00    	je     f0109a7a <kmalloc+0x2ab>
			ptr = alloc_block_BF(size);
f0109877:	83 ec 0c             	sub    $0xc,%esp
f010987a:	ff 75 08             	pushl  0x8(%ebp)
f010987d:	e8 87 79 01 00       	call   f0121209 <alloc_block_BF>
f0109882:	83 c4 10             	add    $0x10,%esp
f0109885:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109888:	e9 ed 01 00 00       	jmp    f0109a7a <kmalloc+0x2ab>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f010988d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109890:	48                   	dec    %eax
f0109891:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109894:	0f 86 c9 01 00 00    	jbe    f0109a63 <kmalloc+0x294>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f010989a:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f010989f:	05 00 10 00 00       	add    $0x1000,%eax
f01098a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f01098a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f01098ae:	e9 96 00 00 00       	jmp    f0109949 <kmalloc+0x17a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f01098b3:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01098b8:	83 ec 08             	sub    $0x8,%esp
f01098bb:	ff 75 f0             	pushl  -0x10(%ebp)
f01098be:	50                   	push   %eax
f01098bf:	e8 d2 fe ff ff       	call   f0109796 <isPageAllocated>
f01098c4:	83 c4 10             	add    $0x10,%esp
f01098c7:	85 c0                	test   %eax,%eax
f01098c9:	75 71                	jne    f010993c <kmalloc+0x16d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f01098cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098ce:	05 00 10 00 00       	add    $0x1000,%eax
f01098d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f01098d6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f01098dd:	eb 4d                	jmp    f010992c <kmalloc+0x15d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) {release_spinlock(&kheaplock); return NULL;}
f01098df:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f01098e6:	76 1a                	jbe    f0109902 <kmalloc+0x133>
f01098e8:	83 ec 0c             	sub    $0xc,%esp
f01098eb:	68 40 f7 f1 f0       	push   $0xf0f1f740
f01098f0:	e8 46 67 00 00       	call   f011003b <release_spinlock>
f01098f5:	83 c4 10             	add    $0x10,%esp
f01098f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01098fd:	e9 8b 01 00 00       	jmp    f0109a8d <kmalloc+0x2be>
					if (isPageAllocated(ptr_page_directory, j))
f0109902:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0109907:	83 ec 08             	sub    $0x8,%esp
f010990a:	ff 75 e8             	pushl  -0x18(%ebp)
f010990d:	50                   	push   %eax
f010990e:	e8 83 fe ff ff       	call   f0109796 <isPageAllocated>
f0109913:	83 c4 10             	add    $0x10,%esp
f0109916:	85 c0                	test   %eax,%eax
f0109918:	74 08                	je     f0109922 <kmalloc+0x153>
					{

						i = j;
f010991a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010991d:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f0109920:	eb 1a                	jmp    f010993c <kmalloc+0x16d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f0109922:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f0109929:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f010992c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010992f:	48                   	dec    %eax
f0109930:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0109933:	77 aa                	ja     f01098df <kmalloc+0x110>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f0109935:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f010993c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109940:	75 16                	jne    f0109958 <kmalloc+0x189>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f0109942:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f0109949:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f0109950:	0f 86 5d ff ff ff    	jbe    f01098b3 <kmalloc+0xe4>
f0109956:	eb 01                	jmp    f0109959 <kmalloc+0x18a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f0109958:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) {release_spinlock(&kheaplock); return NULL;}
f0109959:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010995d:	75 1a                	jne    f0109979 <kmalloc+0x1aa>
f010995f:	83 ec 0c             	sub    $0xc,%esp
f0109962:	68 40 f7 f1 f0       	push   $0xf0f1f740
f0109967:	e8 cf 66 00 00       	call   f011003b <release_spinlock>
f010996c:	83 c4 10             	add    $0x10,%esp
f010996f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109974:	e9 14 01 00 00       	jmp    f0109a8d <kmalloc+0x2be>
		for (int k = 0; k < num_pages; k++)
f0109979:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109980:	eb 67                	jmp    f01099e9 <kmalloc+0x21a>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f0109982:	83 ec 0c             	sub    $0xc,%esp
f0109985:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0109988:	50                   	push   %eax
f0109989:	e8 4f eb ff ff       	call   f01084dd <allocate_frame>
f010998e:	83 c4 10             	add    $0x10,%esp
f0109991:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if (ret != E_NO_MEM)
f0109994:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f0109998:	74 28                	je     f01099c2 <kmalloc+0x1f3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE);
f010999a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010999d:	c1 e0 0c             	shl    $0xc,%eax
f01099a0:	89 c2                	mov    %eax,%edx
f01099a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099a5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01099a8:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01099ab:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01099b0:	6a 02                	push   $0x2
f01099b2:	51                   	push   %ecx
f01099b3:	52                   	push   %edx
f01099b4:	50                   	push   %eax
f01099b5:	e8 f0 ef ff ff       	call   f01089aa <map_frame>
f01099ba:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) {release_spinlock(&kheaplock); return NULL;}
		for (int k = 0; k < num_pages; k++)
f01099bd:	ff 45 e0             	incl   -0x20(%ebp)
f01099c0:	eb 27                	jmp    f01099e9 <kmalloc+0x21a>
				//cprintf("kmalloc Page Index1 : %d\n",isTableExist[PDX((uint32)((uint32)i + (k * PAGE_SIZE)))]);
				//cprintf("kmalloc Index1 : %d\n",PDX((uint32)((uint32)i + (k * PAGE_SIZE))));
			}
			else
			{
				release_spinlock(&kheaplock);
f01099c2:	83 ec 0c             	sub    $0xc,%esp
f01099c5:	68 40 f7 f1 f0       	push   $0xf0f1f740
f01099ca:	e8 6c 66 00 00       	call   f011003b <release_spinlock>
f01099cf:	83 c4 10             	add    $0x10,%esp
				panic("No Memory");
f01099d2:	83 ec 04             	sub    $0x4,%esp
f01099d5:	68 ed 60 12 f0       	push   $0xf01260ed
f01099da:	68 c1 00 00 00       	push   $0xc1
f01099df:	68 dc 60 12 f0       	push   $0xf01260dc
f01099e4:	e8 50 69 ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) {release_spinlock(&kheaplock); return NULL;}
		for (int k = 0; k < num_pages; k++)
f01099e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099ec:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01099ef:	72 91                	jb     f0109982 <kmalloc+0x1b3>
			{
				release_spinlock(&kheaplock);
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f01099f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099f4:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f01099f7:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f01099fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01099ff:	29 c2                	sub    %eax,%edx
f0109a01:	89 d0                	mov    %edx,%eax
f0109a03:	2d 00 10 00 00       	sub    $0x1000,%eax
f0109a08:	c1 e8 0c             	shr    $0xc,%eax
f0109a0b:	89 c2                	mov    %eax,%edx
f0109a0d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109a10:	89 04 95 20 f1 71 f0 	mov    %eax,-0xf8e0ee0(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f0109a17:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109a1e:	eb 39                	jmp    f0109a59 <kmalloc+0x28a>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f0109a20:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109a23:	c1 e0 0c             	shl    $0xc,%eax
f0109a26:	89 c2                	mov    %eax,%edx
f0109a28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109a2b:	01 d0                	add    %edx,%eax
f0109a2d:	83 ec 0c             	sub    $0xc,%esp
f0109a30:	50                   	push   %eax
f0109a31:	e8 7f 01 00 00       	call   f0109bb5 <kheap_physical_address>
f0109a36:	83 c4 10             	add    $0x10,%esp
f0109a39:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f0109a3c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0109a3f:	c1 e8 0c             	shr    $0xc,%eax
f0109a42:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109a45:	c1 e2 0c             	shl    $0xc,%edx
f0109a48:	89 d1                	mov    %edx,%ecx
f0109a4a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109a4d:	01 ca                	add    %ecx,%edx
f0109a4f:	89 14 85 40 f7 b1 f0 	mov    %edx,-0xf4e08c0(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f0109a56:	ff 45 dc             	incl   -0x24(%ebp)
f0109a59:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109a5c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109a5f:	72 bf                	jb     f0109a20 <kmalloc+0x251>
f0109a61:	eb 17                	jmp    f0109a7a <kmalloc+0x2ab>
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
		}
	}
	else
	{
		release_spinlock(&kheaplock);
f0109a63:	83 ec 0c             	sub    $0xc,%esp
f0109a66:	68 40 f7 f1 f0       	push   $0xf0f1f740
f0109a6b:	e8 cb 65 00 00       	call   f011003b <release_spinlock>
f0109a70:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0109a73:	b8 00 00 00 00       	mov    $0x0,%eax
f0109a78:	eb 13                	jmp    f0109a8d <kmalloc+0x2be>
	}
	release_spinlock(&kheaplock);
f0109a7a:	83 ec 0c             	sub    $0xc,%esp
f0109a7d:	68 40 f7 f1 f0       	push   $0xf0f1f740
f0109a82:	e8 b4 65 00 00       	call   f011003b <release_spinlock>
f0109a87:	83 c4 10             	add    $0x10,%esp
	return ptr;
f0109a8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109a8d:	c9                   	leave  
f0109a8e:	c3                   	ret    

f0109a8f <kfree>:

void kfree(void *va)
{
f0109a8f:	55                   	push   %ebp
f0109a90:	89 e5                	mov    %esp,%ebp
f0109a92:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
	acquire_spinlock(&kheaplock);
f0109a95:	83 ec 0c             	sub    $0xc,%esp
f0109a98:	68 40 f7 f1 f0       	push   $0xf0f1f740
f0109a9d:	e8 12 65 00 00       	call   f010ffb4 <acquire_spinlock>
f0109aa2:	83 c4 10             	add    $0x10,%esp
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109aa5:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109aaa:	05 00 10 00 00       	add    $0x1000,%eax
f0109aaf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f0109ab2:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ab5:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109aba:	39 c2                	cmp    %eax,%edx
f0109abc:	73 23                	jae    f0109ae1 <kfree+0x52>

        free_block(va);
f0109abe:	83 ec 0c             	sub    $0xc,%esp
f0109ac1:	ff 75 08             	pushl  0x8(%ebp)
f0109ac4:	e8 25 81 01 00       	call   f0121bee <free_block>
f0109ac9:	83 c4 10             	add    $0x10,%esp
        release_spinlock(&kheaplock);
f0109acc:	83 ec 0c             	sub    $0xc,%esp
f0109acf:	68 40 f7 f1 f0       	push   $0xf0f1f740
f0109ad4:	e8 62 65 00 00       	call   f011003b <release_spinlock>
f0109ad9:	83 c4 10             	add    $0x10,%esp
    else{
    	release_spinlock(&kheaplock);
        panic("kfree: The virtual Address is invalid");
    }

}
f0109adc:	e9 d2 00 00 00       	jmp    f0109bb3 <kfree+0x124>
    if((uint32)va < hard_limit){

        free_block(va);
        release_spinlock(&kheaplock);
    }
    else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ae4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0109ae7:	0f 82 9f 00 00 00    	jb     f0109b8c <kfree+0xfd>
f0109aed:	8b 45 08             	mov    0x8(%ebp),%eax
f0109af0:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109af5:	0f 87 91 00 00 00    	ja     f0109b8c <kfree+0xfd>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f0109afb:	8b 55 08             	mov    0x8(%ebp),%edx
f0109afe:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109b03:	29 c2                	sub    %eax,%edx
f0109b05:	89 d0                	mov    %edx,%eax
f0109b07:	2d 00 10 00 00       	sub    $0x1000,%eax
f0109b0c:	c1 e8 0c             	shr    $0xc,%eax
f0109b0f:	8b 04 85 20 f1 71 f0 	mov    -0xf8e0ee0(,%eax,4),%eax
f0109b16:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f0109b19:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109b20:	eb 4f                	jmp    f0109b71 <kfree+0xe2>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f0109b22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b25:	c1 e0 0c             	shl    $0xc,%eax
f0109b28:	89 c2                	mov    %eax,%edx
f0109b2a:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b2d:	01 d0                	add    %edx,%eax
f0109b2f:	83 ec 0c             	sub    $0xc,%esp
f0109b32:	50                   	push   %eax
f0109b33:	e8 7d 00 00 00       	call   f0109bb5 <kheap_physical_address>
f0109b38:	83 c4 10             	add    $0x10,%esp
f0109b3b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f0109b3e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109b41:	c1 e8 0c             	shr    $0xc,%eax
f0109b44:	c7 04 85 40 f7 b1 f0 	movl   $0x0,-0xf4e08c0(,%eax,4)
f0109b4b:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f0109b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b52:	c1 e0 0c             	shl    $0xc,%eax
f0109b55:	89 c2                	mov    %eax,%edx
f0109b57:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b5a:	01 c2                	add    %eax,%edx
f0109b5c:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0109b61:	83 ec 08             	sub    $0x8,%esp
f0109b64:	52                   	push   %edx
f0109b65:	50                   	push   %eax
f0109b66:	e8 9f ef ff ff       	call   f0108b0a <unmap_frame>
f0109b6b:	83 c4 10             	add    $0x10,%esp
        free_block(va);
        release_spinlock(&kheaplock);
    }
    else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f0109b6e:	ff 45 f4             	incl   -0xc(%ebp)
f0109b71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b74:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109b77:	72 a9                	jb     f0109b22 <kfree+0x93>
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
			//isTableExist[PDX((uint32)va + i*PAGE_SIZE)]--;
			//cprintf("kfree Page Index1 : %d\n",isTableExist[PDX((uint32)((uint32)va + (i * PAGE_SIZE)))]);
			//cprintf(" kfree Index1 : %d\n",PDX((uint32)((uint32)va + (i * PAGE_SIZE))));
		}
		release_spinlock(&kheaplock);
f0109b79:	83 ec 0c             	sub    $0xc,%esp
f0109b7c:	68 40 f7 f1 f0       	push   $0xf0f1f740
f0109b81:	e8 b5 64 00 00       	call   f011003b <release_spinlock>
f0109b86:	83 c4 10             	add    $0x10,%esp
    if((uint32)va < hard_limit){

        free_block(va);
        release_spinlock(&kheaplock);
    }
    else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109b89:	90                   	nop
    else{
    	release_spinlock(&kheaplock);
        panic("kfree: The virtual Address is invalid");
    }

}
f0109b8a:	eb 27                	jmp    f0109bb3 <kfree+0x124>
			//cprintf(" kfree Index1 : %d\n",PDX((uint32)((uint32)va + (i * PAGE_SIZE))));
		}
		release_spinlock(&kheaplock);
    }
    else{
    	release_spinlock(&kheaplock);
f0109b8c:	83 ec 0c             	sub    $0xc,%esp
f0109b8f:	68 40 f7 f1 f0       	push   $0xf0f1f740
f0109b94:	e8 a2 64 00 00       	call   f011003b <release_spinlock>
f0109b99:	83 c4 10             	add    $0x10,%esp
        panic("kfree: The virtual Address is invalid");
f0109b9c:	83 ec 04             	sub    $0x4,%esp
f0109b9f:	68 f8 60 12 f0       	push   $0xf01260f8
f0109ba4:	68 f3 00 00 00       	push   $0xf3
f0109ba9:	68 dc 60 12 f0       	push   $0xf01260dc
f0109bae:	e8 86 67 ff ff       	call   f0100339 <_panic>
    }

}
f0109bb3:	c9                   	leave  
f0109bb4:	c3                   	ret    

f0109bb5 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f0109bb5:	55                   	push   %ebp
f0109bb6:	89 e5                	mov    %esp,%ebp
f0109bb8:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f0109bbb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f0109bc2:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0109bc7:	83 ec 04             	sub    $0x4,%esp
f0109bca:	8d 55 e8             	lea    -0x18(%ebp),%edx
f0109bcd:	52                   	push   %edx
f0109bce:	ff 75 08             	pushl  0x8(%ebp)
f0109bd1:	50                   	push   %eax
f0109bd2:	e8 bd ee ff ff       	call   f0108a94 <get_frame_info>
f0109bd7:	83 c4 10             	add    $0x10,%esp
f0109bda:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f0109bdd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109be1:	75 07                	jne    f0109bea <kheap_physical_address+0x35>
		return 0;
f0109be3:	b8 00 00 00 00       	mov    $0x0,%eax
f0109be8:	eb 26                	jmp    f0109c10 <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f0109bea:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bed:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109bf2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f0109bf5:	83 ec 0c             	sub    $0xc,%esp
f0109bf8:	ff 75 f4             	pushl  -0xc(%ebp)
f0109bfb:	e8 5d f9 ff ff       	call   f010955d <to_physical_address>
f0109c00:	83 c4 10             	add    $0x10,%esp
f0109c03:	89 c2                	mov    %eax,%edx
f0109c05:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c08:	01 d0                	add    %edx,%eax
f0109c0a:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f0109c0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0109c10:	c9                   	leave  
f0109c11:	c3                   	ret    

f0109c12 <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0109c12:	55                   	push   %ebp
f0109c13:	89 e5                	mov    %esp,%ebp
f0109c15:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f0109c18:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c1b:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109c20:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f0109c23:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c26:	c1 e8 0c             	shr    $0xc,%eax
f0109c29:	8b 04 85 40 f7 b1 f0 	mov    -0xf4e08c0(,%eax,4),%eax
f0109c30:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f0109c33:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0109c37:	74 06                	je     f0109c3f <kheap_virtual_address+0x2d>
f0109c39:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0109c3c:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f0109c3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0109c42:	c9                   	leave  
f0109c43:	c3                   	ret    

f0109c44 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *va, uint32 new_size)
{
f0109c44:	55                   	push   %ebp
f0109c45:	89 e5                	mov    %esp,%ebp
f0109c47:	83 ec 58             	sub    $0x58,%esp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	//return NULL;
//	panic("krealloc() is not implemented yet...!!");
	void *ptr = NULL;
f0109c4a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if(va == NULL){
f0109c51:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109c55:	75 16                	jne    f0109c6d <krealloc+0x29>
		ptr = kmalloc(new_size);
f0109c57:	83 ec 0c             	sub    $0xc,%esp
f0109c5a:	ff 75 0c             	pushl  0xc(%ebp)
f0109c5d:	e8 6d fb ff ff       	call   f01097cf <kmalloc>
f0109c62:	83 c4 10             	add    $0x10,%esp
f0109c65:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109c68:	e9 37 03 00 00       	jmp    f0109fa4 <krealloc+0x360>
	} else if(new_size == 0){
f0109c6d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0109c71:	75 13                	jne    f0109c86 <krealloc+0x42>
		kfree(va);
f0109c73:	83 ec 0c             	sub    $0xc,%esp
f0109c76:	ff 75 08             	pushl  0x8(%ebp)
f0109c79:	e8 11 fe ff ff       	call   f0109a8f <kfree>
f0109c7e:	83 c4 10             	add    $0x10,%esp
f0109c81:	e9 1e 03 00 00       	jmp    f0109fa4 <krealloc+0x360>
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109c86:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109c8b:	05 00 10 00 00       	add    $0x1000,%eax
f0109c90:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)va < hard_limit){
f0109c93:	8b 55 08             	mov    0x8(%ebp),%edx
f0109c96:	a1 14 f6 b1 f0       	mov    0xf0b1f614,%eax
f0109c9b:	39 c2                	cmp    %eax,%edx
f0109c9d:	73 19                	jae    f0109cb8 <krealloc+0x74>
			ptr = realloc_block_FF(va, new_size);
f0109c9f:	83 ec 08             	sub    $0x8,%esp
f0109ca2:	ff 75 0c             	pushl  0xc(%ebp)
f0109ca5:	ff 75 08             	pushl  0x8(%ebp)
f0109ca8:	e8 41 80 01 00       	call   f0121cee <realloc_block_FF>
f0109cad:	83 c4 10             	add    $0x10,%esp
f0109cb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109cb3:	e9 ec 02 00 00       	jmp    f0109fa4 <krealloc+0x360>
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109cb8:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cbb:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0109cbe:	0f 82 c8 02 00 00    	jb     f0109f8c <krealloc+0x348>
f0109cc4:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cc7:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109ccc:	0f 87 ba 02 00 00    	ja     f0109f8c <krealloc+0x348>
			uint32 num_pages = ROUNDUP(new_size ,PAGE_SIZE) / PAGE_SIZE;
f0109cd2:	c7 45 d4 00 10 00 00 	movl   $0x1000,-0x2c(%ebp)
f0109cd9:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109cdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109cdf:	01 d0                	add    %edx,%eax
f0109ce1:	48                   	dec    %eax
f0109ce2:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109ce5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109ce8:	ba 00 00 00 00       	mov    $0x0,%edx
f0109ced:	f7 75 d4             	divl   -0x2c(%ebp)
f0109cf0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109cf3:	29 d0                	sub    %edx,%eax
f0109cf5:	c1 e8 0c             	shr    $0xc,%eax
f0109cf8:	89 45 cc             	mov    %eax,-0x34(%ebp)
			uint32 num_old_pages = no_pages_alloc[(uint32)va / PAGE_SIZE];
f0109cfb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cfe:	c1 e8 0c             	shr    $0xc,%eax
f0109d01:	8b 04 85 20 f1 71 f0 	mov    -0xf8e0ee0(,%eax,4),%eax
f0109d08:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if(num_pages <= num_old_pages){
f0109d0b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109d0e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0109d11:	0f 87 ee 00 00 00    	ja     f0109e05 <krealloc+0x1c1>
				if (new_size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109d17:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
f0109d1e:	77 63                	ja     f0109d83 <krealloc+0x13f>
				{
					if (isKHeapPlacementStrategyFIRSTFIT())
f0109d20:	e8 d6 f7 ff ff       	call   f01094fb <isKHeapPlacementStrategyFIRSTFIT>
f0109d25:	84 c0                	test   %al,%al
f0109d27:	74 13                	je     f0109d3c <krealloc+0xf8>
						ptr = alloc_block_FF(new_size);
f0109d29:	83 ec 0c             	sub    $0xc,%esp
f0109d2c:	ff 75 0c             	pushl  0xc(%ebp)
f0109d2f:	e8 19 70 01 00       	call   f0120d4d <alloc_block_FF>
f0109d34:	83 c4 10             	add    $0x10,%esp
f0109d37:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109d3a:	eb 1a                	jmp    f0109d56 <krealloc+0x112>
					else if (isKHeapPlacementStrategyBESTFIT())
f0109d3c:	e8 cf f7 ff ff       	call   f0109510 <isKHeapPlacementStrategyBESTFIT>
f0109d41:	84 c0                	test   %al,%al
f0109d43:	74 11                	je     f0109d56 <krealloc+0x112>
						ptr = alloc_block_BF(new_size);
f0109d45:	83 ec 0c             	sub    $0xc,%esp
f0109d48:	ff 75 0c             	pushl  0xc(%ebp)
f0109d4b:	e8 b9 74 01 00       	call   f0121209 <alloc_block_BF>
f0109d50:	83 c4 10             	add    $0x10,%esp
f0109d53:	89 45 f4             	mov    %eax,-0xc(%ebp)
					if(ptr != NULL) memcpy(ptr, va, new_size);
f0109d56:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109d5a:	74 14                	je     f0109d70 <krealloc+0x12c>
f0109d5c:	83 ec 04             	sub    $0x4,%esp
f0109d5f:	ff 75 0c             	pushl  0xc(%ebp)
f0109d62:	ff 75 08             	pushl  0x8(%ebp)
f0109d65:	ff 75 f4             	pushl  -0xc(%ebp)
f0109d68:	e8 13 64 01 00       	call   f0120180 <memcpy>
f0109d6d:	83 c4 10             	add    $0x10,%esp
					kfree(va);
f0109d70:	83 ec 0c             	sub    $0xc,%esp
f0109d73:	ff 75 08             	pushl  0x8(%ebp)
f0109d76:	e8 14 fd ff ff       	call   f0109a8f <kfree>
f0109d7b:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109d7e:	e9 20 02 00 00       	jmp    f0109fa3 <krealloc+0x35f>
					else if (isKHeapPlacementStrategyBESTFIT())
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
f0109d83:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109d86:	c1 e0 0c             	shl    $0xc,%eax
f0109d89:	89 c2                	mov    %eax,%edx
f0109d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d8e:	01 d0                	add    %edx,%eax
f0109d90:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109d93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0109d9a:	eb 4f                	jmp    f0109deb <krealloc+0x1a7>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
f0109d9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d9f:	c1 e0 0c             	shl    $0xc,%eax
f0109da2:	89 c2                	mov    %eax,%edx
f0109da4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109da7:	01 d0                	add    %edx,%eax
f0109da9:	83 ec 0c             	sub    $0xc,%esp
f0109dac:	50                   	push   %eax
f0109dad:	e8 03 fe ff ff       	call   f0109bb5 <kheap_physical_address>
f0109db2:	83 c4 10             	add    $0x10,%esp
f0109db5:	89 45 c0             	mov    %eax,-0x40(%ebp)
						to_virtual[pa / PAGE_SIZE] = 0;
f0109db8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109dbb:	c1 e8 0c             	shr    $0xc,%eax
f0109dbe:	c7 04 85 40 f7 b1 f0 	movl   $0x0,-0xf4e08c0(,%eax,4)
f0109dc5:	00 00 00 00 
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
f0109dc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109dcc:	c1 e0 0c             	shl    $0xc,%eax
f0109dcf:	89 c2                	mov    %eax,%edx
f0109dd1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109dd4:	01 c2                	add    %eax,%edx
f0109dd6:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0109ddb:	83 ec 08             	sub    $0x8,%esp
f0109dde:	52                   	push   %edx
f0109ddf:	50                   	push   %eax
f0109de0:	e8 25 ed ff ff       	call   f0108b0a <unmap_frame>
f0109de5:	83 c4 10             	add    $0x10,%esp
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109de8:	ff 45 f0             	incl   -0x10(%ebp)
f0109deb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109dee:	2b 45 cc             	sub    -0x34(%ebp),%eax
f0109df1:	89 c2                	mov    %eax,%edx
f0109df3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109df6:	39 c2                	cmp    %eax,%edx
f0109df8:	77 a2                	ja     f0109d9c <krealloc+0x158>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
						to_virtual[pa / PAGE_SIZE] = 0;
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
f0109dfa:	8b 45 08             	mov    0x8(%ebp),%eax
f0109dfd:	89 45 f4             	mov    %eax,-0xc(%ebp)
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109e00:	e9 9e 01 00 00       	jmp    f0109fa3 <krealloc+0x35f>
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
f0109e05:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109e08:	c1 e0 0c             	shl    $0xc,%eax
f0109e0b:	89 c2                	mov    %eax,%edx
f0109e0d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e10:	01 d0                	add    %edx,%eax
f0109e12:	89 45 ec             	mov    %eax,-0x14(%ebp)
				uint32 cnt = 0;
f0109e15:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				bool found_free_pages = 0;
f0109e1c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < (num_pages - num_old_pages))
f0109e23:	eb 33                	jmp    f0109e58 <krealloc+0x214>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
f0109e25:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f0109e2c:	0f 87 19 01 00 00    	ja     f0109f4b <krealloc+0x307>
f0109e32:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0109e37:	83 ec 08             	sub    $0x8,%esp
f0109e3a:	ff 75 ec             	pushl  -0x14(%ebp)
f0109e3d:	50                   	push   %eax
f0109e3e:	e8 53 f9 ff ff       	call   f0109796 <isPageAllocated>
f0109e43:	83 c4 10             	add    $0x10,%esp
f0109e46:	85 c0                	test   %eax,%eax
f0109e48:	0f 85 fd 00 00 00    	jne    f0109f4b <krealloc+0x307>
					j += (uint32)PAGE_SIZE;
f0109e4e:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
					cnt++;
f0109e55:	ff 45 e8             	incl   -0x18(%ebp)
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
				uint32 cnt = 0;
				bool found_free_pages = 0;
				while(cnt < (num_pages - num_old_pages))
f0109e58:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109e5b:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109e5e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109e61:	77 c2                	ja     f0109e25 <krealloc+0x1e1>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
f0109e63:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109e6a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109e71:	eb 5c                	jmp    f0109ecf <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
f0109e73:	83 ec 0c             	sub    $0xc,%esp
f0109e76:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0109e79:	50                   	push   %eax
f0109e7a:	e8 5e e6 ff ff       	call   f01084dd <allocate_frame>
f0109e7f:	83 c4 10             	add    $0x10,%esp
f0109e82:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
f0109e85:	83 7d bc fc          	cmpl   $0xfffffffc,-0x44(%ebp)
f0109e89:	74 2d                	je     f0109eb8 <krealloc+0x274>
f0109e8b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109e8e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109e91:	01 d0                	add    %edx,%eax
f0109e93:	c1 e0 0c             	shl    $0xc,%eax
f0109e96:	89 c2                	mov    %eax,%edx
f0109e98:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e9b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109e9e:	8b 55 b4             	mov    -0x4c(%ebp),%edx
f0109ea1:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0109ea6:	6a 02                	push   $0x2
f0109ea8:	51                   	push   %ecx
f0109ea9:	52                   	push   %edx
f0109eaa:	50                   	push   %eax
f0109eab:	e8 fa ea ff ff       	call   f01089aa <map_frame>
f0109eb0:	83 c4 10             	add    $0x10,%esp
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109eb3:	ff 45 e0             	incl   -0x20(%ebp)
f0109eb6:	eb 17                	jmp    f0109ecf <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
f0109eb8:	83 ec 04             	sub    $0x4,%esp
f0109ebb:	68 ed 60 12 f0       	push   $0xf01260ed
f0109ec0:	68 61 01 00 00       	push   $0x161
f0109ec5:	68 dc 60 12 f0       	push   $0xf01260dc
f0109eca:	e8 6a 64 ff ff       	call   f0100339 <_panic>
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109ecf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109ed2:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109ed5:	89 c2                	mov    %eax,%edx
f0109ed7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109eda:	39 c2                	cmp    %eax,%edx
f0109edc:	77 95                	ja     f0109e73 <krealloc+0x22f>
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
f0109ede:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ee1:	c1 e8 0c             	shr    $0xc,%eax
f0109ee4:	89 c2                	mov    %eax,%edx
f0109ee6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109ee9:	89 04 95 20 f1 71 f0 	mov    %eax,-0xf8e0ee0(,%edx,4)
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109ef0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109ef7:	eb 43                	jmp    f0109f3c <krealloc+0x2f8>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
f0109ef9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109efc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109eff:	01 d0                	add    %edx,%eax
f0109f01:	c1 e0 0c             	shl    $0xc,%eax
f0109f04:	89 c2                	mov    %eax,%edx
f0109f06:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f09:	01 d0                	add    %edx,%eax
f0109f0b:	83 ec 0c             	sub    $0xc,%esp
f0109f0e:	50                   	push   %eax
f0109f0f:	e8 a1 fc ff ff       	call   f0109bb5 <kheap_physical_address>
f0109f14:	83 c4 10             	add    $0x10,%esp
f0109f17:	89 45 b8             	mov    %eax,-0x48(%ebp)
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
f0109f1a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0109f1d:	c1 e8 0c             	shr    $0xc,%eax
f0109f20:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0109f23:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0109f26:	01 ca                	add    %ecx,%edx
f0109f28:	89 d1                	mov    %edx,%ecx
f0109f2a:	c1 e1 0c             	shl    $0xc,%ecx
f0109f2d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109f30:	01 ca                	add    %ecx,%edx
f0109f32:	89 14 85 40 f7 b1 f0 	mov    %edx,-0xf4e08c0(,%eax,4)
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109f39:	ff 45 dc             	incl   -0x24(%ebp)
f0109f3c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109f3f:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109f42:	89 c2                	mov    %eax,%edx
f0109f44:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109f47:	39 c2                	cmp    %eax,%edx
f0109f49:	77 ae                	ja     f0109ef9 <krealloc+0x2b5>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
				}
				sayed:
					if(!found_free_pages){
f0109f4b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109f4f:	75 52                	jne    f0109fa3 <krealloc+0x35f>
						ptr = kmalloc(new_size);
f0109f51:	83 ec 0c             	sub    $0xc,%esp
f0109f54:	ff 75 0c             	pushl  0xc(%ebp)
f0109f57:	e8 73 f8 ff ff       	call   f01097cf <kmalloc>
f0109f5c:	83 c4 10             	add    $0x10,%esp
f0109f5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
						if(ptr != NULL) memcpy(ptr, va, new_size);
f0109f62:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109f66:	74 14                	je     f0109f7c <krealloc+0x338>
f0109f68:	83 ec 04             	sub    $0x4,%esp
f0109f6b:	ff 75 0c             	pushl  0xc(%ebp)
f0109f6e:	ff 75 08             	pushl  0x8(%ebp)
f0109f71:	ff 75 f4             	pushl  -0xc(%ebp)
f0109f74:	e8 07 62 01 00       	call   f0120180 <memcpy>
f0109f79:	83 c4 10             	add    $0x10,%esp
						kfree(va);
f0109f7c:	83 ec 0c             	sub    $0xc,%esp
f0109f7f:	ff 75 08             	pushl  0x8(%ebp)
f0109f82:	e8 08 fb ff ff       	call   f0109a8f <kfree>
f0109f87:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109f8a:	eb 17                	jmp    f0109fa3 <krealloc+0x35f>
						if(ptr != NULL) memcpy(ptr, va, new_size);
						kfree(va);
					}
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
f0109f8c:	83 ec 04             	sub    $0x4,%esp
f0109f8f:	68 20 61 12 f0       	push   $0xf0126120
f0109f94:	68 70 01 00 00       	push   $0x170
f0109f99:	68 dc 60 12 f0       	push   $0xf01260dc
f0109f9e:	e8 96 63 ff ff       	call   f0100339 <_panic>
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109fa3:	90                   	nop
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
		}
	}
	return ptr;
f0109fa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109fa7:	c9                   	leave  
f0109fa8:	c3                   	ret    

f0109fa9 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109fa9:	55                   	push   %ebp
f0109faa:	89 e5                	mov    %esp,%ebp
f0109fac:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109faf:	83 ec 04             	sub    $0x4,%esp
f0109fb2:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109fb5:	50                   	push   %eax
f0109fb6:	ff 75 0c             	pushl  0xc(%ebp)
f0109fb9:	ff 75 08             	pushl  0x8(%ebp)
f0109fbc:	e8 59 e7 ff ff       	call   f010871a <get_page_table>
f0109fc1:	83 c4 10             	add    $0x10,%esp
f0109fc4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109fc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fca:	85 c0                	test   %eax,%eax
f0109fcc:	74 64                	je     f010a032 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109fce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fd1:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109fd4:	c1 ea 0c             	shr    $0xc,%edx
f0109fd7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109fdd:	c1 e2 02             	shl    $0x2,%edx
f0109fe0:	01 c2                	add    %eax,%edx
f0109fe2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fe5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109fe8:	c1 e9 0c             	shr    $0xc,%ecx
f0109feb:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109ff1:	c1 e1 02             	shl    $0x2,%ecx
f0109ff4:	01 c8                	add    %ecx,%eax
f0109ff6:	8b 00                	mov    (%eax),%eax
f0109ff8:	0b 45 10             	or     0x10(%ebp),%eax
f0109ffb:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109ffd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a000:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a003:	c1 ea 0c             	shr    $0xc,%edx
f010a006:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a00c:	c1 e2 02             	shl    $0x2,%edx
f010a00f:	01 d0                	add    %edx,%eax
f010a011:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a014:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010a017:	c1 e9 0c             	shr    $0xc,%ecx
f010a01a:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010a020:	c1 e1 02             	shl    $0x2,%ecx
f010a023:	01 ca                	add    %ecx,%edx
f010a025:	8b 12                	mov    (%edx),%edx
f010a027:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010a02a:	f7 d1                	not    %ecx
f010a02c:	21 ca                	and    %ecx,%edx
f010a02e:	89 10                	mov    %edx,(%eax)
f010a030:	eb 27                	jmp    f010a059 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f010a032:	83 ec 08             	sub    $0x8,%esp
f010a035:	ff 75 0c             	pushl  0xc(%ebp)
f010a038:	68 4c 61 12 f0       	push   $0xf012614c
f010a03d:	e8 49 6f ff ff       	call   f0100f8b <cprintf>
f010a042:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010a045:	83 ec 04             	sub    $0x4,%esp
f010a048:	68 74 61 12 f0       	push   $0xf0126174
f010a04d:	6a 1c                	push   $0x1c
f010a04f:	68 e8 61 12 f0       	push   $0xf01261e8
f010a054:	e8 e0 62 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a059:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a05c:	83 ec 08             	sub    $0x8,%esp
f010a05f:	50                   	push   %eax
f010a060:	6a 00                	push   $0x0
f010a062:	e8 7d e0 ff ff       	call   f01080e4 <tlb_invalidate>
f010a067:	83 c4 10             	add    $0x10,%esp
}
f010a06a:	90                   	nop
f010a06b:	c9                   	leave  
f010a06c:	c3                   	ret    

f010a06d <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f010a06d:	55                   	push   %ebp
f010a06e:	89 e5                	mov    %esp,%ebp
f010a070:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010a073:	83 ec 04             	sub    $0x4,%esp
f010a076:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a079:	50                   	push   %eax
f010a07a:	ff 75 0c             	pushl  0xc(%ebp)
f010a07d:	ff 75 08             	pushl  0x8(%ebp)
f010a080:	e8 95 e6 ff ff       	call   f010871a <get_page_table>
f010a085:	83 c4 10             	add    $0x10,%esp
f010a088:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f010a08b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a08e:	85 c0                	test   %eax,%eax
f010a090:	74 1d                	je     f010a0af <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f010a092:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a095:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a098:	c1 ea 0c             	shr    $0xc,%edx
f010a09b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a0a1:	c1 e2 02             	shl    $0x2,%edx
f010a0a4:	01 d0                	add    %edx,%eax
f010a0a6:	8b 00                	mov    (%eax),%eax
f010a0a8:	25 ff 0f 00 00       	and    $0xfff,%eax
f010a0ad:	eb 05                	jmp    f010a0b4 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f010a0af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f010a0b4:	c9                   	leave  
f010a0b5:	c3                   	ret    

f010a0b6 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f010a0b6:	55                   	push   %ebp
f010a0b7:	89 e5                	mov    %esp,%ebp
f010a0b9:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010a0bc:	83 ec 04             	sub    $0x4,%esp
f010a0bf:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a0c2:	50                   	push   %eax
f010a0c3:	ff 75 0c             	pushl  0xc(%ebp)
f010a0c6:	ff 75 08             	pushl  0x8(%ebp)
f010a0c9:	e8 4c e6 ff ff       	call   f010871a <get_page_table>
f010a0ce:	83 c4 10             	add    $0x10,%esp
f010a0d1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f010a0d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0d7:	85 c0                	test   %eax,%eax
f010a0d9:	74 46                	je     f010a121 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f010a0db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0de:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a0e1:	c1 ea 0c             	shr    $0xc,%edx
f010a0e4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a0ea:	c1 e2 02             	shl    $0x2,%edx
f010a0ed:	01 d0                	add    %edx,%eax
f010a0ef:	8b 00                	mov    (%eax),%eax
f010a0f1:	83 ec 04             	sub    $0x4,%esp
f010a0f4:	50                   	push   %eax
f010a0f5:	ff 75 0c             	pushl  0xc(%ebp)
f010a0f8:	68 04 62 12 f0       	push   $0xf0126204
f010a0fd:	e8 89 6e ff ff       	call   f0100f8b <cprintf>
f010a102:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f010a105:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a108:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a10b:	c1 ea 0c             	shr    $0xc,%edx
f010a10e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a114:	c1 e2 02             	shl    $0x2,%edx
f010a117:	01 d0                	add    %edx,%eax
f010a119:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a11f:	eb 14                	jmp    f010a135 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010a121:	83 ec 04             	sub    $0x4,%esp
f010a124:	68 2c 62 12 f0       	push   $0xf012622c
f010a129:	6a 47                	push   $0x47
f010a12b:	68 e8 61 12 f0       	push   $0xf01261e8
f010a130:	e8 04 62 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a135:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a138:	83 ec 08             	sub    $0x8,%esp
f010a13b:	50                   	push   %eax
f010a13c:	6a 00                	push   $0x0
f010a13e:	e8 a1 df ff ff       	call   f01080e4 <tlb_invalidate>
f010a143:	83 c4 10             	add    $0x10,%esp
}
f010a146:	90                   	nop
f010a147:	c9                   	leave  
f010a148:	c3                   	ret    

f010a149 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f010a149:	55                   	push   %ebp
f010a14a:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f010a14c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a14f:	c1 e8 16             	shr    $0x16,%eax
f010a152:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a159:	8b 45 08             	mov    0x8(%ebp),%eax
f010a15c:	01 d0                	add    %edx,%eax
f010a15e:	8b 00                	mov    (%eax),%eax
f010a160:	83 e0 20             	and    $0x20,%eax
f010a163:	85 c0                	test   %eax,%eax
f010a165:	0f 95 c0             	setne  %al
f010a168:	0f b6 c0             	movzbl %al,%eax
}
f010a16b:	5d                   	pop    %ebp
f010a16c:	c3                   	ret    

f010a16d <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f010a16d:	55                   	push   %ebp
f010a16e:	89 e5                	mov    %esp,%ebp
f010a170:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f010a173:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a176:	c1 e8 16             	shr    $0x16,%eax
f010a179:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a180:	8b 45 08             	mov    0x8(%ebp),%eax
f010a183:	01 d0                	add    %edx,%eax
f010a185:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a188:	c1 ea 16             	shr    $0x16,%edx
f010a18b:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f010a192:	8b 55 08             	mov    0x8(%ebp),%edx
f010a195:	01 ca                	add    %ecx,%edx
f010a197:	8b 12                	mov    (%edx),%edx
f010a199:	83 e2 df             	and    $0xffffffdf,%edx
f010a19c:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a19e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a1a1:	83 ec 08             	sub    $0x8,%esp
f010a1a4:	50                   	push   %eax
f010a1a5:	6a 00                	push   $0x0
f010a1a7:	e8 38 df ff ff       	call   f01080e4 <tlb_invalidate>
f010a1ac:	83 c4 10             	add    $0x10,%esp
}
f010a1af:	90                   	nop
f010a1b0:	c9                   	leave  
f010a1b1:	c3                   	ret    

f010a1b2 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f010a1b2:	55                   	push   %ebp
f010a1b3:	89 e5                	mov    %esp,%ebp
f010a1b5:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f010a1b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a1bb:	c1 e8 16             	shr    $0x16,%eax
f010a1be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a1c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1c8:	01 d0                	add    %edx,%eax
f010a1ca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010a1d0:	0f 20 d8             	mov    %cr3,%eax
f010a1d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010a1d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010a1d9:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010a1dc:	90                   	nop
f010a1dd:	c9                   	leave  
f010a1de:	c3                   	ret    

f010a1df <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f010a1df:	55                   	push   %ebp
f010a1e0:	89 e5                	mov    %esp,%ebp
f010a1e2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f010a1e5:	83 ec 0c             	sub    $0xc,%esp
f010a1e8:	6a 18                	push   $0x18
f010a1ea:	e8 e0 f5 ff ff       	call   f01097cf <kmalloc>
f010a1ef:	83 c4 10             	add    $0x10,%esp
f010a1f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f010a1f5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a1f9:	75 14                	jne    f010a20f <env_page_ws_list_create_element+0x30>
f010a1fb:	83 ec 04             	sub    $0x4,%esp
f010a1fe:	68 a4 62 12 f0       	push   $0xf01262a4
f010a203:	6a 19                	push   $0x19
f010a205:	68 d4 62 12 f0       	push   $0xf01262d4
f010a20a:	e8 2a 61 ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f010a20f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a212:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f010a215:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a218:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a21b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a21e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a223:	89 c2                	mov    %eax,%edx
f010a225:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a228:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f010a22a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a22d:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f010a231:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a234:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f010a23b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a23e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f010a245:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f010a248:	c9                   	leave  
f010a249:	c3                   	ret    

f010a24a <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a24a:	55                   	push   %ebp
f010a24b:	89 e5                	mov    %esp,%ebp
f010a24d:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a250:	83 ec 0c             	sub    $0xc,%esp
f010a253:	6a 02                	push   $0x2
f010a255:	e8 07 57 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010a25a:	83 c4 10             	add    $0x10,%esp
f010a25d:	85 c0                	test   %eax,%eax
f010a25f:	0f 84 e5 03 00 00    	je     f010a64a <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f010a265:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f010a26c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a273:	8b 45 08             	mov    0x8(%ebp),%eax
f010a276:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a27c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a27f:	e9 3b 02 00 00       	jmp    f010a4bf <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a284:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a287:	8b 00                	mov    (%eax),%eax
f010a289:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a28c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a28f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a294:	89 c2                	mov    %eax,%edx
f010a296:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a299:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010a29c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a29f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a2a4:	39 c2                	cmp    %eax,%edx
f010a2a6:	0f 85 07 02 00 00    	jne    f010a4b3 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f010a2ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2af:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a2b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a2b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2bb:	8b 10                	mov    (%eax),%edx
f010a2bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2c0:	8b 40 64             	mov    0x64(%eax),%eax
f010a2c3:	83 ec 08             	sub    $0x8,%esp
f010a2c6:	52                   	push   %edx
f010a2c7:	50                   	push   %eax
f010a2c8:	e8 3d e8 ff ff       	call   f0108b0a <unmap_frame>
f010a2cd:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010a2d0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a2d4:	75 14                	jne    f010a2ea <env_page_ws_invalidate+0xa0>
f010a2d6:	83 ec 04             	sub    $0x4,%esp
f010a2d9:	68 f3 62 12 f0       	push   $0xf01262f3
f010a2de:	6a 2f                	push   $0x2f
f010a2e0:	68 d4 62 12 f0       	push   $0xf01262d4
f010a2e5:	e8 4f 60 ff ff       	call   f0100339 <_panic>
f010a2ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2ed:	8b 40 10             	mov    0x10(%eax),%eax
f010a2f0:	85 c0                	test   %eax,%eax
f010a2f2:	74 11                	je     f010a305 <env_page_ws_invalidate+0xbb>
f010a2f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2f7:	8b 40 10             	mov    0x10(%eax),%eax
f010a2fa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a2fd:	8b 52 14             	mov    0x14(%edx),%edx
f010a300:	89 50 14             	mov    %edx,0x14(%eax)
f010a303:	eb 0f                	jmp    f010a314 <env_page_ws_invalidate+0xca>
f010a305:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a308:	8b 50 14             	mov    0x14(%eax),%edx
f010a30b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a30e:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a314:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a317:	8b 40 14             	mov    0x14(%eax),%eax
f010a31a:	85 c0                	test   %eax,%eax
f010a31c:	74 11                	je     f010a32f <env_page_ws_invalidate+0xe5>
f010a31e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a321:	8b 40 14             	mov    0x14(%eax),%eax
f010a324:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a327:	8b 52 10             	mov    0x10(%edx),%edx
f010a32a:	89 50 10             	mov    %edx,0x10(%eax)
f010a32d:	eb 0f                	jmp    f010a33e <env_page_ws_invalidate+0xf4>
f010a32f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a332:	8b 50 10             	mov    0x10(%eax),%edx
f010a335:	8b 45 08             	mov    0x8(%ebp),%eax
f010a338:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a33e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a341:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a348:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a34b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a352:	8b 45 08             	mov    0x8(%ebp),%eax
f010a355:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a35b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a35e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a361:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a367:	83 ec 0c             	sub    $0xc,%esp
f010a36a:	ff 75 f0             	pushl  -0x10(%ebp)
f010a36d:	e8 1d f7 ff ff       	call   f0109a8f <kfree>
f010a372:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a375:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a379:	0f 84 2b 01 00 00    	je     f010a4aa <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a37f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a383:	75 14                	jne    f010a399 <env_page_ws_invalidate+0x14f>
f010a385:	83 ec 04             	sub    $0x4,%esp
f010a388:	68 f3 62 12 f0       	push   $0xf01262f3
f010a38d:	6a 35                	push   $0x35
f010a38f:	68 d4 62 12 f0       	push   $0xf01262d4
f010a394:	e8 a0 5f ff ff       	call   f0100339 <_panic>
f010a399:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a39c:	8b 40 10             	mov    0x10(%eax),%eax
f010a39f:	85 c0                	test   %eax,%eax
f010a3a1:	74 11                	je     f010a3b4 <env_page_ws_invalidate+0x16a>
f010a3a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3a6:	8b 40 10             	mov    0x10(%eax),%eax
f010a3a9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a3ac:	8b 52 14             	mov    0x14(%edx),%edx
f010a3af:	89 50 14             	mov    %edx,0x14(%eax)
f010a3b2:	eb 0f                	jmp    f010a3c3 <env_page_ws_invalidate+0x179>
f010a3b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3b7:	8b 50 14             	mov    0x14(%eax),%edx
f010a3ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3bd:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a3c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3c6:	8b 40 14             	mov    0x14(%eax),%eax
f010a3c9:	85 c0                	test   %eax,%eax
f010a3cb:	74 11                	je     f010a3de <env_page_ws_invalidate+0x194>
f010a3cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3d0:	8b 40 14             	mov    0x14(%eax),%eax
f010a3d3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a3d6:	8b 52 10             	mov    0x10(%edx),%edx
f010a3d9:	89 50 10             	mov    %edx,0x10(%eax)
f010a3dc:	eb 0f                	jmp    f010a3ed <env_page_ws_invalidate+0x1a3>
f010a3de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3e1:	8b 50 10             	mov    0x10(%eax),%edx
f010a3e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3e7:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a3ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3f0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a3f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3fa:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a401:	8b 45 08             	mov    0x8(%ebp),%eax
f010a404:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a40a:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a40d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a410:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a416:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a41a:	75 14                	jne    f010a430 <env_page_ws_invalidate+0x1e6>
f010a41c:	83 ec 04             	sub    $0x4,%esp
f010a41f:	68 14 63 12 f0       	push   $0xf0126314
f010a424:	6a 36                	push   $0x36
f010a426:	68 d4 62 12 f0       	push   $0xf01262d4
f010a42b:	e8 09 5f ff ff       	call   f0100339 <_panic>
f010a430:	8b 45 08             	mov    0x8(%ebp),%eax
f010a433:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010a439:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a43c:	89 50 14             	mov    %edx,0x14(%eax)
f010a43f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a442:	8b 40 14             	mov    0x14(%eax),%eax
f010a445:	85 c0                	test   %eax,%eax
f010a447:	74 11                	je     f010a45a <env_page_ws_invalidate+0x210>
f010a449:	8b 45 08             	mov    0x8(%ebp),%eax
f010a44c:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a452:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a455:	89 50 10             	mov    %edx,0x10(%eax)
f010a458:	eb 0c                	jmp    f010a466 <env_page_ws_invalidate+0x21c>
f010a45a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a45d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a460:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a466:	8b 45 08             	mov    0x8(%ebp),%eax
f010a469:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a46c:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a472:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a475:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a47c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a47f:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a485:	8d 50 01             	lea    0x1(%eax),%edx
f010a488:	8b 45 08             	mov    0x8(%ebp),%eax
f010a48b:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a491:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a494:	8b 10                	mov    (%eax),%edx
f010a496:	8b 45 08             	mov    0x8(%ebp),%eax
f010a499:	8b 40 64             	mov    0x64(%eax),%eax
f010a49c:	6a 00                	push   $0x0
f010a49e:	6a 01                	push   $0x1
f010a4a0:	52                   	push   %edx
f010a4a1:	50                   	push   %eax
f010a4a2:	e8 02 fb ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010a4a7:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a4aa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a4b1:	eb 43                	jmp    f010a4f6 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a4b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4b6:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a4bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a4bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4c3:	74 08                	je     f010a4cd <env_page_ws_invalidate+0x283>
f010a4c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4c8:	8b 40 10             	mov    0x10(%eax),%eax
f010a4cb:	eb 05                	jmp    f010a4d2 <env_page_ws_invalidate+0x288>
f010a4cd:	b8 00 00 00 00       	mov    $0x0,%eax
f010a4d2:	8b 55 08             	mov    0x8(%ebp),%edx
f010a4d5:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a4db:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4de:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a4e4:	85 c0                	test   %eax,%eax
f010a4e6:	0f 85 98 fd ff ff    	jne    f010a284 <env_page_ws_invalidate+0x3a>
f010a4ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4f0:	0f 85 8e fd ff ff    	jne    f010a284 <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a4f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a4fa:	0f 85 a4 02 00 00    	jne    f010a7a4 <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a500:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a507:	8b 45 08             	mov    0x8(%ebp),%eax
f010a50a:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a510:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a513:	e9 f6 00 00 00       	jmp    f010a60e <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a518:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a51b:	8b 00                	mov    (%eax),%eax
f010a51d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a520:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a523:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a528:	89 c2                	mov    %eax,%edx
f010a52a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a52d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a530:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a533:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a538:	39 c2                	cmp    %eax,%edx
f010a53a:	0f 85 c2 00 00 00    	jne    f010a602 <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a540:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a543:	8b 10                	mov    (%eax),%edx
f010a545:	8b 45 08             	mov    0x8(%ebp),%eax
f010a548:	8b 40 64             	mov    0x64(%eax),%eax
f010a54b:	83 ec 08             	sub    $0x8,%esp
f010a54e:	52                   	push   %edx
f010a54f:	50                   	push   %eax
f010a550:	e8 b5 e5 ff ff       	call   f0108b0a <unmap_frame>
f010a555:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a558:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a55c:	75 14                	jne    f010a572 <env_page_ws_invalidate+0x328>
f010a55e:	83 ec 04             	sub    $0x4,%esp
f010a561:	68 f3 62 12 f0       	push   $0xf01262f3
f010a566:	6a 46                	push   $0x46
f010a568:	68 d4 62 12 f0       	push   $0xf01262d4
f010a56d:	e8 c7 5d ff ff       	call   f0100339 <_panic>
f010a572:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a575:	8b 40 10             	mov    0x10(%eax),%eax
f010a578:	85 c0                	test   %eax,%eax
f010a57a:	74 11                	je     f010a58d <env_page_ws_invalidate+0x343>
f010a57c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a57f:	8b 40 10             	mov    0x10(%eax),%eax
f010a582:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a585:	8b 52 14             	mov    0x14(%edx),%edx
f010a588:	89 50 14             	mov    %edx,0x14(%eax)
f010a58b:	eb 0f                	jmp    f010a59c <env_page_ws_invalidate+0x352>
f010a58d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a590:	8b 50 14             	mov    0x14(%eax),%edx
f010a593:	8b 45 08             	mov    0x8(%ebp),%eax
f010a596:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a59c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a59f:	8b 40 14             	mov    0x14(%eax),%eax
f010a5a2:	85 c0                	test   %eax,%eax
f010a5a4:	74 11                	je     f010a5b7 <env_page_ws_invalidate+0x36d>
f010a5a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5a9:	8b 40 14             	mov    0x14(%eax),%eax
f010a5ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a5af:	8b 52 10             	mov    0x10(%edx),%edx
f010a5b2:	89 50 10             	mov    %edx,0x10(%eax)
f010a5b5:	eb 0f                	jmp    f010a5c6 <env_page_ws_invalidate+0x37c>
f010a5b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5ba:	8b 50 10             	mov    0x10(%eax),%edx
f010a5bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5c0:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a5c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5c9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a5d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5d3:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a5da:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5dd:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a5e3:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a5e6:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5e9:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f010a5ef:	83 ec 0c             	sub    $0xc,%esp
f010a5f2:	ff 75 f0             	pushl  -0x10(%ebp)
f010a5f5:	e8 95 f4 ff ff       	call   f0109a8f <kfree>
f010a5fa:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a5fd:	e9 a2 01 00 00       	jmp    f010a7a4 <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a602:	8b 45 08             	mov    0x8(%ebp),%eax
f010a605:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a60b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a60e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a612:	74 08                	je     f010a61c <env_page_ws_invalidate+0x3d2>
f010a614:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a617:	8b 40 10             	mov    0x10(%eax),%eax
f010a61a:	eb 05                	jmp    f010a621 <env_page_ws_invalidate+0x3d7>
f010a61c:	b8 00 00 00 00       	mov    $0x0,%eax
f010a621:	8b 55 08             	mov    0x8(%ebp),%edx
f010a624:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a62a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a62d:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a633:	85 c0                	test   %eax,%eax
f010a635:	0f 85 dd fe ff ff    	jne    f010a518 <env_page_ws_invalidate+0x2ce>
f010a63b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a63f:	0f 85 d3 fe ff ff    	jne    f010a518 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a645:	e9 5a 01 00 00       	jmp    f010a7a4 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a64a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a64d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a653:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a656:	e9 10 01 00 00       	jmp    f010a76b <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a65b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a65e:	8b 00                	mov    (%eax),%eax
f010a660:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a663:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a666:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a66b:	89 c2                	mov    %eax,%edx
f010a66d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a670:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a673:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a676:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a67b:	39 c2                	cmp    %eax,%edx
f010a67d:	0f 85 dc 00 00 00    	jne    f010a75f <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a683:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a686:	8b 10                	mov    (%eax),%edx
f010a688:	8b 45 08             	mov    0x8(%ebp),%eax
f010a68b:	8b 40 64             	mov    0x64(%eax),%eax
f010a68e:	83 ec 08             	sub    $0x8,%esp
f010a691:	52                   	push   %edx
f010a692:	50                   	push   %eax
f010a693:	e8 72 e4 ff ff       	call   f0108b0a <unmap_frame>
f010a698:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a69b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a69e:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a6a4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a6a7:	75 0f                	jne    f010a6b8 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a6a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6ac:	8b 50 10             	mov    0x10(%eax),%edx
f010a6af:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6b2:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a6b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a6bc:	75 14                	jne    f010a6d2 <env_page_ws_invalidate+0x488>
f010a6be:	83 ec 04             	sub    $0x4,%esp
f010a6c1:	68 f3 62 12 f0       	push   $0xf01262f3
f010a6c6:	6a 5c                	push   $0x5c
f010a6c8:	68 d4 62 12 f0       	push   $0xf01262d4
f010a6cd:	e8 67 5c ff ff       	call   f0100339 <_panic>
f010a6d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6d5:	8b 40 10             	mov    0x10(%eax),%eax
f010a6d8:	85 c0                	test   %eax,%eax
f010a6da:	74 11                	je     f010a6ed <env_page_ws_invalidate+0x4a3>
f010a6dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6df:	8b 40 10             	mov    0x10(%eax),%eax
f010a6e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a6e5:	8b 52 14             	mov    0x14(%edx),%edx
f010a6e8:	89 50 14             	mov    %edx,0x14(%eax)
f010a6eb:	eb 0f                	jmp    f010a6fc <env_page_ws_invalidate+0x4b2>
f010a6ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6f0:	8b 50 14             	mov    0x14(%eax),%edx
f010a6f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6f6:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a6fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6ff:	8b 40 14             	mov    0x14(%eax),%eax
f010a702:	85 c0                	test   %eax,%eax
f010a704:	74 11                	je     f010a717 <env_page_ws_invalidate+0x4cd>
f010a706:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a709:	8b 40 14             	mov    0x14(%eax),%eax
f010a70c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a70f:	8b 52 10             	mov    0x10(%edx),%edx
f010a712:	89 50 10             	mov    %edx,0x10(%eax)
f010a715:	eb 0f                	jmp    f010a726 <env_page_ws_invalidate+0x4dc>
f010a717:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a71a:	8b 50 10             	mov    0x10(%eax),%edx
f010a71d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a720:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010a726:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a729:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a730:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a733:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a73a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a73d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010a743:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a746:	8b 45 08             	mov    0x8(%ebp),%eax
f010a749:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f010a74f:	83 ec 0c             	sub    $0xc,%esp
f010a752:	ff 75 ec             	pushl  -0x14(%ebp)
f010a755:	e8 35 f3 ff ff       	call   f0109a8f <kfree>
f010a75a:	83 c4 10             	add    $0x10,%esp

				break;
f010a75d:	eb 45                	jmp    f010a7a4 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a75f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a762:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a768:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a76b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a76f:	74 08                	je     f010a779 <env_page_ws_invalidate+0x52f>
f010a771:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a774:	8b 40 10             	mov    0x10(%eax),%eax
f010a777:	eb 05                	jmp    f010a77e <env_page_ws_invalidate+0x534>
f010a779:	b8 00 00 00 00       	mov    $0x0,%eax
f010a77e:	8b 55 08             	mov    0x8(%ebp),%edx
f010a781:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a787:	8b 45 08             	mov    0x8(%ebp),%eax
f010a78a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a790:	85 c0                	test   %eax,%eax
f010a792:	0f 85 c3 fe ff ff    	jne    f010a65b <env_page_ws_invalidate+0x411>
f010a798:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a79c:	0f 85 b9 fe ff ff    	jne    f010a65b <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a7a2:	eb 00                	jmp    f010a7a4 <env_page_ws_invalidate+0x55a>
f010a7a4:	90                   	nop
f010a7a5:	c9                   	leave  
f010a7a6:	c3                   	ret    

f010a7a7 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a7a7:	55                   	push   %ebp
f010a7a8:	89 e5                	mov    %esp,%ebp
f010a7aa:	53                   	push   %ebx
f010a7ab:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a7ae:	83 ec 0c             	sub    $0xc,%esp
f010a7b1:	6a 02                	push   $0x2
f010a7b3:	e8 a9 51 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010a7b8:	83 c4 10             	add    $0x10,%esp
f010a7bb:	85 c0                	test   %eax,%eax
f010a7bd:	0f 84 fe 00 00 00    	je     f010a8c1 <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a7c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a7ca:	83 ec 0c             	sub    $0xc,%esp
f010a7cd:	68 37 63 12 f0       	push   $0xf0126337
f010a7d2:	e8 b4 67 ff ff       	call   f0100f8b <cprintf>
f010a7d7:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a7da:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7dd:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a7e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a7e6:	eb 2c                	jmp    f010a814 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a7e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a7eb:	8b 10                	mov    (%eax),%edx
f010a7ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7f0:	8d 48 01             	lea    0x1(%eax),%ecx
f010a7f3:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a7f6:	83 ec 04             	sub    $0x4,%esp
f010a7f9:	52                   	push   %edx
f010a7fa:	50                   	push   %eax
f010a7fb:	68 51 63 12 f0       	push   $0xf0126351
f010a800:	e8 86 67 ff ff       	call   f0100f8b <cprintf>
f010a805:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a808:	8b 45 08             	mov    0x8(%ebp),%eax
f010a80b:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a811:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a814:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a818:	74 08                	je     f010a822 <env_page_ws_print+0x7b>
f010a81a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a81d:	8b 40 10             	mov    0x10(%eax),%eax
f010a820:	eb 05                	jmp    f010a827 <env_page_ws_print+0x80>
f010a822:	b8 00 00 00 00       	mov    $0x0,%eax
f010a827:	8b 55 08             	mov    0x8(%ebp),%edx
f010a82a:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a830:	8b 45 08             	mov    0x8(%ebp),%eax
f010a833:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a839:	85 c0                	test   %eax,%eax
f010a83b:	75 ab                	jne    f010a7e8 <env_page_ws_print+0x41>
f010a83d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a841:	75 a5                	jne    f010a7e8 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a843:	83 ec 0c             	sub    $0xc,%esp
f010a846:	68 59 63 12 f0       	push   $0xf0126359
f010a84b:	e8 3b 67 ff ff       	call   f0100f8b <cprintf>
f010a850:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a853:	8b 45 08             	mov    0x8(%ebp),%eax
f010a856:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a85c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a85f:	eb 2c                	jmp    f010a88d <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a861:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a864:	8b 10                	mov    (%eax),%edx
f010a866:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a869:	8d 48 01             	lea    0x1(%eax),%ecx
f010a86c:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a86f:	83 ec 04             	sub    $0x4,%esp
f010a872:	52                   	push   %edx
f010a873:	50                   	push   %eax
f010a874:	68 51 63 12 f0       	push   $0xf0126351
f010a879:	e8 0d 67 ff ff       	call   f0100f8b <cprintf>
f010a87e:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a881:	8b 45 08             	mov    0x8(%ebp),%eax
f010a884:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a88a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a88d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a891:	74 08                	je     f010a89b <env_page_ws_print+0xf4>
f010a893:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a896:	8b 40 10             	mov    0x10(%eax),%eax
f010a899:	eb 05                	jmp    f010a8a0 <env_page_ws_print+0xf9>
f010a89b:	b8 00 00 00 00       	mov    $0x0,%eax
f010a8a0:	8b 55 08             	mov    0x8(%ebp),%edx
f010a8a3:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a8a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8ac:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a8b2:	85 c0                	test   %eax,%eax
f010a8b4:	75 ab                	jne    f010a861 <env_page_ws_print+0xba>
f010a8b6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a8ba:	75 a5                	jne    f010a861 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a8bc:	e9 5a 01 00 00       	jmp    f010aa1b <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a8c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a8c8:	83 ec 0c             	sub    $0xc,%esp
f010a8cb:	68 74 63 12 f0       	push   $0xf0126374
f010a8d0:	e8 b6 66 ff ff       	call   f0100f8b <cprintf>
f010a8d5:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a8d8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a8df:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8e2:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a8e8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a8eb:	e9 d1 00 00 00       	jmp    f010a9c1 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a8f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a8f3:	8b 00                	mov    (%eax),%eax
f010a8f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a8f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a8fb:	8b 40 08             	mov    0x8(%eax),%eax
f010a8fe:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a901:	8b 45 08             	mov    0x8(%ebp),%eax
f010a904:	8b 40 64             	mov    0x64(%eax),%eax
f010a907:	83 ec 08             	sub    $0x8,%esp
f010a90a:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a90d:	50                   	push   %eax
f010a90e:	e8 5a f7 ff ff       	call   f010a06d <pt_get_page_permissions>
f010a913:	83 c4 10             	add    $0x10,%esp
f010a916:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a919:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a91c:	83 e0 40             	and    $0x40,%eax
f010a91f:	85 c0                	test   %eax,%eax
f010a921:	0f 95 c0             	setne  %al
f010a924:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a927:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a92a:	83 e0 20             	and    $0x20,%eax
f010a92d:	85 c0                	test   %eax,%eax
f010a92f:	0f 95 c0             	setne  %al
f010a932:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a935:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a938:	25 00 02 00 00       	and    $0x200,%eax
f010a93d:	85 c0                	test   %eax,%eax
f010a93f:	0f 95 c0             	setne  %al
f010a942:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a945:	83 ec 04             	sub    $0x4,%esp
f010a948:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a94b:	ff 75 ec             	pushl  -0x14(%ebp)
f010a94e:	68 7e 63 12 f0       	push   $0xf012637e
f010a953:	e8 33 66 ff ff       	call   f0100f8b <cprintf>
f010a958:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a95b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a95e:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a961:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a965:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a969:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a96d:	83 ec 08             	sub    $0x8,%esp
f010a970:	53                   	push   %ebx
f010a971:	ff 75 e0             	pushl  -0x20(%ebp)
f010a974:	51                   	push   %ecx
f010a975:	52                   	push   %edx
f010a976:	50                   	push   %eax
f010a977:	68 88 63 12 f0       	push   $0xf0126388
f010a97c:	e8 0a 66 ff ff       	call   f0100f8b <cprintf>
f010a981:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a984:	8b 45 08             	mov    0x8(%ebp),%eax
f010a987:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a98d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a990:	75 10                	jne    f010a9a2 <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a992:	83 ec 0c             	sub    $0xc,%esp
f010a995:	68 cf 63 12 f0       	push   $0xf01263cf
f010a99a:	e8 ec 65 ff ff       	call   f0100f8b <cprintf>
f010a99f:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a9a2:	83 ec 0c             	sub    $0xc,%esp
f010a9a5:	68 d4 63 12 f0       	push   $0xf01263d4
f010a9aa:	e8 dc 65 ff ff       	call   f0100f8b <cprintf>
f010a9af:	83 c4 10             	add    $0x10,%esp
			i++;
f010a9b2:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a9b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9b8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a9be:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a9c1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a9c5:	74 08                	je     f010a9cf <env_page_ws_print+0x228>
f010a9c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a9ca:	8b 40 10             	mov    0x10(%eax),%eax
f010a9cd:	eb 05                	jmp    f010a9d4 <env_page_ws_print+0x22d>
f010a9cf:	b8 00 00 00 00       	mov    $0x0,%eax
f010a9d4:	8b 55 08             	mov    0x8(%ebp),%edx
f010a9d7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a9dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9e0:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a9e6:	85 c0                	test   %eax,%eax
f010a9e8:	0f 85 02 ff ff ff    	jne    f010a8f0 <env_page_ws_print+0x149>
f010a9ee:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a9f2:	0f 85 f8 fe ff ff    	jne    f010a8f0 <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a9f8:	eb 13                	jmp    f010aa0d <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a9fa:	83 ec 0c             	sub    $0xc,%esp
f010a9fd:	68 d6 63 12 f0       	push   $0xf01263d6
f010aa02:	e8 84 65 ff ff       	call   f0100f8b <cprintf>
f010aa07:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010aa0a:	ff 45 ec             	incl   -0x14(%ebp)
f010aa0d:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa10:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010aa16:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010aa19:	77 df                	ja     f010a9fa <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010aa1b:	90                   	nop
f010aa1c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010aa1f:	c9                   	leave  
f010aa20:	c3                   	ret    

f010aa21 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010aa21:	55                   	push   %ebp
f010aa22:	89 e5                	mov    %esp,%ebp
f010aa24:	53                   	push   %ebx
f010aa25:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010aa28:	83 ec 0c             	sub    $0xc,%esp
f010aa2b:	68 e8 63 12 f0       	push   $0xf01263e8
f010aa30:	e8 56 65 ff ff       	call   f0100f8b <cprintf>
f010aa35:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010aa38:	83 ec 0c             	sub    $0xc,%esp
f010aa3b:	68 1d 64 12 f0       	push   $0xf012641d
f010aa40:	e8 46 65 ff ff       	call   f0100f8b <cprintf>
f010aa45:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010aa48:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010aa4f:	e9 16 01 00 00       	jmp    f010ab6a <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010aa54:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa57:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa5a:	89 d0                	mov    %edx,%eax
f010aa5c:	01 c0                	add    %eax,%eax
f010aa5e:	01 d0                	add    %edx,%eax
f010aa60:	c1 e0 03             	shl    $0x3,%eax
f010aa63:	01 c8                	add    %ecx,%eax
f010aa65:	05 b0 00 00 00       	add    $0xb0,%eax
f010aa6a:	8a 00                	mov    (%eax),%al
f010aa6c:	84 c0                	test   %al,%al
f010aa6e:	74 43                	je     f010aab3 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010aa70:	83 ec 0c             	sub    $0xc,%esp
f010aa73:	68 28 64 12 f0       	push   $0xf0126428
f010aa78:	e8 0e 65 ff ff       	call   f0100f8b <cprintf>
f010aa7d:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010aa80:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa83:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010aa89:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010aa8c:	75 10                	jne    f010aa9e <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010aa8e:	83 ec 0c             	sub    $0xc,%esp
f010aa91:	68 37 64 12 f0       	push   $0xf0126437
f010aa96:	e8 f0 64 ff ff       	call   f0100f8b <cprintf>
f010aa9b:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010aa9e:	83 ec 0c             	sub    $0xc,%esp
f010aaa1:	68 d4 63 12 f0       	push   $0xf01263d4
f010aaa6:	e8 e0 64 ff ff       	call   f0100f8b <cprintf>
f010aaab:	83 c4 10             	add    $0x10,%esp
			continue;
f010aaae:	e9 b4 00 00 00       	jmp    f010ab67 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010aab3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aab6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aab9:	89 d0                	mov    %edx,%eax
f010aabb:	01 c0                	add    %eax,%eax
f010aabd:	01 d0                	add    %edx,%eax
f010aabf:	c1 e0 03             	shl    $0x3,%eax
f010aac2:	01 c8                	add    %ecx,%eax
f010aac4:	05 ac 00 00 00       	add    $0xac,%eax
f010aac9:	8b 00                	mov    (%eax),%eax
f010aacb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010aace:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aad1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aad4:	89 d0                	mov    %edx,%eax
f010aad6:	01 c0                	add    %eax,%eax
f010aad8:	01 d0                	add    %edx,%eax
f010aada:	c1 e0 03             	shl    $0x3,%eax
f010aadd:	01 c8                	add    %ecx,%eax
f010aadf:	05 ac 00 00 00       	add    $0xac,%eax
f010aae4:	8b 00                	mov    (%eax),%eax
f010aae6:	83 ec 04             	sub    $0x4,%esp
f010aae9:	50                   	push   %eax
f010aaea:	ff 75 f4             	pushl  -0xc(%ebp)
f010aaed:	68 3d 64 12 f0       	push   $0xf012643d
f010aaf2:	e8 94 64 ff ff       	call   f0100f8b <cprintf>
f010aaf7:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010aafa:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aafd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ab00:	89 d0                	mov    %edx,%eax
f010ab02:	01 c0                	add    %eax,%eax
f010ab04:	01 d0                	add    %edx,%eax
f010ab06:	c1 e0 03             	shl    $0x3,%eax
f010ab09:	01 c8                	add    %ecx,%eax
f010ab0b:	05 b4 00 00 00       	add    $0xb4,%eax
f010ab10:	8b 18                	mov    (%eax),%ebx
f010ab12:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab15:	8b 40 64             	mov    0x64(%eax),%eax
f010ab18:	83 ec 08             	sub    $0x8,%esp
f010ab1b:	ff 75 f0             	pushl  -0x10(%ebp)
f010ab1e:	50                   	push   %eax
f010ab1f:	e8 25 f6 ff ff       	call   f010a149 <pd_is_table_used>
f010ab24:	83 c4 10             	add    $0x10,%esp
f010ab27:	83 ec 04             	sub    $0x4,%esp
f010ab2a:	53                   	push   %ebx
f010ab2b:	50                   	push   %eax
f010ab2c:	68 54 64 12 f0       	push   $0xf0126454
f010ab31:	e8 55 64 ff ff       	call   f0100f8b <cprintf>
f010ab36:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010ab39:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab3c:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010ab42:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ab45:	75 10                	jne    f010ab57 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010ab47:	83 ec 0c             	sub    $0xc,%esp
f010ab4a:	68 cf 63 12 f0       	push   $0xf01263cf
f010ab4f:	e8 37 64 ff ff       	call   f0100f8b <cprintf>
f010ab54:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010ab57:	83 ec 0c             	sub    $0xc,%esp
f010ab5a:	68 d4 63 12 f0       	push   $0xf01263d4
f010ab5f:	e8 27 64 ff ff       	call   f0100f8b <cprintf>
f010ab64:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010ab67:	ff 45 f4             	incl   -0xc(%ebp)
f010ab6a:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010ab6e:	0f 86 e0 fe ff ff    	jbe    f010aa54 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010ab74:	90                   	nop
f010ab75:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ab78:	c9                   	leave  
f010ab79:	c3                   	ret    

f010ab7a <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010ab7a:	55                   	push   %ebp
f010ab7b:	89 e5                	mov    %esp,%ebp
f010ab7d:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010ab80:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010ab87:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010ab8e:	eb 22                	jmp    f010abb2 <env_table_ws_get_size+0x38>
f010ab90:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab93:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ab96:	89 d0                	mov    %edx,%eax
f010ab98:	01 c0                	add    %eax,%eax
f010ab9a:	01 d0                	add    %edx,%eax
f010ab9c:	c1 e0 03             	shl    $0x3,%eax
f010ab9f:	01 c8                	add    %ecx,%eax
f010aba1:	05 b0 00 00 00       	add    $0xb0,%eax
f010aba6:	8a 00                	mov    (%eax),%al
f010aba8:	84 c0                	test   %al,%al
f010abaa:	75 03                	jne    f010abaf <env_table_ws_get_size+0x35>
f010abac:	ff 45 f8             	incl   -0x8(%ebp)
f010abaf:	ff 45 fc             	incl   -0x4(%ebp)
f010abb2:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010abb6:	7e d8                	jle    f010ab90 <env_table_ws_get_size+0x16>
	return counter;
f010abb8:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010abbb:	c9                   	leave  
f010abbc:	c3                   	ret    

f010abbd <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010abbd:	55                   	push   %ebp
f010abbe:	89 e5                	mov    %esp,%ebp
f010abc0:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010abc3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010abca:	eb 4e                	jmp    f010ac1a <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010abcc:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abcf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010abd2:	89 d0                	mov    %edx,%eax
f010abd4:	01 c0                	add    %eax,%eax
f010abd6:	01 d0                	add    %edx,%eax
f010abd8:	c1 e0 03             	shl    $0x3,%eax
f010abdb:	01 c8                	add    %ecx,%eax
f010abdd:	05 ac 00 00 00       	add    $0xac,%eax
f010abe2:	8b 00                	mov    (%eax),%eax
f010abe4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010abe7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010abea:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010abef:	89 c2                	mov    %eax,%edx
f010abf1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010abf4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010abf7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010abfa:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010abff:	39 c2                	cmp    %eax,%edx
f010ac01:	75 14                	jne    f010ac17 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010ac03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac06:	83 ec 08             	sub    $0x8,%esp
f010ac09:	50                   	push   %eax
f010ac0a:	ff 75 08             	pushl  0x8(%ebp)
f010ac0d:	e8 bc 00 00 00       	call   f010acce <env_table_ws_clear_entry>
f010ac12:	83 c4 10             	add    $0x10,%esp
			break;
f010ac15:	eb 09                	jmp    f010ac20 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010ac17:	ff 45 f4             	incl   -0xc(%ebp)
f010ac1a:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010ac1e:	7e ac                	jle    f010abcc <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010ac20:	90                   	nop
f010ac21:	c9                   	leave  
f010ac22:	c3                   	ret    

f010ac23 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010ac23:	55                   	push   %ebp
f010ac24:	89 e5                	mov    %esp,%ebp
f010ac26:	53                   	push   %ebx
f010ac27:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ac2a:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ac2e:	76 19                	jbe    f010ac49 <env_table_ws_set_entry+0x26>
f010ac30:	68 78 64 12 f0       	push   $0xf0126478
f010ac35:	68 a9 64 12 f0       	push   $0xf01264a9
f010ac3a:	68 3f 01 00 00       	push   $0x13f
f010ac3f:	68 d4 62 12 f0       	push   $0xf01262d4
f010ac44:	e8 f0 56 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010ac49:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010ac50:	76 19                	jbe    f010ac6b <env_table_ws_set_entry+0x48>
f010ac52:	68 c0 64 12 f0       	push   $0xf01264c0
f010ac57:	68 a9 64 12 f0       	push   $0xf01264a9
f010ac5c:	68 40 01 00 00       	push   $0x140
f010ac61:	68 d4 62 12 f0       	push   $0xf01262d4
f010ac66:	e8 ce 56 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010ac6b:	8b 45 10             	mov    0x10(%ebp),%eax
f010ac6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ac71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac74:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010ac79:	89 c1                	mov    %eax,%ecx
f010ac7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ac7e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ac81:	89 d0                	mov    %edx,%eax
f010ac83:	01 c0                	add    %eax,%eax
f010ac85:	01 d0                	add    %edx,%eax
f010ac87:	c1 e0 03             	shl    $0x3,%eax
f010ac8a:	01 d8                	add    %ebx,%eax
f010ac8c:	05 ac 00 00 00       	add    $0xac,%eax
f010ac91:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010ac93:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac96:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ac99:	89 d0                	mov    %edx,%eax
f010ac9b:	01 c0                	add    %eax,%eax
f010ac9d:	01 d0                	add    %edx,%eax
f010ac9f:	c1 e0 03             	shl    $0x3,%eax
f010aca2:	01 c8                	add    %ecx,%eax
f010aca4:	05 b0 00 00 00       	add    $0xb0,%eax
f010aca9:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010acac:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010acaf:	8b 55 0c             	mov    0xc(%ebp),%edx
f010acb2:	89 d0                	mov    %edx,%eax
f010acb4:	01 c0                	add    %eax,%eax
f010acb6:	01 d0                	add    %edx,%eax
f010acb8:	c1 e0 03             	shl    $0x3,%eax
f010acbb:	01 c8                	add    %ecx,%eax
f010acbd:	05 b4 00 00 00       	add    $0xb4,%eax
f010acc2:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010acc8:	90                   	nop
}
f010acc9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010accc:	c9                   	leave  
f010accd:	c3                   	ret    

f010acce <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010acce:	55                   	push   %ebp
f010accf:	89 e5                	mov    %esp,%ebp
f010acd1:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010acd4:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010acd8:	76 19                	jbe    f010acf3 <env_table_ws_clear_entry+0x25>
f010acda:	68 78 64 12 f0       	push   $0xf0126478
f010acdf:	68 a9 64 12 f0       	push   $0xf01264a9
f010ace4:	68 4b 01 00 00       	push   $0x14b
f010ace9:	68 d4 62 12 f0       	push   $0xf01262d4
f010acee:	e8 46 56 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010acf3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010acf6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010acf9:	89 d0                	mov    %edx,%eax
f010acfb:	01 c0                	add    %eax,%eax
f010acfd:	01 d0                	add    %edx,%eax
f010acff:	c1 e0 03             	shl    $0x3,%eax
f010ad02:	01 c8                	add    %ecx,%eax
f010ad04:	05 ac 00 00 00       	add    $0xac,%eax
f010ad09:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010ad0f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad12:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ad15:	89 d0                	mov    %edx,%eax
f010ad17:	01 c0                	add    %eax,%eax
f010ad19:	01 d0                	add    %edx,%eax
f010ad1b:	c1 e0 03             	shl    $0x3,%eax
f010ad1e:	01 c8                	add    %ecx,%eax
f010ad20:	05 b0 00 00 00       	add    $0xb0,%eax
f010ad25:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010ad28:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad2b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ad2e:	89 d0                	mov    %edx,%eax
f010ad30:	01 c0                	add    %eax,%eax
f010ad32:	01 d0                	add    %edx,%eax
f010ad34:	c1 e0 03             	shl    $0x3,%eax
f010ad37:	01 c8                	add    %ecx,%eax
f010ad39:	05 b4 00 00 00       	add    $0xb4,%eax
f010ad3e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010ad44:	90                   	nop
f010ad45:	c9                   	leave  
f010ad46:	c3                   	ret    

f010ad47 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010ad47:	55                   	push   %ebp
f010ad48:	89 e5                	mov    %esp,%ebp
f010ad4a:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ad4d:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ad51:	76 19                	jbe    f010ad6c <env_table_ws_get_virtual_address+0x25>
f010ad53:	68 78 64 12 f0       	push   $0xf0126478
f010ad58:	68 a9 64 12 f0       	push   $0xf01264a9
f010ad5d:	68 53 01 00 00       	push   $0x153
f010ad62:	68 d4 62 12 f0       	push   $0xf01262d4
f010ad67:	e8 cd 55 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010ad6c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad6f:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ad72:	89 d0                	mov    %edx,%eax
f010ad74:	01 c0                	add    %eax,%eax
f010ad76:	01 d0                	add    %edx,%eax
f010ad78:	c1 e0 03             	shl    $0x3,%eax
f010ad7b:	01 c8                	add    %ecx,%eax
f010ad7d:	05 ac 00 00 00       	add    $0xac,%eax
f010ad82:	8b 00                	mov    (%eax),%eax
f010ad84:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ad87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad8a:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010ad8f:	c9                   	leave  
f010ad90:	c3                   	ret    

f010ad91 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010ad91:	55                   	push   %ebp
f010ad92:	89 e5                	mov    %esp,%ebp
f010ad94:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ad97:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ad9b:	76 19                	jbe    f010adb6 <env_table_ws_get_time_stamp+0x25>
f010ad9d:	68 78 64 12 f0       	push   $0xf0126478
f010ada2:	68 a9 64 12 f0       	push   $0xf01264a9
f010ada7:	68 5a 01 00 00       	push   $0x15a
f010adac:	68 d4 62 12 f0       	push   $0xf01262d4
f010adb1:	e8 83 55 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010adb6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010adb9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010adbc:	89 d0                	mov    %edx,%eax
f010adbe:	01 c0                	add    %eax,%eax
f010adc0:	01 d0                	add    %edx,%eax
f010adc2:	c1 e0 03             	shl    $0x3,%eax
f010adc5:	01 c8                	add    %ecx,%eax
f010adc7:	05 b4 00 00 00       	add    $0xb4,%eax
f010adcc:	8b 00                	mov    (%eax),%eax
}
f010adce:	c9                   	leave  
f010adcf:	c3                   	ret    

f010add0 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010add0:	55                   	push   %ebp
f010add1:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010add3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010add6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010add9:	89 d0                	mov    %edx,%eax
f010addb:	01 c0                	add    %eax,%eax
f010addd:	01 d0                	add    %edx,%eax
f010addf:	c1 e0 03             	shl    $0x3,%eax
f010ade2:	01 c8                	add    %ecx,%eax
f010ade4:	05 b0 00 00 00       	add    $0xb0,%eax
f010ade9:	8a 00                	mov    (%eax),%al
f010adeb:	0f b6 c0             	movzbl %al,%eax
}
f010adee:	5d                   	pop    %ebp
f010adef:	c3                   	ret    

f010adf0 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010adf0:	55                   	push   %ebp
f010adf1:	89 e5                	mov    %esp,%ebp
f010adf3:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010adf6:	83 ec 04             	sub    $0x4,%esp
f010adf9:	68 f3 64 12 f0       	push   $0xf01264f3
f010adfe:	68 6a 01 00 00       	push   $0x16a
f010ae03:	68 d4 62 12 f0       	push   $0xf01262d4
f010ae08:	e8 2c 55 ff ff       	call   f0100339 <_panic>

f010ae0d <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010ae0d:	55                   	push   %ebp
f010ae0e:	89 e5                	mov    %esp,%ebp
f010ae10:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ae13:	83 ec 04             	sub    $0x4,%esp
f010ae16:	68 f3 64 12 f0       	push   $0xf01264f3
f010ae1b:	68 6f 01 00 00       	push   $0x16f
f010ae20:	68 d4 62 12 f0       	push   $0xf01262d4
f010ae25:	e8 0f 55 ff ff       	call   f0100339 <_panic>

f010ae2a <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010ae2a:	55                   	push   %ebp
f010ae2b:	89 e5                	mov    %esp,%ebp
f010ae2d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010ae30:	83 ec 04             	sub    $0x4,%esp
f010ae33:	68 04 65 12 f0       	push   $0xf0126504
f010ae38:	6a 22                	push   $0x22
f010ae3a:	68 32 65 12 f0       	push   $0xf0126532
f010ae3f:	e8 f5 54 ff ff       	call   f0100339 <_panic>

f010ae44 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010ae44:	55                   	push   %ebp
f010ae45:	89 e5                	mov    %esp,%ebp
f010ae47:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010ae4a:	83 ec 04             	sub    $0x4,%esp
f010ae4d:	68 50 65 12 f0       	push   $0xf0126550
f010ae52:	6a 35                	push   $0x35
f010ae54:	68 32 65 12 f0       	push   $0xf0126532
f010ae59:	e8 db 54 ff ff       	call   f0100339 <_panic>

f010ae5e <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010ae5e:	55                   	push   %ebp
f010ae5f:	89 e5                	mov    %esp,%ebp
f010ae61:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010ae64:	83 ec 04             	sub    $0x4,%esp
f010ae67:	68 80 65 12 f0       	push   $0xf0126580
f010ae6c:	6a 45                	push   $0x45
f010ae6e:	68 32 65 12 f0       	push   $0xf0126532
f010ae73:	e8 c1 54 ff ff       	call   f0100339 <_panic>

f010ae78 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010ae78:	55                   	push   %ebp
f010ae79:	89 e5                	mov    %esp,%ebp
f010ae7b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010ae7e:	83 ec 04             	sub    $0x4,%esp
f010ae81:	68 ac 65 12 f0       	push   $0xf01265ac
f010ae86:	6a 53                	push   $0x53
f010ae88:	68 32 65 12 f0       	push   $0xf0126532
f010ae8d:	e8 a7 54 ff ff       	call   f0100339 <_panic>

f010ae92 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010ae92:	55                   	push   %ebp
f010ae93:	89 e5                	mov    %esp,%ebp
f010ae95:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010ae98:	83 ec 04             	sub    $0x4,%esp
f010ae9b:	68 dc 65 12 f0       	push   $0xf01265dc
f010aea0:	6a 5d                	push   $0x5d
f010aea2:	68 32 65 12 f0       	push   $0xf0126532
f010aea7:	e8 8d 54 ff ff       	call   f0100339 <_panic>

f010aeac <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010aeac:	55                   	push   %ebp
f010aead:	89 e5                	mov    %esp,%ebp
f010aeaf:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010aeb2:	83 ec 04             	sub    $0x4,%esp
f010aeb5:	68 14 66 12 f0       	push   $0xf0126614
f010aeba:	6a 6a                	push   $0x6a
f010aebc:	68 32 65 12 f0       	push   $0xf0126532
f010aec1:	e8 73 54 ff ff       	call   f0100339 <_panic>

f010aec6 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010aec6:	55                   	push   %ebp
f010aec7:	89 e5                	mov    %esp,%ebp
f010aec9:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010aecc:	e8 54 0e 00 00       	call   f010bd25 <get_cpu_proc>
f010aed1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010aed4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010aed8:	7e 61                	jle    f010af3b <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010aeda:	8b 45 08             	mov    0x8(%ebp),%eax
f010aedd:	c1 e0 0c             	shl    $0xc,%eax
f010aee0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010aee3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aee6:	8b 40 7c             	mov    0x7c(%eax),%eax
f010aee9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010aeec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aeef:	8b 50 7c             	mov    0x7c(%eax),%edx
f010aef2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010aef5:	01 c2                	add    %eax,%edx
f010aef7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aefa:	8b 40 78             	mov    0x78(%eax),%eax
f010aefd:	39 c2                	cmp    %eax,%edx
f010aeff:	77 09                	ja     f010af0a <sys_sbrk+0x44>
f010af01:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f010af06:	85 c0                	test   %eax,%eax
f010af08:	75 07                	jne    f010af11 <sys_sbrk+0x4b>
f010af0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010af0f:	eb 3d                	jmp    f010af4e <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010af11:	83 ec 04             	sub    $0x4,%esp
f010af14:	ff 75 f0             	pushl  -0x10(%ebp)
f010af17:	ff 75 ec             	pushl  -0x14(%ebp)
f010af1a:	ff 75 f4             	pushl  -0xc(%ebp)
f010af1d:	e8 2e 00 00 00       	call   f010af50 <allocate_user_mem>
f010af22:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010af25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af28:	8b 50 7c             	mov    0x7c(%eax),%edx
f010af2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010af2e:	01 c2                	add    %eax,%edx
f010af30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af33:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010af36:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010af39:	eb 13                	jmp    f010af4e <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010af3b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010af3f:	75 08                	jne    f010af49 <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010af41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af44:	8b 40 7c             	mov    0x7c(%eax),%eax
f010af47:	eb 05                	jmp    f010af4e <sys_sbrk+0x88>
	}

	return (void *)-1;
f010af49:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010af4e:	c9                   	leave  
f010af4f:	c3                   	ret    

f010af50 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010af50:	55                   	push   %ebp
f010af51:	89 e5                	mov    %esp,%ebp
f010af53:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010af56:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010af5d:	8b 55 10             	mov    0x10(%ebp),%edx
f010af60:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010af63:	01 d0                	add    %edx,%eax
f010af65:	48                   	dec    %eax
f010af66:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010af69:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010af6c:	ba 00 00 00 00       	mov    $0x0,%edx
f010af71:	f7 75 f0             	divl   -0x10(%ebp)
f010af74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010af77:	29 d0                	sub    %edx,%eax
f010af79:	c1 e8 0c             	shr    $0xc,%eax
f010af7c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010af7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010af86:	eb 78                	jmp    f010b000 <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010af88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af8b:	c1 e0 0c             	shl    $0xc,%eax
f010af8e:	89 c2                	mov    %eax,%edx
f010af90:	8b 45 0c             	mov    0xc(%ebp),%eax
f010af93:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010af96:	8b 45 08             	mov    0x8(%ebp),%eax
f010af99:	8b 40 64             	mov    0x64(%eax),%eax
f010af9c:	83 ec 04             	sub    $0x4,%esp
f010af9f:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010afa2:	52                   	push   %edx
f010afa3:	51                   	push   %ecx
f010afa4:	50                   	push   %eax
f010afa5:	e8 70 d7 ff ff       	call   f010871a <get_page_table>
f010afaa:	83 c4 10             	add    $0x10,%esp
f010afad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010afb0:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010afb4:	75 23                	jne    f010afd9 <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010afb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afb9:	c1 e0 0c             	shl    $0xc,%eax
f010afbc:	89 c2                	mov    %eax,%edx
f010afbe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010afc1:	01 c2                	add    %eax,%edx
f010afc3:	8b 45 08             	mov    0x8(%ebp),%eax
f010afc6:	8b 40 64             	mov    0x64(%eax),%eax
f010afc9:	83 ec 08             	sub    $0x8,%esp
f010afcc:	52                   	push   %edx
f010afcd:	50                   	push   %eax
f010afce:	e8 9d d8 ff ff       	call   f0108870 <create_page_table>
f010afd3:	83 c4 10             	add    $0x10,%esp
f010afd6:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010afd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afdc:	c1 e0 0c             	shl    $0xc,%eax
f010afdf:	89 c2                	mov    %eax,%edx
f010afe1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010afe4:	01 c2                	add    %eax,%edx
f010afe6:	8b 45 08             	mov    0x8(%ebp),%eax
f010afe9:	8b 40 64             	mov    0x64(%eax),%eax
f010afec:	6a 00                	push   $0x0
f010afee:	68 00 02 00 00       	push   $0x200
f010aff3:	52                   	push   %edx
f010aff4:	50                   	push   %eax
f010aff5:	e8 af ef ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010affa:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010affd:	ff 45 f4             	incl   -0xc(%ebp)
f010b000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b003:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010b006:	72 80                	jb     f010af88 <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010b008:	90                   	nop
f010b009:	c9                   	leave  
f010b00a:	c3                   	ret    

f010b00b <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010b00b:	55                   	push   %ebp
f010b00c:	89 e5                	mov    %esp,%ebp
f010b00e:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem

		pt_set_page_permissions(e->env_page_directory,(size*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010b011:	8b 45 10             	mov    0x10(%ebp),%eax
f010b014:	c1 e0 0c             	shl    $0xc,%eax
f010b017:	89 c2                	mov    %eax,%edx
f010b019:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b01c:	01 c2                	add    %eax,%edx
f010b01e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b021:	8b 40 64             	mov    0x64(%eax),%eax
f010b024:	68 00 02 00 00       	push   $0x200
f010b029:	6a 00                	push   $0x0
f010b02b:	52                   	push   %edx
f010b02c:	50                   	push   %eax
f010b02d:	e8 77 ef ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010b032:	83 c4 10             	add    $0x10,%esp
		int ret = pf_read_env_page(e,(void*)((size*PAGE_SIZE)+virtual_address));
f010b035:	8b 45 10             	mov    0x10(%ebp),%eax
f010b038:	c1 e0 0c             	shl    $0xc,%eax
f010b03b:	89 c2                	mov    %eax,%edx
f010b03d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b040:	01 d0                	add    %edx,%eax
f010b042:	83 ec 08             	sub    $0x8,%esp
f010b045:	50                   	push   %eax
f010b046:	ff 75 08             	pushl  0x8(%ebp)
f010b049:	e8 81 96 ff ff       	call   f01046cf <pf_read_env_page>
f010b04e:	83 c4 10             	add    $0x10,%esp
f010b051:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (size*PAGE_SIZE)+virtual_address);
f010b054:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%ebp)
f010b058:	75 1e                	jne    f010b078 <free_user_mem+0x6d>
f010b05a:	8b 45 10             	mov    0x10(%ebp),%eax
f010b05d:	c1 e0 0c             	shl    $0xc,%eax
f010b060:	89 c2                	mov    %eax,%edx
f010b062:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b065:	01 d0                	add    %edx,%eax
f010b067:	83 ec 08             	sub    $0x8,%esp
f010b06a:	50                   	push   %eax
f010b06b:	ff 75 08             	pushl  0x8(%ebp)
f010b06e:	e8 d7 f1 ff ff       	call   f010a24a <env_page_ws_invalidate>
f010b073:	83 c4 10             	add    $0x10,%esp
		else pf_remove_env_page(e, (size*PAGE_SIZE)+virtual_address);


}
f010b076:	eb 1c                	jmp    f010b094 <free_user_mem+0x89>
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem

		pt_set_page_permissions(e->env_page_directory,(size*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
		int ret = pf_read_env_page(e,(void*)((size*PAGE_SIZE)+virtual_address));
		if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (size*PAGE_SIZE)+virtual_address);
		else pf_remove_env_page(e, (size*PAGE_SIZE)+virtual_address);
f010b078:	8b 45 10             	mov    0x10(%ebp),%eax
f010b07b:	c1 e0 0c             	shl    $0xc,%eax
f010b07e:	89 c2                	mov    %eax,%edx
f010b080:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b083:	01 d0                	add    %edx,%eax
f010b085:	83 ec 08             	sub    $0x8,%esp
f010b088:	50                   	push   %eax
f010b089:	ff 75 08             	pushl  0x8(%ebp)
f010b08c:	e8 01 97 ff ff       	call   f0104792 <pf_remove_env_page>
f010b091:	83 c4 10             	add    $0x10,%esp


}
f010b094:	90                   	nop
f010b095:	c9                   	leave  
f010b096:	c3                   	ret    

f010b097 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010b097:	55                   	push   %ebp
f010b098:	89 e5                	mov    %esp,%ebp
f010b09a:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010b09d:	83 ec 04             	sub    $0x4,%esp
f010b0a0:	68 4c 66 12 f0       	push   $0xf012664c
f010b0a5:	68 de 00 00 00       	push   $0xde
f010b0aa:	68 32 65 12 f0       	push   $0xf0126532
f010b0af:	e8 85 52 ff ff       	call   f0100339 <_panic>

f010b0b4 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010b0b4:	55                   	push   %ebp
f010b0b5:	89 e5                	mov    %esp,%ebp
f010b0b7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010b0ba:	83 ec 04             	sub    $0x4,%esp
f010b0bd:	68 8c 66 12 f0       	push   $0xf012668c
f010b0c2:	68 e8 00 00 00       	push   $0xe8
f010b0c7:	68 32 65 12 f0       	push   $0xf0126532
f010b0cc:	e8 68 52 ff ff       	call   f0100339 <_panic>

f010b0d1 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010b0d1:	55                   	push   %ebp
f010b0d2:	89 e5                	mov    %esp,%ebp
f010b0d4:	56                   	push   %esi
f010b0d5:	53                   	push   %ebx
f010b0d6:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010b0d9:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010b0e0:	e9 b0 01 00 00       	jmp    f010b295 <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010b0e5:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b0eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b0ee:	89 d0                	mov    %edx,%eax
f010b0f0:	c1 e0 03             	shl    $0x3,%eax
f010b0f3:	01 d0                	add    %edx,%eax
f010b0f5:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b0fc:	01 d8                	add    %ebx,%eax
f010b0fe:	01 c0                	add    %eax,%eax
f010b100:	01 d0                	add    %edx,%eax
f010b102:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b109:	01 d8                	add    %ebx,%eax
f010b10b:	01 d0                	add    %edx,%eax
f010b10d:	01 c8                	add    %ecx,%eax
f010b10f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010b116:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b11c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b11f:	89 d0                	mov    %edx,%eax
f010b121:	c1 e0 03             	shl    $0x3,%eax
f010b124:	01 d0                	add    %edx,%eax
f010b126:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b12d:	01 d8                	add    %ebx,%eax
f010b12f:	01 c0                	add    %eax,%eax
f010b131:	01 d0                	add    %edx,%eax
f010b133:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b13a:	01 d8                	add    %ebx,%eax
f010b13c:	01 d0                	add    %edx,%eax
f010b13e:	01 c8                	add    %ecx,%eax
f010b140:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010b147:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b14d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b150:	89 d0                	mov    %edx,%eax
f010b152:	c1 e0 03             	shl    $0x3,%eax
f010b155:	01 d0                	add    %edx,%eax
f010b157:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b15e:	01 d8                	add    %ebx,%eax
f010b160:	01 c0                	add    %eax,%eax
f010b162:	01 d0                	add    %edx,%eax
f010b164:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b16b:	01 d8                	add    %ebx,%eax
f010b16d:	01 d0                	add    %edx,%eax
f010b16f:	01 c8                	add    %ecx,%eax
f010b171:	85 c0                	test   %eax,%eax
f010b173:	75 14                	jne    f010b189 <env_init+0xb8>
f010b175:	83 ec 04             	sub    $0x4,%esp
f010b178:	68 b8 66 12 f0       	push   $0xf01266b8
f010b17d:	6a 65                	push   $0x65
f010b17f:	68 db 66 12 f0       	push   $0xf01266db
f010b184:	e8 b0 51 ff ff       	call   f0100339 <_panic>
f010b189:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b18f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b192:	89 d0                	mov    %edx,%eax
f010b194:	c1 e0 03             	shl    $0x3,%eax
f010b197:	01 d0                	add    %edx,%eax
f010b199:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b1a0:	01 d8                	add    %ebx,%eax
f010b1a2:	01 c0                	add    %eax,%eax
f010b1a4:	01 d0                	add    %edx,%eax
f010b1a6:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b1ad:	01 d8                	add    %ebx,%eax
f010b1af:	01 d0                	add    %edx,%eax
f010b1b1:	01 c8                	add    %ecx,%eax
f010b1b3:	8b 15 94 65 6f f0    	mov    0xf06f6594,%edx
f010b1b9:	89 50 08             	mov    %edx,0x8(%eax)
f010b1bc:	8b 40 08             	mov    0x8(%eax),%eax
f010b1bf:	85 c0                	test   %eax,%eax
f010b1c1:	74 35                	je     f010b1f8 <env_init+0x127>
f010b1c3:	8b 0d 94 65 6f f0    	mov    0xf06f6594,%ecx
f010b1c9:	8b 1d 90 65 6f f0    	mov    0xf06f6590,%ebx
f010b1cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b1d2:	89 d0                	mov    %edx,%eax
f010b1d4:	c1 e0 03             	shl    $0x3,%eax
f010b1d7:	01 d0                	add    %edx,%eax
f010b1d9:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010b1e0:	01 f0                	add    %esi,%eax
f010b1e2:	01 c0                	add    %eax,%eax
f010b1e4:	01 d0                	add    %edx,%eax
f010b1e6:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010b1ed:	01 f0                	add    %esi,%eax
f010b1ef:	01 d0                	add    %edx,%eax
f010b1f1:	01 d8                	add    %ebx,%eax
f010b1f3:	89 41 0c             	mov    %eax,0xc(%ecx)
f010b1f6:	eb 2f                	jmp    f010b227 <env_init+0x156>
f010b1f8:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b1fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b201:	89 d0                	mov    %edx,%eax
f010b203:	c1 e0 03             	shl    $0x3,%eax
f010b206:	01 d0                	add    %edx,%eax
f010b208:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b20f:	01 d8                	add    %ebx,%eax
f010b211:	01 c0                	add    %eax,%eax
f010b213:	01 d0                	add    %edx,%eax
f010b215:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b21c:	01 d8                	add    %ebx,%eax
f010b21e:	01 d0                	add    %edx,%eax
f010b220:	01 c8                	add    %ecx,%eax
f010b222:	a3 98 65 6f f0       	mov    %eax,0xf06f6598
f010b227:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b22d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b230:	89 d0                	mov    %edx,%eax
f010b232:	c1 e0 03             	shl    $0x3,%eax
f010b235:	01 d0                	add    %edx,%eax
f010b237:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b23e:	01 d8                	add    %ebx,%eax
f010b240:	01 c0                	add    %eax,%eax
f010b242:	01 d0                	add    %edx,%eax
f010b244:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b24b:	01 d8                	add    %ebx,%eax
f010b24d:	01 d0                	add    %edx,%eax
f010b24f:	01 c8                	add    %ecx,%eax
f010b251:	a3 94 65 6f f0       	mov    %eax,0xf06f6594
f010b256:	8b 0d 90 65 6f f0    	mov    0xf06f6590,%ecx
f010b25c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b25f:	89 d0                	mov    %edx,%eax
f010b261:	c1 e0 03             	shl    $0x3,%eax
f010b264:	01 d0                	add    %edx,%eax
f010b266:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b26d:	01 d8                	add    %ebx,%eax
f010b26f:	01 c0                	add    %eax,%eax
f010b271:	01 d0                	add    %edx,%eax
f010b273:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b27a:	01 d8                	add    %ebx,%eax
f010b27c:	01 d0                	add    %edx,%eax
f010b27e:	01 c8                	add    %ecx,%eax
f010b280:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b287:	a1 a0 65 6f f0       	mov    0xf06f65a0,%eax
f010b28c:	40                   	inc    %eax
f010b28d:	a3 a0 65 6f f0       	mov    %eax,0xf06f65a0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010b292:	ff 4d f4             	decl   -0xc(%ebp)
f010b295:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b299:	0f 89 46 fe ff ff    	jns    f010b0e5 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010b29f:	90                   	nop
f010b2a0:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b2a3:	5b                   	pop    %ebx
f010b2a4:	5e                   	pop    %esi
f010b2a5:	5d                   	pop    %ebp
f010b2a6:	c3                   	ret    

f010b2a7 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010b2a7:	55                   	push   %ebp
f010b2a8:	89 e5                	mov    %esp,%ebp
f010b2aa:	57                   	push   %edi
f010b2ab:	56                   	push   %esi
f010b2ac:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010b2b2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010b2b9:	83 ec 0c             	sub    $0xc,%esp
f010b2bc:	ff 75 08             	pushl  0x8(%ebp)
f010b2bf:	e8 b8 1e 00 00       	call   f010d17c <get_user_program_info>
f010b2c4:	83 c4 10             	add    $0x10,%esp
f010b2c7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010b2ca:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b2ce:	75 0a                	jne    f010b2da <env_create+0x33>
	{
		return NULL;
f010b2d0:	b8 00 00 00 00       	mov    $0x0,%eax
f010b2d5:	e9 aa 09 00 00       	jmp    f010bc84 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010b2da:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b2dd:	8b 40 08             	mov    0x8(%eax),%eax
f010b2e0:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010b2e3:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010b2ea:	00 00 00 
	if(allocate_environment(&e) < 0)
f010b2ed:	83 ec 0c             	sub    $0xc,%esp
f010b2f0:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010b2f6:	50                   	push   %eax
f010b2f7:	e8 96 0e 00 00       	call   f010c192 <allocate_environment>
f010b2fc:	83 c4 10             	add    $0x10,%esp
f010b2ff:	85 c0                	test   %eax,%eax
f010b301:	79 0a                	jns    f010b30d <env_create+0x66>
	{
		return NULL;
f010b303:	b8 00 00 00 00       	mov    $0x0,%eax
f010b308:	e9 77 09 00 00       	jmp    f010bc84 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010b30d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b310:	8b 00                	mov    (%eax),%eax
f010b312:	83 ec 0c             	sub    $0xc,%esp
f010b315:	50                   	push   %eax
f010b316:	e8 47 4c 01 00       	call   f011ff62 <strlen>
f010b31b:	83 c4 10             	add    $0x10,%esp
f010b31e:	83 f8 3f             	cmp    $0x3f,%eax
f010b321:	7f 1d                	jg     f010b340 <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010b323:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b326:	8b 00                	mov    (%eax),%eax
f010b328:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b32e:	83 c2 20             	add    $0x20,%edx
f010b331:	83 ec 08             	sub    $0x8,%esp
f010b334:	50                   	push   %eax
f010b335:	52                   	push   %edx
f010b336:	e8 76 4c 01 00       	call   f011ffb1 <strcpy>
f010b33b:	83 c4 10             	add    $0x10,%esp
f010b33e:	eb 1d                	jmp    f010b35d <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010b340:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b343:	8b 00                	mov    (%eax),%eax
f010b345:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b34b:	83 c2 20             	add    $0x20,%edx
f010b34e:	83 ec 04             	sub    $0x4,%esp
f010b351:	6a 3f                	push   $0x3f
f010b353:	50                   	push   %eax
f010b354:	52                   	push   %edx
f010b355:	e8 85 4c 01 00       	call   f011ffdf <strncpy>
f010b35a:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010b35d:	e8 fc 13 00 00       	call   f010c75e <create_user_directory>
f010b362:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010b365:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b368:	83 ec 0c             	sub    $0xc,%esp
f010b36b:	50                   	push   %eax
f010b36c:	e8 44 e8 ff ff       	call   f0109bb5 <kheap_physical_address>
f010b371:	83 c4 10             	add    $0x10,%esp
f010b374:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010b377:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b37d:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b380:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b386:	83 ec 0c             	sub    $0xc,%esp
f010b389:	6a 02                	push   $0x2
f010b38b:	e8 d1 45 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010b390:	83 c4 10             	add    $0x10,%esp
f010b393:	85 c0                	test   %eax,%eax
f010b395:	74 21                	je     f010b3b8 <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010b397:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b39d:	8b 55 10             	mov    0x10(%ebp),%edx
f010b3a0:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010b3a6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3ac:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b3af:	2b 55 10             	sub    0x10(%ebp),%edx
f010b3b2:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010b3b8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b3bc:	75 12                	jne    f010b3d0 <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010b3be:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3c4:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010b3cb:	00 00 00 
f010b3ce:	eb 0f                	jmp    f010b3df <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010b3d0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3d6:	8b 55 14             	mov    0x14(%ebp),%edx
f010b3d9:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010b3df:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3e5:	83 ec 04             	sub    $0x4,%esp
f010b3e8:	ff 75 bc             	pushl  -0x44(%ebp)
f010b3eb:	ff 75 c0             	pushl  -0x40(%ebp)
f010b3ee:	50                   	push   %eax
f010b3ef:	e8 c8 14 00 00       	call   f010c8bc <initialize_environment>
f010b3f4:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010b3f7:	e8 fe c0 ff ff       	call   f01074fa <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010b3fc:	0f 20 d8             	mov    %cr3,%eax
f010b3ff:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010b402:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010b405:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010b408:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b40e:	8b 40 68             	mov    0x68(%eax),%eax
f010b411:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b417:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b41d:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010b420:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010b427:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010b42e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b434:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b43a:	48                   	dec    %eax
f010b43b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b43e:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010b445:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b448:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010b44e:	83 ec 08             	sub    $0x8,%esp
f010b451:	ff 75 c8             	pushl  -0x38(%ebp)
f010b454:	50                   	push   %eax
f010b455:	e8 34 1a 00 00       	call   f010ce8e <PROGRAM_SEGMENT_FIRST>
f010b45a:	83 c4 0c             	add    $0xc,%esp
f010b45d:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b463:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010b469:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b46e:	89 c7                	mov    %eax,%edi
f010b470:	89 d6                	mov    %edx,%esi
f010b472:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b474:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b47a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010b47d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b480:	8b 40 10             	mov    0x10(%eax),%eax
f010b483:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b486:	75 07                	jne    f010b48f <env_create+0x1e8>
f010b488:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010b48f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b492:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b495:	e9 fa 02 00 00       	jmp    f010b794 <env_create+0x4ed>
		{
			segment_counter++;
f010b49a:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b49d:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010b4a4:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b4a7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b4ad:	83 ec 0c             	sub    $0xc,%esp
f010b4b0:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010b4b6:	52                   	push   %edx
f010b4b7:	ff 75 ec             	pushl  -0x14(%ebp)
f010b4ba:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b4c0:	52                   	push   %edx
f010b4c1:	ff 75 f4             	pushl  -0xc(%ebp)
f010b4c4:	50                   	push   %eax
f010b4c5:	e8 86 0d 00 00       	call   f010c250 <program_segment_alloc_map_copy_workingset>
f010b4ca:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b4cd:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010b4d3:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b4d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4d9:	8b 00                	mov    (%eax),%eax
f010b4db:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b4de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4e1:	8b 40 0c             	mov    0xc(%eax),%eax
f010b4e4:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b4e7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b4ea:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010b4ed:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010b4f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b4f5:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b4f8:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010b4ff:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010b502:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b505:	01 d0                	add    %edx,%eax
f010b507:	48                   	dec    %eax
f010b508:	89 45 98             	mov    %eax,-0x68(%ebp)
f010b50b:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b50e:	ba 00 00 00 00       	mov    $0x0,%edx
f010b513:	f7 75 9c             	divl   -0x64(%ebp)
f010b516:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b519:	29 d0                	sub    %edx,%eax
f010b51b:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b51e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b521:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010b524:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b527:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b52a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b52d:	8b 15 4c f8 f1 f0    	mov    0xf0f1f84c,%edx
f010b533:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b536:	01 d0                	add    %edx,%eax
f010b538:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010b53b:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010b53f:	74 73                	je     f010b5b4 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b541:	a1 4c f8 f1 f0       	mov    0xf0f1f84c,%eax
f010b546:	83 ec 04             	sub    $0x4,%esp
f010b549:	68 00 10 00 00       	push   $0x1000
f010b54e:	6a 00                	push   $0x0
f010b550:	50                   	push   %eax
f010b551:	e8 fa 4b 01 00       	call   f0120150 <memset>
f010b556:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b559:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b55c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b55f:	eb 13                	jmp    f010b574 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010b561:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b564:	8a 10                	mov    (%eax),%dl
f010b566:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b569:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b56b:	ff 45 dc             	incl   -0x24(%ebp)
f010b56e:	ff 45 e4             	incl   -0x1c(%ebp)
f010b571:	ff 45 e0             	incl   -0x20(%ebp)
f010b574:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b577:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010b57a:	72 e5                	jb     f010b561 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b57c:	8b 15 4c f8 f1 f0    	mov    0xf0f1f84c,%edx
f010b582:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b588:	83 ec 04             	sub    $0x4,%esp
f010b58b:	52                   	push   %edx
f010b58c:	ff 75 a0             	pushl  -0x60(%ebp)
f010b58f:	50                   	push   %eax
f010b590:	e8 90 8e ff ff       	call   f0104425 <pf_add_env_page>
f010b595:	83 c4 10             	add    $0x10,%esp
f010b598:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b59b:	75 17                	jne    f010b5b4 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b59d:	83 ec 04             	sub    $0x4,%esp
f010b5a0:	68 f8 66 12 f0       	push   $0xf01266f8
f010b5a5:	68 f5 00 00 00       	push   $0xf5
f010b5aa:	68 db 66 12 f0       	push   $0xf01266db
f010b5af:	e8 85 4d ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b5b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5b7:	8b 50 04             	mov    0x4(%eax),%edx
f010b5ba:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b5bd:	01 d0                	add    %edx,%eax
f010b5bf:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b5c2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b5c5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b5ca:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b5cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5d0:	8b 50 04             	mov    0x4(%eax),%edx
f010b5d3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b5d6:	01 d0                	add    %edx,%eax
f010b5d8:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b5db:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b5de:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b5e1:	eb 43                	jmp    f010b626 <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b5e3:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010b5e6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5ec:	83 ec 04             	sub    $0x4,%esp
f010b5ef:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b5f2:	52                   	push   %edx
f010b5f3:	50                   	push   %eax
f010b5f4:	e8 2c 8e ff ff       	call   f0104425 <pf_add_env_page>
f010b5f9:	83 c4 10             	add    $0x10,%esp
f010b5fc:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b5ff:	75 17                	jne    f010b618 <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b601:	83 ec 04             	sub    $0x4,%esp
f010b604:	68 f8 66 12 f0       	push   $0xf01266f8
f010b609:	68 02 01 00 00       	push   $0x102
f010b60e:	68 db 66 12 f0       	push   $0xf01266db
f010b613:	e8 21 4d ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b618:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b61f:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010b626:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b629:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010b62c:	72 b5                	jb     f010b5e3 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b62e:	a1 4c f8 f1 f0       	mov    0xf0f1f84c,%eax
f010b633:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b636:	83 ec 04             	sub    $0x4,%esp
f010b639:	68 00 10 00 00       	push   $0x1000
f010b63e:	6a 00                	push   $0x0
f010b640:	ff 75 e0             	pushl  -0x20(%ebp)
f010b643:	e8 08 4b 01 00       	call   f0120150 <memset>
f010b648:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b64b:	8b 45 88             	mov    -0x78(%ebp),%eax
f010b64e:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b651:	eb 13                	jmp    f010b666 <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010b653:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b656:	8a 10                	mov    (%eax),%dl
f010b658:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b65b:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b65d:	ff 45 dc             	incl   -0x24(%ebp)
f010b660:	ff 45 e4             	incl   -0x1c(%ebp)
f010b663:	ff 45 e0             	incl   -0x20(%ebp)
f010b666:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b669:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010b66c:	72 e5                	jb     f010b653 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b66e:	8b 15 4c f8 f1 f0    	mov    0xf0f1f84c,%edx
f010b674:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b67a:	83 ec 04             	sub    $0x4,%esp
f010b67d:	52                   	push   %edx
f010b67e:	ff 75 88             	pushl  -0x78(%ebp)
f010b681:	50                   	push   %eax
f010b682:	e8 9e 8d ff ff       	call   f0104425 <pf_add_env_page>
f010b687:	83 c4 10             	add    $0x10,%esp
f010b68a:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b68d:	75 17                	jne    f010b6a6 <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b68f:	83 ec 04             	sub    $0x4,%esp
f010b692:	68 f8 66 12 f0       	push   $0xf01266f8
f010b697:	68 11 01 00 00       	push   $0x111
f010b69c:	68 db 66 12 f0       	push   $0xf01266db
f010b6a1:	e8 93 4c ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b6a6:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010b6ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6b0:	8b 50 04             	mov    0x4(%eax),%edx
f010b6b3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b6b6:	01 c2                	add    %eax,%edx
f010b6b8:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b6bb:	01 d0                	add    %edx,%eax
f010b6bd:	48                   	dec    %eax
f010b6be:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010b6c4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b6ca:	ba 00 00 00 00       	mov    $0x0,%edx
f010b6cf:	f7 75 80             	divl   -0x80(%ebp)
f010b6d2:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b6d8:	29 d0                	sub    %edx,%eax
f010b6da:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b6dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6e0:	8b 50 08             	mov    0x8(%eax),%edx
f010b6e3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b6e6:	01 d0                	add    %edx,%eax
f010b6e8:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010b6eb:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b6f1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010b6f8:	eb 41                	jmp    f010b73b <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b6fa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b700:	83 ec 04             	sub    $0x4,%esp
f010b703:	6a 01                	push   $0x1
f010b705:	ff 75 d8             	pushl  -0x28(%ebp)
f010b708:	50                   	push   %eax
f010b709:	e8 e6 8b ff ff       	call   f01042f4 <pf_add_empty_env_page>
f010b70e:	83 c4 10             	add    $0x10,%esp
f010b711:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b714:	75 17                	jne    f010b72d <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b716:	83 ec 04             	sub    $0x4,%esp
f010b719:	68 f8 66 12 f0       	push   $0xf01266f8
f010b71e:	68 1e 01 00 00       	push   $0x11e
f010b723:	68 db 66 12 f0       	push   $0xf01266db
f010b728:	e8 0c 4c ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b72d:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b734:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010b73b:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010b742:	10 00 00 
f010b745:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010b74b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b751:	01 d0                	add    %edx,%eax
f010b753:	48                   	dec    %eax
f010b754:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010b75a:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b760:	ba 00 00 00 00       	mov    $0x0,%edx
f010b765:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010b76b:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b771:	29 d0                	sub    %edx,%eax
f010b773:	89 c2                	mov    %eax,%edx
f010b775:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b778:	39 c2                	cmp    %eax,%edx
f010b77a:	0f 87 7a ff ff ff    	ja     f010b6fa <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b780:	83 ec 08             	sub    $0x8,%esp
f010b783:	ff 75 c8             	pushl  -0x38(%ebp)
f010b786:	ff 75 f4             	pushl  -0xc(%ebp)
f010b789:	e8 f5 15 00 00       	call   f010cd83 <PROGRAM_SEGMENT_NEXT>
f010b78e:	83 c4 10             	add    $0x10,%esp
f010b791:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b794:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b798:	0f 85 fc fc ff ff    	jne    f010b49a <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b79e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7a4:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b7aa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b7ad:	eb 77                	jmp    f010b826 <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010b7af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7b2:	8b 00                	mov    (%eax),%eax
f010b7b4:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b7ba:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7c0:	8b 40 64             	mov    0x64(%eax),%eax
f010b7c3:	83 ec 04             	sub    $0x4,%esp
f010b7c6:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010b7cc:	52                   	push   %edx
f010b7cd:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010b7d3:	50                   	push   %eax
f010b7d4:	e8 41 cf ff ff       	call   f010871a <get_page_table>
f010b7d9:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b7dc:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010b7e2:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010b7e8:	c1 ea 0c             	shr    $0xc,%edx
f010b7eb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b7f1:	c1 e2 02             	shl    $0x2,%edx
f010b7f4:	01 d0                	add    %edx,%eax
f010b7f6:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010b7fc:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010b802:	c1 e9 0c             	shr    $0xc,%ecx
f010b805:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b80b:	c1 e1 02             	shl    $0x2,%ecx
f010b80e:	01 ca                	add    %ecx,%edx
f010b810:	8b 12                	mov    (%edx),%edx
f010b812:	83 e2 bf             	and    $0xffffffbf,%edx
f010b815:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b817:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b81d:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b823:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b826:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b82c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b830:	74 08                	je     f010b83a <env_create+0x593>
f010b832:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b835:	8b 52 10             	mov    0x10(%edx),%edx
f010b838:	eb 05                	jmp    f010b83f <env_create+0x598>
f010b83a:	ba 00 00 00 00       	mov    $0x0,%edx
f010b83f:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010b845:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b84b:	85 c0                	test   %eax,%eax
f010b84d:	0f 85 5c ff ff ff    	jne    f010b7af <env_create+0x508>
f010b853:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b857:	0f 85 52 ff ff ff    	jne    f010b7af <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b85d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b860:	8b 50 08             	mov    0x8(%eax),%edx
f010b863:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b869:	83 ec 08             	sub    $0x8,%esp
f010b86c:	52                   	push   %edx
f010b86d:	50                   	push   %eax
f010b86e:	e8 d0 14 00 00       	call   f010cd43 <set_environment_entry_point>
f010b873:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b876:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b87c:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b883:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010b88a:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b88d:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b894:	e9 42 03 00 00       	jmp    f010bbdb <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b899:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010b8a0:	00 00 00 
			allocate_frame(&pp);
f010b8a3:	83 ec 0c             	sub    $0xc,%esp
f010b8a6:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010b8ac:	50                   	push   %eax
f010b8ad:	e8 2b cc ff ff       	call   f01084dd <allocate_frame>
f010b8b2:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b8b5:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010b8bb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8c1:	8b 40 64             	mov    0x64(%eax),%eax
f010b8c4:	6a 06                	push   $0x6
f010b8c6:	ff 75 d0             	pushl  -0x30(%ebp)
f010b8c9:	52                   	push   %edx
f010b8ca:	50                   	push   %eax
f010b8cb:	e8 de d2 ff ff       	call   f0108bae <loadtime_map_frame>
f010b8d0:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b8d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b8d6:	83 ec 04             	sub    $0x4,%esp
f010b8d9:	68 00 10 00 00       	push   $0x1000
f010b8de:	6a 00                	push   $0x0
f010b8e0:	50                   	push   %eax
f010b8e1:	e8 6a 48 01 00       	call   f0120150 <memset>
f010b8e6:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b8e9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8ef:	83 ec 08             	sub    $0x8,%esp
f010b8f2:	ff 75 d0             	pushl  -0x30(%ebp)
f010b8f5:	50                   	push   %eax
f010b8f6:	e8 e4 e8 ff ff       	call   f010a1df <env_page_ws_list_create_element>
f010b8fb:	83 c4 10             	add    $0x10,%esp
f010b8fe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b901:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b905:	75 17                	jne    f010b91e <env_create+0x677>
f010b907:	83 ec 04             	sub    $0x4,%esp
f010b90a:	68 40 67 12 f0       	push   $0xf0126740
f010b90f:	68 5d 01 00 00       	push   $0x15d
f010b914:	68 db 66 12 f0       	push   $0xf01266db
f010b919:	e8 1b 4a ff ff       	call   f0100339 <_panic>
f010b91e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b924:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b92a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b92d:	89 50 14             	mov    %edx,0x14(%eax)
f010b930:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b933:	8b 40 14             	mov    0x14(%eax),%eax
f010b936:	85 c0                	test   %eax,%eax
f010b938:	74 14                	je     f010b94e <env_create+0x6a7>
f010b93a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b940:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b946:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b949:	89 50 10             	mov    %edx,0x10(%eax)
f010b94c:	eb 0f                	jmp    f010b95d <env_create+0x6b6>
f010b94e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b954:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b957:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b95d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b963:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b966:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b96c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b96f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b976:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b97c:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b982:	42                   	inc    %edx
f010b983:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b989:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b98f:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b995:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b99b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b9a1:	39 c2                	cmp    %eax,%edx
f010b9a3:	75 1a                	jne    f010b9bf <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b9a5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9ab:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b9b1:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b9b7:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010b9bd:	eb 10                	jmp    f010b9cf <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b9bf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9c5:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010b9cc:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b9cf:	83 ec 0c             	sub    $0xc,%esp
f010b9d2:	6a 02                	push   $0x2
f010b9d4:	e8 88 3f 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010b9d9:	83 c4 10             	add    $0x10,%esp
f010b9dc:	85 c0                	test   %eax,%eax
f010b9de:	0f 84 d3 01 00 00    	je     f010bbb7 <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b9e4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b9e8:	75 17                	jne    f010ba01 <env_create+0x75a>
f010b9ea:	83 ec 04             	sub    $0x4,%esp
f010b9ed:	68 63 67 12 f0       	push   $0xf0126763
f010b9f2:	68 6a 01 00 00       	push   $0x16a
f010b9f7:	68 db 66 12 f0       	push   $0xf01266db
f010b9fc:	e8 38 49 ff ff       	call   f0100339 <_panic>
f010ba01:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba04:	8b 40 10             	mov    0x10(%eax),%eax
f010ba07:	85 c0                	test   %eax,%eax
f010ba09:	74 11                	je     f010ba1c <env_create+0x775>
f010ba0b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba0e:	8b 40 10             	mov    0x10(%eax),%eax
f010ba11:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba14:	8b 52 14             	mov    0x14(%edx),%edx
f010ba17:	89 50 14             	mov    %edx,0x14(%eax)
f010ba1a:	eb 12                	jmp    f010ba2e <env_create+0x787>
f010ba1c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba22:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba25:	8b 52 14             	mov    0x14(%edx),%edx
f010ba28:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010ba2e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba31:	8b 40 14             	mov    0x14(%eax),%eax
f010ba34:	85 c0                	test   %eax,%eax
f010ba36:	74 11                	je     f010ba49 <env_create+0x7a2>
f010ba38:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba3b:	8b 40 14             	mov    0x14(%eax),%eax
f010ba3e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba41:	8b 52 10             	mov    0x10(%edx),%edx
f010ba44:	89 50 10             	mov    %edx,0x10(%eax)
f010ba47:	eb 12                	jmp    f010ba5b <env_create+0x7b4>
f010ba49:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba4f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba52:	8b 52 10             	mov    0x10(%edx),%edx
f010ba55:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010ba5b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba5e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010ba65:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba68:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010ba6f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba75:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010ba7b:	4a                   	dec    %edx
f010ba7c:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010ba82:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba88:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010ba8e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba94:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010ba9a:	39 c2                	cmp    %eax,%edx
f010ba9c:	0f 83 8d 00 00 00    	jae    f010bb2f <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010baa2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010baa6:	75 17                	jne    f010babf <env_create+0x818>
f010baa8:	83 ec 04             	sub    $0x4,%esp
f010baab:	68 b8 66 12 f0       	push   $0xf01266b8
f010bab0:	68 6f 01 00 00       	push   $0x16f
f010bab5:	68 db 66 12 f0       	push   $0xf01266db
f010baba:	e8 7a 48 ff ff       	call   f0100339 <_panic>
f010babf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bac5:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010bacb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bace:	89 50 10             	mov    %edx,0x10(%eax)
f010bad1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bad4:	8b 40 10             	mov    0x10(%eax),%eax
f010bad7:	85 c0                	test   %eax,%eax
f010bad9:	74 14                	je     f010baef <env_create+0x848>
f010badb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bae1:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010bae7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010baea:	89 50 14             	mov    %edx,0x14(%eax)
f010baed:	eb 0f                	jmp    f010bafe <env_create+0x857>
f010baef:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010baf5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010baf8:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010bafe:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb04:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb07:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010bb0d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb10:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bb17:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb1d:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010bb23:	42                   	inc    %edx
f010bb24:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010bb2a:	e9 88 00 00 00       	jmp    f010bbb7 <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010bb2f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010bb33:	75 17                	jne    f010bb4c <env_create+0x8a5>
f010bb35:	83 ec 04             	sub    $0x4,%esp
f010bb38:	68 b8 66 12 f0       	push   $0xf01266b8
f010bb3d:	68 73 01 00 00       	push   $0x173
f010bb42:	68 db 66 12 f0       	push   $0xf01266db
f010bb47:	e8 ed 47 ff ff       	call   f0100339 <_panic>
f010bb4c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb52:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010bb58:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb5b:	89 50 10             	mov    %edx,0x10(%eax)
f010bb5e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb61:	8b 40 10             	mov    0x10(%eax),%eax
f010bb64:	85 c0                	test   %eax,%eax
f010bb66:	74 14                	je     f010bb7c <env_create+0x8d5>
f010bb68:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb6e:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010bb74:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb77:	89 50 14             	mov    %edx,0x14(%eax)
f010bb7a:	eb 0f                	jmp    f010bb8b <env_create+0x8e4>
f010bb7c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb82:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb85:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010bb8b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb91:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb94:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010bb9a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb9d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bba4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bbaa:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010bbb0:	42                   	inc    %edx
f010bbb1:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010bbb7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bbbd:	83 ec 04             	sub    $0x4,%esp
f010bbc0:	6a 01                	push   $0x1
f010bbc2:	ff 75 d0             	pushl  -0x30(%ebp)
f010bbc5:	50                   	push   %eax
f010bbc6:	e8 29 87 ff ff       	call   f01042f4 <pf_add_empty_env_page>
f010bbcb:	83 c4 10             	add    $0x10,%esp
f010bbce:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010bbd4:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010bbdb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bbde:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010bbe4:	0f 83 af fc ff ff    	jae    f010b899 <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010bbea:	83 ec 0c             	sub    $0xc,%esp
f010bbed:	6a 02                	push   $0x2
f010bbef:	e8 6d 3d 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010bbf4:	83 c4 10             	add    $0x10,%esp
f010bbf7:	85 c0                	test   %eax,%eax
f010bbf9:	74 72                	je     f010bc6d <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010bbfb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010bc02:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc08:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010bc0e:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010bc11:	eb 2b                	jmp    f010bc3e <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010bc13:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bc16:	8b 10                	mov    (%eax),%edx
f010bc18:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc1e:	8b 40 64             	mov    0x64(%eax),%eax
f010bc21:	6a 01                	push   $0x1
f010bc23:	6a 00                	push   $0x0
f010bc25:	52                   	push   %edx
f010bc26:	50                   	push   %eax
f010bc27:	e8 7d e3 ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010bc2c:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010bc2f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc35:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010bc3b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010bc3e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc44:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bc48:	74 08                	je     f010bc52 <env_create+0x9ab>
f010bc4a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bc4d:	8b 52 10             	mov    0x10(%edx),%edx
f010bc50:	eb 05                	jmp    f010bc57 <env_create+0x9b0>
f010bc52:	ba 00 00 00 00       	mov    $0x0,%edx
f010bc57:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010bc5d:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010bc63:	85 c0                	test   %eax,%eax
f010bc65:	75 ac                	jne    f010bc13 <env_create+0x96c>
f010bc67:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bc6b:	75 a6                	jne    f010bc13 <env_create+0x96c>
f010bc6d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010bc70:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010bc73:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010bc76:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010bc79:	e8 ce b8 ff ff       	call   f010754c <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010bc7e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010bc84:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010bc87:	5e                   	pop    %esi
f010bc88:	5f                   	pop    %edi
f010bc89:	5d                   	pop    %ebp
f010bc8a:	c3                   	ret    

f010bc8b <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010bc8b:	55                   	push   %ebp
f010bc8c:	89 e5                	mov    %esp,%ebp
f010bc8e:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010bc91:	83 ec 0c             	sub    $0xc,%esp
f010bc94:	68 80 f0 71 f0       	push   $0xf071f080
f010bc99:	e8 9d 43 00 00       	call   f011003b <release_spinlock>
f010bc9e:	83 c4 10             	add    $0x10,%esp

	if (first)
f010bca1:	a1 94 09 18 f0       	mov    0xf0180994,%eax
f010bca6:	85 c0                	test   %eax,%eax
f010bca8:	74 30                	je     f010bcda <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010bcaa:	e8 76 00 00 00       	call   f010bd25 <get_cpu_proc>
f010bcaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010bcb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bcb5:	8b 40 10             	mov    0x10(%eax),%eax
f010bcb8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bcbb:	83 c2 20             	add    $0x20,%edx
f010bcbe:	83 ec 04             	sub    $0x4,%esp
f010bcc1:	50                   	push   %eax
f010bcc2:	52                   	push   %edx
f010bcc3:	68 81 67 12 f0       	push   $0xf0126781
f010bcc8:	e8 be 52 ff ff       	call   f0100f8b <cprintf>
f010bccd:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010bcd0:	c7 05 94 09 18 f0 00 	movl   $0x0,0xf0180994
f010bcd7:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010bcda:	90                   	nop
f010bcdb:	c9                   	leave  
f010bcdc:	c3                   	ret    

f010bcdd <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010bcdd:	55                   	push   %ebp
f010bcde:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010bce0:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010bce1:	5d                   	pop    %ebp
f010bce2:	c3                   	ret    

f010bce3 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010bce3:	55                   	push   %ebp
f010bce4:	89 e5                	mov    %esp,%ebp
f010bce6:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010bce9:	e8 37 00 00 00       	call   f010bd25 <get_cpu_proc>
f010bcee:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010bcf1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bcf5:	75 19                	jne    f010bd10 <env_exit+0x2d>
f010bcf7:	68 97 67 12 f0       	push   $0xf0126797
f010bcfc:	68 a7 67 12 f0       	push   $0xf01267a7
f010bd01:	68 ed 01 00 00       	push   $0x1ed
f010bd06:	68 db 66 12 f0       	push   $0xf01266db
f010bd0b:	e8 29 46 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010bd10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd13:	8b 40 10             	mov    0x10(%eax),%eax
f010bd16:	83 ec 0c             	sub    $0xc,%esp
f010bd19:	50                   	push   %eax
f010bd1a:	e8 75 9d ff ff       	call   f0105a94 <sched_exit_env>
f010bd1f:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010bd22:	90                   	nop
f010bd23:	c9                   	leave  
f010bd24:	c3                   	ret    

f010bd25 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010bd25:	55                   	push   %ebp
f010bd26:	89 e5                	mov    %esp,%ebp
f010bd28:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010bd2b:	e8 ca b7 ff ff       	call   f01074fa <pushcli>
	c = mycpu();
f010bd30:	e8 02 b7 ff ff       	call   f0107437 <mycpu>
f010bd35:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010bd38:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd3b:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bd41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010bd44:	e8 03 b8 ff ff       	call   f010754c <popcli>
	return p;
f010bd49:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010bd4c:	c9                   	leave  
f010bd4d:	c3                   	ret    

f010bd4e <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010bd4e:	55                   	push   %ebp
f010bd4f:	89 e5                	mov    %esp,%ebp
f010bd51:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010bd54:	e8 a1 b7 ff ff       	call   f01074fa <pushcli>
	c = mycpu();
f010bd59:	e8 d9 b6 ff ff       	call   f0107437 <mycpu>
f010bd5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010bd61:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd64:	8b 55 08             	mov    0x8(%ebp),%edx
f010bd67:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010bd6d:	e8 da b7 ff ff       	call   f010754c <popcli>
}
f010bd72:	90                   	nop
f010bd73:	c9                   	leave  
f010bd74:	c3                   	ret    

f010bd75 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010bd75:	55                   	push   %ebp
f010bd76:	89 e5                	mov    %esp,%ebp
f010bd78:	53                   	push   %ebx
f010bd79:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010bd7c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bd80:	75 16                	jne    f010bd98 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010bd82:	e8 9e ff ff ff       	call   f010bd25 <get_cpu_proc>
f010bd87:	89 c2                	mov    %eax,%edx
f010bd89:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd8c:	89 10                	mov    %edx,(%eax)
		return 0;
f010bd8e:	b8 00 00 00 00       	mov    $0x0,%eax
f010bd93:	e9 aa 00 00 00       	jmp    f010be42 <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010bd98:	8b 1d 90 65 6f f0    	mov    0xf06f6590,%ebx
f010bd9e:	83 ec 0c             	sub    $0xc,%esp
f010bda1:	68 ca 02 00 00       	push   $0x2ca
f010bda6:	e8 15 27 01 00       	call   f011e4c0 <nearest_pow2_ceil>
f010bdab:	83 c4 10             	add    $0x10,%esp
f010bdae:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bdb1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bdb4:	21 c2                	and    %eax,%edx
f010bdb6:	89 d0                	mov    %edx,%eax
f010bdb8:	c1 e0 03             	shl    $0x3,%eax
f010bdbb:	01 d0                	add    %edx,%eax
f010bdbd:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010bdc4:	01 c8                	add    %ecx,%eax
f010bdc6:	01 c0                	add    %eax,%eax
f010bdc8:	01 d0                	add    %edx,%eax
f010bdca:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010bdd1:	01 c8                	add    %ecx,%eax
f010bdd3:	01 d0                	add    %edx,%eax
f010bdd5:	01 d8                	add    %ebx,%eax
f010bdd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010bdda:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bddd:	8b 40 18             	mov    0x18(%eax),%eax
f010bde0:	85 c0                	test   %eax,%eax
f010bde2:	74 0b                	je     f010bdef <envid2env+0x7a>
f010bde4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bde7:	8b 40 10             	mov    0x10(%eax),%eax
f010bdea:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bded:	74 10                	je     f010bdff <envid2env+0x8a>
		*env_store = 0;
f010bdef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bdf2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bdf8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bdfd:	eb 43                	jmp    f010be42 <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010bdff:	e8 21 ff ff ff       	call   f010bd25 <get_cpu_proc>
f010be04:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010be07:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010be0b:	74 28                	je     f010be35 <envid2env+0xc0>
f010be0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be10:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010be13:	74 20                	je     f010be35 <envid2env+0xc0>
f010be15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be18:	8b 50 14             	mov    0x14(%eax),%edx
f010be1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010be1e:	8b 40 10             	mov    0x10(%eax),%eax
f010be21:	39 c2                	cmp    %eax,%edx
f010be23:	74 10                	je     f010be35 <envid2env+0xc0>
		*env_store = 0;
f010be25:	8b 45 0c             	mov    0xc(%ebp),%eax
f010be28:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010be2e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010be33:	eb 0d                	jmp    f010be42 <envid2env+0xcd>
	}

	*env_store = e;
f010be35:	8b 45 0c             	mov    0xc(%ebp),%eax
f010be38:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be3b:	89 10                	mov    %edx,(%eax)
	return 0;
f010be3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010be42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010be45:	c9                   	leave  
f010be46:	c3                   	ret    

f010be47 <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010be47:	55                   	push   %ebp
f010be48:	89 e5                	mov    %esp,%ebp
f010be4a:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010be4d:	83 ec 0c             	sub    $0xc,%esp
f010be50:	68 80 f0 71 f0       	push   $0xf071f080
f010be55:	e8 5a 41 00 00       	call   f010ffb4 <acquire_spinlock>
f010be5a:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010be5d:	e8 c3 fe ff ff       	call   f010bd25 <get_cpu_proc>
f010be62:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010be65:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be69:	75 19                	jne    f010be84 <yield+0x3d>
f010be6b:	68 bc 67 12 f0       	push   $0xf01267bc
f010be70:	68 a7 67 12 f0       	push   $0xf01267a7
f010be75:	68 4c 02 00 00       	push   $0x24c
f010be7a:	68 db 66 12 f0       	push   $0xf01266db
f010be7f:	e8 b5 44 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010be84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be87:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010be8e:	e8 13 00 00 00       	call   f010bea6 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010be93:	83 ec 0c             	sub    $0xc,%esp
f010be96:	68 80 f0 71 f0       	push   $0xf071f080
f010be9b:	e8 9b 41 00 00       	call   f011003b <release_spinlock>
f010bea0:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bea3:	90                   	nop
f010bea4:	c9                   	leave  
f010bea5:	c3                   	ret    

f010bea6 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bea6:	55                   	push   %ebp
f010bea7:	89 e5                	mov    %esp,%ebp
f010bea9:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010beac:	e8 74 fe ff ff       	call   f010bd25 <get_cpu_proc>
f010beb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010beb4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010beb8:	75 19                	jne    f010bed3 <sched+0x2d>
f010beba:	68 bc 67 12 f0       	push   $0xf01267bc
f010bebf:	68 a7 67 12 f0       	push   $0xf01267a7
f010bec4:	68 60 02 00 00       	push   $0x260
f010bec9:	68 db 66 12 f0       	push   $0xf01266db
f010bece:	e8 66 44 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010bed3:	83 ec 0c             	sub    $0xc,%esp
f010bed6:	68 80 f0 71 f0       	push   $0xf071f080
f010bedb:	e8 ed 42 00 00       	call   f01101cd <holding_spinlock>
f010bee0:	83 c4 10             	add    $0x10,%esp
f010bee3:	85 c0                	test   %eax,%eax
f010bee5:	75 17                	jne    f010befe <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010bee7:	83 ec 04             	sub    $0x4,%esp
f010beea:	68 c8 67 12 f0       	push   $0xf01267c8
f010beef:	68 64 02 00 00       	push   $0x264
f010bef4:	68 db 66 12 f0       	push   $0xf01266db
f010bef9:	e8 3b 44 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010befe:	e8 34 b5 ff ff       	call   f0107437 <mycpu>
f010bf03:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bf09:	83 f8 01             	cmp    $0x1,%eax
f010bf0c:	74 20                	je     f010bf2e <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010bf0e:	e8 24 b5 ff ff       	call   f0107437 <mycpu>
f010bf13:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bf19:	50                   	push   %eax
f010bf1a:	68 0a 68 12 f0       	push   $0xf012680a
f010bf1f:	68 67 02 00 00       	push   $0x267
f010bf24:	68 db 66 12 f0       	push   $0xf01266db
f010bf29:	e8 0b 44 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010bf2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf31:	8b 40 18             	mov    0x18(%eax),%eax
f010bf34:	83 f8 02             	cmp    $0x2,%eax
f010bf37:	75 17                	jne    f010bf50 <sched+0xaa>
		panic("sched a running process");
f010bf39:	83 ec 04             	sub    $0x4,%esp
f010bf3c:	68 21 68 12 f0       	push   $0xf0126821
f010bf41:	68 6a 02 00 00       	push   $0x26a
f010bf46:	68 db 66 12 f0       	push   $0xf01266db
f010bf4b:	e8 e9 43 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010bf50:	9c                   	pushf  
f010bf51:	58                   	pop    %eax
f010bf52:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bf55:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bf58:	25 00 02 00 00       	and    $0x200,%eax
f010bf5d:	85 c0                	test   %eax,%eax
f010bf5f:	74 17                	je     f010bf78 <sched+0xd2>
		panic("sched is interruptible!");
f010bf61:	83 ec 04             	sub    $0x4,%esp
f010bf64:	68 39 68 12 f0       	push   $0xf0126839
f010bf69:	68 6c 02 00 00       	push   $0x26c
f010bf6e:	68 db 66 12 f0       	push   $0xf01266db
f010bf73:	e8 c1 43 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010bf78:	e8 ba b4 ff ff       	call   f0107437 <mycpu>
f010bf7d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bf83:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bf86:	e8 ac b4 ff ff       	call   f0107437 <mycpu>
f010bf8b:	8b 40 04             	mov    0x4(%eax),%eax
f010bf8e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf91:	83 c2 04             	add    $0x4,%edx
f010bf94:	83 ec 08             	sub    $0x8,%esp
f010bf97:	50                   	push   %eax
f010bf98:	52                   	push   %edx
f010bf99:	e8 c1 8d ff ff       	call   f0104d5f <context_switch>
f010bf9e:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010bfa1:	e8 91 b4 ff ff       	call   f0107437 <mycpu>
f010bfa6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bfa9:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010bfaf:	90                   	nop
f010bfb0:	c9                   	leave  
f010bfb1:	c3                   	ret    

f010bfb2 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010bfb2:	55                   	push   %ebp
f010bfb3:	89 e5                	mov    %esp,%ebp
f010bfb5:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bfb8:	a1 e4 f8 f1 f0       	mov    0xf0f1f8e4,%eax
f010bfbd:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bfc0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bfc3:	0f 22 d8             	mov    %eax,%cr3
}
f010bfc6:	90                   	nop
f010bfc7:	c9                   	leave  
f010bfc8:	c3                   	ret    

f010bfc9 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bfc9:	55                   	push   %ebp
f010bfca:	89 e5                	mov    %esp,%ebp
f010bfcc:	53                   	push   %ebx
f010bfcd:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bfd0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bfd4:	75 17                	jne    f010bfed <switchuvm+0x24>
		panic("switchuvm: no process");
f010bfd6:	83 ec 04             	sub    $0x4,%esp
f010bfd9:	68 51 68 12 f0       	push   $0xf0126851
f010bfde:	68 81 02 00 00       	push   $0x281
f010bfe3:	68 db 66 12 f0       	push   $0xf01266db
f010bfe8:	e8 4c 43 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010bfed:	8b 45 08             	mov    0x8(%ebp),%eax
f010bff0:	8b 40 70             	mov    0x70(%eax),%eax
f010bff3:	85 c0                	test   %eax,%eax
f010bff5:	75 17                	jne    f010c00e <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bff7:	83 ec 04             	sub    $0x4,%esp
f010bffa:	68 67 68 12 f0       	push   $0xf0126867
f010bfff:	68 83 02 00 00       	push   $0x283
f010c004:	68 db 66 12 f0       	push   $0xf01266db
f010c009:	e8 2b 43 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010c00e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c011:	8b 40 64             	mov    0x64(%eax),%eax
f010c014:	85 c0                	test   %eax,%eax
f010c016:	75 17                	jne    f010c02f <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010c018:	83 ec 04             	sub    $0x4,%esp
f010c01b:	68 7c 68 12 f0       	push   $0xf012687c
f010c020:	68 85 02 00 00       	push   $0x285
f010c025:	68 db 66 12 f0       	push   $0xf01266db
f010c02a:	e8 0a 43 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010c02f:	e8 c6 b4 ff ff       	call   f01074fa <pushcli>
	struct cpu* c = mycpu();
f010c034:	e8 fe b3 ff ff       	call   f0107437 <mycpu>
f010c039:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010c03c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c03f:	8b 55 08             	mov    0x8(%ebp),%edx
f010c042:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c048:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c04b:	83 c0 0c             	add    $0xc,%eax
f010c04e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c051:	83 c2 0c             	add    $0xc,%edx
f010c054:	c1 ea 10             	shr    $0x10,%edx
f010c057:	88 d3                	mov    %dl,%bl
f010c059:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c05c:	83 c2 0c             	add    $0xc,%edx
f010c05f:	c1 ea 18             	shr    $0x18,%edx
f010c062:	88 d1                	mov    %dl,%cl
f010c064:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c067:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c06e:	68 00 
f010c070:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c073:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c07a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c07d:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c083:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c086:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c08c:	83 e2 f0             	and    $0xfffffff0,%edx
f010c08f:	83 ca 09             	or     $0x9,%edx
f010c092:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c098:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c09b:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0a1:	83 ca 10             	or     $0x10,%edx
f010c0a4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c0aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0ad:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0b3:	83 e2 9f             	and    $0xffffff9f,%edx
f010c0b6:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c0bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0bf:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0c5:	83 ca 80             	or     $0xffffff80,%edx
f010c0c8:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c0ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0d1:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c0d7:	83 e2 f0             	and    $0xfffffff0,%edx
f010c0da:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c0e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0e3:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c0e9:	83 e2 ef             	and    $0xffffffef,%edx
f010c0ec:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c0f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0f5:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c0fb:	83 e2 df             	and    $0xffffffdf,%edx
f010c0fe:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c104:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c107:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c10d:	83 ca 40             	or     $0x40,%edx
f010c110:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c116:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c119:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c11f:	83 e2 7f             	and    $0x7f,%edx
f010c122:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c128:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c12b:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010c131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c134:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c13a:	83 e2 ef             	and    $0xffffffef,%edx
f010c13d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010c143:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c146:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010c14c:	8b 40 70             	mov    0x70(%eax),%eax
f010c14f:	05 00 80 00 00       	add    $0x8000,%eax
f010c154:	89 c2                	mov    %eax,%edx
f010c156:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c159:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c15c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c15f:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010c165:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010c16b:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010c16f:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010c172:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c175:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010c17b:	8b 40 68             	mov    0x68(%eax),%eax
f010c17e:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010c181:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c184:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010c187:	e8 c0 b3 ff ff       	call   f010754c <popcli>
}
f010c18c:	90                   	nop
f010c18d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c190:	c9                   	leave  
f010c191:	c3                   	ret    

f010c192 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010c192:	55                   	push   %ebp
f010c193:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010c195:	8b 15 94 65 6f f0    	mov    0xf06f6594,%edx
f010c19b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c19e:	89 10                	mov    %edx,(%eax)
f010c1a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1a3:	8b 00                	mov    (%eax),%eax
f010c1a5:	85 c0                	test   %eax,%eax
f010c1a7:	75 07                	jne    f010c1b0 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010c1a9:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010c1ae:	eb 11                	jmp    f010c1c1 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010c1b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1b3:	8b 00                	mov    (%eax),%eax
f010c1b5:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010c1bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c1c1:	5d                   	pop    %ebp
f010c1c2:	c3                   	ret    

f010c1c3 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010c1c3:	55                   	push   %ebp
f010c1c4:	89 e5                	mov    %esp,%ebp
f010c1c6:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010c1c9:	83 ec 04             	sub    $0x4,%esp
f010c1cc:	68 bc 05 00 00       	push   $0x5bc
f010c1d1:	6a 00                	push   $0x0
f010c1d3:	ff 75 08             	pushl  0x8(%ebp)
f010c1d6:	e8 75 3f 01 00       	call   f0120150 <memset>
f010c1db:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010c1de:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1e1:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010c1e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c1ec:	75 17                	jne    f010c205 <free_environment+0x42>
f010c1ee:	83 ec 04             	sub    $0x4,%esp
f010c1f1:	68 b8 66 12 f0       	push   $0xf01266b8
f010c1f6:	68 c0 02 00 00       	push   $0x2c0
f010c1fb:	68 db 66 12 f0       	push   $0xf01266db
f010c200:	e8 34 41 ff ff       	call   f0100339 <_panic>
f010c205:	8b 15 94 65 6f f0    	mov    0xf06f6594,%edx
f010c20b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c20e:	89 50 08             	mov    %edx,0x8(%eax)
f010c211:	8b 45 08             	mov    0x8(%ebp),%eax
f010c214:	8b 40 08             	mov    0x8(%eax),%eax
f010c217:	85 c0                	test   %eax,%eax
f010c219:	74 0d                	je     f010c228 <free_environment+0x65>
f010c21b:	a1 94 65 6f f0       	mov    0xf06f6594,%eax
f010c220:	8b 55 08             	mov    0x8(%ebp),%edx
f010c223:	89 50 0c             	mov    %edx,0xc(%eax)
f010c226:	eb 08                	jmp    f010c230 <free_environment+0x6d>
f010c228:	8b 45 08             	mov    0x8(%ebp),%eax
f010c22b:	a3 98 65 6f f0       	mov    %eax,0xf06f6598
f010c230:	8b 45 08             	mov    0x8(%ebp),%eax
f010c233:	a3 94 65 6f f0       	mov    %eax,0xf06f6594
f010c238:	8b 45 08             	mov    0x8(%ebp),%eax
f010c23b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c242:	a1 a0 65 6f f0       	mov    0xf06f65a0,%eax
f010c247:	40                   	inc    %eax
f010c248:	a3 a0 65 6f f0       	mov    %eax,0xf06f65a0
}
f010c24d:	90                   	nop
f010c24e:	c9                   	leave  
f010c24f:	c3                   	ret    

f010c250 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010c250:	55                   	push   %ebp
f010c251:	89 e5                	mov    %esp,%ebp
f010c253:	53                   	push   %ebx
f010c254:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010c257:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c25a:	8b 40 0c             	mov    0xc(%eax),%eax
f010c25d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010c260:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c263:	8b 40 08             	mov    0x8(%eax),%eax
f010c266:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010c269:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010c270:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010c273:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c276:	01 c2                	add    %eax,%edx
f010c278:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c27b:	01 d0                	add    %edx,%eax
f010c27d:	48                   	dec    %eax
f010c27e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010c281:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c284:	ba 00 00 00 00       	mov    $0x0,%edx
f010c289:	f7 75 dc             	divl   -0x24(%ebp)
f010c28c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c28f:	29 d0                	sub    %edx,%eax
f010c291:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010c294:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c297:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010c29a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c29d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c2a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010c2a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010c2ac:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010c2b3:	8b 45 10             	mov    0x10(%ebp),%eax
f010c2b6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010c2bc:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010c2c3:	0f 85 f5 03 00 00    	jne    f010c6be <program_segment_alloc_map_copy_workingset+0x46e>
f010c2c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2cc:	83 c0 20             	add    $0x20,%eax
f010c2cf:	83 ec 08             	sub    $0x8,%esp
f010c2d2:	68 90 68 12 f0       	push   $0xf0126890
f010c2d7:	50                   	push   %eax
f010c2d8:	e8 91 3d 01 00       	call   f012006e <strcmp>
f010c2dd:	83 c4 10             	add    $0x10,%esp
f010c2e0:	85 c0                	test   %eax,%eax
f010c2e2:	0f 84 d6 03 00 00    	je     f010c6be <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010c2e8:	8b 45 14             	mov    0x14(%ebp),%eax
f010c2eb:	83 f8 06             	cmp    $0x6,%eax
f010c2ee:	76 05                	jbe    f010c2f5 <program_segment_alloc_map_copy_workingset+0xa5>
f010c2f0:	b8 06 00 00 00       	mov    $0x6,%eax
f010c2f5:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c2f8:	e9 c1 03 00 00       	jmp    f010c6be <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010c2fd:	83 ec 0c             	sub    $0xc,%esp
f010c300:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010c303:	50                   	push   %eax
f010c304:	e8 d4 c1 ff ff       	call   f01084dd <allocate_frame>
f010c309:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010c30c:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010c30f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c312:	8b 40 64             	mov    0x64(%eax),%eax
f010c315:	6a 06                	push   $0x6
f010c317:	ff 75 f4             	pushl  -0xc(%ebp)
f010c31a:	52                   	push   %edx
f010c31b:	50                   	push   %eax
f010c31c:	e8 8d c8 ff ff       	call   f0108bae <loadtime_map_frame>
f010c321:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010c324:	83 ec 08             	sub    $0x8,%esp
f010c327:	ff 75 f4             	pushl  -0xc(%ebp)
f010c32a:	ff 75 08             	pushl  0x8(%ebp)
f010c32d:	e8 ad de ff ff       	call   f010a1df <env_page_ws_list_create_element>
f010c332:	83 c4 10             	add    $0x10,%esp
f010c335:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010c338:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c33b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010c342:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c346:	75 17                	jne    f010c35f <program_segment_alloc_map_copy_workingset+0x10f>
f010c348:	83 ec 04             	sub    $0x4,%esp
f010c34b:	68 40 67 12 f0       	push   $0xf0126740
f010c350:	68 ea 02 00 00       	push   $0x2ea
f010c355:	68 db 66 12 f0       	push   $0xf01266db
f010c35a:	e8 da 3f ff ff       	call   f0100339 <_panic>
f010c35f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c362:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010c368:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c36b:	89 50 14             	mov    %edx,0x14(%eax)
f010c36e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c371:	8b 40 14             	mov    0x14(%eax),%eax
f010c374:	85 c0                	test   %eax,%eax
f010c376:	74 11                	je     f010c389 <program_segment_alloc_map_copy_workingset+0x139>
f010c378:	8b 45 08             	mov    0x8(%ebp),%eax
f010c37b:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010c381:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c384:	89 50 10             	mov    %edx,0x10(%eax)
f010c387:	eb 0c                	jmp    f010c395 <program_segment_alloc_map_copy_workingset+0x145>
f010c389:	8b 45 08             	mov    0x8(%ebp),%eax
f010c38c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c38f:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c395:	8b 45 08             	mov    0x8(%ebp),%eax
f010c398:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c39b:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c3a1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c3a4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c3ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3ae:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c3b4:	8d 50 01             	lea    0x1(%eax),%edx
f010c3b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3ba:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c3c0:	83 ec 0c             	sub    $0xc,%esp
f010c3c3:	6a 02                	push   $0x2
f010c3c5:	e8 97 35 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010c3ca:	83 c4 10             	add    $0x10,%esp
f010c3cd:	85 c0                	test   %eax,%eax
f010c3cf:	0f 84 b3 01 00 00    	je     f010c588 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c3d5:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c3d9:	75 17                	jne    f010c3f2 <program_segment_alloc_map_copy_workingset+0x1a2>
f010c3db:	83 ec 04             	sub    $0x4,%esp
f010c3de:	68 63 67 12 f0       	push   $0xf0126763
f010c3e3:	68 f6 02 00 00       	push   $0x2f6
f010c3e8:	68 db 66 12 f0       	push   $0xf01266db
f010c3ed:	e8 47 3f ff ff       	call   f0100339 <_panic>
f010c3f2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c3f5:	8b 40 10             	mov    0x10(%eax),%eax
f010c3f8:	85 c0                	test   %eax,%eax
f010c3fa:	74 11                	je     f010c40d <program_segment_alloc_map_copy_workingset+0x1bd>
f010c3fc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c3ff:	8b 40 10             	mov    0x10(%eax),%eax
f010c402:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c405:	8b 52 14             	mov    0x14(%edx),%edx
f010c408:	89 50 14             	mov    %edx,0x14(%eax)
f010c40b:	eb 0f                	jmp    f010c41c <program_segment_alloc_map_copy_workingset+0x1cc>
f010c40d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c410:	8b 50 14             	mov    0x14(%eax),%edx
f010c413:	8b 45 08             	mov    0x8(%ebp),%eax
f010c416:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c41c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c41f:	8b 40 14             	mov    0x14(%eax),%eax
f010c422:	85 c0                	test   %eax,%eax
f010c424:	74 11                	je     f010c437 <program_segment_alloc_map_copy_workingset+0x1e7>
f010c426:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c429:	8b 40 14             	mov    0x14(%eax),%eax
f010c42c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c42f:	8b 52 10             	mov    0x10(%edx),%edx
f010c432:	89 50 10             	mov    %edx,0x10(%eax)
f010c435:	eb 0f                	jmp    f010c446 <program_segment_alloc_map_copy_workingset+0x1f6>
f010c437:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c43a:	8b 50 10             	mov    0x10(%eax),%edx
f010c43d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c440:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c446:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c449:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c450:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c453:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c45a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c45d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c463:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c466:	8b 45 08             	mov    0x8(%ebp),%eax
f010c469:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c46f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c472:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010c478:	8b 45 08             	mov    0x8(%ebp),%eax
f010c47b:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010c481:	48                   	dec    %eax
f010c482:	39 c2                	cmp    %eax,%edx
f010c484:	0f 83 80 00 00 00    	jae    f010c50a <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c48a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c48e:	75 17                	jne    f010c4a7 <program_segment_alloc_map_copy_workingset+0x257>
f010c490:	83 ec 04             	sub    $0x4,%esp
f010c493:	68 b8 66 12 f0       	push   $0xf01266b8
f010c498:	68 fa 02 00 00       	push   $0x2fa
f010c49d:	68 db 66 12 f0       	push   $0xf01266db
f010c4a2:	e8 92 3e ff ff       	call   f0100339 <_panic>
f010c4a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4aa:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c4b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c4b3:	89 50 10             	mov    %edx,0x10(%eax)
f010c4b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c4b9:	8b 40 10             	mov    0x10(%eax),%eax
f010c4bc:	85 c0                	test   %eax,%eax
f010c4be:	74 11                	je     f010c4d1 <program_segment_alloc_map_copy_workingset+0x281>
f010c4c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4c3:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c4c9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c4cc:	89 50 14             	mov    %edx,0x14(%eax)
f010c4cf:	eb 0c                	jmp    f010c4dd <program_segment_alloc_map_copy_workingset+0x28d>
f010c4d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4d4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c4d7:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010c4dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4e0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c4e3:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010c4e9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c4ec:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c4f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4f6:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010c4fc:	8d 50 01             	lea    0x1(%eax),%edx
f010c4ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010c502:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c508:	eb 7e                	jmp    f010c588 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c50a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c50e:	75 17                	jne    f010c527 <program_segment_alloc_map_copy_workingset+0x2d7>
f010c510:	83 ec 04             	sub    $0x4,%esp
f010c513:	68 b8 66 12 f0       	push   $0xf01266b8
f010c518:	68 ff 02 00 00       	push   $0x2ff
f010c51d:	68 db 66 12 f0       	push   $0xf01266db
f010c522:	e8 12 3e ff ff       	call   f0100339 <_panic>
f010c527:	8b 45 08             	mov    0x8(%ebp),%eax
f010c52a:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010c530:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c533:	89 50 10             	mov    %edx,0x10(%eax)
f010c536:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c539:	8b 40 10             	mov    0x10(%eax),%eax
f010c53c:	85 c0                	test   %eax,%eax
f010c53e:	74 11                	je     f010c551 <program_segment_alloc_map_copy_workingset+0x301>
f010c540:	8b 45 08             	mov    0x8(%ebp),%eax
f010c543:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010c549:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c54c:	89 50 14             	mov    %edx,0x14(%eax)
f010c54f:	eb 0c                	jmp    f010c55d <program_segment_alloc_map_copy_workingset+0x30d>
f010c551:	8b 45 08             	mov    0x8(%ebp),%eax
f010c554:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c557:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c55d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c560:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c563:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010c569:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c56c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c573:	8b 45 08             	mov    0x8(%ebp),%eax
f010c576:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010c57c:	8d 50 01             	lea    0x1(%eax),%edx
f010c57f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c582:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c588:	8b 45 08             	mov    0x8(%ebp),%eax
f010c58b:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010c591:	8b 45 08             	mov    0x8(%ebp),%eax
f010c594:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c59a:	39 c2                	cmp    %eax,%edx
f010c59c:	75 14                	jne    f010c5b2 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c59e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5a1:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c5a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5aa:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010c5b0:	eb 0d                	jmp    f010c5bf <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c5b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5b5:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010c5bc:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c5bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5c2:	c1 e8 16             	shr    $0x16,%eax
f010c5c5:	89 c2                	mov    %eax,%edx
f010c5c7:	8b 45 18             	mov    0x18(%ebp),%eax
f010c5ca:	8b 00                	mov    (%eax),%eax
f010c5cc:	39 c2                	cmp    %eax,%edx
f010c5ce:	0f 84 d3 00 00 00    	je     f010c6a7 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c5d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5d7:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c5dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5e0:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c5e3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c5e6:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c5eb:	89 c1                	mov    %eax,%ecx
f010c5ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c5f0:	89 d0                	mov    %edx,%eax
f010c5f2:	01 c0                	add    %eax,%eax
f010c5f4:	01 d0                	add    %edx,%eax
f010c5f6:	c1 e0 03             	shl    $0x3,%eax
f010c5f9:	01 d8                	add    %ebx,%eax
f010c5fb:	05 ac 00 00 00       	add    $0xac,%eax
f010c600:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c602:	8b 45 08             	mov    0x8(%ebp),%eax
f010c605:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c60b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c60e:	89 d0                	mov    %edx,%eax
f010c610:	01 c0                	add    %eax,%eax
f010c612:	01 d0                	add    %edx,%eax
f010c614:	c1 e0 03             	shl    $0x3,%eax
f010c617:	01 c8                	add    %ecx,%eax
f010c619:	05 b0 00 00 00       	add    $0xb0,%eax
f010c61e:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c621:	8b 45 08             	mov    0x8(%ebp),%eax
f010c624:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c62a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c62d:	89 d0                	mov    %edx,%eax
f010c62f:	01 c0                	add    %eax,%eax
f010c631:	01 d0                	add    %edx,%eax
f010c633:	c1 e0 03             	shl    $0x3,%eax
f010c636:	01 c8                	add    %ecx,%eax
f010c638:	05 b4 00 00 00       	add    $0xb4,%eax
f010c63d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c643:	8b 45 08             	mov    0x8(%ebp),%eax
f010c646:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c64c:	8d 50 01             	lea    0x1(%eax),%edx
f010c64f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c652:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c658:	8b 45 08             	mov    0x8(%ebp),%eax
f010c65b:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c661:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c666:	ba 00 00 00 00       	mov    $0x0,%edx
f010c66b:	f7 f1                	div    %ecx
f010c66d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c670:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010c676:	8b 45 08             	mov    0x8(%ebp),%eax
f010c679:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c67f:	85 c0                	test   %eax,%eax
f010c681:	75 17                	jne    f010c69a <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c683:	83 ec 04             	sub    $0x4,%esp
f010c686:	68 94 68 12 f0       	push   $0xf0126894
f010c68b:	68 27 03 00 00       	push   $0x327
f010c690:	68 db 66 12 f0       	push   $0xf01266db
f010c695:	e8 9f 3c ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c69a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c69d:	c1 e8 16             	shr    $0x16,%eax
f010c6a0:	89 c2                	mov    %eax,%edx
f010c6a2:	8b 45 18             	mov    0x18(%ebp),%eax
f010c6a5:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c6a7:	8b 45 10             	mov    0x10(%ebp),%eax
f010c6aa:	8b 00                	mov    (%eax),%eax
f010c6ac:	8d 50 01             	lea    0x1(%eax),%edx
f010c6af:	8b 45 10             	mov    0x10(%ebp),%eax
f010c6b2:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c6b4:	ff 45 f0             	incl   -0x10(%ebp)
f010c6b7:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c6be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6c1:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c6c4:	73 0c                	jae    f010c6d2 <program_segment_alloc_map_copy_workingset+0x482>
f010c6c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c6c9:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c6cc:	0f 82 2b fc ff ff    	jb     f010c2fd <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c6d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c6d5:	8b 00                	mov    (%eax),%eax
f010c6d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c6da:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c6dd:	8b 40 0c             	mov    0xc(%eax),%eax
f010c6e0:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c6e3:	eb 10                	jmp    f010c6f5 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c6e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c6e8:	8a 10                	mov    (%eax),%dl
f010c6ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c6ed:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c6ef:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c6f2:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c6f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c6f8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c6fb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c6fe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c703:	89 c2                	mov    %eax,%edx
f010c705:	8b 45 10             	mov    0x10(%ebp),%eax
f010c708:	8b 00                	mov    (%eax),%eax
f010c70a:	c1 e0 0c             	shl    $0xc,%eax
f010c70d:	01 c2                	add    %eax,%edx
f010c70f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c712:	39 c2                	cmp    %eax,%edx
f010c714:	76 1d                	jbe    f010c733 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c716:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c719:	8b 50 04             	mov    0x4(%eax),%edx
f010c71c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c71f:	01 c2                	add    %eax,%edx
f010c721:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c724:	39 c2                	cmp    %eax,%edx
f010c726:	77 bd                	ja     f010c6e5 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c728:	eb 09                	jmp    f010c733 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c72a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c72d:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c730:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c733:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c736:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c739:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c73c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c741:	89 c2                	mov    %eax,%edx
f010c743:	8b 45 10             	mov    0x10(%ebp),%eax
f010c746:	8b 00                	mov    (%eax),%eax
f010c748:	c1 e0 0c             	shl    $0xc,%eax
f010c74b:	01 c2                	add    %eax,%edx
f010c74d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c750:	39 c2                	cmp    %eax,%edx
f010c752:	77 d6                	ja     f010c72a <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c754:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c759:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c75c:	c9                   	leave  
f010c75d:	c3                   	ret    

f010c75e <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c75e:	55                   	push   %ebp
f010c75f:	89 e5                	mov    %esp,%ebp
f010c761:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c764:	83 ec 0c             	sub    $0xc,%esp
f010c767:	68 00 10 00 00       	push   $0x1000
f010c76c:	e8 5e d0 ff ff       	call   f01097cf <kmalloc>
f010c771:	83 c4 10             	add    $0x10,%esp
f010c774:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c777:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c77b:	75 17                	jne    f010c794 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c77d:	83 ec 04             	sub    $0x4,%esp
f010c780:	68 37 69 12 f0       	push   $0xf0126937
f010c785:	68 57 03 00 00       	push   $0x357
f010c78a:	68 db 66 12 f0       	push   $0xf01266db
f010c78f:	e8 a5 3b ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010c794:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c797:	c9                   	leave  
f010c798:	c3                   	ret    

f010c799 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c799:	55                   	push   %ebp
f010c79a:	89 e5                	mov    %esp,%ebp
f010c79c:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010c79f:	83 ec 0c             	sub    $0xc,%esp
f010c7a2:	68 00 80 00 00       	push   $0x8000
f010c7a7:	e8 23 d0 ff ff       	call   f01097cf <kmalloc>
f010c7ac:	83 c4 10             	add    $0x10,%esp
f010c7af:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010c7b2:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010c7b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c7bc:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010c7c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010c7c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c7c7:	ba 00 00 00 00       	mov    $0x0,%edx
f010c7cc:	f7 75 ec             	divl   -0x14(%ebp)
f010c7cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c7d2:	29 d0                	sub    %edx,%eax
f010c7d4:	85 c0                	test   %eax,%eax
f010c7d6:	79 05                	jns    f010c7dd <create_user_kern_stack+0x44>
f010c7d8:	05 ff 0f 00 00       	add    $0xfff,%eax
f010c7dd:	c1 f8 0c             	sar    $0xc,%eax
f010c7e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010c7e3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010c7ea:	eb 72                	jmp    f010c85e <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010c7ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010c7f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c7f6:	c1 e0 0c             	shl    $0xc,%eax
f010c7f9:	89 c2                	mov    %eax,%edx
f010c7fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c7fe:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010c801:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f010c806:	83 ec 04             	sub    $0x4,%esp
f010c809:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010c80c:	52                   	push   %edx
f010c80d:	51                   	push   %ecx
f010c80e:	50                   	push   %eax
f010c80f:	e8 80 c2 ff ff       	call   f0108a94 <get_frame_info>
f010c814:	83 c4 10             	add    $0x10,%esp
f010c817:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010c81a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c81d:	c1 e0 0c             	shl    $0xc,%eax
f010c820:	89 c2                	mov    %eax,%edx
f010c822:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c825:	01 d0                	add    %edx,%eax
f010c827:	6a 01                	push   $0x1
f010c829:	50                   	push   %eax
f010c82a:	ff 75 e0             	pushl  -0x20(%ebp)
f010c82d:	ff 75 08             	pushl  0x8(%ebp)
f010c830:	e8 75 c1 ff ff       	call   f01089aa <map_frame>
f010c835:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010c838:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c83c:	75 1d                	jne    f010c85b <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010c83e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c841:	c1 e0 0c             	shl    $0xc,%eax
f010c844:	89 c2                	mov    %eax,%edx
f010c846:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c849:	01 d0                	add    %edx,%eax
f010c84b:	6a 01                	push   $0x1
f010c84d:	6a 00                	push   $0x0
f010c84f:	50                   	push   %eax
f010c850:	ff 75 08             	pushl  0x8(%ebp)
f010c853:	e8 51 d7 ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010c858:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010c85b:	ff 45 f4             	incl   -0xc(%ebp)
f010c85e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c861:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010c864:	72 86                	jb     f010c7ec <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010c866:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010c869:	c9                   	leave  
f010c86a:	c3                   	ret    

f010c86b <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c86b:	55                   	push   %ebp
f010c86c:	89 e5                	mov    %esp,%ebp
f010c86e:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c871:	83 ec 04             	sub    $0x4,%esp
f010c874:	68 54 69 12 f0       	push   $0xf0126954
f010c879:	68 8e 03 00 00       	push   $0x38e
f010c87e:	68 db 66 12 f0       	push   $0xf01266db
f010c883:	e8 b1 3a ff ff       	call   f0100339 <_panic>

f010c888 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010c888:	55                   	push   %ebp
f010c889:	89 e5                	mov    %esp,%ebp
f010c88b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010c88e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c891:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c894:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010c897:	8b 45 08             	mov    0x8(%ebp),%eax
f010c89a:	8b 55 10             	mov    0x10(%ebp),%edx
f010c89d:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010c8a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8a3:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c8a6:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010c8a9:	83 ec 08             	sub    $0x8,%esp
f010c8ac:	6a 00                	push   $0x0
f010c8ae:	ff 75 0c             	pushl  0xc(%ebp)
f010c8b1:	e8 7b 42 01 00       	call   f0120b31 <initialize_dynamic_allocator>
f010c8b6:	83 c4 10             	add    $0x10,%esp
}
f010c8b9:	90                   	nop
f010c8ba:	c9                   	leave  
f010c8bb:	c3                   	ret    

f010c8bc <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c8bc:	55                   	push   %ebp
f010c8bd:	89 e5                	mov    %esp,%ebp
f010c8bf:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c8c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8c5:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c8c8:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c8cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8ce:	8b 55 10             	mov    0x10(%ebp),%edx
f010c8d1:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c8d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c8db:	eb 17                	jmp    f010c8f4 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c8dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8e0:	8b 40 64             	mov    0x64(%eax),%eax
f010c8e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c8e6:	c1 e2 02             	shl    $0x2,%edx
f010c8e9:	01 d0                	add    %edx,%eax
f010c8eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c8f1:	ff 45 f4             	incl   -0xc(%ebp)
f010c8f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8f7:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c8fc:	76 df                	jbe    f010c8dd <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c8fe:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c905:	eb 22                	jmp    f010c929 <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c907:	8b 45 08             	mov    0x8(%ebp),%eax
f010c90a:	8b 40 64             	mov    0x64(%eax),%eax
f010c90d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c910:	c1 e2 02             	shl    $0x2,%edx
f010c913:	01 c2                	add    %eax,%edx
f010c915:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f010c91a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c91d:	c1 e1 02             	shl    $0x2,%ecx
f010c920:	01 c8                	add    %ecx,%eax
f010c922:	8b 00                	mov    (%eax),%eax
f010c924:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c926:	ff 45 f4             	incl   -0xc(%ebp)
f010c929:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c930:	7e d5                	jle    f010c907 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c932:	8b 45 08             	mov    0x8(%ebp),%eax
f010c935:	8b 40 64             	mov    0x64(%eax),%eax
f010c938:	83 ec 0c             	sub    $0xc,%esp
f010c93b:	50                   	push   %eax
f010c93c:	e8 58 fe ff ff       	call   f010c799 <create_user_kern_stack>
f010c941:	83 c4 10             	add    $0x10,%esp
f010c944:	89 c2                	mov    %eax,%edx
f010c946:	8b 45 08             	mov    0x8(%ebp),%eax
f010c949:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c94c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c94f:	8b 40 70             	mov    0x70(%eax),%eax
f010c952:	05 00 80 00 00       	add    $0x8000,%eax
f010c957:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c95a:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c95e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c961:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c964:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c966:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c96a:	ba aa e9 10 f0       	mov    $0xf010e9aa,%edx
f010c96f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c972:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c974:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c978:	8b 45 08             	mov    0x8(%ebp),%eax
f010c97b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c97e:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c981:	8b 45 08             	mov    0x8(%ebp),%eax
f010c984:	8b 40 04             	mov    0x4(%eax),%eax
f010c987:	83 ec 04             	sub    $0x4,%esp
f010c98a:	6a 20                	push   $0x20
f010c98c:	6a 00                	push   $0x0
f010c98e:	50                   	push   %eax
f010c98f:	e8 bc 37 01 00       	call   f0120150 <memset>
f010c994:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c997:	8b 45 08             	mov    0x8(%ebp),%eax
f010c99a:	8b 40 04             	mov    0x4(%eax),%eax
f010c99d:	ba 8b bc 10 f0       	mov    $0xf010bc8b,%edx
f010c9a2:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c9a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9a8:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c9af:	00 00 00 
f010c9b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9b5:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c9bc:	00 00 00 
f010c9bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9c2:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c9c9:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c9cc:	83 ec 0c             	sub    $0xc,%esp
f010c9cf:	6a 02                	push   $0x2
f010c9d1:	e8 8b 2f 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010c9d6:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c9d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c9e0:	eb 54                	jmp    f010ca36 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c9e2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c9e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c9e8:	89 d0                	mov    %edx,%eax
f010c9ea:	01 c0                	add    %eax,%eax
f010c9ec:	01 d0                	add    %edx,%eax
f010c9ee:	c1 e0 03             	shl    $0x3,%eax
f010c9f1:	01 c8                	add    %ecx,%eax
f010c9f3:	05 ac 00 00 00       	add    $0xac,%eax
f010c9f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c9fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ca01:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca04:	89 d0                	mov    %edx,%eax
f010ca06:	01 c0                	add    %eax,%eax
f010ca08:	01 d0                	add    %edx,%eax
f010ca0a:	c1 e0 03             	shl    $0x3,%eax
f010ca0d:	01 c8                	add    %ecx,%eax
f010ca0f:	05 b0 00 00 00       	add    $0xb0,%eax
f010ca14:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010ca17:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ca1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca1d:	89 d0                	mov    %edx,%eax
f010ca1f:	01 c0                	add    %eax,%eax
f010ca21:	01 d0                	add    %edx,%eax
f010ca23:	c1 e0 03             	shl    $0x3,%eax
f010ca26:	01 c8                	add    %ecx,%eax
f010ca28:	05 b4 00 00 00       	add    $0xb4,%eax
f010ca2d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010ca33:	ff 45 f4             	incl   -0xc(%ebp)
f010ca36:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010ca3a:	7e a6                	jle    f010c9e2 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010ca3c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca3f:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010ca46:	00 00 00 

	e->pageFaultsCounter=0;
f010ca49:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca4c:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010ca53:	00 00 00 
	e->tableFaultsCounter=0;
f010ca56:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca59:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010ca60:	00 00 00 

	e->freeingFullWSCounter = 0;
f010ca63:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca66:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010ca6d:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010ca70:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca73:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010ca7a:	00 00 00 

	e->nModifiedPages=0;
f010ca7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca80:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010ca87:	00 00 00 
	e->nNotModifiedPages=0;
f010ca8a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca8d:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010ca94:	00 00 00 
	e->nClocks = 0;
f010ca97:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca9a:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010caa1:	00 00 00 

	//2020
	e->nPageIn = 0;
f010caa4:	8b 45 08             	mov    0x8(%ebp),%eax
f010caa7:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010caae:	00 00 00 
	e->nPageOut = 0;
f010cab1:	8b 45 08             	mov    0x8(%ebp),%eax
f010cab4:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010cabb:	00 00 00 
	e->nNewPageAdded = 0;
f010cabe:	8b 45 08             	mov    0x8(%ebp),%eax
f010cac1:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010cac8:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010cacb:	83 ec 04             	sub    $0x4,%esp
f010cace:	68 00 00 00 82       	push   $0x82000000
f010cad3:	68 00 00 00 80       	push   $0x80000000
f010cad8:	ff 75 08             	pushl  0x8(%ebp)
f010cadb:	e8 a8 fd ff ff       	call   f010c888 <initialize_uheap_dynamic_allocator>
f010cae0:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010cae3:	83 ec 0c             	sub    $0xc,%esp
f010cae6:	ff 75 08             	pushl  0x8(%ebp)
f010cae9:	e8 06 00 00 00       	call   f010caf4 <complete_environment_initialization>
f010caee:	83 c4 10             	add    $0x10,%esp
}
f010caf1:	90                   	nop
f010caf2:	c9                   	leave  
f010caf3:	c3                   	ret    

f010caf4 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010caf4:	55                   	push   %ebp
f010caf5:	89 e5                	mov    %esp,%ebp
f010caf7:	53                   	push   %ebx
f010caf8:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010cafb:	8b 45 08             	mov    0x8(%ebp),%eax
f010cafe:	8b 40 64             	mov    0x64(%eax),%eax
f010cb01:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010cb07:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb0a:	8b 40 68             	mov    0x68(%eax),%eax
f010cb0d:	83 c8 03             	or     $0x3,%eax
f010cb10:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010cb12:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb15:	8b 40 64             	mov    0x64(%eax),%eax
f010cb18:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010cb1e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb21:	8b 40 68             	mov    0x68(%eax),%eax
f010cb24:	83 c8 05             	or     $0x5,%eax
f010cb27:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010cb29:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb2c:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010cb33:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010cb36:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb39:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010cb40:	00 00 00 
	e->disk_env_tabledir = 0;
f010cb43:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb46:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010cb4d:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010cb50:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb53:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010cb5a:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010cb5d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb60:	8b 58 10             	mov    0x10(%eax),%ebx
f010cb63:	83 ec 0c             	sub    $0xc,%esp
f010cb66:	68 ca 02 00 00       	push   $0x2ca
f010cb6b:	e8 85 19 01 00       	call   f011e4f5 <log2_ceil>
f010cb70:	83 c4 10             	add    $0x10,%esp
f010cb73:	ba 01 00 00 00       	mov    $0x1,%edx
f010cb78:	88 c1                	mov    %al,%cl
f010cb7a:	d3 e2                	shl    %cl,%edx
f010cb7c:	89 d0                	mov    %edx,%eax
f010cb7e:	01 d8                	add    %ebx,%eax
f010cb80:	89 c3                	mov    %eax,%ebx
f010cb82:	83 ec 0c             	sub    $0xc,%esp
f010cb85:	68 ca 02 00 00       	push   $0x2ca
f010cb8a:	e8 31 19 01 00       	call   f011e4c0 <nearest_pow2_ceil>
f010cb8f:	83 c4 10             	add    $0x10,%esp
f010cb92:	f7 d8                	neg    %eax
f010cb94:	21 d8                	and    %ebx,%eax
f010cb96:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010cb99:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cb9d:	7f 1e                	jg     f010cbbd <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010cb9f:	83 ec 0c             	sub    $0xc,%esp
f010cba2:	68 ca 02 00 00       	push   $0x2ca
f010cba7:	e8 49 19 01 00       	call   f011e4f5 <log2_ceil>
f010cbac:	83 c4 10             	add    $0x10,%esp
f010cbaf:	ba 01 00 00 00       	mov    $0x1,%edx
f010cbb4:	88 c1                	mov    %al,%cl
f010cbb6:	d3 e2                	shl    %cl,%edx
f010cbb8:	89 d0                	mov    %edx,%eax
f010cbba:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010cbbd:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbc0:	8b 15 90 65 6f f0    	mov    0xf06f6590,%edx
f010cbc6:	29 d0                	sub    %edx,%eax
f010cbc8:	c1 f8 02             	sar    $0x2,%eax
f010cbcb:	89 c2                	mov    %eax,%edx
f010cbcd:	89 d0                	mov    %edx,%eax
f010cbcf:	c1 e0 03             	shl    $0x3,%eax
f010cbd2:	01 d0                	add    %edx,%eax
f010cbd4:	c1 e0 03             	shl    $0x3,%eax
f010cbd7:	01 d0                	add    %edx,%eax
f010cbd9:	c1 e0 02             	shl    $0x2,%eax
f010cbdc:	01 d0                	add    %edx,%eax
f010cbde:	01 c0                	add    %eax,%eax
f010cbe0:	01 d0                	add    %edx,%eax
f010cbe2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010cbe9:	01 c8                	add    %ecx,%eax
f010cbeb:	c1 e0 02             	shl    $0x2,%eax
f010cbee:	01 d0                	add    %edx,%eax
f010cbf0:	c1 e0 03             	shl    $0x3,%eax
f010cbf3:	01 d0                	add    %edx,%eax
f010cbf5:	c1 e0 05             	shl    $0x5,%eax
f010cbf8:	29 d0                	sub    %edx,%eax
f010cbfa:	c1 e0 02             	shl    $0x2,%eax
f010cbfd:	01 d0                	add    %edx,%eax
f010cbff:	01 c0                	add    %eax,%eax
f010cc01:	01 d0                	add    %edx,%eax
f010cc03:	c1 e0 03             	shl    $0x3,%eax
f010cc06:	01 d0                	add    %edx,%eax
f010cc08:	c1 e0 04             	shl    $0x4,%eax
f010cc0b:	29 d0                	sub    %edx,%eax
f010cc0d:	0b 45 f4             	or     -0xc(%ebp),%eax
f010cc10:	89 c2                	mov    %eax,%edx
f010cc12:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc15:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010cc18:	e8 08 f1 ff ff       	call   f010bd25 <get_cpu_proc>
f010cc1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010cc20:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010cc24:	75 0c                	jne    f010cc32 <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010cc26:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc29:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010cc30:	eb 0c                	jmp    f010cc3e <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010cc32:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cc35:	8b 50 10             	mov    0x10(%eax),%edx
f010cc38:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc3b:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010cc3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc41:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010cc48:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc4b:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010cc52:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010cc55:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc58:	8b 00                	mov    (%eax),%eax
f010cc5a:	83 ec 04             	sub    $0x4,%esp
f010cc5d:	6a 44                	push   $0x44
f010cc5f:	6a 00                	push   $0x0
f010cc61:	50                   	push   %eax
f010cc62:	e8 e9 34 01 00       	call   f0120150 <memset>
f010cc67:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010cc6a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc6d:	8b 00                	mov    (%eax),%eax
f010cc6f:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010cc75:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc78:	8b 00                	mov    (%eax),%eax
f010cc7a:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010cc80:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc83:	8b 00                	mov    (%eax),%eax
f010cc85:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010cc8b:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc8e:	8b 00                	mov    (%eax),%eax
f010cc90:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010cc97:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc9a:	8b 00                	mov    (%eax),%eax
f010cc9c:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010cca2:	8b 45 08             	mov    0x8(%ebp),%eax
f010cca5:	8b 00                	mov    (%eax),%eax
f010cca7:	8b 55 08             	mov    0x8(%ebp),%edx
f010ccaa:	8b 12                	mov    (%edx),%edx
f010ccac:	8b 52 38             	mov    0x38(%edx),%edx
f010ccaf:	80 ce 02             	or     $0x2,%dh
f010ccb2:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010ccb5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ccb9:	75 17                	jne    f010ccd2 <complete_environment_initialization+0x1de>
f010ccbb:	83 ec 04             	sub    $0x4,%esp
f010ccbe:	68 63 67 12 f0       	push   $0xf0126763
f010ccc3:	68 67 04 00 00       	push   $0x467
f010ccc8:	68 db 66 12 f0       	push   $0xf01266db
f010cccd:	e8 67 36 ff ff       	call   f0100339 <_panic>
f010ccd2:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccd5:	8b 40 08             	mov    0x8(%eax),%eax
f010ccd8:	85 c0                	test   %eax,%eax
f010ccda:	74 11                	je     f010cced <complete_environment_initialization+0x1f9>
f010ccdc:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccdf:	8b 40 08             	mov    0x8(%eax),%eax
f010cce2:	8b 55 08             	mov    0x8(%ebp),%edx
f010cce5:	8b 52 0c             	mov    0xc(%edx),%edx
f010cce8:	89 50 0c             	mov    %edx,0xc(%eax)
f010cceb:	eb 0b                	jmp    f010ccf8 <complete_environment_initialization+0x204>
f010cced:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccf0:	8b 40 0c             	mov    0xc(%eax),%eax
f010ccf3:	a3 98 65 6f f0       	mov    %eax,0xf06f6598
f010ccf8:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccfb:	8b 40 0c             	mov    0xc(%eax),%eax
f010ccfe:	85 c0                	test   %eax,%eax
f010cd00:	74 11                	je     f010cd13 <complete_environment_initialization+0x21f>
f010cd02:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd05:	8b 40 0c             	mov    0xc(%eax),%eax
f010cd08:	8b 55 08             	mov    0x8(%ebp),%edx
f010cd0b:	8b 52 08             	mov    0x8(%edx),%edx
f010cd0e:	89 50 08             	mov    %edx,0x8(%eax)
f010cd11:	eb 0b                	jmp    f010cd1e <complete_environment_initialization+0x22a>
f010cd13:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd16:	8b 40 08             	mov    0x8(%eax),%eax
f010cd19:	a3 94 65 6f f0       	mov    %eax,0xf06f6594
f010cd1e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd21:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010cd28:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd2b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010cd32:	a1 a0 65 6f f0       	mov    0xf06f65a0,%eax
f010cd37:	48                   	dec    %eax
f010cd38:	a3 a0 65 6f f0       	mov    %eax,0xf06f65a0
	return ;
f010cd3d:	90                   	nop
}
f010cd3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010cd41:	c9                   	leave  
f010cd42:	c3                   	ret    

f010cd43 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010cd43:	55                   	push   %ebp
f010cd44:	89 e5                	mov    %esp,%ebp
f010cd46:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cd49:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cd4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cd4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd52:	8b 00                	mov    (%eax),%eax
f010cd54:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cd59:	74 17                	je     f010cd72 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010cd5b:	83 ec 04             	sub    $0x4,%esp
f010cd5e:	68 89 69 12 f0       	push   $0xf0126989
f010cd63:	68 73 04 00 00       	push   $0x473
f010cd68:	68 db 66 12 f0       	push   $0xf01266db
f010cd6d:	e8 c7 35 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010cd72:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd75:	8b 00                	mov    (%eax),%eax
f010cd77:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd7a:	8b 52 18             	mov    0x18(%edx),%edx
f010cd7d:	89 50 30             	mov    %edx,0x30(%eax)
}
f010cd80:	90                   	nop
f010cd81:	c9                   	leave  
f010cd82:	c3                   	ret    

f010cd83 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010cd83:	55                   	push   %ebp
f010cd84:	89 e5                	mov    %esp,%ebp
f010cd86:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010cd89:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd8c:	8b 40 10             	mov    0x10(%eax),%eax
f010cd8f:	8d 48 01             	lea    0x1(%eax),%ecx
f010cd92:	8b 55 08             	mov    0x8(%ebp),%edx
f010cd95:	89 4a 10             	mov    %ecx,0x10(%edx)
f010cd98:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cd9b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cd9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cda1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cda4:	8b 00                	mov    (%eax),%eax
f010cda6:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cdab:	74 17                	je     f010cdc4 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010cdad:	83 ec 04             	sub    $0x4,%esp
f010cdb0:	68 89 69 12 f0       	push   $0xf0126989
f010cdb5:	68 81 04 00 00       	push   $0x481
f010cdba:	68 db 66 12 f0       	push   $0xf01266db
f010cdbf:	e8 75 35 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cdc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cdc7:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cdca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cdcd:	01 d0                	add    %edx,%eax
f010cdcf:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010cdd2:	eb 0f                	jmp    f010cde3 <PROGRAM_SEGMENT_NEXT+0x60>
f010cdd4:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdd7:	8b 40 10             	mov    0x10(%eax),%eax
f010cdda:	8d 50 01             	lea    0x1(%eax),%edx
f010cddd:	8b 45 08             	mov    0x8(%ebp),%eax
f010cde0:	89 50 10             	mov    %edx,0x10(%eax)
f010cde3:	8b 45 08             	mov    0x8(%ebp),%eax
f010cde6:	8b 40 10             	mov    0x10(%eax),%eax
f010cde9:	c1 e0 05             	shl    $0x5,%eax
f010cdec:	89 c2                	mov    %eax,%edx
f010cdee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cdf1:	01 d0                	add    %edx,%eax
f010cdf3:	8b 00                	mov    (%eax),%eax
f010cdf5:	83 f8 01             	cmp    $0x1,%eax
f010cdf8:	74 13                	je     f010ce0d <PROGRAM_SEGMENT_NEXT+0x8a>
f010cdfa:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdfd:	8b 50 10             	mov    0x10(%eax),%edx
f010ce00:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ce03:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ce06:	0f b7 c0             	movzwl %ax,%eax
f010ce09:	39 c2                	cmp    %eax,%edx
f010ce0b:	72 c7                	jb     f010cdd4 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010ce0d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce10:	8b 40 10             	mov    0x10(%eax),%eax
f010ce13:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010ce16:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ce19:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ce1c:	0f b7 c0             	movzwl %ax,%eax
f010ce1f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ce22:	7e 63                	jle    f010ce87 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010ce24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ce27:	c1 e0 05             	shl    $0x5,%eax
f010ce2a:	89 c2                	mov    %eax,%edx
f010ce2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ce2f:	01 d0                	add    %edx,%eax
f010ce31:	8b 50 04             	mov    0x4(%eax),%edx
f010ce34:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ce37:	01 c2                	add    %eax,%edx
f010ce39:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce3c:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010ce3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ce41:	c1 e0 05             	shl    $0x5,%eax
f010ce44:	89 c2                	mov    %eax,%edx
f010ce46:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ce49:	01 d0                	add    %edx,%eax
f010ce4b:	8b 50 14             	mov    0x14(%eax),%edx
f010ce4e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce51:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010ce54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ce57:	c1 e0 05             	shl    $0x5,%eax
f010ce5a:	89 c2                	mov    %eax,%edx
f010ce5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ce5f:	01 d0                	add    %edx,%eax
f010ce61:	8b 50 10             	mov    0x10(%eax),%edx
f010ce64:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce67:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010ce6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ce6d:	c1 e0 05             	shl    $0x5,%eax
f010ce70:	89 c2                	mov    %eax,%edx
f010ce72:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ce75:	01 d0                	add    %edx,%eax
f010ce77:	8b 40 08             	mov    0x8(%eax),%eax
f010ce7a:	89 c2                	mov    %eax,%edx
f010ce7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce7f:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010ce82:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce85:	eb 05                	jmp    f010ce8c <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010ce87:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ce8c:	c9                   	leave  
f010ce8d:	c3                   	ret    

f010ce8e <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010ce8e:	55                   	push   %ebp
f010ce8f:	89 e5                	mov    %esp,%ebp
f010ce91:	57                   	push   %edi
f010ce92:	56                   	push   %esi
f010ce93:	53                   	push   %ebx
f010ce94:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010ce97:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010ce9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cea1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cea4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cea7:	8b 00                	mov    (%eax),%eax
f010cea9:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010ceae:	74 17                	je     f010cec7 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010ceb0:	83 ec 04             	sub    $0x4,%esp
f010ceb3:	68 89 69 12 f0       	push   $0xf0126989
f010ceb8:	68 9d 04 00 00       	push   $0x49d
f010cebd:	68 db 66 12 f0       	push   $0xf01266db
f010cec2:	e8 72 34 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cec7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ceca:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cecd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ced0:	01 d0                	add    %edx,%eax
f010ced2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010ced5:	eb 07                	jmp    f010cede <PROGRAM_SEGMENT_FIRST+0x50>
f010ced7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ceda:	40                   	inc    %eax
f010cedb:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cede:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cee1:	c1 e0 05             	shl    $0x5,%eax
f010cee4:	89 c2                	mov    %eax,%edx
f010cee6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cee9:	01 d0                	add    %edx,%eax
f010ceeb:	8b 00                	mov    (%eax),%eax
f010ceed:	83 f8 01             	cmp    $0x1,%eax
f010cef0:	74 10                	je     f010cf02 <PROGRAM_SEGMENT_FIRST+0x74>
f010cef2:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010cef5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cef8:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cefb:	0f b7 c0             	movzwl %ax,%eax
f010cefe:	39 c2                	cmp    %eax,%edx
f010cf00:	72 d5                	jb     f010ced7 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010cf02:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cf05:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010cf08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cf0b:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cf0e:	0f b7 c0             	movzwl %ax,%eax
f010cf11:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010cf14:	7e 68                	jle    f010cf7e <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cf16:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cf19:	c1 e0 05             	shl    $0x5,%eax
f010cf1c:	89 c2                	mov    %eax,%edx
f010cf1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cf21:	01 d0                	add    %edx,%eax
f010cf23:	8b 50 04             	mov    0x4(%eax),%edx
f010cf26:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cf29:	01 d0                	add    %edx,%eax
f010cf2b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010cf2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cf31:	c1 e0 05             	shl    $0x5,%eax
f010cf34:	89 c2                	mov    %eax,%edx
f010cf36:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cf39:	01 d0                	add    %edx,%eax
f010cf3b:	8b 40 14             	mov    0x14(%eax),%eax
f010cf3e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010cf41:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cf44:	c1 e0 05             	shl    $0x5,%eax
f010cf47:	89 c2                	mov    %eax,%edx
f010cf49:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cf4c:	01 d0                	add    %edx,%eax
f010cf4e:	8b 40 10             	mov    0x10(%eax),%eax
f010cf51:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010cf54:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cf57:	c1 e0 05             	shl    $0x5,%eax
f010cf5a:	89 c2                	mov    %eax,%edx
f010cf5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cf5f:	01 d0                	add    %edx,%eax
f010cf61:	8b 40 08             	mov    0x8(%eax),%eax
f010cf64:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010cf67:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf6a:	89 c3                	mov    %eax,%ebx
f010cf6c:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cf6f:	ba 05 00 00 00       	mov    $0x5,%edx
f010cf74:	89 df                	mov    %ebx,%edi
f010cf76:	89 c6                	mov    %eax,%esi
f010cf78:	89 d1                	mov    %edx,%ecx
f010cf7a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cf7c:	eb 1c                	jmp    f010cf9a <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010cf7e:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010cf85:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf88:	89 c3                	mov    %eax,%ebx
f010cf8a:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cf8d:	ba 05 00 00 00       	mov    $0x5,%edx
f010cf92:	89 df                	mov    %ebx,%edi
f010cf94:	89 c6                	mov    %eax,%esi
f010cf96:	89 d1                	mov    %edx,%ecx
f010cf98:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010cf9a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010cfa0:	5b                   	pop    %ebx
f010cfa1:	5e                   	pop    %esi
f010cfa2:	5f                   	pop    %edi
f010cfa3:	5d                   	pop    %ebp
f010cfa4:	c2 04 00             	ret    $0x4

f010cfa7 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010cfa7:	55                   	push   %ebp
f010cfa8:	89 e5                	mov    %esp,%ebp
f010cfaa:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010cfad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010cfb4:	83 ec 0c             	sub    $0xc,%esp
f010cfb7:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010cfbc:	e8 f3 2f 00 00       	call   f010ffb4 <acquire_spinlock>
f010cfc1:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cfc4:	a1 30 f1 b1 f0       	mov    0xf0b1f130,%eax
f010cfc9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cfcc:	e9 c3 00 00 00       	jmp    f010d094 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010cfd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfd4:	8b 40 0c             	mov    0xc(%eax),%eax
f010cfd7:	3b 45 08             	cmp    0x8(%ebp),%eax
f010cfda:	0f 85 ac 00 00 00    	jne    f010d08c <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010cfe0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfe3:	8b 50 10             	mov    0x10(%eax),%edx
f010cfe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfe9:	8b 40 0c             	mov    0xc(%eax),%eax
f010cfec:	8b 40 64             	mov    0x64(%eax),%eax
f010cfef:	83 ec 08             	sub    $0x8,%esp
f010cff2:	52                   	push   %edx
f010cff3:	50                   	push   %eax
f010cff4:	e8 bd d0 ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f010cff9:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010cffc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d000:	75 17                	jne    f010d019 <cleanup_buffers+0x72>
f010d002:	83 ec 04             	sub    $0x4,%esp
f010d005:	68 63 67 12 f0       	push   $0xf0126763
f010d00a:	68 c6 04 00 00       	push   $0x4c6
f010d00f:	68 db 66 12 f0       	push   $0xf01266db
f010d014:	e8 20 33 ff ff       	call   f0100339 <_panic>
f010d019:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d01c:	8b 00                	mov    (%eax),%eax
f010d01e:	85 c0                	test   %eax,%eax
f010d020:	74 10                	je     f010d032 <cleanup_buffers+0x8b>
f010d022:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d025:	8b 00                	mov    (%eax),%eax
f010d027:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d02a:	8b 52 04             	mov    0x4(%edx),%edx
f010d02d:	89 50 04             	mov    %edx,0x4(%eax)
f010d030:	eb 0b                	jmp    f010d03d <cleanup_buffers+0x96>
f010d032:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d035:	8b 40 04             	mov    0x4(%eax),%eax
f010d038:	a3 34 f1 b1 f0       	mov    %eax,0xf0b1f134
f010d03d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d040:	8b 40 04             	mov    0x4(%eax),%eax
f010d043:	85 c0                	test   %eax,%eax
f010d045:	74 0f                	je     f010d056 <cleanup_buffers+0xaf>
f010d047:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d04a:	8b 40 04             	mov    0x4(%eax),%eax
f010d04d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d050:	8b 12                	mov    (%edx),%edx
f010d052:	89 10                	mov    %edx,(%eax)
f010d054:	eb 0a                	jmp    f010d060 <cleanup_buffers+0xb9>
f010d056:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d059:	8b 00                	mov    (%eax),%eax
f010d05b:	a3 30 f1 b1 f0       	mov    %eax,0xf0b1f130
f010d060:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d063:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010d069:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d06c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010d073:	a1 3c f1 b1 f0       	mov    0xf0b1f13c,%eax
f010d078:	48                   	dec    %eax
f010d079:	a3 3c f1 b1 f0       	mov    %eax,0xf0b1f13c

				free_frame(ptr_fi);
f010d07e:	83 ec 0c             	sub    $0xc,%esp
f010d081:	ff 75 f4             	pushl  -0xc(%ebp)
f010d084:	e8 a8 b5 ff ff       	call   f0108631 <free_frame>
f010d089:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010d08c:	a1 38 f1 b1 f0       	mov    0xf0b1f138,%eax
f010d091:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d094:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d098:	74 07                	je     f010d0a1 <cleanup_buffers+0xfa>
f010d09a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d09d:	8b 00                	mov    (%eax),%eax
f010d09f:	eb 05                	jmp    f010d0a6 <cleanup_buffers+0xff>
f010d0a1:	b8 00 00 00 00       	mov    $0x0,%eax
f010d0a6:	a3 38 f1 b1 f0       	mov    %eax,0xf0b1f138
f010d0ab:	a1 38 f1 b1 f0       	mov    0xf0b1f138,%eax
f010d0b0:	85 c0                	test   %eax,%eax
f010d0b2:	0f 85 19 ff ff ff    	jne    f010cfd1 <cleanup_buffers+0x2a>
f010d0b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d0bc:	0f 85 0f ff ff ff    	jne    f010cfd1 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010d0c2:	83 ec 0c             	sub    $0xc,%esp
f010d0c5:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010d0ca:	e8 6c 2f 00 00       	call   f011003b <release_spinlock>
f010d0cf:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010d0d2:	90                   	nop
f010d0d3:	c9                   	leave  
f010d0d4:	c3                   	ret    

f010d0d5 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010d0d5:	55                   	push   %ebp
f010d0d6:	89 e5                	mov    %esp,%ebp
f010d0d8:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010d0db:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010d0df:	7e 06                	jle    f010d0e7 <set_program_priority+0x12>
f010d0e1:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010d0e5:	7e 14                	jle    f010d0fb <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010d0e7:	83 ec 04             	sub    $0x4,%esp
f010d0ea:	68 a0 69 12 f0       	push   $0xf01269a0
f010d0ef:	6a 10                	push   $0x10
f010d0f1:	68 c4 69 12 f0       	push   $0xf01269c4
f010d0f6:	e8 3e 32 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010d0fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d0ff:	74 78                	je     f010d179 <set_program_priority+0xa4>
		return;
	switch(priority)
f010d101:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010d105:	77 56                	ja     f010d15d <set_program_priority+0x88>
f010d107:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d10a:	c1 e0 02             	shl    $0x2,%eax
f010d10d:	05 00 6a 12 f0       	add    $0xf0126a00,%eax
f010d112:	8b 00                	mov    (%eax),%eax
f010d114:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010d116:	83 ec 08             	sub    $0x8,%esp
f010d119:	6a 01                	push   $0x1
f010d11b:	ff 75 08             	pushl  0x8(%ebp)
f010d11e:	e8 ea dc ff ff       	call   f010ae0d <half_WS_Size>
f010d123:	83 c4 10             	add    $0x10,%esp
			break;
f010d126:	eb 35                	jmp    f010d15d <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010d128:	83 ec 08             	sub    $0x8,%esp
f010d12b:	6a 00                	push   $0x0
f010d12d:	ff 75 08             	pushl  0x8(%ebp)
f010d130:	e8 d8 dc ff ff       	call   f010ae0d <half_WS_Size>
f010d135:	83 c4 10             	add    $0x10,%esp
			break;
f010d138:	eb 23                	jmp    f010d15d <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010d13a:	83 ec 08             	sub    $0x8,%esp
f010d13d:	6a 01                	push   $0x1
f010d13f:	ff 75 08             	pushl  0x8(%ebp)
f010d142:	e8 a9 dc ff ff       	call   f010adf0 <double_WS_Size>
f010d147:	83 c4 10             	add    $0x10,%esp
			break;
f010d14a:	eb 11                	jmp    f010d15d <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010d14c:	83 ec 08             	sub    $0x8,%esp
f010d14f:	6a 00                	push   $0x0
f010d151:	ff 75 08             	pushl  0x8(%ebp)
f010d154:	e8 97 dc ff ff       	call   f010adf0 <double_WS_Size>
f010d159:	83 c4 10             	add    $0x10,%esp
			break;
f010d15c:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010d15d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d160:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010d166:	83 ec 08             	sub    $0x8,%esp
f010d169:	50                   	push   %eax
f010d16a:	68 e1 69 12 f0       	push   $0xf01269e1
f010d16f:	e8 17 3e ff ff       	call   f0100f8b <cprintf>
f010d174:	83 c4 10             	add    $0x10,%esp
f010d177:	eb 01                	jmp    f010d17a <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010d179:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010d17a:	c9                   	leave  
f010d17b:	c3                   	ret    

f010d17c <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010d17c:	55                   	push   %ebp
f010d17d:	89 e5                	mov    %esp,%ebp
f010d17f:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d182:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d189:	eb 29                	jmp    f010d1b4 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010d18b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d18e:	89 d0                	mov    %edx,%eax
f010d190:	01 c0                	add    %eax,%eax
f010d192:	01 d0                	add    %edx,%eax
f010d194:	c1 e0 02             	shl    $0x2,%eax
f010d197:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
f010d19c:	8b 00                	mov    (%eax),%eax
f010d19e:	83 ec 08             	sub    $0x8,%esp
f010d1a1:	50                   	push   %eax
f010d1a2:	ff 75 08             	pushl  0x8(%ebp)
f010d1a5:	e8 c4 2e 01 00       	call   f012006e <strcmp>
f010d1aa:	83 c4 10             	add    $0x10,%esp
f010d1ad:	85 c0                	test   %eax,%eax
f010d1af:	74 0f                	je     f010d1c0 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d1b1:	ff 45 f4             	incl   -0xc(%ebp)
f010d1b4:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d1b9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d1bc:	7c cd                	jl     f010d18b <get_user_program_info+0xf>
f010d1be:	eb 01                	jmp    f010d1c1 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010d1c0:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010d1c1:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d1c6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d1c9:	75 1a                	jne    f010d1e5 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010d1cb:	83 ec 08             	sub    $0x8,%esp
f010d1ce:	ff 75 08             	pushl  0x8(%ebp)
f010d1d1:	68 fd 78 12 f0       	push   $0xf01278fd
f010d1d6:	e8 b0 3d ff ff       	call   f0100f8b <cprintf>
f010d1db:	83 c4 10             	add    $0x10,%esp
		return 0;
f010d1de:	b8 00 00 00 00       	mov    $0x0,%eax
f010d1e3:	eb 11                	jmp    f010d1f6 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010d1e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d1e8:	89 d0                	mov    %edx,%eax
f010d1ea:	01 c0                	add    %eax,%eax
f010d1ec:	01 d0                	add    %edx,%eax
f010d1ee:	c1 e0 02             	shl    $0x2,%eax
f010d1f1:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
}
f010d1f6:	c9                   	leave  
f010d1f7:	c3                   	ret    

f010d1f8 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010d1f8:	55                   	push   %ebp
f010d1f9:	89 e5                	mov    %esp,%ebp
f010d1fb:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d1fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d205:	eb 2d                	jmp    f010d234 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010d207:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d20a:	89 d0                	mov    %edx,%eax
f010d20c:	01 c0                	add    %eax,%eax
f010d20e:	01 d0                	add    %edx,%eax
f010d210:	c1 e0 02             	shl    $0x2,%eax
f010d213:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
f010d218:	8b 00                	mov    (%eax),%eax
f010d21a:	8b 55 08             	mov    0x8(%ebp),%edx
f010d21d:	83 c2 20             	add    $0x20,%edx
f010d220:	83 ec 08             	sub    $0x8,%esp
f010d223:	50                   	push   %eax
f010d224:	52                   	push   %edx
f010d225:	e8 44 2e 01 00       	call   f012006e <strcmp>
f010d22a:	83 c4 10             	add    $0x10,%esp
f010d22d:	85 c0                	test   %eax,%eax
f010d22f:	74 0f                	je     f010d240 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d231:	ff 45 f4             	incl   -0xc(%ebp)
f010d234:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d239:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d23c:	7c c9                	jl     f010d207 <get_user_program_info_by_env+0xf>
f010d23e:	eb 01                	jmp    f010d241 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010d240:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010d241:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d246:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d249:	75 17                	jne    f010d262 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010d24b:	83 ec 0c             	sub    $0xc,%esp
f010d24e:	68 18 79 12 f0       	push   $0xf0127918
f010d253:	e8 33 3d ff ff       	call   f0100f8b <cprintf>
f010d258:	83 c4 10             	add    $0x10,%esp
		return 0;
f010d25b:	b8 00 00 00 00       	mov    $0x0,%eax
f010d260:	eb 11                	jmp    f010d273 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010d262:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d265:	89 d0                	mov    %edx,%eax
f010d267:	01 c0                	add    %eax,%eax
f010d269:	01 d0                	add    %edx,%eax
f010d26b:	c1 e0 02             	shl    $0x2,%eax
f010d26e:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
}
f010d273:	c9                   	leave  
f010d274:	c3                   	ret    

f010d275 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010d275:	55                   	push   %ebp
f010d276:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010d278:	8b 45 08             	mov    0x8(%ebp),%eax
f010d27b:	83 f8 13             	cmp    $0x13,%eax
f010d27e:	77 0c                	ja     f010d28c <trapname+0x17>
		return excnames[trapno];
f010d280:	8b 45 08             	mov    0x8(%ebp),%eax
f010d283:	8b 04 85 00 7d 12 f0 	mov    -0xfed8300(,%eax,4),%eax
f010d28a:	eb 2c                	jmp    f010d2b8 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010d28c:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010d290:	75 07                	jne    f010d299 <trapname+0x24>
		return "System call";
f010d292:	b8 40 79 12 f0       	mov    $0xf0127940,%eax
f010d297:	eb 1f                	jmp    f010d2b8 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010d299:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010d29d:	75 07                	jne    f010d2a6 <trapname+0x31>
		return "Clock Interrupt";
f010d29f:	b8 4c 79 12 f0       	mov    $0xf012794c,%eax
f010d2a4:	eb 12                	jmp    f010d2b8 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010d2a6:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010d2aa:	75 07                	jne    f010d2b3 <trapname+0x3e>
		return "Keyboard Interrupt";
f010d2ac:	b8 5c 79 12 f0       	mov    $0xf012795c,%eax
f010d2b1:	eb 05                	jmp    f010d2b8 <trapname+0x43>
	return "(unknown trap)";
f010d2b3:	b8 6f 79 12 f0       	mov    $0xf012796f,%eax
}
f010d2b8:	5d                   	pop    %ebp
f010d2b9:	c3                   	ret    

f010d2ba <ts_init>:


void ts_init(void)
{
f010d2ba:	55                   	push   %ebp
f010d2bb:	89 e5                	mov    %esp,%ebp
f010d2bd:	53                   	push   %ebx
f010d2be:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010d2c1:	e8 34 a2 ff ff       	call   f01074fa <pushcli>

	struct cpu* c = mycpu();
f010d2c6:	e8 6c a1 ff ff       	call   f0107437 <mycpu>
f010d2cb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010d2ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2d1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010d2d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2db:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010d2e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2e4:	83 c0 0c             	add    $0xc,%eax
f010d2e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d2ea:	83 c2 0c             	add    $0xc,%edx
f010d2ed:	c1 ea 10             	shr    $0x10,%edx
f010d2f0:	88 d3                	mov    %dl,%bl
f010d2f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d2f5:	83 c2 0c             	add    $0xc,%edx
f010d2f8:	c1 ea 18             	shr    $0x18,%edx
f010d2fb:	88 d1                	mov    %dl,%cl
f010d2fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d300:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010d307:	68 00 
f010d309:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d30c:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010d313:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d316:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010d31c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d31f:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d325:	83 e2 f0             	and    $0xfffffff0,%edx
f010d328:	83 ca 09             	or     $0x9,%edx
f010d32b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d331:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d334:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d33a:	83 ca 10             	or     $0x10,%edx
f010d33d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d343:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d346:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d34c:	83 e2 9f             	and    $0xffffff9f,%edx
f010d34f:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d355:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d358:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d35e:	83 ca 80             	or     $0xffffff80,%edx
f010d361:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d367:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d36a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d370:	83 e2 f0             	and    $0xfffffff0,%edx
f010d373:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d379:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d37c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d382:	83 e2 ef             	and    $0xffffffef,%edx
f010d385:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d38b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d38e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d394:	83 e2 df             	and    $0xffffffdf,%edx
f010d397:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d39d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3a0:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d3a6:	83 ca 40             	or     $0x40,%edx
f010d3a9:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d3af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3b2:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d3b8:	83 e2 7f             	and    $0x7f,%edx
f010d3bb:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d3c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3c4:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010d3ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3cd:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d3d3:	83 e2 ef             	and    $0xffffffef,%edx
f010d3d6:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010d3dc:	e8 6b a1 ff ff       	call   f010754c <popcli>
f010d3e1:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010d3e7:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010d3eb:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010d3ee:	90                   	nop
f010d3ef:	83 c4 14             	add    $0x14,%esp
f010d3f2:	5b                   	pop    %ebx
f010d3f3:	5d                   	pop    %ebp
f010d3f4:	c3                   	ret    

f010d3f5 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010d3f5:	55                   	push   %ebp
f010d3f6:	89 e5                	mov    %esp,%ebp
f010d3f8:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d3fb:	b8 a4 e8 10 f0       	mov    $0xf010e8a4,%eax
f010d400:	66 a3 00 66 6f f0    	mov    %ax,0xf06f6600
f010d406:	66 c7 05 02 66 6f f0 	movw   $0x8,0xf06f6602
f010d40d:	08 00 
f010d40f:	a0 04 66 6f f0       	mov    0xf06f6604,%al
f010d414:	83 e0 e0             	and    $0xffffffe0,%eax
f010d417:	a2 04 66 6f f0       	mov    %al,0xf06f6604
f010d41c:	a0 04 66 6f f0       	mov    0xf06f6604,%al
f010d421:	83 e0 1f             	and    $0x1f,%eax
f010d424:	a2 04 66 6f f0       	mov    %al,0xf06f6604
f010d429:	a0 05 66 6f f0       	mov    0xf06f6605,%al
f010d42e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d431:	83 c8 0e             	or     $0xe,%eax
f010d434:	a2 05 66 6f f0       	mov    %al,0xf06f6605
f010d439:	a0 05 66 6f f0       	mov    0xf06f6605,%al
f010d43e:	83 e0 ef             	and    $0xffffffef,%eax
f010d441:	a2 05 66 6f f0       	mov    %al,0xf06f6605
f010d446:	a0 05 66 6f f0       	mov    0xf06f6605,%al
f010d44b:	83 e0 9f             	and    $0xffffff9f,%eax
f010d44e:	a2 05 66 6f f0       	mov    %al,0xf06f6605
f010d453:	a0 05 66 6f f0       	mov    0xf06f6605,%al
f010d458:	83 c8 80             	or     $0xffffff80,%eax
f010d45b:	a2 05 66 6f f0       	mov    %al,0xf06f6605
f010d460:	b8 a4 e8 10 f0       	mov    $0xf010e8a4,%eax
f010d465:	c1 e8 10             	shr    $0x10,%eax
f010d468:	66 a3 06 66 6f f0    	mov    %ax,0xf06f6606
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d46e:	b8 ac e8 10 f0       	mov    $0xf010e8ac,%eax
f010d473:	66 a3 30 66 6f f0    	mov    %ax,0xf06f6630
f010d479:	66 c7 05 32 66 6f f0 	movw   $0x8,0xf06f6632
f010d480:	08 00 
f010d482:	a0 34 66 6f f0       	mov    0xf06f6634,%al
f010d487:	83 e0 e0             	and    $0xffffffe0,%eax
f010d48a:	a2 34 66 6f f0       	mov    %al,0xf06f6634
f010d48f:	a0 34 66 6f f0       	mov    0xf06f6634,%al
f010d494:	83 e0 1f             	and    $0x1f,%eax
f010d497:	a2 34 66 6f f0       	mov    %al,0xf06f6634
f010d49c:	a0 35 66 6f f0       	mov    0xf06f6635,%al
f010d4a1:	83 e0 f0             	and    $0xfffffff0,%eax
f010d4a4:	83 c8 0e             	or     $0xe,%eax
f010d4a7:	a2 35 66 6f f0       	mov    %al,0xf06f6635
f010d4ac:	a0 35 66 6f f0       	mov    0xf06f6635,%al
f010d4b1:	83 e0 ef             	and    $0xffffffef,%eax
f010d4b4:	a2 35 66 6f f0       	mov    %al,0xf06f6635
f010d4b9:	a0 35 66 6f f0       	mov    0xf06f6635,%al
f010d4be:	83 e0 9f             	and    $0xffffff9f,%eax
f010d4c1:	a2 35 66 6f f0       	mov    %al,0xf06f6635
f010d4c6:	a0 35 66 6f f0       	mov    0xf06f6635,%al
f010d4cb:	83 c8 80             	or     $0xffffff80,%eax
f010d4ce:	a2 35 66 6f f0       	mov    %al,0xf06f6635
f010d4d3:	b8 ac e8 10 f0       	mov    $0xf010e8ac,%eax
f010d4d8:	c1 e8 10             	shr    $0x10,%eax
f010d4db:	66 a3 36 66 6f f0    	mov    %ax,0xf06f6636
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d4e1:	b8 b4 e8 10 f0       	mov    $0xf010e8b4,%eax
f010d4e6:	66 a3 c0 66 6f f0    	mov    %ax,0xf06f66c0
f010d4ec:	66 c7 05 c2 66 6f f0 	movw   $0x8,0xf06f66c2
f010d4f3:	08 00 
f010d4f5:	a0 c4 66 6f f0       	mov    0xf06f66c4,%al
f010d4fa:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4fd:	a2 c4 66 6f f0       	mov    %al,0xf06f66c4
f010d502:	a0 c4 66 6f f0       	mov    0xf06f66c4,%al
f010d507:	83 e0 1f             	and    $0x1f,%eax
f010d50a:	a2 c4 66 6f f0       	mov    %al,0xf06f66c4
f010d50f:	a0 c5 66 6f f0       	mov    0xf06f66c5,%al
f010d514:	83 e0 f0             	and    $0xfffffff0,%eax
f010d517:	83 c8 0e             	or     $0xe,%eax
f010d51a:	a2 c5 66 6f f0       	mov    %al,0xf06f66c5
f010d51f:	a0 c5 66 6f f0       	mov    0xf06f66c5,%al
f010d524:	83 e0 ef             	and    $0xffffffef,%eax
f010d527:	a2 c5 66 6f f0       	mov    %al,0xf06f66c5
f010d52c:	a0 c5 66 6f f0       	mov    0xf06f66c5,%al
f010d531:	83 c8 60             	or     $0x60,%eax
f010d534:	a2 c5 66 6f f0       	mov    %al,0xf06f66c5
f010d539:	a0 c5 66 6f f0       	mov    0xf06f66c5,%al
f010d53e:	83 c8 80             	or     $0xffffff80,%eax
f010d541:	a2 c5 66 6f f0       	mov    %al,0xf06f66c5
f010d546:	b8 b4 e8 10 f0       	mov    $0xf010e8b4,%eax
f010d54b:	c1 e8 10             	shr    $0x10,%eax
f010d54e:	66 a3 c6 66 6f f0    	mov    %ax,0xf06f66c6
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d554:	b8 be e8 10 f0       	mov    $0xf010e8be,%eax
f010d559:	66 a3 c8 66 6f f0    	mov    %ax,0xf06f66c8
f010d55f:	66 c7 05 ca 66 6f f0 	movw   $0x8,0xf06f66ca
f010d566:	08 00 
f010d568:	a0 cc 66 6f f0       	mov    0xf06f66cc,%al
f010d56d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d570:	a2 cc 66 6f f0       	mov    %al,0xf06f66cc
f010d575:	a0 cc 66 6f f0       	mov    0xf06f66cc,%al
f010d57a:	83 e0 1f             	and    $0x1f,%eax
f010d57d:	a2 cc 66 6f f0       	mov    %al,0xf06f66cc
f010d582:	a0 cd 66 6f f0       	mov    0xf06f66cd,%al
f010d587:	83 e0 f0             	and    $0xfffffff0,%eax
f010d58a:	83 c8 0e             	or     $0xe,%eax
f010d58d:	a2 cd 66 6f f0       	mov    %al,0xf06f66cd
f010d592:	a0 cd 66 6f f0       	mov    0xf06f66cd,%al
f010d597:	83 e0 ef             	and    $0xffffffef,%eax
f010d59a:	a2 cd 66 6f f0       	mov    %al,0xf06f66cd
f010d59f:	a0 cd 66 6f f0       	mov    0xf06f66cd,%al
f010d5a4:	83 c8 60             	or     $0x60,%eax
f010d5a7:	a2 cd 66 6f f0       	mov    %al,0xf06f66cd
f010d5ac:	a0 cd 66 6f f0       	mov    0xf06f66cd,%al
f010d5b1:	83 c8 80             	or     $0xffffff80,%eax
f010d5b4:	a2 cd 66 6f f0       	mov    %al,0xf06f66cd
f010d5b9:	b8 be e8 10 f0       	mov    $0xf010e8be,%eax
f010d5be:	c1 e8 10             	shr    $0x10,%eax
f010d5c1:	66 a3 ce 66 6f f0    	mov    %ax,0xf06f66ce
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d5c7:	b8 c8 e8 10 f0       	mov    $0xf010e8c8,%eax
f010d5cc:	66 a3 40 67 6f f0    	mov    %ax,0xf06f6740
f010d5d2:	66 c7 05 42 67 6f f0 	movw   $0x8,0xf06f6742
f010d5d9:	08 00 
f010d5db:	a0 44 67 6f f0       	mov    0xf06f6744,%al
f010d5e0:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5e3:	a2 44 67 6f f0       	mov    %al,0xf06f6744
f010d5e8:	a0 44 67 6f f0       	mov    0xf06f6744,%al
f010d5ed:	83 e0 1f             	and    $0x1f,%eax
f010d5f0:	a2 44 67 6f f0       	mov    %al,0xf06f6744
f010d5f5:	a0 45 67 6f f0       	mov    0xf06f6745,%al
f010d5fa:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5fd:	83 c8 0e             	or     $0xe,%eax
f010d600:	a2 45 67 6f f0       	mov    %al,0xf06f6745
f010d605:	a0 45 67 6f f0       	mov    0xf06f6745,%al
f010d60a:	83 e0 ef             	and    $0xffffffef,%eax
f010d60d:	a2 45 67 6f f0       	mov    %al,0xf06f6745
f010d612:	a0 45 67 6f f0       	mov    0xf06f6745,%al
f010d617:	83 c8 60             	or     $0x60,%eax
f010d61a:	a2 45 67 6f f0       	mov    %al,0xf06f6745
f010d61f:	a0 45 67 6f f0       	mov    0xf06f6745,%al
f010d624:	83 c8 80             	or     $0xffffff80,%eax
f010d627:	a2 45 67 6f f0       	mov    %al,0xf06f6745
f010d62c:	b8 c8 e8 10 f0       	mov    $0xf010e8c8,%eax
f010d631:	c1 e8 10             	shr    $0x10,%eax
f010d634:	66 a3 46 67 6f f0    	mov    %ax,0xf06f6746

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d63a:	b8 d2 e8 10 f0       	mov    $0xf010e8d2,%eax
f010d63f:	66 a3 c0 65 6f f0    	mov    %ax,0xf06f65c0
f010d645:	66 c7 05 c2 65 6f f0 	movw   $0x8,0xf06f65c2
f010d64c:	08 00 
f010d64e:	a0 c4 65 6f f0       	mov    0xf06f65c4,%al
f010d653:	83 e0 e0             	and    $0xffffffe0,%eax
f010d656:	a2 c4 65 6f f0       	mov    %al,0xf06f65c4
f010d65b:	a0 c4 65 6f f0       	mov    0xf06f65c4,%al
f010d660:	83 e0 1f             	and    $0x1f,%eax
f010d663:	a2 c4 65 6f f0       	mov    %al,0xf06f65c4
f010d668:	a0 c5 65 6f f0       	mov    0xf06f65c5,%al
f010d66d:	83 e0 f0             	and    $0xfffffff0,%eax
f010d670:	83 c8 0e             	or     $0xe,%eax
f010d673:	a2 c5 65 6f f0       	mov    %al,0xf06f65c5
f010d678:	a0 c5 65 6f f0       	mov    0xf06f65c5,%al
f010d67d:	83 e0 ef             	and    $0xffffffef,%eax
f010d680:	a2 c5 65 6f f0       	mov    %al,0xf06f65c5
f010d685:	a0 c5 65 6f f0       	mov    0xf06f65c5,%al
f010d68a:	83 c8 60             	or     $0x60,%eax
f010d68d:	a2 c5 65 6f f0       	mov    %al,0xf06f65c5
f010d692:	a0 c5 65 6f f0       	mov    0xf06f65c5,%al
f010d697:	83 c8 80             	or     $0xffffff80,%eax
f010d69a:	a2 c5 65 6f f0       	mov    %al,0xf06f65c5
f010d69f:	b8 d2 e8 10 f0       	mov    $0xf010e8d2,%eax
f010d6a4:	c1 e8 10             	shr    $0x10,%eax
f010d6a7:	66 a3 c6 65 6f f0    	mov    %ax,0xf06f65c6
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d6ad:	b8 dc e8 10 f0       	mov    $0xf010e8dc,%eax
f010d6b2:	66 a3 c8 65 6f f0    	mov    %ax,0xf06f65c8
f010d6b8:	66 c7 05 ca 65 6f f0 	movw   $0x8,0xf06f65ca
f010d6bf:	08 00 
f010d6c1:	a0 cc 65 6f f0       	mov    0xf06f65cc,%al
f010d6c6:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6c9:	a2 cc 65 6f f0       	mov    %al,0xf06f65cc
f010d6ce:	a0 cc 65 6f f0       	mov    0xf06f65cc,%al
f010d6d3:	83 e0 1f             	and    $0x1f,%eax
f010d6d6:	a2 cc 65 6f f0       	mov    %al,0xf06f65cc
f010d6db:	a0 cd 65 6f f0       	mov    0xf06f65cd,%al
f010d6e0:	83 c8 0f             	or     $0xf,%eax
f010d6e3:	a2 cd 65 6f f0       	mov    %al,0xf06f65cd
f010d6e8:	a0 cd 65 6f f0       	mov    0xf06f65cd,%al
f010d6ed:	83 e0 ef             	and    $0xffffffef,%eax
f010d6f0:	a2 cd 65 6f f0       	mov    %al,0xf06f65cd
f010d6f5:	a0 cd 65 6f f0       	mov    0xf06f65cd,%al
f010d6fa:	83 c8 60             	or     $0x60,%eax
f010d6fd:	a2 cd 65 6f f0       	mov    %al,0xf06f65cd
f010d702:	a0 cd 65 6f f0       	mov    0xf06f65cd,%al
f010d707:	83 c8 80             	or     $0xffffff80,%eax
f010d70a:	a2 cd 65 6f f0       	mov    %al,0xf06f65cd
f010d70f:	b8 dc e8 10 f0       	mov    $0xf010e8dc,%eax
f010d714:	c1 e8 10             	shr    $0x10,%eax
f010d717:	66 a3 ce 65 6f f0    	mov    %ax,0xf06f65ce
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d71d:	b8 e6 e8 10 f0       	mov    $0xf010e8e6,%eax
f010d722:	66 a3 d0 65 6f f0    	mov    %ax,0xf06f65d0
f010d728:	66 c7 05 d2 65 6f f0 	movw   $0x8,0xf06f65d2
f010d72f:	08 00 
f010d731:	a0 d4 65 6f f0       	mov    0xf06f65d4,%al
f010d736:	83 e0 e0             	and    $0xffffffe0,%eax
f010d739:	a2 d4 65 6f f0       	mov    %al,0xf06f65d4
f010d73e:	a0 d4 65 6f f0       	mov    0xf06f65d4,%al
f010d743:	83 e0 1f             	and    $0x1f,%eax
f010d746:	a2 d4 65 6f f0       	mov    %al,0xf06f65d4
f010d74b:	a0 d5 65 6f f0       	mov    0xf06f65d5,%al
f010d750:	83 e0 f0             	and    $0xfffffff0,%eax
f010d753:	83 c8 0e             	or     $0xe,%eax
f010d756:	a2 d5 65 6f f0       	mov    %al,0xf06f65d5
f010d75b:	a0 d5 65 6f f0       	mov    0xf06f65d5,%al
f010d760:	83 e0 ef             	and    $0xffffffef,%eax
f010d763:	a2 d5 65 6f f0       	mov    %al,0xf06f65d5
f010d768:	a0 d5 65 6f f0       	mov    0xf06f65d5,%al
f010d76d:	83 c8 60             	or     $0x60,%eax
f010d770:	a2 d5 65 6f f0       	mov    %al,0xf06f65d5
f010d775:	a0 d5 65 6f f0       	mov    0xf06f65d5,%al
f010d77a:	83 c8 80             	or     $0xffffff80,%eax
f010d77d:	a2 d5 65 6f f0       	mov    %al,0xf06f65d5
f010d782:	b8 e6 e8 10 f0       	mov    $0xf010e8e6,%eax
f010d787:	c1 e8 10             	shr    $0x10,%eax
f010d78a:	66 a3 d6 65 6f f0    	mov    %ax,0xf06f65d6
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d790:	b8 f0 e8 10 f0       	mov    $0xf010e8f0,%eax
f010d795:	66 a3 d8 65 6f f0    	mov    %ax,0xf06f65d8
f010d79b:	66 c7 05 da 65 6f f0 	movw   $0x8,0xf06f65da
f010d7a2:	08 00 
f010d7a4:	a0 dc 65 6f f0       	mov    0xf06f65dc,%al
f010d7a9:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7ac:	a2 dc 65 6f f0       	mov    %al,0xf06f65dc
f010d7b1:	a0 dc 65 6f f0       	mov    0xf06f65dc,%al
f010d7b6:	83 e0 1f             	and    $0x1f,%eax
f010d7b9:	a2 dc 65 6f f0       	mov    %al,0xf06f65dc
f010d7be:	a0 dd 65 6f f0       	mov    0xf06f65dd,%al
f010d7c3:	83 c8 0f             	or     $0xf,%eax
f010d7c6:	a2 dd 65 6f f0       	mov    %al,0xf06f65dd
f010d7cb:	a0 dd 65 6f f0       	mov    0xf06f65dd,%al
f010d7d0:	83 e0 ef             	and    $0xffffffef,%eax
f010d7d3:	a2 dd 65 6f f0       	mov    %al,0xf06f65dd
f010d7d8:	a0 dd 65 6f f0       	mov    0xf06f65dd,%al
f010d7dd:	83 c8 60             	or     $0x60,%eax
f010d7e0:	a2 dd 65 6f f0       	mov    %al,0xf06f65dd
f010d7e5:	a0 dd 65 6f f0       	mov    0xf06f65dd,%al
f010d7ea:	83 c8 80             	or     $0xffffff80,%eax
f010d7ed:	a2 dd 65 6f f0       	mov    %al,0xf06f65dd
f010d7f2:	b8 f0 e8 10 f0       	mov    $0xf010e8f0,%eax
f010d7f7:	c1 e8 10             	shr    $0x10,%eax
f010d7fa:	66 a3 de 65 6f f0    	mov    %ax,0xf06f65de
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d800:	b8 fa e8 10 f0       	mov    $0xf010e8fa,%eax
f010d805:	66 a3 e0 65 6f f0    	mov    %ax,0xf06f65e0
f010d80b:	66 c7 05 e2 65 6f f0 	movw   $0x8,0xf06f65e2
f010d812:	08 00 
f010d814:	a0 e4 65 6f f0       	mov    0xf06f65e4,%al
f010d819:	83 e0 e0             	and    $0xffffffe0,%eax
f010d81c:	a2 e4 65 6f f0       	mov    %al,0xf06f65e4
f010d821:	a0 e4 65 6f f0       	mov    0xf06f65e4,%al
f010d826:	83 e0 1f             	and    $0x1f,%eax
f010d829:	a2 e4 65 6f f0       	mov    %al,0xf06f65e4
f010d82e:	a0 e5 65 6f f0       	mov    0xf06f65e5,%al
f010d833:	83 c8 0f             	or     $0xf,%eax
f010d836:	a2 e5 65 6f f0       	mov    %al,0xf06f65e5
f010d83b:	a0 e5 65 6f f0       	mov    0xf06f65e5,%al
f010d840:	83 e0 ef             	and    $0xffffffef,%eax
f010d843:	a2 e5 65 6f f0       	mov    %al,0xf06f65e5
f010d848:	a0 e5 65 6f f0       	mov    0xf06f65e5,%al
f010d84d:	83 c8 60             	or     $0x60,%eax
f010d850:	a2 e5 65 6f f0       	mov    %al,0xf06f65e5
f010d855:	a0 e5 65 6f f0       	mov    0xf06f65e5,%al
f010d85a:	83 c8 80             	or     $0xffffff80,%eax
f010d85d:	a2 e5 65 6f f0       	mov    %al,0xf06f65e5
f010d862:	b8 fa e8 10 f0       	mov    $0xf010e8fa,%eax
f010d867:	c1 e8 10             	shr    $0x10,%eax
f010d86a:	66 a3 e6 65 6f f0    	mov    %ax,0xf06f65e6
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d870:	b8 04 e9 10 f0       	mov    $0xf010e904,%eax
f010d875:	66 a3 e8 65 6f f0    	mov    %ax,0xf06f65e8
f010d87b:	66 c7 05 ea 65 6f f0 	movw   $0x8,0xf06f65ea
f010d882:	08 00 
f010d884:	a0 ec 65 6f f0       	mov    0xf06f65ec,%al
f010d889:	83 e0 e0             	and    $0xffffffe0,%eax
f010d88c:	a2 ec 65 6f f0       	mov    %al,0xf06f65ec
f010d891:	a0 ec 65 6f f0       	mov    0xf06f65ec,%al
f010d896:	83 e0 1f             	and    $0x1f,%eax
f010d899:	a2 ec 65 6f f0       	mov    %al,0xf06f65ec
f010d89e:	a0 ed 65 6f f0       	mov    0xf06f65ed,%al
f010d8a3:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8a6:	83 c8 0e             	or     $0xe,%eax
f010d8a9:	a2 ed 65 6f f0       	mov    %al,0xf06f65ed
f010d8ae:	a0 ed 65 6f f0       	mov    0xf06f65ed,%al
f010d8b3:	83 e0 ef             	and    $0xffffffef,%eax
f010d8b6:	a2 ed 65 6f f0       	mov    %al,0xf06f65ed
f010d8bb:	a0 ed 65 6f f0       	mov    0xf06f65ed,%al
f010d8c0:	83 c8 60             	or     $0x60,%eax
f010d8c3:	a2 ed 65 6f f0       	mov    %al,0xf06f65ed
f010d8c8:	a0 ed 65 6f f0       	mov    0xf06f65ed,%al
f010d8cd:	83 c8 80             	or     $0xffffff80,%eax
f010d8d0:	a2 ed 65 6f f0       	mov    %al,0xf06f65ed
f010d8d5:	b8 04 e9 10 f0       	mov    $0xf010e904,%eax
f010d8da:	c1 e8 10             	shr    $0x10,%eax
f010d8dd:	66 a3 ee 65 6f f0    	mov    %ax,0xf06f65ee
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d8e3:	b8 0e e9 10 f0       	mov    $0xf010e90e,%eax
f010d8e8:	66 a3 f0 65 6f f0    	mov    %ax,0xf06f65f0
f010d8ee:	66 c7 05 f2 65 6f f0 	movw   $0x8,0xf06f65f2
f010d8f5:	08 00 
f010d8f7:	a0 f4 65 6f f0       	mov    0xf06f65f4,%al
f010d8fc:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8ff:	a2 f4 65 6f f0       	mov    %al,0xf06f65f4
f010d904:	a0 f4 65 6f f0       	mov    0xf06f65f4,%al
f010d909:	83 e0 1f             	and    $0x1f,%eax
f010d90c:	a2 f4 65 6f f0       	mov    %al,0xf06f65f4
f010d911:	a0 f5 65 6f f0       	mov    0xf06f65f5,%al
f010d916:	83 e0 f0             	and    $0xfffffff0,%eax
f010d919:	83 c8 0e             	or     $0xe,%eax
f010d91c:	a2 f5 65 6f f0       	mov    %al,0xf06f65f5
f010d921:	a0 f5 65 6f f0       	mov    0xf06f65f5,%al
f010d926:	83 e0 ef             	and    $0xffffffef,%eax
f010d929:	a2 f5 65 6f f0       	mov    %al,0xf06f65f5
f010d92e:	a0 f5 65 6f f0       	mov    0xf06f65f5,%al
f010d933:	83 c8 60             	or     $0x60,%eax
f010d936:	a2 f5 65 6f f0       	mov    %al,0xf06f65f5
f010d93b:	a0 f5 65 6f f0       	mov    0xf06f65f5,%al
f010d940:	83 c8 80             	or     $0xffffff80,%eax
f010d943:	a2 f5 65 6f f0       	mov    %al,0xf06f65f5
f010d948:	b8 0e e9 10 f0       	mov    $0xf010e90e,%eax
f010d94d:	c1 e8 10             	shr    $0x10,%eax
f010d950:	66 a3 f6 65 6f f0    	mov    %ax,0xf06f65f6
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d956:	b8 18 e9 10 f0       	mov    $0xf010e918,%eax
f010d95b:	66 a3 f8 65 6f f0    	mov    %ax,0xf06f65f8
f010d961:	66 c7 05 fa 65 6f f0 	movw   $0x8,0xf06f65fa
f010d968:	08 00 
f010d96a:	a0 fc 65 6f f0       	mov    0xf06f65fc,%al
f010d96f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d972:	a2 fc 65 6f f0       	mov    %al,0xf06f65fc
f010d977:	a0 fc 65 6f f0       	mov    0xf06f65fc,%al
f010d97c:	83 e0 1f             	and    $0x1f,%eax
f010d97f:	a2 fc 65 6f f0       	mov    %al,0xf06f65fc
f010d984:	a0 fd 65 6f f0       	mov    0xf06f65fd,%al
f010d989:	83 e0 f0             	and    $0xfffffff0,%eax
f010d98c:	83 c8 0e             	or     $0xe,%eax
f010d98f:	a2 fd 65 6f f0       	mov    %al,0xf06f65fd
f010d994:	a0 fd 65 6f f0       	mov    0xf06f65fd,%al
f010d999:	83 e0 ef             	and    $0xffffffef,%eax
f010d99c:	a2 fd 65 6f f0       	mov    %al,0xf06f65fd
f010d9a1:	a0 fd 65 6f f0       	mov    0xf06f65fd,%al
f010d9a6:	83 c8 60             	or     $0x60,%eax
f010d9a9:	a2 fd 65 6f f0       	mov    %al,0xf06f65fd
f010d9ae:	a0 fd 65 6f f0       	mov    0xf06f65fd,%al
f010d9b3:	83 c8 80             	or     $0xffffff80,%eax
f010d9b6:	a2 fd 65 6f f0       	mov    %al,0xf06f65fd
f010d9bb:	b8 18 e9 10 f0       	mov    $0xf010e918,%eax
f010d9c0:	c1 e8 10             	shr    $0x10,%eax
f010d9c3:	66 a3 fe 65 6f f0    	mov    %ax,0xf06f65fe
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d9c9:	b8 1e e9 10 f0       	mov    $0xf010e91e,%eax
f010d9ce:	66 a3 10 66 6f f0    	mov    %ax,0xf06f6610
f010d9d4:	66 c7 05 12 66 6f f0 	movw   $0x8,0xf06f6612
f010d9db:	08 00 
f010d9dd:	a0 14 66 6f f0       	mov    0xf06f6614,%al
f010d9e2:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9e5:	a2 14 66 6f f0       	mov    %al,0xf06f6614
f010d9ea:	a0 14 66 6f f0       	mov    0xf06f6614,%al
f010d9ef:	83 e0 1f             	and    $0x1f,%eax
f010d9f2:	a2 14 66 6f f0       	mov    %al,0xf06f6614
f010d9f7:	a0 15 66 6f f0       	mov    0xf06f6615,%al
f010d9fc:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9ff:	83 c8 0e             	or     $0xe,%eax
f010da02:	a2 15 66 6f f0       	mov    %al,0xf06f6615
f010da07:	a0 15 66 6f f0       	mov    0xf06f6615,%al
f010da0c:	83 e0 ef             	and    $0xffffffef,%eax
f010da0f:	a2 15 66 6f f0       	mov    %al,0xf06f6615
f010da14:	a0 15 66 6f f0       	mov    0xf06f6615,%al
f010da19:	83 c8 60             	or     $0x60,%eax
f010da1c:	a2 15 66 6f f0       	mov    %al,0xf06f6615
f010da21:	a0 15 66 6f f0       	mov    0xf06f6615,%al
f010da26:	83 c8 80             	or     $0xffffff80,%eax
f010da29:	a2 15 66 6f f0       	mov    %al,0xf06f6615
f010da2e:	b8 1e e9 10 f0       	mov    $0xf010e91e,%eax
f010da33:	c1 e8 10             	shr    $0x10,%eax
f010da36:	66 a3 16 66 6f f0    	mov    %ax,0xf06f6616
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010da3c:	b8 22 e9 10 f0       	mov    $0xf010e922,%eax
f010da41:	66 a3 18 66 6f f0    	mov    %ax,0xf06f6618
f010da47:	66 c7 05 1a 66 6f f0 	movw   $0x8,0xf06f661a
f010da4e:	08 00 
f010da50:	a0 1c 66 6f f0       	mov    0xf06f661c,%al
f010da55:	83 e0 e0             	and    $0xffffffe0,%eax
f010da58:	a2 1c 66 6f f0       	mov    %al,0xf06f661c
f010da5d:	a0 1c 66 6f f0       	mov    0xf06f661c,%al
f010da62:	83 e0 1f             	and    $0x1f,%eax
f010da65:	a2 1c 66 6f f0       	mov    %al,0xf06f661c
f010da6a:	a0 1d 66 6f f0       	mov    0xf06f661d,%al
f010da6f:	83 e0 f0             	and    $0xfffffff0,%eax
f010da72:	83 c8 0e             	or     $0xe,%eax
f010da75:	a2 1d 66 6f f0       	mov    %al,0xf06f661d
f010da7a:	a0 1d 66 6f f0       	mov    0xf06f661d,%al
f010da7f:	83 e0 ef             	and    $0xffffffef,%eax
f010da82:	a2 1d 66 6f f0       	mov    %al,0xf06f661d
f010da87:	a0 1d 66 6f f0       	mov    0xf06f661d,%al
f010da8c:	83 c8 60             	or     $0x60,%eax
f010da8f:	a2 1d 66 6f f0       	mov    %al,0xf06f661d
f010da94:	a0 1d 66 6f f0       	mov    0xf06f661d,%al
f010da99:	83 c8 80             	or     $0xffffff80,%eax
f010da9c:	a2 1d 66 6f f0       	mov    %al,0xf06f661d
f010daa1:	b8 22 e9 10 f0       	mov    $0xf010e922,%eax
f010daa6:	c1 e8 10             	shr    $0x10,%eax
f010daa9:	66 a3 1e 66 6f f0    	mov    %ax,0xf06f661e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010daaf:	b8 26 e9 10 f0       	mov    $0xf010e926,%eax
f010dab4:	66 a3 20 66 6f f0    	mov    %ax,0xf06f6620
f010daba:	66 c7 05 22 66 6f f0 	movw   $0x8,0xf06f6622
f010dac1:	08 00 
f010dac3:	a0 24 66 6f f0       	mov    0xf06f6624,%al
f010dac8:	83 e0 e0             	and    $0xffffffe0,%eax
f010dacb:	a2 24 66 6f f0       	mov    %al,0xf06f6624
f010dad0:	a0 24 66 6f f0       	mov    0xf06f6624,%al
f010dad5:	83 e0 1f             	and    $0x1f,%eax
f010dad8:	a2 24 66 6f f0       	mov    %al,0xf06f6624
f010dadd:	a0 25 66 6f f0       	mov    0xf06f6625,%al
f010dae2:	83 e0 f0             	and    $0xfffffff0,%eax
f010dae5:	83 c8 0e             	or     $0xe,%eax
f010dae8:	a2 25 66 6f f0       	mov    %al,0xf06f6625
f010daed:	a0 25 66 6f f0       	mov    0xf06f6625,%al
f010daf2:	83 e0 ef             	and    $0xffffffef,%eax
f010daf5:	a2 25 66 6f f0       	mov    %al,0xf06f6625
f010dafa:	a0 25 66 6f f0       	mov    0xf06f6625,%al
f010daff:	83 c8 60             	or     $0x60,%eax
f010db02:	a2 25 66 6f f0       	mov    %al,0xf06f6625
f010db07:	a0 25 66 6f f0       	mov    0xf06f6625,%al
f010db0c:	83 c8 80             	or     $0xffffff80,%eax
f010db0f:	a2 25 66 6f f0       	mov    %al,0xf06f6625
f010db14:	b8 26 e9 10 f0       	mov    $0xf010e926,%eax
f010db19:	c1 e8 10             	shr    $0x10,%eax
f010db1c:	66 a3 26 66 6f f0    	mov    %ax,0xf06f6626
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010db22:	b8 2a e9 10 f0       	mov    $0xf010e92a,%eax
f010db27:	66 a3 28 66 6f f0    	mov    %ax,0xf06f6628
f010db2d:	66 c7 05 2a 66 6f f0 	movw   $0x8,0xf06f662a
f010db34:	08 00 
f010db36:	a0 2c 66 6f f0       	mov    0xf06f662c,%al
f010db3b:	83 e0 e0             	and    $0xffffffe0,%eax
f010db3e:	a2 2c 66 6f f0       	mov    %al,0xf06f662c
f010db43:	a0 2c 66 6f f0       	mov    0xf06f662c,%al
f010db48:	83 e0 1f             	and    $0x1f,%eax
f010db4b:	a2 2c 66 6f f0       	mov    %al,0xf06f662c
f010db50:	a0 2d 66 6f f0       	mov    0xf06f662d,%al
f010db55:	83 e0 f0             	and    $0xfffffff0,%eax
f010db58:	83 c8 0e             	or     $0xe,%eax
f010db5b:	a2 2d 66 6f f0       	mov    %al,0xf06f662d
f010db60:	a0 2d 66 6f f0       	mov    0xf06f662d,%al
f010db65:	83 e0 ef             	and    $0xffffffef,%eax
f010db68:	a2 2d 66 6f f0       	mov    %al,0xf06f662d
f010db6d:	a0 2d 66 6f f0       	mov    0xf06f662d,%al
f010db72:	83 c8 60             	or     $0x60,%eax
f010db75:	a2 2d 66 6f f0       	mov    %al,0xf06f662d
f010db7a:	a0 2d 66 6f f0       	mov    0xf06f662d,%al
f010db7f:	83 c8 80             	or     $0xffffff80,%eax
f010db82:	a2 2d 66 6f f0       	mov    %al,0xf06f662d
f010db87:	b8 2a e9 10 f0       	mov    $0xf010e92a,%eax
f010db8c:	c1 e8 10             	shr    $0x10,%eax
f010db8f:	66 a3 2e 66 6f f0    	mov    %ax,0xf06f662e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010db95:	b8 2e e9 10 f0       	mov    $0xf010e92e,%eax
f010db9a:	66 a3 40 66 6f f0    	mov    %ax,0xf06f6640
f010dba0:	66 c7 05 42 66 6f f0 	movw   $0x8,0xf06f6642
f010dba7:	08 00 
f010dba9:	a0 44 66 6f f0       	mov    0xf06f6644,%al
f010dbae:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbb1:	a2 44 66 6f f0       	mov    %al,0xf06f6644
f010dbb6:	a0 44 66 6f f0       	mov    0xf06f6644,%al
f010dbbb:	83 e0 1f             	and    $0x1f,%eax
f010dbbe:	a2 44 66 6f f0       	mov    %al,0xf06f6644
f010dbc3:	a0 45 66 6f f0       	mov    0xf06f6645,%al
f010dbc8:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbcb:	83 c8 0e             	or     $0xe,%eax
f010dbce:	a2 45 66 6f f0       	mov    %al,0xf06f6645
f010dbd3:	a0 45 66 6f f0       	mov    0xf06f6645,%al
f010dbd8:	83 e0 ef             	and    $0xffffffef,%eax
f010dbdb:	a2 45 66 6f f0       	mov    %al,0xf06f6645
f010dbe0:	a0 45 66 6f f0       	mov    0xf06f6645,%al
f010dbe5:	83 c8 60             	or     $0x60,%eax
f010dbe8:	a2 45 66 6f f0       	mov    %al,0xf06f6645
f010dbed:	a0 45 66 6f f0       	mov    0xf06f6645,%al
f010dbf2:	83 c8 80             	or     $0xffffff80,%eax
f010dbf5:	a2 45 66 6f f0       	mov    %al,0xf06f6645
f010dbfa:	b8 2e e9 10 f0       	mov    $0xf010e92e,%eax
f010dbff:	c1 e8 10             	shr    $0x10,%eax
f010dc02:	66 a3 46 66 6f f0    	mov    %ax,0xf06f6646
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010dc08:	b8 34 e9 10 f0       	mov    $0xf010e934,%eax
f010dc0d:	66 a3 48 66 6f f0    	mov    %ax,0xf06f6648
f010dc13:	66 c7 05 4a 66 6f f0 	movw   $0x8,0xf06f664a
f010dc1a:	08 00 
f010dc1c:	a0 4c 66 6f f0       	mov    0xf06f664c,%al
f010dc21:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc24:	a2 4c 66 6f f0       	mov    %al,0xf06f664c
f010dc29:	a0 4c 66 6f f0       	mov    0xf06f664c,%al
f010dc2e:	83 e0 1f             	and    $0x1f,%eax
f010dc31:	a2 4c 66 6f f0       	mov    %al,0xf06f664c
f010dc36:	a0 4d 66 6f f0       	mov    0xf06f664d,%al
f010dc3b:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc3e:	83 c8 0e             	or     $0xe,%eax
f010dc41:	a2 4d 66 6f f0       	mov    %al,0xf06f664d
f010dc46:	a0 4d 66 6f f0       	mov    0xf06f664d,%al
f010dc4b:	83 e0 ef             	and    $0xffffffef,%eax
f010dc4e:	a2 4d 66 6f f0       	mov    %al,0xf06f664d
f010dc53:	a0 4d 66 6f f0       	mov    0xf06f664d,%al
f010dc58:	83 c8 60             	or     $0x60,%eax
f010dc5b:	a2 4d 66 6f f0       	mov    %al,0xf06f664d
f010dc60:	a0 4d 66 6f f0       	mov    0xf06f664d,%al
f010dc65:	83 c8 80             	or     $0xffffff80,%eax
f010dc68:	a2 4d 66 6f f0       	mov    %al,0xf06f664d
f010dc6d:	b8 34 e9 10 f0       	mov    $0xf010e934,%eax
f010dc72:	c1 e8 10             	shr    $0x10,%eax
f010dc75:	66 a3 4e 66 6f f0    	mov    %ax,0xf06f664e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010dc7b:	b8 38 e9 10 f0       	mov    $0xf010e938,%eax
f010dc80:	66 a3 50 66 6f f0    	mov    %ax,0xf06f6650
f010dc86:	66 c7 05 52 66 6f f0 	movw   $0x8,0xf06f6652
f010dc8d:	08 00 
f010dc8f:	a0 54 66 6f f0       	mov    0xf06f6654,%al
f010dc94:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc97:	a2 54 66 6f f0       	mov    %al,0xf06f6654
f010dc9c:	a0 54 66 6f f0       	mov    0xf06f6654,%al
f010dca1:	83 e0 1f             	and    $0x1f,%eax
f010dca4:	a2 54 66 6f f0       	mov    %al,0xf06f6654
f010dca9:	a0 55 66 6f f0       	mov    0xf06f6655,%al
f010dcae:	83 e0 f0             	and    $0xfffffff0,%eax
f010dcb1:	83 c8 0e             	or     $0xe,%eax
f010dcb4:	a2 55 66 6f f0       	mov    %al,0xf06f6655
f010dcb9:	a0 55 66 6f f0       	mov    0xf06f6655,%al
f010dcbe:	83 e0 ef             	and    $0xffffffef,%eax
f010dcc1:	a2 55 66 6f f0       	mov    %al,0xf06f6655
f010dcc6:	a0 55 66 6f f0       	mov    0xf06f6655,%al
f010dccb:	83 c8 60             	or     $0x60,%eax
f010dcce:	a2 55 66 6f f0       	mov    %al,0xf06f6655
f010dcd3:	a0 55 66 6f f0       	mov    0xf06f6655,%al
f010dcd8:	83 c8 80             	or     $0xffffff80,%eax
f010dcdb:	a2 55 66 6f f0       	mov    %al,0xf06f6655
f010dce0:	b8 38 e9 10 f0       	mov    $0xf010e938,%eax
f010dce5:	c1 e8 10             	shr    $0x10,%eax
f010dce8:	66 a3 56 66 6f f0    	mov    %ax,0xf06f6656
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010dcee:	b8 3e e9 10 f0       	mov    $0xf010e93e,%eax
f010dcf3:	66 a3 58 66 6f f0    	mov    %ax,0xf06f6658
f010dcf9:	66 c7 05 5a 66 6f f0 	movw   $0x8,0xf06f665a
f010dd00:	08 00 
f010dd02:	a0 5c 66 6f f0       	mov    0xf06f665c,%al
f010dd07:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd0a:	a2 5c 66 6f f0       	mov    %al,0xf06f665c
f010dd0f:	a0 5c 66 6f f0       	mov    0xf06f665c,%al
f010dd14:	83 e0 1f             	and    $0x1f,%eax
f010dd17:	a2 5c 66 6f f0       	mov    %al,0xf06f665c
f010dd1c:	a0 5d 66 6f f0       	mov    0xf06f665d,%al
f010dd21:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd24:	83 c8 0e             	or     $0xe,%eax
f010dd27:	a2 5d 66 6f f0       	mov    %al,0xf06f665d
f010dd2c:	a0 5d 66 6f f0       	mov    0xf06f665d,%al
f010dd31:	83 e0 ef             	and    $0xffffffef,%eax
f010dd34:	a2 5d 66 6f f0       	mov    %al,0xf06f665d
f010dd39:	a0 5d 66 6f f0       	mov    0xf06f665d,%al
f010dd3e:	83 c8 60             	or     $0x60,%eax
f010dd41:	a2 5d 66 6f f0       	mov    %al,0xf06f665d
f010dd46:	a0 5d 66 6f f0       	mov    0xf06f665d,%al
f010dd4b:	83 c8 80             	or     $0xffffff80,%eax
f010dd4e:	a2 5d 66 6f f0       	mov    %al,0xf06f665d
f010dd53:	b8 3e e9 10 f0       	mov    $0xf010e93e,%eax
f010dd58:	c1 e8 10             	shr    $0x10,%eax
f010dd5b:	66 a3 5e 66 6f f0    	mov    %ax,0xf06f665e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010dd61:	b8 44 e9 10 f0       	mov    $0xf010e944,%eax
f010dd66:	66 a3 d0 66 6f f0    	mov    %ax,0xf06f66d0
f010dd6c:	66 c7 05 d2 66 6f f0 	movw   $0x8,0xf06f66d2
f010dd73:	08 00 
f010dd75:	a0 d4 66 6f f0       	mov    0xf06f66d4,%al
f010dd7a:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd7d:	a2 d4 66 6f f0       	mov    %al,0xf06f66d4
f010dd82:	a0 d4 66 6f f0       	mov    0xf06f66d4,%al
f010dd87:	83 e0 1f             	and    $0x1f,%eax
f010dd8a:	a2 d4 66 6f f0       	mov    %al,0xf06f66d4
f010dd8f:	a0 d5 66 6f f0       	mov    0xf06f66d5,%al
f010dd94:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd97:	83 c8 0e             	or     $0xe,%eax
f010dd9a:	a2 d5 66 6f f0       	mov    %al,0xf06f66d5
f010dd9f:	a0 d5 66 6f f0       	mov    0xf06f66d5,%al
f010dda4:	83 e0 ef             	and    $0xffffffef,%eax
f010dda7:	a2 d5 66 6f f0       	mov    %al,0xf06f66d5
f010ddac:	a0 d5 66 6f f0       	mov    0xf06f66d5,%al
f010ddb1:	83 c8 60             	or     $0x60,%eax
f010ddb4:	a2 d5 66 6f f0       	mov    %al,0xf06f66d5
f010ddb9:	a0 d5 66 6f f0       	mov    0xf06f66d5,%al
f010ddbe:	83 c8 80             	or     $0xffffff80,%eax
f010ddc1:	a2 d5 66 6f f0       	mov    %al,0xf06f66d5
f010ddc6:	b8 44 e9 10 f0       	mov    $0xf010e944,%eax
f010ddcb:	c1 e8 10             	shr    $0x10,%eax
f010ddce:	66 a3 d6 66 6f f0    	mov    %ax,0xf06f66d6
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010ddd4:	b8 4a e9 10 f0       	mov    $0xf010e94a,%eax
f010ddd9:	66 a3 d8 66 6f f0    	mov    %ax,0xf06f66d8
f010dddf:	66 c7 05 da 66 6f f0 	movw   $0x8,0xf06f66da
f010dde6:	08 00 
f010dde8:	a0 dc 66 6f f0       	mov    0xf06f66dc,%al
f010dded:	83 e0 e0             	and    $0xffffffe0,%eax
f010ddf0:	a2 dc 66 6f f0       	mov    %al,0xf06f66dc
f010ddf5:	a0 dc 66 6f f0       	mov    0xf06f66dc,%al
f010ddfa:	83 e0 1f             	and    $0x1f,%eax
f010ddfd:	a2 dc 66 6f f0       	mov    %al,0xf06f66dc
f010de02:	a0 dd 66 6f f0       	mov    0xf06f66dd,%al
f010de07:	83 e0 f0             	and    $0xfffffff0,%eax
f010de0a:	83 c8 0e             	or     $0xe,%eax
f010de0d:	a2 dd 66 6f f0       	mov    %al,0xf06f66dd
f010de12:	a0 dd 66 6f f0       	mov    0xf06f66dd,%al
f010de17:	83 e0 ef             	and    $0xffffffef,%eax
f010de1a:	a2 dd 66 6f f0       	mov    %al,0xf06f66dd
f010de1f:	a0 dd 66 6f f0       	mov    0xf06f66dd,%al
f010de24:	83 c8 60             	or     $0x60,%eax
f010de27:	a2 dd 66 6f f0       	mov    %al,0xf06f66dd
f010de2c:	a0 dd 66 6f f0       	mov    0xf06f66dd,%al
f010de31:	83 c8 80             	or     $0xffffff80,%eax
f010de34:	a2 dd 66 6f f0       	mov    %al,0xf06f66dd
f010de39:	b8 4a e9 10 f0       	mov    $0xf010e94a,%eax
f010de3e:	c1 e8 10             	shr    $0x10,%eax
f010de41:	66 a3 de 66 6f f0    	mov    %ax,0xf06f66de
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010de47:	b8 50 e9 10 f0       	mov    $0xf010e950,%eax
f010de4c:	66 a3 e0 66 6f f0    	mov    %ax,0xf06f66e0
f010de52:	66 c7 05 e2 66 6f f0 	movw   $0x8,0xf06f66e2
f010de59:	08 00 
f010de5b:	a0 e4 66 6f f0       	mov    0xf06f66e4,%al
f010de60:	83 e0 e0             	and    $0xffffffe0,%eax
f010de63:	a2 e4 66 6f f0       	mov    %al,0xf06f66e4
f010de68:	a0 e4 66 6f f0       	mov    0xf06f66e4,%al
f010de6d:	83 e0 1f             	and    $0x1f,%eax
f010de70:	a2 e4 66 6f f0       	mov    %al,0xf06f66e4
f010de75:	a0 e5 66 6f f0       	mov    0xf06f66e5,%al
f010de7a:	83 e0 f0             	and    $0xfffffff0,%eax
f010de7d:	83 c8 0e             	or     $0xe,%eax
f010de80:	a2 e5 66 6f f0       	mov    %al,0xf06f66e5
f010de85:	a0 e5 66 6f f0       	mov    0xf06f66e5,%al
f010de8a:	83 e0 ef             	and    $0xffffffef,%eax
f010de8d:	a2 e5 66 6f f0       	mov    %al,0xf06f66e5
f010de92:	a0 e5 66 6f f0       	mov    0xf06f66e5,%al
f010de97:	83 c8 60             	or     $0x60,%eax
f010de9a:	a2 e5 66 6f f0       	mov    %al,0xf06f66e5
f010de9f:	a0 e5 66 6f f0       	mov    0xf06f66e5,%al
f010dea4:	83 c8 80             	or     $0xffffff80,%eax
f010dea7:	a2 e5 66 6f f0       	mov    %al,0xf06f66e5
f010deac:	b8 50 e9 10 f0       	mov    $0xf010e950,%eax
f010deb1:	c1 e8 10             	shr    $0x10,%eax
f010deb4:	66 a3 e6 66 6f f0    	mov    %ax,0xf06f66e6
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010deba:	b8 56 e9 10 f0       	mov    $0xf010e956,%eax
f010debf:	66 a3 e8 66 6f f0    	mov    %ax,0xf06f66e8
f010dec5:	66 c7 05 ea 66 6f f0 	movw   $0x8,0xf06f66ea
f010decc:	08 00 
f010dece:	a0 ec 66 6f f0       	mov    0xf06f66ec,%al
f010ded3:	83 e0 e0             	and    $0xffffffe0,%eax
f010ded6:	a2 ec 66 6f f0       	mov    %al,0xf06f66ec
f010dedb:	a0 ec 66 6f f0       	mov    0xf06f66ec,%al
f010dee0:	83 e0 1f             	and    $0x1f,%eax
f010dee3:	a2 ec 66 6f f0       	mov    %al,0xf06f66ec
f010dee8:	a0 ed 66 6f f0       	mov    0xf06f66ed,%al
f010deed:	83 e0 f0             	and    $0xfffffff0,%eax
f010def0:	83 c8 0e             	or     $0xe,%eax
f010def3:	a2 ed 66 6f f0       	mov    %al,0xf06f66ed
f010def8:	a0 ed 66 6f f0       	mov    0xf06f66ed,%al
f010defd:	83 e0 ef             	and    $0xffffffef,%eax
f010df00:	a2 ed 66 6f f0       	mov    %al,0xf06f66ed
f010df05:	a0 ed 66 6f f0       	mov    0xf06f66ed,%al
f010df0a:	83 c8 60             	or     $0x60,%eax
f010df0d:	a2 ed 66 6f f0       	mov    %al,0xf06f66ed
f010df12:	a0 ed 66 6f f0       	mov    0xf06f66ed,%al
f010df17:	83 c8 80             	or     $0xffffff80,%eax
f010df1a:	a2 ed 66 6f f0       	mov    %al,0xf06f66ed
f010df1f:	b8 56 e9 10 f0       	mov    $0xf010e956,%eax
f010df24:	c1 e8 10             	shr    $0x10,%eax
f010df27:	66 a3 ee 66 6f f0    	mov    %ax,0xf06f66ee
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010df2d:	b8 5c e9 10 f0       	mov    $0xf010e95c,%eax
f010df32:	66 a3 f0 66 6f f0    	mov    %ax,0xf06f66f0
f010df38:	66 c7 05 f2 66 6f f0 	movw   $0x8,0xf06f66f2
f010df3f:	08 00 
f010df41:	a0 f4 66 6f f0       	mov    0xf06f66f4,%al
f010df46:	83 e0 e0             	and    $0xffffffe0,%eax
f010df49:	a2 f4 66 6f f0       	mov    %al,0xf06f66f4
f010df4e:	a0 f4 66 6f f0       	mov    0xf06f66f4,%al
f010df53:	83 e0 1f             	and    $0x1f,%eax
f010df56:	a2 f4 66 6f f0       	mov    %al,0xf06f66f4
f010df5b:	a0 f5 66 6f f0       	mov    0xf06f66f5,%al
f010df60:	83 e0 f0             	and    $0xfffffff0,%eax
f010df63:	83 c8 0e             	or     $0xe,%eax
f010df66:	a2 f5 66 6f f0       	mov    %al,0xf06f66f5
f010df6b:	a0 f5 66 6f f0       	mov    0xf06f66f5,%al
f010df70:	83 e0 ef             	and    $0xffffffef,%eax
f010df73:	a2 f5 66 6f f0       	mov    %al,0xf06f66f5
f010df78:	a0 f5 66 6f f0       	mov    0xf06f66f5,%al
f010df7d:	83 c8 60             	or     $0x60,%eax
f010df80:	a2 f5 66 6f f0       	mov    %al,0xf06f66f5
f010df85:	a0 f5 66 6f f0       	mov    0xf06f66f5,%al
f010df8a:	83 c8 80             	or     $0xffffff80,%eax
f010df8d:	a2 f5 66 6f f0       	mov    %al,0xf06f66f5
f010df92:	b8 5c e9 10 f0       	mov    $0xf010e95c,%eax
f010df97:	c1 e8 10             	shr    $0x10,%eax
f010df9a:	66 a3 f6 66 6f f0    	mov    %ax,0xf06f66f6
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010dfa0:	b8 62 e9 10 f0       	mov    $0xf010e962,%eax
f010dfa5:	66 a3 f8 66 6f f0    	mov    %ax,0xf06f66f8
f010dfab:	66 c7 05 fa 66 6f f0 	movw   $0x8,0xf06f66fa
f010dfb2:	08 00 
f010dfb4:	a0 fc 66 6f f0       	mov    0xf06f66fc,%al
f010dfb9:	83 e0 e0             	and    $0xffffffe0,%eax
f010dfbc:	a2 fc 66 6f f0       	mov    %al,0xf06f66fc
f010dfc1:	a0 fc 66 6f f0       	mov    0xf06f66fc,%al
f010dfc6:	83 e0 1f             	and    $0x1f,%eax
f010dfc9:	a2 fc 66 6f f0       	mov    %al,0xf06f66fc
f010dfce:	a0 fd 66 6f f0       	mov    0xf06f66fd,%al
f010dfd3:	83 e0 f0             	and    $0xfffffff0,%eax
f010dfd6:	83 c8 0e             	or     $0xe,%eax
f010dfd9:	a2 fd 66 6f f0       	mov    %al,0xf06f66fd
f010dfde:	a0 fd 66 6f f0       	mov    0xf06f66fd,%al
f010dfe3:	83 e0 ef             	and    $0xffffffef,%eax
f010dfe6:	a2 fd 66 6f f0       	mov    %al,0xf06f66fd
f010dfeb:	a0 fd 66 6f f0       	mov    0xf06f66fd,%al
f010dff0:	83 c8 60             	or     $0x60,%eax
f010dff3:	a2 fd 66 6f f0       	mov    %al,0xf06f66fd
f010dff8:	a0 fd 66 6f f0       	mov    0xf06f66fd,%al
f010dffd:	83 c8 80             	or     $0xffffff80,%eax
f010e000:	a2 fd 66 6f f0       	mov    %al,0xf06f66fd
f010e005:	b8 62 e9 10 f0       	mov    $0xf010e962,%eax
f010e00a:	c1 e8 10             	shr    $0x10,%eax
f010e00d:	66 a3 fe 66 6f f0    	mov    %ax,0xf06f66fe
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010e013:	b8 68 e9 10 f0       	mov    $0xf010e968,%eax
f010e018:	66 a3 00 67 6f f0    	mov    %ax,0xf06f6700
f010e01e:	66 c7 05 02 67 6f f0 	movw   $0x8,0xf06f6702
f010e025:	08 00 
f010e027:	a0 04 67 6f f0       	mov    0xf06f6704,%al
f010e02c:	83 e0 e0             	and    $0xffffffe0,%eax
f010e02f:	a2 04 67 6f f0       	mov    %al,0xf06f6704
f010e034:	a0 04 67 6f f0       	mov    0xf06f6704,%al
f010e039:	83 e0 1f             	and    $0x1f,%eax
f010e03c:	a2 04 67 6f f0       	mov    %al,0xf06f6704
f010e041:	a0 05 67 6f f0       	mov    0xf06f6705,%al
f010e046:	83 e0 f0             	and    $0xfffffff0,%eax
f010e049:	83 c8 0e             	or     $0xe,%eax
f010e04c:	a2 05 67 6f f0       	mov    %al,0xf06f6705
f010e051:	a0 05 67 6f f0       	mov    0xf06f6705,%al
f010e056:	83 e0 ef             	and    $0xffffffef,%eax
f010e059:	a2 05 67 6f f0       	mov    %al,0xf06f6705
f010e05e:	a0 05 67 6f f0       	mov    0xf06f6705,%al
f010e063:	83 c8 60             	or     $0x60,%eax
f010e066:	a2 05 67 6f f0       	mov    %al,0xf06f6705
f010e06b:	a0 05 67 6f f0       	mov    0xf06f6705,%al
f010e070:	83 c8 80             	or     $0xffffff80,%eax
f010e073:	a2 05 67 6f f0       	mov    %al,0xf06f6705
f010e078:	b8 68 e9 10 f0       	mov    $0xf010e968,%eax
f010e07d:	c1 e8 10             	shr    $0x10,%eax
f010e080:	66 a3 06 67 6f f0    	mov    %ax,0xf06f6706
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010e086:	b8 6e e9 10 f0       	mov    $0xf010e96e,%eax
f010e08b:	66 a3 08 67 6f f0    	mov    %ax,0xf06f6708
f010e091:	66 c7 05 0a 67 6f f0 	movw   $0x8,0xf06f670a
f010e098:	08 00 
f010e09a:	a0 0c 67 6f f0       	mov    0xf06f670c,%al
f010e09f:	83 e0 e0             	and    $0xffffffe0,%eax
f010e0a2:	a2 0c 67 6f f0       	mov    %al,0xf06f670c
f010e0a7:	a0 0c 67 6f f0       	mov    0xf06f670c,%al
f010e0ac:	83 e0 1f             	and    $0x1f,%eax
f010e0af:	a2 0c 67 6f f0       	mov    %al,0xf06f670c
f010e0b4:	a0 0d 67 6f f0       	mov    0xf06f670d,%al
f010e0b9:	83 e0 f0             	and    $0xfffffff0,%eax
f010e0bc:	83 c8 0e             	or     $0xe,%eax
f010e0bf:	a2 0d 67 6f f0       	mov    %al,0xf06f670d
f010e0c4:	a0 0d 67 6f f0       	mov    0xf06f670d,%al
f010e0c9:	83 e0 ef             	and    $0xffffffef,%eax
f010e0cc:	a2 0d 67 6f f0       	mov    %al,0xf06f670d
f010e0d1:	a0 0d 67 6f f0       	mov    0xf06f670d,%al
f010e0d6:	83 c8 60             	or     $0x60,%eax
f010e0d9:	a2 0d 67 6f f0       	mov    %al,0xf06f670d
f010e0de:	a0 0d 67 6f f0       	mov    0xf06f670d,%al
f010e0e3:	83 c8 80             	or     $0xffffff80,%eax
f010e0e6:	a2 0d 67 6f f0       	mov    %al,0xf06f670d
f010e0eb:	b8 6e e9 10 f0       	mov    $0xf010e96e,%eax
f010e0f0:	c1 e8 10             	shr    $0x10,%eax
f010e0f3:	66 a3 0e 67 6f f0    	mov    %ax,0xf06f670e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010e0f9:	b8 74 e9 10 f0       	mov    $0xf010e974,%eax
f010e0fe:	66 a3 10 67 6f f0    	mov    %ax,0xf06f6710
f010e104:	66 c7 05 12 67 6f f0 	movw   $0x8,0xf06f6712
f010e10b:	08 00 
f010e10d:	a0 14 67 6f f0       	mov    0xf06f6714,%al
f010e112:	83 e0 e0             	and    $0xffffffe0,%eax
f010e115:	a2 14 67 6f f0       	mov    %al,0xf06f6714
f010e11a:	a0 14 67 6f f0       	mov    0xf06f6714,%al
f010e11f:	83 e0 1f             	and    $0x1f,%eax
f010e122:	a2 14 67 6f f0       	mov    %al,0xf06f6714
f010e127:	a0 15 67 6f f0       	mov    0xf06f6715,%al
f010e12c:	83 e0 f0             	and    $0xfffffff0,%eax
f010e12f:	83 c8 0e             	or     $0xe,%eax
f010e132:	a2 15 67 6f f0       	mov    %al,0xf06f6715
f010e137:	a0 15 67 6f f0       	mov    0xf06f6715,%al
f010e13c:	83 e0 ef             	and    $0xffffffef,%eax
f010e13f:	a2 15 67 6f f0       	mov    %al,0xf06f6715
f010e144:	a0 15 67 6f f0       	mov    0xf06f6715,%al
f010e149:	83 c8 60             	or     $0x60,%eax
f010e14c:	a2 15 67 6f f0       	mov    %al,0xf06f6715
f010e151:	a0 15 67 6f f0       	mov    0xf06f6715,%al
f010e156:	83 c8 80             	or     $0xffffff80,%eax
f010e159:	a2 15 67 6f f0       	mov    %al,0xf06f6715
f010e15e:	b8 74 e9 10 f0       	mov    $0xf010e974,%eax
f010e163:	c1 e8 10             	shr    $0x10,%eax
f010e166:	66 a3 16 67 6f f0    	mov    %ax,0xf06f6716
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010e16c:	b8 7a e9 10 f0       	mov    $0xf010e97a,%eax
f010e171:	66 a3 18 67 6f f0    	mov    %ax,0xf06f6718
f010e177:	66 c7 05 1a 67 6f f0 	movw   $0x8,0xf06f671a
f010e17e:	08 00 
f010e180:	a0 1c 67 6f f0       	mov    0xf06f671c,%al
f010e185:	83 e0 e0             	and    $0xffffffe0,%eax
f010e188:	a2 1c 67 6f f0       	mov    %al,0xf06f671c
f010e18d:	a0 1c 67 6f f0       	mov    0xf06f671c,%al
f010e192:	83 e0 1f             	and    $0x1f,%eax
f010e195:	a2 1c 67 6f f0       	mov    %al,0xf06f671c
f010e19a:	a0 1d 67 6f f0       	mov    0xf06f671d,%al
f010e19f:	83 e0 f0             	and    $0xfffffff0,%eax
f010e1a2:	83 c8 0e             	or     $0xe,%eax
f010e1a5:	a2 1d 67 6f f0       	mov    %al,0xf06f671d
f010e1aa:	a0 1d 67 6f f0       	mov    0xf06f671d,%al
f010e1af:	83 e0 ef             	and    $0xffffffef,%eax
f010e1b2:	a2 1d 67 6f f0       	mov    %al,0xf06f671d
f010e1b7:	a0 1d 67 6f f0       	mov    0xf06f671d,%al
f010e1bc:	83 c8 60             	or     $0x60,%eax
f010e1bf:	a2 1d 67 6f f0       	mov    %al,0xf06f671d
f010e1c4:	a0 1d 67 6f f0       	mov    0xf06f671d,%al
f010e1c9:	83 c8 80             	or     $0xffffff80,%eax
f010e1cc:	a2 1d 67 6f f0       	mov    %al,0xf06f671d
f010e1d1:	b8 7a e9 10 f0       	mov    $0xf010e97a,%eax
f010e1d6:	c1 e8 10             	shr    $0x10,%eax
f010e1d9:	66 a3 1e 67 6f f0    	mov    %ax,0xf06f671e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010e1df:	b8 80 e9 10 f0       	mov    $0xf010e980,%eax
f010e1e4:	66 a3 20 67 6f f0    	mov    %ax,0xf06f6720
f010e1ea:	66 c7 05 22 67 6f f0 	movw   $0x8,0xf06f6722
f010e1f1:	08 00 
f010e1f3:	a0 24 67 6f f0       	mov    0xf06f6724,%al
f010e1f8:	83 e0 e0             	and    $0xffffffe0,%eax
f010e1fb:	a2 24 67 6f f0       	mov    %al,0xf06f6724
f010e200:	a0 24 67 6f f0       	mov    0xf06f6724,%al
f010e205:	83 e0 1f             	and    $0x1f,%eax
f010e208:	a2 24 67 6f f0       	mov    %al,0xf06f6724
f010e20d:	a0 25 67 6f f0       	mov    0xf06f6725,%al
f010e212:	83 e0 f0             	and    $0xfffffff0,%eax
f010e215:	83 c8 0e             	or     $0xe,%eax
f010e218:	a2 25 67 6f f0       	mov    %al,0xf06f6725
f010e21d:	a0 25 67 6f f0       	mov    0xf06f6725,%al
f010e222:	83 e0 ef             	and    $0xffffffef,%eax
f010e225:	a2 25 67 6f f0       	mov    %al,0xf06f6725
f010e22a:	a0 25 67 6f f0       	mov    0xf06f6725,%al
f010e22f:	83 c8 60             	or     $0x60,%eax
f010e232:	a2 25 67 6f f0       	mov    %al,0xf06f6725
f010e237:	a0 25 67 6f f0       	mov    0xf06f6725,%al
f010e23c:	83 c8 80             	or     $0xffffff80,%eax
f010e23f:	a2 25 67 6f f0       	mov    %al,0xf06f6725
f010e244:	b8 80 e9 10 f0       	mov    $0xf010e980,%eax
f010e249:	c1 e8 10             	shr    $0x10,%eax
f010e24c:	66 a3 26 67 6f f0    	mov    %ax,0xf06f6726
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010e252:	b8 86 e9 10 f0       	mov    $0xf010e986,%eax
f010e257:	66 a3 28 67 6f f0    	mov    %ax,0xf06f6728
f010e25d:	66 c7 05 2a 67 6f f0 	movw   $0x8,0xf06f672a
f010e264:	08 00 
f010e266:	a0 2c 67 6f f0       	mov    0xf06f672c,%al
f010e26b:	83 e0 e0             	and    $0xffffffe0,%eax
f010e26e:	a2 2c 67 6f f0       	mov    %al,0xf06f672c
f010e273:	a0 2c 67 6f f0       	mov    0xf06f672c,%al
f010e278:	83 e0 1f             	and    $0x1f,%eax
f010e27b:	a2 2c 67 6f f0       	mov    %al,0xf06f672c
f010e280:	a0 2d 67 6f f0       	mov    0xf06f672d,%al
f010e285:	83 e0 f0             	and    $0xfffffff0,%eax
f010e288:	83 c8 0e             	or     $0xe,%eax
f010e28b:	a2 2d 67 6f f0       	mov    %al,0xf06f672d
f010e290:	a0 2d 67 6f f0       	mov    0xf06f672d,%al
f010e295:	83 e0 ef             	and    $0xffffffef,%eax
f010e298:	a2 2d 67 6f f0       	mov    %al,0xf06f672d
f010e29d:	a0 2d 67 6f f0       	mov    0xf06f672d,%al
f010e2a2:	83 c8 60             	or     $0x60,%eax
f010e2a5:	a2 2d 67 6f f0       	mov    %al,0xf06f672d
f010e2aa:	a0 2d 67 6f f0       	mov    0xf06f672d,%al
f010e2af:	83 c8 80             	or     $0xffffff80,%eax
f010e2b2:	a2 2d 67 6f f0       	mov    %al,0xf06f672d
f010e2b7:	b8 86 e9 10 f0       	mov    $0xf010e986,%eax
f010e2bc:	c1 e8 10             	shr    $0x10,%eax
f010e2bf:	66 a3 2e 67 6f f0    	mov    %ax,0xf06f672e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010e2c5:	b8 8c e9 10 f0       	mov    $0xf010e98c,%eax
f010e2ca:	66 a3 30 67 6f f0    	mov    %ax,0xf06f6730
f010e2d0:	66 c7 05 32 67 6f f0 	movw   $0x8,0xf06f6732
f010e2d7:	08 00 
f010e2d9:	a0 34 67 6f f0       	mov    0xf06f6734,%al
f010e2de:	83 e0 e0             	and    $0xffffffe0,%eax
f010e2e1:	a2 34 67 6f f0       	mov    %al,0xf06f6734
f010e2e6:	a0 34 67 6f f0       	mov    0xf06f6734,%al
f010e2eb:	83 e0 1f             	and    $0x1f,%eax
f010e2ee:	a2 34 67 6f f0       	mov    %al,0xf06f6734
f010e2f3:	a0 35 67 6f f0       	mov    0xf06f6735,%al
f010e2f8:	83 e0 f0             	and    $0xfffffff0,%eax
f010e2fb:	83 c8 0e             	or     $0xe,%eax
f010e2fe:	a2 35 67 6f f0       	mov    %al,0xf06f6735
f010e303:	a0 35 67 6f f0       	mov    0xf06f6735,%al
f010e308:	83 e0 ef             	and    $0xffffffef,%eax
f010e30b:	a2 35 67 6f f0       	mov    %al,0xf06f6735
f010e310:	a0 35 67 6f f0       	mov    0xf06f6735,%al
f010e315:	83 c8 60             	or     $0x60,%eax
f010e318:	a2 35 67 6f f0       	mov    %al,0xf06f6735
f010e31d:	a0 35 67 6f f0       	mov    0xf06f6735,%al
f010e322:	83 c8 80             	or     $0xffffff80,%eax
f010e325:	a2 35 67 6f f0       	mov    %al,0xf06f6735
f010e32a:	b8 8c e9 10 f0       	mov    $0xf010e98c,%eax
f010e32f:	c1 e8 10             	shr    $0x10,%eax
f010e332:	66 a3 36 67 6f f0    	mov    %ax,0xf06f6736
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010e338:	b8 92 e9 10 f0       	mov    $0xf010e992,%eax
f010e33d:	66 a3 38 67 6f f0    	mov    %ax,0xf06f6738
f010e343:	66 c7 05 3a 67 6f f0 	movw   $0x8,0xf06f673a
f010e34a:	08 00 
f010e34c:	a0 3c 67 6f f0       	mov    0xf06f673c,%al
f010e351:	83 e0 e0             	and    $0xffffffe0,%eax
f010e354:	a2 3c 67 6f f0       	mov    %al,0xf06f673c
f010e359:	a0 3c 67 6f f0       	mov    0xf06f673c,%al
f010e35e:	83 e0 1f             	and    $0x1f,%eax
f010e361:	a2 3c 67 6f f0       	mov    %al,0xf06f673c
f010e366:	a0 3d 67 6f f0       	mov    0xf06f673d,%al
f010e36b:	83 e0 f0             	and    $0xfffffff0,%eax
f010e36e:	83 c8 0e             	or     $0xe,%eax
f010e371:	a2 3d 67 6f f0       	mov    %al,0xf06f673d
f010e376:	a0 3d 67 6f f0       	mov    0xf06f673d,%al
f010e37b:	83 e0 ef             	and    $0xffffffef,%eax
f010e37e:	a2 3d 67 6f f0       	mov    %al,0xf06f673d
f010e383:	a0 3d 67 6f f0       	mov    0xf06f673d,%al
f010e388:	83 c8 60             	or     $0x60,%eax
f010e38b:	a2 3d 67 6f f0       	mov    %al,0xf06f673d
f010e390:	a0 3d 67 6f f0       	mov    0xf06f673d,%al
f010e395:	83 c8 80             	or     $0xffffff80,%eax
f010e398:	a2 3d 67 6f f0       	mov    %al,0xf06f673d
f010e39d:	b8 92 e9 10 f0       	mov    $0xf010e992,%eax
f010e3a2:	c1 e8 10             	shr    $0x10,%eax
f010e3a5:	66 a3 3e 67 6f f0    	mov    %ax,0xf06f673e
f010e3ab:	c7 45 fc c0 65 6f f0 	movl   $0xf06f65c0,-0x4(%ebp)
f010e3b2:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010e3b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e3bc:	48                   	dec    %eax
f010e3bd:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010e3c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e3c4:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010e3c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e3cb:	c1 e8 10             	shr    $0x10,%eax
f010e3ce:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010e3d2:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010e3d5:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010e3d8:	90                   	nop
f010e3d9:	c9                   	leave  
f010e3da:	c3                   	ret    

f010e3db <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010e3db:	55                   	push   %ebp
f010e3dc:	89 e5                	mov    %esp,%ebp
f010e3de:	53                   	push   %ebx
f010e3df:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010e3e2:	83 ec 08             	sub    $0x8,%esp
f010e3e5:	ff 75 08             	pushl  0x8(%ebp)
f010e3e8:	68 7e 79 12 f0       	push   $0xf012797e
f010e3ed:	e8 99 2b ff ff       	call   f0100f8b <cprintf>
f010e3f2:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010e3f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3f8:	83 ec 0c             	sub    $0xc,%esp
f010e3fb:	50                   	push   %eax
f010e3fc:	e8 fd 00 00 00       	call   f010e4fe <print_regs>
f010e401:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e404:	8b 45 08             	mov    0x8(%ebp),%eax
f010e407:	8b 40 20             	mov    0x20(%eax),%eax
f010e40a:	0f b7 c0             	movzwl %ax,%eax
f010e40d:	83 ec 08             	sub    $0x8,%esp
f010e410:	50                   	push   %eax
f010e411:	68 90 79 12 f0       	push   $0xf0127990
f010e416:	e8 70 2b ff ff       	call   f0100f8b <cprintf>
f010e41b:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e41e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e421:	8b 40 24             	mov    0x24(%eax),%eax
f010e424:	0f b7 c0             	movzwl %ax,%eax
f010e427:	83 ec 08             	sub    $0x8,%esp
f010e42a:	50                   	push   %eax
f010e42b:	68 a3 79 12 f0       	push   $0xf01279a3
f010e430:	e8 56 2b ff ff       	call   f0100f8b <cprintf>
f010e435:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e438:	8b 45 08             	mov    0x8(%ebp),%eax
f010e43b:	8b 58 28             	mov    0x28(%eax),%ebx
f010e43e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e441:	8b 40 28             	mov    0x28(%eax),%eax
f010e444:	83 ec 0c             	sub    $0xc,%esp
f010e447:	50                   	push   %eax
f010e448:	e8 28 ee ff ff       	call   f010d275 <trapname>
f010e44d:	83 c4 10             	add    $0x10,%esp
f010e450:	89 c2                	mov    %eax,%edx
f010e452:	8b 45 08             	mov    0x8(%ebp),%eax
f010e455:	8b 40 28             	mov    0x28(%eax),%eax
f010e458:	53                   	push   %ebx
f010e459:	52                   	push   %edx
f010e45a:	50                   	push   %eax
f010e45b:	68 b6 79 12 f0       	push   $0xf01279b6
f010e460:	e8 26 2b ff ff       	call   f0100f8b <cprintf>
f010e465:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e468:	8b 45 08             	mov    0x8(%ebp),%eax
f010e46b:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e46e:	83 ec 08             	sub    $0x8,%esp
f010e471:	50                   	push   %eax
f010e472:	68 cd 79 12 f0       	push   $0xf01279cd
f010e477:	e8 0f 2b ff ff       	call   f0100f8b <cprintf>
f010e47c:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e47f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e482:	8b 40 30             	mov    0x30(%eax),%eax
f010e485:	83 ec 08             	sub    $0x8,%esp
f010e488:	50                   	push   %eax
f010e489:	68 dc 79 12 f0       	push   $0xf01279dc
f010e48e:	e8 f8 2a ff ff       	call   f0100f8b <cprintf>
f010e493:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e496:	8b 45 08             	mov    0x8(%ebp),%eax
f010e499:	8b 40 34             	mov    0x34(%eax),%eax
f010e49c:	0f b7 c0             	movzwl %ax,%eax
f010e49f:	83 ec 08             	sub    $0x8,%esp
f010e4a2:	50                   	push   %eax
f010e4a3:	68 eb 79 12 f0       	push   $0xf01279eb
f010e4a8:	e8 de 2a ff ff       	call   f0100f8b <cprintf>
f010e4ad:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e4b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4b3:	8b 40 38             	mov    0x38(%eax),%eax
f010e4b6:	83 ec 08             	sub    $0x8,%esp
f010e4b9:	50                   	push   %eax
f010e4ba:	68 fe 79 12 f0       	push   $0xf01279fe
f010e4bf:	e8 c7 2a ff ff       	call   f0100f8b <cprintf>
f010e4c4:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e4c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4ca:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e4cd:	83 ec 08             	sub    $0x8,%esp
f010e4d0:	50                   	push   %eax
f010e4d1:	68 0d 7a 12 f0       	push   $0xf0127a0d
f010e4d6:	e8 b0 2a ff ff       	call   f0100f8b <cprintf>
f010e4db:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e4de:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4e1:	8b 40 40             	mov    0x40(%eax),%eax
f010e4e4:	0f b7 c0             	movzwl %ax,%eax
f010e4e7:	83 ec 08             	sub    $0x8,%esp
f010e4ea:	50                   	push   %eax
f010e4eb:	68 1c 7a 12 f0       	push   $0xf0127a1c
f010e4f0:	e8 96 2a ff ff       	call   f0100f8b <cprintf>
f010e4f5:	83 c4 10             	add    $0x10,%esp
}
f010e4f8:	90                   	nop
f010e4f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e4fc:	c9                   	leave  
f010e4fd:	c3                   	ret    

f010e4fe <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e4fe:	55                   	push   %ebp
f010e4ff:	89 e5                	mov    %esp,%ebp
f010e501:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e504:	8b 45 08             	mov    0x8(%ebp),%eax
f010e507:	8b 00                	mov    (%eax),%eax
f010e509:	83 ec 08             	sub    $0x8,%esp
f010e50c:	50                   	push   %eax
f010e50d:	68 2f 7a 12 f0       	push   $0xf0127a2f
f010e512:	e8 74 2a ff ff       	call   f0100f8b <cprintf>
f010e517:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e51a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e51d:	8b 40 04             	mov    0x4(%eax),%eax
f010e520:	83 ec 08             	sub    $0x8,%esp
f010e523:	50                   	push   %eax
f010e524:	68 3e 7a 12 f0       	push   $0xf0127a3e
f010e529:	e8 5d 2a ff ff       	call   f0100f8b <cprintf>
f010e52e:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e531:	8b 45 08             	mov    0x8(%ebp),%eax
f010e534:	8b 40 08             	mov    0x8(%eax),%eax
f010e537:	83 ec 08             	sub    $0x8,%esp
f010e53a:	50                   	push   %eax
f010e53b:	68 4d 7a 12 f0       	push   $0xf0127a4d
f010e540:	e8 46 2a ff ff       	call   f0100f8b <cprintf>
f010e545:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e548:	8b 45 08             	mov    0x8(%ebp),%eax
f010e54b:	8b 40 0c             	mov    0xc(%eax),%eax
f010e54e:	83 ec 08             	sub    $0x8,%esp
f010e551:	50                   	push   %eax
f010e552:	68 5c 7a 12 f0       	push   $0xf0127a5c
f010e557:	e8 2f 2a ff ff       	call   f0100f8b <cprintf>
f010e55c:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e55f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e562:	8b 40 10             	mov    0x10(%eax),%eax
f010e565:	83 ec 08             	sub    $0x8,%esp
f010e568:	50                   	push   %eax
f010e569:	68 6b 7a 12 f0       	push   $0xf0127a6b
f010e56e:	e8 18 2a ff ff       	call   f0100f8b <cprintf>
f010e573:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e576:	8b 45 08             	mov    0x8(%ebp),%eax
f010e579:	8b 40 14             	mov    0x14(%eax),%eax
f010e57c:	83 ec 08             	sub    $0x8,%esp
f010e57f:	50                   	push   %eax
f010e580:	68 7a 7a 12 f0       	push   $0xf0127a7a
f010e585:	e8 01 2a ff ff       	call   f0100f8b <cprintf>
f010e58a:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e58d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e590:	8b 40 18             	mov    0x18(%eax),%eax
f010e593:	83 ec 08             	sub    $0x8,%esp
f010e596:	50                   	push   %eax
f010e597:	68 89 7a 12 f0       	push   $0xf0127a89
f010e59c:	e8 ea 29 ff ff       	call   f0100f8b <cprintf>
f010e5a1:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e5a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5a7:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e5aa:	83 ec 08             	sub    $0x8,%esp
f010e5ad:	50                   	push   %eax
f010e5ae:	68 98 7a 12 f0       	push   $0xf0127a98
f010e5b3:	e8 d3 29 ff ff       	call   f0100f8b <cprintf>
f010e5b8:	83 c4 10             	add    $0x10,%esp
}
f010e5bb:	90                   	nop
f010e5bc:	c9                   	leave  
f010e5bd:	c3                   	ret    

f010e5be <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e5be:	55                   	push   %ebp
f010e5bf:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e5c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5c4:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e5c7:	89 14 85 c0 6d 6f f0 	mov    %edx,-0xf909240(,%eax,4)
}
f010e5ce:	90                   	nop
f010e5cf:	5d                   	pop    %ebp
f010e5d0:	c3                   	ret    

f010e5d1 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e5d1:	55                   	push   %ebp
f010e5d2:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e5d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5d7:	c7 04 85 c0 6d 6f f0 	movl   $0x0,-0xf909240(,%eax,4)
f010e5de:	00 00 00 00 
}
f010e5e2:	90                   	nop
f010e5e3:	5d                   	pop    %ebp
f010e5e4:	c3                   	ret    

f010e5e5 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e5e5:	55                   	push   %ebp
f010e5e6:	89 e5                	mov    %esp,%ebp
f010e5e8:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e5eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5ee:	8b 40 28             	mov    0x28(%eax),%eax
f010e5f1:	83 e8 20             	sub    $0x20,%eax
f010e5f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e5f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5fa:	8b 04 85 c0 6d 6f f0 	mov    -0xf909240(,%eax,4),%eax
f010e601:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e604:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e608:	74 0e                	je     f010e618 <irq_dispatch+0x33>
	{
		handler(tf);
f010e60a:	83 ec 0c             	sub    $0xc,%esp
f010e60d:	ff 75 08             	pushl  0x8(%ebp)
f010e610:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e613:	ff d0                	call   *%eax
f010e615:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e618:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e61b:	0f b6 c0             	movzbl %al,%eax
f010e61e:	83 ec 0c             	sub    $0xc,%esp
f010e621:	50                   	push   %eax
f010e622:	e8 d7 8d ff ff       	call   f01073fe <pic_sendEOI>
f010e627:	83 c4 10             	add    $0x10,%esp
}
f010e62a:	90                   	nop
f010e62b:	c9                   	leave  
f010e62c:	c3                   	ret    

f010e62d <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e62d:	55                   	push   %ebp
f010e62e:	89 e5                	mov    %esp,%ebp
f010e630:	57                   	push   %edi
f010e631:	56                   	push   %esi
f010e632:	53                   	push   %ebx
f010e633:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010e636:	8b 45 08             	mov    0x8(%ebp),%eax
f010e639:	8b 40 28             	mov    0x28(%eax),%eax
f010e63c:	83 f8 0e             	cmp    $0xe,%eax
f010e63f:	75 51                	jne    f010e692 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e641:	a0 00 6e 6f f0       	mov    0xf06f6e00,%al
f010e646:	84 c0                	test   %al,%al
f010e648:	74 1f                	je     f010e669 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e64a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e64d:	8b 40 30             	mov    0x30(%eax),%eax
f010e650:	89 c2                	mov    %eax,%edx
f010e652:	a0 00 6e 6f f0       	mov    0xf06f6e00,%al
f010e657:	0f b6 c0             	movzbl %al,%eax
f010e65a:	01 d0                	add    %edx,%eax
f010e65c:	89 c2                	mov    %eax,%edx
f010e65e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e661:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e664:	e9 0c 01 00 00       	jmp    f010e775 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e669:	83 ec 0c             	sub    $0xc,%esp
f010e66c:	6a 01                	push   $0x1
f010e66e:	e8 ee 12 00 00       	call   f010f961 <isPageReplacmentAlgorithmLRU>
f010e673:	83 c4 10             	add    $0x10,%esp
f010e676:	85 c0                	test   %eax,%eax
f010e678:	74 05                	je     f010e67f <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e67a:	e8 ee 88 ff ff       	call   f0106f6d <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e67f:	83 ec 0c             	sub    $0xc,%esp
f010e682:	ff 75 08             	pushl  0x8(%ebp)
f010e685:	e8 bc 13 00 00       	call   f010fa46 <fault_handler>
f010e68a:	83 c4 10             	add    $0x10,%esp
f010e68d:	e9 e3 00 00 00       	jmp    f010e775 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e692:	8b 45 08             	mov    0x8(%ebp),%eax
f010e695:	8b 40 28             	mov    0x28(%eax),%eax
f010e698:	83 f8 30             	cmp    $0x30,%eax
f010e69b:	75 6e                	jne    f010e70b <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e69d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6a0:	8b 40 38             	mov    0x38(%eax),%eax
f010e6a3:	25 00 02 00 00       	and    $0x200,%eax
f010e6a8:	85 c0                	test   %eax,%eax
f010e6aa:	74 06                	je     f010e6b2 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e6ac:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e6ad:	e8 1e 68 ff ff       	call   f0104ed0 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e6b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6b5:	8b 78 04             	mov    0x4(%eax),%edi
f010e6b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6bb:	8b 30                	mov    (%eax),%esi
f010e6bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6c0:	8b 58 10             	mov    0x10(%eax),%ebx
f010e6c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6c6:	8b 48 18             	mov    0x18(%eax),%ecx
f010e6c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6cc:	8b 50 14             	mov    0x14(%eax),%edx
f010e6cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6d2:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e6d5:	83 ec 08             	sub    $0x8,%esp
f010e6d8:	57                   	push   %edi
f010e6d9:	56                   	push   %esi
f010e6da:	53                   	push   %ebx
f010e6db:	51                   	push   %ecx
f010e6dc:	52                   	push   %edx
f010e6dd:	50                   	push   %eax
f010e6de:	e8 a5 09 00 00       	call   f010f088 <syscall>
f010e6e3:	83 c4 20             	add    $0x20,%esp
f010e6e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e6e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6ec:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e6ef:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e6f2:	9c                   	pushf  
f010e6f3:	58                   	pop    %eax
f010e6f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e6f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e6fa:	25 00 02 00 00       	and    $0x200,%eax
f010e6ff:	85 c0                	test   %eax,%eax
f010e701:	74 72                	je     f010e775 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e703:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e704:	e8 9f 67 ff ff       	call   f0104ea8 <kclock_stop>
f010e709:	eb 6a                	jmp    f010e775 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e70b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e70e:	8b 40 28             	mov    0x28(%eax),%eax
f010e711:	83 f8 08             	cmp    $0x8,%eax
f010e714:	75 17                	jne    f010e72d <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e716:	83 ec 04             	sub    $0x4,%esp
f010e719:	68 a7 7a 12 f0       	push   $0xf0127aa7
f010e71e:	68 22 01 00 00       	push   $0x122
f010e723:	68 b6 7a 12 f0       	push   $0xf0127ab6
f010e728:	e8 0c 1c ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e72d:	83 ec 0c             	sub    $0xc,%esp
f010e730:	ff 75 08             	pushl  0x8(%ebp)
f010e733:	e8 a3 fc ff ff       	call   f010e3db <print_trapframe>
f010e738:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e73b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e73e:	8b 40 34             	mov    0x34(%eax),%eax
f010e741:	66 83 f8 08          	cmp    $0x8,%ax
f010e745:	75 17                	jne    f010e75e <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e747:	83 ec 04             	sub    $0x4,%esp
f010e74a:	68 c7 7a 12 f0       	push   $0xf0127ac7
f010e74f:	68 2a 01 00 00       	push   $0x12a
f010e754:	68 b6 7a 12 f0       	push   $0xf0127ab6
f010e759:	e8 db 1b ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e75e:	83 ec 04             	sub    $0x4,%esp
f010e761:	68 e0 7a 12 f0       	push   $0xf0127ae0
f010e766:	68 2f 01 00 00       	push   $0x12f
f010e76b:	68 b6 7a 12 f0       	push   $0xf0127ab6
f010e770:	e8 c4 1b ff ff       	call   f0100339 <_panic>
		}
	}
}
f010e775:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e778:	5b                   	pop    %ebx
f010e779:	5e                   	pop    %esi
f010e77a:	5f                   	pop    %edi
f010e77b:	5d                   	pop    %ebp
f010e77c:	c3                   	ret    

f010e77d <trap>:

void trap(struct Trapframe *tf)
{
f010e77d:	55                   	push   %ebp
f010e77e:	89 e5                	mov    %esp,%ebp
f010e780:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e783:	e8 20 67 ff ff       	call   f0104ea8 <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e788:	9c                   	pushf  
f010e789:	58                   	pop    %eax
f010e78a:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010e78d:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e790:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010e793:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e796:	25 00 02 00 00       	and    $0x200,%eax
f010e79b:	85 c0                	test   %eax,%eax
f010e79d:	74 25                	je     f010e7c4 <trap+0x47>
	{
		print_trapframe(tf);
f010e79f:	83 ec 0c             	sub    $0xc,%esp
f010e7a2:	ff 75 08             	pushl  0x8(%ebp)
f010e7a5:	e8 31 fc ff ff       	call   f010e3db <print_trapframe>
f010e7aa:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e7ad:	83 ec 04             	sub    $0x4,%esp
f010e7b0:	68 00 7b 12 f0       	push   $0xf0127b00
f010e7b5:	68 45 01 00 00       	push   $0x145
f010e7ba:	68 b6 7a 12 f0       	push   $0xf0127ab6
f010e7bf:	e8 75 1b ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010e7c4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e7cb:	e8 55 d5 ff ff       	call   f010bd25 <get_cpu_proc>
f010e7d0:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e7d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7d6:	8b 40 34             	mov    0x34(%eax),%eax
f010e7d9:	0f b7 c0             	movzwl %ax,%eax
f010e7dc:	83 e0 03             	and    $0x3,%eax
f010e7df:	83 f8 03             	cmp    $0x3,%eax
f010e7e2:	75 54                	jne    f010e838 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e7e4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e7e8:	74 0b                	je     f010e7f5 <trap+0x78>
f010e7ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e7ed:	8b 40 18             	mov    0x18(%eax),%eax
f010e7f0:	83 f8 02             	cmp    $0x2,%eax
f010e7f3:	74 19                	je     f010e80e <trap+0x91>
f010e7f5:	68 44 7b 12 f0       	push   $0xf0127b44
f010e7fa:	68 72 7b 12 f0       	push   $0xf0127b72
f010e7ff:	68 4d 01 00 00       	push   $0x14d
f010e804:	68 b6 7a 12 f0       	push   $0xf0127ab6
f010e809:	e8 2b 1b ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010e80e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e811:	8b 00                	mov    (%eax),%eax
f010e813:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e816:	74 19                	je     f010e831 <trap+0xb4>
f010e818:	68 87 7b 12 f0       	push   $0xf0127b87
f010e81d:	68 72 7b 12 f0       	push   $0xf0127b72
f010e822:	68 4f 01 00 00       	push   $0x14f
f010e827:	68 b6 7a 12 f0       	push   $0xf0127ab6
f010e82c:	e8 08 1b ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010e831:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e838:	8b 45 08             	mov    0x8(%ebp),%eax
f010e83b:	8b 40 28             	mov    0x28(%eax),%eax
f010e83e:	83 f8 1f             	cmp    $0x1f,%eax
f010e841:	76 1b                	jbe    f010e85e <trap+0xe1>
f010e843:	8b 45 08             	mov    0x8(%ebp),%eax
f010e846:	8b 40 28             	mov    0x28(%eax),%eax
f010e849:	83 f8 2f             	cmp    $0x2f,%eax
f010e84c:	77 10                	ja     f010e85e <trap+0xe1>
	{
		irq_dispatch(tf);
f010e84e:	83 ec 0c             	sub    $0xc,%esp
f010e851:	ff 75 08             	pushl  0x8(%ebp)
f010e854:	e8 8c fd ff ff       	call   f010e5e5 <irq_dispatch>
f010e859:	83 c4 10             	add    $0x10,%esp
f010e85c:	eb 0e                	jmp    f010e86c <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010e85e:	83 ec 0c             	sub    $0xc,%esp
f010e861:	ff 75 08             	pushl  0x8(%ebp)
f010e864:	e8 c4 fd ff ff       	call   f010e62d <trap_dispatch>
f010e869:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e86c:	9c                   	pushf  
f010e86d:	58                   	pop    %eax
f010e86e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010e871:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e874:	25 00 02 00 00       	and    $0x200,%eax
f010e879:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010e87c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e880:	74 19                	je     f010e89b <trap+0x11e>
f010e882:	68 9d 7b 12 f0       	push   $0xf0127b9d
f010e887:	68 72 7b 12 f0       	push   $0xf0127b72
f010e88c:	68 66 01 00 00       	push   $0x166
f010e891:	68 b6 7a 12 f0       	push   $0xf0127ab6
f010e896:	e8 9e 1a ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e89b:	e8 30 66 ff ff       	call   f0104ed0 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e8a0:	90                   	nop
f010e8a1:	c9                   	leave  
f010e8a2:	c3                   	ret    
f010e8a3:	90                   	nop

f010e8a4 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e8a4:	6a 08                	push   $0x8
f010e8a6:	e9 ed 00 00 00       	jmp    f010e998 <_alltraps>
f010e8ab:	90                   	nop

f010e8ac <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e8ac:	6a 0e                	push   $0xe
f010e8ae:	e9 e5 00 00 00       	jmp    f010e998 <_alltraps>
f010e8b3:	90                   	nop

f010e8b4 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e8b4:	6a 00                	push   $0x0
f010e8b6:	6a 20                	push   $0x20
f010e8b8:	e9 db 00 00 00       	jmp    f010e998 <_alltraps>
f010e8bd:	90                   	nop

f010e8be <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e8be:	6a 00                	push   $0x0
f010e8c0:	6a 21                	push   $0x21
f010e8c2:	e9 d1 00 00 00       	jmp    f010e998 <_alltraps>
f010e8c7:	90                   	nop

f010e8c8 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e8c8:	6a 00                	push   $0x0
f010e8ca:	6a 30                	push   $0x30
f010e8cc:	e9 c7 00 00 00       	jmp    f010e998 <_alltraps>
f010e8d1:	90                   	nop

f010e8d2 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e8d2:	6a 00                	push   $0x0
f010e8d4:	6a 00                	push   $0x0
f010e8d6:	e9 bd 00 00 00       	jmp    f010e998 <_alltraps>
f010e8db:	90                   	nop

f010e8dc <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e8dc:	6a 00                	push   $0x0
f010e8de:	6a 01                	push   $0x1
f010e8e0:	e9 b3 00 00 00       	jmp    f010e998 <_alltraps>
f010e8e5:	90                   	nop

f010e8e6 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e8e6:	6a 00                	push   $0x0
f010e8e8:	6a 02                	push   $0x2
f010e8ea:	e9 a9 00 00 00       	jmp    f010e998 <_alltraps>
f010e8ef:	90                   	nop

f010e8f0 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e8f0:	6a 00                	push   $0x0
f010e8f2:	6a 03                	push   $0x3
f010e8f4:	e9 9f 00 00 00       	jmp    f010e998 <_alltraps>
f010e8f9:	90                   	nop

f010e8fa <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e8fa:	6a 00                	push   $0x0
f010e8fc:	6a 04                	push   $0x4
f010e8fe:	e9 95 00 00 00       	jmp    f010e998 <_alltraps>
f010e903:	90                   	nop

f010e904 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e904:	6a 00                	push   $0x0
f010e906:	6a 05                	push   $0x5
f010e908:	e9 8b 00 00 00       	jmp    f010e998 <_alltraps>
f010e90d:	90                   	nop

f010e90e <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e90e:	6a 00                	push   $0x0
f010e910:	6a 06                	push   $0x6
f010e912:	e9 81 00 00 00       	jmp    f010e998 <_alltraps>
f010e917:	90                   	nop

f010e918 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e918:	6a 00                	push   $0x0
f010e91a:	6a 07                	push   $0x7
f010e91c:	eb 7a                	jmp    f010e998 <_alltraps>

f010e91e <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e91e:	6a 0a                	push   $0xa
f010e920:	eb 76                	jmp    f010e998 <_alltraps>

f010e922 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e922:	6a 0b                	push   $0xb
f010e924:	eb 72                	jmp    f010e998 <_alltraps>

f010e926 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e926:	6a 0c                	push   $0xc
f010e928:	eb 6e                	jmp    f010e998 <_alltraps>

f010e92a <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e92a:	6a 0d                	push   $0xd
f010e92c:	eb 6a                	jmp    f010e998 <_alltraps>

f010e92e <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e92e:	6a 00                	push   $0x0
f010e930:	6a 10                	push   $0x10
f010e932:	eb 64                	jmp    f010e998 <_alltraps>

f010e934 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e934:	6a 11                	push   $0x11
f010e936:	eb 60                	jmp    f010e998 <_alltraps>

f010e938 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e938:	6a 00                	push   $0x0
f010e93a:	6a 12                	push   $0x12
f010e93c:	eb 5a                	jmp    f010e998 <_alltraps>

f010e93e <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e93e:	6a 00                	push   $0x0
f010e940:	6a 13                	push   $0x13
f010e942:	eb 54                	jmp    f010e998 <_alltraps>

f010e944 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e944:	6a 00                	push   $0x0
f010e946:	6a 22                	push   $0x22
f010e948:	eb 4e                	jmp    f010e998 <_alltraps>

f010e94a <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e94a:	6a 00                	push   $0x0
f010e94c:	6a 23                	push   $0x23
f010e94e:	eb 48                	jmp    f010e998 <_alltraps>

f010e950 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e950:	6a 00                	push   $0x0
f010e952:	6a 24                	push   $0x24
f010e954:	eb 42                	jmp    f010e998 <_alltraps>

f010e956 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e956:	6a 00                	push   $0x0
f010e958:	6a 25                	push   $0x25
f010e95a:	eb 3c                	jmp    f010e998 <_alltraps>

f010e95c <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e95c:	6a 00                	push   $0x0
f010e95e:	6a 26                	push   $0x26
f010e960:	eb 36                	jmp    f010e998 <_alltraps>

f010e962 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e962:	6a 00                	push   $0x0
f010e964:	6a 27                	push   $0x27
f010e966:	eb 30                	jmp    f010e998 <_alltraps>

f010e968 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e968:	6a 00                	push   $0x0
f010e96a:	6a 28                	push   $0x28
f010e96c:	eb 2a                	jmp    f010e998 <_alltraps>

f010e96e <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e96e:	6a 00                	push   $0x0
f010e970:	6a 29                	push   $0x29
f010e972:	eb 24                	jmp    f010e998 <_alltraps>

f010e974 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e974:	6a 00                	push   $0x0
f010e976:	6a 2a                	push   $0x2a
f010e978:	eb 1e                	jmp    f010e998 <_alltraps>

f010e97a <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e97a:	6a 00                	push   $0x0
f010e97c:	6a 2b                	push   $0x2b
f010e97e:	eb 18                	jmp    f010e998 <_alltraps>

f010e980 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e980:	6a 00                	push   $0x0
f010e982:	6a 2c                	push   $0x2c
f010e984:	eb 12                	jmp    f010e998 <_alltraps>

f010e986 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e986:	6a 00                	push   $0x0
f010e988:	6a 2d                	push   $0x2d
f010e98a:	eb 0c                	jmp    f010e998 <_alltraps>

f010e98c <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e98c:	6a 00                	push   $0x0
f010e98e:	6a 2e                	push   $0x2e
f010e990:	eb 06                	jmp    f010e998 <_alltraps>

f010e992 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e992:	6a 00                	push   $0x0
f010e994:	6a 2f                	push   $0x2f
f010e996:	eb 00                	jmp    f010e998 <_alltraps>

f010e998 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e998:	1e                   	push   %ds
push 	%es
f010e999:	06                   	push   %es
pushal
f010e99a:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e99b:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e99f:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e9a1:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e9a3:	54                   	push   %esp
call 	trap
f010e9a4:	e8 d4 fd ff ff       	call   f010e77d <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e9a9:	59                   	pop    %ecx

f010e9aa <trapret>:
.globl trapret
trapret:
popal
f010e9aa:	61                   	popa   
pop 	%es
f010e9ab:	07                   	pop    %es
pop 	%ds
f010e9ac:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e9ad:	83 c4 08             	add    $0x8,%esp
iret
f010e9b0:	cf                   	iret   

f010e9b1 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010e9b1:	55                   	push   %ebp
f010e9b2:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010e9b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9b7:	8b 15 80 f5 b1 f0    	mov    0xf0b1f580,%edx
f010e9bd:	29 d0                	sub    %edx,%eax
f010e9bf:	c1 f8 03             	sar    $0x3,%eax
f010e9c2:	89 c2                	mov    %eax,%edx
f010e9c4:	89 d0                	mov    %edx,%eax
f010e9c6:	c1 e0 02             	shl    $0x2,%eax
f010e9c9:	01 d0                	add    %edx,%eax
f010e9cb:	c1 e0 02             	shl    $0x2,%eax
f010e9ce:	01 d0                	add    %edx,%eax
f010e9d0:	c1 e0 02             	shl    $0x2,%eax
f010e9d3:	01 d0                	add    %edx,%eax
f010e9d5:	89 c1                	mov    %eax,%ecx
f010e9d7:	c1 e1 08             	shl    $0x8,%ecx
f010e9da:	01 c8                	add    %ecx,%eax
f010e9dc:	89 c1                	mov    %eax,%ecx
f010e9de:	c1 e1 10             	shl    $0x10,%ecx
f010e9e1:	01 c8                	add    %ecx,%eax
f010e9e3:	01 c0                	add    %eax,%eax
f010e9e5:	01 d0                	add    %edx,%eax
}
f010e9e7:	5d                   	pop    %ebp
f010e9e8:	c3                   	ret    

f010e9e9 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010e9e9:	55                   	push   %ebp
f010e9ea:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010e9ec:	ff 75 08             	pushl  0x8(%ebp)
f010e9ef:	e8 bd ff ff ff       	call   f010e9b1 <to_frame_number>
f010e9f4:	83 c4 04             	add    $0x4,%esp
f010e9f7:	c1 e0 0c             	shl    $0xc,%eax
}
f010e9fa:	c9                   	leave  
f010e9fb:	c3                   	ret    

f010e9fc <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010e9fc:	55                   	push   %ebp
f010e9fd:	89 e5                	mov    %esp,%ebp
f010e9ff:	83 ec 18             	sub    $0x18,%esp
f010ea02:	8b 45 10             	mov    0x10(%ebp),%eax
f010ea05:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010ea08:	e8 ed 8a ff ff       	call   f01074fa <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010ea0d:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010ea11:	74 23                	je     f010ea36 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010ea13:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ea18:	8b 40 10             	mov    0x10(%eax),%eax
f010ea1b:	8b 15 e0 dd 6a f2    	mov    0xf26adde0,%edx
f010ea21:	83 c2 20             	add    $0x20,%edx
f010ea24:	83 ec 04             	sub    $0x4,%esp
f010ea27:	50                   	push   %eax
f010ea28:	52                   	push   %edx
f010ea29:	68 50 7d 12 f0       	push   $0xf0127d50
f010ea2e:	e8 58 25 ff ff       	call   f0100f8b <cprintf>
f010ea33:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010ea36:	83 ec 04             	sub    $0x4,%esp
f010ea39:	ff 75 08             	pushl  0x8(%ebp)
f010ea3c:	ff 75 0c             	pushl  0xc(%ebp)
f010ea3f:	68 59 7d 12 f0       	push   $0xf0127d59
f010ea44:	e8 42 25 ff ff       	call   f0100f8b <cprintf>
f010ea49:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010ea4c:	e8 fb 8a ff ff       	call   f010754c <popcli>
}
f010ea51:	90                   	nop
f010ea52:	c9                   	leave  
f010ea53:	c3                   	ret    

f010ea54 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010ea54:	55                   	push   %ebp
f010ea55:	89 e5                	mov    %esp,%ebp
f010ea57:	83 ec 18             	sub    $0x18,%esp
f010ea5a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea5d:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010ea60:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010ea64:	83 ec 08             	sub    $0x8,%esp
f010ea67:	50                   	push   %eax
f010ea68:	68 5e 7d 12 f0       	push   $0xf0127d5e
f010ea6d:	e8 19 25 ff ff       	call   f0100f8b <cprintf>
f010ea72:	83 c4 10             	add    $0x10,%esp
}
f010ea75:	90                   	nop
f010ea76:	c9                   	leave  
f010ea77:	c3                   	ret    

f010ea78 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010ea78:	55                   	push   %ebp
f010ea79:	89 e5                	mov    %esp,%ebp
f010ea7b:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010ea7e:	9c                   	pushf  
f010ea7f:	58                   	pop    %eax
f010ea80:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010ea83:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010ea86:	25 00 02 00 00       	and    $0x200,%eax
f010ea8b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010ea8e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ea92:	74 10                	je     f010eaa4 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010ea94:	e8 2b 23 ff ff       	call   f0100dc4 <cons_getc2>
f010ea99:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ea9c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eaa0:	74 f2                	je     f010ea94 <sys_cgetc+0x1c>
f010eaa2:	eb 0e                	jmp    f010eab2 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010eaa4:	e8 c0 22 ff ff       	call   f0100d69 <cons_getc>
f010eaa9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010eaac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eab0:	74 f2                	je     f010eaa4 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010eab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010eab5:	c9                   	leave  
f010eab6:	c3                   	ret    

f010eab7 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010eab7:	55                   	push   %ebp
f010eab8:	89 e5                	mov    %esp,%ebp
f010eaba:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010eabd:	e8 ee 23 ff ff       	call   f0100eb0 <cons_lock>
}
f010eac2:	90                   	nop
f010eac3:	c9                   	leave  
f010eac4:	c3                   	ret    

f010eac5 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010eac5:	55                   	push   %ebp
f010eac6:	89 e5                	mov    %esp,%ebp
f010eac8:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010eacb:	e8 27 24 ff ff       	call   f0100ef7 <cons_unlock>
}
f010ead0:	90                   	nop
f010ead1:	c9                   	leave  
f010ead2:	c3                   	ret    

f010ead3 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010ead3:	55                   	push   %ebp
f010ead4:	89 e5                	mov    %esp,%ebp
f010ead6:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010ead9:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010eade:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010eae1:	83 ec 0c             	sub    $0xc,%esp
f010eae4:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010eae7:	50                   	push   %eax
f010eae8:	e8 f0 99 ff ff       	call   f01084dd <allocate_frame>
f010eaed:	83 c4 10             	add    $0x10,%esp
f010eaf0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010eaf3:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010eaf7:	75 08                	jne    f010eb01 <__sys_allocate_page+0x2e>
		return r ;
f010eaf9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eafc:	e9 e9 00 00 00       	jmp    f010ebea <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010eb01:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb04:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010eb09:	77 0c                	ja     f010eb17 <__sys_allocate_page+0x44>
f010eb0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb0e:	25 ff 0f 00 00       	and    $0xfff,%eax
f010eb13:	85 c0                	test   %eax,%eax
f010eb15:	74 0a                	je     f010eb21 <__sys_allocate_page+0x4e>
		return E_INVAL;
f010eb17:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010eb1c:	e9 c9 00 00 00       	jmp    f010ebea <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010eb21:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb24:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010eb29:	83 f8 04             	cmp    $0x4,%eax
f010eb2c:	74 0a                	je     f010eb38 <__sys_allocate_page+0x65>
		return E_INVAL;
f010eb2e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010eb33:	e9 b2 00 00 00       	jmp    f010ebea <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010eb38:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eb3b:	83 ec 0c             	sub    $0xc,%esp
f010eb3e:	50                   	push   %eax
f010eb3f:	e8 a5 fe ff ff       	call   f010e9e9 <to_physical_address>
f010eb44:	83 c4 10             	add    $0x10,%esp
f010eb47:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010eb4a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eb4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eb50:	8b 40 64             	mov    0x64(%eax),%eax
f010eb53:	6a 02                	push   $0x2
f010eb55:	68 00 00 80 ef       	push   $0xef800000
f010eb5a:	52                   	push   %edx
f010eb5b:	50                   	push   %eax
f010eb5c:	e8 49 9e ff ff       	call   f01089aa <map_frame>
f010eb61:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010eb64:	83 ec 04             	sub    $0x4,%esp
f010eb67:	68 00 10 00 00       	push   $0x1000
f010eb6c:	6a 00                	push   $0x0
f010eb6e:	68 00 00 80 ef       	push   $0xef800000
f010eb73:	e8 d8 15 01 00       	call   f0120150 <memset>
f010eb78:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010eb7b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eb7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eb81:	8b 40 08             	mov    0x8(%eax),%eax
f010eb84:	40                   	inc    %eax
f010eb85:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010eb89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eb8c:	8b 40 64             	mov    0x64(%eax),%eax
f010eb8f:	83 ec 08             	sub    $0x8,%esp
f010eb92:	68 00 00 80 ef       	push   $0xef800000
f010eb97:	50                   	push   %eax
f010eb98:	e8 6d 9f ff ff       	call   f0108b0a <unmap_frame>
f010eb9d:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010eba0:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eba3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eba6:	8b 40 08             	mov    0x8(%eax),%eax
f010eba9:	48                   	dec    %eax
f010ebaa:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010ebae:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ebb1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010ebb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ebb7:	8b 40 64             	mov    0x64(%eax),%eax
f010ebba:	ff 75 0c             	pushl  0xc(%ebp)
f010ebbd:	51                   	push   %ecx
f010ebbe:	52                   	push   %edx
f010ebbf:	50                   	push   %eax
f010ebc0:	e8 e5 9d ff ff       	call   f01089aa <map_frame>
f010ebc5:	83 c4 10             	add    $0x10,%esp
f010ebc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010ebcb:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010ebcf:	75 14                	jne    f010ebe5 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010ebd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ebd4:	83 ec 0c             	sub    $0xc,%esp
f010ebd7:	50                   	push   %eax
f010ebd8:	e8 0d 9b ff ff       	call   f01086ea <decrement_references>
f010ebdd:	83 c4 10             	add    $0x10,%esp
		return r;
f010ebe0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ebe3:	eb 05                	jmp    f010ebea <__sys_allocate_page+0x117>
	}
	return 0 ;
f010ebe5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ebea:	c9                   	leave  
f010ebeb:	c3                   	ret    

f010ebec <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010ebec:	55                   	push   %ebp
f010ebed:	89 e5                	mov    %esp,%ebp
f010ebef:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010ebf2:	83 ec 04             	sub    $0x4,%esp
f010ebf5:	68 61 7d 12 f0       	push   $0xf0127d61
f010ebfa:	68 dc 00 00 00       	push   $0xdc
f010ebff:	68 7f 7d 12 f0       	push   $0xf0127d7f
f010ec04:	e8 30 17 ff ff       	call   f0100339 <_panic>

f010ec09 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010ec09:	55                   	push   %ebp
f010ec0a:	89 e5                	mov    %esp,%ebp
f010ec0c:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010ec0f:	83 ec 04             	sub    $0x4,%esp
f010ec12:	68 94 7d 12 f0       	push   $0xf0127d94
f010ec17:	68 ed 00 00 00       	push   $0xed
f010ec1c:	68 7f 7d 12 f0       	push   $0xf0127d7f
f010ec21:	e8 13 17 ff ff       	call   f0100339 <_panic>

f010ec26 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010ec26:	55                   	push   %ebp
f010ec27:	89 e5                	mov    %esp,%ebp
f010ec29:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010ec2c:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ec31:	8b 40 64             	mov    0x64(%eax),%eax
f010ec34:	83 ec 04             	sub    $0x4,%esp
f010ec37:	ff 75 0c             	pushl  0xc(%ebp)
f010ec3a:	ff 75 08             	pushl  0x8(%ebp)
f010ec3d:	50                   	push   %eax
f010ec3e:	e8 69 c2 ff ff       	call   f010aeac <calculate_required_frames>
f010ec43:	83 c4 10             	add    $0x10,%esp
}
f010ec46:	c9                   	leave  
f010ec47:	c3                   	ret    

f010ec48 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010ec48:	55                   	push   %ebp
f010ec49:	89 e5                	mov    %esp,%ebp
f010ec4b:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ec4e:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ec51:	83 ec 0c             	sub    $0xc,%esp
f010ec54:	50                   	push   %eax
f010ec55:	e8 32 a0 ff ff       	call   f0108c8c <calculate_available_frames>
f010ec5a:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010ec5d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ec60:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec63:	01 d0                	add    %edx,%eax
}
f010ec65:	c9                   	leave  
f010ec66:	c3                   	ret    

f010ec67 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010ec67:	55                   	push   %ebp
f010ec68:	89 e5                	mov    %esp,%ebp
f010ec6a:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ec6d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ec70:	83 ec 0c             	sub    $0xc,%esp
f010ec73:	50                   	push   %eax
f010ec74:	e8 13 a0 ff ff       	call   f0108c8c <calculate_available_frames>
f010ec79:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010ec7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ec7f:	c9                   	leave  
f010ec80:	c3                   	ret    

f010ec81 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010ec81:	55                   	push   %ebp
f010ec82:	89 e5                	mov    %esp,%ebp
f010ec84:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ec87:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ec8a:	83 ec 0c             	sub    $0xc,%esp
f010ec8d:	50                   	push   %eax
f010ec8e:	e8 f9 9f ff ff       	call   f0108c8c <calculate_available_frames>
f010ec93:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010ec96:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010ec99:	c9                   	leave  
f010ec9a:	c3                   	ret    

f010ec9b <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010ec9b:	55                   	push   %ebp
f010ec9c:	89 e5                	mov    %esp,%ebp
f010ec9e:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010eca1:	83 ec 0c             	sub    $0xc,%esp
f010eca4:	ff 75 08             	pushl  0x8(%ebp)
f010eca7:	e8 4d 00 01 00       	call   f011ecf9 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010ecac:	83 c4 10             	add    $0x10,%esp
}
f010ecaf:	c9                   	leave  
f010ecb0:	c3                   	ret    

f010ecb1 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010ecb1:	55                   	push   %ebp
f010ecb2:	89 e5                	mov    %esp,%ebp
f010ecb4:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010ecb7:	e8 68 ff 00 00       	call   f011ec24 <scarce_memory>
}
f010ecbc:	90                   	nop
f010ecbd:	c9                   	leave  
f010ecbe:	c3                   	ret    

f010ecbf <sys_clearFFL>:

void sys_clearFFL()
{
f010ecbf:	55                   	push   %ebp
f010ecc0:	89 e5                	mov    %esp,%ebp
f010ecc2:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010ecc5:	83 ec 0c             	sub    $0xc,%esp
f010ecc8:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010eccd:	e8 e2 12 00 00       	call   f010ffb4 <acquire_spinlock>
f010ecd2:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010ecd5:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f010ecda:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ecdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ece4:	eb 12                	jmp    f010ecf8 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010ece6:	83 ec 0c             	sub    $0xc,%esp
f010ece9:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ecec:	50                   	push   %eax
f010eced:	e8 eb 97 ff ff       	call   f01084dd <allocate_frame>
f010ecf2:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ecf5:	ff 45 f4             	incl   -0xc(%ebp)
f010ecf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ecfb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ecfe:	7c e6                	jl     f010ece6 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010ed00:	83 ec 0c             	sub    $0xc,%esp
f010ed03:	68 40 f1 b1 f0       	push   $0xf0b1f140
f010ed08:	e8 2e 13 00 00       	call   f011003b <release_spinlock>
f010ed0d:	83 c4 10             	add    $0x10,%esp
}
f010ed10:	90                   	nop
f010ed11:	c9                   	leave  
f010ed12:	c3                   	ret    

f010ed13 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010ed13:	55                   	push   %ebp
f010ed14:	89 e5                	mov    %esp,%ebp
f010ed16:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010ed19:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ed1e:	83 ec 0c             	sub    $0xc,%esp
f010ed21:	50                   	push   %eax
f010ed22:	e8 c6 5c ff ff       	call   f01049ed <pf_calculate_allocated_pages>
f010ed27:	83 c4 10             	add    $0x10,%esp
}
f010ed2a:	c9                   	leave  
f010ed2b:	c3                   	ret    

f010ed2c <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010ed2c:	55                   	push   %ebp
f010ed2d:	89 e5                	mov    %esp,%ebp
f010ed2f:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010ed32:	e8 ed 0c 00 00       	call   f010fa24 <isBufferingEnabled>
f010ed37:	84 c0                	test   %al,%al
f010ed39:	74 19                	je     f010ed54 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010ed3b:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ed40:	83 ec 04             	sub    $0x4,%esp
f010ed43:	ff 75 0c             	pushl  0xc(%ebp)
f010ed46:	ff 75 08             	pushl  0x8(%ebp)
f010ed49:	50                   	push   %eax
f010ed4a:	e8 48 c3 ff ff       	call   f010b097 <__free_user_mem_with_buffering>
f010ed4f:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010ed52:	eb 18                	jmp    f010ed6c <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010ed54:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ed59:	83 ec 04             	sub    $0x4,%esp
f010ed5c:	ff 75 0c             	pushl  0xc(%ebp)
f010ed5f:	ff 75 08             	pushl  0x8(%ebp)
f010ed62:	50                   	push   %eax
f010ed63:	e8 a3 c2 ff ff       	call   f010b00b <free_user_mem>
f010ed68:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010ed6b:	90                   	nop
}
f010ed6c:	c9                   	leave  
f010ed6d:	c3                   	ret    

f010ed6e <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010ed6e:	55                   	push   %ebp
f010ed6f:	89 e5                	mov    %esp,%ebp
f010ed71:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010ed74:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ed78:	75 07                	jne    f010ed81 <check_Param+0x13>
	{
		env_exit();
f010ed7a:	e8 64 cf ff ff       	call   f010bce3 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010ed7f:	eb 25                	jmp    f010eda6 <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010ed81:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010ed88:	77 07                	ja     f010ed91 <check_Param+0x23>
f010ed8a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed8d:	85 c0                	test   %eax,%eax
f010ed8f:	78 07                	js     f010ed98 <check_Param+0x2a>
	{
		env_exit();
f010ed91:	e8 4d cf ff ff       	call   f010bce3 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010ed96:	eb 0e                	jmp    f010eda6 <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010ed98:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010ed9f:	76 05                	jbe    f010eda6 <check_Param+0x38>
	{
		env_exit();
f010eda1:	e8 3d cf ff ff       	call   f010bce3 <env_exit>
	}
}
f010eda6:	90                   	nop
f010eda7:	c9                   	leave  
f010eda8:	c3                   	ret    

f010eda9 <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010eda9:	55                   	push   %ebp
f010edaa:	89 e5                	mov    %esp,%ebp
f010edac:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010edaf:	83 ec 0c             	sub    $0xc,%esp
f010edb2:	ff 75 08             	pushl  0x8(%ebp)
f010edb5:	e8 b4 ff ff ff       	call   f010ed6e <check_Param>
f010edba:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010edbd:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010edc2:	83 ec 04             	sub    $0x4,%esp
f010edc5:	ff 75 0c             	pushl  0xc(%ebp)
f010edc8:	ff 75 08             	pushl  0x8(%ebp)
f010edcb:	50                   	push   %eax
f010edcc:	e8 7f c1 ff ff       	call   f010af50 <allocate_user_mem>
f010edd1:	83 c4 10             	add    $0x10,%esp
	return;
f010edd4:	90                   	nop
}
f010edd5:	c9                   	leave  
f010edd6:	c3                   	ret    

f010edd7 <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010edd7:	55                   	push   %ebp
f010edd8:	89 e5                	mov    %esp,%ebp
f010edda:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010eddd:	83 ec 0c             	sub    $0xc,%esp
f010ede0:	ff 75 08             	pushl  0x8(%ebp)
f010ede3:	e8 86 ff ff ff       	call   f010ed6e <check_Param>
f010ede8:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010edeb:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010edf0:	8b 40 64             	mov    0x64(%eax),%eax
f010edf3:	ff 75 10             	pushl  0x10(%ebp)
f010edf6:	ff 75 0c             	pushl  0xc(%ebp)
f010edf9:	ff 75 08             	pushl  0x8(%ebp)
f010edfc:	50                   	push   %eax
f010edfd:	e8 76 c0 ff ff       	call   f010ae78 <allocate_chunk>
f010ee02:	83 c4 10             	add    $0x10,%esp
	return;
f010ee05:	90                   	nop
}
f010ee06:	c9                   	leave  
f010ee07:	c3                   	ret    

f010ee08 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010ee08:	55                   	push   %ebp
f010ee09:	89 e5                	mov    %esp,%ebp
f010ee0b:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010ee0e:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ee13:	ff 75 10             	pushl  0x10(%ebp)
f010ee16:	ff 75 0c             	pushl  0xc(%ebp)
f010ee19:	ff 75 08             	pushl  0x8(%ebp)
f010ee1c:	50                   	push   %eax
f010ee1d:	e8 92 c2 ff ff       	call   f010b0b4 <move_user_mem>
f010ee22:	83 c4 10             	add    $0x10,%esp
	return;
f010ee25:	90                   	nop
}
f010ee26:	c9                   	leave  
f010ee27:	c3                   	ret    

f010ee28 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010ee28:	55                   	push   %ebp
f010ee29:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010ee2b:	a1 64 f5 b1 f0       	mov    0xf0b1f564,%eax
}
f010ee30:	5d                   	pop    %ebp
f010ee31:	c3                   	ret    

f010ee32 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010ee32:	55                   	push   %ebp
f010ee33:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010ee35:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee38:	a3 64 f5 b1 f0       	mov    %eax,0xf0b1f564
}
f010ee3d:	90                   	nop
f010ee3e:	5d                   	pop    %ebp
f010ee3f:	c3                   	ret    

f010ee40 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010ee40:	55                   	push   %ebp
f010ee41:	89 e5                	mov    %esp,%ebp
f010ee43:	83 ec 18             	sub    $0x18,%esp
f010ee46:	8b 45 10             	mov    0x10(%ebp),%eax
f010ee49:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010ee4c:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010ee50:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ee55:	8b 40 10             	mov    0x10(%eax),%eax
f010ee58:	83 ec 0c             	sub    $0xc,%esp
f010ee5b:	ff 75 14             	pushl  0x14(%ebp)
f010ee5e:	52                   	push   %edx
f010ee5f:	ff 75 0c             	pushl  0xc(%ebp)
f010ee62:	ff 75 08             	pushl  0x8(%ebp)
f010ee65:	50                   	push   %eax
f010ee66:	e8 45 a1 ff ff       	call   f0108fb0 <createSharedObject>
f010ee6b:	83 c4 20             	add    $0x20,%esp
}
f010ee6e:	c9                   	leave  
f010ee6f:	c3                   	ret    

f010ee70 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010ee70:	55                   	push   %ebp
f010ee71:	89 e5                	mov    %esp,%ebp
f010ee73:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010ee76:	83 ec 08             	sub    $0x8,%esp
f010ee79:	ff 75 0c             	pushl  0xc(%ebp)
f010ee7c:	ff 75 08             	pushl  0x8(%ebp)
f010ee7f:	e8 27 9f ff ff       	call   f0108dab <getSizeOfSharedObject>
f010ee84:	83 c4 10             	add    $0x10,%esp
}
f010ee87:	c9                   	leave  
f010ee88:	c3                   	ret    

f010ee89 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010ee89:	55                   	push   %ebp
f010ee8a:	89 e5                	mov    %esp,%ebp
f010ee8c:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010ee8f:	83 ec 04             	sub    $0x4,%esp
f010ee92:	ff 75 10             	pushl  0x10(%ebp)
f010ee95:	ff 75 0c             	pushl  0xc(%ebp)
f010ee98:	ff 75 08             	pushl  0x8(%ebp)
f010ee9b:	e8 a3 a2 ff ff       	call   f0109143 <getSharedObject>
f010eea0:	83 c4 10             	add    $0x10,%esp
}
f010eea3:	c9                   	leave  
f010eea4:	c3                   	ret    

f010eea5 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010eea5:	55                   	push   %ebp
f010eea6:	89 e5                	mov    %esp,%ebp
f010eea8:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010eeab:	83 ec 08             	sub    $0x8,%esp
f010eeae:	ff 75 0c             	pushl  0xc(%ebp)
f010eeb1:	ff 75 08             	pushl  0x8(%ebp)
f010eeb4:	e8 cb a4 ff ff       	call   f0109384 <freeSharedObject>
f010eeb9:	83 c4 10             	add    $0x10,%esp
}
f010eebc:	c9                   	leave  
f010eebd:	c3                   	ret    

f010eebe <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010eebe:	55                   	push   %ebp
f010eebf:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010eec1:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010eec6:	8b 40 10             	mov    0x10(%eax),%eax
}
f010eec9:	5d                   	pop    %ebp
f010eeca:	c3                   	ret    

f010eecb <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010eecb:	55                   	push   %ebp
f010eecc:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010eece:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010eed3:	89 c2                	mov    %eax,%edx
f010eed5:	a1 90 65 6f f0       	mov    0xf06f6590,%eax
f010eeda:	29 c2                	sub    %eax,%edx
f010eedc:	89 d0                	mov    %edx,%eax
f010eede:	c1 f8 02             	sar    $0x2,%eax
f010eee1:	89 c2                	mov    %eax,%edx
f010eee3:	89 d0                	mov    %edx,%eax
f010eee5:	c1 e0 03             	shl    $0x3,%eax
f010eee8:	01 d0                	add    %edx,%eax
f010eeea:	c1 e0 03             	shl    $0x3,%eax
f010eeed:	01 d0                	add    %edx,%eax
f010eeef:	c1 e0 02             	shl    $0x2,%eax
f010eef2:	01 d0                	add    %edx,%eax
f010eef4:	01 c0                	add    %eax,%eax
f010eef6:	01 d0                	add    %edx,%eax
f010eef8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010eeff:	01 c8                	add    %ecx,%eax
f010ef01:	c1 e0 02             	shl    $0x2,%eax
f010ef04:	01 d0                	add    %edx,%eax
f010ef06:	c1 e0 03             	shl    $0x3,%eax
f010ef09:	01 d0                	add    %edx,%eax
f010ef0b:	c1 e0 05             	shl    $0x5,%eax
f010ef0e:	29 d0                	sub    %edx,%eax
f010ef10:	c1 e0 02             	shl    $0x2,%eax
f010ef13:	01 d0                	add    %edx,%eax
f010ef15:	01 c0                	add    %eax,%eax
f010ef17:	01 d0                	add    %edx,%eax
f010ef19:	c1 e0 03             	shl    $0x3,%eax
f010ef1c:	01 d0                	add    %edx,%eax
f010ef1e:	c1 e0 04             	shl    $0x4,%eax
f010ef21:	29 d0                	sub    %edx,%eax
}
f010ef23:	5d                   	pop    %ebp
f010ef24:	c3                   	ret    

f010ef25 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010ef25:	55                   	push   %ebp
f010ef26:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010ef28:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ef2d:	8b 40 14             	mov    0x14(%eax),%eax
}
f010ef30:	5d                   	pop    %ebp
f010ef31:	c3                   	ret    

f010ef32 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010ef32:	55                   	push   %ebp
f010ef33:	89 e5                	mov    %esp,%ebp
f010ef35:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010ef38:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ef3c:	75 0a                	jne    f010ef48 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010ef3e:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ef43:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ef46:	eb 22                	jmp    f010ef6a <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010ef48:	83 ec 04             	sub    $0x4,%esp
f010ef4b:	6a 00                	push   $0x0
f010ef4d:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010ef50:	50                   	push   %eax
f010ef51:	ff 75 08             	pushl  0x8(%ebp)
f010ef54:	e8 1c ce ff ff       	call   f010bd75 <envid2env>
f010ef59:	83 c4 10             	add    $0x10,%esp
f010ef5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ef5f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ef63:	79 05                	jns    f010ef6a <sys_destroy_env+0x38>
	{
		return r;
f010ef65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef68:	eb 5e                	jmp    f010efc8 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010ef6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ef6d:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ef72:	39 c2                	cmp    %eax,%edx
f010ef74:	75 1b                	jne    f010ef91 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010ef76:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ef7b:	8b 40 10             	mov    0x10(%eax),%eax
f010ef7e:	83 ec 08             	sub    $0x8,%esp
f010ef81:	50                   	push   %eax
f010ef82:	68 b3 7d 12 f0       	push   $0xf0127db3
f010ef87:	e8 ff 1f ff ff       	call   f0100f8b <cprintf>
f010ef8c:	83 c4 10             	add    $0x10,%esp
f010ef8f:	eb 20                	jmp    f010efb1 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010ef91:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ef94:	8b 50 10             	mov    0x10(%eax),%edx
f010ef97:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010ef9c:	8b 40 10             	mov    0x10(%eax),%eax
f010ef9f:	83 ec 04             	sub    $0x4,%esp
f010efa2:	52                   	push   %edx
f010efa3:	50                   	push   %eax
f010efa4:	68 ce 7d 12 f0       	push   $0xf0127dce
f010efa9:	e8 dd 1f ff ff       	call   f0100f8b <cprintf>
f010efae:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010efb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010efb4:	8b 40 10             	mov    0x10(%eax),%eax
f010efb7:	83 ec 0c             	sub    $0xc,%esp
f010efba:	50                   	push   %eax
f010efbb:	e8 63 6d ff ff       	call   f0105d23 <sched_kill_env>
f010efc0:	83 c4 10             	add    $0x10,%esp

	return 0;
f010efc3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010efc8:	c9                   	leave  
f010efc9:	c3                   	ret    

f010efca <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010efca:	55                   	push   %ebp
f010efcb:	89 e5                	mov    %esp,%ebp
f010efcd:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010efd0:	e8 0e cd ff ff       	call   f010bce3 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010efd5:	90                   	nop
f010efd6:	c9                   	leave  
f010efd7:	c3                   	ret    

f010efd8 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010efd8:	55                   	push   %ebp
f010efd9:	89 e5                	mov    %esp,%ebp
f010efdb:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010efde:	ff 75 14             	pushl  0x14(%ebp)
f010efe1:	ff 75 10             	pushl  0x10(%ebp)
f010efe4:	ff 75 0c             	pushl  0xc(%ebp)
f010efe7:	ff 75 08             	pushl  0x8(%ebp)
f010efea:	e8 b8 c2 ff ff       	call   f010b2a7 <env_create>
f010efef:	83 c4 10             	add    $0x10,%esp
f010eff2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010eff5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eff9:	75 07                	jne    f010f002 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010effb:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010f000:	eb 14                	jmp    f010f016 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010f002:	83 ec 0c             	sub    $0xc,%esp
f010f005:	ff 75 f4             	pushl  -0xc(%ebp)
f010f008:	e8 7a 69 ff ff       	call   f0105987 <sched_new_env>
f010f00d:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010f010:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f013:	8b 40 10             	mov    0x10(%eax),%eax
}
f010f016:	c9                   	leave  
f010f017:	c3                   	ret    

f010f018 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010f018:	55                   	push   %ebp
f010f019:	89 e5                	mov    %esp,%ebp
f010f01b:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010f01e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f021:	83 ec 0c             	sub    $0xc,%esp
f010f024:	50                   	push   %eax
f010f025:	e8 b3 69 ff ff       	call   f01059dd <sched_run_env>
f010f02a:	83 c4 10             	add    $0x10,%esp
}
f010f02d:	90                   	nop
f010f02e:	c9                   	leave  
f010f02f:	c3                   	ret    

f010f030 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010f030:	55                   	push   %ebp
f010f031:	89 e5                	mov    %esp,%ebp
f010f033:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010f036:	0f 31                	rdtsc  
f010f038:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010f03b:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010f03e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f041:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f044:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f047:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010f04a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010f04d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f050:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f053:	89 01                	mov    %eax,(%ecx)
f010f055:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010f058:	8b 45 08             	mov    0x8(%ebp),%eax
f010f05b:	c9                   	leave  
f010f05c:	c2 04 00             	ret    $0x4

f010f05f <sys_rcr2>:

uint32 sys_rcr2()
{
f010f05f:	55                   	push   %ebp
f010f060:	89 e5                	mov    %esp,%ebp
f010f062:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f065:	0f 20 d0             	mov    %cr2,%eax
f010f068:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010f06b:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010f06e:	90                   	nop
}
f010f06f:	c9                   	leave  
f010f070:	c3                   	ret    

f010f071 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010f071:	55                   	push   %ebp
f010f072:	89 e5                	mov    %esp,%ebp
f010f074:	83 ec 04             	sub    $0x4,%esp
f010f077:	8b 45 08             	mov    0x8(%ebp),%eax
f010f07a:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010f07d:	8a 45 fc             	mov    -0x4(%ebp),%al
f010f080:	a2 00 6e 6f f0       	mov    %al,0xf06f6e00
}
f010f085:	90                   	nop
f010f086:	c9                   	leave  
f010f087:	c3                   	ret    

f010f088 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010f088:	55                   	push   %ebp
f010f089:	89 e5                	mov    %esp,%ebp
f010f08b:	56                   	push   %esi
f010f08c:	53                   	push   %ebx
f010f08d:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010f090:	e8 90 cc ff ff       	call   f010bd25 <get_cpu_proc>
f010f095:	a3 e0 dd 6a f2       	mov    %eax,0xf26adde0
	assert(cur_env != NULL);
f010f09a:	a1 e0 dd 6a f2       	mov    0xf26adde0,%eax
f010f09f:	85 c0                	test   %eax,%eax
f010f0a1:	75 19                	jne    f010f0bc <syscall+0x34>
f010f0a3:	68 e6 7d 12 f0       	push   $0xf0127de6
f010f0a8:	68 f6 7d 12 f0       	push   $0xf0127df6
f010f0ad:	68 05 02 00 00       	push   $0x205
f010f0b2:	68 7f 7d 12 f0       	push   $0xf0127d7f
f010f0b7:	e8 7d 12 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010f0bc:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010f0c0:	0f 87 06 04 00 00    	ja     f010f4cc <syscall+0x444>
f010f0c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f0c9:	c1 e0 02             	shl    $0x2,%eax
f010f0cc:	05 0c 7e 12 f0       	add    $0xf0127e0c,%eax
f010f0d1:	8b 00                	mov    (%eax),%eax
f010f0d3:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010f0d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0d8:	83 ec 0c             	sub    $0xc,%esp
f010f0db:	50                   	push   %eax
f010f0dc:	e8 e5 bd ff ff       	call   f010aec6 <sys_sbrk>
f010f0e1:	83 c4 10             	add    $0x10,%esp
f010f0e4:	e9 e8 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010f0e9:	83 ec 08             	sub    $0x8,%esp
f010f0ec:	ff 75 10             	pushl  0x10(%ebp)
f010f0ef:	ff 75 0c             	pushl  0xc(%ebp)
f010f0f2:	e8 35 fc ff ff       	call   f010ed2c <sys_free_user_mem>
f010f0f7:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f0fa:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0ff:	e9 cd 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010f104:	83 ec 08             	sub    $0x8,%esp
f010f107:	ff 75 10             	pushl  0x10(%ebp)
f010f10a:	ff 75 0c             	pushl  0xc(%ebp)
f010f10d:	e8 97 fc ff ff       	call   f010eda9 <sys_allocate_user_mem>
f010f112:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f115:	b8 00 00 00 00       	mov    $0x0,%eax
f010f11a:	e9 b2 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010f11f:	8b 45 14             	mov    0x14(%ebp),%eax
f010f122:	0f b6 d0             	movzbl %al,%edx
f010f125:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f128:	83 ec 04             	sub    $0x4,%esp
f010f12b:	52                   	push   %edx
f010f12c:	ff 75 10             	pushl  0x10(%ebp)
f010f12f:	50                   	push   %eax
f010f130:	e8 c7 f8 ff ff       	call   f010e9fc <sys_cputs>
f010f135:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f138:	b8 00 00 00 00       	mov    $0x0,%eax
f010f13d:	e9 8f 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010f142:	e8 31 f9 ff ff       	call   f010ea78 <sys_cgetc>
f010f147:	e9 85 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010f14c:	e8 66 f9 ff ff       	call   f010eab7 <sys_lock_cons>
		return 0;
f010f151:	b8 00 00 00 00       	mov    $0x0,%eax
f010f156:	e9 76 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010f15b:	e8 65 f9 ff ff       	call   f010eac5 <sys_unlock_cons>
		return 0;
f010f160:	b8 00 00 00 00       	mov    $0x0,%eax
f010f165:	e9 67 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010f16a:	83 ec 08             	sub    $0x8,%esp
f010f16d:	ff 75 10             	pushl  0x10(%ebp)
f010f170:	ff 75 0c             	pushl  0xc(%ebp)
f010f173:	e8 ae fa ff ff       	call   f010ec26 <sys_calculate_required_frames>
f010f178:	83 c4 10             	add    $0x10,%esp
f010f17b:	e9 51 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010f180:	e8 c3 fa ff ff       	call   f010ec48 <sys_calculate_free_frames>
f010f185:	e9 47 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010f18a:	e8 d8 fa ff ff       	call   f010ec67 <sys_calculate_modified_frames>
f010f18f:	e9 3d 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010f194:	e8 e8 fa ff ff       	call   f010ec81 <sys_calculate_notmod_frames>
f010f199:	e9 33 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010f19e:	e8 70 fb ff ff       	call   f010ed13 <sys_pf_calculate_allocated_pages>
f010f1a3:	e9 29 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010f1a8:	83 ec 0c             	sub    $0xc,%esp
f010f1ab:	ff 75 0c             	pushl  0xc(%ebp)
f010f1ae:	e8 e8 fa ff ff       	call   f010ec9b <sys_calculate_pages_tobe_removed_ready_exit>
f010f1b3:	83 c4 10             	add    $0x10,%esp
f010f1b6:	e9 16 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010f1bb:	e8 f1 fa ff ff       	call   f010ecb1 <sys_scarce_memory>
		return 0;
f010f1c0:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1c5:	e9 07 03 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010f1ca:	83 ec 04             	sub    $0x4,%esp
f010f1cd:	ff 75 14             	pushl  0x14(%ebp)
f010f1d0:	ff 75 10             	pushl  0x10(%ebp)
f010f1d3:	ff 75 0c             	pushl  0xc(%ebp)
f010f1d6:	e8 fc fb ff ff       	call   f010edd7 <sys_allocate_chunk>
f010f1db:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1de:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1e3:	e9 e9 02 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010f1e8:	8b 55 10             	mov    0x10(%ebp),%edx
f010f1eb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1ee:	83 ec 08             	sub    $0x8,%esp
f010f1f1:	52                   	push   %edx
f010f1f2:	50                   	push   %eax
f010f1f3:	e8 db f8 ff ff       	call   f010ead3 <__sys_allocate_page>
f010f1f8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1fb:	b8 00 00 00 00       	mov    $0x0,%eax
f010f200:	e9 cc 02 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010f205:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010f208:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f20b:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f20e:	8b 55 10             	mov    0x10(%ebp),%edx
f010f211:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f214:	83 ec 0c             	sub    $0xc,%esp
f010f217:	56                   	push   %esi
f010f218:	53                   	push   %ebx
f010f219:	51                   	push   %ecx
f010f21a:	52                   	push   %edx
f010f21b:	50                   	push   %eax
f010f21c:	e8 cb f9 ff ff       	call   f010ebec <__sys_map_frame>
f010f221:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f224:	b8 00 00 00 00       	mov    $0x0,%eax
f010f229:	e9 a3 02 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010f22e:	8b 55 10             	mov    0x10(%ebp),%edx
f010f231:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f234:	83 ec 08             	sub    $0x8,%esp
f010f237:	52                   	push   %edx
f010f238:	50                   	push   %eax
f010f239:	e8 cb f9 ff ff       	call   f010ec09 <__sys_unmap_frame>
f010f23e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f241:	b8 00 00 00 00       	mov    $0x0,%eax
f010f246:	e9 86 02 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010f24b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f24e:	0f be c0             	movsbl %al,%eax
f010f251:	83 ec 0c             	sub    $0xc,%esp
f010f254:	50                   	push   %eax
f010f255:	e8 fa f7 ff ff       	call   f010ea54 <sys_cputc>
f010f25a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f25d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f262:	e9 6a 02 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010f267:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f26a:	0f be c0             	movsbl %al,%eax
f010f26d:	83 ec 0c             	sub    $0xc,%esp
f010f270:	50                   	push   %eax
f010f271:	e8 49 fa ff ff       	call   f010ecbf <sys_clearFFL>
f010f276:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f279:	b8 00 00 00 00       	mov    $0x0,%eax
f010f27e:	e9 4e 02 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010f283:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f286:	8b 45 14             	mov    0x14(%ebp),%eax
f010f289:	0f b6 d0             	movzbl %al,%edx
f010f28c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f28f:	51                   	push   %ecx
f010f290:	52                   	push   %edx
f010f291:	ff 75 10             	pushl  0x10(%ebp)
f010f294:	50                   	push   %eax
f010f295:	e8 a6 fb ff ff       	call   f010ee40 <sys_createSharedObject>
f010f29a:	83 c4 10             	add    $0x10,%esp
f010f29d:	e9 2f 02 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010f2a2:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f2a5:	8b 55 10             	mov    0x10(%ebp),%edx
f010f2a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2ab:	83 ec 04             	sub    $0x4,%esp
f010f2ae:	51                   	push   %ecx
f010f2af:	52                   	push   %edx
f010f2b0:	50                   	push   %eax
f010f2b1:	e8 d3 fb ff ff       	call   f010ee89 <sys_getSharedObject>
f010f2b6:	83 c4 10             	add    $0x10,%esp
f010f2b9:	e9 13 02 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010f2be:	8b 55 10             	mov    0x10(%ebp),%edx
f010f2c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2c4:	83 ec 08             	sub    $0x8,%esp
f010f2c7:	52                   	push   %edx
f010f2c8:	50                   	push   %eax
f010f2c9:	e8 d7 fb ff ff       	call   f010eea5 <sys_freeSharedObject>
f010f2ce:	83 c4 10             	add    $0x10,%esp
f010f2d1:	e9 fb 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010f2d6:	8b 55 10             	mov    0x10(%ebp),%edx
f010f2d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2dc:	83 ec 08             	sub    $0x8,%esp
f010f2df:	52                   	push   %edx
f010f2e0:	50                   	push   %eax
f010f2e1:	e8 8a fb ff ff       	call   f010ee70 <sys_getSizeOfSharedObject>
f010f2e6:	83 c4 10             	add    $0x10,%esp
f010f2e9:	e9 e3 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010f2ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2f1:	ff 75 18             	pushl  0x18(%ebp)
f010f2f4:	ff 75 14             	pushl  0x14(%ebp)
f010f2f7:	ff 75 10             	pushl  0x10(%ebp)
f010f2fa:	50                   	push   %eax
f010f2fb:	e8 d8 fc ff ff       	call   f010efd8 <sys_create_env>
f010f300:	83 c4 10             	add    $0x10,%esp
f010f303:	e9 c9 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010f308:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f30b:	83 ec 0c             	sub    $0xc,%esp
f010f30e:	50                   	push   %eax
f010f30f:	e8 04 fd ff ff       	call   f010f018 <sys_run_env>
f010f314:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f317:	b8 00 00 00 00       	mov    $0x0,%eax
f010f31c:	e9 b0 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010f321:	e8 a5 fb ff ff       	call   f010eecb <sys_getenvindex>
f010f326:	e9 a6 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010f32b:	e8 8e fb ff ff       	call   f010eebe <sys_getenvid>
f010f330:	e9 9c 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010f335:	e8 eb fb ff ff       	call   f010ef25 <sys_getparentenvid>
f010f33a:	e9 92 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010f33f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f342:	83 ec 0c             	sub    $0xc,%esp
f010f345:	50                   	push   %eax
f010f346:	e8 e7 fb ff ff       	call   f010ef32 <sys_destroy_env>
f010f34b:	83 c4 10             	add    $0x10,%esp
f010f34e:	e9 7e 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f353:	e8 72 fc ff ff       	call   f010efca <sys_exit_env>
		return 0;
f010f358:	b8 00 00 00 00       	mov    $0x0,%eax
f010f35d:	e9 6f 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010f362:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010f365:	83 ec 0c             	sub    $0xc,%esp
f010f368:	50                   	push   %eax
f010f369:	e8 c2 fc ff ff       	call   f010f030 <sys_get_virtual_time>
f010f36e:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010f371:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f374:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010f377:	8b 45 10             	mov    0x10(%ebp),%eax
f010f37a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010f37d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f380:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f383:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f385:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f388:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f38b:	89 10                	mov    %edx,(%eax)
		return 0;
f010f38d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f392:	e9 3a 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f397:	83 ec 04             	sub    $0x4,%esp
f010f39a:	ff 75 14             	pushl  0x14(%ebp)
f010f39d:	ff 75 10             	pushl  0x10(%ebp)
f010f3a0:	ff 75 0c             	pushl  0xc(%ebp)
f010f3a3:	e8 60 fa ff ff       	call   f010ee08 <sys_move_user_mem>
f010f3a8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f3ab:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3b0:	e9 1c 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f3b5:	e8 a5 fc ff ff       	call   f010f05f <sys_rcr2>
f010f3ba:	e9 12 01 00 00       	jmp    f010f4d1 <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f3bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3c2:	0f b6 c0             	movzbl %al,%eax
f010f3c5:	83 ec 0c             	sub    $0xc,%esp
f010f3c8:	50                   	push   %eax
f010f3c9:	e8 a3 fc ff ff       	call   f010f071 <sys_bypassPageFault>
f010f3ce:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f3d1:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3d6:	e9 f6 00 00 00       	jmp    f010f4d1 <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010f3db:	e8 f8 ee 00 00       	call   f011e2d8 <rsttst>
		return 0;
f010f3e0:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3e5:	e9 e7 00 00 00       	jmp    f010f4d1 <syscall+0x449>
	case SYS_inctst:
		inctst();
f010f3ea:	e8 31 ef 00 00       	call   f011e320 <inctst>
		return 0;
f010f3ef:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3f4:	e9 d8 00 00 00       	jmp    f010f4d1 <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010f3f9:	83 ec 0c             	sub    $0xc,%esp
f010f3fc:	ff 75 0c             	pushl  0xc(%ebp)
f010f3ff:	e8 5e f0 00 00       	call   f011e462 <chktst>
f010f404:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f407:	b8 00 00 00 00       	mov    $0x0,%eax
f010f40c:	e9 c0 00 00 00       	jmp    f010f4d1 <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010f411:	e8 3e ef 00 00       	call   f011e354 <gettst>
f010f416:	e9 b6 00 00 00       	jmp    f010f4d1 <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f41b:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f41e:	8b 45 18             	mov    0x18(%ebp),%eax
f010f421:	0f be c0             	movsbl %al,%eax
f010f424:	83 ec 0c             	sub    $0xc,%esp
f010f427:	52                   	push   %edx
f010f428:	50                   	push   %eax
f010f429:	ff 75 14             	pushl  0x14(%ebp)
f010f42c:	ff 75 10             	pushl  0x10(%ebp)
f010f42f:	ff 75 0c             	pushl  0xc(%ebp)
f010f432:	e8 27 ef 00 00       	call   f011e35e <tst>
f010f437:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f43a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f43f:	e9 8d 00 00 00       	jmp    f010f4d1 <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f444:	e8 df f9 ff ff       	call   f010ee28 <sys_get_heap_strategy>
f010f449:	e9 83 00 00 00       	jmp    f010f4d1 <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f44e:	83 ec 0c             	sub    $0xc,%esp
f010f451:	ff 75 0c             	pushl  0xc(%ebp)
f010f454:	e8 d9 f9 ff ff       	call   f010ee32 <sys_set_uheap_strategy>
f010f459:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f45c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f461:	eb 6e                	jmp    f010f4d1 <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f463:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f466:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f469:	8b 55 10             	mov    0x10(%ebp),%edx
f010f46c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f46f:	53                   	push   %ebx
f010f470:	51                   	push   %ecx
f010f471:	52                   	push   %edx
f010f472:	50                   	push   %eax
f010f473:	e8 b3 1d 00 00       	call   f011122b <sys_check_LRU_lists>
f010f478:	83 c4 10             	add    $0x10,%esp
f010f47b:	eb 54                	jmp    f010f4d1 <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f47d:	8b 55 10             	mov    0x10(%ebp),%edx
f010f480:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f483:	83 ec 08             	sub    $0x8,%esp
f010f486:	52                   	push   %edx
f010f487:	50                   	push   %eax
f010f488:	e8 60 1f 00 00       	call   f01113ed <sys_check_LRU_lists_free>
f010f48d:	83 c4 10             	add    $0x10,%esp
f010f490:	eb 3f                	jmp    f010f4d1 <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f492:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f495:	8b 55 10             	mov    0x10(%ebp),%edx
f010f498:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f49b:	51                   	push   %ecx
f010f49c:	ff 75 14             	pushl  0x14(%ebp)
f010f49f:	52                   	push   %edx
f010f4a0:	50                   	push   %eax
f010f4a1:	e8 d4 20 00 00       	call   f011157a <sys_check_WS_list>
f010f4a6:	83 c4 10             	add    $0x10,%esp
f010f4a9:	eb 26                	jmp    f010f4d1 <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f4ab:	8b 55 10             	mov    0x10(%ebp),%edx
f010f4ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4b1:	83 ec 08             	sub    $0x8,%esp
f010f4b4:	52                   	push   %edx
f010f4b5:	50                   	push   %eax
f010f4b6:	e8 a8 f1 00 00       	call   f011e663 <sys_utilities>
f010f4bb:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f4be:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4c3:	eb 0c                	jmp    f010f4d1 <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010f4c5:	b8 03 00 00 00       	mov    $0x3,%eax
f010f4ca:	eb 05                	jmp    f010f4d1 <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f4cc:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f4d1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f4d4:	5b                   	pop    %ebx
f010f4d5:	5e                   	pop    %esi
f010f4d6:	5d                   	pop    %ebp
f010f4d7:	c3                   	ret    

f010f4d8 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f4d8:	55                   	push   %ebp
f010f4d9:	89 e5                	mov    %esp,%ebp
f010f4db:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f4de:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4e1:	8b 00                	mov    (%eax),%eax
f010f4e3:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f4e6:	8b 45 10             	mov    0x10(%ebp),%eax
f010f4e9:	8b 00                	mov    (%eax),%eax
f010f4eb:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f4ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f4f5:	e9 ca 00 00 00       	jmp    f010f5c4 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f4fa:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f4fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f500:	01 d0                	add    %edx,%eax
f010f502:	89 c2                	mov    %eax,%edx
f010f504:	c1 ea 1f             	shr    $0x1f,%edx
f010f507:	01 d0                	add    %edx,%eax
f010f509:	d1 f8                	sar    %eax
f010f50b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f50e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f511:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f514:	eb 03                	jmp    f010f519 <stab_binsearch+0x41>
			m--;
f010f516:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f519:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f51c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f51f:	7c 1e                	jl     f010f53f <stab_binsearch+0x67>
f010f521:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f524:	89 d0                	mov    %edx,%eax
f010f526:	01 c0                	add    %eax,%eax
f010f528:	01 d0                	add    %edx,%eax
f010f52a:	c1 e0 02             	shl    $0x2,%eax
f010f52d:	89 c2                	mov    %eax,%edx
f010f52f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f532:	01 d0                	add    %edx,%eax
f010f534:	8a 40 04             	mov    0x4(%eax),%al
f010f537:	0f b6 c0             	movzbl %al,%eax
f010f53a:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f53d:	75 d7                	jne    f010f516 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f53f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f542:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f545:	7d 09                	jge    f010f550 <stab_binsearch+0x78>
			l = true_m + 1;
f010f547:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f54a:	40                   	inc    %eax
f010f54b:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f54e:	eb 74                	jmp    f010f5c4 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f550:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f557:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f55a:	89 d0                	mov    %edx,%eax
f010f55c:	01 c0                	add    %eax,%eax
f010f55e:	01 d0                	add    %edx,%eax
f010f560:	c1 e0 02             	shl    $0x2,%eax
f010f563:	89 c2                	mov    %eax,%edx
f010f565:	8b 45 08             	mov    0x8(%ebp),%eax
f010f568:	01 d0                	add    %edx,%eax
f010f56a:	8b 40 08             	mov    0x8(%eax),%eax
f010f56d:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f570:	73 11                	jae    f010f583 <stab_binsearch+0xab>
			*region_left = m;
f010f572:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f575:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f578:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f57a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f57d:	40                   	inc    %eax
f010f57e:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f581:	eb 41                	jmp    f010f5c4 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f583:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f586:	89 d0                	mov    %edx,%eax
f010f588:	01 c0                	add    %eax,%eax
f010f58a:	01 d0                	add    %edx,%eax
f010f58c:	c1 e0 02             	shl    $0x2,%eax
f010f58f:	89 c2                	mov    %eax,%edx
f010f591:	8b 45 08             	mov    0x8(%ebp),%eax
f010f594:	01 d0                	add    %edx,%eax
f010f596:	8b 40 08             	mov    0x8(%eax),%eax
f010f599:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f59c:	76 14                	jbe    f010f5b2 <stab_binsearch+0xda>
			*region_right = m - 1;
f010f59e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f5a1:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f5a4:	8b 45 10             	mov    0x10(%ebp),%eax
f010f5a7:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f5a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f5ac:	48                   	dec    %eax
f010f5ad:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f5b0:	eb 12                	jmp    f010f5c4 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f5b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f5b8:	89 10                	mov    %edx,(%eax)
			l = m;
f010f5ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f5bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f5c0:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f5c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f5c7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f5ca:	0f 8e 2a ff ff ff    	jle    f010f4fa <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f5d0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f5d4:	75 0f                	jne    f010f5e5 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f5d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5d9:	8b 00                	mov    (%eax),%eax
f010f5db:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f5de:	8b 45 10             	mov    0x10(%ebp),%eax
f010f5e1:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f5e3:	eb 3d                	jmp    f010f622 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f5e5:	8b 45 10             	mov    0x10(%ebp),%eax
f010f5e8:	8b 00                	mov    (%eax),%eax
f010f5ea:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f5ed:	eb 03                	jmp    f010f5f2 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f5ef:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f5f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5f5:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f5f7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f5fa:	7d 1e                	jge    f010f61a <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f5fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f5ff:	89 d0                	mov    %edx,%eax
f010f601:	01 c0                	add    %eax,%eax
f010f603:	01 d0                	add    %edx,%eax
f010f605:	c1 e0 02             	shl    $0x2,%eax
f010f608:	89 c2                	mov    %eax,%edx
f010f60a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f60d:	01 d0                	add    %edx,%eax
f010f60f:	8a 40 04             	mov    0x4(%eax),%al
f010f612:	0f b6 c0             	movzbl %al,%eax
f010f615:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f618:	75 d5                	jne    f010f5ef <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f61a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f61d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f620:	89 10                	mov    %edx,(%eax)
	}
}
f010f622:	90                   	nop
f010f623:	c9                   	leave  
f010f624:	c3                   	ret    

f010f625 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f625:	55                   	push   %ebp
f010f626:	89 e5                	mov    %esp,%ebp
f010f628:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f62b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f62e:	c7 00 c8 7e 12 f0    	movl   $0xf0127ec8,(%eax)
	info->eip_line = 0;
f010f634:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f637:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f63e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f641:	c7 40 08 c8 7e 12 f0 	movl   $0xf0127ec8,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f648:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f64b:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f652:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f655:	8b 55 08             	mov    0x8(%ebp),%edx
f010f658:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f65b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f65e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f665:	8b 45 08             	mov    0x8(%ebp),%eax
f010f668:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f66d:	76 1e                	jbe    f010f68d <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f66f:	c7 45 f4 44 1c 13 f0 	movl   $0xf0131c44,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f676:	c7 45 f0 78 5a 16 f0 	movl   $0xf0165a78,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f67d:	c7 45 ec 79 5a 16 f0 	movl   $0xf0165a79,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f684:	c7 45 e8 e9 78 17 f0 	movl   $0xf01778e9,-0x18(%ebp)
f010f68b:	eb 2a                	jmp    f010f6b7 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f68d:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f694:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f697:	8b 00                	mov    (%eax),%eax
f010f699:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f69c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f69f:	8b 40 04             	mov    0x4(%eax),%eax
f010f6a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f6a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f6a8:	8b 40 08             	mov    0x8(%eax),%eax
f010f6ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f6ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f6b1:	8b 40 0c             	mov    0xc(%eax),%eax
f010f6b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f6b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f6ba:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f6bd:	76 0a                	jbe    f010f6c9 <debuginfo_eip+0xa4>
f010f6bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f6c2:	48                   	dec    %eax
f010f6c3:	8a 00                	mov    (%eax),%al
f010f6c5:	84 c0                	test   %al,%al
f010f6c7:	74 0a                	je     f010f6d3 <debuginfo_eip+0xae>
		return -1;
f010f6c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f6ce:	e9 01 02 00 00       	jmp    f010f8d4 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f6d3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f6da:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f6dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f6e0:	29 c2                	sub    %eax,%edx
f010f6e2:	89 d0                	mov    %edx,%eax
f010f6e4:	c1 f8 02             	sar    $0x2,%eax
f010f6e7:	89 c2                	mov    %eax,%edx
f010f6e9:	89 d0                	mov    %edx,%eax
f010f6eb:	c1 e0 02             	shl    $0x2,%eax
f010f6ee:	01 d0                	add    %edx,%eax
f010f6f0:	c1 e0 02             	shl    $0x2,%eax
f010f6f3:	01 d0                	add    %edx,%eax
f010f6f5:	c1 e0 02             	shl    $0x2,%eax
f010f6f8:	01 d0                	add    %edx,%eax
f010f6fa:	89 c1                	mov    %eax,%ecx
f010f6fc:	c1 e1 08             	shl    $0x8,%ecx
f010f6ff:	01 c8                	add    %ecx,%eax
f010f701:	89 c1                	mov    %eax,%ecx
f010f703:	c1 e1 10             	shl    $0x10,%ecx
f010f706:	01 c8                	add    %ecx,%eax
f010f708:	01 c0                	add    %eax,%eax
f010f70a:	01 d0                	add    %edx,%eax
f010f70c:	48                   	dec    %eax
f010f70d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f710:	ff 75 08             	pushl  0x8(%ebp)
f010f713:	6a 64                	push   $0x64
f010f715:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f718:	50                   	push   %eax
f010f719:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f71c:	50                   	push   %eax
f010f71d:	ff 75 f4             	pushl  -0xc(%ebp)
f010f720:	e8 b3 fd ff ff       	call   f010f4d8 <stab_binsearch>
f010f725:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f728:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f72b:	85 c0                	test   %eax,%eax
f010f72d:	75 0a                	jne    f010f739 <debuginfo_eip+0x114>
		return -1;
f010f72f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f734:	e9 9b 01 00 00       	jmp    f010f8d4 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f739:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f73c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f73f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f742:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f745:	ff 75 08             	pushl  0x8(%ebp)
f010f748:	6a 24                	push   $0x24
f010f74a:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f74d:	50                   	push   %eax
f010f74e:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f751:	50                   	push   %eax
f010f752:	ff 75 f4             	pushl  -0xc(%ebp)
f010f755:	e8 7e fd ff ff       	call   f010f4d8 <stab_binsearch>
f010f75a:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f75d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f760:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f763:	39 c2                	cmp    %eax,%edx
f010f765:	0f 8f 86 00 00 00    	jg     f010f7f1 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f76b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f76e:	89 c2                	mov    %eax,%edx
f010f770:	89 d0                	mov    %edx,%eax
f010f772:	01 c0                	add    %eax,%eax
f010f774:	01 d0                	add    %edx,%eax
f010f776:	c1 e0 02             	shl    $0x2,%eax
f010f779:	89 c2                	mov    %eax,%edx
f010f77b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f77e:	01 d0                	add    %edx,%eax
f010f780:	8b 00                	mov    (%eax),%eax
f010f782:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f785:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f788:	29 d1                	sub    %edx,%ecx
f010f78a:	89 ca                	mov    %ecx,%edx
f010f78c:	39 d0                	cmp    %edx,%eax
f010f78e:	73 22                	jae    f010f7b2 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f790:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f793:	89 c2                	mov    %eax,%edx
f010f795:	89 d0                	mov    %edx,%eax
f010f797:	01 c0                	add    %eax,%eax
f010f799:	01 d0                	add    %edx,%eax
f010f79b:	c1 e0 02             	shl    $0x2,%eax
f010f79e:	89 c2                	mov    %eax,%edx
f010f7a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f7a3:	01 d0                	add    %edx,%eax
f010f7a5:	8b 10                	mov    (%eax),%edx
f010f7a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f7aa:	01 c2                	add    %eax,%edx
f010f7ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7af:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f7b2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f7b5:	89 c2                	mov    %eax,%edx
f010f7b7:	89 d0                	mov    %edx,%eax
f010f7b9:	01 c0                	add    %eax,%eax
f010f7bb:	01 d0                	add    %edx,%eax
f010f7bd:	c1 e0 02             	shl    $0x2,%eax
f010f7c0:	89 c2                	mov    %eax,%edx
f010f7c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f7c5:	01 d0                	add    %edx,%eax
f010f7c7:	8b 50 08             	mov    0x8(%eax),%edx
f010f7ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7cd:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f7d0:	8b 55 08             	mov    0x8(%ebp),%edx
f010f7d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7d6:	8b 40 10             	mov    0x10(%eax),%eax
f010f7d9:	29 c2                	sub    %eax,%edx
f010f7db:	89 d0                	mov    %edx,%eax
f010f7dd:	c1 f8 02             	sar    $0x2,%eax
f010f7e0:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f7e3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f7e6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f7e9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f7ec:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f7ef:	eb 15                	jmp    f010f806 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f7f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7f4:	8b 55 08             	mov    0x8(%ebp),%edx
f010f7f7:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f7fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f7fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f800:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f803:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f806:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f809:	8b 40 08             	mov    0x8(%eax),%eax
f010f80c:	83 ec 08             	sub    $0x8,%esp
f010f80f:	6a 3a                	push   $0x3a
f010f811:	50                   	push   %eax
f010f812:	e8 0d 09 01 00       	call   f0120124 <strfind>
f010f817:	83 c4 10             	add    $0x10,%esp
f010f81a:	89 c2                	mov    %eax,%edx
f010f81c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f81f:	8b 40 08             	mov    0x8(%eax),%eax
f010f822:	29 c2                	sub    %eax,%edx
f010f824:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f827:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f82a:	eb 03                	jmp    f010f82f <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f82c:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f82f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f832:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f835:	7c 4e                	jl     f010f885 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f837:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f83a:	89 d0                	mov    %edx,%eax
f010f83c:	01 c0                	add    %eax,%eax
f010f83e:	01 d0                	add    %edx,%eax
f010f840:	c1 e0 02             	shl    $0x2,%eax
f010f843:	89 c2                	mov    %eax,%edx
f010f845:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f848:	01 d0                	add    %edx,%eax
f010f84a:	8a 40 04             	mov    0x4(%eax),%al
f010f84d:	3c 84                	cmp    $0x84,%al
f010f84f:	74 34                	je     f010f885 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f851:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f854:	89 d0                	mov    %edx,%eax
f010f856:	01 c0                	add    %eax,%eax
f010f858:	01 d0                	add    %edx,%eax
f010f85a:	c1 e0 02             	shl    $0x2,%eax
f010f85d:	89 c2                	mov    %eax,%edx
f010f85f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f862:	01 d0                	add    %edx,%eax
f010f864:	8a 40 04             	mov    0x4(%eax),%al
f010f867:	3c 64                	cmp    $0x64,%al
f010f869:	75 c1                	jne    f010f82c <debuginfo_eip+0x207>
f010f86b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f86e:	89 d0                	mov    %edx,%eax
f010f870:	01 c0                	add    %eax,%eax
f010f872:	01 d0                	add    %edx,%eax
f010f874:	c1 e0 02             	shl    $0x2,%eax
f010f877:	89 c2                	mov    %eax,%edx
f010f879:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f87c:	01 d0                	add    %edx,%eax
f010f87e:	8b 40 08             	mov    0x8(%eax),%eax
f010f881:	85 c0                	test   %eax,%eax
f010f883:	74 a7                	je     f010f82c <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f885:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f888:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f88b:	7c 42                	jl     f010f8cf <debuginfo_eip+0x2aa>
f010f88d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f890:	89 d0                	mov    %edx,%eax
f010f892:	01 c0                	add    %eax,%eax
f010f894:	01 d0                	add    %edx,%eax
f010f896:	c1 e0 02             	shl    $0x2,%eax
f010f899:	89 c2                	mov    %eax,%edx
f010f89b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f89e:	01 d0                	add    %edx,%eax
f010f8a0:	8b 00                	mov    (%eax),%eax
f010f8a2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f8a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f8a8:	29 d1                	sub    %edx,%ecx
f010f8aa:	89 ca                	mov    %ecx,%edx
f010f8ac:	39 d0                	cmp    %edx,%eax
f010f8ae:	73 1f                	jae    f010f8cf <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f8b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f8b3:	89 d0                	mov    %edx,%eax
f010f8b5:	01 c0                	add    %eax,%eax
f010f8b7:	01 d0                	add    %edx,%eax
f010f8b9:	c1 e0 02             	shl    $0x2,%eax
f010f8bc:	89 c2                	mov    %eax,%edx
f010f8be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f8c1:	01 d0                	add    %edx,%eax
f010f8c3:	8b 10                	mov    (%eax),%edx
f010f8c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f8c8:	01 c2                	add    %eax,%edx
f010f8ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8cd:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f8cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f8d4:	c9                   	leave  
f010f8d5:	c3                   	ret    

f010f8d6 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f8d6:	55                   	push   %ebp
f010f8d7:	89 e5                	mov    %esp,%ebp
f010f8d9:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f8dc:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f8e0:	74 1c                	je     f010f8fe <setPageReplacmentAlgorithmLRU+0x28>
f010f8e2:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f8e6:	74 16                	je     f010f8fe <setPageReplacmentAlgorithmLRU+0x28>
f010f8e8:	68 d4 7e 12 f0       	push   $0xf0127ed4
f010f8ed:	68 1e 7f 12 f0       	push   $0xf0127f1e
f010f8f2:	6a 1a                	push   $0x1a
f010f8f4:	68 33 7f 12 f0       	push   $0xf0127f33
f010f8f9:	e8 3b 0a ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f8fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010f901:	a3 50 f8 f1 f0       	mov    %eax,0xf0f1f850
}
f010f906:	90                   	nop
f010f907:	c9                   	leave  
f010f908:	c3                   	ret    

f010f909 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f909:	55                   	push   %ebp
f010f90a:	89 e5                	mov    %esp,%ebp
f010f90c:	c7 05 50 f8 f1 f0 03 	movl   $0x3,0xf0f1f850
f010f913:	00 00 00 
f010f916:	90                   	nop
f010f917:	5d                   	pop    %ebp
f010f918:	c3                   	ret    

f010f919 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f919:	55                   	push   %ebp
f010f91a:	89 e5                	mov    %esp,%ebp
f010f91c:	c7 05 50 f8 f1 f0 04 	movl   $0x4,0xf0f1f850
f010f923:	00 00 00 
f010f926:	90                   	nop
f010f927:	5d                   	pop    %ebp
f010f928:	c3                   	ret    

f010f929 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f929:	55                   	push   %ebp
f010f92a:	89 e5                	mov    %esp,%ebp
f010f92c:	c7 05 50 f8 f1 f0 05 	movl   $0x5,0xf0f1f850
f010f933:	00 00 00 
f010f936:	90                   	nop
f010f937:	5d                   	pop    %ebp
f010f938:	c3                   	ret    

f010f939 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010f939:	55                   	push   %ebp
f010f93a:	89 e5                	mov    %esp,%ebp
f010f93c:	c7 05 50 f8 f1 f0 07 	movl   $0x7,0xf0f1f850
f010f943:	00 00 00 
f010f946:	90                   	nop
f010f947:	5d                   	pop    %ebp
f010f948:	c3                   	ret    

f010f949 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010f949:	55                   	push   %ebp
f010f94a:	89 e5                	mov    %esp,%ebp
f010f94c:	c7 05 50 f8 f1 f0 06 	movl   $0x6,0xf0f1f850
f010f953:	00 00 00 
f010f956:	8b 45 08             	mov    0x8(%ebp),%eax
f010f959:	a3 14 f1 71 f0       	mov    %eax,0xf071f114
f010f95e:	90                   	nop
f010f95f:	5d                   	pop    %ebp
f010f960:	c3                   	ret    

f010f961 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010f961:	55                   	push   %ebp
f010f962:	89 e5                	mov    %esp,%ebp
f010f964:	8b 15 50 f8 f1 f0    	mov    0xf0f1f850,%edx
f010f96a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f96d:	39 c2                	cmp    %eax,%edx
f010f96f:	0f 94 c0             	sete   %al
f010f972:	0f b6 c0             	movzbl %al,%eax
f010f975:	5d                   	pop    %ebp
f010f976:	c3                   	ret    

f010f977 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010f977:	55                   	push   %ebp
f010f978:	89 e5                	mov    %esp,%ebp
f010f97a:	a1 50 f8 f1 f0       	mov    0xf0f1f850,%eax
f010f97f:	83 f8 03             	cmp    $0x3,%eax
f010f982:	75 07                	jne    f010f98b <isPageReplacmentAlgorithmCLOCK+0x14>
f010f984:	b8 01 00 00 00       	mov    $0x1,%eax
f010f989:	eb 05                	jmp    f010f990 <isPageReplacmentAlgorithmCLOCK+0x19>
f010f98b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f990:	5d                   	pop    %ebp
f010f991:	c3                   	ret    

f010f992 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f992:	55                   	push   %ebp
f010f993:	89 e5                	mov    %esp,%ebp
f010f995:	a1 50 f8 f1 f0       	mov    0xf0f1f850,%eax
f010f99a:	83 f8 04             	cmp    $0x4,%eax
f010f99d:	75 07                	jne    f010f9a6 <isPageReplacmentAlgorithmFIFO+0x14>
f010f99f:	b8 01 00 00 00       	mov    $0x1,%eax
f010f9a4:	eb 05                	jmp    f010f9ab <isPageReplacmentAlgorithmFIFO+0x19>
f010f9a6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9ab:	5d                   	pop    %ebp
f010f9ac:	c3                   	ret    

f010f9ad <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f9ad:	55                   	push   %ebp
f010f9ae:	89 e5                	mov    %esp,%ebp
f010f9b0:	a1 50 f8 f1 f0       	mov    0xf0f1f850,%eax
f010f9b5:	83 f8 05             	cmp    $0x5,%eax
f010f9b8:	75 07                	jne    f010f9c1 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f9ba:	b8 01 00 00 00       	mov    $0x1,%eax
f010f9bf:	eb 05                	jmp    f010f9c6 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f9c1:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9c6:	5d                   	pop    %ebp
f010f9c7:	c3                   	ret    

f010f9c8 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f9c8:	55                   	push   %ebp
f010f9c9:	89 e5                	mov    %esp,%ebp
f010f9cb:	a1 50 f8 f1 f0       	mov    0xf0f1f850,%eax
f010f9d0:	83 f8 07             	cmp    $0x7,%eax
f010f9d3:	75 07                	jne    f010f9dc <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f9d5:	b8 01 00 00 00       	mov    $0x1,%eax
f010f9da:	eb 05                	jmp    f010f9e1 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f9dc:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9e1:	5d                   	pop    %ebp
f010f9e2:	c3                   	ret    

f010f9e3 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f9e3:	55                   	push   %ebp
f010f9e4:	89 e5                	mov    %esp,%ebp
f010f9e6:	a1 50 f8 f1 f0       	mov    0xf0f1f850,%eax
f010f9eb:	83 f8 06             	cmp    $0x6,%eax
f010f9ee:	75 07                	jne    f010f9f7 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f9f0:	b8 01 00 00 00       	mov    $0x1,%eax
f010f9f5:	eb 05                	jmp    f010f9fc <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f9f7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9fc:	5d                   	pop    %ebp
f010f9fd:	c3                   	ret    

f010f9fe <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f9fe:	55                   	push   %ebp
f010f9ff:	89 e5                	mov    %esp,%ebp
f010fa01:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa04:	a3 78 f5 b1 f0       	mov    %eax,0xf0b1f578
f010fa09:	90                   	nop
f010fa0a:	5d                   	pop    %ebp
f010fa0b:	c3                   	ret    

f010fa0c <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010fa0c:	55                   	push   %ebp
f010fa0d:	89 e5                	mov    %esp,%ebp
f010fa0f:	a1 78 f5 b1 f0       	mov    0xf0b1f578,%eax
f010fa14:	5d                   	pop    %ebp
f010fa15:	c3                   	ret    

f010fa16 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010fa16:	55                   	push   %ebp
f010fa17:	89 e5                	mov    %esp,%ebp
f010fa19:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa1c:	a3 d4 f8 f1 f0       	mov    %eax,0xf0f1f8d4
f010fa21:	90                   	nop
f010fa22:	5d                   	pop    %ebp
f010fa23:	c3                   	ret    

f010fa24 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010fa24:	55                   	push   %ebp
f010fa25:	89 e5                	mov    %esp,%ebp
f010fa27:	a1 d4 f8 f1 f0       	mov    0xf0f1f8d4,%eax
f010fa2c:	5d                   	pop    %ebp
f010fa2d:	c3                   	ret    

f010fa2e <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010fa2e:	55                   	push   %ebp
f010fa2f:	89 e5                	mov    %esp,%ebp
f010fa31:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa34:	a3 70 f9 f1 f0       	mov    %eax,0xf0f1f970
f010fa39:	90                   	nop
f010fa3a:	5d                   	pop    %ebp
f010fa3b:	c3                   	ret    

f010fa3c <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010fa3c:	55                   	push   %ebp
f010fa3d:	89 e5                	mov    %esp,%ebp
f010fa3f:	a1 70 f9 f1 f0       	mov    0xf0f1f970,%eax
f010fa44:	5d                   	pop    %ebp
f010fa45:	c3                   	ret    

f010fa46 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010fa46:	55                   	push   %ebp
f010fa47:	89 e5                	mov    %esp,%ebp
f010fa49:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010fa4c:	0f 20 d0             	mov    %cr2,%eax
f010fa4f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010fa52:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010fa55:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010fa58:	e8 c8 c2 ff ff       	call   f010bd25 <get_cpu_proc>
f010fa5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010fa60:	a1 0c 6e 6f f0       	mov    0xf06f6e0c,%eax
f010fa65:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa68:	75 50                	jne    f010faba <fault_handler+0x74>
f010fa6a:	a1 18 6e 6f f0       	mov    0xf06f6e18,%eax
f010fa6f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010fa72:	75 46                	jne    f010faba <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010fa74:	a0 14 6e 6f f0       	mov    0xf06f6e14,%al
f010fa79:	40                   	inc    %eax
f010fa7a:	a2 14 6e 6f f0       	mov    %al,0xf06f6e14
		if (num_repeated_fault == 3)
f010fa7f:	a0 14 6e 6f f0       	mov    0xf06f6e14,%al
f010fa84:	3c 03                	cmp    $0x3,%al
f010fa86:	75 4d                	jne    f010fad5 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010fa88:	83 ec 0c             	sub    $0xc,%esp
f010fa8b:	ff 75 08             	pushl  0x8(%ebp)
f010fa8e:	e8 48 e9 ff ff       	call   f010e3db <print_trapframe>
f010fa93:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010fa96:	8b 15 08 6e 6f f0    	mov    0xf06f6e08,%edx
f010fa9c:	a1 10 6e 6f f0       	mov    0xf06f6e10,%eax
f010faa1:	83 ec 08             	sub    $0x8,%esp
f010faa4:	ff 75 ec             	pushl  -0x14(%ebp)
f010faa7:	52                   	push   %edx
f010faa8:	50                   	push   %eax
f010faa9:	68 50 7f 12 f0       	push   $0xf0127f50
f010faae:	6a 58                	push   $0x58
f010fab0:	68 33 7f 12 f0       	push   $0xf0127f33
f010fab5:	e8 7f 08 ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010faba:	a1 0c 6e 6f f0       	mov    0xf06f6e0c,%eax
f010fabf:	a3 10 6e 6f f0       	mov    %eax,0xf06f6e10
		before_last_eip = last_eip;
f010fac4:	a1 04 6e 6f f0       	mov    0xf06f6e04,%eax
f010fac9:	a3 08 6e 6f f0       	mov    %eax,0xf06f6e08
		num_repeated_fault = 0;
f010face:	c6 05 14 6e 6f f0 00 	movb   $0x0,0xf06f6e14
	}
	last_eip = (uint32)tf->tf_eip;
f010fad5:	8b 45 08             	mov    0x8(%ebp),%eax
f010fad8:	8b 40 30             	mov    0x30(%eax),%eax
f010fadb:	a3 04 6e 6f f0       	mov    %eax,0xf06f6e04
	last_fault_va = fault_va ;
f010fae0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fae3:	a3 0c 6e 6f f0       	mov    %eax,0xf06f6e0c
	last_faulted_env = cur_env;
f010fae8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010faeb:	a3 18 6e 6f f0       	mov    %eax,0xf06f6e18
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010faf0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010faf7:	8b 45 08             	mov    0x8(%ebp),%eax
f010fafa:	8b 40 34             	mov    0x34(%eax),%eax
f010fafd:	0f b7 c0             	movzwl %ax,%eax
f010fb00:	83 e0 03             	and    $0x3,%eax
f010fb03:	83 f8 03             	cmp    $0x3,%eax
f010fb06:	75 07                	jne    f010fb0f <fault_handler+0xc9>
		userTrap = 1;
f010fb08:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010fb0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fb13:	0f 85 c2 00 00 00    	jne    f010fbdb <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010fb19:	e8 19 79 ff ff       	call   f0107437 <mycpu>
f010fb1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010fb21:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010fb25:	74 2f                	je     f010fb56 <fault_handler+0x110>
f010fb27:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb2a:	8b 40 70             	mov    0x70(%eax),%eax
f010fb2d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fb30:	77 24                	ja     f010fb56 <fault_handler+0x110>
f010fb32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb35:	8b 40 70             	mov    0x70(%eax),%eax
f010fb38:	05 00 10 00 00       	add    $0x1000,%eax
f010fb3d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fb40:	76 14                	jbe    f010fb56 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010fb42:	83 ec 04             	sub    $0x4,%esp
f010fb45:	68 c0 7f 12 f0       	push   $0xf0127fc0
f010fb4a:	6a 6f                	push   $0x6f
f010fb4c:	68 33 7f 12 f0       	push   $0xf0127f33
f010fb51:	e8 e3 07 ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010fb56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb59:	8b 40 08             	mov    0x8(%eax),%eax
f010fb5c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fb5f:	77 5d                	ja     f010fbbe <fault_handler+0x178>
f010fb61:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb64:	8b 40 08             	mov    0x8(%eax),%eax
f010fb67:	05 00 10 00 00       	add    $0x1000,%eax
f010fb6c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fb6f:	76 4d                	jbe    f010fbbe <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010fb71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb74:	ba 60 f2 b1 f0       	mov    $0xf0b1f260,%edx
f010fb79:	29 d0                	sub    %edx,%eax
f010fb7b:	c1 f8 03             	sar    $0x3,%eax
f010fb7e:	89 c2                	mov    %eax,%edx
f010fb80:	89 d0                	mov    %edx,%eax
f010fb82:	c1 e0 02             	shl    $0x2,%eax
f010fb85:	01 d0                	add    %edx,%eax
f010fb87:	01 c0                	add    %eax,%eax
f010fb89:	01 d0                	add    %edx,%eax
f010fb8b:	c1 e0 03             	shl    $0x3,%eax
f010fb8e:	01 d0                	add    %edx,%eax
f010fb90:	89 c1                	mov    %eax,%ecx
f010fb92:	c1 e1 0b             	shl    $0xb,%ecx
f010fb95:	01 c8                	add    %ecx,%eax
f010fb97:	c1 e0 05             	shl    $0x5,%eax
f010fb9a:	01 d0                	add    %edx,%eax
f010fb9c:	c1 e0 02             	shl    $0x2,%eax
f010fb9f:	01 d0                	add    %edx,%eax
f010fba1:	01 c0                	add    %eax,%eax
f010fba3:	01 d0                	add    %edx,%eax
f010fba5:	c1 e0 03             	shl    $0x3,%eax
f010fba8:	01 d0                	add    %edx,%eax
f010fbaa:	f7 d8                	neg    %eax
f010fbac:	50                   	push   %eax
f010fbad:	68 e8 7f 12 f0       	push   $0xf0127fe8
f010fbb2:	6a 71                	push   $0x71
f010fbb4:	68 33 7f 12 f0       	push   $0xf0127f33
f010fbb9:	e8 7b 07 ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010fbbe:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010fbc5:	76 3a                	jbe    f010fc01 <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010fbc7:	83 ec 04             	sub    $0x4,%esp
f010fbca:	68 1c 80 12 f0       	push   $0xf012801c
f010fbcf:	6a 74                	push   $0x74
f010fbd1:	68 33 7f 12 f0       	push   $0xf0127f33
f010fbd6:	e8 5e 07 ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010fbdb:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010fbe2:	76 1d                	jbe    f010fc01 <fault_handler+0x1bb>
f010fbe4:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010fbeb:	77 14                	ja     f010fc01 <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010fbed:	83 ec 04             	sub    $0x4,%esp
f010fbf0:	68 40 80 12 f0       	push   $0xf0128040
f010fbf5:	6a 7c                	push   $0x7c
f010fbf7:	68 33 7f 12 f0       	push   $0xf0127f33
f010fbfc:	e8 38 07 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010fc01:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fc04:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010fc07:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fc0b:	75 25                	jne    f010fc32 <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010fc0d:	83 ec 0c             	sub    $0xc,%esp
f010fc10:	ff 75 08             	pushl  0x8(%ebp)
f010fc13:	e8 c3 e7 ff ff       	call   f010e3db <print_trapframe>
f010fc18:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010fc1b:	83 ec 04             	sub    $0x4,%esp
f010fc1e:	68 61 80 12 f0       	push   $0xf0128061
f010fc23:	68 85 00 00 00       	push   $0x85
f010fc28:	68 33 7f 12 f0       	push   $0xf0127f33
f010fc2d:	e8 07 07 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010fc32:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc35:	8b 40 64             	mov    0x64(%eax),%eax
f010fc38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fc3b:	c1 ea 16             	shr    $0x16,%edx
f010fc3e:	c1 e2 02             	shl    $0x2,%edx
f010fc41:	01 d0                	add    %edx,%eax
f010fc43:	8b 00                	mov    (%eax),%eax
f010fc45:	83 e0 01             	and    $0x1,%eax
f010fc48:	85 c0                	test   %eax,%eax
f010fc4a:	75 2b                	jne    f010fc77 <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010fc4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc4f:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010fc55:	8d 50 01             	lea    0x1(%eax),%edx
f010fc58:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc5b:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010fc61:	83 ec 08             	sub    $0x8,%esp
f010fc64:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc67:	ff 75 e0             	pushl  -0x20(%ebp)
f010fc6a:	e8 1e 01 00 00       	call   f010fd8d <table_fault_handler>
f010fc6f:	83 c4 10             	add    $0x10,%esp
f010fc72:	e9 07 01 00 00       	jmp    f010fd7e <fault_handler+0x338>
	}
	else
	{
		if (userTrap)
f010fc77:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fc7b:	0f 84 82 00 00 00    	je     f010fd03 <fault_handler+0x2bd>
		{
			//============================================================================================
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010fc81:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010fc88:	76 07                	jbe    f010fc91 <fault_handler+0x24b>
			{
				env_exit();
f010fc8a:	e8 54 c0 ff ff       	call   f010bce3 <env_exit>
f010fc8f:	eb 72                	jmp    f010fd03 <fault_handler+0x2bd>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010fc91:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc94:	8b 40 64             	mov    0x64(%eax),%eax
f010fc97:	83 ec 08             	sub    $0x8,%esp
f010fc9a:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc9d:	50                   	push   %eax
f010fc9e:	e8 ca a3 ff ff       	call   f010a06d <pt_get_page_permissions>
f010fca3:	83 c4 10             	add    $0x10,%esp
f010fca6:	25 00 02 00 00       	and    $0x200,%eax
f010fcab:	85 c0                	test   %eax,%eax
f010fcad:	75 17                	jne    f010fcc6 <fault_handler+0x280>
f010fcaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fcb2:	85 c0                	test   %eax,%eax
f010fcb4:	79 10                	jns    f010fcc6 <fault_handler+0x280>
f010fcb6:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010fcbd:	77 07                	ja     f010fcc6 <fault_handler+0x280>
			{
				env_exit();
f010fcbf:	e8 1f c0 ff ff       	call   f010bce3 <env_exit>
f010fcc4:	eb 3d                	jmp    f010fd03 <fault_handler+0x2bd>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && (!(pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE)))
f010fcc6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fcc9:	8b 40 64             	mov    0x64(%eax),%eax
f010fccc:	83 ec 08             	sub    $0x8,%esp
f010fccf:	ff 75 ec             	pushl  -0x14(%ebp)
f010fcd2:	50                   	push   %eax
f010fcd3:	e8 95 a3 ff ff       	call   f010a06d <pt_get_page_permissions>
f010fcd8:	83 c4 10             	add    $0x10,%esp
f010fcdb:	83 e0 01             	and    $0x1,%eax
f010fcde:	85 c0                	test   %eax,%eax
f010fce0:	74 21                	je     f010fd03 <fault_handler+0x2bd>
f010fce2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fce5:	8b 40 64             	mov    0x64(%eax),%eax
f010fce8:	83 ec 08             	sub    $0x8,%esp
f010fceb:	ff 75 ec             	pushl  -0x14(%ebp)
f010fcee:	50                   	push   %eax
f010fcef:	e8 79 a3 ff ff       	call   f010a06d <pt_get_page_permissions>
f010fcf4:	83 c4 10             	add    $0x10,%esp
f010fcf7:	83 e0 02             	and    $0x2,%eax
f010fcfa:	85 c0                	test   %eax,%eax
f010fcfc:	75 05                	jne    f010fd03 <fault_handler+0x2bd>
			{
				env_exit();
f010fcfe:	e8 e0 bf ff ff       	call   f010bce3 <env_exit>
			}
			//============================================================================================
		}

		//2022: Check if fault due to Access Rights
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010fd03:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd06:	8b 40 64             	mov    0x64(%eax),%eax
f010fd09:	83 ec 08             	sub    $0x8,%esp
f010fd0c:	ff 75 ec             	pushl  -0x14(%ebp)
f010fd0f:	50                   	push   %eax
f010fd10:	e8 58 a3 ff ff       	call   f010a06d <pt_get_page_permissions>
f010fd15:	83 c4 10             	add    $0x10,%esp
f010fd18:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010fd1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fd1e:	83 e0 01             	and    $0x1,%eax
f010fd21:	85 c0                	test   %eax,%eax
f010fd23:	74 17                	je     f010fd3c <fault_handler+0x2f6>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010fd25:	ff 75 ec             	pushl  -0x14(%ebp)
f010fd28:	68 78 80 12 f0       	push   $0xf0128078
f010fd2d:	68 ad 00 00 00       	push   $0xad
f010fd32:	68 33 7f 12 f0       	push   $0xf0127f33
f010fd37:	e8 fd 05 ff ff       	call   f0100339 <_panic>
		//============================================================================================


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010fd3c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd3f:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010fd45:	8d 50 01             	lea    0x1(%eax),%edx
f010fd48:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd4b:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010fd51:	e8 ce fc ff ff       	call   f010fa24 <isBufferingEnabled>
f010fd56:	84 c0                	test   %al,%al
f010fd58:	74 13                	je     f010fd6d <fault_handler+0x327>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010fd5a:	83 ec 08             	sub    $0x8,%esp
f010fd5d:	ff 75 ec             	pushl  -0x14(%ebp)
f010fd60:	ff 75 e0             	pushl  -0x20(%ebp)
f010fd63:	e8 fe 01 00 00       	call   f010ff66 <__page_fault_handler_with_buffering>
f010fd68:	83 c4 10             	add    $0x10,%esp
f010fd6b:	eb 11                	jmp    f010fd7e <fault_handler+0x338>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010fd6d:	83 ec 08             	sub    $0x8,%esp
f010fd70:	ff 75 ec             	pushl  -0x14(%ebp)
f010fd73:	ff 75 e0             	pushl  -0x20(%ebp)
f010fd76:	e8 33 00 00 00       	call   f010fdae <page_fault_handler>
f010fd7b:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010fd7e:	0f 20 d8             	mov    %cr3,%eax
f010fd81:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010fd84:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fd87:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010fd8a:	90                   	nop
f010fd8b:	c9                   	leave  
f010fd8c:	c3                   	ret    

f010fd8d <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010fd8d:	55                   	push   %ebp
f010fd8e:	89 e5                	mov    %esp,%ebp
f010fd90:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010fd93:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd96:	8b 40 64             	mov    0x64(%eax),%eax
f010fd99:	83 ec 08             	sub    $0x8,%esp
f010fd9c:	ff 75 0c             	pushl  0xc(%ebp)
f010fd9f:	50                   	push   %eax
f010fda0:	e8 cb 8a ff ff       	call   f0108870 <create_page_table>
f010fda5:	83 c4 10             	add    $0x10,%esp
f010fda8:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010fdab:	90                   	nop
f010fdac:	c9                   	leave  
f010fdad:	c3                   	ret    

f010fdae <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010fdae:	55                   	push   %ebp
f010fdaf:	89 e5                	mov    %esp,%ebp
f010fdb1:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010fdb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fdbb:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdbe:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fdc4:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010fdc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdca:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fdd0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fdd3:	0f 86 74 01 00 00    	jbe    f010ff4d <page_fault_handler+0x19f>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010fdd9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fddc:	83 ec 08             	sub    $0x8,%esp
f010fddf:	50                   	push   %eax
f010fde0:	ff 75 08             	pushl  0x8(%ebp)
f010fde3:	e8 e7 48 ff ff       	call   f01046cf <pf_read_env_page>
f010fde8:	83 c4 10             	add    $0x10,%esp
f010fdeb:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010fdee:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010fdf2:	75 45                	jne    f010fe39 <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010fdf4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fdf7:	85 c0                	test   %eax,%eax
f010fdf9:	79 09                	jns    f010fe04 <page_fault_handler+0x56>
f010fdfb:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010fe02:	76 35                	jbe    f010fe39 <page_fault_handler+0x8b>
f010fe04:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010fe0b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe0e:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010fe13:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010fe16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fe19:	ba 00 00 00 00       	mov    $0x0,%edx
f010fe1e:	f7 75 e8             	divl   -0x18(%ebp)
f010fe21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fe24:	29 d0                	sub    %edx,%eax
f010fe26:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fe29:	77 09                	ja     f010fe34 <page_fault_handler+0x86>
f010fe2b:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010fe32:	76 05                	jbe    f010fe39 <page_fault_handler+0x8b>
			{
				env_exit();
f010fe34:	e8 aa be ff ff       	call   f010bce3 <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010fe39:	83 ec 0c             	sub    $0xc,%esp
f010fe3c:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010fe3f:	50                   	push   %eax
f010fe40:	e8 98 86 ff ff       	call   f01084dd <allocate_frame>
f010fe45:	83 c4 10             	add    $0x10,%esp
f010fe48:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010fe4b:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010fe4f:	74 34                	je     f010fe85 <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010fe51:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010fe54:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe57:	8b 40 64             	mov    0x64(%eax),%eax
f010fe5a:	6a 06                	push   $0x6
f010fe5c:	ff 75 0c             	pushl  0xc(%ebp)
f010fe5f:	52                   	push   %edx
f010fe60:	50                   	push   %eax
f010fe61:	e8 44 8b ff ff       	call   f01089aa <map_frame>
f010fe66:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010fe69:	83 ec 08             	sub    $0x8,%esp
f010fe6c:	ff 75 0c             	pushl  0xc(%ebp)
f010fe6f:	ff 75 08             	pushl  0x8(%ebp)
f010fe72:	e8 68 a3 ff ff       	call   f010a1df <env_page_ws_list_create_element>
f010fe77:	83 c4 10             	add    $0x10,%esp
f010fe7a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fe7d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010fe81:	75 30                	jne    f010feb3 <page_fault_handler+0x105>
f010fe83:	eb 17                	jmp    f010fe9c <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010fe85:	83 ec 04             	sub    $0x4,%esp
f010fe88:	68 bc 80 12 f0       	push   $0xf01280bc
f010fe8d:	68 03 01 00 00       	push   $0x103
f010fe92:	68 33 7f 12 f0       	push   $0xf0127f33
f010fe97:	e8 9d 04 ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fe9c:	83 ec 04             	sub    $0x4,%esp
f010fe9f:	68 d4 80 12 f0       	push   $0xf01280d4
f010fea4:	68 05 01 00 00       	push   $0x105
f010fea9:	68 33 7f 12 f0       	push   $0xf0127f33
f010feae:	e8 86 04 ff ff       	call   f0100339 <_panic>
f010feb3:	8b 45 08             	mov    0x8(%ebp),%eax
f010feb6:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010febc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010febf:	89 50 14             	mov    %edx,0x14(%eax)
f010fec2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fec5:	8b 40 14             	mov    0x14(%eax),%eax
f010fec8:	85 c0                	test   %eax,%eax
f010feca:	74 11                	je     f010fedd <page_fault_handler+0x12f>
f010fecc:	8b 45 08             	mov    0x8(%ebp),%eax
f010fecf:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010fed5:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fed8:	89 50 10             	mov    %edx,0x10(%eax)
f010fedb:	eb 0c                	jmp    f010fee9 <page_fault_handler+0x13b>
f010fedd:	8b 45 08             	mov    0x8(%ebp),%eax
f010fee0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fee3:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010fee9:	8b 45 08             	mov    0x8(%ebp),%eax
f010feec:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010feef:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010fef5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fef8:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010feff:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff02:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010ff08:	8d 50 01             	lea    0x1(%eax),%edx
f010ff0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff0e:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010ff14:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff17:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010ff1d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff20:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010ff26:	39 c2                	cmp    %eax,%edx
f010ff28:	75 14                	jne    f010ff3e <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010ff2a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff2d:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010ff33:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff36:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010ff3c:	eb 26                	jmp    f010ff64 <page_fault_handler+0x1b6>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f010ff3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff41:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010ff48:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010ff4b:	eb 17                	jmp    f010ff64 <page_fault_handler+0x1b6>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010ff4d:	83 ec 04             	sub    $0x4,%esp
f010ff50:	68 f8 80 12 f0       	push   $0xf01280f8
f010ff55:	68 15 01 00 00       	push   $0x115
f010ff5a:	68 33 7f 12 f0       	push   $0xf0127f33
f010ff5f:	e8 d5 03 ff ff       	call   f0100339 <_panic>
	}
}
f010ff64:	c9                   	leave  
f010ff65:	c3                   	ret    

f010ff66 <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010ff66:	55                   	push   %ebp
f010ff67:	89 e5                	mov    %esp,%ebp
f010ff69:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010ff6c:	83 ec 04             	sub    $0x4,%esp
f010ff6f:	68 38 81 12 f0       	push   $0xf0128138
f010ff74:	68 1d 01 00 00       	push   $0x11d
f010ff79:	68 33 7f 12 f0       	push   $0xf0127f33
f010ff7e:	e8 b6 03 ff ff       	call   f0100339 <_panic>

f010ff83 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010ff83:	55                   	push   %ebp
f010ff84:	89 e5                	mov    %esp,%ebp
f010ff86:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010ff89:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff8c:	83 c0 04             	add    $0x4,%eax
f010ff8f:	83 ec 08             	sub    $0x8,%esp
f010ff92:	ff 75 0c             	pushl  0xc(%ebp)
f010ff95:	50                   	push   %eax
f010ff96:	e8 16 00 01 00       	call   f011ffb1 <strcpy>
f010ff9b:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010ff9e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffa1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010ffa7:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffaa:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010ffb1:	90                   	nop
f010ffb2:	c9                   	leave  
f010ffb3:	c3                   	ret    

f010ffb4 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010ffb4:	55                   	push   %ebp
f010ffb5:	89 e5                	mov    %esp,%ebp
f010ffb7:	53                   	push   %ebx
f010ffb8:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010ffbb:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffbe:	83 ec 0c             	sub    $0xc,%esp
f010ffc1:	50                   	push   %eax
f010ffc2:	e8 06 02 00 00       	call   f01101cd <holding_spinlock>
f010ffc7:	83 c4 10             	add    $0x10,%esp
f010ffca:	85 c0                	test   %eax,%eax
f010ffcc:	74 18                	je     f010ffe6 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010ffce:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffd1:	83 c0 04             	add    $0x4,%eax
f010ffd4:	50                   	push   %eax
f010ffd5:	68 7c 81 12 f0       	push   $0xf012817c
f010ffda:	6a 1f                	push   $0x1f
f010ffdc:	68 b9 81 12 f0       	push   $0xf01281b9
f010ffe1:	e8 53 03 ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010ffe6:	e8 0f 75 ff ff       	call   f01074fa <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010ffeb:	90                   	nop
f010ffec:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffef:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010fff2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010fff9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010fffc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ffff:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0110002:	f0 87 02             	lock xchg %eax,(%edx)
f0110005:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f0110008:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011000b:	85 c0                	test   %eax,%eax
f011000d:	75 dd                	jne    f010ffec <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f011000f:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f0110014:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0110017:	e8 1b 74 ff ff       	call   f0107437 <mycpu>
f011001c:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f011001f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110022:	83 c0 48             	add    $0x48,%eax
f0110025:	83 ec 08             	sub    $0x8,%esp
f0110028:	50                   	push   %eax
f0110029:	8d 45 08             	lea    0x8(%ebp),%eax
f011002c:	50                   	push   %eax
f011002d:	e8 74 00 00 00       	call   f01100a6 <getcallerpcs>
f0110032:	83 c4 10             	add    $0x10,%esp

}
f0110035:	90                   	nop
f0110036:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0110039:	c9                   	leave  
f011003a:	c3                   	ret    

f011003b <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f011003b:	55                   	push   %ebp
f011003c:	89 e5                	mov    %esp,%ebp
f011003e:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f0110041:	83 ec 0c             	sub    $0xc,%esp
f0110044:	ff 75 08             	pushl  0x8(%ebp)
f0110047:	e8 81 01 00 00       	call   f01101cd <holding_spinlock>
f011004c:	83 c4 10             	add    $0x10,%esp
f011004f:	85 c0                	test   %eax,%eax
f0110051:	75 26                	jne    f0110079 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f0110053:	83 ec 0c             	sub    $0xc,%esp
f0110056:	ff 75 08             	pushl  0x8(%ebp)
f0110059:	e8 08 01 00 00       	call   f0110166 <printcallstack>
f011005e:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f0110061:	8b 45 08             	mov    0x8(%ebp),%eax
f0110064:	83 c0 04             	add    $0x4,%eax
f0110067:	50                   	push   %eax
f0110068:	68 d0 81 12 f0       	push   $0xf01281d0
f011006d:	6a 3c                	push   $0x3c
f011006f:	68 b9 81 12 f0       	push   $0xf01281b9
f0110074:	e8 c0 02 ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f0110079:	8b 45 08             	mov    0x8(%ebp),%eax
f011007c:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f0110083:	8b 45 08             	mov    0x8(%ebp),%eax
f0110086:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f011008d:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f0110092:	8b 45 08             	mov    0x8(%ebp),%eax
f0110095:	8b 55 08             	mov    0x8(%ebp),%edx
f0110098:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f011009e:	e8 a9 74 ff ff       	call   f010754c <popcli>
}
f01100a3:	90                   	nop
f01100a4:	c9                   	leave  
f01100a5:	c3                   	ret    

f01100a6 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f01100a6:	55                   	push   %ebp
f01100a7:	89 e5                	mov    %esp,%ebp
f01100a9:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f01100ac:	e8 74 bc ff ff       	call   f010bd25 <get_cpu_proc>
f01100b1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f01100b4:	e8 7e 73 ff ff       	call   f0107437 <mycpu>
f01100b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f01100bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01100bf:	83 e8 08             	sub    $0x8,%eax
f01100c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f01100c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01100cc:	eb 67                	jmp    f0110135 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f01100ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01100d2:	74 67                	je     f011013b <getcallerpcs+0x95>
f01100d4:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f01100db:	76 5e                	jbe    f011013b <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f01100dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01100e0:	8b 40 08             	mov    0x8(%eax),%eax
f01100e3:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f01100e8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01100eb:	77 10                	ja     f01100fd <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f01100ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01100f0:	8b 40 08             	mov    0x8(%eax),%eax
f01100f3:	05 00 90 00 00       	add    $0x9000,%eax
f01100f8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01100fb:	77 3e                	ja     f011013b <getcallerpcs+0x95>
f01100fd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110101:	74 10                	je     f0110113 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f0110103:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110106:	8b 40 70             	mov    0x70(%eax),%eax
f0110109:	05 00 80 00 00       	add    $0x8000,%eax
f011010e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110111:	76 28                	jbe    f011013b <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f0110113:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110116:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011011d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110120:	01 c2                	add    %eax,%edx
f0110122:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110125:	8b 40 04             	mov    0x4(%eax),%eax
f0110128:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f011012a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011012d:	8b 00                	mov    (%eax),%eax
f011012f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f0110132:	ff 45 f0             	incl   -0x10(%ebp)
f0110135:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0110139:	7e 93                	jle    f01100ce <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f011013b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011013e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f0110141:	eb 18                	jmp    f011015b <getcallerpcs+0xb5>
		pcs[i] = 0;
f0110143:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110146:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011014d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110150:	01 d0                	add    %edx,%eax
f0110152:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f0110158:	ff 45 f0             	incl   -0x10(%ebp)
f011015b:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011015f:	7e e2                	jle    f0110143 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f0110161:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0110164:	c9                   	leave  
f0110165:	c3                   	ret    

f0110166 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f0110166:	55                   	push   %ebp
f0110167:	89 e5                	mov    %esp,%ebp
f0110169:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f011016c:	83 ec 0c             	sub    $0xc,%esp
f011016f:	68 0e 82 12 f0       	push   $0xf012820e
f0110174:	e8 12 0e ff ff       	call   f0100f8b <cprintf>
f0110179:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f011017c:	8b 45 08             	mov    0x8(%ebp),%eax
f011017f:	83 c0 48             	add    $0x48,%eax
f0110182:	83 ec 08             	sub    $0x8,%esp
f0110185:	50                   	push   %eax
f0110186:	8d 45 08             	lea    0x8(%ebp),%eax
f0110189:	50                   	push   %eax
f011018a:	e8 17 ff ff ff       	call   f01100a6 <getcallerpcs>
f011018f:	83 c4 10             	add    $0x10,%esp
f0110192:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f0110195:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011019c:	eb 24                	jmp    f01101c2 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f011019e:	8b 45 08             	mov    0x8(%ebp),%eax
f01101a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01101a4:	83 c2 10             	add    $0x10,%edx
f01101a7:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f01101ab:	83 ec 04             	sub    $0x4,%esp
f01101ae:	50                   	push   %eax
f01101af:	ff 75 f4             	pushl  -0xc(%ebp)
f01101b2:	68 1e 82 12 f0       	push   $0xf012821e
f01101b7:	e8 cf 0d ff ff       	call   f0100f8b <cprintf>
f01101bc:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f01101bf:	ff 45 f4             	incl   -0xc(%ebp)
f01101c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01101c5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01101c8:	7c d4                	jl     f011019e <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f01101ca:	90                   	nop
f01101cb:	c9                   	leave  
f01101cc:	c3                   	ret    

f01101cd <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f01101cd:	55                   	push   %ebp
f01101ce:	89 e5                	mov    %esp,%ebp
f01101d0:	53                   	push   %ebx
f01101d1:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f01101d4:	e8 21 73 ff ff       	call   f01074fa <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f01101d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01101dc:	8b 00                	mov    (%eax),%eax
f01101de:	85 c0                	test   %eax,%eax
f01101e0:	74 16                	je     f01101f8 <holding_spinlock+0x2b>
f01101e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01101e5:	8b 58 44             	mov    0x44(%eax),%ebx
f01101e8:	e8 4a 72 ff ff       	call   f0107437 <mycpu>
f01101ed:	39 c3                	cmp    %eax,%ebx
f01101ef:	75 07                	jne    f01101f8 <holding_spinlock+0x2b>
f01101f1:	b8 01 00 00 00       	mov    $0x1,%eax
f01101f6:	eb 05                	jmp    f01101fd <holding_spinlock+0x30>
f01101f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01101fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f0110200:	e8 47 73 ff ff       	call   f010754c <popcli>
	return r;
f0110205:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110208:	83 c4 14             	add    $0x14,%esp
f011020b:	5b                   	pop    %ebx
f011020c:	5d                   	pop    %ebp
f011020d:	c3                   	ret    

f011020e <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f011020e:	55                   	push   %ebp
f011020f:	89 e5                	mov    %esp,%ebp
f0110211:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f0110214:	8b 45 08             	mov    0x8(%ebp),%eax
f0110217:	83 c0 74             	add    $0x74,%eax
f011021a:	83 ec 08             	sub    $0x8,%esp
f011021d:	68 2d 82 12 f0       	push   $0xf012822d
f0110222:	50                   	push   %eax
f0110223:	e8 4c 01 00 00       	call   f0110374 <init_channel>
f0110228:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f011022b:	8b 45 08             	mov    0x8(%ebp),%eax
f011022e:	83 c0 04             	add    $0x4,%eax
f0110231:	83 ec 08             	sub    $0x8,%esp
f0110234:	68 40 82 12 f0       	push   $0xf0128240
f0110239:	50                   	push   %eax
f011023a:	e8 44 fd ff ff       	call   f010ff83 <init_spinlock>
f011023f:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f0110242:	8b 45 08             	mov    0x8(%ebp),%eax
f0110245:	05 c4 00 00 00       	add    $0xc4,%eax
f011024a:	83 ec 08             	sub    $0x8,%esp
f011024d:	ff 75 0c             	pushl  0xc(%ebp)
f0110250:	50                   	push   %eax
f0110251:	e8 5b fd 00 00       	call   f011ffb1 <strcpy>
f0110256:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f0110259:	8b 45 08             	mov    0x8(%ebp),%eax
f011025c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f0110262:	8b 45 08             	mov    0x8(%ebp),%eax
f0110265:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f011026c:	00 00 00 
}
f011026f:	90                   	nop
f0110270:	c9                   	leave  
f0110271:	c3                   	ret    

f0110272 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f0110272:	55                   	push   %ebp
f0110273:	89 e5                	mov    %esp,%ebp
f0110275:	53                   	push   %ebx
f0110276:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f0110279:	8b 45 08             	mov    0x8(%ebp),%eax
f011027c:	83 c0 04             	add    $0x4,%eax
f011027f:	83 ec 0c             	sub    $0xc,%esp
f0110282:	50                   	push   %eax
f0110283:	e8 2c fd ff ff       	call   f010ffb4 <acquire_spinlock>
f0110288:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f011028b:	8b 45 08             	mov    0x8(%ebp),%eax
f011028e:	8b 00                	mov    (%eax),%eax
f0110290:	85 c0                	test   %eax,%eax
f0110292:	74 1c                	je     f01102b0 <holding_sleeplock+0x3e>
f0110294:	8b 45 08             	mov    0x8(%ebp),%eax
f0110297:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f011029d:	e8 83 ba ff ff       	call   f010bd25 <get_cpu_proc>
f01102a2:	8b 40 10             	mov    0x10(%eax),%eax
f01102a5:	39 c3                	cmp    %eax,%ebx
f01102a7:	75 07                	jne    f01102b0 <holding_sleeplock+0x3e>
f01102a9:	b8 01 00 00 00       	mov    $0x1,%eax
f01102ae:	eb 05                	jmp    f01102b5 <holding_sleeplock+0x43>
f01102b0:	b8 00 00 00 00       	mov    $0x0,%eax
f01102b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f01102b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01102bb:	83 c0 04             	add    $0x4,%eax
f01102be:	83 ec 0c             	sub    $0xc,%esp
f01102c1:	50                   	push   %eax
f01102c2:	e8 74 fd ff ff       	call   f011003b <release_spinlock>
f01102c7:	83 c4 10             	add    $0x10,%esp
	return r;
f01102ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01102cd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01102d0:	c9                   	leave  
f01102d1:	c3                   	ret    

f01102d2 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f01102d2:	55                   	push   %ebp
f01102d3:	89 e5                	mov    %esp,%ebp
f01102d5:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f01102d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01102db:	83 c0 04             	add    $0x4,%eax
f01102de:	83 ec 0c             	sub    $0xc,%esp
f01102e1:	50                   	push   %eax
f01102e2:	e8 cd fc ff ff       	call   f010ffb4 <acquire_spinlock>
f01102e7:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f01102ea:	eb 19                	jmp    f0110305 <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f01102ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01102ef:	8d 50 04             	lea    0x4(%eax),%edx
f01102f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01102f5:	83 c0 74             	add    $0x74,%eax
f01102f8:	83 ec 08             	sub    $0x8,%esp
f01102fb:	52                   	push   %edx
f01102fc:	50                   	push   %eax
f01102fd:	e8 9f 00 00 00       	call   f01103a1 <sleep>
f0110302:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f0110305:	8b 45 08             	mov    0x8(%ebp),%eax
f0110308:	8b 00                	mov    (%eax),%eax
f011030a:	85 c0                	test   %eax,%eax
f011030c:	75 de                	jne    f01102ec <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f011030e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110311:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f0110317:	8b 45 08             	mov    0x8(%ebp),%eax
f011031a:	83 c0 04             	add    $0x4,%eax
f011031d:	83 ec 0c             	sub    $0xc,%esp
f0110320:	50                   	push   %eax
f0110321:	e8 15 fd ff ff       	call   f011003b <release_spinlock>
f0110326:	83 c4 10             	add    $0x10,%esp

}
f0110329:	90                   	nop
f011032a:	c9                   	leave  
f011032b:	c3                   	ret    

f011032c <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f011032c:	55                   	push   %ebp
f011032d:	89 e5                	mov    %esp,%ebp
f011032f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f0110332:	8b 45 08             	mov    0x8(%ebp),%eax
f0110335:	83 c0 04             	add    $0x4,%eax
f0110338:	83 ec 0c             	sub    $0xc,%esp
f011033b:	50                   	push   %eax
f011033c:	e8 73 fc ff ff       	call   f010ffb4 <acquire_spinlock>
f0110341:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f0110344:	8b 45 08             	mov    0x8(%ebp),%eax
f0110347:	83 c0 74             	add    $0x74,%eax
f011034a:	83 ec 0c             	sub    $0xc,%esp
f011034d:	50                   	push   %eax
f011034e:	e8 3f 01 00 00       	call   f0110492 <wakeup_all>
f0110353:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f0110356:	8b 45 08             	mov    0x8(%ebp),%eax
f0110359:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f011035f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110362:	83 c0 04             	add    $0x4,%eax
f0110365:	83 ec 0c             	sub    $0xc,%esp
f0110368:	50                   	push   %eax
f0110369:	e8 cd fc ff ff       	call   f011003b <release_spinlock>
f011036e:	83 c4 10             	add    $0x10,%esp
}
f0110371:	90                   	nop
f0110372:	c9                   	leave  
f0110373:	c3                   	ret    

f0110374 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f0110374:	55                   	push   %ebp
f0110375:	89 e5                	mov    %esp,%ebp
f0110377:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f011037a:	8b 45 08             	mov    0x8(%ebp),%eax
f011037d:	83 c0 10             	add    $0x10,%eax
f0110380:	83 ec 08             	sub    $0x8,%esp
f0110383:	ff 75 0c             	pushl  0xc(%ebp)
f0110386:	50                   	push   %eax
f0110387:	e8 25 fc 00 00       	call   f011ffb1 <strcpy>
f011038c:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f011038f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110392:	83 ec 0c             	sub    $0xc,%esp
f0110395:	50                   	push   %eax
f0110396:	e8 bc 4d ff ff       	call   f0105157 <init_queue>
f011039b:	83 c4 10             	add    $0x10,%esp
}
f011039e:	90                   	nop
f011039f:	c9                   	leave  
f01103a0:	c3                   	ret    

f01103a1 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f01103a1:	55                   	push   %ebp
f01103a2:	89 e5                	mov    %esp,%ebp
f01103a4:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f01103a7:	83 ec 0c             	sub    $0xc,%esp
f01103aa:	68 80 f0 71 f0       	push   $0xf071f080
f01103af:	e8 00 fc ff ff       	call   f010ffb4 <acquire_spinlock>
f01103b4:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f01103b7:	e8 69 b9 ff ff       	call   f010bd25 <get_cpu_proc>
f01103bc:	89 c2                	mov    %eax,%edx
f01103be:	8b 45 08             	mov    0x8(%ebp),%eax
f01103c1:	83 ec 08             	sub    $0x8,%esp
f01103c4:	52                   	push   %edx
f01103c5:	50                   	push   %eax
f01103c6:	e8 cd 4d ff ff       	call   f0105198 <enqueue>
f01103cb:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f01103ce:	e8 52 b9 ff ff       	call   f010bd25 <get_cpu_proc>
f01103d3:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f01103da:	83 ec 0c             	sub    $0xc,%esp
f01103dd:	ff 75 0c             	pushl  0xc(%ebp)
f01103e0:	e8 56 fc ff ff       	call   f011003b <release_spinlock>
f01103e5:	83 c4 10             	add    $0x10,%esp
	sched();
f01103e8:	e8 b9 ba ff ff       	call   f010bea6 <sched>
	release_spinlock(&(ProcessQueues.qlock));
f01103ed:	83 ec 0c             	sub    $0xc,%esp
f01103f0:	68 80 f0 71 f0       	push   $0xf071f080
f01103f5:	e8 41 fc ff ff       	call   f011003b <release_spinlock>
f01103fa:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f01103fd:	83 ec 0c             	sub    $0xc,%esp
f0110400:	ff 75 0c             	pushl  0xc(%ebp)
f0110403:	e8 ac fb ff ff       	call   f010ffb4 <acquire_spinlock>
f0110408:	83 c4 10             	add    $0x10,%esp
}
f011040b:	90                   	nop
f011040c:	c9                   	leave  
f011040d:	c3                   	ret    

f011040e <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f011040e:	55                   	push   %ebp
f011040f:	89 e5                	mov    %esp,%ebp
f0110411:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f0110414:	8b 45 08             	mov    0x8(%ebp),%eax
f0110417:	83 ec 0c             	sub    $0xc,%esp
f011041a:	50                   	push   %eax
f011041b:	e8 60 4d ff ff       	call   f0105180 <queue_size>
f0110420:	83 c4 10             	add    $0x10,%esp
f0110423:	85 c0                	test   %eax,%eax
f0110425:	74 68                	je     f011048f <wakeup_one+0x81>
		bool locked_by_me = 0;
f0110427:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f011042e:	83 ec 0c             	sub    $0xc,%esp
f0110431:	68 80 f0 71 f0       	push   $0xf071f080
f0110436:	e8 92 fd ff ff       	call   f01101cd <holding_spinlock>
f011043b:	83 c4 10             	add    $0x10,%esp
f011043e:	85 c0                	test   %eax,%eax
f0110440:	75 17                	jne    f0110459 <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f0110442:	83 ec 0c             	sub    $0xc,%esp
f0110445:	68 80 f0 71 f0       	push   $0xf071f080
f011044a:	e8 65 fb ff ff       	call   f010ffb4 <acquire_spinlock>
f011044f:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f0110452:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f0110459:	8b 45 08             	mov    0x8(%ebp),%eax
f011045c:	83 ec 0c             	sub    $0xc,%esp
f011045f:	50                   	push   %eax
f0110460:	e8 c4 4d ff ff       	call   f0105229 <dequeue>
f0110465:	83 c4 10             	add    $0x10,%esp
f0110468:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f011046b:	83 ec 0c             	sub    $0xc,%esp
f011046e:	ff 75 f0             	pushl  -0x10(%ebp)
f0110471:	e8 ee 4f ff ff       	call   f0105464 <sched_insert_ready0>
f0110476:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f0110479:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011047d:	74 10                	je     f011048f <wakeup_one+0x81>
f011047f:	83 ec 0c             	sub    $0xc,%esp
f0110482:	68 80 f0 71 f0       	push   $0xf071f080
f0110487:	e8 af fb ff ff       	call   f011003b <release_spinlock>
f011048c:	83 c4 10             	add    $0x10,%esp
	}
}
f011048f:	90                   	nop
f0110490:	c9                   	leave  
f0110491:	c3                   	ret    

f0110492 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f0110492:	55                   	push   %ebp
f0110493:	89 e5                	mov    %esp,%ebp
f0110495:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f0110498:	83 ec 0c             	sub    $0xc,%esp
f011049b:	68 80 f0 71 f0       	push   $0xf071f080
f01104a0:	e8 0f fb ff ff       	call   f010ffb4 <acquire_spinlock>
f01104a5:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f01104a8:	eb 0e                	jmp    f01104b8 <wakeup_all+0x26>
		wakeup_one(chan);
f01104aa:	83 ec 0c             	sub    $0xc,%esp
f01104ad:	ff 75 08             	pushl  0x8(%ebp)
f01104b0:	e8 59 ff ff ff       	call   f011040e <wakeup_one>
f01104b5:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f01104b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01104bb:	83 ec 0c             	sub    $0xc,%esp
f01104be:	50                   	push   %eax
f01104bf:	e8 bc 4c ff ff       	call   f0105180 <queue_size>
f01104c4:	83 c4 10             	add    $0x10,%esp
f01104c7:	85 c0                	test   %eax,%eax
f01104c9:	75 df                	jne    f01104aa <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f01104cb:	83 ec 0c             	sub    $0xc,%esp
f01104ce:	68 80 f0 71 f0       	push   $0xf071f080
f01104d3:	e8 63 fb ff ff       	call   f011003b <release_spinlock>
f01104d8:	83 c4 10             	add    $0x10,%esp
}
f01104db:	90                   	nop
f01104dc:	c9                   	leave  
f01104dd:	c3                   	ret    

f01104de <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f01104de:	55                   	push   %ebp
f01104df:	89 e5                	mov    %esp,%ebp
f01104e1:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f01104e4:	83 ec 04             	sub    $0x4,%esp
f01104e7:	68 54 82 12 f0       	push   $0xf0128254
f01104ec:	6a 13                	push   $0x13
f01104ee:	68 7b 82 12 f0       	push   $0xf012827b
f01104f3:	e8 41 fe fe ff       	call   f0100339 <_panic>

f01104f8 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f01104f8:	55                   	push   %ebp
f01104f9:	89 e5                	mov    %esp,%ebp
f01104fb:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f01104fe:	83 ec 04             	sub    $0x4,%esp
f0110501:	68 94 82 12 f0       	push   $0xf0128294
f0110506:	6a 1b                	push   $0x1b
f0110508:	68 7b 82 12 f0       	push   $0xf012827b
f011050d:	e8 27 fe fe ff       	call   f0100339 <_panic>

f0110512 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f0110512:	55                   	push   %ebp
f0110513:	89 e5                	mov    %esp,%ebp
f0110515:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f0110518:	83 ec 04             	sub    $0x4,%esp
f011051b:	68 bc 82 12 f0       	push   $0xf01282bc
f0110520:	6a 24                	push   $0x24
f0110522:	68 7b 82 12 f0       	push   $0xf012827b
f0110527:	e8 0d fe fe ff       	call   f0100339 <_panic>

f011052c <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f011052c:	55                   	push   %ebp
f011052d:	89 e5                	mov    %esp,%ebp
f011052f:	c7 05 18 f6 b1 f0 01 	movl   $0x1,0xf0b1f618
f0110536:	00 00 00 
f0110539:	90                   	nop
f011053a:	5d                   	pop    %ebp
f011053b:	c3                   	ret    

f011053c <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f011053c:	55                   	push   %ebp
f011053d:	89 e5                	mov    %esp,%ebp
f011053f:	c7 05 18 f6 b1 f0 02 	movl   $0x2,0xf0b1f618
f0110546:	00 00 00 
f0110549:	90                   	nop
f011054a:	5d                   	pop    %ebp
f011054b:	c3                   	ret    

f011054c <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f011054c:	55                   	push   %ebp
f011054d:	89 e5                	mov    %esp,%ebp
f011054f:	c7 05 18 f6 b1 f0 03 	movl   $0x3,0xf0b1f618
f0110556:	00 00 00 
f0110559:	90                   	nop
f011055a:	5d                   	pop    %ebp
f011055b:	c3                   	ret    

f011055c <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f011055c:	55                   	push   %ebp
f011055d:	89 e5                	mov    %esp,%ebp
f011055f:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0110564:	83 f8 01             	cmp    $0x1,%eax
f0110567:	75 04                	jne    f011056d <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0110569:	b0 01                	mov    $0x1,%al
f011056b:	eb 02                	jmp    f011056f <isKHeapPlacementStrategyFIRSTFIT+0x13>
f011056d:	b0 00                	mov    $0x0,%al
f011056f:	5d                   	pop    %ebp
f0110570:	c3                   	ret    

f0110571 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0110571:	55                   	push   %ebp
f0110572:	89 e5                	mov    %esp,%ebp
f0110574:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f0110579:	83 f8 02             	cmp    $0x2,%eax
f011057c:	75 04                	jne    f0110582 <isKHeapPlacementStrategyBESTFIT+0x11>
f011057e:	b0 01                	mov    $0x1,%al
f0110580:	eb 02                	jmp    f0110584 <isKHeapPlacementStrategyBESTFIT+0x13>
f0110582:	b0 00                	mov    $0x0,%al
f0110584:	5d                   	pop    %ebp
f0110585:	c3                   	ret    

f0110586 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0110586:	55                   	push   %ebp
f0110587:	89 e5                	mov    %esp,%ebp
f0110589:	a1 18 f6 b1 f0       	mov    0xf0b1f618,%eax
f011058e:	83 f8 03             	cmp    $0x3,%eax
f0110591:	75 04                	jne    f0110597 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0110593:	b0 01                	mov    $0x1,%al
f0110595:	eb 02                	jmp    f0110599 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0110597:	b0 00                	mov    $0x0,%al
f0110599:	5d                   	pop    %ebp
f011059a:	c3                   	ret    

f011059b <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f011059b:	55                   	push   %ebp
f011059c:	89 e5                	mov    %esp,%ebp
f011059e:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f01105a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01105a8:	eb 26                	jmp    f01105d0 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f01105aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01105ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01105b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105b7:	01 c2                	add    %eax,%edx
f01105b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01105bc:	40                   	inc    %eax
f01105bd:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01105c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105c7:	01 c8                	add    %ecx,%eax
f01105c9:	8b 00                	mov    (%eax),%eax
f01105cb:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f01105cd:	ff 45 f4             	incl   -0xc(%ebp)
f01105d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01105d3:	48                   	dec    %eax
f01105d4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01105d7:	7f d1                	jg     f01105aa <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f01105d9:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f01105dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f01105e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01105ea:	eb 35                	jmp    f0110621 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f01105ec:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01105ef:	89 d0                	mov    %edx,%eax
f01105f1:	01 c0                	add    %eax,%eax
f01105f3:	01 d0                	add    %edx,%eax
f01105f5:	c1 e0 02             	shl    $0x2,%eax
f01105f8:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f01105fd:	8b 10                	mov    (%eax),%edx
f01105ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110602:	8b 00                	mov    (%eax),%eax
f0110604:	83 ec 08             	sub    $0x8,%esp
f0110607:	52                   	push   %edx
f0110608:	50                   	push   %eax
f0110609:	e8 60 fa 00 00       	call   f012006e <strcmp>
f011060e:	83 c4 10             	add    $0x10,%esp
f0110611:	85 c0                	test   %eax,%eax
f0110613:	75 09                	jne    f011061e <tst_handler+0x83>
		{
			test_found = 1;
f0110615:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f011061c:	eb 0f                	jmp    f011062d <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f011061e:	ff 45 ec             	incl   -0x14(%ebp)
f0110621:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110624:	a1 14 0e 18 f0       	mov    0xf0180e14,%eax
f0110629:	39 c2                	cmp    %eax,%edx
f011062b:	72 bf                	jb     f01105ec <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f011062d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110631:	74 29                	je     f011065c <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f0110633:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110636:	89 d0                	mov    %edx,%eax
f0110638:	01 c0                	add    %eax,%eax
f011063a:	01 d0                	add    %edx,%eax
f011063c:	c1 e0 02             	shl    $0x2,%eax
f011063f:	05 68 0d 18 f0       	add    $0xf0180d68,%eax
f0110644:	8b 00                	mov    (%eax),%eax
f0110646:	83 ec 08             	sub    $0x8,%esp
f0110649:	ff 75 0c             	pushl  0xc(%ebp)
f011064c:	ff 75 08             	pushl  0x8(%ebp)
f011064f:	ff d0                	call   *%eax
f0110651:	83 c4 10             	add    $0x10,%esp
f0110654:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f0110657:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011065a:	eb 1b                	jmp    f0110677 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f011065c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011065f:	8b 00                	mov    (%eax),%eax
f0110661:	83 ec 08             	sub    $0x8,%esp
f0110664:	50                   	push   %eax
f0110665:	68 fc 85 12 f0       	push   $0xf01285fc
f011066a:	e8 1c 09 ff ff       	call   f0100f8b <cprintf>
f011066f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110672:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0110677:	c9                   	leave  
f0110678:	c3                   	ret    

f0110679 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f0110679:	55                   	push   %ebp
f011067a:	89 e5                	mov    %esp,%ebp
f011067c:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f011067f:	e8 69 d0 00 00       	call   f011d6ed <test_three_creation_functions>
	return 0;
f0110684:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110689:	c9                   	leave  
f011068a:	c3                   	ret    

f011068b <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f011068b:	55                   	push   %ebp
f011068c:	89 e5                	mov    %esp,%ebp
f011068e:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f0110691:	e8 03 69 00 00       	call   f0116f99 <test_priority_normal_and_higher>
	return 0;
f0110696:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011069b:	c9                   	leave  
f011069c:	c3                   	ret    

f011069d <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f011069d:	55                   	push   %ebp
f011069e:	89 e5                	mov    %esp,%ebp
f01106a0:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f01106a3:	e8 0b 69 00 00       	call   f0116fb3 <test_priority_normal_and_lower>
	return 0;
f01106a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106ad:	c9                   	leave  
f01106ae:	c3                   	ret    

f01106af <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f01106af:	55                   	push   %ebp
f01106b0:	89 e5                	mov    %esp,%ebp
f01106b2:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f01106b5:	e8 e6 d1 00 00       	call   f011d8a0 <test_kfreeall>
	return 0;
f01106ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106bf:	c9                   	leave  
f01106c0:	c3                   	ret    

f01106c1 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f01106c1:	55                   	push   %ebp
f01106c2:	89 e5                	mov    %esp,%ebp
f01106c4:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f01106c7:	e8 f1 d1 00 00       	call   f011d8bd <test_kexpand>
	return 0;
f01106cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106d1:	c9                   	leave  
f01106d2:	c3                   	ret    

f01106d3 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f01106d3:	55                   	push   %ebp
f01106d4:	89 e5                	mov    %esp,%ebp
f01106d6:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f01106d9:	e8 fc d1 00 00       	call   f011d8da <test_kshrink>
	return 0;
f01106de:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106e3:	c9                   	leave  
f01106e4:	c3                   	ret    

f01106e5 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f01106e5:	55                   	push   %ebp
f01106e6:	89 e5                	mov    %esp,%ebp
f01106e8:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f01106eb:	e8 07 d2 00 00       	call   f011d8f7 <test_kfreelast>
	return 0;
f01106f0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106f5:	c9                   	leave  
f01106f6:	c3                   	ret    

f01106f7 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f01106f7:	55                   	push   %ebp
f01106f8:	89 e5                	mov    %esp,%ebp
f01106fa:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f01106fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110700:	83 c0 04             	add    $0x4,%eax
f0110703:	8b 00                	mov    (%eax),%eax
f0110705:	83 ec 04             	sub    $0x4,%esp
f0110708:	6a 0a                	push   $0xa
f011070a:	6a 00                	push   $0x0
f011070c:	50                   	push   %eax
f011070d:	e8 b0 fb 00 00       	call   f01202c2 <strtol>
f0110712:	83 c4 10             	add    $0x10,%esp
f0110715:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f0110718:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f011071f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f0110726:	83 ec 0c             	sub    $0xc,%esp
f0110729:	68 80 f0 71 f0       	push   $0xf071f080
f011072e:	e8 81 f8 ff ff       	call   f010ffb4 <acquire_spinlock>
f0110733:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110736:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f011073b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011073e:	eb 3b                	jmp    f011077b <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f0110740:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110743:	83 c0 20             	add    $0x20,%eax
f0110746:	83 ec 08             	sub    $0x8,%esp
f0110749:	68 0f 86 12 f0       	push   $0xf012860f
f011074e:	50                   	push   %eax
f011074f:	e8 1a f9 00 00       	call   f012006e <strcmp>
f0110754:	83 c4 10             	add    $0x10,%esp
f0110757:	85 c0                	test   %eax,%eax
f0110759:	75 12                	jne    f011076d <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f011075b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011075f:	74 07                	je     f0110768 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f0110761:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f0110768:	ff 45 f4             	incl   -0xc(%ebp)
f011076b:	eb 06                	jmp    f0110773 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f011076d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110771:	74 31                	je     f01107a4 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110773:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0110778:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011077b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011077f:	74 08                	je     f0110789 <tst_sc_MLFQ+0x92>
f0110781:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110784:	8b 40 08             	mov    0x8(%eax),%eax
f0110787:	eb 05                	jmp    f011078e <tst_sc_MLFQ+0x97>
f0110789:	b8 00 00 00 00       	mov    $0x0,%eax
f011078e:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f0110793:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f0110798:	85 c0                	test   %eax,%eax
f011079a:	75 a4                	jne    f0110740 <tst_sc_MLFQ+0x49>
f011079c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01107a0:	75 9e                	jne    f0110740 <tst_sc_MLFQ+0x49>
f01107a2:	eb 01                	jmp    f01107a5 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f01107a4:	90                   	nop
			}
		if(cnt == numOfSlave2)
f01107a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01107a8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01107ab:	75 12                	jne    f01107bf <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f01107ad:	83 ec 0c             	sub    $0xc,%esp
f01107b0:	68 18 86 12 f0       	push   $0xf0128618
f01107b5:	e8 d1 07 ff ff       	call   f0100f8b <cprintf>
f01107ba:	83 c4 10             	add    $0x10,%esp
f01107bd:	eb 17                	jmp    f01107d6 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f01107bf:	83 ec 04             	sub    $0x4,%esp
f01107c2:	68 51 86 12 f0       	push   $0xf0128651
f01107c7:	68 9b 00 00 00       	push   $0x9b
f01107cc:	68 67 86 12 f0       	push   $0xf0128667
f01107d1:	e8 63 fb fe ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f01107d6:	83 ec 0c             	sub    $0xc,%esp
f01107d9:	68 80 f0 71 f0       	push   $0xf071f080
f01107de:	e8 58 f8 ff ff       	call   f011003b <release_spinlock>
f01107e3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01107e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01107eb:	c9                   	leave  
f01107ec:	c3                   	ret    

f01107ed <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f01107ed:	55                   	push   %ebp
f01107ee:	89 e5                	mov    %esp,%ebp
f01107f0:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f01107f3:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01107f7:	74 17                	je     f0110810 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f01107f9:	83 ec 0c             	sub    $0xc,%esp
f01107fc:	68 80 86 12 f0       	push   $0xf0128680
f0110801:	e8 85 07 ff ff       	call   f0100f8b <cprintf>
f0110806:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110809:	b8 00 00 00 00       	mov    $0x0,%eax
f011080e:	eb 45                	jmp    f0110855 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0110810:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110813:	83 c0 04             	add    $0x4,%eax
f0110816:	8b 00                	mov    (%eax),%eax
f0110818:	83 ec 04             	sub    $0x4,%esp
f011081b:	6a 0a                	push   $0xa
f011081d:	6a 00                	push   $0x0
f011081f:	50                   	push   %eax
f0110820:	e8 9d fa 00 00       	call   f01202c2 <strtol>
f0110825:	83 c4 10             	add    $0x10,%esp
f0110828:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f011082b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011082e:	83 f8 01             	cmp    $0x1,%eax
f0110831:	74 10                	je     f0110843 <tst_bsd_nice+0x56>
f0110833:	83 f8 02             	cmp    $0x2,%eax
f0110836:	74 12                	je     f011084a <tst_bsd_nice+0x5d>
f0110838:	85 c0                	test   %eax,%eax
f011083a:	75 14                	jne    f0110850 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f011083c:	e8 b9 d2 00 00       	call   f011dafa <test_bsd_nice_0>
		break;
f0110841:	eb 0d                	jmp    f0110850 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f0110843:	e8 3c d5 00 00       	call   f011dd84 <test_bsd_nice_1>
		break;
f0110848:	eb 06                	jmp    f0110850 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f011084a:	e8 49 d7 00 00       	call   f011df98 <test_bsd_nice_2>
		break;
f011084f:	90                   	nop
	}
	return 0;
f0110850:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110855:	c9                   	leave  
f0110856:	c3                   	ret    

f0110857 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f0110857:	55                   	push   %ebp
f0110858:	89 e5                	mov    %esp,%ebp
f011085a:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f011085d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0110861:	74 17                	je     f011087a <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f0110863:	83 ec 0c             	sub    $0xc,%esp
f0110866:	68 c0 86 12 f0       	push   $0xf01286c0
f011086b:	e8 1b 07 ff ff       	call   f0100f8b <cprintf>
f0110870:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110873:	b8 00 00 00 00       	mov    $0x0,%eax
f0110878:	eb 0a                	jmp    f0110884 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f011087a:	e8 3f 15 00 00       	call   f0111dbe <test_str2lower_function>
	return 0;
f011087f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110884:	c9                   	leave  
f0110885:	c3                   	ret    

f0110886 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f0110886:	55                   	push   %ebp
f0110887:	89 e5                	mov    %esp,%ebp
f0110889:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f011088c:	e8 63 11 00 00       	call   f01119f4 <TestAutoCompleteCommand>
f0110891:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f0110894:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110899:	c9                   	leave  
f011089a:	c3                   	ret    

f011089b <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f011089b:	55                   	push   %ebp
f011089c:	89 e5                	mov    %esp,%ebp
f011089e:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01108a1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01108a5:	74 1a                	je     f01108c1 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f01108a7:	83 ec 0c             	sub    $0xc,%esp
f01108aa:	68 f4 86 12 f0       	push   $0xf01286f4
f01108af:	e8 d7 06 ff ff       	call   f0100f8b <cprintf>
f01108b4:	83 c4 10             	add    $0x10,%esp
		return 0;
f01108b7:	b8 00 00 00 00       	mov    $0x0,%eax
f01108bc:	e9 2f 01 00 00       	jmp    f01109f0 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f01108c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108c4:	83 c0 04             	add    $0x4,%eax
f01108c7:	8b 00                	mov    (%eax),%eax
f01108c9:	83 ec 08             	sub    $0x8,%esp
f01108cc:	68 31 87 12 f0       	push   $0xf0128731
f01108d1:	50                   	push   %eax
f01108d2:	e8 97 f7 00 00       	call   f012006e <strcmp>
f01108d7:	83 c4 10             	add    $0x10,%esp
f01108da:	85 c0                	test   %eax,%eax
f01108dc:	75 0a                	jne    f01108e8 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f01108de:	e8 40 08 00 00       	call   f0111123 <test_initialize_dynamic_allocator>
f01108e3:	e9 03 01 00 00       	jmp    f01109eb <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f01108e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108eb:	83 c0 04             	add    $0x4,%eax
f01108ee:	8b 00                	mov    (%eax),%eax
f01108f0:	83 ec 08             	sub    $0x8,%esp
f01108f3:	68 36 87 12 f0       	push   $0xf0128736
f01108f8:	50                   	push   %eax
f01108f9:	e8 70 f7 00 00       	call   f012006e <strcmp>
f01108fe:	83 c4 10             	add    $0x10,%esp
f0110901:	85 c0                	test   %eax,%eax
f0110903:	75 0a                	jne    f011090f <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f0110905:	e8 4d 08 00 00       	call   f0111157 <test_alloc_block_FF>
f011090a:	e9 dc 00 00 00       	jmp    f01109eb <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f011090f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110912:	83 c0 04             	add    $0x4,%eax
f0110915:	8b 00                	mov    (%eax),%eax
f0110917:	83 ec 08             	sub    $0x8,%esp
f011091a:	68 3e 87 12 f0       	push   $0xf012873e
f011091f:	50                   	push   %eax
f0110920:	e8 49 f7 00 00       	call   f012006e <strcmp>
f0110925:	83 c4 10             	add    $0x10,%esp
f0110928:	85 c0                	test   %eax,%eax
f011092a:	75 0a                	jne    f0110936 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f011092c:	e8 43 08 00 00       	call   f0111174 <test_alloc_block_BF>
f0110931:	e9 b5 00 00 00       	jmp    f01109eb <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f0110936:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110939:	83 c0 04             	add    $0x4,%eax
f011093c:	8b 00                	mov    (%eax),%eax
f011093e:	83 ec 08             	sub    $0x8,%esp
f0110941:	68 46 87 12 f0       	push   $0xf0128746
f0110946:	50                   	push   %eax
f0110947:	e8 22 f7 00 00       	call   f012006e <strcmp>
f011094c:	83 c4 10             	add    $0x10,%esp
f011094f:	85 c0                	test   %eax,%eax
f0110951:	75 0a                	jne    f011095d <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f0110953:	e8 3c 08 00 00       	call   f0111194 <test_alloc_block_NF>
f0110958:	e9 8e 00 00 00       	jmp    f01109eb <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f011095d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110960:	83 c0 04             	add    $0x4,%eax
f0110963:	8b 00                	mov    (%eax),%eax
f0110965:	83 ec 08             	sub    $0x8,%esp
f0110968:	68 4e 87 12 f0       	push   $0xf012874e
f011096d:	50                   	push   %eax
f011096e:	e8 fb f6 00 00       	call   f012006e <strcmp>
f0110973:	83 c4 10             	add    $0x10,%esp
f0110976:	85 c0                	test   %eax,%eax
f0110978:	75 07                	jne    f0110981 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f011097a:	e8 1b 08 00 00       	call   f011119a <test_free_block_FF>
f011097f:	eb 6a                	jmp    f01109eb <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f0110981:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110984:	83 c0 04             	add    $0x4,%eax
f0110987:	8b 00                	mov    (%eax),%eax
f0110989:	83 ec 08             	sub    $0x8,%esp
f011098c:	68 55 87 12 f0       	push   $0xf0128755
f0110991:	50                   	push   %eax
f0110992:	e8 d7 f6 00 00       	call   f012006e <strcmp>
f0110997:	83 c4 10             	add    $0x10,%esp
f011099a:	85 c0                	test   %eax,%eax
f011099c:	75 07                	jne    f01109a5 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f011099e:	e8 14 08 00 00       	call   f01111b7 <test_free_block_BF>
f01109a3:	eb 46                	jmp    f01109eb <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f01109a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109a8:	83 c0 04             	add    $0x4,%eax
f01109ab:	8b 00                	mov    (%eax),%eax
f01109ad:	83 ec 08             	sub    $0x8,%esp
f01109b0:	68 5c 87 12 f0       	push   $0xf012875c
f01109b5:	50                   	push   %eax
f01109b6:	e8 b3 f6 00 00       	call   f012006e <strcmp>
f01109bb:	83 c4 10             	add    $0x10,%esp
f01109be:	85 c0                	test   %eax,%eax
f01109c0:	75 07                	jne    f01109c9 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f01109c2:	e8 0d 08 00 00       	call   f01111d4 <test_free_block_NF>
f01109c7:	eb 22                	jmp    f01109eb <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f01109c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109cc:	83 c0 04             	add    $0x4,%eax
f01109cf:	8b 00                	mov    (%eax),%eax
f01109d1:	83 ec 08             	sub    $0x8,%esp
f01109d4:	68 63 87 12 f0       	push   $0xf0128763
f01109d9:	50                   	push   %eax
f01109da:	e8 8f f6 00 00       	call   f012006e <strcmp>
f01109df:	83 c4 10             	add    $0x10,%esp
f01109e2:	85 c0                	test   %eax,%eax
f01109e4:	75 05                	jne    f01109eb <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f01109e6:	e8 06 08 00 00       	call   f01111f1 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f01109eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01109f0:	c9                   	leave  
f01109f1:	c3                   	ret    

f01109f2 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f01109f2:	55                   	push   %ebp
f01109f3:	89 e5                	mov    %esp,%ebp
f01109f5:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01109f8:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01109fc:	74 1a                	je     f0110a18 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f01109fe:	83 ec 0c             	sub    $0xc,%esp
f0110a01:	68 70 87 12 f0       	push   $0xf0128770
f0110a06:	e8 80 05 ff ff       	call   f0100f8b <cprintf>
f0110a0b:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110a0e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a13:	e9 e1 00 00 00       	jmp    f0110af9 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f0110a18:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a1b:	83 c0 04             	add    $0x4,%eax
f0110a1e:	8b 00                	mov    (%eax),%eax
f0110a20:	83 ec 08             	sub    $0x8,%esp
f0110a23:	68 a9 87 12 f0       	push   $0xf01287a9
f0110a28:	50                   	push   %eax
f0110a29:	e8 40 f6 00 00       	call   f012006e <strcmp>
f0110a2e:	83 c4 10             	add    $0x10,%esp
f0110a31:	85 c0                	test   %eax,%eax
f0110a33:	75 0a                	jne    f0110a3f <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f0110a35:	e8 97 1c 00 00       	call   f01126d1 <test_cut_paste_pages>
f0110a3a:	e9 b5 00 00 00       	jmp    f0110af4 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f0110a3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a42:	83 c0 04             	add    $0x4,%eax
f0110a45:	8b 00                	mov    (%eax),%eax
f0110a47:	83 ec 08             	sub    $0x8,%esp
f0110a4a:	68 b2 87 12 f0       	push   $0xf01287b2
f0110a4f:	50                   	push   %eax
f0110a50:	e8 19 f6 00 00       	call   f012006e <strcmp>
f0110a55:	83 c4 10             	add    $0x10,%esp
f0110a58:	85 c0                	test   %eax,%eax
f0110a5a:	75 0a                	jne    f0110a66 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f0110a5c:	e8 bb 26 00 00       	call   f011311c <test_copy_paste_chunk>
f0110a61:	e9 8e 00 00 00       	jmp    f0110af4 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f0110a66:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a69:	83 c0 04             	add    $0x4,%eax
f0110a6c:	8b 00                	mov    (%eax),%eax
f0110a6e:	83 ec 08             	sub    $0x8,%esp
f0110a71:	68 bc 87 12 f0       	push   $0xf01287bc
f0110a76:	50                   	push   %eax
f0110a77:	e8 f2 f5 00 00       	call   f012006e <strcmp>
f0110a7c:	83 c4 10             	add    $0x10,%esp
f0110a7f:	85 c0                	test   %eax,%eax
f0110a81:	75 07                	jne    f0110a8a <tst_chunks+0x98>
	{
		test_share_chunk();
f0110a83:	e8 92 37 00 00       	call   f011421a <test_share_chunk>
f0110a88:	eb 6a                	jmp    f0110af4 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f0110a8a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a8d:	83 c0 04             	add    $0x4,%eax
f0110a90:	8b 00                	mov    (%eax),%eax
f0110a92:	83 ec 08             	sub    $0x8,%esp
f0110a95:	68 c2 87 12 f0       	push   $0xf01287c2
f0110a9a:	50                   	push   %eax
f0110a9b:	e8 ce f5 00 00       	call   f012006e <strcmp>
f0110aa0:	83 c4 10             	add    $0x10,%esp
f0110aa3:	85 c0                	test   %eax,%eax
f0110aa5:	75 07                	jne    f0110aae <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f0110aa7:	e8 96 41 00 00       	call   f0114c42 <test_allocate_chunk>
f0110aac:	eb 46                	jmp    f0110af4 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110aae:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ab1:	83 c0 04             	add    $0x4,%eax
f0110ab4:	8b 00                	mov    (%eax),%eax
f0110ab6:	83 ec 08             	sub    $0x8,%esp
f0110ab9:	68 cb 87 12 f0       	push   $0xf01287cb
f0110abe:	50                   	push   %eax
f0110abf:	e8 aa f5 00 00       	call   f012006e <strcmp>
f0110ac4:	83 c4 10             	add    $0x10,%esp
f0110ac7:	85 c0                	test   %eax,%eax
f0110ac9:	75 07                	jne    f0110ad2 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f0110acb:	e8 79 4a 00 00       	call   f0115549 <test_calculate_required_frames>
f0110ad0:	eb 22                	jmp    f0110af4 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f0110ad2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ad5:	83 c0 04             	add    $0x4,%eax
f0110ad8:	8b 00                	mov    (%eax),%eax
f0110ada:	83 ec 08             	sub    $0x8,%esp
f0110add:	68 da 87 12 f0       	push   $0xf01287da
f0110ae2:	50                   	push   %eax
f0110ae3:	e8 86 f5 00 00       	call   f012006e <strcmp>
f0110ae8:	83 c4 10             	add    $0x10,%esp
f0110aeb:	85 c0                	test   %eax,%eax
f0110aed:	75 05                	jne    f0110af4 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110aef:	e8 c9 52 00 00       	call   f0115dbd <test_calculate_allocated_space>
	}
	return 0;
f0110af4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110af9:	c9                   	leave  
f0110afa:	c3                   	ret    

f0110afb <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f0110afb:	55                   	push   %ebp
f0110afc:	89 e5                	mov    %esp,%ebp
f0110afe:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110b01:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110b05:	74 1a                	je     f0110b21 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f0110b07:	83 ec 0c             	sub    $0xc,%esp
f0110b0a:	68 ec 87 12 f0       	push   $0xf01287ec
f0110b0f:	e8 77 04 ff ff       	call   f0100f8b <cprintf>
f0110b14:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110b17:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b1c:	e9 ba 00 00 00       	jmp    f0110bdb <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f0110b21:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b24:	83 c0 04             	add    $0x4,%eax
f0110b27:	8b 00                	mov    (%eax),%eax
f0110b29:	83 ec 08             	sub    $0x8,%esp
f0110b2c:	68 22 88 12 f0       	push   $0xf0128822
f0110b31:	50                   	push   %eax
f0110b32:	e8 37 f5 00 00       	call   f012006e <strcmp>
f0110b37:	83 c4 10             	add    $0x10,%esp
f0110b3a:	85 c0                	test   %eax,%eax
f0110b3c:	75 0a                	jne    f0110b48 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f0110b3e:	e8 01 16 00 00       	call   f0112144 <test_pt_set_page_permissions>
f0110b43:	e9 8e 00 00 00       	jmp    f0110bd6 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f0110b48:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b4b:	83 c0 04             	add    $0x4,%eax
f0110b4e:	8b 00                	mov    (%eax),%eax
f0110b50:	83 ec 08             	sub    $0x8,%esp
f0110b53:	68 2a 88 12 f0       	push   $0xf012882a
f0110b58:	50                   	push   %eax
f0110b59:	e8 10 f5 00 00       	call   f012006e <strcmp>
f0110b5e:	83 c4 10             	add    $0x10,%esp
f0110b61:	85 c0                	test   %eax,%eax
f0110b63:	75 07                	jne    f0110b6c <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f0110b65:	e8 49 18 00 00       	call   f01123b3 <test_pt_set_page_permissions_invalid_va>
f0110b6a:	eb 6a                	jmp    f0110bd6 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f0110b6c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b6f:	83 c0 04             	add    $0x4,%eax
f0110b72:	8b 00                	mov    (%eax),%eax
f0110b74:	83 ec 08             	sub    $0x8,%esp
f0110b77:	68 32 88 12 f0       	push   $0xf0128832
f0110b7c:	50                   	push   %eax
f0110b7d:	e8 ec f4 00 00       	call   f012006e <strcmp>
f0110b82:	83 c4 10             	add    $0x10,%esp
f0110b85:	85 c0                	test   %eax,%eax
f0110b87:	75 07                	jne    f0110b90 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f0110b89:	e8 6e 18 00 00       	call   f01123fc <test_pt_get_page_permissions>
f0110b8e:	eb 46                	jmp    f0110bd6 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f0110b90:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b93:	83 c0 04             	add    $0x4,%eax
f0110b96:	8b 00                	mov    (%eax),%eax
f0110b98:	83 ec 08             	sub    $0x8,%esp
f0110b9b:	68 3a 88 12 f0       	push   $0xf012883a
f0110ba0:	50                   	push   %eax
f0110ba1:	e8 c8 f4 00 00       	call   f012006e <strcmp>
f0110ba6:	83 c4 10             	add    $0x10,%esp
f0110ba9:	85 c0                	test   %eax,%eax
f0110bab:	75 07                	jne    f0110bb4 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f0110bad:	e8 8e 19 00 00       	call   f0112540 <test_pt_clear_page_table_entry>
f0110bb2:	eb 22                	jmp    f0110bd6 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110bb4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bb7:	83 c0 04             	add    $0x4,%eax
f0110bba:	8b 00                	mov    (%eax),%eax
f0110bbc:	83 ec 08             	sub    $0x8,%esp
f0110bbf:	68 41 88 12 f0       	push   $0xf0128841
f0110bc4:	50                   	push   %eax
f0110bc5:	e8 a4 f4 00 00       	call   f012006e <strcmp>
f0110bca:	83 c4 10             	add    $0x10,%esp
f0110bcd:	85 c0                	test   %eax,%eax
f0110bcf:	75 05                	jne    f0110bd6 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f0110bd1:	e8 c3 1a 00 00       	call   f0112699 <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f0110bd6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110bdb:	c9                   	leave  
f0110bdc:	c3                   	ret    

f0110bdd <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f0110bdd:	55                   	push   %ebp
f0110bde:	89 e5                	mov    %esp,%ebp
f0110be0:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0110be3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110be6:	83 c0 08             	add    $0x8,%eax
f0110be9:	8b 00                	mov    (%eax),%eax
f0110beb:	83 ec 08             	sub    $0x8,%esp
f0110bee:	68 48 88 12 f0       	push   $0xf0128848
f0110bf3:	50                   	push   %eax
f0110bf4:	e8 75 f4 00 00       	call   f012006e <strcmp>
f0110bf9:	83 c4 10             	add    $0x10,%esp
f0110bfc:	85 c0                	test   %eax,%eax
f0110bfe:	75 20                	jne    f0110c20 <tst_kheap+0x43>
f0110c00:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110c04:	74 1a                	je     f0110c20 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f0110c06:	83 ec 0c             	sub    $0xc,%esp
f0110c09:	68 50 88 12 f0       	push   $0xf0128850
f0110c0e:	e8 78 03 ff ff       	call   f0100f8b <cprintf>
f0110c13:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110c16:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c1b:	e9 42 04 00 00       	jmp    f0111062 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f0110c20:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c23:	83 c0 08             	add    $0x8,%eax
f0110c26:	8b 00                	mov    (%eax),%eax
f0110c28:	83 ec 08             	sub    $0x8,%esp
f0110c2b:	68 48 88 12 f0       	push   $0xf0128848
f0110c30:	50                   	push   %eax
f0110c31:	e8 38 f4 00 00       	call   f012006e <strcmp>
f0110c36:	83 c4 10             	add    $0x10,%esp
f0110c39:	85 c0                	test   %eax,%eax
f0110c3b:	74 43                	je     f0110c80 <tst_kheap+0xa3>
f0110c3d:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0110c41:	74 3d                	je     f0110c80 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f0110c43:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c46:	83 c0 08             	add    $0x8,%eax
f0110c49:	8b 00                	mov    (%eax),%eax
f0110c4b:	83 ec 08             	sub    $0x8,%esp
f0110c4e:	68 a0 88 12 f0       	push   $0xf01288a0
f0110c53:	50                   	push   %eax
f0110c54:	e8 15 f4 00 00       	call   f012006e <strcmp>
f0110c59:	83 c4 10             	add    $0x10,%esp
f0110c5c:	85 c0                	test   %eax,%eax
f0110c5e:	74 20                	je     f0110c80 <tst_kheap+0xa3>
f0110c60:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f0110c64:	74 1a                	je     f0110c80 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f0110c66:	83 ec 0c             	sub    $0xc,%esp
f0110c69:	68 ac 88 12 f0       	push   $0xf01288ac
f0110c6e:	e8 18 03 ff ff       	call   f0100f8b <cprintf>
f0110c73:	83 c4 10             	add    $0x10,%esp
			return 0;
f0110c76:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c7b:	e9 e2 03 00 00       	jmp    f0111062 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f0110c80:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c83:	83 c0 04             	add    $0x4,%eax
f0110c86:	8b 00                	mov    (%eax),%eax
f0110c88:	83 ec 08             	sub    $0x8,%esp
f0110c8b:	68 f1 88 12 f0       	push   $0xf01288f1
f0110c90:	50                   	push   %eax
f0110c91:	e8 d8 f3 00 00       	call   f012006e <strcmp>
f0110c96:	83 c4 10             	add    $0x10,%esp
f0110c99:	85 c0                	test   %eax,%eax
f0110c9b:	74 1d                	je     f0110cba <tst_kheap+0xdd>
f0110c9d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ca0:	83 c0 04             	add    $0x4,%eax
f0110ca3:	8b 00                	mov    (%eax),%eax
f0110ca5:	83 ec 08             	sub    $0x8,%esp
f0110ca8:	68 f4 88 12 f0       	push   $0xf01288f4
f0110cad:	50                   	push   %eax
f0110cae:	e8 bb f3 00 00       	call   f012006e <strcmp>
f0110cb3:	83 c4 10             	add    $0x10,%esp
f0110cb6:	85 c0                	test   %eax,%eax
f0110cb8:	75 1a                	jne    f0110cd4 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f0110cba:	e8 6d f8 ff ff       	call   f011052c <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110cbf:	83 ec 0c             	sub    $0xc,%esp
f0110cc2:	68 f8 88 12 f0       	push   $0xf01288f8
f0110cc7:	e8 bf 02 ff ff       	call   f0100f8b <cprintf>
f0110ccc:	83 c4 10             	add    $0x10,%esp
f0110ccf:	e9 a0 00 00 00       	jmp    f0110d74 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110cd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cd7:	83 c0 04             	add    $0x4,%eax
f0110cda:	8b 00                	mov    (%eax),%eax
f0110cdc:	83 ec 08             	sub    $0x8,%esp
f0110cdf:	68 25 89 12 f0       	push   $0xf0128925
f0110ce4:	50                   	push   %eax
f0110ce5:	e8 84 f3 00 00       	call   f012006e <strcmp>
f0110cea:	83 c4 10             	add    $0x10,%esp
f0110ced:	85 c0                	test   %eax,%eax
f0110cef:	74 1d                	je     f0110d0e <tst_kheap+0x131>
f0110cf1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cf4:	83 c0 04             	add    $0x4,%eax
f0110cf7:	8b 00                	mov    (%eax),%eax
f0110cf9:	83 ec 08             	sub    $0x8,%esp
f0110cfc:	68 28 89 12 f0       	push   $0xf0128928
f0110d01:	50                   	push   %eax
f0110d02:	e8 67 f3 00 00       	call   f012006e <strcmp>
f0110d07:	83 c4 10             	add    $0x10,%esp
f0110d0a:	85 c0                	test   %eax,%eax
f0110d0c:	75 17                	jne    f0110d25 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f0110d0e:	e8 29 f8 ff ff       	call   f011053c <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110d13:	83 ec 0c             	sub    $0xc,%esp
f0110d16:	68 2c 89 12 f0       	push   $0xf012892c
f0110d1b:	e8 6b 02 ff ff       	call   f0100f8b <cprintf>
f0110d20:	83 c4 10             	add    $0x10,%esp
f0110d23:	eb 4f                	jmp    f0110d74 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110d25:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d28:	83 c0 04             	add    $0x4,%eax
f0110d2b:	8b 00                	mov    (%eax),%eax
f0110d2d:	83 ec 08             	sub    $0x8,%esp
f0110d30:	68 58 89 12 f0       	push   $0xf0128958
f0110d35:	50                   	push   %eax
f0110d36:	e8 33 f3 00 00       	call   f012006e <strcmp>
f0110d3b:	83 c4 10             	add    $0x10,%esp
f0110d3e:	85 c0                	test   %eax,%eax
f0110d40:	74 1d                	je     f0110d5f <tst_kheap+0x182>
f0110d42:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d45:	83 c0 04             	add    $0x4,%eax
f0110d48:	8b 00                	mov    (%eax),%eax
f0110d4a:	83 ec 08             	sub    $0x8,%esp
f0110d4d:	68 5b 89 12 f0       	push   $0xf012895b
f0110d52:	50                   	push   %eax
f0110d53:	e8 16 f3 00 00       	call   f012006e <strcmp>
f0110d58:	83 c4 10             	add    $0x10,%esp
f0110d5b:	85 c0                	test   %eax,%eax
f0110d5d:	75 15                	jne    f0110d74 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f0110d5f:	e8 e8 f7 ff ff       	call   f011054c <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0110d64:	83 ec 0c             	sub    $0xc,%esp
f0110d67:	68 60 89 12 f0       	push   $0xf0128960
f0110d6c:	e8 1a 02 ff ff       	call   f0100f8b <cprintf>
f0110d71:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110d74:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d77:	83 c0 08             	add    $0x8,%eax
f0110d7a:	8b 00                	mov    (%eax),%eax
f0110d7c:	83 ec 08             	sub    $0x8,%esp
f0110d7f:	68 48 88 12 f0       	push   $0xf0128848
f0110d84:	50                   	push   %eax
f0110d85:	e8 e4 f2 00 00       	call   f012006e <strcmp>
f0110d8a:	83 c4 10             	add    $0x10,%esp
f0110d8d:	85 c0                	test   %eax,%eax
f0110d8f:	0f 85 13 01 00 00    	jne    f0110ea8 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110d95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d98:	83 c0 0c             	add    $0xc,%eax
f0110d9b:	8b 00                	mov    (%eax),%eax
f0110d9d:	83 ec 04             	sub    $0x4,%esp
f0110da0:	6a 0a                	push   $0xa
f0110da2:	6a 00                	push   $0x0
f0110da4:	50                   	push   %eax
f0110da5:	e8 18 f5 00 00       	call   f01202c2 <strtol>
f0110daa:	83 c4 10             	add    $0x10,%esp
f0110dad:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110db0:	e8 a7 f7 ff ff       	call   f011055c <isKHeapPlacementStrategyFIRSTFIT>
f0110db5:	84 c0                	test   %al,%al
f0110db7:	74 54                	je     f0110e0d <tst_kheap+0x230>
		{
			if (testNum == 0)
f0110db9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110dbd:	75 1a                	jne    f0110dd9 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110dbf:	83 ec 0c             	sub    $0xc,%esp
f0110dc2:	68 8c 89 12 f0       	push   $0xf012898c
f0110dc7:	e8 bf 01 ff ff       	call   f0100f8b <cprintf>
f0110dcc:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110dcf:	b8 00 00 00 00       	mov    $0x0,%eax
f0110dd4:	e9 89 02 00 00       	jmp    f0111062 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f0110dd9:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110ddd:	75 0a                	jne    f0110de9 <tst_kheap+0x20c>
				test_kmalloc();
f0110ddf:	e8 ec 61 00 00       	call   f0116fd0 <test_kmalloc>
f0110de4:	e9 b5 00 00 00       	jmp    f0110e9e <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110de9:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110ded:	75 0a                	jne    f0110df9 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110def:	e8 68 6d 00 00       	call   f0117b5c <test_kmalloc_firstfit1>
f0110df4:	e9 a5 00 00 00       	jmp    f0110e9e <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110df9:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110dfd:	0f 85 9b 00 00 00    	jne    f0110e9e <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110e03:	e8 38 78 00 00       	call   f0118640 <test_kmalloc_firstfit2>
f0110e08:	e9 91 00 00 00       	jmp    f0110e9e <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f0110e0d:	e8 5f f7 ff ff       	call   f0110571 <isKHeapPlacementStrategyBESTFIT>
f0110e12:	84 c0                	test   %al,%al
f0110e14:	74 47                	je     f0110e5d <tst_kheap+0x280>
		{
			if (testNum == 0)
f0110e16:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110e1a:	75 1a                	jne    f0110e36 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f0110e1c:	83 ec 0c             	sub    $0xc,%esp
f0110e1f:	68 dc 89 12 f0       	push   $0xf01289dc
f0110e24:	e8 62 01 ff ff       	call   f0100f8b <cprintf>
f0110e29:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110e2c:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e31:	e9 2c 02 00 00       	jmp    f0111062 <tst_kheap+0x485>
			}
			if (testNum == 1)
f0110e36:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110e3a:	75 07                	jne    f0110e43 <tst_kheap+0x266>
				test_kmalloc();
f0110e3c:	e8 8f 61 00 00       	call   f0116fd0 <test_kmalloc>
f0110e41:	eb 5b                	jmp    f0110e9e <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110e43:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110e47:	75 07                	jne    f0110e50 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f0110e49:	e8 2b c8 00 00       	call   f011d679 <test_kmalloc_bestfit1>
f0110e4e:	eb 4e                	jmp    f0110e9e <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110e50:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110e54:	75 48                	jne    f0110e9e <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f0110e56:	e8 3b c8 00 00       	call   f011d696 <test_kmalloc_bestfit2>
f0110e5b:	eb 41                	jmp    f0110e9e <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f0110e5d:	e8 24 f7 ff ff       	call   f0110586 <isKHeapPlacementStrategyNEXTFIT>
f0110e62:	84 c0                	test   %al,%al
f0110e64:	74 38                	je     f0110e9e <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f0110e66:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110e6a:	75 1a                	jne    f0110e86 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f0110e6c:	83 ec 0c             	sub    $0xc,%esp
f0110e6f:	68 2c 8a 12 f0       	push   $0xf0128a2c
f0110e74:	e8 12 01 ff ff       	call   f0100f8b <cprintf>
f0110e79:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110e7c:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e81:	e9 dc 01 00 00       	jmp    f0111062 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f0110e86:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110e8a:	75 07                	jne    f0110e93 <tst_kheap+0x2b6>
				test_kmalloc();
f0110e8c:	e8 3f 61 00 00       	call   f0116fd0 <test_kmalloc>
f0110e91:	eb 0b                	jmp    f0110e9e <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f0110e93:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110e97:	75 05                	jne    f0110e9e <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f0110e99:	e8 be c7 00 00       	call   f011d65c <test_kmalloc_nextfit>
		}
		return 0;
f0110e9e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ea3:	e9 ba 01 00 00       	jmp    f0111062 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f0110ea8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110eab:	83 c0 08             	add    $0x8,%eax
f0110eae:	8b 00                	mov    (%eax),%eax
f0110eb0:	83 ec 08             	sub    $0x8,%esp
f0110eb3:	68 7a 8a 12 f0       	push   $0xf0128a7a
f0110eb8:	50                   	push   %eax
f0110eb9:	e8 b0 f1 00 00       	call   f012006e <strcmp>
f0110ebe:	83 c4 10             	add    $0x10,%esp
f0110ec1:	85 c0                	test   %eax,%eax
f0110ec3:	75 2f                	jne    f0110ef4 <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110ec5:	e8 92 f6 ff ff       	call   f011055c <isKHeapPlacementStrategyFIRSTFIT>
f0110eca:	84 c0                	test   %al,%al
f0110ecc:	74 0f                	je     f0110edd <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0110ece:	e8 74 82 00 00       	call   f0119147 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110ed3:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ed8:	e9 85 01 00 00       	jmp    f0111062 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f0110edd:	83 ec 04             	sub    $0x4,%esp
f0110ee0:	68 80 8a 12 f0       	push   $0xf0128a80
f0110ee5:	68 ac 01 00 00       	push   $0x1ac
f0110eea:	68 67 86 12 f0       	push   $0xf0128667
f0110eef:	e8 45 f4 fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110ef4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ef7:	83 c0 08             	add    $0x8,%eax
f0110efa:	8b 00                	mov    (%eax),%eax
f0110efc:	83 ec 08             	sub    $0x8,%esp
f0110eff:	68 c1 8a 12 f0       	push   $0xf0128ac1
f0110f04:	50                   	push   %eax
f0110f05:	e8 64 f1 00 00       	call   f012006e <strcmp>
f0110f0a:	83 c4 10             	add    $0x10,%esp
f0110f0d:	85 c0                	test   %eax,%eax
f0110f0f:	75 28                	jne    f0110f39 <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0110f11:	e8 5b f6 ff ff       	call   f0110571 <isKHeapPlacementStrategyBESTFIT>
f0110f16:	84 c0                	test   %al,%al
f0110f18:	75 09                	jne    f0110f23 <tst_kheap+0x346>
f0110f1a:	e8 3d f6 ff ff       	call   f011055c <isKHeapPlacementStrategyFIRSTFIT>
f0110f1f:	84 c0                	test   %al,%al
f0110f21:	74 07                	je     f0110f2a <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0110f23:	e8 ee 8a 00 00       	call   f0119a16 <test_kfree_bestfirstfit>
f0110f28:	eb 05                	jmp    f0110f2f <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f0110f2a:	e8 a1 c7 00 00       	call   f011d6d0 <test_kfree>
		}
		return 0;
f0110f2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f34:	e9 29 01 00 00       	jmp    f0111062 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110f39:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f3c:	83 c0 08             	add    $0x8,%eax
f0110f3f:	8b 00                	mov    (%eax),%eax
f0110f41:	83 ec 08             	sub    $0x8,%esp
f0110f44:	68 c7 8a 12 f0       	push   $0xf0128ac7
f0110f49:	50                   	push   %eax
f0110f4a:	e8 1f f1 00 00       	call   f012006e <strcmp>
f0110f4f:	83 c4 10             	add    $0x10,%esp
f0110f52:	85 c0                	test   %eax,%eax
f0110f54:	75 0f                	jne    f0110f65 <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f0110f56:	e8 17 a1 00 00       	call   f011b072 <test_kheap_phys_addr>
		return 0;
f0110f5b:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f60:	e9 fd 00 00 00       	jmp    f0111062 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0110f65:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f68:	83 c0 08             	add    $0x8,%eax
f0110f6b:	8b 00                	mov    (%eax),%eax
f0110f6d:	83 ec 08             	sub    $0x8,%esp
f0110f70:	68 d1 8a 12 f0       	push   $0xf0128ad1
f0110f75:	50                   	push   %eax
f0110f76:	e8 f3 f0 00 00       	call   f012006e <strcmp>
f0110f7b:	83 c4 10             	add    $0x10,%esp
f0110f7e:	85 c0                	test   %eax,%eax
f0110f80:	75 0f                	jne    f0110f91 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f0110f82:	e8 ce ae 00 00       	call   f011be55 <test_kheap_virt_addr>
		return 0;
f0110f87:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f8c:	e9 d1 00 00 00       	jmp    f0111062 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110f91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f94:	83 c0 08             	add    $0x8,%eax
f0110f97:	8b 00                	mov    (%eax),%eax
f0110f99:	83 ec 08             	sub    $0x8,%esp
f0110f9c:	68 a0 88 12 f0       	push   $0xf01288a0
f0110fa1:	50                   	push   %eax
f0110fa2:	e8 c7 f0 00 00       	call   f012006e <strcmp>
f0110fa7:	83 c4 10             	add    $0x10,%esp
f0110faa:	85 c0                	test   %eax,%eax
f0110fac:	0f 85 89 00 00 00    	jne    f011103b <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110fb2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110fb5:	83 c0 0c             	add    $0xc,%eax
f0110fb8:	8b 00                	mov    (%eax),%eax
f0110fba:	83 ec 04             	sub    $0x4,%esp
f0110fbd:	6a 0a                	push   $0xa
f0110fbf:	6a 00                	push   $0x0
f0110fc1:	50                   	push   %eax
f0110fc2:	e8 fb f2 00 00       	call   f01202c2 <strtol>
f0110fc7:	83 c4 10             	add    $0x10,%esp
f0110fca:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110fcd:	e8 8a f5 ff ff       	call   f011055c <isKHeapPlacementStrategyFIRSTFIT>
f0110fd2:	84 c0                	test   %al,%al
f0110fd4:	74 42                	je     f0111018 <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0110fd6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110fda:	75 17                	jne    f0110ff3 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110fdc:	83 ec 0c             	sub    $0xc,%esp
f0110fdf:	68 8c 89 12 f0       	push   $0xf012898c
f0110fe4:	e8 a2 ff fe ff       	call   f0100f8b <cprintf>
f0110fe9:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110fec:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ff1:	eb 6f                	jmp    f0111062 <tst_kheap+0x485>
			}
			if (testNum==1)
f0110ff3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110ff7:	75 07                	jne    f0111000 <tst_kheap+0x423>
				test_krealloc_FF1();
f0110ff9:	e8 50 c9 00 00       	call   f011d94e <test_krealloc_FF1>
f0110ffe:	eb 18                	jmp    f0111018 <tst_kheap+0x43b>
			else if (testNum==2)
f0111000:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0111004:	75 07                	jne    f011100d <tst_kheap+0x430>
				test_krealloc_FF2();
f0111006:	e8 60 c9 00 00       	call   f011d96b <test_krealloc_FF2>
f011100b:	eb 0b                	jmp    f0111018 <tst_kheap+0x43b>
			else if (testNum==3)
f011100d:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111011:	75 05                	jne    f0111018 <tst_kheap+0x43b>
				test_krealloc_FF3();
f0111013:	e8 70 c9 00 00       	call   f011d988 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f0111018:	e8 69 f5 ff ff       	call   f0110586 <isKHeapPlacementStrategyNEXTFIT>
f011101d:	84 c0                	test   %al,%al
f011101f:	74 05                	je     f0111026 <tst_kheap+0x449>
		{
			test_krealloc();
f0111021:	e8 ee c8 00 00       	call   f011d914 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f0111026:	e8 46 f5 ff ff       	call   f0110571 <isKHeapPlacementStrategyBESTFIT>
f011102b:	84 c0                	test   %al,%al
f011102d:	74 05                	je     f0111034 <tst_kheap+0x457>
		{
			test_krealloc_BF();
f011102f:	e8 fd c8 00 00       	call   f011d931 <test_krealloc_BF>
		}
		return 0;
f0111034:	b8 00 00 00 00       	mov    $0x0,%eax
f0111039:	eb 27                	jmp    f0111062 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f011103b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011103e:	83 c0 08             	add    $0x8,%eax
f0111041:	8b 00                	mov    (%eax),%eax
f0111043:	83 ec 08             	sub    $0x8,%esp
f0111046:	68 db 8a 12 f0       	push   $0xf0128adb
f011104b:	50                   	push   %eax
f011104c:	e8 1d f0 00 00       	call   f012006e <strcmp>
f0111051:	83 c4 10             	add    $0x10,%esp
f0111054:	85 c0                	test   %eax,%eax
f0111056:	75 05                	jne    f011105d <tst_kheap+0x480>
	{
		test_ksbrk();
f0111058:	e8 1d bb 00 00       	call   f011cb7a <test_ksbrk>
	}
	return 0;
f011105d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111062:	c9                   	leave  
f0111063:	c3                   	ret    

f0111064 <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f0111064:	55                   	push   %ebp
f0111065:	89 e5                	mov    %esp,%ebp
f0111067:	83 ec 28             	sub    $0x28,%esp
f011106a:	8b 45 14             	mov    0x14(%ebp),%eax
f011106d:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f0111070:	8b 45 08             	mov    0x8(%ebp),%eax
f0111073:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111076:	74 1d                	je     f0111095 <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f0111078:	83 ec 04             	sub    $0x4,%esp
f011107b:	ff 75 08             	pushl  0x8(%ebp)
f011107e:	ff 75 0c             	pushl  0xc(%ebp)
f0111081:	68 e0 8a 12 f0       	push   $0xf0128ae0
f0111086:	e8 00 ff fe ff       	call   f0100f8b <cprintf>
f011108b:	83 c4 10             	add    $0x10,%esp
		return 0;
f011108e:	b8 00 00 00 00       	mov    $0x0,%eax
f0111093:	eb 55                	jmp    f01110ea <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f0111095:	8b 45 08             	mov    0x8(%ebp),%eax
f0111098:	8b 40 fc             	mov    -0x4(%eax),%eax
f011109b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f011109e:	8b 45 10             	mov    0x10(%ebp),%eax
f01110a1:	8d 50 f8             	lea    -0x8(%eax),%edx
f01110a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01110a7:	01 d0                	add    %edx,%eax
f01110a9:	8b 00                	mov    (%eax),%eax
f01110ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f01110ae:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f01110b2:	0b 45 10             	or     0x10(%ebp),%eax
f01110b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f01110b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01110bb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01110be:	75 08                	jne    f01110c8 <check_block+0x64>
f01110c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01110c3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01110c6:	74 1d                	je     f01110e5 <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f01110c8:	ff 75 f0             	pushl  -0x10(%ebp)
f01110cb:	ff 75 f4             	pushl  -0xc(%ebp)
f01110ce:	ff 75 ec             	pushl  -0x14(%ebp)
f01110d1:	68 10 8b 12 f0       	push   $0xf0128b10
f01110d6:	e8 b0 fe fe ff       	call   f0100f8b <cprintf>
f01110db:	83 c4 10             	add    $0x10,%esp
		return 0;
f01110de:	b8 00 00 00 00       	mov    $0x0,%eax
f01110e3:	eb 05                	jmp    f01110ea <check_block+0x86>
	}
	return 1;
f01110e5:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01110ea:	c9                   	leave  
f01110eb:	c3                   	ret    

f01110ec <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f01110ec:	55                   	push   %ebp
f01110ed:	89 e5                	mov    %esp,%ebp
f01110ef:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f01110f2:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01110f7:	3b 45 08             	cmp    0x8(%ebp),%eax
f01110fa:	74 20                	je     f011111c <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f01110fc:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0111101:	83 ec 04             	sub    $0x4,%esp
f0111104:	50                   	push   %eax
f0111105:	ff 75 08             	pushl  0x8(%ebp)
f0111108:	68 4c 8b 12 f0       	push   $0xf0128b4c
f011110d:	e8 79 fe fe ff       	call   f0100f8b <cprintf>
f0111112:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111115:	b8 00 00 00 00       	mov    $0x0,%eax
f011111a:	eb 05                	jmp    f0111121 <check_list_size+0x35>
	}
	return 1;
f011111c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111121:	c9                   	leave  
f0111122:	c3                   	ret    

f0111123 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0111123:	55                   	push   %ebp
f0111124:	89 e5                	mov    %esp,%ebp
f0111126:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f0111129:	83 ec 04             	sub    $0x4,%esp
f011112c:	68 80 8b 12 f0       	push   $0xf0128b80
f0111131:	6a 3f                	push   $0x3f
f0111133:	68 e0 8b 12 f0       	push   $0xf0128be0
f0111138:	e8 fc f1 fe ff       	call   f0100339 <_panic>

f011113d <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f011113d:	55                   	push   %ebp
f011113e:	89 e5                	mov    %esp,%ebp
f0111140:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111143:	83 ec 04             	sub    $0x4,%esp
f0111146:	68 04 8c 12 f0       	push   $0xf0128c04
f011114b:	6a 61                	push   $0x61
f011114d:	68 e0 8b 12 f0       	push   $0xf0128be0
f0111152:	e8 e2 f1 fe ff       	call   f0100339 <_panic>

f0111157 <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f0111157:	55                   	push   %ebp
f0111158:	89 e5                	mov    %esp,%ebp
f011115a:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011115d:	83 ec 04             	sub    $0x4,%esp
f0111160:	68 54 8c 12 f0       	push   $0xf0128c54
f0111165:	68 e7 00 00 00       	push   $0xe7
f011116a:	68 e0 8b 12 f0       	push   $0xf0128be0
f011116f:	e8 c5 f1 fe ff       	call   f0100339 <_panic>

f0111174 <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f0111174:	55                   	push   %ebp
f0111175:	89 e5                	mov    %esp,%ebp
f0111177:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011117d:	83 ec 04             	sub    $0x4,%esp
f0111180:	68 a8 8c 12 f0       	push   $0xf0128ca8
f0111185:	68 88 01 00 00       	push   $0x188
f011118a:	68 e0 8b 12 f0       	push   $0xf0128be0
f011118f:	e8 a5 f1 fe ff       	call   f0100339 <_panic>

f0111194 <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f0111194:	55                   	push   %ebp
f0111195:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f0111197:	90                   	nop
f0111198:	5d                   	pop    %ebp
f0111199:	c3                   	ret    

f011119a <test_free_block_FF>:

void test_free_block_FF()
{
f011119a:	55                   	push   %ebp
f011119b:	89 e5                	mov    %esp,%ebp
f011119d:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01111a0:	83 ec 04             	sub    $0x4,%esp
f01111a3:	68 fc 8c 12 f0       	push   $0xf0128cfc
f01111a8:	68 4e 02 00 00       	push   $0x24e
f01111ad:	68 e0 8b 12 f0       	push   $0xf0128be0
f01111b2:	e8 82 f1 fe ff       	call   f0100339 <_panic>

f01111b7 <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f01111b7:	55                   	push   %ebp
f01111b8:	89 e5                	mov    %esp,%ebp
f01111ba:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01111bd:	83 ec 04             	sub    $0x4,%esp
f01111c0:	68 fc 8c 12 f0       	push   $0xf0128cfc
f01111c5:	68 9a 03 00 00       	push   $0x39a
f01111ca:	68 e0 8b 12 f0       	push   $0xf0128be0
f01111cf:	e8 65 f1 fe ff       	call   f0100339 <_panic>

f01111d4 <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f01111d4:	55                   	push   %ebp
f01111d5:	89 e5                	mov    %esp,%ebp
f01111d7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f01111da:	83 ec 04             	sub    $0x4,%esp
f01111dd:	68 49 8d 12 f0       	push   $0xf0128d49
f01111e2:	68 ba 04 00 00       	push   $0x4ba
f01111e7:	68 e0 8b 12 f0       	push   $0xf0128be0
f01111ec:	e8 48 f1 fe ff       	call   f0100339 <_panic>

f01111f1 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f01111f1:	55                   	push   %ebp
f01111f2:	89 e5                	mov    %esp,%ebp
f01111f4:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01111f7:	83 ec 04             	sub    $0x4,%esp
f01111fa:	68 fc 8c 12 f0       	push   $0xf0128cfc
f01111ff:	68 c0 04 00 00       	push   $0x4c0
f0111204:	68 e0 8b 12 f0       	push   $0xf0128be0
f0111209:	e8 2b f1 fe ff       	call   f0100339 <_panic>

f011120e <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f011120e:	55                   	push   %ebp
f011120f:	89 e5                	mov    %esp,%ebp
f0111211:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111214:	83 ec 04             	sub    $0x4,%esp
f0111217:	68 fc 8c 12 f0       	push   $0xf0128cfc
f011121c:	68 e7 05 00 00       	push   $0x5e7
f0111221:	68 e0 8b 12 f0       	push   $0xf0128be0
f0111226:	e8 0e f1 fe ff       	call   f0100339 <_panic>

f011122b <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f011122b:	55                   	push   %ebp
f011122c:	89 e5                	mov    %esp,%ebp
f011122e:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0111231:	e8 ef aa ff ff       	call   f010bd25 <get_cpu_proc>
f0111236:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0111239:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011123d:	75 16                	jne    f0111255 <sys_check_LRU_lists+0x2a>
f011123f:	68 5c 8d 12 f0       	push   $0xf0128d5c
f0111244:	68 6c 8d 12 f0       	push   $0xf0128d6c
f0111249:	6a 10                	push   $0x10
f011124b:	68 81 8d 12 f0       	push   $0xf0128d81
f0111250:	e8 e4 f0 fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0111255:	83 ec 0c             	sub    $0xc,%esp
f0111258:	68 a0 8d 12 f0       	push   $0xf0128da0
f011125d:	e8 29 fd fe ff       	call   f0100f8b <cprintf>
f0111262:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0111265:	83 ec 0c             	sub    $0xc,%esp
f0111268:	ff 75 e0             	pushl  -0x20(%ebp)
f011126b:	e8 37 95 ff ff       	call   f010a7a7 <env_page_ws_print>
f0111270:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0111273:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111276:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0111279:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0111280:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0111287:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011128b:	0f 84 a5 00 00 00    	je     f0111336 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f0111291:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111298:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011129b:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f01112a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01112a4:	eb 4a                	jmp    f01112f0 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f01112a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01112a9:	8b 00                	mov    (%eax),%eax
f01112ab:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01112ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01112b1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112b6:	89 c2                	mov    %eax,%edx
f01112b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01112bb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01112c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01112c5:	01 c8                	add    %ecx,%eax
f01112c7:	8b 00                	mov    (%eax),%eax
f01112c9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01112cc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01112cf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112d4:	39 c2                	cmp    %eax,%edx
f01112d6:	74 09                	je     f01112e1 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f01112d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01112df:	eb 3e                	jmp    f011131f <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f01112e1:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01112e4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01112e7:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01112ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01112f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01112f4:	74 08                	je     f01112fe <sys_check_LRU_lists+0xd3>
f01112f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01112f9:	8b 40 10             	mov    0x10(%eax),%eax
f01112fc:	eb 05                	jmp    f0111303 <sys_check_LRU_lists+0xd8>
f01112fe:	b8 00 00 00 00       	mov    $0x0,%eax
f0111303:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111306:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f011130c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011130f:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111315:	85 c0                	test   %eax,%eax
f0111317:	75 8d                	jne    f01112a6 <sys_check_LRU_lists+0x7b>
f0111319:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011131d:	75 87                	jne    f01112a6 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f011131f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111322:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f0111328:	8b 45 10             	mov    0x10(%ebp),%eax
f011132b:	39 c2                	cmp    %eax,%edx
f011132d:	74 07                	je     f0111336 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f011132f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0111336:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011133a:	0f 84 a5 00 00 00    	je     f01113e5 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f0111340:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111347:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011134a:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111350:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111353:	eb 4a                	jmp    f011139f <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f0111355:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111358:	8b 00                	mov    (%eax),%eax
f011135a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011135d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111360:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111365:	89 c2                	mov    %eax,%edx
f0111367:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011136a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111371:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111374:	01 c8                	add    %ecx,%eax
f0111376:	8b 00                	mov    (%eax),%eax
f0111378:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011137b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011137e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111383:	39 c2                	cmp    %eax,%edx
f0111385:	74 09                	je     f0111390 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f0111387:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f011138e:	eb 3e                	jmp    f01113ce <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f0111390:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111393:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111396:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011139c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011139f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01113a3:	74 08                	je     f01113ad <sys_check_LRU_lists+0x182>
f01113a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01113a8:	8b 40 10             	mov    0x10(%eax),%eax
f01113ab:	eb 05                	jmp    f01113b2 <sys_check_LRU_lists+0x187>
f01113ad:	b8 00 00 00 00       	mov    $0x0,%eax
f01113b2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01113b5:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f01113bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01113be:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01113c4:	85 c0                	test   %eax,%eax
f01113c6:	75 8d                	jne    f0111355 <sys_check_LRU_lists+0x12a>
f01113c8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01113cc:	75 87                	jne    f0111355 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f01113ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01113d1:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f01113d7:	8b 45 14             	mov    0x14(%ebp),%eax
f01113da:	39 c2                	cmp    %eax,%edx
f01113dc:	74 07                	je     f01113e5 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f01113de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f01113e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01113e8:	23 45 f0             	and    -0x10(%ebp),%eax
}
f01113eb:	c9                   	leave  
f01113ec:	c3                   	ret    

f01113ed <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f01113ed:	55                   	push   %ebp
f01113ee:	89 e5                	mov    %esp,%ebp
f01113f0:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f01113f3:	e8 2d a9 ff ff       	call   f010bd25 <get_cpu_proc>
f01113f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01113fb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01113ff:	75 16                	jne    f0111417 <sys_check_LRU_lists_free+0x2a>
f0111401:	68 5c 8d 12 f0       	push   $0xf0128d5c
f0111406:	68 6c 8d 12 f0       	push   $0xf0128d6c
f011140b:	6a 45                	push   $0x45
f011140d:	68 81 8d 12 f0       	push   $0xf0128d81
f0111412:	e8 22 ef fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0111417:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011141a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f011141d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111424:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111427:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f011142d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111430:	eb 65                	jmp    f0111497 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0111432:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0111439:	eb 3a                	jmp    f0111475 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f011143b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011143e:	8b 00                	mov    (%eax),%eax
f0111440:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111443:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111446:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011144b:	89 c2                	mov    %eax,%edx
f011144d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111450:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111457:	8b 45 08             	mov    0x8(%ebp),%eax
f011145a:	01 c8                	add    %ecx,%eax
f011145c:	8b 00                	mov    (%eax),%eax
f011145e:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0111461:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111464:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111469:	39 c2                	cmp    %eax,%edx
f011146b:	75 05                	jne    f0111472 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f011146d:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111470:	eb 0b                	jmp    f011147d <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f0111472:	ff 45 ec             	incl   -0x14(%ebp)
f0111475:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111478:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011147b:	7c be                	jl     f011143b <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f011147d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111481:	7e 08                	jle    f011148b <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f0111483:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111486:	e9 ed 00 00 00       	jmp    f0111578 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f011148b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011148e:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111494:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111497:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011149b:	74 08                	je     f01114a5 <sys_check_LRU_lists_free+0xb8>
f011149d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01114a0:	8b 40 10             	mov    0x10(%eax),%eax
f01114a3:	eb 05                	jmp    f01114aa <sys_check_LRU_lists_free+0xbd>
f01114a5:	b8 00 00 00 00       	mov    $0x0,%eax
f01114aa:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01114ad:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f01114b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01114b6:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01114bc:	85 c0                	test   %eax,%eax
f01114be:	0f 85 6e ff ff ff    	jne    f0111432 <sys_check_LRU_lists_free+0x45>
f01114c4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01114c8:	0f 85 64 ff ff ff    	jne    f0111432 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01114ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01114d1:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01114d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01114da:	eb 62                	jmp    f011153e <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f01114dc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01114e3:	eb 3a                	jmp    f011151f <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f01114e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01114e8:	8b 00                	mov    (%eax),%eax
f01114ea:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01114ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01114f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01114f5:	89 c2                	mov    %eax,%edx
f01114f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01114fa:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111501:	8b 45 08             	mov    0x8(%ebp),%eax
f0111504:	01 c8                	add    %ecx,%eax
f0111506:	8b 00                	mov    (%eax),%eax
f0111508:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011150b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011150e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111513:	39 c2                	cmp    %eax,%edx
f0111515:	75 05                	jne    f011151c <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0111517:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f011151a:	eb 0b                	jmp    f0111527 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f011151c:	ff 45 e8             	incl   -0x18(%ebp)
f011151f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111522:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111525:	7c be                	jl     f01114e5 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111527:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011152b:	7e 05                	jle    f0111532 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f011152d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111530:	eb 46                	jmp    f0111578 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111532:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111535:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011153b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011153e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111542:	74 08                	je     f011154c <sys_check_LRU_lists_free+0x15f>
f0111544:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111547:	8b 40 10             	mov    0x10(%eax),%eax
f011154a:	eb 05                	jmp    f0111551 <sys_check_LRU_lists_free+0x164>
f011154c:	b8 00 00 00 00       	mov    $0x0,%eax
f0111551:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111554:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f011155a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011155d:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111563:	85 c0                	test   %eax,%eax
f0111565:	0f 85 71 ff ff ff    	jne    f01114dc <sys_check_LRU_lists_free+0xef>
f011156b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011156f:	0f 85 67 ff ff ff    	jne    f01114dc <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f0111575:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0111578:	c9                   	leave  
f0111579:	c3                   	ret    

f011157a <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f011157a:	55                   	push   %ebp
f011157b:	89 e5                	mov    %esp,%ebp
f011157d:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f0111580:	e8 a0 a7 ff ff       	call   f010bd25 <get_cpu_proc>
f0111585:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0111588:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011158c:	75 16                	jne    f01115a4 <sys_check_WS_list+0x2a>
f011158e:	68 5c 8d 12 f0       	push   $0xf0128d5c
f0111593:	68 6c 8d 12 f0       	push   $0xf0128d6c
f0111598:	6a 79                	push   $0x79
f011159a:	68 81 8d 12 f0       	push   $0xf0128d81
f011159f:	e8 95 ed fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f01115a4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01115a7:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f01115aa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f01115b1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f01115b5:	74 06                	je     f01115bd <sys_check_WS_list+0x43>
f01115b7:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f01115bb:	75 1f                	jne    f01115dc <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f01115bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115c0:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f01115c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01115c9:	39 c2                	cmp    %eax,%edx
f01115cb:	74 0f                	je     f01115dc <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f01115cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01115d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01115d7:	e9 15 03 00 00       	jmp    f01118f1 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f01115dc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01115e0:	74 39                	je     f011161b <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f01115e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115e5:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01115eb:	8b 00                	mov    (%eax),%eax
f01115ed:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01115f0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01115f3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115f8:	89 c2                	mov    %eax,%edx
f01115fa:	8b 45 10             	mov    0x10(%ebp),%eax
f01115fd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0111600:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111603:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111608:	39 c2                	cmp    %eax,%edx
f011160a:	74 0f                	je     f011161b <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f011160c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111613:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111616:	e9 d6 02 00 00       	jmp    f01118f1 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f011161b:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f011161f:	0f 85 3c 01 00 00    	jne    f0111761 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0111625:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f011162c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0111630:	74 4c                	je     f011167e <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0111632:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111639:	eb 3b                	jmp    f0111676 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f011163b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011163e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111645:	8b 45 08             	mov    0x8(%ebp),%eax
f0111648:	01 d0                	add    %edx,%eax
f011164a:	8b 00                	mov    (%eax),%eax
f011164c:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011164f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111652:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111657:	89 c2                	mov    %eax,%edx
f0111659:	8b 45 10             	mov    0x10(%ebp),%eax
f011165c:	89 45 bc             	mov    %eax,-0x44(%ebp)
f011165f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111662:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111667:	39 c2                	cmp    %eax,%edx
f0111669:	75 08                	jne    f0111673 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f011166b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011166e:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f0111671:	eb 0b                	jmp    f011167e <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0111673:	ff 45 e8             	incl   -0x18(%ebp)
f0111676:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111679:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011167c:	7c bd                	jl     f011163b <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f011167e:	83 ec 08             	sub    $0x8,%esp
f0111681:	ff 75 ec             	pushl  -0x14(%ebp)
f0111684:	68 c8 8d 12 f0       	push   $0xf0128dc8
f0111689:	e8 fd f8 fe ff       	call   f0100f8b <cprintf>
f011168e:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f0111691:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111694:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011169a:	85 c0                	test   %eax,%eax
f011169c:	74 0e                	je     f01116ac <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f011169e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01116a1:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01116a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01116aa:	eb 0c                	jmp    f01116b8 <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01116ac:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01116af:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01116b5:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f01116b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116bb:	8b 00                	mov    (%eax),%eax
f01116bd:	83 ec 08             	sub    $0x8,%esp
f01116c0:	50                   	push   %eax
f01116c1:	68 e7 8d 12 f0       	push   $0xf0128de7
f01116c6:	e8 c0 f8 fe ff       	call   f0100f8b <cprintf>
f01116cb:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f01116ce:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01116d5:	eb 79                	jmp    f0111750 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f01116d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116da:	8b 00                	mov    (%eax),%eax
f01116dc:	89 45 b8             	mov    %eax,-0x48(%ebp)
f01116df:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01116e2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01116e7:	89 c2                	mov    %eax,%edx
f01116e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01116ec:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01116f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01116f6:	01 c8                	add    %ecx,%eax
f01116f8:	8b 00                	mov    (%eax),%eax
f01116fa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f01116fd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111700:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111705:	39 c2                	cmp    %eax,%edx
f0111707:	74 0c                	je     f0111715 <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f0111709:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111710:	e9 d9 01 00 00       	jmp    f01118ee <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0111715:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111718:	40                   	inc    %eax
f0111719:	89 c2                	mov    %eax,%edx
f011171b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011171e:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f0111724:	89 d0                	mov    %edx,%eax
f0111726:	ba 00 00 00 00       	mov    $0x0,%edx
f011172b:	f7 f1                	div    %ecx
f011172d:	89 d0                	mov    %edx,%eax
f011172f:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0111732:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111735:	8b 40 10             	mov    0x10(%eax),%eax
f0111738:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f011173b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011173f:	75 0c                	jne    f011174d <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111741:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111744:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011174a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f011174d:	ff 45 e4             	incl   -0x1c(%ebp)
f0111750:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111753:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111756:	0f 8c 7b ff ff ff    	jl     f01116d7 <sys_check_WS_list+0x15d>
f011175c:	e9 8d 01 00 00       	jmp    f01118ee <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0111761:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111765:	74 0a                	je     f0111771 <sys_check_WS_list+0x1f7>
f0111767:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f011176b:	0f 85 be 00 00 00    	jne    f011182f <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111771:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0111778:	e9 a1 00 00 00       	jmp    f011181e <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f011177d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111784:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111787:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011178d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111790:	eb 47                	jmp    f01117d9 <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0111792:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111795:	8b 00                	mov    (%eax),%eax
f0111797:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011179a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011179d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01117a2:	89 c2                	mov    %eax,%edx
f01117a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01117a7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01117ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01117b1:	01 c8                	add    %ecx,%eax
f01117b3:	8b 00                	mov    (%eax),%eax
f01117b5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f01117b8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01117bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01117c0:	39 c2                	cmp    %eax,%edx
f01117c2:	75 09                	jne    f01117cd <sys_check_WS_list+0x253>
				{
					found = 1;
f01117c4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f01117cb:	eb 3b                	jmp    f0111808 <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01117cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01117d0:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01117d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01117d9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01117dd:	74 08                	je     f01117e7 <sys_check_WS_list+0x26d>
f01117df:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01117e2:	8b 40 10             	mov    0x10(%eax),%eax
f01117e5:	eb 05                	jmp    f01117ec <sys_check_WS_list+0x272>
f01117e7:	b8 00 00 00 00       	mov    $0x0,%eax
f01117ec:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01117ef:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f01117f5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01117f8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01117fe:	85 c0                	test   %eax,%eax
f0111800:	75 90                	jne    f0111792 <sys_check_WS_list+0x218>
f0111802:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111806:	75 8a                	jne    f0111792 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f0111808:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011180c:	75 0d                	jne    f011181b <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f011180e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111815:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111816:	e9 d3 00 00 00       	jmp    f01118ee <sys_check_WS_list+0x374>
f011181b:	ff 45 e0             	incl   -0x20(%ebp)
f011181e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111821:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111824:	0f 8c 53 ff ff ff    	jl     f011177d <sys_check_WS_list+0x203>
f011182a:	e9 bf 00 00 00       	jmp    f01118ee <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f011182f:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0111833:	0f 85 b5 00 00 00    	jne    f01118ee <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111839:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0111840:	e9 9d 00 00 00       	jmp    f01118e2 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f0111845:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011184c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011184f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111855:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111858:	eb 47                	jmp    f01118a1 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f011185a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011185d:	8b 00                	mov    (%eax),%eax
f011185f:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111862:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111865:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011186a:	89 c2                	mov    %eax,%edx
f011186c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011186f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111876:	8b 45 08             	mov    0x8(%ebp),%eax
f0111879:	01 c8                	add    %ecx,%eax
f011187b:	8b 00                	mov    (%eax),%eax
f011187d:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0111880:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111883:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111888:	39 c2                	cmp    %eax,%edx
f011188a:	75 09                	jne    f0111895 <sys_check_WS_list+0x31b>
				{
					found = 1;
f011188c:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f0111893:	eb 3b                	jmp    f01118d0 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111895:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111898:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f011189e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01118a1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01118a5:	74 08                	je     f01118af <sys_check_WS_list+0x335>
f01118a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01118aa:	8b 40 10             	mov    0x10(%eax),%eax
f01118ad:	eb 05                	jmp    f01118b4 <sys_check_WS_list+0x33a>
f01118af:	b8 00 00 00 00       	mov    $0x0,%eax
f01118b4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01118b7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f01118bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01118c0:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01118c6:	85 c0                	test   %eax,%eax
f01118c8:	75 90                	jne    f011185a <sys_check_WS_list+0x2e0>
f01118ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01118ce:	75 8a                	jne    f011185a <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f01118d0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01118d4:	74 09                	je     f01118df <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f01118d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01118dd:	eb 0f                	jmp    f01118ee <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01118df:	ff 45 d8             	incl   -0x28(%ebp)
f01118e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01118e5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01118e8:	0f 8c 57 ff ff ff    	jl     f0111845 <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f01118ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f01118f1:	c9                   	leave  
f01118f2:	c3                   	ret    

f01118f3 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f01118f3:	55                   	push   %ebp
f01118f4:	89 e5                	mov    %esp,%ebp
f01118f6:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f01118f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0111900:	8b 15 64 f8 f1 f0    	mov    0xf0f1f864,%edx
f0111906:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111909:	39 c2                	cmp    %eax,%edx
f011190b:	74 0a                	je     f0111917 <hasExpectedCommands+0x24>
		return 0;
f011190d:	b8 00 00 00 00       	mov    $0x0,%eax
f0111912:	e9 8b 00 00 00       	jmp    f01119a2 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0111917:	a1 58 f8 f1 f0       	mov    0xf0f1f858,%eax
f011191c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011191f:	eb 55                	jmp    f0111976 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111921:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0111928:	eb 2a                	jmp    f0111954 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f011192a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011192d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111934:	8b 45 08             	mov    0x8(%ebp),%eax
f0111937:	01 d0                	add    %edx,%eax
f0111939:	8b 10                	mov    (%eax),%edx
f011193b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011193e:	8b 00                	mov    (%eax),%eax
f0111940:	83 ec 08             	sub    $0x8,%esp
f0111943:	52                   	push   %edx
f0111944:	50                   	push   %eax
f0111945:	e8 24 e7 00 00       	call   f012006e <strcmp>
f011194a:	83 c4 10             	add    $0x10,%esp
f011194d:	85 c0                	test   %eax,%eax
f011194f:	74 0d                	je     f011195e <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111951:	ff 45 f0             	incl   -0x10(%ebp)
f0111954:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111957:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011195a:	7c ce                	jl     f011192a <hasExpectedCommands+0x37>
f011195c:	eb 01                	jmp    f011195f <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f011195e:	90                   	nop
		if (i == commandsCount)
f011195f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111962:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111965:	75 07                	jne    f011196e <hasExpectedCommands+0x7b>
			return 0;
f0111967:	b8 00 00 00 00       	mov    $0x0,%eax
f011196c:	eb 34                	jmp    f01119a2 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f011196e:	a1 60 f8 f1 f0       	mov    0xf0f1f860,%eax
f0111973:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111976:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011197a:	74 08                	je     f0111984 <hasExpectedCommands+0x91>
f011197c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011197f:	8b 40 10             	mov    0x10(%eax),%eax
f0111982:	eb 05                	jmp    f0111989 <hasExpectedCommands+0x96>
f0111984:	b8 00 00 00 00       	mov    $0x0,%eax
f0111989:	a3 60 f8 f1 f0       	mov    %eax,0xf0f1f860
f011198e:	a1 60 f8 f1 f0       	mov    0xf0f1f860,%eax
f0111993:	85 c0                	test   %eax,%eax
f0111995:	75 8a                	jne    f0111921 <hasExpectedCommands+0x2e>
f0111997:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011199b:	75 84                	jne    f0111921 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f011199d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01119a2:	c9                   	leave  
f01119a3:	c3                   	ret    

f01119a4 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f01119a4:	55                   	push   %ebp
f01119a5:	89 e5                	mov    %esp,%ebp
f01119a7:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01119aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01119b1:	eb 2e                	jmp    f01119e1 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01119b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01119b6:	89 d0                	mov    %edx,%eax
f01119b8:	01 c0                	add    %eax,%eax
f01119ba:	01 d0                	add    %edx,%eax
f01119bc:	c1 e0 03             	shl    $0x3,%eax
f01119bf:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01119c4:	8b 00                	mov    (%eax),%eax
f01119c6:	83 ec 08             	sub    $0x8,%esp
f01119c9:	ff 75 08             	pushl  0x8(%ebp)
f01119cc:	50                   	push   %eax
f01119cd:	e8 9c e6 00 00       	call   f012006e <strcmp>
f01119d2:	83 c4 10             	add    $0x10,%esp
f01119d5:	85 c0                	test   %eax,%eax
f01119d7:	75 05                	jne    f01119de <getIndexOfCommand+0x3a>
			return i;
f01119d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01119dc:	eb 14                	jmp    f01119f2 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01119de:	ff 45 f4             	incl   -0xc(%ebp)
f01119e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01119e4:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01119e9:	39 c2                	cmp    %eax,%edx
f01119eb:	72 c6                	jb     f01119b3 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f01119ed:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f01119f2:	c9                   	leave  
f01119f3:	c3                   	ret    

f01119f4 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f01119f4:	55                   	push   %ebp
f01119f5:	89 e5                	mov    %esp,%ebp
f01119f7:	57                   	push   %edi
f01119f8:	56                   	push   %esi
f01119f9:	53                   	push   %ebx
f01119fa:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111a00:	83 ec 0c             	sub    $0xc,%esp
f0111a03:	68 20 8e 12 f0       	push   $0xf0128e20
f0111a08:	e8 7e f5 fe ff       	call   f0100f8b <cprintf>
f0111a0d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111a10:	83 ec 0c             	sub    $0xc,%esp
f0111a13:	68 44 8e 12 f0       	push   $0xf0128e44
f0111a18:	e8 6e f5 fe ff       	call   f0100f8b <cprintf>
f0111a1d:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111a20:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0111a27:	c7 45 8c 5f 8e 12 f0 	movl   $0xf0128e5f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0111a2e:	83 ec 08             	sub    $0x8,%esp
f0111a31:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0111a34:	50                   	push   %eax
f0111a35:	6a 01                	push   $0x1
f0111a37:	e8 94 07 ff ff       	call   f01021d0 <process_command>
f0111a3c:	83 c4 10             	add    $0x10,%esp
f0111a3f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0111a42:	83 ec 0c             	sub    $0xc,%esp
f0111a45:	68 6c 8e 12 f0       	push   $0xf0128e6c
f0111a4a:	e8 3c f5 fe ff       	call   f0100f8b <cprintf>
f0111a4f:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0111a52:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0111a55:	83 ec 0c             	sub    $0xc,%esp
f0111a58:	50                   	push   %eax
f0111a59:	e8 46 ff ff ff       	call   f01119a4 <getIndexOfCommand>
f0111a5e:	83 c4 10             	add    $0x10,%esp
f0111a61:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111a64:	75 0f                	jne    f0111a75 <TestAutoCompleteCommand+0x81>
f0111a66:	a1 58 f8 f1 f0       	mov    0xf0f1f858,%eax
f0111a6b:	85 c0                	test   %eax,%eax
f0111a6d:	75 06                	jne    f0111a75 <TestAutoCompleteCommand+0x81>
		eval += 15;
f0111a6f:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111a73:	eb 10                	jmp    f0111a85 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111a75:	83 ec 0c             	sub    $0xc,%esp
f0111a78:	68 9c 8e 12 f0       	push   $0xf0128e9c
f0111a7d:	e8 09 f5 fe ff       	call   f0100f8b <cprintf>
f0111a82:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f0111a85:	83 ec 0c             	sub    $0xc,%esp
f0111a88:	68 ec 8e 12 f0       	push   $0xf0128eec
f0111a8d:	e8 f9 f4 fe ff       	call   f0100f8b <cprintf>
f0111a92:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f0111a95:	c7 45 88 12 8f 12 f0 	movl   $0xf0128f12,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f0111a9c:	83 ec 08             	sub    $0x8,%esp
f0111a9f:	8d 45 88             	lea    -0x78(%ebp),%eax
f0111aa2:	50                   	push   %eax
f0111aa3:	6a 01                	push   $0x1
f0111aa5:	e8 26 07 ff ff       	call   f01021d0 <process_command>
f0111aaa:	83 c4 10             	add    $0x10,%esp
f0111aad:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0111ab0:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111ab4:	75 30                	jne    f0111ae6 <TestAutoCompleteCommand+0xf2>
f0111ab6:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111ab9:	bb f0 92 12 f0       	mov    $0xf01292f0,%ebx
f0111abe:	ba 03 00 00 00       	mov    $0x3,%edx
f0111ac3:	89 c7                	mov    %eax,%edi
f0111ac5:	89 de                	mov    %ebx,%esi
f0111ac7:	89 d1                	mov    %edx,%ecx
f0111ac9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111acb:	83 ec 08             	sub    $0x8,%esp
f0111ace:	6a 03                	push   $0x3
f0111ad0:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111ad3:	50                   	push   %eax
f0111ad4:	e8 1a fe ff ff       	call   f01118f3 <hasExpectedCommands>
f0111ad9:	83 c4 10             	add    $0x10,%esp
f0111adc:	85 c0                	test   %eax,%eax
f0111ade:	74 06                	je     f0111ae6 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111ae0:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111ae4:	eb 10                	jmp    f0111af6 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111ae6:	83 ec 0c             	sub    $0xc,%esp
f0111ae9:	68 18 8f 12 f0       	push   $0xf0128f18
f0111aee:	e8 98 f4 fe ff       	call   f0100f8b <cprintf>
f0111af3:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111af6:	83 ec 0c             	sub    $0xc,%esp
f0111af9:	68 68 8f 12 f0       	push   $0xf0128f68
f0111afe:	e8 88 f4 fe ff       	call   f0100f8b <cprintf>
f0111b03:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0111b06:	c7 45 84 8d 8f 12 f0 	movl   $0xf0128f8d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f0111b0d:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111b10:	83 ec 04             	sub    $0x4,%esp
f0111b13:	50                   	push   %eax
f0111b14:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111b17:	50                   	push   %eax
f0111b18:	68 90 8f 12 f0       	push   $0xf0128f90
f0111b1d:	e8 69 f4 fe ff       	call   f0100f8b <cprintf>
f0111b22:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0111b25:	83 ec 08             	sub    $0x8,%esp
f0111b28:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111b2b:	50                   	push   %eax
f0111b2c:	6a 01                	push   $0x1
f0111b2e:	e8 9d 06 ff ff       	call   f01021d0 <process_command>
f0111b33:	83 c4 10             	add    $0x10,%esp
f0111b36:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f0111b39:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0111b3d:	75 1b                	jne    f0111b5a <TestAutoCompleteCommand+0x166>
f0111b3f:	83 ec 08             	sub    $0x8,%esp
f0111b42:	6a 01                	push   $0x1
f0111b44:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111b47:	50                   	push   %eax
f0111b48:	e8 a6 fd ff ff       	call   f01118f3 <hasExpectedCommands>
f0111b4d:	83 c4 10             	add    $0x10,%esp
f0111b50:	85 c0                	test   %eax,%eax
f0111b52:	74 06                	je     f0111b5a <TestAutoCompleteCommand+0x166>
		eval += 15;
f0111b54:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111b58:	eb 10                	jmp    f0111b6a <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0111b5a:	83 ec 0c             	sub    $0xc,%esp
f0111b5d:	68 b0 8f 12 f0       	push   $0xf0128fb0
f0111b62:	e8 24 f4 fe ff       	call   f0100f8b <cprintf>
f0111b67:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f0111b6a:	83 ec 0c             	sub    $0xc,%esp
f0111b6d:	68 08 90 12 f0       	push   $0xf0129008
f0111b72:	e8 14 f4 fe ff       	call   f0100f8b <cprintf>
f0111b77:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f0111b7a:	c7 45 80 2e 90 12 f0 	movl   $0xf012902e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0111b81:	83 ec 08             	sub    $0x8,%esp
f0111b84:	8d 45 80             	lea    -0x80(%ebp),%eax
f0111b87:	50                   	push   %eax
f0111b88:	6a 01                	push   $0x1
f0111b8a:	e8 41 06 ff ff       	call   f01021d0 <process_command>
f0111b8f:	83 c4 10             	add    $0x10,%esp
f0111b92:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111b95:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0111b99:	75 0f                	jne    f0111baa <TestAutoCompleteCommand+0x1b6>
f0111b9b:	a1 64 f8 f1 f0       	mov    0xf0f1f864,%eax
f0111ba0:	85 c0                	test   %eax,%eax
f0111ba2:	75 06                	jne    f0111baa <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0111ba4:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111ba8:	eb 10                	jmp    f0111bba <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111baa:	83 ec 0c             	sub    $0xc,%esp
f0111bad:	68 34 90 12 f0       	push   $0xf0129034
f0111bb2:	e8 d4 f3 fe ff       	call   f0100f8b <cprintf>
f0111bb7:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0111bba:	83 ec 0c             	sub    $0xc,%esp
f0111bbd:	68 84 90 12 f0       	push   $0xf0129084
f0111bc2:	e8 c4 f3 fe ff       	call   f0100f8b <cprintf>
f0111bc7:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0111bca:	c7 85 7c ff ff ff a9 	movl   $0xf01290a9,-0x84(%ebp)
f0111bd1:	90 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111bd4:	83 ec 08             	sub    $0x8,%esp
f0111bd7:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f0111bdd:	50                   	push   %eax
f0111bde:	6a 01                	push   $0x1
f0111be0:	e8 eb 05 ff ff       	call   f01021d0 <process_command>
f0111be5:	83 c4 10             	add    $0x10,%esp
f0111be8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f0111beb:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111bef:	75 30                	jne    f0111c21 <TestAutoCompleteCommand+0x22d>
f0111bf1:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111bf4:	bb 80 93 12 f0       	mov    $0xf0129380,%ebx
f0111bf9:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111bfe:	89 c7                	mov    %eax,%edi
f0111c00:	89 de                	mov    %ebx,%esi
f0111c02:	89 d1                	mov    %edx,%ecx
f0111c04:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111c06:	83 ec 08             	sub    $0x8,%esp
f0111c09:	6a 0c                	push   $0xc
f0111c0b:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111c0e:	50                   	push   %eax
f0111c0f:	e8 df fc ff ff       	call   f01118f3 <hasExpectedCommands>
f0111c14:	83 c4 10             	add    $0x10,%esp
f0111c17:	85 c0                	test   %eax,%eax
f0111c19:	74 06                	je     f0111c21 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f0111c1b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111c1f:	eb 10                	jmp    f0111c31 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111c21:	83 ec 0c             	sub    $0xc,%esp
f0111c24:	68 ac 90 12 f0       	push   $0xf01290ac
f0111c29:	e8 5d f3 fe ff       	call   f0100f8b <cprintf>
f0111c2e:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111c31:	83 ec 0c             	sub    $0xc,%esp
f0111c34:	68 04 91 12 f0       	push   $0xf0129104
f0111c39:	e8 4d f3 fe ff       	call   f0100f8b <cprintf>
f0111c3e:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0111c41:	c7 85 78 ff ff ff 29 	movl   $0xf0129129,-0x88(%ebp)
f0111c48:	91 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0111c4b:	83 ec 08             	sub    $0x8,%esp
f0111c4e:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0111c54:	50                   	push   %eax
f0111c55:	6a 01                	push   $0x1
f0111c57:	e8 74 05 ff ff       	call   f01021d0 <process_command>
f0111c5c:	83 c4 10             	add    $0x10,%esp
f0111c5f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0111c62:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111c66:	75 30                	jne    f0111c98 <TestAutoCompleteCommand+0x2a4>
f0111c68:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111c6b:	bb c8 93 12 f0       	mov    $0xf01293c8,%ebx
f0111c70:	ba 05 00 00 00       	mov    $0x5,%edx
f0111c75:	89 c7                	mov    %eax,%edi
f0111c77:	89 de                	mov    %ebx,%esi
f0111c79:	89 d1                	mov    %edx,%ecx
f0111c7b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111c7d:	83 ec 08             	sub    $0x8,%esp
f0111c80:	6a 05                	push   $0x5
f0111c82:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111c85:	50                   	push   %eax
f0111c86:	e8 68 fc ff ff       	call   f01118f3 <hasExpectedCommands>
f0111c8b:	83 c4 10             	add    $0x10,%esp
f0111c8e:	85 c0                	test   %eax,%eax
f0111c90:	74 06                	je     f0111c98 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0111c92:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111c96:	eb 10                	jmp    f0111ca8 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111c98:	83 ec 0c             	sub    $0xc,%esp
f0111c9b:	68 2c 91 12 f0       	push   $0xf012912c
f0111ca0:	e8 e6 f2 fe ff       	call   f0100f8b <cprintf>
f0111ca5:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111ca8:	83 ec 0c             	sub    $0xc,%esp
f0111cab:	68 84 91 12 f0       	push   $0xf0129184
f0111cb0:	e8 d6 f2 fe ff       	call   f0100f8b <cprintf>
f0111cb5:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111cb8:	c7 85 70 ff ff ff b0 	movl   $0xf01291b0,-0x90(%ebp)
f0111cbf:	91 12 f0 
f0111cc2:	c7 85 74 ff ff ff b5 	movl   $0xf01291b5,-0x8c(%ebp)
f0111cc9:	91 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111ccc:	83 ec 08             	sub    $0x8,%esp
f0111ccf:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111cd5:	50                   	push   %eax
f0111cd6:	6a 02                	push   $0x2
f0111cd8:	e8 f3 04 ff ff       	call   f01021d0 <process_command>
f0111cdd:	83 c4 10             	add    $0x10,%esp
f0111ce0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111ce3:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0111ce9:	83 ec 0c             	sub    $0xc,%esp
f0111cec:	50                   	push   %eax
f0111ced:	e8 b2 fc ff ff       	call   f01119a4 <getIndexOfCommand>
f0111cf2:	83 c4 10             	add    $0x10,%esp
f0111cf5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111cf8:	75 0f                	jne    f0111d09 <TestAutoCompleteCommand+0x315>
f0111cfa:	a1 58 f8 f1 f0       	mov    0xf0f1f858,%eax
f0111cff:	85 c0                	test   %eax,%eax
f0111d01:	75 06                	jne    f0111d09 <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111d03:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111d07:	eb 10                	jmp    f0111d19 <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111d09:	83 ec 0c             	sub    $0xc,%esp
f0111d0c:	68 bc 91 12 f0       	push   $0xf01291bc
f0111d11:	e8 75 f2 fe ff       	call   f0100f8b <cprintf>
f0111d16:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0111d19:	83 ec 0c             	sub    $0xc,%esp
f0111d1c:	68 0c 92 12 f0       	push   $0xf012920c
f0111d21:	e8 65 f2 fe ff       	call   f0100f8b <cprintf>
f0111d26:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0111d29:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111d2f:	bb f0 93 12 f0       	mov    $0xf01293f0,%ebx
f0111d34:	ba 03 00 00 00       	mov    $0x3,%edx
f0111d39:	89 c7                	mov    %eax,%edi
f0111d3b:	89 de                	mov    %ebx,%esi
f0111d3d:	89 d1                	mov    %edx,%ecx
f0111d3f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0111d41:	83 ec 08             	sub    $0x8,%esp
f0111d44:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111d4a:	50                   	push   %eax
f0111d4b:	6a 03                	push   $0x3
f0111d4d:	e8 7e 04 ff ff       	call   f01021d0 <process_command>
f0111d52:	83 c4 10             	add    $0x10,%esp
f0111d55:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0111d58:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0111d5e:	83 ec 0c             	sub    $0xc,%esp
f0111d61:	50                   	push   %eax
f0111d62:	e8 3d fc ff ff       	call   f01119a4 <getIndexOfCommand>
f0111d67:	83 c4 10             	add    $0x10,%esp
f0111d6a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111d6d:	75 0f                	jne    f0111d7e <TestAutoCompleteCommand+0x38a>
f0111d6f:	a1 58 f8 f1 f0       	mov    0xf0f1f858,%eax
f0111d74:	85 c0                	test   %eax,%eax
f0111d76:	75 06                	jne    f0111d7e <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0111d78:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111d7c:	eb 10                	jmp    f0111d8e <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111d7e:	83 ec 0c             	sub    $0xc,%esp
f0111d81:	68 40 92 12 f0       	push   $0xf0129240
f0111d86:	e8 00 f2 fe ff       	call   f0100f8b <cprintf>
f0111d8b:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0111d8e:	83 ec 08             	sub    $0x8,%esp
f0111d91:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111d94:	68 90 92 12 f0       	push   $0xf0129290
f0111d99:	e8 ed f1 fe ff       	call   f0100f8b <cprintf>
f0111d9e:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111da1:	83 ec 0c             	sub    $0xc,%esp
f0111da4:	68 c0 92 12 f0       	push   $0xf01292c0
f0111da9:	e8 dd f1 fe ff       	call   f0100f8b <cprintf>
f0111dae:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111db1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111db6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111db9:	5b                   	pop    %ebx
f0111dba:	5e                   	pop    %esi
f0111dbb:	5f                   	pop    %edi
f0111dbc:	5d                   	pop    %ebp
f0111dbd:	c3                   	ret    

f0111dbe <test_str2lower_function>:

int test_str2lower_function()
{
f0111dbe:	55                   	push   %ebp
f0111dbf:	89 e5                	mov    %esp,%ebp
f0111dc1:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111dc7:	83 ec 0c             	sub    $0xc,%esp
f0111dca:	68 fc 93 12 f0       	push   $0xf01293fc
f0111dcf:	e8 b7 f1 fe ff       	call   f0100f8b <cprintf>
f0111dd4:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111dd7:	83 ec 0c             	sub    $0xc,%esp
f0111dda:	68 1d 94 12 f0       	push   $0xf012941d
f0111ddf:	e8 a7 f1 fe ff       	call   f0100f8b <cprintf>
f0111de4:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111de7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111dee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111df5:	c7 45 ec 37 94 12 f0 	movl   $0xf0129437,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111dfc:	83 ec 08             	sub    $0x8,%esp
f0111dff:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e02:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111e08:	50                   	push   %eax
f0111e09:	e8 3d e8 00 00       	call   f012064b <str2lower>
f0111e0e:	83 c4 10             	add    $0x10,%esp
f0111e11:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111e14:	83 ec 0c             	sub    $0xc,%esp
f0111e17:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e1a:	e8 43 e1 00 00       	call   f011ff62 <strlen>
f0111e1f:	83 c4 10             	add    $0x10,%esp
f0111e22:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111e25:	83 ec 08             	sub    $0x8,%esp
f0111e28:	68 42 94 12 f0       	push   $0xf0129442
f0111e2d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e30:	e8 39 e2 00 00       	call   f012006e <strcmp>
f0111e35:	83 c4 10             	add    $0x10,%esp
f0111e38:	85 c0                	test   %eax,%eax
f0111e3a:	75 13                	jne    f0111e4f <test_str2lower_function+0x91>
f0111e3c:	83 ec 0c             	sub    $0xc,%esp
f0111e3f:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e42:	e8 1b e1 00 00       	call   f011ff62 <strlen>
f0111e47:	83 c4 10             	add    $0x10,%esp
f0111e4a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e4d:	74 15                	je     f0111e64 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111e4f:	83 ec 08             	sub    $0x8,%esp
f0111e52:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e55:	68 50 94 12 f0       	push   $0xf0129450
f0111e5a:	e8 2c f1 fe ff       	call   f0100f8b <cprintf>
f0111e5f:	83 c4 10             	add    $0x10,%esp
f0111e62:	eb 04                	jmp    f0111e68 <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111e64:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111e68:	c7 45 e0 b2 94 12 f0 	movl   $0xf01294b2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111e6f:	83 ec 08             	sub    $0x8,%esp
f0111e72:	ff 75 e0             	pushl  -0x20(%ebp)
f0111e75:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111e7b:	50                   	push   %eax
f0111e7c:	e8 ca e7 00 00       	call   f012064b <str2lower>
f0111e81:	83 c4 10             	add    $0x10,%esp
f0111e84:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111e87:	83 ec 0c             	sub    $0xc,%esp
f0111e8a:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e8d:	e8 d0 e0 00 00       	call   f011ff62 <strlen>
f0111e92:	83 c4 10             	add    $0x10,%esp
f0111e95:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111e98:	83 ec 08             	sub    $0x8,%esp
f0111e9b:	68 b2 94 12 f0       	push   $0xf01294b2
f0111ea0:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ea3:	e8 c6 e1 00 00       	call   f012006e <strcmp>
f0111ea8:	83 c4 10             	add    $0x10,%esp
f0111eab:	85 c0                	test   %eax,%eax
f0111ead:	75 13                	jne    f0111ec2 <test_str2lower_function+0x104>
f0111eaf:	83 ec 0c             	sub    $0xc,%esp
f0111eb2:	ff 75 e0             	pushl  -0x20(%ebp)
f0111eb5:	e8 a8 e0 00 00       	call   f011ff62 <strlen>
f0111eba:	83 c4 10             	add    $0x10,%esp
f0111ebd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111ec0:	74 15                	je     f0111ed7 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111ec2:	83 ec 08             	sub    $0x8,%esp
f0111ec5:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ec8:	68 b4 94 12 f0       	push   $0xf01294b4
f0111ecd:	e8 b9 f0 fe ff       	call   f0100f8b <cprintf>
f0111ed2:	83 c4 10             	add    $0x10,%esp
f0111ed5:	eb 04                	jmp    f0111edb <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111ed7:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111edb:	c7 45 dc 0c 95 12 f0 	movl   $0xf012950c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111ee2:	83 ec 08             	sub    $0x8,%esp
f0111ee5:	ff 75 dc             	pushl  -0x24(%ebp)
f0111ee8:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111eee:	50                   	push   %eax
f0111eef:	e8 57 e7 00 00       	call   f012064b <str2lower>
f0111ef4:	83 c4 10             	add    $0x10,%esp
f0111ef7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111efa:	83 ec 0c             	sub    $0xc,%esp
f0111efd:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f00:	e8 5d e0 00 00       	call   f011ff62 <strlen>
f0111f05:	83 c4 10             	add    $0x10,%esp
f0111f08:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111f0b:	83 ec 08             	sub    $0x8,%esp
f0111f0e:	68 0c 95 12 f0       	push   $0xf012950c
f0111f13:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f16:	e8 53 e1 00 00       	call   f012006e <strcmp>
f0111f1b:	83 c4 10             	add    $0x10,%esp
f0111f1e:	85 c0                	test   %eax,%eax
f0111f20:	75 13                	jne    f0111f35 <test_str2lower_function+0x177>
f0111f22:	83 ec 0c             	sub    $0xc,%esp
f0111f25:	ff 75 dc             	pushl  -0x24(%ebp)
f0111f28:	e8 35 e0 00 00       	call   f011ff62 <strlen>
f0111f2d:	83 c4 10             	add    $0x10,%esp
f0111f30:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f33:	74 15                	je     f0111f4a <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111f35:	83 ec 08             	sub    $0x8,%esp
f0111f38:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f3b:	68 18 95 12 f0       	push   $0xf0129518
f0111f40:	e8 46 f0 fe ff       	call   f0100f8b <cprintf>
f0111f45:	83 c4 10             	add    $0x10,%esp
f0111f48:	eb 04                	jmp    f0111f4e <test_str2lower_function+0x190>
	else
		eval += 15;
f0111f4a:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0111f4e:	c7 45 d8 7b 95 12 f0 	movl   $0xf012957b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0111f55:	83 ec 08             	sub    $0x8,%esp
f0111f58:	ff 75 d8             	pushl  -0x28(%ebp)
f0111f5b:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0111f61:	50                   	push   %eax
f0111f62:	e8 e4 e6 00 00       	call   f012064b <str2lower>
f0111f67:	83 c4 10             	add    $0x10,%esp
f0111f6a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111f6d:	83 ec 0c             	sub    $0xc,%esp
f0111f70:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f73:	e8 ea df 00 00       	call   f011ff62 <strlen>
f0111f78:	83 c4 10             	add    $0x10,%esp
f0111f7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111f7e:	83 ec 08             	sub    $0x8,%esp
f0111f81:	68 7b 95 12 f0       	push   $0xf012957b
f0111f86:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f89:	e8 e0 e0 00 00       	call   f012006e <strcmp>
f0111f8e:	83 c4 10             	add    $0x10,%esp
f0111f91:	85 c0                	test   %eax,%eax
f0111f93:	75 13                	jne    f0111fa8 <test_str2lower_function+0x1ea>
f0111f95:	83 ec 0c             	sub    $0xc,%esp
f0111f98:	ff 75 d8             	pushl  -0x28(%ebp)
f0111f9b:	e8 c2 df 00 00       	call   f011ff62 <strlen>
f0111fa0:	83 c4 10             	add    $0x10,%esp
f0111fa3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111fa6:	74 15                	je     f0111fbd <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111fa8:	83 ec 08             	sub    $0x8,%esp
f0111fab:	ff 75 e8             	pushl  -0x18(%ebp)
f0111fae:	68 88 95 12 f0       	push   $0xf0129588
f0111fb3:	e8 d3 ef fe ff       	call   f0100f8b <cprintf>
f0111fb8:	83 c4 10             	add    $0x10,%esp
f0111fbb:	eb 04                	jmp    f0111fc1 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111fbd:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111fc1:	c7 45 d4 ea 95 12 f0 	movl   $0xf01295ea,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111fc8:	83 ec 08             	sub    $0x8,%esp
f0111fcb:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111fce:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111fd4:	50                   	push   %eax
f0111fd5:	e8 71 e6 00 00       	call   f012064b <str2lower>
f0111fda:	83 c4 10             	add    $0x10,%esp
f0111fdd:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111fe0:	83 ec 0c             	sub    $0xc,%esp
f0111fe3:	ff 75 e8             	pushl  -0x18(%ebp)
f0111fe6:	e8 77 df 00 00       	call   f011ff62 <strlen>
f0111feb:	83 c4 10             	add    $0x10,%esp
f0111fee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111ff1:	83 ec 08             	sub    $0x8,%esp
f0111ff4:	68 00 96 12 f0       	push   $0xf0129600
f0111ff9:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ffc:	e8 6d e0 00 00       	call   f012006e <strcmp>
f0112001:	83 c4 10             	add    $0x10,%esp
f0112004:	85 c0                	test   %eax,%eax
f0112006:	75 13                	jne    f011201b <test_str2lower_function+0x25d>
f0112008:	83 ec 0c             	sub    $0xc,%esp
f011200b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011200e:	e8 4f df 00 00       	call   f011ff62 <strlen>
f0112013:	83 c4 10             	add    $0x10,%esp
f0112016:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112019:	74 15                	je     f0112030 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f011201b:	83 ec 08             	sub    $0x8,%esp
f011201e:	ff 75 e8             	pushl  -0x18(%ebp)
f0112021:	68 18 96 12 f0       	push   $0xf0129618
f0112026:	e8 60 ef fe ff       	call   f0100f8b <cprintf>
f011202b:	83 c4 10             	add    $0x10,%esp
f011202e:	eb 04                	jmp    f0112034 <test_str2lower_function+0x276>
	else
		eval += 15;
f0112030:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0112034:	c7 45 d0 85 96 12 f0 	movl   $0xf0129685,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f011203b:	83 ec 08             	sub    $0x8,%esp
f011203e:	ff 75 d0             	pushl  -0x30(%ebp)
f0112041:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0112047:	50                   	push   %eax
f0112048:	e8 fe e5 00 00       	call   f012064b <str2lower>
f011204d:	83 c4 10             	add    $0x10,%esp
f0112050:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0112053:	83 ec 0c             	sub    $0xc,%esp
f0112056:	ff 75 e8             	pushl  -0x18(%ebp)
f0112059:	e8 04 df 00 00       	call   f011ff62 <strlen>
f011205e:	83 c4 10             	add    $0x10,%esp
f0112061:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0112064:	83 ec 08             	sub    $0x8,%esp
f0112067:	68 91 96 12 f0       	push   $0xf0129691
f011206c:	ff 75 e8             	pushl  -0x18(%ebp)
f011206f:	e8 fa df 00 00       	call   f012006e <strcmp>
f0112074:	83 c4 10             	add    $0x10,%esp
f0112077:	85 c0                	test   %eax,%eax
f0112079:	75 13                	jne    f011208e <test_str2lower_function+0x2d0>
f011207b:	83 ec 0c             	sub    $0xc,%esp
f011207e:	ff 75 d0             	pushl  -0x30(%ebp)
f0112081:	e8 dc de 00 00       	call   f011ff62 <strlen>
f0112086:	83 c4 10             	add    $0x10,%esp
f0112089:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011208c:	74 15                	je     f01120a3 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f011208e:	83 ec 08             	sub    $0x8,%esp
f0112091:	ff 75 e8             	pushl  -0x18(%ebp)
f0112094:	68 a0 96 12 f0       	push   $0xf01296a0
f0112099:	e8 ed ee fe ff       	call   f0100f8b <cprintf>
f011209e:	83 c4 10             	add    $0x10,%esp
f01120a1:	eb 04                	jmp    f01120a7 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f01120a3:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f01120a7:	c7 45 cc 03 97 12 f0 	movl   $0xf0129703,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f01120ae:	83 ec 08             	sub    $0x8,%esp
f01120b1:	ff 75 cc             	pushl  -0x34(%ebp)
f01120b4:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f01120ba:	50                   	push   %eax
f01120bb:	e8 8b e5 00 00       	call   f012064b <str2lower>
f01120c0:	83 c4 10             	add    $0x10,%esp
f01120c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01120c6:	83 ec 0c             	sub    $0xc,%esp
f01120c9:	ff 75 e8             	pushl  -0x18(%ebp)
f01120cc:	e8 91 de 00 00       	call   f011ff62 <strlen>
f01120d1:	83 c4 10             	add    $0x10,%esp
f01120d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f01120d7:	83 ec 08             	sub    $0x8,%esp
f01120da:	68 1e 97 12 f0       	push   $0xf012971e
f01120df:	ff 75 e8             	pushl  -0x18(%ebp)
f01120e2:	e8 87 df 00 00       	call   f012006e <strcmp>
f01120e7:	83 c4 10             	add    $0x10,%esp
f01120ea:	85 c0                	test   %eax,%eax
f01120ec:	75 13                	jne    f0112101 <test_str2lower_function+0x343>
f01120ee:	83 ec 0c             	sub    $0xc,%esp
f01120f1:	ff 75 cc             	pushl  -0x34(%ebp)
f01120f4:	e8 69 de 00 00       	call   f011ff62 <strlen>
f01120f9:	83 c4 10             	add    $0x10,%esp
f01120fc:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01120ff:	74 15                	je     f0112116 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0112101:	83 ec 08             	sub    $0x8,%esp
f0112104:	ff 75 e8             	pushl  -0x18(%ebp)
f0112107:	68 3c 97 12 f0       	push   $0xf012973c
f011210c:	e8 7a ee fe ff       	call   f0100f8b <cprintf>
f0112111:	83 c4 10             	add    $0x10,%esp
f0112114:	eb 04                	jmp    f011211a <test_str2lower_function+0x35c>
	else
		eval += 20;
f0112116:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f011211a:	83 ec 08             	sub    $0x8,%esp
f011211d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112120:	68 b0 97 12 f0       	push   $0xf01297b0
f0112125:	e8 61 ee fe ff       	call   f0100f8b <cprintf>
f011212a:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f011212d:	83 ec 0c             	sub    $0xc,%esp
f0112130:	68 c0 92 12 f0       	push   $0xf01292c0
f0112135:	e8 51 ee fe ff       	call   f0100f8b <cprintf>
f011213a:	83 c4 10             	add    $0x10,%esp
	return 0;
f011213d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112142:	c9                   	leave  
f0112143:	c3                   	ret    

f0112144 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0112144:	55                   	push   %ebp
f0112145:	89 e5                	mov    %esp,%ebp
f0112147:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f011214a:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0112151:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0112158:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011215f:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112164:	ff 75 ec             	pushl  -0x14(%ebp)
f0112167:	ff 75 f0             	pushl  -0x10(%ebp)
f011216a:	ff 75 f4             	pushl  -0xc(%ebp)
f011216d:	50                   	push   %eax
f011216e:	e8 36 7e ff ff       	call   f0109fa9 <pt_set_page_permissions>
f0112173:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112176:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011217b:	ff 75 ec             	pushl  -0x14(%ebp)
f011217e:	ff 75 f0             	pushl  -0x10(%ebp)
f0112181:	ff 75 f4             	pushl  -0xc(%ebp)
f0112184:	50                   	push   %eax
f0112185:	e8 74 4b 00 00       	call   f0116cfe <CP>
f011218a:	83 c4 10             	add    $0x10,%esp
f011218d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112190:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112194:	74 17                	je     f01121ad <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0112196:	83 ec 04             	sub    $0x4,%esp
f0112199:	68 e0 97 12 f0       	push   $0xf01297e0
f011219e:	68 23 01 00 00       	push   $0x123
f01121a3:	68 02 98 12 f0       	push   $0xf0129802
f01121a8:	e8 8c e1 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f01121ad:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f01121b4:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f01121bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121c2:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01121c7:	ff 75 ec             	pushl  -0x14(%ebp)
f01121ca:	ff 75 f0             	pushl  -0x10(%ebp)
f01121cd:	ff 75 f4             	pushl  -0xc(%ebp)
f01121d0:	50                   	push   %eax
f01121d1:	e8 d3 7d ff ff       	call   f0109fa9 <pt_set_page_permissions>
f01121d6:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121d9:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01121de:	ff 75 ec             	pushl  -0x14(%ebp)
f01121e1:	ff 75 f0             	pushl  -0x10(%ebp)
f01121e4:	ff 75 f4             	pushl  -0xc(%ebp)
f01121e7:	50                   	push   %eax
f01121e8:	e8 11 4b 00 00       	call   f0116cfe <CP>
f01121ed:	83 c4 10             	add    $0x10,%esp
f01121f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01121f3:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01121f7:	74 17                	je     f0112210 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f01121f9:	83 ec 04             	sub    $0x4,%esp
f01121fc:	68 20 98 12 f0       	push   $0xf0129820
f0112201:	68 2f 01 00 00       	push   $0x12f
f0112206:	68 02 98 12 f0       	push   $0xf0129802
f011220b:	e8 29 e1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0112210:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0112217:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f011221e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112225:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011222a:	ff 75 ec             	pushl  -0x14(%ebp)
f011222d:	ff 75 f0             	pushl  -0x10(%ebp)
f0112230:	ff 75 f4             	pushl  -0xc(%ebp)
f0112233:	50                   	push   %eax
f0112234:	e8 70 7d ff ff       	call   f0109fa9 <pt_set_page_permissions>
f0112239:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011223c:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112241:	ff 75 ec             	pushl  -0x14(%ebp)
f0112244:	ff 75 f0             	pushl  -0x10(%ebp)
f0112247:	ff 75 f4             	pushl  -0xc(%ebp)
f011224a:	50                   	push   %eax
f011224b:	e8 ae 4a 00 00       	call   f0116cfe <CP>
f0112250:	83 c4 10             	add    $0x10,%esp
f0112253:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112256:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011225a:	74 17                	je     f0112273 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f011225c:	83 ec 04             	sub    $0x4,%esp
f011225f:	68 44 98 12 f0       	push   $0xf0129844
f0112264:	68 3a 01 00 00       	push   $0x13a
f0112269:	68 02 98 12 f0       	push   $0xf0129802
f011226e:	e8 c6 e0 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0112273:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f011227a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0112281:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112288:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011228d:	ff 75 ec             	pushl  -0x14(%ebp)
f0112290:	ff 75 f0             	pushl  -0x10(%ebp)
f0112293:	ff 75 f4             	pushl  -0xc(%ebp)
f0112296:	50                   	push   %eax
f0112297:	e8 0d 7d ff ff       	call   f0109fa9 <pt_set_page_permissions>
f011229c:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011229f:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01122a4:	ff 75 ec             	pushl  -0x14(%ebp)
f01122a7:	ff 75 f0             	pushl  -0x10(%ebp)
f01122aa:	ff 75 f4             	pushl  -0xc(%ebp)
f01122ad:	50                   	push   %eax
f01122ae:	e8 4b 4a 00 00       	call   f0116cfe <CP>
f01122b3:	83 c4 10             	add    $0x10,%esp
f01122b6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01122b9:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01122bd:	74 17                	je     f01122d6 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f01122bf:	83 ec 04             	sub    $0x4,%esp
f01122c2:	68 68 98 12 f0       	push   $0xf0129868
f01122c7:	68 46 01 00 00       	push   $0x146
f01122cc:	68 02 98 12 f0       	push   $0xf0129802
f01122d1:	e8 63 e0 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f01122d6:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f01122dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f01122e4:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01122eb:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01122f0:	ff 75 ec             	pushl  -0x14(%ebp)
f01122f3:	ff 75 f0             	pushl  -0x10(%ebp)
f01122f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01122f9:	50                   	push   %eax
f01122fa:	e8 aa 7c ff ff       	call   f0109fa9 <pt_set_page_permissions>
f01122ff:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112302:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112307:	ff 75 ec             	pushl  -0x14(%ebp)
f011230a:	ff 75 f0             	pushl  -0x10(%ebp)
f011230d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112310:	50                   	push   %eax
f0112311:	e8 e8 49 00 00       	call   f0116cfe <CP>
f0112316:	83 c4 10             	add    $0x10,%esp
f0112319:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011231c:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112320:	74 17                	je     f0112339 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0112322:	83 ec 04             	sub    $0x4,%esp
f0112325:	68 8c 98 12 f0       	push   $0xf012988c
f011232a:	68 52 01 00 00       	push   $0x152
f011232f:	68 02 98 12 f0       	push   $0xf0129802
f0112334:	e8 00 e0 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0112339:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0112340:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0112347:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011234e:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112353:	ff 75 ec             	pushl  -0x14(%ebp)
f0112356:	ff 75 f0             	pushl  -0x10(%ebp)
f0112359:	ff 75 f4             	pushl  -0xc(%ebp)
f011235c:	50                   	push   %eax
f011235d:	e8 47 7c ff ff       	call   f0109fa9 <pt_set_page_permissions>
f0112362:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112365:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011236a:	ff 75 ec             	pushl  -0x14(%ebp)
f011236d:	ff 75 f0             	pushl  -0x10(%ebp)
f0112370:	ff 75 f4             	pushl  -0xc(%ebp)
f0112373:	50                   	push   %eax
f0112374:	e8 85 49 00 00       	call   f0116cfe <CP>
f0112379:	83 c4 10             	add    $0x10,%esp
f011237c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011237f:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112383:	74 17                	je     f011239c <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0112385:	83 ec 04             	sub    $0x4,%esp
f0112388:	68 b0 98 12 f0       	push   $0xf01298b0
f011238d:	68 5e 01 00 00       	push   $0x15e
f0112392:	68 02 98 12 f0       	push   $0xf0129802
f0112397:	e8 9d df fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f011239c:	83 ec 0c             	sub    $0xc,%esp
f011239f:	68 dc 98 12 f0       	push   $0xf01298dc
f01123a4:	e8 e2 eb fe ff       	call   f0100f8b <cprintf>
f01123a9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01123ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01123b1:	c9                   	leave  
f01123b2:	c3                   	ret    

f01123b3 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f01123b3:	55                   	push   %ebp
f01123b4:	89 e5                	mov    %esp,%ebp
f01123b6:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f01123b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f01123c0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f01123c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01123ce:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01123d3:	ff 75 ec             	pushl  -0x14(%ebp)
f01123d6:	ff 75 f0             	pushl  -0x10(%ebp)
f01123d9:	ff 75 f4             	pushl  -0xc(%ebp)
f01123dc:	50                   	push   %eax
f01123dd:	e8 c7 7b ff ff       	call   f0109fa9 <pt_set_page_permissions>
f01123e2:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f01123e5:	83 ec 04             	sub    $0x4,%esp
f01123e8:	68 2c 99 12 f0       	push   $0xf012992c
f01123ed:	68 6b 01 00 00       	push   $0x16b
f01123f2:	68 02 98 12 f0       	push   $0xf0129802
f01123f7:	e8 3d df fe ff       	call   f0100339 <_panic>

f01123fc <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f01123fc:	55                   	push   %ebp
f01123fd:	89 e5                	mov    %esp,%ebp
f01123ff:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0112402:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0112409:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011240e:	83 ec 08             	sub    $0x8,%esp
f0112411:	ff 75 f4             	pushl  -0xc(%ebp)
f0112414:	50                   	push   %eax
f0112415:	e8 53 7c ff ff       	call   f010a06d <pt_get_page_permissions>
f011241a:	83 c4 10             	add    $0x10,%esp
f011241d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0112420:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0112424:	74 17                	je     f011243d <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0112426:	83 ec 04             	sub    $0x4,%esp
f0112429:	68 c8 99 12 f0       	push   $0xf01299c8
f011242e:	68 79 01 00 00       	push   $0x179
f0112433:	68 02 98 12 f0       	push   $0xf0129802
f0112438:	e8 fc de fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f011243d:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112444:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112449:	83 ec 08             	sub    $0x8,%esp
f011244c:	ff 75 f4             	pushl  -0xc(%ebp)
f011244f:	50                   	push   %eax
f0112450:	e8 18 7c ff ff       	call   f010a06d <pt_get_page_permissions>
f0112455:	83 c4 10             	add    $0x10,%esp
f0112458:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f011245b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011245f:	74 17                	je     f0112478 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0112461:	83 ec 04             	sub    $0x4,%esp
f0112464:	68 ec 99 12 f0       	push   $0xf01299ec
f0112469:	68 81 01 00 00       	push   $0x181
f011246e:	68 02 98 12 f0       	push   $0xf0129802
f0112473:	e8 c1 de fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0112478:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011247f:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112484:	83 ec 08             	sub    $0x8,%esp
f0112487:	ff 75 f4             	pushl  -0xc(%ebp)
f011248a:	50                   	push   %eax
f011248b:	e8 dd 7b ff ff       	call   f010a06d <pt_get_page_permissions>
f0112490:	83 c4 10             	add    $0x10,%esp
f0112493:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112496:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f011249a:	74 17                	je     f01124b3 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f011249c:	83 ec 04             	sub    $0x4,%esp
f011249f:	68 10 9a 12 f0       	push   $0xf0129a10
f01124a4:	68 89 01 00 00       	push   $0x189
f01124a9:	68 02 98 12 f0       	push   $0xf0129802
f01124ae:	e8 86 de fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f01124b3:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01124ba:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01124bf:	83 ec 08             	sub    $0x8,%esp
f01124c2:	ff 75 f4             	pushl  -0xc(%ebp)
f01124c5:	50                   	push   %eax
f01124c6:	e8 a2 7b ff ff       	call   f010a06d <pt_get_page_permissions>
f01124cb:	83 c4 10             	add    $0x10,%esp
f01124ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f01124d1:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01124d5:	74 17                	je     f01124ee <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f01124d7:	83 ec 04             	sub    $0x4,%esp
f01124da:	68 34 9a 12 f0       	push   $0xf0129a34
f01124df:	68 90 01 00 00       	push   $0x190
f01124e4:	68 02 98 12 f0       	push   $0xf0129802
f01124e9:	e8 4b de fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f01124ee:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01124f5:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01124fa:	83 ec 08             	sub    $0x8,%esp
f01124fd:	ff 75 f4             	pushl  -0xc(%ebp)
f0112500:	50                   	push   %eax
f0112501:	e8 67 7b ff ff       	call   f010a06d <pt_get_page_permissions>
f0112506:	83 c4 10             	add    $0x10,%esp
f0112509:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f011250c:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0112510:	74 17                	je     f0112529 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0112512:	83 ec 04             	sub    $0x4,%esp
f0112515:	68 58 9a 12 f0       	push   $0xf0129a58
f011251a:	68 97 01 00 00       	push   $0x197
f011251f:	68 02 98 12 f0       	push   $0xf0129802
f0112524:	e8 10 de fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0112529:	83 ec 0c             	sub    $0xc,%esp
f011252c:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0112531:	e8 55 ea fe ff       	call   f0100f8b <cprintf>
f0112536:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112539:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011253e:	c9                   	leave  
f011253f:	c3                   	ret    

f0112540 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0112540:	55                   	push   %ebp
f0112541:	89 e5                	mov    %esp,%ebp
f0112543:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0112546:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011254d:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112552:	83 ec 08             	sub    $0x8,%esp
f0112555:	ff 75 f4             	pushl  -0xc(%ebp)
f0112558:	50                   	push   %eax
f0112559:	e8 58 7b ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f011255e:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0112561:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112566:	83 ec 08             	sub    $0x8,%esp
f0112569:	ff 75 f4             	pushl  -0xc(%ebp)
f011256c:	50                   	push   %eax
f011256d:	e8 e8 46 00 00       	call   f0116c5a <CE>
f0112572:	83 c4 10             	add    $0x10,%esp
f0112575:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112578:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011257c:	74 17                	je     f0112595 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f011257e:	83 ec 04             	sub    $0x4,%esp
f0112581:	68 c4 9a 12 f0       	push   $0xf0129ac4
f0112586:	68 a7 01 00 00       	push   $0x1a7
f011258b:	68 02 98 12 f0       	push   $0xf0129802
f0112590:	e8 a4 dd fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0112595:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011259c:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01125a1:	83 ec 08             	sub    $0x8,%esp
f01125a4:	ff 75 f4             	pushl  -0xc(%ebp)
f01125a7:	50                   	push   %eax
f01125a8:	e8 09 7b ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f01125ad:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01125b0:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01125b5:	83 ec 08             	sub    $0x8,%esp
f01125b8:	ff 75 f4             	pushl  -0xc(%ebp)
f01125bb:	50                   	push   %eax
f01125bc:	e8 99 46 00 00       	call   f0116c5a <CE>
f01125c1:	83 c4 10             	add    $0x10,%esp
f01125c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01125c7:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01125cb:	74 17                	je     f01125e4 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f01125cd:	83 ec 04             	sub    $0x4,%esp
f01125d0:	68 f0 9a 12 f0       	push   $0xf0129af0
f01125d5:	68 af 01 00 00       	push   $0x1af
f01125da:	68 02 98 12 f0       	push   $0xf0129802
f01125df:	e8 55 dd fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f01125e4:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01125eb:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01125f0:	83 ec 08             	sub    $0x8,%esp
f01125f3:	ff 75 f4             	pushl  -0xc(%ebp)
f01125f6:	50                   	push   %eax
f01125f7:	e8 ba 7a ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f01125fc:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01125ff:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112604:	83 ec 08             	sub    $0x8,%esp
f0112607:	ff 75 f4             	pushl  -0xc(%ebp)
f011260a:	50                   	push   %eax
f011260b:	e8 4a 46 00 00       	call   f0116c5a <CE>
f0112610:	83 c4 10             	add    $0x10,%esp
f0112613:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112616:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011261a:	74 17                	je     f0112633 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f011261c:	83 ec 04             	sub    $0x4,%esp
f011261f:	68 1c 9b 12 f0       	push   $0xf0129b1c
f0112624:	68 b7 01 00 00       	push   $0x1b7
f0112629:	68 02 98 12 f0       	push   $0xf0129802
f011262e:	e8 06 dd fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f0112633:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011263a:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011263f:	83 ec 08             	sub    $0x8,%esp
f0112642:	ff 75 f4             	pushl  -0xc(%ebp)
f0112645:	50                   	push   %eax
f0112646:	e8 6b 7a ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f011264b:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f011264e:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0112653:	83 ec 08             	sub    $0x8,%esp
f0112656:	ff 75 f4             	pushl  -0xc(%ebp)
f0112659:	50                   	push   %eax
f011265a:	e8 fb 45 00 00       	call   f0116c5a <CE>
f011265f:	83 c4 10             	add    $0x10,%esp
f0112662:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112665:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112669:	74 17                	je     f0112682 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f011266b:	83 ec 04             	sub    $0x4,%esp
f011266e:	68 48 9b 12 f0       	push   $0xf0129b48
f0112673:	68 bf 01 00 00       	push   $0x1bf
f0112678:	68 02 98 12 f0       	push   $0xf0129802
f011267d:	e8 b7 dc fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0112682:	83 ec 0c             	sub    $0xc,%esp
f0112685:	68 74 9b 12 f0       	push   $0xf0129b74
f011268a:	e8 fc e8 fe ff       	call   f0100f8b <cprintf>
f011268f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112692:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112697:	c9                   	leave  
f0112698:	c3                   	ret    

f0112699 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0112699:	55                   	push   %ebp
f011269a:	89 e5                	mov    %esp,%ebp
f011269c:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f011269f:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01126a6:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f01126ab:	83 ec 08             	sub    $0x8,%esp
f01126ae:	ff 75 f4             	pushl  -0xc(%ebp)
f01126b1:	50                   	push   %eax
f01126b2:	e8 ff 79 ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f01126b7:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f01126ba:	83 ec 04             	sub    $0x4,%esp
f01126bd:	68 c0 9b 12 f0       	push   $0xf0129bc0
f01126c2:	68 ca 01 00 00       	push   $0x1ca
f01126c7:	68 02 98 12 f0       	push   $0xf0129802
f01126cc:	e8 68 dc fe ff       	call   f0100339 <_panic>

f01126d1 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f01126d1:	55                   	push   %ebp
f01126d2:	89 e5                	mov    %esp,%ebp
f01126d4:	57                   	push   %edi
f01126d5:	56                   	push   %esi
f01126d6:	53                   	push   %ebx
f01126d7:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01126dd:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01126e3:	bb 04 9f 12 f0       	mov    $0xf0129f04,%ebx
f01126e8:	ba 0f 00 00 00       	mov    $0xf,%edx
f01126ed:	89 c7                	mov    %eax,%edi
f01126ef:	89 de                	mov    %ebx,%esi
f01126f1:	89 d1                	mov    %edx,%ecx
f01126f3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01126f5:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01126fb:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112700:	b0 00                	mov    $0x0,%al
f0112702:	89 d7                	mov    %edx,%edi
f0112704:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112706:	6a 00                	push   $0x0
f0112708:	6a 0a                	push   $0xa
f011270a:	6a 14                	push   $0x14
f011270c:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112712:	50                   	push   %eax
f0112713:	e8 8f 8b ff ff       	call   f010b2a7 <env_create>
f0112718:	83 c4 10             	add    $0x10,%esp
f011271b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011271e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112721:	8b 40 64             	mov    0x64(%eax),%eax
f0112724:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112727:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011272a:	8b 40 68             	mov    0x68(%eax),%eax
f011272d:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0112730:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112733:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112736:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f011273d:	75 70 20 
f0112740:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0112747:	00 00 00 
f011274a:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0112750:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112755:	b8 00 00 00 00       	mov    $0x0,%eax
f011275a:	89 d7                	mov    %edx,%edi
f011275c:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f011275e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112761:	8b 40 10             	mov    0x10(%eax),%eax
f0112764:	83 ec 08             	sub    $0x8,%esp
f0112767:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f011276d:	52                   	push   %edx
f011276e:	50                   	push   %eax
f011276f:	e8 94 dc 00 00       	call   f0120408 <ltostr>
f0112774:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112777:	83 ec 04             	sub    $0x4,%esp
f011277a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112780:	50                   	push   %eax
f0112781:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0112787:	50                   	push   %eax
f0112788:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f011278e:	50                   	push   %eax
f011278f:	e8 4d dd 00 00       	call   f01204e1 <strcconcat>
f0112794:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0112797:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f011279e:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f01127a5:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f01127ac:	83 ec 0c             	sub    $0xc,%esp
f01127af:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127b2:	e8 85 45 00 00       	call   f0116d3c <ClearUserSpace>
f01127b7:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f01127ba:	83 ec 04             	sub    $0x4,%esp
f01127bd:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01127c3:	50                   	push   %eax
f01127c4:	68 56 9c 12 f0       	push   $0xf0129c56
f01127c9:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01127cf:	50                   	push   %eax
f01127d0:	e8 0c dd 00 00       	call   f01204e1 <strcconcat>
f01127d5:	83 c4 10             	add    $0x10,%esp
f01127d8:	83 ec 0c             	sub    $0xc,%esp
f01127db:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01127e1:	50                   	push   %eax
f01127e2:	e8 14 f7 fe ff       	call   f0101efb <execute_command>
f01127e7:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f01127ea:	83 ec 04             	sub    $0x4,%esp
f01127ed:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01127f3:	50                   	push   %eax
f01127f4:	68 61 9c 12 f0       	push   $0xf0129c61
f01127f9:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01127ff:	50                   	push   %eax
f0112800:	e8 dc dc 00 00       	call   f01204e1 <strcconcat>
f0112805:	83 c4 10             	add    $0x10,%esp
f0112808:	83 ec 0c             	sub    $0xc,%esp
f011280b:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112811:	50                   	push   %eax
f0112812:	e8 e4 f6 fe ff       	call   f0101efb <execute_command>
f0112817:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f011281a:	83 ec 04             	sub    $0x4,%esp
f011281d:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112823:	50                   	push   %eax
f0112824:	68 6c 9c 12 f0       	push   $0xf0129c6c
f0112829:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011282f:	50                   	push   %eax
f0112830:	e8 ac dc 00 00       	call   f01204e1 <strcconcat>
f0112835:	83 c4 10             	add    $0x10,%esp
f0112838:	83 ec 0c             	sub    $0xc,%esp
f011283b:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112841:	50                   	push   %eax
f0112842:	e8 b4 f6 fe ff       	call   f0101efb <execute_command>
f0112847:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f011284a:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0112851:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112854:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0112857:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f011285e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112861:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0112864:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f011286b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011286e:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0112871:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112874:	83 ec 08             	sub    $0x8,%esp
f0112877:	50                   	push   %eax
f0112878:	ff 75 d4             	pushl  -0x2c(%ebp)
f011287b:	e8 9d 44 00 00       	call   f0116d1d <GP>
f0112880:	83 c4 10             	add    $0x10,%esp
f0112883:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0112886:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f011288d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0112894:	e8 af c3 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112899:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f011289c:	83 ec 0c             	sub    $0xc,%esp
f011289f:	68 78 9c 12 f0       	push   $0xf0129c78
f01128a4:	e8 e2 e6 fe ff       	call   f0100f8b <cprintf>
f01128a9:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f01128ac:	6a 03                	push   $0x3
f01128ae:	68 00 00 90 02       	push   $0x2900000
f01128b3:	68 00 00 80 02       	push   $0x2800000
f01128b8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01128bb:	e8 6a 85 ff ff       	call   f010ae2a <cut_paste_pages>
f01128c0:	83 c4 10             	add    $0x10,%esp
f01128c3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f01128c6:	e8 7d c3 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01128cb:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f01128ce:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f01128d5:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01128d9:	75 08                	jne    f01128e3 <test_cut_paste_pages+0x212>
f01128db:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01128de:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01128e1:	74 2b                	je     f011290e <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01128e3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01128e6:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01128e9:	83 ec 0c             	sub    $0xc,%esp
f01128ec:	50                   	push   %eax
f01128ed:	ff 75 b4             	pushl  -0x4c(%ebp)
f01128f0:	68 a8 9c 12 f0       	push   $0xf0129ca8
f01128f5:	68 04 02 00 00       	push   $0x204
f01128fa:	68 02 98 12 f0       	push   $0xf0129802
f01128ff:	e8 d2 db fe ff       	call   f01004d6 <_warn>
f0112904:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112907:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f011290e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112912:	74 04                	je     f0112918 <test_cut_paste_pages+0x247>
f0112914:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112918:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011291f:	83 ec 08             	sub    $0x8,%esp
f0112922:	6a 00                	push   $0x0
f0112924:	6a 01                	push   $0x1
f0112926:	6a 00                	push   $0x0
f0112928:	68 ff 0f 00 00       	push   $0xfff
f011292d:	ff 75 bc             	pushl  -0x44(%ebp)
f0112930:	6a 01                	push   $0x1
f0112932:	68 00 30 00 00       	push   $0x3000
f0112937:	68 00 00 90 02       	push   $0x2900000
f011293c:	68 00 00 80 02       	push   $0x2800000
f0112941:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112944:	e8 27 44 00 00       	call   f0116d70 <CCP>
f0112949:	83 c4 30             	add    $0x30,%esp
f011294c:	83 f8 01             	cmp    $0x1,%eax
f011294f:	74 21                	je     f0112972 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112951:	83 ec 04             	sub    $0x4,%esp
f0112954:	68 fc 9c 12 f0       	push   $0xf0129cfc
f0112959:	68 0c 02 00 00       	push   $0x20c
f011295e:	68 02 98 12 f0       	push   $0xf0129802
f0112963:	e8 6e db fe ff       	call   f01004d6 <_warn>
f0112968:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011296b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0112972:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112976:	74 04                	je     f011297c <test_cut_paste_pages+0x2ab>
f0112978:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f011297c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0112983:	83 ec 04             	sub    $0x4,%esp
f0112986:	6a 00                	push   $0x0
f0112988:	68 00 00 90 02       	push   $0x2900000
f011298d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112990:	e8 b7 41 00 00       	call   f0116b4c <CB>
f0112995:	83 c4 10             	add    $0x10,%esp
f0112998:	85 c0                	test   %eax,%eax
f011299a:	0f 84 f6 00 00 00    	je     f0112a96 <test_cut_paste_pages+0x3c5>
f01129a0:	83 ec 04             	sub    $0x4,%esp
f01129a3:	6a 00                	push   $0x0
f01129a5:	68 00 10 90 02       	push   $0x2901000
f01129aa:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129ad:	e8 9a 41 00 00       	call   f0116b4c <CB>
f01129b2:	83 c4 10             	add    $0x10,%esp
f01129b5:	85 c0                	test   %eax,%eax
f01129b7:	0f 84 d9 00 00 00    	je     f0112a96 <test_cut_paste_pages+0x3c5>
f01129bd:	83 ec 04             	sub    $0x4,%esp
f01129c0:	6a 00                	push   $0x0
f01129c2:	68 00 20 90 02       	push   $0x2902000
f01129c7:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129ca:	e8 7d 41 00 00       	call   f0116b4c <CB>
f01129cf:	83 c4 10             	add    $0x10,%esp
f01129d2:	85 c0                	test   %eax,%eax
f01129d4:	0f 84 bc 00 00 00    	je     f0112a96 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f01129da:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f01129e1:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f01129e8:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f01129ef:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01129f2:	8a 00                	mov    (%eax),%al
f01129f4:	3c 61                	cmp    $0x61,%al
f01129f6:	75 12                	jne    f0112a0a <test_cut_paste_pages+0x339>
f01129f8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01129fb:	8a 00                	mov    (%eax),%al
f01129fd:	3c 62                	cmp    $0x62,%al
f01129ff:	75 09                	jne    f0112a0a <test_cut_paste_pages+0x339>
f0112a01:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112a04:	8a 00                	mov    (%eax),%al
f0112a06:	3c 63                	cmp    $0x63,%al
f0112a08:	74 21                	je     f0112a2b <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112a0a:	83 ec 04             	sub    $0x4,%esp
f0112a0d:	68 48 9d 12 f0       	push   $0xf0129d48
f0112a12:	68 19 02 00 00       	push   $0x219
f0112a17:	68 02 98 12 f0       	push   $0xf0129802
f0112a1c:	e8 b5 da fe ff       	call   f01004d6 <_warn>
f0112a21:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112a24:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112a2b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112a2f:	74 04                	je     f0112a35 <test_cut_paste_pages+0x364>
f0112a31:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112a35:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0112a3c:	83 ec 04             	sub    $0x4,%esp
f0112a3f:	6a 01                	push   $0x1
f0112a41:	68 00 10 90 02       	push   $0x2901000
f0112a46:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a49:	e8 fe 40 00 00       	call   f0116b4c <CB>
f0112a4e:	83 c4 10             	add    $0x10,%esp
f0112a51:	85 c0                	test   %eax,%eax
f0112a53:	74 41                	je     f0112a96 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0112a55:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112a58:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0112a5b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112a5e:	8a 00                	mov    (%eax),%al
f0112a60:	3c 79                	cmp    $0x79,%al
f0112a62:	74 21                	je     f0112a85 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112a64:	83 ec 04             	sub    $0x4,%esp
f0112a67:	68 48 9d 12 f0       	push   $0xf0129d48
f0112a6c:	68 24 02 00 00       	push   $0x224
f0112a71:	68 02 98 12 f0       	push   $0xf0129802
f0112a76:	e8 5b da fe ff       	call   f01004d6 <_warn>
f0112a7b:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112a7e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112a85:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112a89:	74 04                	je     f0112a8f <test_cut_paste_pages+0x3be>
f0112a8b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112a8f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0112a96:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112a99:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0112a9c:	6a 02                	push   $0x2
f0112a9e:	68 00 f0 bf 02       	push   $0x2bff000
f0112aa3:	68 00 10 90 02       	push   $0x2901000
f0112aa8:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112aab:	e8 7a 83 ff ff       	call   f010ae2a <cut_paste_pages>
f0112ab0:	83 c4 10             	add    $0x10,%esp
f0112ab3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112ab6:	e8 8d c1 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112abb:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112abe:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112ac2:	75 0b                	jne    f0112acf <test_cut_paste_pages+0x3fe>
f0112ac4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112ac7:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112aca:	83 f8 01             	cmp    $0x1,%eax
f0112acd:	74 2b                	je     f0112afa <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112acf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112ad2:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112ad5:	83 ec 0c             	sub    $0xc,%esp
f0112ad8:	50                   	push   %eax
f0112ad9:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112adc:	68 a8 9c 12 f0       	push   $0xf0129ca8
f0112ae1:	68 35 02 00 00       	push   $0x235
f0112ae6:	68 02 98 12 f0       	push   $0xf0129802
f0112aeb:	e8 e6 d9 fe ff       	call   f01004d6 <_warn>
f0112af0:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112af3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112afa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112afe:	74 04                	je     f0112b04 <test_cut_paste_pages+0x433>
f0112b00:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112b04:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112b0b:	83 ec 08             	sub    $0x8,%esp
f0112b0e:	6a 00                	push   $0x0
f0112b10:	6a 01                	push   $0x1
f0112b12:	6a 00                	push   $0x0
f0112b14:	68 ff 0f 00 00       	push   $0xfff
f0112b19:	ff 75 bc             	pushl  -0x44(%ebp)
f0112b1c:	6a 01                	push   $0x1
f0112b1e:	68 00 20 00 00       	push   $0x2000
f0112b23:	68 00 f0 bf 02       	push   $0x2bff000
f0112b28:	68 00 10 90 02       	push   $0x2901000
f0112b2d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b30:	e8 3b 42 00 00       	call   f0116d70 <CCP>
f0112b35:	83 c4 30             	add    $0x30,%esp
f0112b38:	83 f8 01             	cmp    $0x1,%eax
f0112b3b:	74 21                	je     f0112b5e <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112b3d:	83 ec 04             	sub    $0x4,%esp
f0112b40:	68 fc 9c 12 f0       	push   $0xf0129cfc
f0112b45:	68 3d 02 00 00       	push   $0x23d
f0112b4a:	68 02 98 12 f0       	push   $0xf0129802
f0112b4f:	e8 82 d9 fe ff       	call   f01004d6 <_warn>
f0112b54:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112b57:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112b5e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b62:	74 04                	je     f0112b68 <test_cut_paste_pages+0x497>
f0112b64:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112b68:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0112b6f:	83 ec 04             	sub    $0x4,%esp
f0112b72:	6a 00                	push   $0x0
f0112b74:	68 ff f7 bf 02       	push   $0x2bff7ff
f0112b79:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b7c:	e8 cb 3f 00 00       	call   f0116b4c <CB>
f0112b81:	83 c4 10             	add    $0x10,%esp
f0112b84:	85 c0                	test   %eax,%eax
f0112b86:	74 6b                	je     f0112bf3 <test_cut_paste_pages+0x522>
f0112b88:	83 ec 04             	sub    $0x4,%esp
f0112b8b:	6a 00                	push   $0x0
f0112b8d:	68 ff 0f c0 02       	push   $0x2c00fff
f0112b92:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b95:	e8 b2 3f 00 00       	call   f0116b4c <CB>
f0112b9a:	83 c4 10             	add    $0x10,%esp
f0112b9d:	85 c0                	test   %eax,%eax
f0112b9f:	74 52                	je     f0112bf3 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112ba1:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0112ba8:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112baf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112bb2:	8a 00                	mov    (%eax),%al
f0112bb4:	3c 79                	cmp    $0x79,%al
f0112bb6:	75 09                	jne    f0112bc1 <test_cut_paste_pages+0x4f0>
f0112bb8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112bbb:	8a 00                	mov    (%eax),%al
f0112bbd:	3c 63                	cmp    $0x63,%al
f0112bbf:	74 21                	je     f0112be2 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112bc1:	83 ec 04             	sub    $0x4,%esp
f0112bc4:	68 48 9d 12 f0       	push   $0xf0129d48
f0112bc9:	68 49 02 00 00       	push   $0x249
f0112bce:	68 02 98 12 f0       	push   $0xf0129802
f0112bd3:	e8 fe d8 fe ff       	call   f01004d6 <_warn>
f0112bd8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112bdb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112be2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112be6:	74 04                	je     f0112bec <test_cut_paste_pages+0x51b>
f0112be8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112bec:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112bf3:	83 ec 0c             	sub    $0xc,%esp
f0112bf6:	68 81 9d 12 f0       	push   $0xf0129d81
f0112bfb:	e8 8b e3 fe ff       	call   f0100f8b <cprintf>
f0112c00:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112c03:	83 ec 0c             	sub    $0xc,%esp
f0112c06:	68 90 9d 12 f0       	push   $0xf0129d90
f0112c0b:	e8 7b e3 fe ff       	call   f0100f8b <cprintf>
f0112c10:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112c13:	83 ec 04             	sub    $0x4,%esp
f0112c16:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112c1c:	50                   	push   %eax
f0112c1d:	68 b9 9d 12 f0       	push   $0xf0129db9
f0112c22:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112c28:	50                   	push   %eax
f0112c29:	e8 b3 d8 00 00       	call   f01204e1 <strcconcat>
f0112c2e:	83 c4 10             	add    $0x10,%esp
f0112c31:	83 ec 0c             	sub    $0xc,%esp
f0112c34:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112c3a:	50                   	push   %eax
f0112c3b:	e8 bb f2 fe ff       	call   f0101efb <execute_command>
f0112c40:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0112c43:	83 ec 04             	sub    $0x4,%esp
f0112c46:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112c4c:	50                   	push   %eax
f0112c4d:	68 c4 9d 12 f0       	push   $0xf0129dc4
f0112c52:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112c58:	50                   	push   %eax
f0112c59:	e8 83 d8 00 00       	call   f01204e1 <strcconcat>
f0112c5e:	83 c4 10             	add    $0x10,%esp
f0112c61:	83 ec 0c             	sub    $0xc,%esp
f0112c64:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112c6a:	50                   	push   %eax
f0112c6b:	e8 8b f2 fe ff       	call   f0101efb <execute_command>
f0112c70:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0112c73:	83 ec 04             	sub    $0x4,%esp
f0112c76:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112c7c:	50                   	push   %eax
f0112c7d:	68 cf 9d 12 f0       	push   $0xf0129dcf
f0112c82:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112c88:	50                   	push   %eax
f0112c89:	e8 53 d8 00 00       	call   f01204e1 <strcconcat>
f0112c8e:	83 c4 10             	add    $0x10,%esp
f0112c91:	83 ec 0c             	sub    $0xc,%esp
f0112c94:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112c9a:	50                   	push   %eax
f0112c9b:	e8 5b f2 fe ff       	call   f0101efb <execute_command>
f0112ca0:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112ca3:	83 ec 04             	sub    $0x4,%esp
f0112ca6:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112cac:	50                   	push   %eax
f0112cad:	68 da 9d 12 f0       	push   $0xf0129dda
f0112cb2:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112cb8:	50                   	push   %eax
f0112cb9:	e8 23 d8 00 00       	call   f01204e1 <strcconcat>
f0112cbe:	83 c4 10             	add    $0x10,%esp
f0112cc1:	83 ec 0c             	sub    $0xc,%esp
f0112cc4:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112cca:	50                   	push   %eax
f0112ccb:	e8 2b f2 fe ff       	call   f0101efb <execute_command>
f0112cd0:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112cd3:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0112cda:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112cdd:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112ce0:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112ce7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112cea:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112ced:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112cf4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112cf7:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0112cfa:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112d01:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112d04:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112d07:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112d0e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112d11:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112d14:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0112d1b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112d1e:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112d21:	83 ec 08             	sub    $0x8,%esp
f0112d24:	68 00 00 c0 01       	push   $0x1c00000
f0112d29:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d2c:	e8 ec 3f 00 00       	call   f0116d1d <GP>
f0112d31:	83 c4 10             	add    $0x10,%esp
f0112d34:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0112d37:	83 ec 08             	sub    $0x8,%esp
f0112d3a:	68 00 00 40 01       	push   $0x1400000
f0112d3f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d42:	e8 d6 3f 00 00       	call   f0116d1d <GP>
f0112d47:	83 c4 10             	add    $0x10,%esp
f0112d4a:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0112d4d:	e8 f6 be ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112d52:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0112d55:	6a 01                	push   $0x1
f0112d57:	68 00 00 40 01       	push   $0x1400000
f0112d5c:	68 00 00 c0 01       	push   $0x1c00000
f0112d61:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d64:	e8 c1 80 ff ff       	call   f010ae2a <cut_paste_pages>
f0112d69:	83 c4 10             	add    $0x10,%esp
f0112d6c:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112d6f:	e8 d4 be ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112d74:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112d77:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112d7b:	75 08                	jne    f0112d85 <test_cut_paste_pages+0x6b4>
f0112d7d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112d80:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112d83:	74 2b                	je     f0112db0 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112d85:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112d88:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112d8b:	83 ec 0c             	sub    $0xc,%esp
f0112d8e:	50                   	push   %eax
f0112d8f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112d92:	68 e8 9d 12 f0       	push   $0xf0129de8
f0112d97:	68 6c 02 00 00       	push   $0x26c
f0112d9c:	68 02 98 12 f0       	push   $0xf0129802
f0112da1:	e8 30 d7 fe ff       	call   f01004d6 <_warn>
f0112da6:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112da9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112db0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112db4:	74 04                	je     f0112dba <test_cut_paste_pages+0x6e9>
f0112db6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112dba:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112dc1:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112dc8:	83 ec 08             	sub    $0x8,%esp
f0112dcb:	6a 00                	push   $0x0
f0112dcd:	68 ff 0f 00 00       	push   $0xfff
f0112dd2:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112dd5:	68 ff 0f 00 00       	push   $0xfff
f0112dda:	ff 75 a0             	pushl  -0x60(%ebp)
f0112ddd:	6a 01                	push   $0x1
f0112ddf:	68 00 10 00 00       	push   $0x1000
f0112de4:	68 00 00 40 01       	push   $0x1400000
f0112de9:	68 00 00 c0 01       	push   $0x1c00000
f0112dee:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112df1:	e8 7a 3f 00 00       	call   f0116d70 <CCP>
f0112df6:	83 c4 30             	add    $0x30,%esp
f0112df9:	83 f8 01             	cmp    $0x1,%eax
f0112dfc:	74 28                	je     f0112e26 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112dfe:	83 ec 04             	sub    $0x4,%esp
f0112e01:	68 fc 9c 12 f0       	push   $0xf0129cfc
f0112e06:	68 75 02 00 00       	push   $0x275
f0112e0b:	68 02 98 12 f0       	push   $0xf0129802
f0112e10:	e8 c1 d6 fe ff       	call   f01004d6 <_warn>
f0112e15:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112e18:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112e1f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112e26:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112e2a:	74 04                	je     f0112e30 <test_cut_paste_pages+0x75f>
f0112e2c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112e30:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112e37:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112e3b:	0f 84 92 00 00 00    	je     f0112ed3 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0112e41:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112e48:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112e4f:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112e56:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112e5d:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112e64:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112e6b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112e6e:	8a 00                	mov    (%eax),%al
f0112e70:	3c 61                	cmp    $0x61,%al
f0112e72:	75 2d                	jne    f0112ea1 <test_cut_paste_pages+0x7d0>
f0112e74:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112e77:	8a 00                	mov    (%eax),%al
f0112e79:	3c 78                	cmp    $0x78,%al
f0112e7b:	75 24                	jne    f0112ea1 <test_cut_paste_pages+0x7d0>
f0112e7d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112e80:	8a 00                	mov    (%eax),%al
f0112e82:	3c 62                	cmp    $0x62,%al
f0112e84:	75 1b                	jne    f0112ea1 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112e86:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112e89:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112e8b:	3c 79                	cmp    $0x79,%al
f0112e8d:	75 12                	jne    f0112ea1 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112e8f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112e92:	8a 00                	mov    (%eax),%al
f0112e94:	3c 63                	cmp    $0x63,%al
f0112e96:	75 09                	jne    f0112ea1 <test_cut_paste_pages+0x7d0>
f0112e98:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112e9b:	8a 00                	mov    (%eax),%al
f0112e9d:	3c 7a                	cmp    $0x7a,%al
f0112e9f:	74 21                	je     f0112ec2 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112ea1:	83 ec 04             	sub    $0x4,%esp
f0112ea4:	68 48 9d 12 f0       	push   $0xf0129d48
f0112ea9:	68 87 02 00 00       	push   $0x287
f0112eae:	68 02 98 12 f0       	push   $0xf0129802
f0112eb3:	e8 1e d6 fe ff       	call   f01004d6 <_warn>
f0112eb8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112ebb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112ec2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ec6:	74 04                	je     f0112ecc <test_cut_paste_pages+0x7fb>
f0112ec8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112ecc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112ed3:	e8 70 bd ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112ed8:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0112edb:	6a 03                	push   $0x3
f0112edd:	68 00 f0 bf 01       	push   $0x1bff000
f0112ee2:	68 00 00 40 01       	push   $0x1400000
f0112ee7:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112eea:	e8 3b 7f ff ff       	call   f010ae2a <cut_paste_pages>
f0112eef:	83 c4 10             	add    $0x10,%esp
f0112ef2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112ef5:	e8 4e bd ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112efa:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112efd:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112f01:	75 08                	jne    f0112f0b <test_cut_paste_pages+0x83a>
f0112f03:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112f06:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112f09:	74 2b                	je     f0112f36 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112f0b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112f0e:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112f11:	83 ec 0c             	sub    $0xc,%esp
f0112f14:	50                   	push   %eax
f0112f15:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112f18:	68 e8 9d 12 f0       	push   $0xf0129de8
f0112f1d:	68 96 02 00 00       	push   $0x296
f0112f22:	68 02 98 12 f0       	push   $0xf0129802
f0112f27:	e8 aa d5 fe ff       	call   f01004d6 <_warn>
f0112f2c:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112f2f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112f36:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112f3a:	74 04                	je     f0112f40 <test_cut_paste_pages+0x86f>
f0112f3c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112f40:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0112f47:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112f4e:	83 ec 04             	sub    $0x4,%esp
f0112f51:	6a 00                	push   $0x0
f0112f53:	68 00 00 40 01       	push   $0x1400000
f0112f58:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f5b:	e8 ec 3b 00 00       	call   f0116b4c <CB>
f0112f60:	83 c4 10             	add    $0x10,%esp
f0112f63:	83 f8 01             	cmp    $0x1,%eax
f0112f66:	0f 85 80 00 00 00    	jne    f0112fec <test_cut_paste_pages+0x91b>
f0112f6c:	83 ec 04             	sub    $0x4,%esp
f0112f6f:	6a 00                	push   $0x0
f0112f71:	68 00 10 40 01       	push   $0x1401000
f0112f76:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f79:	e8 ce 3b 00 00       	call   f0116b4c <CB>
f0112f7e:	83 c4 10             	add    $0x10,%esp
f0112f81:	83 f8 01             	cmp    $0x1,%eax
f0112f84:	75 66                	jne    f0112fec <test_cut_paste_pages+0x91b>
f0112f86:	83 ec 04             	sub    $0x4,%esp
f0112f89:	6a 00                	push   $0x0
f0112f8b:	68 00 20 40 01       	push   $0x1402000
f0112f90:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f93:	e8 b4 3b 00 00       	call   f0116b4c <CB>
f0112f98:	83 c4 10             	add    $0x10,%esp
f0112f9b:	83 f8 01             	cmp    $0x1,%eax
f0112f9e:	75 4c                	jne    f0112fec <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112fa0:	83 ec 04             	sub    $0x4,%esp
f0112fa3:	6a 00                	push   $0x0
f0112fa5:	68 00 f0 bf 01       	push   $0x1bff000
f0112faa:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112fad:	e8 9a 3b 00 00       	call   f0116b4c <CB>
f0112fb2:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112fb5:	85 c0                	test   %eax,%eax
f0112fb7:	75 33                	jne    f0112fec <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112fb9:	83 ec 04             	sub    $0x4,%esp
f0112fbc:	6a 00                	push   $0x0
f0112fbe:	68 00 00 c0 01       	push   $0x1c00000
f0112fc3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112fc6:	e8 81 3b 00 00       	call   f0116b4c <CB>
f0112fcb:	83 c4 10             	add    $0x10,%esp
f0112fce:	83 f8 01             	cmp    $0x1,%eax
f0112fd1:	75 19                	jne    f0112fec <test_cut_paste_pages+0x91b>
f0112fd3:	83 ec 04             	sub    $0x4,%esp
f0112fd6:	6a 00                	push   $0x0
f0112fd8:	68 00 10 c0 01       	push   $0x1c01000
f0112fdd:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112fe0:	e8 67 3b 00 00       	call   f0116b4c <CB>
f0112fe5:	83 c4 10             	add    $0x10,%esp
f0112fe8:	85 c0                	test   %eax,%eax
f0112fea:	74 28                	je     f0113014 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0112fec:	83 ec 04             	sub    $0x4,%esp
f0112fef:	68 48 9e 12 f0       	push   $0xf0129e48
f0112ff4:	68 9f 02 00 00       	push   $0x29f
f0112ff9:	68 02 98 12 f0       	push   $0xf0129802
f0112ffe:	e8 d3 d4 fe ff       	call   f01004d6 <_warn>
f0113003:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0113006:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f011300d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0113014:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113018:	74 04                	je     f011301e <test_cut_paste_pages+0x94d>
f011301a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f011301e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0113025:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113029:	0f 84 99 00 00 00    	je     f01130c8 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f011302f:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0113036:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f011303d:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0113044:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f011304b:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0113052:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0113059:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011305c:	8a 00                	mov    (%eax),%al
f011305e:	3c 61                	cmp    $0x61,%al
f0113060:	75 2d                	jne    f011308f <test_cut_paste_pages+0x9be>
f0113062:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113065:	8a 00                	mov    (%eax),%al
f0113067:	3c 78                	cmp    $0x78,%al
f0113069:	75 24                	jne    f011308f <test_cut_paste_pages+0x9be>
f011306b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011306e:	8a 00                	mov    (%eax),%al
f0113070:	3c 62                	cmp    $0x62,%al
f0113072:	75 1b                	jne    f011308f <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113074:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113077:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0113079:	3c 79                	cmp    $0x79,%al
f011307b:	75 12                	jne    f011308f <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011307d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113080:	8a 00                	mov    (%eax),%al
f0113082:	3c 63                	cmp    $0x63,%al
f0113084:	75 09                	jne    f011308f <test_cut_paste_pages+0x9be>
f0113086:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113089:	8a 00                	mov    (%eax),%al
f011308b:	3c 7a                	cmp    $0x7a,%al
f011308d:	74 28                	je     f01130b7 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f011308f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0113096:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011309d:	83 ec 04             	sub    $0x4,%esp
f01130a0:	68 48 9d 12 f0       	push   $0xf0129d48
f01130a5:	68 b3 02 00 00       	push   $0x2b3
f01130aa:	68 02 98 12 f0       	push   $0xf0129802
f01130af:	e8 22 d4 fe ff       	call   f01004d6 <_warn>
f01130b4:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f01130b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01130bb:	74 04                	je     f01130c1 <test_cut_paste_pages+0x9f0>
f01130bd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01130c1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f01130c8:	83 ec 0c             	sub    $0xc,%esp
f01130cb:	68 81 9e 12 f0       	push   $0xf0129e81
f01130d0:	e8 b6 de fe ff       	call   f0100f8b <cprintf>
f01130d5:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f01130d8:	83 ec 08             	sub    $0x8,%esp
f01130db:	ff 75 e4             	pushl  -0x1c(%ebp)
f01130de:	68 90 9e 12 f0       	push   $0xf0129e90
f01130e3:	e8 a3 de fe ff       	call   f0100f8b <cprintf>
f01130e8:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01130eb:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01130ef:	75 10                	jne    f0113101 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f01130f1:	83 ec 0c             	sub    $0xc,%esp
f01130f4:	68 c4 9e 12 f0       	push   $0xf0129ec4
f01130f9:	e8 8d de fe ff       	call   f0100f8b <cprintf>
f01130fe:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113101:	a1 e4 f8 f1 f0       	mov    0xf0f1f8e4,%eax
f0113106:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113109:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011310c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011310f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113114:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113117:	5b                   	pop    %ebx
f0113118:	5e                   	pop    %esi
f0113119:	5f                   	pop    %edi
f011311a:	5d                   	pop    %ebp
f011311b:	c3                   	ret    

f011311c <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f011311c:	55                   	push   %ebp
f011311d:	89 e5                	mov    %esp,%ebp
f011311f:	57                   	push   %edi
f0113120:	56                   	push   %esi
f0113121:	53                   	push   %ebx
f0113122:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113128:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f011312e:	bb 04 9f 12 f0       	mov    $0xf0129f04,%ebx
f0113133:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113138:	89 c7                	mov    %eax,%edi
f011313a:	89 de                	mov    %ebx,%esi
f011313c:	89 d1                	mov    %edx,%ecx
f011313e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113140:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0113146:	b9 23 00 00 00       	mov    $0x23,%ecx
f011314b:	b0 00                	mov    $0x0,%al
f011314d:	89 d7                	mov    %edx,%edi
f011314f:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113151:	6a 00                	push   $0x0
f0113153:	6a 0a                	push   $0xa
f0113155:	6a 14                	push   $0x14
f0113157:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f011315d:	50                   	push   %eax
f011315e:	e8 44 81 ff ff       	call   f010b2a7 <env_create>
f0113163:	83 c4 10             	add    $0x10,%esp
f0113166:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113169:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011316c:	8b 40 64             	mov    0x64(%eax),%eax
f011316f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0113172:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113175:	8b 40 68             	mov    0x68(%eax),%eax
f0113178:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f011317e:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0113184:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0113187:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f011318e:	75 70 20 
f0113191:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0113198:	00 00 00 
f011319b:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01131a1:	b9 03 00 00 00       	mov    $0x3,%ecx
f01131a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01131ab:	89 d7                	mov    %edx,%edi
f01131ad:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01131af:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01131b2:	8b 40 10             	mov    0x10(%eax),%eax
f01131b5:	83 ec 08             	sub    $0x8,%esp
f01131b8:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f01131be:	52                   	push   %edx
f01131bf:	50                   	push   %eax
f01131c0:	e8 43 d2 00 00       	call   f0120408 <ltostr>
f01131c5:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01131c8:	83 ec 04             	sub    $0x4,%esp
f01131cb:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01131d1:	50                   	push   %eax
f01131d2:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f01131d8:	50                   	push   %eax
f01131d9:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f01131df:	50                   	push   %eax
f01131e0:	e8 fc d2 00 00       	call   f01204e1 <strcconcat>
f01131e5:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f01131e8:	83 ec 0c             	sub    $0xc,%esp
f01131eb:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131ee:	e8 49 3b 00 00       	call   f0116d3c <ClearUserSpace>
f01131f3:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f01131f6:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f01131fd:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0113204:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011320b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0113212:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113219:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0113220:	83 ec 0c             	sub    $0xc,%esp
f0113223:	68 38 9f 12 f0       	push   $0xf0129f38
f0113228:	e8 5e dd fe ff       	call   f0100f8b <cprintf>
f011322d:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0113230:	83 ec 04             	sub    $0x4,%esp
f0113233:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113239:	50                   	push   %eax
f011323a:	68 6e 9f 12 f0       	push   $0xf0129f6e
f011323f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113245:	50                   	push   %eax
f0113246:	e8 96 d2 00 00       	call   f01204e1 <strcconcat>
f011324b:	83 c4 10             	add    $0x10,%esp
f011324e:	83 ec 0c             	sub    $0xc,%esp
f0113251:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113257:	50                   	push   %eax
f0113258:	e8 9e ec fe ff       	call   f0101efb <execute_command>
f011325d:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0113260:	83 ec 04             	sub    $0x4,%esp
f0113263:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113269:	50                   	push   %eax
f011326a:	68 73 9f 12 f0       	push   $0xf0129f73
f011326f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113275:	50                   	push   %eax
f0113276:	e8 66 d2 00 00       	call   f01204e1 <strcconcat>
f011327b:	83 c4 10             	add    $0x10,%esp
f011327e:	83 ec 0c             	sub    $0xc,%esp
f0113281:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113287:	50                   	push   %eax
f0113288:	e8 6e ec fe ff       	call   f0101efb <execute_command>
f011328d:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0113290:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113296:	bb 79 a2 12 f0       	mov    $0xf012a279,%ebx
f011329b:	ba 0f 00 00 00       	mov    $0xf,%edx
f01132a0:	89 c7                	mov    %eax,%edi
f01132a2:	89 de                	mov    %ebx,%esi
f01132a4:	89 d1                	mov    %edx,%ecx
f01132a6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01132a8:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f01132ae:	b9 55 00 00 00       	mov    $0x55,%ecx
f01132b3:	b0 00                	mov    $0x0,%al
f01132b5:	89 d7                	mov    %edx,%edi
f01132b7:	f3 aa                	rep stos %al,%es:(%edi)
f01132b9:	83 ec 0c             	sub    $0xc,%esp
f01132bc:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01132c2:	50                   	push   %eax
f01132c3:	e8 33 ec fe ff       	call   f0101efb <execute_command>
f01132c8:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f01132cb:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01132d1:	bb dd a2 12 f0       	mov    $0xf012a2dd,%ebx
f01132d6:	ba 0f 00 00 00       	mov    $0xf,%edx
f01132db:	89 c7                	mov    %eax,%edi
f01132dd:	89 de                	mov    %ebx,%esi
f01132df:	89 d1                	mov    %edx,%ecx
f01132e1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01132e3:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01132e9:	b9 55 00 00 00       	mov    $0x55,%ecx
f01132ee:	b0 00                	mov    $0x0,%al
f01132f0:	89 d7                	mov    %edx,%edi
f01132f2:	f3 aa                	rep stos %al,%es:(%edi)
f01132f4:	83 ec 0c             	sub    $0xc,%esp
f01132f7:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01132fd:	50                   	push   %eax
f01132fe:	e8 f8 eb fe ff       	call   f0101efb <execute_command>
f0113303:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0113306:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011330c:	bb 41 a3 12 f0       	mov    $0xf012a341,%ebx
f0113311:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113316:	89 c7                	mov    %eax,%edi
f0113318:	89 de                	mov    %ebx,%esi
f011331a:	89 d1                	mov    %edx,%ecx
f011331c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011331e:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113324:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113329:	b0 00                	mov    $0x0,%al
f011332b:	89 d7                	mov    %edx,%edi
f011332d:	f3 aa                	rep stos %al,%es:(%edi)
f011332f:	83 ec 0c             	sub    $0xc,%esp
f0113332:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113338:	50                   	push   %eax
f0113339:	e8 bd eb fe ff       	call   f0101efb <execute_command>
f011333e:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0113341:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113347:	bb a5 a3 12 f0       	mov    $0xf012a3a5,%ebx
f011334c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113351:	89 c7                	mov    %eax,%edi
f0113353:	89 de                	mov    %ebx,%esi
f0113355:	89 d1                	mov    %edx,%ecx
f0113357:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113359:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f011335f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113364:	b0 00                	mov    $0x0,%al
f0113366:	89 d7                	mov    %edx,%edi
f0113368:	f3 aa                	rep stos %al,%es:(%edi)
f011336a:	83 ec 0c             	sub    $0xc,%esp
f011336d:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113373:	50                   	push   %eax
f0113374:	e8 82 eb fe ff       	call   f0101efb <execute_command>
f0113379:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f011337c:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113382:	bb 09 a4 12 f0       	mov    $0xf012a409,%ebx
f0113387:	ba 0f 00 00 00       	mov    $0xf,%edx
f011338c:	89 c7                	mov    %eax,%edi
f011338e:	89 de                	mov    %ebx,%esi
f0113390:	89 d1                	mov    %edx,%ecx
f0113392:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113394:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f011339a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011339f:	b0 00                	mov    $0x0,%al
f01133a1:	89 d7                	mov    %edx,%edi
f01133a3:	f3 aa                	rep stos %al,%es:(%edi)
f01133a5:	83 ec 0c             	sub    $0xc,%esp
f01133a8:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01133ae:	50                   	push   %eax
f01133af:	e8 47 eb fe ff       	call   f0101efb <execute_command>
f01133b4:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f01133b7:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01133bd:	bb 6d a4 12 f0       	mov    $0xf012a46d,%ebx
f01133c2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133c7:	89 c7                	mov    %eax,%edi
f01133c9:	89 de                	mov    %ebx,%esi
f01133cb:	89 d1                	mov    %edx,%ecx
f01133cd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133cf:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01133d5:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133da:	b0 00                	mov    $0x0,%al
f01133dc:	89 d7                	mov    %edx,%edi
f01133de:	f3 aa                	rep stos %al,%es:(%edi)
f01133e0:	83 ec 0c             	sub    $0xc,%esp
f01133e3:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01133e9:	50                   	push   %eax
f01133ea:	e8 0c eb fe ff       	call   f0101efb <execute_command>
f01133ef:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f01133f2:	83 ec 04             	sub    $0x4,%esp
f01133f5:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01133fb:	50                   	push   %eax
f01133fc:	68 7b 9f 12 f0       	push   $0xf0129f7b
f0113401:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113407:	50                   	push   %eax
f0113408:	e8 d4 d0 00 00       	call   f01204e1 <strcconcat>
f011340d:	83 c4 10             	add    $0x10,%esp
f0113410:	83 ec 0c             	sub    $0xc,%esp
f0113413:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113419:	50                   	push   %eax
f011341a:	e8 dc ea fe ff       	call   f0101efb <execute_command>
f011341f:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0113422:	83 ec 04             	sub    $0x4,%esp
f0113425:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011342b:	50                   	push   %eax
f011342c:	68 85 9f 12 f0       	push   $0xf0129f85
f0113431:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113437:	50                   	push   %eax
f0113438:	e8 a4 d0 00 00       	call   f01204e1 <strcconcat>
f011343d:	83 c4 10             	add    $0x10,%esp
f0113440:	83 ec 0c             	sub    $0xc,%esp
f0113443:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113449:	50                   	push   %eax
f011344a:	e8 ac ea fe ff       	call   f0101efb <execute_command>
f011344f:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0113452:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113458:	bb d1 a4 12 f0       	mov    $0xf012a4d1,%ebx
f011345d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113462:	89 c7                	mov    %eax,%edi
f0113464:	89 de                	mov    %ebx,%esi
f0113466:	89 d1                	mov    %edx,%ecx
f0113468:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011346a:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113470:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113475:	b0 00                	mov    $0x0,%al
f0113477:	89 d7                	mov    %edx,%edi
f0113479:	f3 aa                	rep stos %al,%es:(%edi)
f011347b:	83 ec 0c             	sub    $0xc,%esp
f011347e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113484:	50                   	push   %eax
f0113485:	e8 71 ea fe ff       	call   f0101efb <execute_command>
f011348a:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f011348d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113493:	bb 35 a5 12 f0       	mov    $0xf012a535,%ebx
f0113498:	ba 0f 00 00 00       	mov    $0xf,%edx
f011349d:	89 c7                	mov    %eax,%edi
f011349f:	89 de                	mov    %ebx,%esi
f01134a1:	89 d1                	mov    %edx,%ecx
f01134a3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134a5:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01134ab:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134b0:	b0 00                	mov    $0x0,%al
f01134b2:	89 d7                	mov    %edx,%edi
f01134b4:	f3 aa                	rep stos %al,%es:(%edi)
f01134b6:	83 ec 0c             	sub    $0xc,%esp
f01134b9:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01134bf:	50                   	push   %eax
f01134c0:	e8 36 ea fe ff       	call   f0101efb <execute_command>
f01134c5:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f01134c8:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01134ce:	bb 99 a5 12 f0       	mov    $0xf012a599,%ebx
f01134d3:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134d8:	89 c7                	mov    %eax,%edi
f01134da:	89 de                	mov    %ebx,%esi
f01134dc:	89 d1                	mov    %edx,%ecx
f01134de:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134e0:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01134e6:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134eb:	b0 00                	mov    $0x0,%al
f01134ed:	89 d7                	mov    %edx,%edi
f01134ef:	f3 aa                	rep stos %al,%es:(%edi)
f01134f1:	83 ec 0c             	sub    $0xc,%esp
f01134f4:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01134fa:	50                   	push   %eax
f01134fb:	e8 fb e9 fe ff       	call   f0101efb <execute_command>
f0113500:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0113503:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f011350a:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0113511:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0113518:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f011351f:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0113526:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f011352d:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0113534:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f011353b:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0113542:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0113549:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0113550:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0113557:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011355a:	8a 00                	mov    (%eax),%al
f011355c:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0113562:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113565:	8a 00                	mov    (%eax),%al
f0113567:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f011356d:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113570:	8a 00                	mov    (%eax),%al
f0113572:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113578:	e8 cb b6 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011357d:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0113580:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113583:	89 d0                	mov    %edx,%eax
f0113585:	01 c0                	add    %eax,%eax
f0113587:	01 d0                	add    %edx,%eax
f0113589:	01 c0                	add    %eax,%eax
f011358b:	50                   	push   %eax
f011358c:	68 00 00 10 00       	push   $0x100000
f0113591:	6a 00                	push   $0x0
f0113593:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113596:	e8 a9 78 ff ff       	call   f010ae44 <copy_paste_chunk>
f011359b:	83 c4 10             	add    $0x10,%esp
f011359e:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01135a1:	e8 a2 b6 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01135a6:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01135a9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01135b0:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f01135b4:	75 08                	jne    f01135be <test_copy_paste_chunk+0x4a2>
f01135b6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01135b9:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01135bc:	74 2b                	je     f01135e9 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01135be:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01135c1:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01135c4:	83 ec 0c             	sub    $0xc,%esp
f01135c7:	50                   	push   %eax
f01135c8:	ff 75 88             	pushl  -0x78(%ebp)
f01135cb:	68 94 9f 12 f0       	push   $0xf0129f94
f01135d0:	68 06 03 00 00       	push   $0x306
f01135d5:	68 02 98 12 f0       	push   $0xf0129802
f01135da:	e8 f7 ce fe ff       	call   f01004d6 <_warn>
f01135df:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01135e2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01135e9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01135ed:	74 04                	je     f01135f3 <test_copy_paste_chunk+0x4d7>
f01135ef:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01135f3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f01135fa:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01135fd:	8a 00                	mov    (%eax),%al
f01135ff:	3c 61                	cmp    $0x61,%al
f0113601:	75 75                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f0113603:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113606:	8a 00                	mov    (%eax),%al
f0113608:	3c 78                	cmp    $0x78,%al
f011360a:	75 6c                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f011360c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011360f:	8a 00                	mov    (%eax),%al
f0113611:	3c 62                	cmp    $0x62,%al
f0113613:	75 63                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f0113615:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113618:	8a 00                	mov    (%eax),%al
f011361a:	3c 79                	cmp    $0x79,%al
f011361c:	75 5a                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f011361e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113621:	8a 00                	mov    (%eax),%al
f0113623:	3c 63                	cmp    $0x63,%al
f0113625:	75 51                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f0113627:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011362a:	8a 00                	mov    (%eax),%al
f011362c:	3c 7a                	cmp    $0x7a,%al
f011362e:	75 48                	jne    f0113678 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0113630:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113633:	8a 00                	mov    (%eax),%al
f0113635:	3c 64                	cmp    $0x64,%al
f0113637:	75 3f                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f0113639:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011363c:	8a 10                	mov    (%eax),%dl
f011363e:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0113644:	38 c2                	cmp    %al,%dl
f0113646:	75 30                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f0113648:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011364b:	8a 00                	mov    (%eax),%al
f011364d:	3c 65                	cmp    $0x65,%al
f011364f:	75 27                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f0113651:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113654:	8a 10                	mov    (%eax),%dl
f0113656:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f011365c:	38 c2                	cmp    %al,%dl
f011365e:	75 18                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f0113660:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113663:	8a 00                	mov    (%eax),%al
f0113665:	3c 66                	cmp    $0x66,%al
f0113667:	75 0f                	jne    f0113678 <test_copy_paste_chunk+0x55c>
f0113669:	8b 45 90             	mov    -0x70(%ebp),%eax
f011366c:	8a 10                	mov    (%eax),%dl
f011366e:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113674:	38 c2                	cmp    %al,%dl
f0113676:	74 21                	je     f0113699 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113678:	83 ec 04             	sub    $0x4,%esp
f011367b:	68 f8 9f 12 f0       	push   $0xf0129ff8
f0113680:	68 0f 03 00 00       	push   $0x30f
f0113685:	68 02 98 12 f0       	push   $0xf0129802
f011368a:	e8 47 ce fe ff       	call   f01004d6 <_warn>
f011368f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113692:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113699:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011369d:	74 04                	je     f01136a3 <test_copy_paste_chunk+0x587>
f011369f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01136a3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f01136aa:	83 ec 0c             	sub    $0xc,%esp
f01136ad:	68 32 a0 12 f0       	push   $0xf012a032
f01136b2:	e8 d4 d8 fe ff       	call   f0100f8b <cprintf>
f01136b7:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f01136ba:	83 ec 0c             	sub    $0xc,%esp
f01136bd:	68 44 a0 12 f0       	push   $0xf012a044
f01136c2:	e8 c4 d8 fe ff       	call   f0100f8b <cprintf>
f01136c7:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f01136ca:	83 ec 04             	sub    $0x4,%esp
f01136cd:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01136d3:	50                   	push   %eax
f01136d4:	68 7a a0 12 f0       	push   $0xf012a07a
f01136d9:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01136df:	50                   	push   %eax
f01136e0:	e8 fc cd 00 00       	call   f01204e1 <strcconcat>
f01136e5:	83 c4 10             	add    $0x10,%esp
f01136e8:	83 ec 0c             	sub    $0xc,%esp
f01136eb:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01136f1:	50                   	push   %eax
f01136f2:	e8 04 e8 fe ff       	call   f0101efb <execute_command>
f01136f7:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f01136fa:	83 ec 04             	sub    $0x4,%esp
f01136fd:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113703:	50                   	push   %eax
f0113704:	68 84 a0 12 f0       	push   $0xf012a084
f0113709:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011370f:	50                   	push   %eax
f0113710:	e8 cc cd 00 00       	call   f01204e1 <strcconcat>
f0113715:	83 c4 10             	add    $0x10,%esp
f0113718:	83 ec 0c             	sub    $0xc,%esp
f011371b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113721:	50                   	push   %eax
f0113722:	e8 d4 e7 fe ff       	call   f0101efb <execute_command>
f0113727:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f011372a:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113730:	bb fd a5 12 f0       	mov    $0xf012a5fd,%ebx
f0113735:	ba 0f 00 00 00       	mov    $0xf,%edx
f011373a:	89 c7                	mov    %eax,%edi
f011373c:	89 de                	mov    %ebx,%esi
f011373e:	89 d1                	mov    %edx,%ecx
f0113740:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113742:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113748:	b9 55 00 00 00       	mov    $0x55,%ecx
f011374d:	b0 00                	mov    $0x0,%al
f011374f:	89 d7                	mov    %edx,%edi
f0113751:	f3 aa                	rep stos %al,%es:(%edi)
f0113753:	83 ec 0c             	sub    $0xc,%esp
f0113756:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f011375c:	50                   	push   %eax
f011375d:	e8 99 e7 fe ff       	call   f0101efb <execute_command>
f0113762:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0113765:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011376b:	bb 61 a6 12 f0       	mov    $0xf012a661,%ebx
f0113770:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113775:	89 c7                	mov    %eax,%edi
f0113777:	89 de                	mov    %ebx,%esi
f0113779:	89 d1                	mov    %edx,%ecx
f011377b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011377d:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0113783:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113788:	b0 00                	mov    $0x0,%al
f011378a:	89 d7                	mov    %edx,%edi
f011378c:	f3 aa                	rep stos %al,%es:(%edi)
f011378e:	83 ec 0c             	sub    $0xc,%esp
f0113791:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113797:	50                   	push   %eax
f0113798:	e8 5e e7 fe ff       	call   f0101efb <execute_command>
f011379d:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f01137a0:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01137a6:	bb c5 a6 12 f0       	mov    $0xf012a6c5,%ebx
f01137ab:	ba 0f 00 00 00       	mov    $0xf,%edx
f01137b0:	89 c7                	mov    %eax,%edi
f01137b2:	89 de                	mov    %ebx,%esi
f01137b4:	89 d1                	mov    %edx,%ecx
f01137b6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01137b8:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f01137be:	b9 55 00 00 00       	mov    $0x55,%ecx
f01137c3:	b0 00                	mov    $0x0,%al
f01137c5:	89 d7                	mov    %edx,%edi
f01137c7:	f3 aa                	rep stos %al,%es:(%edi)
f01137c9:	83 ec 0c             	sub    $0xc,%esp
f01137cc:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01137d2:	50                   	push   %eax
f01137d3:	e8 23 e7 fe ff       	call   f0101efb <execute_command>
f01137d8:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f01137db:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01137e1:	bb 29 a7 12 f0       	mov    $0xf012a729,%ebx
f01137e6:	ba 0f 00 00 00       	mov    $0xf,%edx
f01137eb:	89 c7                	mov    %eax,%edi
f01137ed:	89 de                	mov    %ebx,%esi
f01137ef:	89 d1                	mov    %edx,%ecx
f01137f1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01137f3:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01137f9:	b9 55 00 00 00       	mov    $0x55,%ecx
f01137fe:	b0 00                	mov    $0x0,%al
f0113800:	89 d7                	mov    %edx,%edi
f0113802:	f3 aa                	rep stos %al,%es:(%edi)
f0113804:	83 ec 0c             	sub    $0xc,%esp
f0113807:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011380d:	50                   	push   %eax
f011380e:	e8 e8 e6 fe ff       	call   f0101efb <execute_command>
f0113813:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0113816:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011381c:	bb 8d a7 12 f0       	mov    $0xf012a78d,%ebx
f0113821:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113826:	89 c7                	mov    %eax,%edi
f0113828:	89 de                	mov    %ebx,%esi
f011382a:	89 d1                	mov    %edx,%ecx
f011382c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011382e:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0113834:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113839:	b0 00                	mov    $0x0,%al
f011383b:	89 d7                	mov    %edx,%edi
f011383d:	f3 aa                	rep stos %al,%es:(%edi)
f011383f:	83 ec 0c             	sub    $0xc,%esp
f0113842:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113848:	50                   	push   %eax
f0113849:	e8 ad e6 fe ff       	call   f0101efb <execute_command>
f011384e:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0113851:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113857:	bb f1 a7 12 f0       	mov    $0xf012a7f1,%ebx
f011385c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113861:	89 c7                	mov    %eax,%edi
f0113863:	89 de                	mov    %ebx,%esi
f0113865:	89 d1                	mov    %edx,%ecx
f0113867:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113869:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f011386f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113874:	b0 00                	mov    $0x0,%al
f0113876:	89 d7                	mov    %edx,%edi
f0113878:	f3 aa                	rep stos %al,%es:(%edi)
f011387a:	83 ec 0c             	sub    $0xc,%esp
f011387d:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113883:	50                   	push   %eax
f0113884:	e8 72 e6 fe ff       	call   f0101efb <execute_command>
f0113889:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f011388c:	83 ec 04             	sub    $0x4,%esp
f011388f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113895:	50                   	push   %eax
f0113896:	68 8e a0 12 f0       	push   $0xf012a08e
f011389b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01138a1:	50                   	push   %eax
f01138a2:	e8 3a cc 00 00       	call   f01204e1 <strcconcat>
f01138a7:	83 c4 10             	add    $0x10,%esp
f01138aa:	83 ec 0c             	sub    $0xc,%esp
f01138ad:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01138b3:	50                   	push   %eax
f01138b4:	e8 42 e6 fe ff       	call   f0101efb <execute_command>
f01138b9:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f01138bc:	83 ec 04             	sub    $0x4,%esp
f01138bf:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01138c5:	50                   	push   %eax
f01138c6:	68 98 a0 12 f0       	push   $0xf012a098
f01138cb:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01138d1:	50                   	push   %eax
f01138d2:	e8 0a cc 00 00       	call   f01204e1 <strcconcat>
f01138d7:	83 c4 10             	add    $0x10,%esp
f01138da:	83 ec 0c             	sub    $0xc,%esp
f01138dd:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01138e3:	50                   	push   %eax
f01138e4:	e8 12 e6 fe ff       	call   f0101efb <execute_command>
f01138e9:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f01138ec:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01138f2:	bb 55 a8 12 f0       	mov    $0xf012a855,%ebx
f01138f7:	ba 0f 00 00 00       	mov    $0xf,%edx
f01138fc:	89 c7                	mov    %eax,%edi
f01138fe:	89 de                	mov    %ebx,%esi
f0113900:	89 d1                	mov    %edx,%ecx
f0113902:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113904:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011390a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011390f:	b0 00                	mov    $0x0,%al
f0113911:	89 d7                	mov    %edx,%edi
f0113913:	f3 aa                	rep stos %al,%es:(%edi)
f0113915:	83 ec 0c             	sub    $0xc,%esp
f0113918:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011391e:	50                   	push   %eax
f011391f:	e8 d7 e5 fe ff       	call   f0101efb <execute_command>
f0113924:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0113927:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011392d:	bb b9 a8 12 f0       	mov    $0xf012a8b9,%ebx
f0113932:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113937:	89 c7                	mov    %eax,%edi
f0113939:	89 de                	mov    %ebx,%esi
f011393b:	89 d1                	mov    %edx,%ecx
f011393d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011393f:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113945:	b9 55 00 00 00       	mov    $0x55,%ecx
f011394a:	b0 00                	mov    $0x0,%al
f011394c:	89 d7                	mov    %edx,%edi
f011394e:	f3 aa                	rep stos %al,%es:(%edi)
f0113950:	83 ec 0c             	sub    $0xc,%esp
f0113953:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113959:	50                   	push   %eax
f011395a:	e8 9c e5 fe ff       	call   f0101efb <execute_command>
f011395f:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0113962:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113968:	bb 1d a9 12 f0       	mov    $0xf012a91d,%ebx
f011396d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113972:	89 c7                	mov    %eax,%edi
f0113974:	89 de                	mov    %ebx,%esi
f0113976:	89 d1                	mov    %edx,%ecx
f0113978:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011397a:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113980:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113985:	b0 00                	mov    $0x0,%al
f0113987:	89 d7                	mov    %edx,%edi
f0113989:	f3 aa                	rep stos %al,%es:(%edi)
f011398b:	83 ec 0c             	sub    $0xc,%esp
f011398e:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113994:	50                   	push   %eax
f0113995:	e8 61 e5 fe ff       	call   f0101efb <execute_command>
f011399a:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f011399d:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f01139a4:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f01139ab:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f01139b2:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f01139b9:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f01139c0:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f01139c7:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f01139ce:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f01139d5:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f01139dc:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f01139e3:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f01139ea:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f01139f1:	8b 45 90             	mov    -0x70(%ebp),%eax
f01139f4:	8a 00                	mov    (%eax),%al
f01139f6:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01139fc:	e8 47 b2 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113a01:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113a04:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113a07:	89 d0                	mov    %edx,%eax
f0113a09:	01 c0                	add    %eax,%eax
f0113a0b:	01 d0                	add    %edx,%eax
f0113a0d:	01 c0                	add    %eax,%eax
f0113a0f:	50                   	push   %eax
f0113a10:	68 00 00 40 00       	push   $0x400000
f0113a15:	68 00 00 20 00       	push   $0x200000
f0113a1a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113a1d:	e8 22 74 ff ff       	call   f010ae44 <copy_paste_chunk>
f0113a22:	83 c4 10             	add    $0x10,%esp
f0113a25:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113a28:	e8 1b b2 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113a2d:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113a30:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113a37:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113a3b:	75 08                	jne    f0113a45 <test_copy_paste_chunk+0x929>
f0113a3d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113a40:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113a43:	74 2b                	je     f0113a70 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113a45:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113a48:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113a4b:	83 ec 0c             	sub    $0xc,%esp
f0113a4e:	50                   	push   %eax
f0113a4f:	ff 75 80             	pushl  -0x80(%ebp)
f0113a52:	68 a4 a0 12 f0       	push   $0xf012a0a4
f0113a57:	68 3f 03 00 00       	push   $0x33f
f0113a5c:	68 02 98 12 f0       	push   $0xf0129802
f0113a61:	e8 70 ca fe ff       	call   f01004d6 <_warn>
f0113a66:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113a69:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113a70:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113a74:	74 04                	je     f0113a7a <test_copy_paste_chunk+0x95e>
f0113a76:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113a7a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0113a81:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0113a88:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113a8b:	83 ec 08             	sub    $0x8,%esp
f0113a8e:	6a 01                	push   $0x1
f0113a90:	6a 07                	push   $0x7
f0113a92:	6a 07                	push   $0x7
f0113a94:	6a 07                	push   $0x7
f0113a96:	6a 07                	push   $0x7
f0113a98:	6a 01                	push   $0x1
f0113a9a:	68 00 20 00 00       	push   $0x2000
f0113a9f:	68 00 00 40 00       	push   $0x400000
f0113aa4:	68 00 00 20 00       	push   $0x200000
f0113aa9:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113aac:	e8 bf 32 00 00       	call   f0116d70 <CCP>
f0113ab1:	83 c4 30             	add    $0x30,%esp
f0113ab4:	83 f8 01             	cmp    $0x1,%eax
f0113ab7:	74 2b                	je     f0113ae4 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0113ab9:	83 ec 04             	sub    $0x4,%esp
f0113abc:	68 f8 a0 12 f0       	push   $0xf012a0f8
f0113ac1:	68 48 03 00 00       	push   $0x348
f0113ac6:	68 02 98 12 f0       	push   $0xf0129802
f0113acb:	e8 06 ca fe ff       	call   f01004d6 <_warn>
f0113ad0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113ad3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f0113ada:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113ae1:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113ae4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113ae8:	74 04                	je     f0113aee <test_copy_paste_chunk+0x9d2>
f0113aea:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113aee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113af5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113af8:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f0113afb:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113afe:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113b01:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113b04:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113b07:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113b0a:	8a 00                	mov    (%eax),%al
f0113b0c:	3c 61                	cmp    $0x61,%al
f0113b0e:	75 69                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b10:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113b13:	8a 00                	mov    (%eax),%al
f0113b15:	3c 61                	cmp    $0x61,%al
f0113b17:	75 60                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b19:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113b1c:	8a 00                	mov    (%eax),%al
f0113b1e:	3c 79                	cmp    $0x79,%al
f0113b20:	75 57                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b22:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113b25:	8a 00                	mov    (%eax),%al
f0113b27:	3c 62                	cmp    $0x62,%al
f0113b29:	75 4e                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b2b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113b2e:	8a 00                	mov    (%eax),%al
f0113b30:	3c 63                	cmp    $0x63,%al
f0113b32:	75 45                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b34:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113b37:	8a 00                	mov    (%eax),%al
f0113b39:	3c 7a                	cmp    $0x7a,%al
f0113b3b:	75 3c                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0113b3d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113b40:	8a 00                	mov    (%eax),%al
f0113b42:	3c 77                	cmp    $0x77,%al
f0113b44:	75 33                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b46:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113b49:	8a 00                	mov    (%eax),%al
f0113b4b:	3c 64                	cmp    $0x64,%al
f0113b4d:	75 2a                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b4f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113b52:	8a 00                	mov    (%eax),%al
f0113b54:	3c 65                	cmp    $0x65,%al
f0113b56:	75 21                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b58:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113b5b:	8a 00                	mov    (%eax),%al
f0113b5d:	3c 65                	cmp    $0x65,%al
f0113b5f:	75 18                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b61:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113b64:	8a 00                	mov    (%eax),%al
f0113b66:	3c 66                	cmp    $0x66,%al
f0113b68:	75 0f                	jne    f0113b79 <test_copy_paste_chunk+0xa5d>
f0113b6a:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113b6d:	8a 10                	mov    (%eax),%dl
f0113b6f:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113b75:	38 c2                	cmp    %al,%dl
f0113b77:	74 21                	je     f0113b9a <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113b79:	83 ec 04             	sub    $0x4,%esp
f0113b7c:	68 f8 9f 12 f0       	push   $0xf0129ff8
f0113b81:	68 56 03 00 00       	push   $0x356
f0113b86:	68 02 98 12 f0       	push   $0xf0129802
f0113b8b:	e8 46 c9 fe ff       	call   f01004d6 <_warn>
f0113b90:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113b93:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113b9a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113b9e:	74 04                	je     f0113ba4 <test_copy_paste_chunk+0xa88>
f0113ba0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113ba4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0113bab:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113bae:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113bb1:	e8 92 b0 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113bb6:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0113bb9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113bbc:	89 c2                	mov    %eax,%edx
f0113bbe:	01 d2                	add    %edx,%edx
f0113bc0:	01 d0                	add    %edx,%eax
f0113bc2:	50                   	push   %eax
f0113bc3:	68 00 08 20 00       	push   $0x200800
f0113bc8:	68 00 08 40 00       	push   $0x400800
f0113bcd:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113bd0:	e8 6f 72 ff ff       	call   f010ae44 <copy_paste_chunk>
f0113bd5:	83 c4 10             	add    $0x10,%esp
f0113bd8:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113bdb:	e8 68 b0 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113be0:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113be3:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113be7:	75 08                	jne    f0113bf1 <test_copy_paste_chunk+0xad5>
f0113be9:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113bec:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113bef:	74 2b                	je     f0113c1c <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113bf1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113bf4:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113bf7:	83 ec 0c             	sub    $0xc,%esp
f0113bfa:	50                   	push   %eax
f0113bfb:	ff 75 80             	pushl  -0x80(%ebp)
f0113bfe:	68 a4 a0 12 f0       	push   $0xf012a0a4
f0113c03:	68 66 03 00 00       	push   $0x366
f0113c08:	68 02 98 12 f0       	push   $0xf0129802
f0113c0d:	e8 c4 c8 fe ff       	call   f01004d6 <_warn>
f0113c12:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113c15:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113c1c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c20:	74 04                	je     f0113c26 <test_copy_paste_chunk+0xb0a>
f0113c22:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c26:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113c2d:	83 ec 08             	sub    $0x8,%esp
f0113c30:	6a 01                	push   $0x1
f0113c32:	6a 07                	push   $0x7
f0113c34:	6a 07                	push   $0x7
f0113c36:	6a 07                	push   $0x7
f0113c38:	6a 07                	push   $0x7
f0113c3a:	6a 01                	push   $0x1
f0113c3c:	68 00 20 00 00       	push   $0x2000
f0113c41:	68 00 00 20 00       	push   $0x200000
f0113c46:	68 00 00 40 00       	push   $0x400000
f0113c4b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113c4e:	e8 1d 31 00 00       	call   f0116d70 <CCP>
f0113c53:	83 c4 30             	add    $0x30,%esp
f0113c56:	83 f8 01             	cmp    $0x1,%eax
f0113c59:	74 21                	je     f0113c7c <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113c5b:	83 ec 04             	sub    $0x4,%esp
f0113c5e:	68 44 a1 12 f0       	push   $0xf012a144
f0113c63:	68 6e 03 00 00       	push   $0x36e
f0113c68:	68 02 98 12 f0       	push   $0xf0129802
f0113c6d:	e8 64 c8 fe ff       	call   f01004d6 <_warn>
f0113c72:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c75:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113c7c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c80:	74 04                	je     f0113c86 <test_copy_paste_chunk+0xb6a>
f0113c82:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c86:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113c8d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c90:	8a 00                	mov    (%eax),%al
f0113c92:	3c 61                	cmp    $0x61,%al
f0113c94:	75 69                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
f0113c96:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113c99:	8a 00                	mov    (%eax),%al
f0113c9b:	3c 61                	cmp    $0x61,%al
f0113c9d:	75 60                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
f0113c9f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ca2:	8a 00                	mov    (%eax),%al
f0113ca4:	3c 79                	cmp    $0x79,%al
f0113ca6:	75 57                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
f0113ca8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113cab:	8a 00                	mov    (%eax),%al
f0113cad:	3c 62                	cmp    $0x62,%al
f0113caf:	75 4e                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
f0113cb1:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113cb4:	8a 00                	mov    (%eax),%al
f0113cb6:	3c 7a                	cmp    $0x7a,%al
f0113cb8:	75 45                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
f0113cba:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113cbd:	8a 00                	mov    (%eax),%al
f0113cbf:	3c 7a                	cmp    $0x7a,%al
f0113cc1:	75 3c                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113cc3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113cc6:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113cc8:	3c 64                	cmp    $0x64,%al
f0113cca:	75 33                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113ccc:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113ccf:	8a 00                	mov    (%eax),%al
f0113cd1:	3c 64                	cmp    $0x64,%al
f0113cd3:	75 2a                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
f0113cd5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113cd8:	8a 00                	mov    (%eax),%al
f0113cda:	3c 65                	cmp    $0x65,%al
f0113cdc:	75 21                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
f0113cde:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113ce1:	8a 00                	mov    (%eax),%al
f0113ce3:	3c 78                	cmp    $0x78,%al
f0113ce5:	75 18                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
f0113ce7:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113cea:	8a 00                	mov    (%eax),%al
f0113cec:	3c 66                	cmp    $0x66,%al
f0113cee:	75 0f                	jne    f0113cff <test_copy_paste_chunk+0xbe3>
f0113cf0:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113cf3:	8a 10                	mov    (%eax),%dl
f0113cf5:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113cfb:	38 c2                	cmp    %al,%dl
f0113cfd:	74 21                	je     f0113d20 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113cff:	83 ec 04             	sub    $0x4,%esp
f0113d02:	68 f8 9f 12 f0       	push   $0xf0129ff8
f0113d07:	68 77 03 00 00       	push   $0x377
f0113d0c:	68 02 98 12 f0       	push   $0xf0129802
f0113d11:	e8 c0 c7 fe ff       	call   f01004d6 <_warn>
f0113d16:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113d19:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113d20:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113d24:	74 04                	je     f0113d2a <test_copy_paste_chunk+0xc0e>
f0113d26:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113d2a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113d31:	83 ec 0c             	sub    $0xc,%esp
f0113d34:	68 8f a1 12 f0       	push   $0xf012a18f
f0113d39:	e8 4d d2 fe ff       	call   f0100f8b <cprintf>
f0113d3e:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0113d41:	83 ec 0c             	sub    $0xc,%esp
f0113d44:	68 a0 a1 12 f0       	push   $0xf012a1a0
f0113d49:	e8 3d d2 fe ff       	call   f0100f8b <cprintf>
f0113d4e:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0113d51:	83 ec 04             	sub    $0x4,%esp
f0113d54:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113d5a:	50                   	push   %eax
f0113d5b:	68 d4 a1 12 f0       	push   $0xf012a1d4
f0113d60:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113d66:	50                   	push   %eax
f0113d67:	e8 75 c7 00 00       	call   f01204e1 <strcconcat>
f0113d6c:	83 c4 10             	add    $0x10,%esp
f0113d6f:	83 ec 0c             	sub    $0xc,%esp
f0113d72:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113d78:	50                   	push   %eax
f0113d79:	e8 7d e1 fe ff       	call   f0101efb <execute_command>
f0113d7e:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113d81:	83 ec 04             	sub    $0x4,%esp
f0113d84:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113d8a:	50                   	push   %eax
f0113d8b:	68 de a1 12 f0       	push   $0xf012a1de
f0113d90:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113d96:	50                   	push   %eax
f0113d97:	e8 45 c7 00 00       	call   f01204e1 <strcconcat>
f0113d9c:	83 c4 10             	add    $0x10,%esp
f0113d9f:	83 ec 0c             	sub    $0xc,%esp
f0113da2:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113da8:	50                   	push   %eax
f0113da9:	e8 4d e1 fe ff       	call   f0101efb <execute_command>
f0113dae:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113db1:	83 ec 04             	sub    $0x4,%esp
f0113db4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113dba:	50                   	push   %eax
f0113dbb:	68 e8 a1 12 f0       	push   $0xf012a1e8
f0113dc0:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113dc6:	50                   	push   %eax
f0113dc7:	e8 15 c7 00 00       	call   f01204e1 <strcconcat>
f0113dcc:	83 c4 10             	add    $0x10,%esp
f0113dcf:	83 ec 0c             	sub    $0xc,%esp
f0113dd2:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113dd8:	50                   	push   %eax
f0113dd9:	e8 1d e1 fe ff       	call   f0101efb <execute_command>
f0113dde:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113de1:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113de7:	bb 81 a9 12 f0       	mov    $0xf012a981,%ebx
f0113dec:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113df1:	89 c7                	mov    %eax,%edi
f0113df3:	89 de                	mov    %ebx,%esi
f0113df5:	89 d1                	mov    %edx,%ecx
f0113df7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113df9:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113dff:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113e04:	b0 00                	mov    $0x0,%al
f0113e06:	89 d7                	mov    %edx,%edi
f0113e08:	f3 aa                	rep stos %al,%es:(%edi)
f0113e0a:	83 ec 0c             	sub    $0xc,%esp
f0113e0d:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113e13:	50                   	push   %eax
f0113e14:	e8 e2 e0 fe ff       	call   f0101efb <execute_command>
f0113e19:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0113e1c:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113e22:	bb e5 a9 12 f0       	mov    $0xf012a9e5,%ebx
f0113e27:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113e2c:	89 c7                	mov    %eax,%edi
f0113e2e:	89 de                	mov    %ebx,%esi
f0113e30:	89 d1                	mov    %edx,%ecx
f0113e32:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113e34:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113e3a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113e3f:	b0 00                	mov    $0x0,%al
f0113e41:	89 d7                	mov    %edx,%edi
f0113e43:	f3 aa                	rep stos %al,%es:(%edi)
f0113e45:	83 ec 0c             	sub    $0xc,%esp
f0113e48:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113e4e:	50                   	push   %eax
f0113e4f:	e8 a7 e0 fe ff       	call   f0101efb <execute_command>
f0113e54:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0113e57:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113e5d:	bb 49 aa 12 f0       	mov    $0xf012aa49,%ebx
f0113e62:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113e67:	89 c7                	mov    %eax,%edi
f0113e69:	89 de                	mov    %ebx,%esi
f0113e6b:	89 d1                	mov    %edx,%ecx
f0113e6d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113e6f:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113e75:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113e7a:	b0 00                	mov    $0x0,%al
f0113e7c:	89 d7                	mov    %edx,%edi
f0113e7e:	f3 aa                	rep stos %al,%es:(%edi)
f0113e80:	83 ec 0c             	sub    $0xc,%esp
f0113e83:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113e89:	50                   	push   %eax
f0113e8a:	e8 6c e0 fe ff       	call   f0101efb <execute_command>
f0113e8f:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113e92:	e8 b1 ad ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113e97:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0113e9a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113e9d:	89 d0                	mov    %edx,%eax
f0113e9f:	01 c0                	add    %eax,%eax
f0113ea1:	01 d0                	add    %edx,%eax
f0113ea3:	c1 e0 02             	shl    $0x2,%eax
f0113ea6:	50                   	push   %eax
f0113ea7:	68 00 00 90 00       	push   $0x900000
f0113eac:	68 00 00 80 00       	push   $0x800000
f0113eb1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113eb4:	e8 8b 6f ff ff       	call   f010ae44 <copy_paste_chunk>
f0113eb9:	83 c4 10             	add    $0x10,%esp
f0113ebc:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113ec2:	e8 81 ad ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113ec7:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113eca:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113ed1:	75 0b                	jne    f0113ede <test_copy_paste_chunk+0xdc2>
f0113ed3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113ed6:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113ed9:	83 f8 03             	cmp    $0x3,%eax
f0113edc:	74 2e                	je     f0113f0c <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113ede:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113ee1:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113ee4:	83 ec 0c             	sub    $0xc,%esp
f0113ee7:	50                   	push   %eax
f0113ee8:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113eee:	68 a4 a0 12 f0       	push   $0xf012a0a4
f0113ef3:	68 95 03 00 00       	push   $0x395
f0113ef8:	68 02 98 12 f0       	push   $0xf0129802
f0113efd:	e8 d4 c5 fe ff       	call   f01004d6 <_warn>
f0113f02:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113f05:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113f0c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113f10:	74 04                	je     f0113f16 <test_copy_paste_chunk+0xdfa>
f0113f12:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f16:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0113f1d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113f24:	83 ec 08             	sub    $0x8,%esp
f0113f27:	6a 01                	push   $0x1
f0113f29:	6a 07                	push   $0x7
f0113f2b:	6a 07                	push   $0x7
f0113f2d:	6a 07                	push   $0x7
f0113f2f:	6a 07                	push   $0x7
f0113f31:	6a 01                	push   $0x1
f0113f33:	68 00 30 00 00       	push   $0x3000
f0113f38:	68 00 00 90 00       	push   $0x900000
f0113f3d:	68 00 00 80 00       	push   $0x800000
f0113f42:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113f45:	e8 26 2e 00 00       	call   f0116d70 <CCP>
f0113f4a:	83 c4 30             	add    $0x30,%esp
f0113f4d:	83 f8 01             	cmp    $0x1,%eax
f0113f50:	74 28                	je     f0113f7a <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113f52:	83 ec 04             	sub    $0x4,%esp
f0113f55:	68 44 a1 12 f0       	push   $0xf012a144
f0113f5a:	68 9e 03 00 00       	push   $0x39e
f0113f5f:	68 02 98 12 f0       	push   $0xf0129802
f0113f64:	e8 6d c5 fe ff       	call   f01004d6 <_warn>
f0113f69:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113f6c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113f73:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0113f7a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113f7e:	74 04                	je     f0113f84 <test_copy_paste_chunk+0xe68>
f0113f80:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f84:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113f8b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113f8f:	0f 84 9e 00 00 00    	je     f0114033 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0113f95:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0113f9c:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113fa3:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0113faa:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113fb1:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0113fb8:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113fbf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113fc2:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113fc5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113fc8:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0113fcb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113fce:	8a 00                	mov    (%eax),%al
f0113fd0:	3c 61                	cmp    $0x61,%al
f0113fd2:	75 2d                	jne    f0114001 <test_copy_paste_chunk+0xee5>
f0113fd4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113fd7:	8a 00                	mov    (%eax),%al
f0113fd9:	3c 61                	cmp    $0x61,%al
f0113fdb:	75 24                	jne    f0114001 <test_copy_paste_chunk+0xee5>
f0113fdd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113fe0:	8a 00                	mov    (%eax),%al
f0113fe2:	3c 79                	cmp    $0x79,%al
f0113fe4:	75 1b                	jne    f0114001 <test_copy_paste_chunk+0xee5>
f0113fe6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113fe9:	8a 00                	mov    (%eax),%al
f0113feb:	3c 62                	cmp    $0x62,%al
f0113fed:	75 12                	jne    f0114001 <test_copy_paste_chunk+0xee5>
f0113fef:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113ff2:	8a 00                	mov    (%eax),%al
f0113ff4:	3c 63                	cmp    $0x63,%al
f0113ff6:	75 09                	jne    f0114001 <test_copy_paste_chunk+0xee5>
f0113ff8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113ffb:	8a 00                	mov    (%eax),%al
f0113ffd:	3c 7a                	cmp    $0x7a,%al
f0113fff:	74 21                	je     f0114022 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114001:	83 ec 04             	sub    $0x4,%esp
f0114004:	68 f8 9f 12 f0       	push   $0xf0129ff8
f0114009:	68 b0 03 00 00       	push   $0x3b0
f011400e:	68 02 98 12 f0       	push   $0xf0129802
f0114013:	e8 be c4 fe ff       	call   f01004d6 <_warn>
f0114018:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011401b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0114022:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114026:	74 04                	je     f011402c <test_copy_paste_chunk+0xf10>
f0114028:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f011402c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114033:	e8 10 ac ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114038:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f011403b:	6a 00                	push   $0x0
f011403d:	6a 02                	push   $0x2
f011403f:	68 00 10 90 00       	push   $0x901000
f0114044:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114047:	e8 b1 2b 00 00       	call   f0116bfd <SB>
f011404c:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f011404f:	6a 00                	push   $0x0
f0114051:	6a 02                	push   $0x2
f0114053:	68 00 20 90 00       	push   $0x902000
f0114058:	ff 75 d4             	pushl  -0x2c(%ebp)
f011405b:	e8 9d 2b 00 00       	call   f0116bfd <SB>
f0114060:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0114063:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114066:	c1 e0 03             	shl    $0x3,%eax
f0114069:	50                   	push   %eax
f011406a:	68 00 f0 bf 00       	push   $0xbff000
f011406f:	68 00 10 90 00       	push   $0x901000
f0114074:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114077:	e8 c8 6d ff ff       	call   f010ae44 <copy_paste_chunk>
f011407c:	83 c4 10             	add    $0x10,%esp
f011407f:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114085:	e8 be ab ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011408a:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011408d:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0114094:	75 0b                	jne    f01140a1 <test_copy_paste_chunk+0xf85>
f0114096:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114099:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011409c:	83 f8 03             	cmp    $0x3,%eax
f011409f:	74 2e                	je     f01140cf <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01140a1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01140a4:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01140a7:	83 ec 0c             	sub    $0xc,%esp
f01140aa:	50                   	push   %eax
f01140ab:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01140b1:	68 a4 a0 12 f0       	push   $0xf012a0a4
f01140b6:	68 c0 03 00 00       	push   $0x3c0
f01140bb:	68 02 98 12 f0       	push   $0xf0129802
f01140c0:	e8 11 c4 fe ff       	call   f01004d6 <_warn>
f01140c5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01140c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01140cf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01140d3:	74 04                	je     f01140d9 <test_copy_paste_chunk+0xfbd>
f01140d5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01140d9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f01140e0:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f01140e7:	83 ec 08             	sub    $0x8,%esp
f01140ea:	6a 01                	push   $0x1
f01140ec:	6a 07                	push   $0x7
f01140ee:	6a 03                	push   $0x3
f01140f0:	6a 07                	push   $0x7
f01140f2:	6a 03                	push   $0x3
f01140f4:	6a 01                	push   $0x1
f01140f6:	68 00 20 00 00       	push   $0x2000
f01140fb:	68 00 f0 bf 00       	push   $0xbff000
f0114100:	68 00 10 90 00       	push   $0x901000
f0114105:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114108:	e8 63 2c 00 00       	call   f0116d70 <CCP>
f011410d:	83 c4 30             	add    $0x30,%esp
f0114110:	83 f8 01             	cmp    $0x1,%eax
f0114113:	74 28                	je     f011413d <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0114115:	83 ec 04             	sub    $0x4,%esp
f0114118:	68 44 a1 12 f0       	push   $0xf012a144
f011411d:	68 c9 03 00 00       	push   $0x3c9
f0114122:	68 02 98 12 f0       	push   $0xf0129802
f0114127:	e8 aa c3 fe ff       	call   f01004d6 <_warn>
f011412c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011412f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0114136:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f011413d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114141:	74 04                	je     f0114147 <test_copy_paste_chunk+0x102b>
f0114143:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114147:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f011414e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114152:	74 72                	je     f01141c6 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0114154:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f011415b:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0114162:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0114169:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0114170:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114173:	8a 00                	mov    (%eax),%al
f0114175:	3c 62                	cmp    $0x62,%al
f0114177:	75 1b                	jne    f0114194 <test_copy_paste_chunk+0x1078>
f0114179:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011417c:	8a 00                	mov    (%eax),%al
f011417e:	3c 62                	cmp    $0x62,%al
f0114180:	75 12                	jne    f0114194 <test_copy_paste_chunk+0x1078>
f0114182:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114185:	8a 00                	mov    (%eax),%al
f0114187:	3c 7a                	cmp    $0x7a,%al
f0114189:	75 09                	jne    f0114194 <test_copy_paste_chunk+0x1078>
f011418b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011418e:	8a 00                	mov    (%eax),%al
f0114190:	3c 7a                	cmp    $0x7a,%al
f0114192:	74 21                	je     f01141b5 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114194:	83 ec 04             	sub    $0x4,%esp
f0114197:	68 f8 9f 12 f0       	push   $0xf0129ff8
f011419c:	68 d5 03 00 00       	push   $0x3d5
f01141a1:	68 02 98 12 f0       	push   $0xf0129802
f01141a6:	e8 2b c3 fe ff       	call   f01004d6 <_warn>
f01141ab:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01141ae:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01141b5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01141b9:	74 04                	je     f01141bf <test_copy_paste_chunk+0x10a3>
f01141bb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01141bf:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01141c6:	83 ec 0c             	sub    $0xc,%esp
f01141c9:	68 f2 a1 12 f0       	push   $0xf012a1f2
f01141ce:	e8 b8 cd fe ff       	call   f0100f8b <cprintf>
f01141d3:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f01141d6:	83 ec 08             	sub    $0x8,%esp
f01141d9:	ff 75 e4             	pushl  -0x1c(%ebp)
f01141dc:	68 04 a2 12 f0       	push   $0xf012a204
f01141e1:	e8 a5 cd fe ff       	call   f0100f8b <cprintf>
f01141e6:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01141e9:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01141ed:	75 10                	jne    f01141ff <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f01141ef:	83 ec 0c             	sub    $0xc,%esp
f01141f2:	68 38 a2 12 f0       	push   $0xf012a238
f01141f7:	e8 8f cd fe ff       	call   f0100f8b <cprintf>
f01141fc:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01141ff:	a1 e4 f8 f1 f0       	mov    0xf0f1f8e4,%eax
f0114204:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0114207:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011420a:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011420d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114212:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114215:	5b                   	pop    %ebx
f0114216:	5e                   	pop    %esi
f0114217:	5f                   	pop    %edi
f0114218:	5d                   	pop    %ebp
f0114219:	c3                   	ret    

f011421a <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f011421a:	55                   	push   %ebp
f011421b:	89 e5                	mov    %esp,%ebp
f011421d:	57                   	push   %edi
f011421e:	56                   	push   %esi
f011421f:	53                   	push   %ebx
f0114220:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114226:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f011422c:	bb 04 9f 12 f0       	mov    $0xf0129f04,%ebx
f0114231:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114236:	89 c7                	mov    %eax,%edi
f0114238:	89 de                	mov    %ebx,%esi
f011423a:	89 d1                	mov    %edx,%ecx
f011423c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011423e:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0114244:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114249:	b0 00                	mov    $0x0,%al
f011424b:	89 d7                	mov    %edx,%edi
f011424d:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011424f:	6a 00                	push   $0x0
f0114251:	6a 0a                	push   $0xa
f0114253:	6a 14                	push   $0x14
f0114255:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f011425b:	50                   	push   %eax
f011425c:	e8 46 70 ff ff       	call   f010b2a7 <env_create>
f0114261:	83 c4 10             	add    $0x10,%esp
f0114264:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114267:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011426a:	8b 40 64             	mov    0x64(%eax),%eax
f011426d:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114270:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114273:	8b 40 68             	mov    0x68(%eax),%eax
f0114276:	89 45 80             	mov    %eax,-0x80(%ebp)
f0114279:	8b 45 80             	mov    -0x80(%ebp),%eax
f011427c:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f011427f:	83 ec 0c             	sub    $0xc,%esp
f0114282:	ff 75 cc             	pushl  -0x34(%ebp)
f0114285:	e8 b2 2a 00 00       	call   f0116d3c <ClearUserSpace>
f011428a:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011428d:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114294:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f011429b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f01142a2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f01142a6:	83 ec 0c             	sub    $0xc,%esp
f01142a9:	68 b0 aa 12 f0       	push   $0xf012aab0
f01142ae:	e8 d8 cc fe ff       	call   f0100f8b <cprintf>
f01142b3:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f01142b6:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f01142bd:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f01142c4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01142c7:	8a 00                	mov    (%eax),%al
f01142c9:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f01142cf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01142d2:	8a 00                	mov    (%eax),%al
f01142d4:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01142da:	e8 69 a9 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01142df:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f01142e2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01142e5:	89 d0                	mov    %edx,%eax
f01142e7:	01 c0                	add    %eax,%eax
f01142e9:	01 d0                	add    %edx,%eax
f01142eb:	01 c0                	add    %eax,%eax
f01142ed:	83 ec 0c             	sub    $0xc,%esp
f01142f0:	6a 02                	push   $0x2
f01142f2:	50                   	push   %eax
f01142f3:	68 00 40 10 f0       	push   $0xf0104000
f01142f8:	68 00 00 10 f0       	push   $0xf0100000
f01142fd:	ff 75 cc             	pushl  -0x34(%ebp)
f0114300:	e8 59 6b ff ff       	call   f010ae5e <share_chunk>
f0114305:	83 c4 20             	add    $0x20,%esp
f0114308:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011430b:	e8 38 a9 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114310:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114313:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114317:	75 08                	jne    f0114321 <test_share_chunk+0x107>
f0114319:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011431c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011431f:	74 28                	je     f0114349 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0114321:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114324:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114327:	83 ec 0c             	sub    $0xc,%esp
f011432a:	50                   	push   %eax
f011432b:	ff 75 b0             	pushl  -0x50(%ebp)
f011432e:	68 dc aa 12 f0       	push   $0xf012aadc
f0114333:	68 11 04 00 00       	push   $0x411
f0114338:	68 02 98 12 f0       	push   $0xf0129802
f011433d:	e8 94 c1 fe ff       	call   f01004d6 <_warn>
f0114342:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114345:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114349:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011434d:	74 04                	je     f0114353 <test_share_chunk+0x139>
f011434f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114353:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0114357:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011435a:	c1 e0 03             	shl    $0x3,%eax
f011435d:	83 ec 08             	sub    $0x8,%esp
f0114360:	68 fd 00 00 00       	push   $0xfd
f0114365:	6a 07                	push   $0x7
f0114367:	6a 03                	push   $0x3
f0114369:	6a 07                	push   $0x7
f011436b:	6a 03                	push   $0x3
f011436d:	6a 01                	push   $0x1
f011436f:	50                   	push   %eax
f0114370:	68 00 40 10 f0       	push   $0xf0104000
f0114375:	68 00 00 10 f0       	push   $0xf0100000
f011437a:	ff 75 cc             	pushl  -0x34(%ebp)
f011437d:	e8 ee 29 00 00       	call   f0116d70 <CCP>
f0114382:	83 c4 30             	add    $0x30,%esp
f0114385:	85 c0                	test   %eax,%eax
f0114387:	75 1e                	jne    f01143a7 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114389:	83 ec 04             	sub    $0x4,%esp
f011438c:	68 38 ab 12 f0       	push   $0xf012ab38
f0114391:	68 19 04 00 00       	push   $0x419
f0114396:	68 02 98 12 f0       	push   $0xf0129802
f011439b:	e8 36 c1 fe ff       	call   f01004d6 <_warn>
f01143a0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01143a3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01143a7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143ab:	74 04                	je     f01143b1 <test_share_chunk+0x197>
f01143ad:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f01143b1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01143b4:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f01143b7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01143ba:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f01143bd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01143c0:	8a 00                	mov    (%eax),%al
f01143c2:	3c 41                	cmp    $0x41,%al
f01143c4:	75 09                	jne    f01143cf <test_share_chunk+0x1b5>
f01143c6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01143c9:	8a 00                	mov    (%eax),%al
f01143cb:	3c 42                	cmp    $0x42,%al
f01143cd:	74 1e                	je     f01143ed <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01143cf:	83 ec 04             	sub    $0x4,%esp
f01143d2:	68 80 ab 12 f0       	push   $0xf012ab80
f01143d7:	68 23 04 00 00       	push   $0x423
f01143dc:	68 02 98 12 f0       	push   $0xf0129802
f01143e1:	e8 f0 c0 fe ff       	call   f01004d6 <_warn>
f01143e6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01143e9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01143ed:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143f1:	74 04                	je     f01143f7 <test_share_chunk+0x1dd>
f01143f3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01143f7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f01143fb:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0114401:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114404:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0114406:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f011440c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011440f:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0114411:	83 ec 0c             	sub    $0xc,%esp
f0114414:	68 b5 ab 12 f0       	push   $0xf012abb5
f0114419:	e8 6d cb fe ff       	call   f0100f8b <cprintf>
f011441e:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0114421:	83 ec 0c             	sub    $0xc,%esp
f0114424:	68 c4 ab 12 f0       	push   $0xf012abc4
f0114429:	e8 5d cb fe ff       	call   f0100f8b <cprintf>
f011442e:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114431:	e8 12 a8 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114436:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114439:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011443c:	c1 e0 05             	shl    $0x5,%eax
f011443f:	83 ec 0c             	sub    $0xc,%esp
f0114442:	68 02 0e 00 00       	push   $0xe02
f0114447:	50                   	push   %eax
f0114448:	68 00 00 00 40       	push   $0x40000000
f011444d:	68 00 00 00 f0       	push   $0xf0000000
f0114452:	ff 75 cc             	pushl  -0x34(%ebp)
f0114455:	e8 04 6a ff ff       	call   f010ae5e <share_chunk>
f011445a:	83 c4 20             	add    $0x20,%esp
f011445d:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114460:	e8 e3 a7 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114465:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0114468:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f011446c:	75 1f                	jne    f011448d <test_share_chunk+0x273>
f011446e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114471:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114474:	89 c1                	mov    %eax,%ecx
f0114476:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114479:	c1 e0 05             	shl    $0x5,%eax
f011447c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011447f:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114486:	99                   	cltd   
f0114487:	f7 fb                	idiv   %ebx
f0114489:	39 c1                	cmp    %eax,%ecx
f011448b:	74 28                	je     f01144b5 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011448d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114490:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114493:	83 ec 0c             	sub    $0xc,%esp
f0114496:	50                   	push   %eax
f0114497:	ff 75 a8             	pushl  -0x58(%ebp)
f011449a:	68 00 ac 12 f0       	push   $0xf012ac00
f011449f:	68 3b 04 00 00       	push   $0x43b
f01144a4:	68 02 98 12 f0       	push   $0xf0129802
f01144a9:	e8 28 c0 fe ff       	call   f01004d6 <_warn>
f01144ae:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01144b1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01144b5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144b9:	74 04                	je     f01144bf <test_share_chunk+0x2a5>
f01144bb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01144bf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01144c3:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01144ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01144cd:	c1 e0 05             	shl    $0x5,%eax
f01144d0:	83 ec 08             	sub    $0x8,%esp
f01144d3:	6a 02                	push   $0x2
f01144d5:	6a 07                	push   $0x7
f01144d7:	6a 03                	push   $0x3
f01144d9:	68 07 0e 00 00       	push   $0xe07
f01144de:	68 03 0e 00 00       	push   $0xe03
f01144e3:	6a ff                	push   $0xffffffff
f01144e5:	50                   	push   %eax
f01144e6:	68 00 00 00 40       	push   $0x40000000
f01144eb:	68 00 00 00 f0       	push   $0xf0000000
f01144f0:	ff 75 cc             	pushl  -0x34(%ebp)
f01144f3:	e8 78 28 00 00       	call   f0116d70 <CCP>
f01144f8:	83 c4 30             	add    $0x30,%esp
f01144fb:	85 c0                	test   %eax,%eax
f01144fd:	75 25                	jne    f0114524 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01144ff:	83 ec 04             	sub    $0x4,%esp
f0114502:	68 38 ab 12 f0       	push   $0xf012ab38
f0114507:	68 44 04 00 00       	push   $0x444
f011450c:	68 02 98 12 f0       	push   $0xf0129802
f0114511:	e8 c0 bf fe ff       	call   f01004d6 <_warn>
f0114516:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114519:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011451d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114524:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114527:	89 d0                	mov    %edx,%eax
f0114529:	01 c0                	add    %eax,%eax
f011452b:	01 d0                	add    %edx,%eax
f011452d:	c1 e0 02             	shl    $0x2,%eax
f0114530:	83 ec 08             	sub    $0x8,%esp
f0114533:	6a 02                	push   $0x2
f0114535:	6a 07                	push   $0x7
f0114537:	6a 03                	push   $0x3
f0114539:	68 07 0e 00 00       	push   $0xe07
f011453e:	68 03 0e 00 00       	push   $0xe03
f0114543:	6a 02                	push   $0x2
f0114545:	50                   	push   %eax
f0114546:	68 00 00 00 40       	push   $0x40000000
f011454b:	68 00 00 00 f0       	push   $0xf0000000
f0114550:	ff 75 cc             	pushl  -0x34(%ebp)
f0114553:	e8 18 28 00 00       	call   f0116d70 <CCP>
f0114558:	83 c4 30             	add    $0x30,%esp
f011455b:	85 c0                	test   %eax,%eax
f011455d:	75 1e                	jne    f011457d <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011455f:	83 ec 04             	sub    $0x4,%esp
f0114562:	68 38 ab 12 f0       	push   $0xf012ab38
f0114567:	68 4b 04 00 00       	push   $0x44b
f011456c:	68 02 98 12 f0       	push   $0xf0129802
f0114571:	e8 60 bf fe ff       	call   f01004d6 <_warn>
f0114576:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114579:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011457d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114581:	74 04                	je     f0114587 <test_share_chunk+0x36d>
f0114583:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114587:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f011458b:	b8 d0 22 6b f2       	mov    $0xf26b22d0,%eax
f0114590:	05 00 00 00 10       	add    $0x10000000,%eax
f0114595:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114598:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011459b:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f01145a0:	83 ec 08             	sub    $0x8,%esp
f01145a3:	6a 02                	push   $0x2
f01145a5:	6a 07                	push   $0x7
f01145a7:	6a 03                	push   $0x3
f01145a9:	68 07 0e 00 00       	push   $0xe07
f01145ae:	68 03 0e 00 00       	push   $0xe03
f01145b3:	6a 02                	push   $0x2
f01145b5:	50                   	push   %eax
f01145b6:	68 00 00 0a 40       	push   $0x400a0000
f01145bb:	68 00 00 0a f0       	push   $0xf00a0000
f01145c0:	ff 75 cc             	pushl  -0x34(%ebp)
f01145c3:	e8 a8 27 00 00       	call   f0116d70 <CCP>
f01145c8:	83 c4 30             	add    $0x30,%esp
f01145cb:	85 c0                	test   %eax,%eax
f01145cd:	75 1e                	jne    f01145ed <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01145cf:	83 ec 04             	sub    $0x4,%esp
f01145d2:	68 38 ab 12 f0       	push   $0xf012ab38
f01145d7:	68 55 04 00 00       	push   $0x455
f01145dc:	68 02 98 12 f0       	push   $0xf0129802
f01145e1:	e8 f0 be fe ff       	call   f01004d6 <_warn>
f01145e6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145e9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01145ed:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145f1:	74 04                	je     f01145f7 <test_share_chunk+0x3dd>
f01145f3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01145f7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01145fb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01145ff:	0f 84 a4 00 00 00    	je     f01146a9 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0114605:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f011460c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011460f:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0114612:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0114619:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011461c:	8a 00                	mov    (%eax),%al
f011461e:	3c 41                	cmp    $0x41,%al
f0114620:	75 09                	jne    f011462b <test_share_chunk+0x411>
f0114622:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114625:	8a 00                	mov    (%eax),%al
f0114627:	3c 41                	cmp    $0x41,%al
f0114629:	74 1e                	je     f0114649 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011462b:	83 ec 04             	sub    $0x4,%esp
f011462e:	68 80 ab 12 f0       	push   $0xf012ab80
f0114633:	68 62 04 00 00       	push   $0x462
f0114638:	68 02 98 12 f0       	push   $0xf0129802
f011463d:	e8 94 be fe ff       	call   f01004d6 <_warn>
f0114642:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114645:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114649:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011464d:	74 04                	je     f0114653 <test_share_chunk+0x439>
f011464f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114653:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0114657:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f011465e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114661:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0114664:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f011466b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011466e:	8a 00                	mov    (%eax),%al
f0114670:	3c 43                	cmp    $0x43,%al
f0114672:	75 09                	jne    f011467d <test_share_chunk+0x463>
f0114674:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114677:	8a 00                	mov    (%eax),%al
f0114679:	3c 43                	cmp    $0x43,%al
f011467b:	74 1e                	je     f011469b <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011467d:	83 ec 04             	sub    $0x4,%esp
f0114680:	68 80 ab 12 f0       	push   $0xf012ab80
f0114685:	68 6d 04 00 00       	push   $0x46d
f011468a:	68 02 98 12 f0       	push   $0xf0129802
f011468f:	e8 42 be fe ff       	call   f01004d6 <_warn>
f0114694:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114697:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011469b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011469f:	74 04                	je     f01146a5 <test_share_chunk+0x48b>
f01146a1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01146a5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01146a9:	83 ec 0c             	sub    $0xc,%esp
f01146ac:	68 8f a1 12 f0       	push   $0xf012a18f
f01146b1:	e8 d5 c8 fe ff       	call   f0100f8b <cprintf>
f01146b6:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f01146b9:	83 ec 0c             	sub    $0xc,%esp
f01146bc:	68 50 ac 12 f0       	push   $0xf012ac50
f01146c1:	e8 c5 c8 fe ff       	call   f0100f8b <cprintf>
f01146c6:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01146c9:	e8 7a a5 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01146ce:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f01146d1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01146d4:	89 d0                	mov    %edx,%eax
f01146d6:	c1 e0 03             	shl    $0x3,%eax
f01146d9:	01 d0                	add    %edx,%eax
f01146db:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01146e2:	01 d0                	add    %edx,%eax
f01146e4:	c1 e0 03             	shl    $0x3,%eax
f01146e7:	83 ec 0c             	sub    $0xc,%esp
f01146ea:	6a 06                	push   $0x6
f01146ec:	50                   	push   %eax
f01146ed:	6a 00                	push   $0x0
f01146ef:	68 00 00 00 40       	push   $0x40000000
f01146f4:	ff 75 cc             	pushl  -0x34(%ebp)
f01146f7:	e8 62 67 ff ff       	call   f010ae5e <share_chunk>
f01146fc:	83 c4 20             	add    $0x20,%esp
f01146ff:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114702:	e8 41 a5 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114707:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011470a:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f011470e:	75 0b                	jne    f011471b <test_share_chunk+0x501>
f0114710:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114713:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114716:	83 f8 01             	cmp    $0x1,%eax
f0114719:	74 28                	je     f0114743 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011471b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011471e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114721:	83 ec 0c             	sub    $0xc,%esp
f0114724:	50                   	push   %eax
f0114725:	ff 75 a0             	pushl  -0x60(%ebp)
f0114728:	68 00 ac 12 f0       	push   $0xf012ac00
f011472d:	68 83 04 00 00       	push   $0x483
f0114732:	68 02 98 12 f0       	push   $0xf0129802
f0114737:	e8 9a bd fe ff       	call   f01004d6 <_warn>
f011473c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011473f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114743:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114747:	74 04                	je     f011474d <test_share_chunk+0x533>
f0114749:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011474d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114751:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114758:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011475b:	05 00 80 02 00       	add    $0x28000,%eax
f0114760:	c1 e0 02             	shl    $0x2,%eax
f0114763:	83 ec 08             	sub    $0x8,%esp
f0114766:	6a 02                	push   $0x2
f0114768:	6a 07                	push   $0x7
f011476a:	6a 03                	push   $0x3
f011476c:	6a 07                	push   $0x7
f011476e:	6a 07                	push   $0x7
f0114770:	6a ff                	push   $0xffffffff
f0114772:	50                   	push   %eax
f0114773:	6a 00                	push   $0x0
f0114775:	68 00 00 00 40       	push   $0x40000000
f011477a:	ff 75 cc             	pushl  -0x34(%ebp)
f011477d:	e8 ee 25 00 00       	call   f0116d70 <CCP>
f0114782:	83 c4 30             	add    $0x30,%esp
f0114785:	85 c0                	test   %eax,%eax
f0114787:	75 25                	jne    f01147ae <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114789:	83 ec 04             	sub    $0x4,%esp
f011478c:	68 38 ab 12 f0       	push   $0xf012ab38
f0114791:	68 8c 04 00 00       	push   $0x48c
f0114796:	68 02 98 12 f0       	push   $0xf0129802
f011479b:	e8 36 bd fe ff       	call   f01004d6 <_warn>
f01147a0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01147a3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01147a7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01147ae:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01147b1:	89 d0                	mov    %edx,%eax
f01147b3:	01 c0                	add    %eax,%eax
f01147b5:	01 d0                	add    %edx,%eax
f01147b7:	c1 e0 02             	shl    $0x2,%eax
f01147ba:	83 ec 08             	sub    $0x8,%esp
f01147bd:	6a 02                	push   $0x2
f01147bf:	6a 07                	push   $0x7
f01147c1:	6a 03                	push   $0x3
f01147c3:	6a 07                	push   $0x7
f01147c5:	6a 07                	push   $0x7
f01147c7:	6a 03                	push   $0x3
f01147c9:	50                   	push   %eax
f01147ca:	6a 00                	push   $0x0
f01147cc:	68 00 00 00 40       	push   $0x40000000
f01147d1:	ff 75 cc             	pushl  -0x34(%ebp)
f01147d4:	e8 97 25 00 00       	call   f0116d70 <CCP>
f01147d9:	83 c4 30             	add    $0x30,%esp
f01147dc:	85 c0                	test   %eax,%eax
f01147de:	75 1e                	jne    f01147fe <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01147e0:	83 ec 04             	sub    $0x4,%esp
f01147e3:	68 38 ab 12 f0       	push   $0xf012ab38
f01147e8:	68 93 04 00 00       	push   $0x493
f01147ed:	68 02 98 12 f0       	push   $0xf0129802
f01147f2:	e8 df bc fe ff       	call   f01004d6 <_warn>
f01147f7:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01147fa:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147fe:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114802:	74 04                	je     f0114808 <test_share_chunk+0x5ee>
f0114804:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114808:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011480c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011480f:	89 d0                	mov    %edx,%eax
f0114811:	01 c0                	add    %eax,%eax
f0114813:	01 d0                	add    %edx,%eax
f0114815:	c1 e0 02             	shl    $0x2,%eax
f0114818:	f7 d8                	neg    %eax
f011481a:	05 00 00 0a 00       	add    $0xa0000,%eax
f011481f:	83 ec 08             	sub    $0x8,%esp
f0114822:	6a 02                	push   $0x2
f0114824:	6a 07                	push   $0x7
f0114826:	6a 03                	push   $0x3
f0114828:	6a 07                	push   $0x7
f011482a:	6a 07                	push   $0x7
f011482c:	6a 02                	push   $0x2
f011482e:	50                   	push   %eax
f011482f:	68 00 30 00 00       	push   $0x3000
f0114834:	68 00 30 00 40       	push   $0x40003000
f0114839:	ff 75 cc             	pushl  -0x34(%ebp)
f011483c:	e8 2f 25 00 00       	call   f0116d70 <CCP>
f0114841:	83 c4 30             	add    $0x30,%esp
f0114844:	85 c0                	test   %eax,%eax
f0114846:	75 1e                	jne    f0114866 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114848:	83 ec 04             	sub    $0x4,%esp
f011484b:	68 38 ab 12 f0       	push   $0xf012ab38
f0114850:	68 9b 04 00 00       	push   $0x49b
f0114855:	68 02 98 12 f0       	push   $0xf0129802
f011485a:	e8 77 bc fe ff       	call   f01004d6 <_warn>
f011485f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114862:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114866:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011486a:	74 04                	je     f0114870 <test_share_chunk+0x656>
f011486c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114870:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114874:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114877:	c1 e0 02             	shl    $0x2,%eax
f011487a:	83 ec 08             	sub    $0x8,%esp
f011487d:	6a 02                	push   $0x2
f011487f:	6a 07                	push   $0x7
f0114881:	6a 03                	push   $0x3
f0114883:	6a 07                	push   $0x7
f0114885:	6a 07                	push   $0x7
f0114887:	6a 03                	push   $0x3
f0114889:	50                   	push   %eax
f011488a:	68 00 00 0a 00       	push   $0xa0000
f011488f:	68 00 00 0a 40       	push   $0x400a0000
f0114894:	ff 75 cc             	pushl  -0x34(%ebp)
f0114897:	e8 d4 24 00 00       	call   f0116d70 <CCP>
f011489c:	83 c4 30             	add    $0x30,%esp
f011489f:	85 c0                	test   %eax,%eax
f01148a1:	75 1e                	jne    f01148c1 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01148a3:	83 ec 04             	sub    $0x4,%esp
f01148a6:	68 38 ab 12 f0       	push   $0xf012ab38
f01148ab:	68 a3 04 00 00       	push   $0x4a3
f01148b0:	68 02 98 12 f0       	push   $0xf0129802
f01148b5:	e8 1c bc fe ff       	call   f01004d6 <_warn>
f01148ba:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01148bd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01148c1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01148c5:	74 04                	je     f01148cb <test_share_chunk+0x6b1>
f01148c7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01148cb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01148cf:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01148d3:	0f 84 92 00 00 00    	je     f011496b <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f01148d9:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f01148e0:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f01148e7:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f01148ee:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f01148f5:	8b 45 98             	mov    -0x68(%ebp),%eax
f01148f8:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f01148fb:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0114902:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114909:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011490c:	8a 00                	mov    (%eax),%al
f011490e:	3c 41                	cmp    $0x41,%al
f0114910:	75 2d                	jne    f011493f <test_share_chunk+0x725>
f0114912:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114915:	8a 00                	mov    (%eax),%al
f0114917:	3c 41                	cmp    $0x41,%al
f0114919:	75 24                	jne    f011493f <test_share_chunk+0x725>
f011491b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011491e:	8a 00                	mov    (%eax),%al
f0114920:	3c 41                	cmp    $0x41,%al
f0114922:	75 1b                	jne    f011493f <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114924:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114927:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114929:	3c 44                	cmp    $0x44,%al
f011492b:	75 12                	jne    f011493f <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f011492d:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114930:	8a 00                	mov    (%eax),%al
f0114932:	3c 44                	cmp    $0x44,%al
f0114934:	75 09                	jne    f011493f <test_share_chunk+0x725>
f0114936:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114939:	8a 00                	mov    (%eax),%al
f011493b:	3c 44                	cmp    $0x44,%al
f011493d:	74 1e                	je     f011495d <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011493f:	83 ec 04             	sub    $0x4,%esp
f0114942:	68 80 ab 12 f0       	push   $0xf012ab80
f0114947:	68 b5 04 00 00       	push   $0x4b5
f011494c:	68 02 98 12 f0       	push   $0xf0129802
f0114951:	e8 80 bb fe ff       	call   f01004d6 <_warn>
f0114956:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114959:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011495d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114961:	74 04                	je     f0114967 <test_share_chunk+0x74d>
f0114963:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114967:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f011496b:	83 ec 0c             	sub    $0xc,%esp
f011496e:	68 f2 a1 12 f0       	push   $0xf012a1f2
f0114973:	e8 13 c6 fe ff       	call   f0100f8b <cprintf>
f0114978:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f011497b:	83 ec 0c             	sub    $0xc,%esp
f011497e:	68 8c ac 12 f0       	push   $0xf012ac8c
f0114983:	e8 03 c6 fe ff       	call   f0100f8b <cprintf>
f0114988:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011498b:	e8 b8 a2 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114990:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0114993:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114996:	89 d0                	mov    %edx,%eax
f0114998:	01 c0                	add    %eax,%eax
f011499a:	01 d0                	add    %edx,%eax
f011499c:	01 c0                	add    %eax,%eax
f011499e:	01 d0                	add    %edx,%eax
f01149a0:	83 ec 0c             	sub    $0xc,%esp
f01149a3:	6a 04                	push   $0x4
f01149a5:	50                   	push   %eax
f01149a6:	68 00 fc 3f 00       	push   $0x3ffc00
f01149ab:	68 00 fc 09 00       	push   $0x9fc00
f01149b0:	ff 75 cc             	pushl  -0x34(%ebp)
f01149b3:	e8 a6 64 ff ff       	call   f010ae5e <share_chunk>
f01149b8:	83 c4 20             	add    $0x20,%esp
f01149bb:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01149be:	e8 85 a2 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01149c3:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f01149c6:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f01149ca:	75 0b                	jne    f01149d7 <test_share_chunk+0x7bd>
f01149cc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01149cf:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01149d2:	83 f8 01             	cmp    $0x1,%eax
f01149d5:	74 28                	je     f01149ff <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01149d7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01149da:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01149dd:	83 ec 0c             	sub    $0xc,%esp
f01149e0:	50                   	push   %eax
f01149e1:	ff 75 8c             	pushl  -0x74(%ebp)
f01149e4:	68 00 ac 12 f0       	push   $0xf012ac00
f01149e9:	68 cb 04 00 00       	push   $0x4cb
f01149ee:	68 02 98 12 f0       	push   $0xf0129802
f01149f3:	e8 de ba fe ff       	call   f01004d6 <_warn>
f01149f8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01149fb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01149ff:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a03:	74 04                	je     f0114a09 <test_share_chunk+0x7ef>
f0114a05:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114a09:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114a0d:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114a14:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114a17:	89 d0                	mov    %edx,%eax
f0114a19:	01 c0                	add    %eax,%eax
f0114a1b:	01 d0                	add    %edx,%eax
f0114a1d:	c1 e0 02             	shl    $0x2,%eax
f0114a20:	83 ec 08             	sub    $0x8,%esp
f0114a23:	6a 02                	push   $0x2
f0114a25:	6a 07                	push   $0x7
f0114a27:	6a 07                	push   $0x7
f0114a29:	6a 07                	push   $0x7
f0114a2b:	6a 05                	push   $0x5
f0114a2d:	6a ff                	push   $0xffffffff
f0114a2f:	50                   	push   %eax
f0114a30:	68 00 f0 3f 00       	push   $0x3ff000
f0114a35:	68 00 f0 09 00       	push   $0x9f000
f0114a3a:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a3d:	e8 2e 23 00 00       	call   f0116d70 <CCP>
f0114a42:	83 c4 30             	add    $0x30,%esp
f0114a45:	85 c0                	test   %eax,%eax
f0114a47:	75 25                	jne    f0114a6e <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114a49:	83 ec 04             	sub    $0x4,%esp
f0114a4c:	68 38 ab 12 f0       	push   $0xf012ab38
f0114a51:	68 d4 04 00 00       	push   $0x4d4
f0114a56:	68 02 98 12 f0       	push   $0xf0129802
f0114a5b:	e8 76 ba fe ff       	call   f01004d6 <_warn>
f0114a60:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114a63:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114a67:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0114a6e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a72:	74 04                	je     f0114a78 <test_share_chunk+0x85e>
f0114a74:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a78:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114a7c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114a7f:	c1 e0 02             	shl    $0x2,%eax
f0114a82:	83 ec 08             	sub    $0x8,%esp
f0114a85:	6a 02                	push   $0x2
f0114a87:	6a 07                	push   $0x7
f0114a89:	6a 07                	push   $0x7
f0114a8b:	6a 07                	push   $0x7
f0114a8d:	6a 05                	push   $0x5
f0114a8f:	6a 03                	push   $0x3
f0114a91:	50                   	push   %eax
f0114a92:	68 00 f0 3f 00       	push   $0x3ff000
f0114a97:	68 00 f0 09 00       	push   $0x9f000
f0114a9c:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a9f:	e8 cc 22 00 00       	call   f0116d70 <CCP>
f0114aa4:	83 c4 30             	add    $0x30,%esp
f0114aa7:	85 c0                	test   %eax,%eax
f0114aa9:	75 1e                	jne    f0114ac9 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114aab:	83 ec 04             	sub    $0x4,%esp
f0114aae:	68 38 ab 12 f0       	push   $0xf012ab38
f0114ab3:	68 dd 04 00 00       	push   $0x4dd
f0114ab8:	68 02 98 12 f0       	push   $0xf0129802
f0114abd:	e8 14 ba fe ff       	call   f01004d6 <_warn>
f0114ac2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114ac5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ac9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114acd:	74 04                	je     f0114ad3 <test_share_chunk+0x8b9>
f0114acf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114ad3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114ad7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114ada:	c1 e0 03             	shl    $0x3,%eax
f0114add:	83 ec 08             	sub    $0x8,%esp
f0114ae0:	6a 02                	push   $0x2
f0114ae2:	6a 07                	push   $0x7
f0114ae4:	6a 07                	push   $0x7
f0114ae6:	6a 07                	push   $0x7
f0114ae8:	6a 05                	push   $0x5
f0114aea:	6a 04                	push   $0x4
f0114aec:	50                   	push   %eax
f0114aed:	68 00 00 40 00       	push   $0x400000
f0114af2:	68 00 00 0a 00       	push   $0xa0000
f0114af7:	ff 75 cc             	pushl  -0x34(%ebp)
f0114afa:	e8 71 22 00 00       	call   f0116d70 <CCP>
f0114aff:	83 c4 30             	add    $0x30,%esp
f0114b02:	85 c0                	test   %eax,%eax
f0114b04:	75 1e                	jne    f0114b24 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114b06:	83 ec 04             	sub    $0x4,%esp
f0114b09:	68 38 ab 12 f0       	push   $0xf012ab38
f0114b0e:	68 e5 04 00 00       	push   $0x4e5
f0114b13:	68 02 98 12 f0       	push   $0xf0129802
f0114b18:	e8 b9 b9 fe ff       	call   f01004d6 <_warn>
f0114b1d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114b20:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114b24:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b28:	74 04                	je     f0114b2e <test_share_chunk+0x914>
f0114b2a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114b2e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114b32:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114b36:	0f 84 b2 00 00 00    	je     f0114bee <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0114b3c:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0114b43:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0114b4a:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0114b51:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0114b58:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0114b5f:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0114b66:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0114b6d:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114b74:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114b77:	8a 00                	mov    (%eax),%al
f0114b79:	3c 44                	cmp    $0x44,%al
f0114b7b:	75 45                	jne    f0114bc2 <test_share_chunk+0x9a8>
f0114b7d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114b80:	8a 00                	mov    (%eax),%al
f0114b82:	3c 44                	cmp    $0x44,%al
f0114b84:	75 3c                	jne    f0114bc2 <test_share_chunk+0x9a8>
f0114b86:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114b89:	8a 00                	mov    (%eax),%al
f0114b8b:	3c 44                	cmp    $0x44,%al
f0114b8d:	75 33                	jne    f0114bc2 <test_share_chunk+0x9a8>
f0114b8f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114b92:	8a 00                	mov    (%eax),%al
f0114b94:	3c 44                	cmp    $0x44,%al
f0114b96:	75 2a                	jne    f0114bc2 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114b98:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114b9b:	8a 10                	mov    (%eax),%dl
f0114b9d:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114ba0:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114ba2:	38 c2                	cmp    %al,%dl
f0114ba4:	75 1c                	jne    f0114bc2 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114ba6:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114ba9:	8a 10                	mov    (%eax),%dl
f0114bab:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114bae:	8a 00                	mov    (%eax),%al
f0114bb0:	38 c2                	cmp    %al,%dl
f0114bb2:	75 0e                	jne    f0114bc2 <test_share_chunk+0x9a8>
f0114bb4:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114bb7:	8a 10                	mov    (%eax),%dl
f0114bb9:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114bbc:	8a 00                	mov    (%eax),%al
f0114bbe:	38 c2                	cmp    %al,%dl
f0114bc0:	74 1e                	je     f0114be0 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114bc2:	83 ec 04             	sub    $0x4,%esp
f0114bc5:	68 80 ab 12 f0       	push   $0xf012ab80
f0114bca:	68 fa 04 00 00       	push   $0x4fa
f0114bcf:	68 02 98 12 f0       	push   $0xf0129802
f0114bd4:	e8 fd b8 fe ff       	call   f01004d6 <_warn>
f0114bd9:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114bdc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114be0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114be4:	74 04                	je     f0114bea <test_share_chunk+0x9d0>
f0114be6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114bea:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114bee:	83 ec 0c             	sub    $0xc,%esp
f0114bf1:	68 c4 ac 12 f0       	push   $0xf012acc4
f0114bf6:	e8 90 c3 fe ff       	call   f0100f8b <cprintf>
f0114bfb:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114bfe:	83 ec 08             	sub    $0x8,%esp
f0114c01:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114c04:	68 d4 ac 12 f0       	push   $0xf012acd4
f0114c09:	e8 7d c3 fe ff       	call   f0100f8b <cprintf>
f0114c0e:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114c11:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114c15:	75 10                	jne    f0114c27 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0114c17:	83 ec 0c             	sub    $0xc,%esp
f0114c1a:	68 04 ad 12 f0       	push   $0xf012ad04
f0114c1f:	e8 67 c3 fe ff       	call   f0100f8b <cprintf>
f0114c24:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114c27:	a1 e4 f8 f1 f0       	mov    0xf0f1f8e4,%eax
f0114c2c:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114c2f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114c32:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114c35:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114c3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114c3d:	5b                   	pop    %ebx
f0114c3e:	5e                   	pop    %esi
f0114c3f:	5f                   	pop    %edi
f0114c40:	5d                   	pop    %ebp
f0114c41:	c3                   	ret    

f0114c42 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0114c42:	55                   	push   %ebp
f0114c43:	89 e5                	mov    %esp,%ebp
f0114c45:	57                   	push   %edi
f0114c46:	56                   	push   %esi
f0114c47:	53                   	push   %ebx
f0114c48:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114c4e:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114c54:	bb 04 9f 12 f0       	mov    $0xf0129f04,%ebx
f0114c59:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114c5e:	89 c7                	mov    %eax,%edi
f0114c60:	89 de                	mov    %ebx,%esi
f0114c62:	89 d1                	mov    %edx,%ecx
f0114c64:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114c66:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0114c6c:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114c71:	b0 00                	mov    $0x0,%al
f0114c73:	89 d7                	mov    %edx,%edi
f0114c75:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114c77:	6a 00                	push   $0x0
f0114c79:	6a 0a                	push   $0xa
f0114c7b:	6a 14                	push   $0x14
f0114c7d:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114c83:	50                   	push   %eax
f0114c84:	e8 1e 66 ff ff       	call   f010b2a7 <env_create>
f0114c89:	83 c4 10             	add    $0x10,%esp
f0114c8c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114c8f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114c92:	8b 40 64             	mov    0x64(%eax),%eax
f0114c95:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114c98:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114c9b:	8b 40 68             	mov    0x68(%eax),%eax
f0114c9e:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114ca1:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114ca4:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114ca7:	83 ec 0c             	sub    $0xc,%esp
f0114caa:	ff 75 cc             	pushl  -0x34(%ebp)
f0114cad:	e8 8a 20 00 00       	call   f0116d3c <ClearUserSpace>
f0114cb2:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114cb5:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114cbc:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114cc3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0114cca:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114cce:	83 ec 0c             	sub    $0xc,%esp
f0114cd1:	68 40 ad 12 f0       	push   $0xf012ad40
f0114cd6:	e8 b0 c2 fe ff       	call   f0100f8b <cprintf>
f0114cdb:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114cde:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114ce5:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114cec:	eb 03                	jmp    f0114cf1 <test_allocate_chunk+0xaf>
f0114cee:	ff 4d e4             	decl   -0x1c(%ebp)
f0114cf1:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114cf8:	76 09                	jbe    f0114d03 <test_allocate_chunk+0xc1>
f0114cfa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114cfd:	8a 00                	mov    (%eax),%al
f0114cff:	84 c0                	test   %al,%al
f0114d01:	74 eb                	je     f0114cee <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114d03:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114d0a:	75 06                	jne    f0114d12 <test_allocate_chunk+0xd0>
f0114d0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114d0f:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114d12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114d15:	8a 00                	mov    (%eax),%al
f0114d17:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0114d1d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114d20:	8a 00                	mov    (%eax),%al
f0114d22:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f0114d28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114d2b:	8a 00                	mov    (%eax),%al
f0114d2d:	0f be c0             	movsbl %al,%eax
f0114d30:	83 ec 08             	sub    $0x8,%esp
f0114d33:	50                   	push   %eax
f0114d34:	68 6a ad 12 f0       	push   $0xf012ad6a
f0114d39:	e8 4d c2 fe ff       	call   f0100f8b <cprintf>
f0114d3e:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0114d41:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114d44:	8a 00                	mov    (%eax),%al
f0114d46:	0f be c0             	movsbl %al,%eax
f0114d49:	83 ec 08             	sub    $0x8,%esp
f0114d4c:	50                   	push   %eax
f0114d4d:	68 76 ad 12 f0       	push   $0xf012ad76
f0114d52:	e8 34 c2 fe ff       	call   f0100f8b <cprintf>
f0114d57:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0114d5a:	83 ec 08             	sub    $0x8,%esp
f0114d5d:	68 00 f0 bf ef       	push   $0xefbff000
f0114d62:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d65:	e8 b3 1f 00 00       	call   f0116d1d <GP>
f0114d6a:	83 c4 10             	add    $0x10,%esp
f0114d6d:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114d70:	e8 d3 9e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114d75:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114d78:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114d7b:	c1 e0 02             	shl    $0x2,%eax
f0114d7e:	6a 02                	push   $0x2
f0114d80:	50                   	push   %eax
f0114d81:	68 00 f0 bf ef       	push   $0xefbff000
f0114d86:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d89:	e8 ea 60 ff ff       	call   f010ae78 <allocate_chunk>
f0114d8e:	83 c4 10             	add    $0x10,%esp
f0114d91:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114d94:	e8 af 9e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114d99:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114d9c:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114da0:	75 08                	jne    f0114daa <test_allocate_chunk+0x168>
f0114da2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114da5:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114da8:	74 2a                	je     f0114dd4 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114daa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114dad:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114db0:	83 ec 08             	sub    $0x8,%esp
f0114db3:	6a 00                	push   $0x0
f0114db5:	50                   	push   %eax
f0114db6:	ff 75 b0             	pushl  -0x50(%ebp)
f0114db9:	68 84 ad 12 f0       	push   $0xf012ad84
f0114dbe:	68 3a 05 00 00       	push   $0x53a
f0114dc3:	68 02 98 12 f0       	push   $0xf0129802
f0114dc8:	e8 09 b7 fe ff       	call   f01004d6 <_warn>
f0114dcd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114dd0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114dd4:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114dd8:	74 04                	je     f0114dde <test_allocate_chunk+0x19c>
f0114dda:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114dde:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114de2:	e8 61 9e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114de7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0114dea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114ded:	01 c0                	add    %eax,%eax
f0114def:	89 c1                	mov    %eax,%ecx
f0114df1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114df4:	89 d0                	mov    %edx,%eax
f0114df6:	c1 e0 02             	shl    $0x2,%eax
f0114df9:	01 d0                	add    %edx,%eax
f0114dfb:	f7 d8                	neg    %eax
f0114dfd:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114e02:	6a 02                	push   $0x2
f0114e04:	51                   	push   %ecx
f0114e05:	50                   	push   %eax
f0114e06:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e09:	e8 6a 60 ff ff       	call   f010ae78 <allocate_chunk>
f0114e0e:	83 c4 10             	add    $0x10,%esp
f0114e11:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114e14:	e8 2f 9e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114e19:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114e1c:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114e20:	75 08                	jne    f0114e2a <test_allocate_chunk+0x1e8>
f0114e22:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114e25:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114e28:	74 2a                	je     f0114e54 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114e2a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114e2d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114e30:	83 ec 08             	sub    $0x8,%esp
f0114e33:	6a 00                	push   $0x0
f0114e35:	50                   	push   %eax
f0114e36:	ff 75 b0             	pushl  -0x50(%ebp)
f0114e39:	68 84 ad 12 f0       	push   $0xf012ad84
f0114e3e:	68 48 05 00 00       	push   $0x548
f0114e43:	68 02 98 12 f0       	push   $0xf0129802
f0114e48:	e8 89 b6 fe ff       	call   f01004d6 <_warn>
f0114e4d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e50:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114e54:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114e58:	74 04                	je     f0114e5e <test_allocate_chunk+0x21c>
f0114e5a:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114e5e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0114e62:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114e65:	c1 e0 02             	shl    $0x2,%eax
f0114e68:	83 ec 08             	sub    $0x8,%esp
f0114e6b:	6a 03                	push   $0x3
f0114e6d:	6a 00                	push   $0x0
f0114e6f:	6a 00                	push   $0x0
f0114e71:	68 ff 0f 00 00       	push   $0xfff
f0114e76:	ff 75 b8             	pushl  -0x48(%ebp)
f0114e79:	6a 01                	push   $0x1
f0114e7b:	50                   	push   %eax
f0114e7c:	68 00 f0 bf ef       	push   $0xefbff000
f0114e81:	6a 00                	push   $0x0
f0114e83:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e86:	e8 e5 1e 00 00       	call   f0116d70 <CCP>
f0114e8b:	83 c4 30             	add    $0x30,%esp
f0114e8e:	85 c0                	test   %eax,%eax
f0114e90:	75 1e                	jne    f0114eb0 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114e92:	83 ec 04             	sub    $0x4,%esp
f0114e95:	68 ec ad 12 f0       	push   $0xf012adec
f0114e9a:	68 50 05 00 00       	push   $0x550
f0114e9f:	68 02 98 12 f0       	push   $0xf0129802
f0114ea4:	e8 2d b6 fe ff       	call   f01004d6 <_warn>
f0114ea9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114eac:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114eb0:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114eb4:	74 04                	je     f0114eba <test_allocate_chunk+0x278>
f0114eb6:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114eba:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114ebe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114ec1:	8a 10                	mov    (%eax),%dl
f0114ec3:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0114ec9:	38 c2                	cmp    %al,%dl
f0114ecb:	75 0f                	jne    f0114edc <test_allocate_chunk+0x29a>
f0114ecd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114ed0:	8a 10                	mov    (%eax),%dl
f0114ed2:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0114ed8:	38 c2                	cmp    %al,%dl
f0114eda:	74 1e                	je     f0114efa <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114edc:	83 ec 04             	sub    $0x4,%esp
f0114edf:	68 38 ae 12 f0       	push   $0xf012ae38
f0114ee4:	68 58 05 00 00       	push   $0x558
f0114ee9:	68 02 98 12 f0       	push   $0xf0129802
f0114eee:	e8 e3 b5 fe ff       	call   f01004d6 <_warn>
f0114ef3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114ef6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114efa:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114efe:	74 04                	je     f0114f04 <test_allocate_chunk+0x2c2>
f0114f00:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114f04:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114f08:	83 ec 0c             	sub    $0xc,%esp
f0114f0b:	68 b5 ab 12 f0       	push   $0xf012abb5
f0114f10:	e8 76 c0 fe ff       	call   f0100f8b <cprintf>
f0114f15:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0114f18:	83 ec 0c             	sub    $0xc,%esp
f0114f1b:	68 70 ae 12 f0       	push   $0xf012ae70
f0114f20:	e8 66 c0 fe ff       	call   f0100f8b <cprintf>
f0114f25:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114f28:	e8 1b 9d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114f2d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114f30:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f33:	c1 e0 05             	shl    $0x5,%eax
f0114f36:	68 02 0e 00 00       	push   $0xe02
f0114f3b:	50                   	push   %eax
f0114f3c:	6a 00                	push   $0x0
f0114f3e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f41:	e8 32 5f ff ff       	call   f010ae78 <allocate_chunk>
f0114f46:	83 c4 10             	add    $0x10,%esp
f0114f49:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114f4c:	e8 f7 9c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114f51:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0114f54:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114f58:	75 36                	jne    f0114f90 <test_allocate_chunk+0x34e>
f0114f5a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114f5d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114f60:	89 c1                	mov    %eax,%ecx
f0114f62:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f65:	c1 e0 05             	shl    $0x5,%eax
f0114f68:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114f6b:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114f72:	99                   	cltd   
f0114f73:	f7 fe                	idiv   %esi
f0114f75:	89 c3                	mov    %eax,%ebx
f0114f77:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f7a:	c1 e0 05             	shl    $0x5,%eax
f0114f7d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114f80:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114f87:	99                   	cltd   
f0114f88:	f7 fe                	idiv   %esi
f0114f8a:	01 d8                	add    %ebx,%eax
f0114f8c:	39 c1                	cmp    %eax,%ecx
f0114f8e:	74 54                	je     f0114fe4 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0114f90:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f93:	c1 e0 05             	shl    $0x5,%eax
f0114f96:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114f99:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114fa0:	99                   	cltd   
f0114fa1:	f7 ff                	idiv   %edi
f0114fa3:	89 c1                	mov    %eax,%ecx
f0114fa5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fa8:	c1 e0 05             	shl    $0x5,%eax
f0114fab:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114fae:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114fb5:	99                   	cltd   
f0114fb6:	f7 fe                	idiv   %esi
f0114fb8:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114fbb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114fbe:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114fc1:	83 ec 08             	sub    $0x8,%esp
f0114fc4:	52                   	push   %edx
f0114fc5:	50                   	push   %eax
f0114fc6:	ff 75 a8             	pushl  -0x58(%ebp)
f0114fc9:	68 b0 ae 12 f0       	push   $0xf012aeb0
f0114fce:	68 6d 05 00 00       	push   $0x56d
f0114fd3:	68 02 98 12 f0       	push   $0xf0129802
f0114fd8:	e8 f9 b4 fe ff       	call   f01004d6 <_warn>
f0114fdd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114fe0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114fe4:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114fe8:	74 04                	je     f0114fee <test_allocate_chunk+0x3ac>
f0114fea:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114fee:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114ff2:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114ff9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ffc:	c1 e0 05             	shl    $0x5,%eax
f0114fff:	83 ec 08             	sub    $0x8,%esp
f0115002:	6a 03                	push   $0x3
f0115004:	6a 00                	push   $0x0
f0115006:	6a 00                	push   $0x0
f0115008:	68 07 0e 00 00       	push   $0xe07
f011500d:	68 03 0e 00 00       	push   $0xe03
f0115012:	6a 01                	push   $0x1
f0115014:	50                   	push   %eax
f0115015:	6a 00                	push   $0x0
f0115017:	6a 00                	push   $0x0
f0115019:	ff 75 cc             	pushl  -0x34(%ebp)
f011501c:	e8 4f 1d 00 00       	call   f0116d70 <CCP>
f0115021:	83 c4 30             	add    $0x30,%esp
f0115024:	85 c0                	test   %eax,%eax
f0115026:	75 25                	jne    f011504d <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115028:	83 ec 04             	sub    $0x4,%esp
f011502b:	68 ec ad 12 f0       	push   $0xf012adec
f0115030:	68 76 05 00 00       	push   $0x576
f0115035:	68 02 98 12 f0       	push   $0xf0129802
f011503a:	e8 97 b4 fe ff       	call   f01004d6 <_warn>
f011503f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115042:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115046:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f011504d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115051:	74 04                	je     f0115057 <test_allocate_chunk+0x415>
f0115053:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115057:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f011505b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011505f:	74 5a                	je     f01150bb <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0115061:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115064:	01 c0                	add    %eax,%eax
f0115066:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0115069:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011506c:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f011506f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115072:	01 c0                	add    %eax,%eax
f0115074:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0115077:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011507a:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f011507d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115080:	8a 00                	mov    (%eax),%al
f0115082:	3c 4b                	cmp    $0x4b,%al
f0115084:	75 09                	jne    f011508f <test_allocate_chunk+0x44d>
f0115086:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115089:	8a 00                	mov    (%eax),%al
f011508b:	3c 4d                	cmp    $0x4d,%al
f011508d:	74 1e                	je     f01150ad <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011508f:	83 ec 04             	sub    $0x4,%esp
f0115092:	68 38 ae 12 f0       	push   $0xf012ae38
f0115097:	68 84 05 00 00       	push   $0x584
f011509c:	68 02 98 12 f0       	push   $0xf0129802
f01150a1:	e8 30 b4 fe ff       	call   f01004d6 <_warn>
f01150a6:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01150a9:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01150ad:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01150b1:	74 04                	je     f01150b7 <test_allocate_chunk+0x475>
f01150b3:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01150b7:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01150bb:	83 ec 0c             	sub    $0xc,%esp
f01150be:	68 8f a1 12 f0       	push   $0xf012a18f
f01150c3:	e8 c3 be fe ff       	call   f0100f8b <cprintf>
f01150c8:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f01150cb:	83 ec 0c             	sub    $0xc,%esp
f01150ce:	68 10 af 12 f0       	push   $0xf012af10
f01150d3:	e8 b3 be fe ff       	call   f0100f8b <cprintf>
f01150d8:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01150db:	e8 68 9b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01150e0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f01150e3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01150e6:	c1 e0 06             	shl    $0x6,%eax
f01150e9:	89 c2                	mov    %eax,%edx
f01150eb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01150ee:	c1 e0 05             	shl    $0x5,%eax
f01150f1:	6a 00                	push   $0x0
f01150f3:	52                   	push   %edx
f01150f4:	50                   	push   %eax
f01150f5:	ff 75 cc             	pushl  -0x34(%ebp)
f01150f8:	e8 7b 5d ff ff       	call   f010ae78 <allocate_chunk>
f01150fd:	83 c4 10             	add    $0x10,%esp
f0115100:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115103:	e8 40 9b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0115108:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f011510b:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f011510f:	75 36                	jne    f0115147 <test_allocate_chunk+0x505>
f0115111:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115114:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115117:	89 c1                	mov    %eax,%ecx
f0115119:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011511c:	c1 e0 06             	shl    $0x6,%eax
f011511f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115122:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0115129:	99                   	cltd   
f011512a:	f7 ff                	idiv   %edi
f011512c:	89 c3                	mov    %eax,%ebx
f011512e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115131:	c1 e0 06             	shl    $0x6,%eax
f0115134:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115137:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011513e:	99                   	cltd   
f011513f:	f7 fe                	idiv   %esi
f0115141:	01 d8                	add    %ebx,%eax
f0115143:	39 c1                	cmp    %eax,%ecx
f0115145:	74 54                	je     f011519b <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0115147:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011514a:	c1 e0 06             	shl    $0x6,%eax
f011514d:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115150:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115157:	99                   	cltd   
f0115158:	f7 fb                	idiv   %ebx
f011515a:	89 c1                	mov    %eax,%ecx
f011515c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011515f:	c1 e0 06             	shl    $0x6,%eax
f0115162:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115165:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011516c:	99                   	cltd   
f011516d:	f7 ff                	idiv   %edi
f011516f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0115172:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115175:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115178:	83 ec 08             	sub    $0x8,%esp
f011517b:	52                   	push   %edx
f011517c:	50                   	push   %eax
f011517d:	ff 75 a4             	pushl  -0x5c(%ebp)
f0115180:	68 b0 ae 12 f0       	push   $0xf012aeb0
f0115185:	68 9a 05 00 00       	push   $0x59a
f011518a:	68 02 98 12 f0       	push   $0xf0129802
f011518f:	e8 42 b3 fe ff       	call   f01004d6 <_warn>
f0115194:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115197:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f011519b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011519f:	74 04                	je     f01151a5 <test_allocate_chunk+0x563>
f01151a1:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01151a5:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01151a9:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01151b0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151b3:	c1 e0 06             	shl    $0x6,%eax
f01151b6:	89 c2                	mov    %eax,%edx
f01151b8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151bb:	c1 e0 05             	shl    $0x5,%eax
f01151be:	83 ec 08             	sub    $0x8,%esp
f01151c1:	6a 03                	push   $0x3
f01151c3:	6a 00                	push   $0x0
f01151c5:	6a 00                	push   $0x0
f01151c7:	68 07 0e 00 00       	push   $0xe07
f01151cc:	6a 01                	push   $0x1
f01151ce:	6a 01                	push   $0x1
f01151d0:	52                   	push   %edx
f01151d1:	50                   	push   %eax
f01151d2:	6a 00                	push   $0x0
f01151d4:	ff 75 cc             	pushl  -0x34(%ebp)
f01151d7:	e8 94 1b 00 00       	call   f0116d70 <CCP>
f01151dc:	83 c4 30             	add    $0x30,%esp
f01151df:	85 c0                	test   %eax,%eax
f01151e1:	75 25                	jne    f0115208 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01151e3:	83 ec 04             	sub    $0x4,%esp
f01151e6:	68 ec ad 12 f0       	push   $0xf012adec
f01151eb:	68 a3 05 00 00       	push   $0x5a3
f01151f0:	68 02 98 12 f0       	push   $0xf0129802
f01151f5:	e8 dc b2 fe ff       	call   f01004d6 <_warn>
f01151fa:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01151fd:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115201:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0115208:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011520c:	74 04                	je     f0115212 <test_allocate_chunk+0x5d0>
f011520e:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115212:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0115216:	83 ec 0c             	sub    $0xc,%esp
f0115219:	68 f2 a1 12 f0       	push   $0xf012a1f2
f011521e:	e8 68 bd fe ff       	call   f0100f8b <cprintf>
f0115223:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0115226:	83 ec 0c             	sub    $0xc,%esp
f0115229:	68 50 af 12 f0       	push   $0xf012af50
f011522e:	e8 58 bd fe ff       	call   f0100f8b <cprintf>
f0115233:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115236:	e8 0d 9a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011523b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f011523e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115241:	c1 e0 06             	shl    $0x6,%eax
f0115244:	68 06 0e 00 00       	push   $0xe06
f0115249:	50                   	push   %eax
f011524a:	68 00 00 00 80       	push   $0x80000000
f011524f:	ff 75 cc             	pushl  -0x34(%ebp)
f0115252:	e8 21 5c ff ff       	call   f010ae78 <allocate_chunk>
f0115257:	83 c4 10             	add    $0x10,%esp
f011525a:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011525d:	e8 e6 99 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0115262:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0115265:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0115269:	75 36                	jne    f01152a1 <test_allocate_chunk+0x65f>
f011526b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011526e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115271:	89 c1                	mov    %eax,%ecx
f0115273:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115276:	c1 e0 06             	shl    $0x6,%eax
f0115279:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011527c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115283:	99                   	cltd   
f0115284:	f7 fb                	idiv   %ebx
f0115286:	89 c3                	mov    %eax,%ebx
f0115288:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011528b:	c1 e0 06             	shl    $0x6,%eax
f011528e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115291:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115298:	99                   	cltd   
f0115299:	f7 fe                	idiv   %esi
f011529b:	01 d8                	add    %ebx,%eax
f011529d:	39 c1                	cmp    %eax,%ecx
f011529f:	74 54                	je     f01152f5 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f01152a1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152a4:	c1 e0 06             	shl    $0x6,%eax
f01152a7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01152aa:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01152b1:	99                   	cltd   
f01152b2:	f7 ff                	idiv   %edi
f01152b4:	89 c1                	mov    %eax,%ecx
f01152b6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152b9:	c1 e0 06             	shl    $0x6,%eax
f01152bc:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01152bf:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01152c6:	99                   	cltd   
f01152c7:	f7 fb                	idiv   %ebx
f01152c9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01152cc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01152cf:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01152d2:	83 ec 08             	sub    $0x8,%esp
f01152d5:	52                   	push   %edx
f01152d6:	50                   	push   %eax
f01152d7:	ff 75 9c             	pushl  -0x64(%ebp)
f01152da:	68 b0 ae 12 f0       	push   $0xf012aeb0
f01152df:	68 b9 05 00 00       	push   $0x5b9
f01152e4:	68 02 98 12 f0       	push   $0xf0129802
f01152e9:	e8 e8 b1 fe ff       	call   f01004d6 <_warn>
f01152ee:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152f1:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01152f5:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01152f9:	74 04                	je     f01152ff <test_allocate_chunk+0x6bd>
f01152fb:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01152ff:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115303:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011530a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011530d:	c1 e0 06             	shl    $0x6,%eax
f0115310:	83 ec 08             	sub    $0x8,%esp
f0115313:	6a 03                	push   $0x3
f0115315:	6a 00                	push   $0x0
f0115317:	6a 00                	push   $0x0
f0115319:	68 07 0e 00 00       	push   $0xe07
f011531e:	68 07 0e 00 00       	push   $0xe07
f0115323:	6a 01                	push   $0x1
f0115325:	50                   	push   %eax
f0115326:	68 00 00 00 80       	push   $0x80000000
f011532b:	6a 00                	push   $0x0
f011532d:	ff 75 cc             	pushl  -0x34(%ebp)
f0115330:	e8 3b 1a 00 00       	call   f0116d70 <CCP>
f0115335:	83 c4 30             	add    $0x30,%esp
f0115338:	85 c0                	test   %eax,%eax
f011533a:	75 25                	jne    f0115361 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011533c:	83 ec 04             	sub    $0x4,%esp
f011533f:	68 ec ad 12 f0       	push   $0xf012adec
f0115344:	68 c2 05 00 00       	push   $0x5c2
f0115349:	68 02 98 12 f0       	push   $0xf0129802
f011534e:	e8 83 b1 fe ff       	call   f01004d6 <_warn>
f0115353:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115356:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011535a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0115361:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115365:	74 04                	je     f011536b <test_allocate_chunk+0x729>
f0115367:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011536b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f011536f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0115373:	74 6f                	je     f01153e4 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0115375:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115378:	01 c0                	add    %eax,%eax
f011537a:	05 00 00 00 80       	add    $0x80000000,%eax
f011537f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0115382:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115385:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0115388:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011538b:	89 d0                	mov    %edx,%eax
f011538d:	c1 e0 02             	shl    $0x2,%eax
f0115390:	01 d0                	add    %edx,%eax
f0115392:	01 c0                	add    %eax,%eax
f0115394:	01 d0                	add    %edx,%eax
f0115396:	01 c0                	add    %eax,%eax
f0115398:	05 00 00 00 80       	add    $0x80000000,%eax
f011539d:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01153a0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01153a3:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f01153a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01153a9:	8a 00                	mov    (%eax),%al
f01153ab:	3c 4b                	cmp    $0x4b,%al
f01153ad:	75 09                	jne    f01153b8 <test_allocate_chunk+0x776>
f01153af:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01153b2:	8a 00                	mov    (%eax),%al
f01153b4:	3c 4d                	cmp    $0x4d,%al
f01153b6:	74 1e                	je     f01153d6 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01153b8:	83 ec 04             	sub    $0x4,%esp
f01153bb:	68 38 ae 12 f0       	push   $0xf012ae38
f01153c0:	68 d0 05 00 00       	push   $0x5d0
f01153c5:	68 02 98 12 f0       	push   $0xf0129802
f01153ca:	e8 07 b1 fe ff       	call   f01004d6 <_warn>
f01153cf:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01153d2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01153d6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01153da:	74 04                	je     f01153e0 <test_allocate_chunk+0x79e>
f01153dc:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01153e0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f01153e4:	83 ec 0c             	sub    $0xc,%esp
f01153e7:	68 c4 ac 12 f0       	push   $0xf012acc4
f01153ec:	e8 9a bb fe ff       	call   f0100f8b <cprintf>
f01153f1:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f01153f4:	83 ec 0c             	sub    $0xc,%esp
f01153f7:	68 8c af 12 f0       	push   $0xf012af8c
f01153fc:	e8 8a bb fe ff       	call   f0100f8b <cprintf>
f0115401:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115404:	e8 3f 98 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0115409:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f011540c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011540f:	89 d0                	mov    %edx,%eax
f0115411:	01 c0                	add    %eax,%eax
f0115413:	01 d0                	add    %edx,%eax
f0115415:	01 c0                	add    %eax,%eax
f0115417:	01 d0                	add    %edx,%eax
f0115419:	68 04 0e 00 00       	push   $0xe04
f011541e:	50                   	push   %eax
f011541f:	68 00 fc 3f 40       	push   $0x403ffc00
f0115424:	ff 75 cc             	pushl  -0x34(%ebp)
f0115427:	e8 4c 5a ff ff       	call   f010ae78 <allocate_chunk>
f011542c:	83 c4 10             	add    $0x10,%esp
f011542f:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115432:	e8 11 98 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0115437:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f011543a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f011543e:	75 0b                	jne    f011544b <test_allocate_chunk+0x809>
f0115440:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115443:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115446:	83 f8 05             	cmp    $0x5,%eax
f0115449:	74 2a                	je     f0115475 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f011544b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011544e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115451:	83 ec 08             	sub    $0x8,%esp
f0115454:	6a 05                	push   $0x5
f0115456:	50                   	push   %eax
f0115457:	ff 75 98             	pushl  -0x68(%ebp)
f011545a:	68 b0 ae 12 f0       	push   $0xf012aeb0
f011545f:	68 e7 05 00 00       	push   $0x5e7
f0115464:	68 02 98 12 f0       	push   $0xf0129802
f0115469:	e8 68 b0 fe ff       	call   f01004d6 <_warn>
f011546e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115471:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115475:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115479:	74 04                	je     f011547f <test_allocate_chunk+0x83d>
f011547b:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011547f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115483:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011548a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011548d:	89 d0                	mov    %edx,%eax
f011548f:	01 c0                	add    %eax,%eax
f0115491:	01 d0                	add    %edx,%eax
f0115493:	c1 e0 02             	shl    $0x2,%eax
f0115496:	83 ec 08             	sub    $0x8,%esp
f0115499:	6a 03                	push   $0x3
f011549b:	6a 00                	push   $0x0
f011549d:	6a 00                	push   $0x0
f011549f:	68 07 0e 00 00       	push   $0xe07
f01154a4:	68 05 0e 00 00       	push   $0xe05
f01154a9:	6a 01                	push   $0x1
f01154ab:	50                   	push   %eax
f01154ac:	68 00 f0 3f 40       	push   $0x403ff000
f01154b1:	6a 00                	push   $0x0
f01154b3:	ff 75 cc             	pushl  -0x34(%ebp)
f01154b6:	e8 b5 18 00 00       	call   f0116d70 <CCP>
f01154bb:	83 c4 30             	add    $0x30,%esp
f01154be:	85 c0                	test   %eax,%eax
f01154c0:	75 25                	jne    f01154e7 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01154c2:	83 ec 04             	sub    $0x4,%esp
f01154c5:	68 ec ad 12 f0       	push   $0xf012adec
f01154ca:	68 f0 05 00 00       	push   $0x5f0
f01154cf:	68 02 98 12 f0       	push   $0xf0129802
f01154d4:	e8 fd af fe ff       	call   f01004d6 <_warn>
f01154d9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01154dc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01154e0:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f01154e7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01154eb:	74 04                	je     f01154f1 <test_allocate_chunk+0x8af>
f01154ed:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01154f1:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f01154f5:	83 ec 0c             	sub    $0xc,%esp
f01154f8:	68 c3 af 12 f0       	push   $0xf012afc3
f01154fd:	e8 89 ba fe ff       	call   f0100f8b <cprintf>
f0115502:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0115505:	83 ec 08             	sub    $0x8,%esp
f0115508:	ff 75 e0             	pushl  -0x20(%ebp)
f011550b:	68 d4 af 12 f0       	push   $0xf012afd4
f0115510:	e8 76 ba fe ff       	call   f0100f8b <cprintf>
f0115515:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115518:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f011551c:	75 10                	jne    f011552e <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f011551e:	83 ec 0c             	sub    $0xc,%esp
f0115521:	68 08 b0 12 f0       	push   $0xf012b008
f0115526:	e8 60 ba fe ff       	call   f0100f8b <cprintf>
f011552b:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011552e:	a1 e4 f8 f1 f0       	mov    0xf0f1f8e4,%eax
f0115533:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0115536:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115539:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011553c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115541:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115544:	5b                   	pop    %ebx
f0115545:	5e                   	pop    %esi
f0115546:	5f                   	pop    %edi
f0115547:	5d                   	pop    %ebp
f0115548:	c3                   	ret    

f0115549 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0115549:	55                   	push   %ebp
f011554a:	89 e5                	mov    %esp,%ebp
f011554c:	57                   	push   %edi
f011554d:	56                   	push   %esi
f011554e:	53                   	push   %ebx
f011554f:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115555:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115558:	bb 04 9f 12 f0       	mov    $0xf0129f04,%ebx
f011555d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115562:	89 c7                	mov    %eax,%edi
f0115564:	89 de                	mov    %ebx,%esi
f0115566:	89 d1                	mov    %edx,%ecx
f0115568:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011556a:	8d 55 9d             	lea    -0x63(%ebp),%edx
f011556d:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115572:	b0 00                	mov    $0x0,%al
f0115574:	89 d7                	mov    %edx,%edi
f0115576:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115578:	6a 00                	push   $0x0
f011557a:	6a 0a                	push   $0xa
f011557c:	6a 14                	push   $0x14
f011557e:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115581:	50                   	push   %eax
f0115582:	e8 20 5d ff ff       	call   f010b2a7 <env_create>
f0115587:	83 c4 10             	add    $0x10,%esp
f011558a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011558d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115590:	8b 40 64             	mov    0x64(%eax),%eax
f0115593:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115596:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115599:	8b 40 68             	mov    0x68(%eax),%eax
f011559c:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011559f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01155a2:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01155a5:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01155ac:	75 70 20 
f01155af:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01155b6:	00 00 00 
f01155b9:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01155bc:	b9 03 00 00 00       	mov    $0x3,%ecx
f01155c1:	b8 00 00 00 00       	mov    $0x0,%eax
f01155c6:	89 d7                	mov    %edx,%edi
f01155c8:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01155ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01155cd:	8b 40 10             	mov    0x10(%eax),%eax
f01155d0:	83 ec 08             	sub    $0x8,%esp
f01155d3:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01155d9:	52                   	push   %edx
f01155da:	50                   	push   %eax
f01155db:	e8 28 ae 00 00       	call   f0120408 <ltostr>
f01155e0:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01155e3:	83 ec 04             	sub    $0x4,%esp
f01155e6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01155ec:	50                   	push   %eax
f01155ed:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01155f3:	50                   	push   %eax
f01155f4:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01155fa:	50                   	push   %eax
f01155fb:	e8 e1 ae 00 00       	call   f01204e1 <strcconcat>
f0115600:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115603:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011560a:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115611:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0115618:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f011561f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0115623:	83 ec 0c             	sub    $0xc,%esp
f0115626:	ff 75 d8             	pushl  -0x28(%ebp)
f0115629:	e8 0e 17 00 00       	call   f0116d3c <ClearUserSpace>
f011562e:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115631:	83 ec 0c             	sub    $0xc,%esp
f0115634:	68 48 b0 12 f0       	push   $0xf012b048
f0115639:	e8 4d b9 fe ff       	call   f0100f8b <cprintf>
f011563e:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115641:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115644:	c1 e0 03             	shl    $0x3,%eax
f0115647:	83 ec 04             	sub    $0x4,%esp
f011564a:	50                   	push   %eax
f011564b:	6a 00                	push   $0x0
f011564d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115650:	e8 57 58 ff ff       	call   f010aeac <calculate_required_frames>
f0115655:	83 c4 10             	add    $0x10,%esp
f0115658:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011565b:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011565f:	74 23                	je     f0115684 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115661:	83 ec 0c             	sub    $0xc,%esp
f0115664:	6a 03                	push   $0x3
f0115666:	ff 75 c8             	pushl  -0x38(%ebp)
f0115669:	68 7c b0 12 f0       	push   $0xf012b07c
f011566e:	68 29 06 00 00       	push   $0x629
f0115673:	68 02 98 12 f0       	push   $0xf0129802
f0115678:	e8 59 ae fe ff       	call   f01004d6 <_warn>
f011567d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115680:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115684:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115688:	74 04                	je     f011568e <test_calculate_required_frames+0x145>
f011568a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011568e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0115692:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115695:	c1 e0 02             	shl    $0x2,%eax
f0115698:	83 ec 04             	sub    $0x4,%esp
f011569b:	50                   	push   %eax
f011569c:	6a 00                	push   $0x0
f011569e:	ff 75 d8             	pushl  -0x28(%ebp)
f01156a1:	e8 06 58 ff ff       	call   f010aeac <calculate_required_frames>
f01156a6:	83 c4 10             	add    $0x10,%esp
f01156a9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f01156ac:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f01156b3:	74 26                	je     f01156db <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f01156b5:	83 ec 0c             	sub    $0xc,%esp
f01156b8:	68 01 04 00 00       	push   $0x401
f01156bd:	ff 75 c8             	pushl  -0x38(%ebp)
f01156c0:	68 7c b0 12 f0       	push   $0xf012b07c
f01156c5:	68 33 06 00 00       	push   $0x633
f01156ca:	68 02 98 12 f0       	push   $0xf0129802
f01156cf:	e8 02 ae fe ff       	call   f01004d6 <_warn>
f01156d4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156d7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01156db:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01156df:	74 04                	je     f01156e5 <test_calculate_required_frames+0x19c>
f01156e1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01156e5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01156e9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01156ec:	c1 e0 0a             	shl    $0xa,%eax
f01156ef:	83 ec 04             	sub    $0x4,%esp
f01156f2:	50                   	push   %eax
f01156f3:	6a 00                	push   $0x0
f01156f5:	ff 75 d8             	pushl  -0x28(%ebp)
f01156f8:	e8 af 57 ff ff       	call   f010aeac <calculate_required_frames>
f01156fd:	83 c4 10             	add    $0x10,%esp
f0115700:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115703:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115706:	c1 e0 0a             	shl    $0xa,%eax
f0115709:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011570c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115713:	99                   	cltd   
f0115714:	f7 fb                	idiv   %ebx
f0115716:	89 c1                	mov    %eax,%ecx
f0115718:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011571b:	c1 e0 0a             	shl    $0xa,%eax
f011571e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115721:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115728:	99                   	cltd   
f0115729:	f7 fe                	idiv   %esi
f011572b:	01 c8                	add    %ecx,%eax
f011572d:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115730:	74 4c                	je     f011577e <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0115732:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115735:	c1 e0 0a             	shl    $0xa,%eax
f0115738:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011573b:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115742:	99                   	cltd   
f0115743:	f7 fb                	idiv   %ebx
f0115745:	89 c1                	mov    %eax,%ecx
f0115747:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011574a:	c1 e0 0a             	shl    $0xa,%eax
f011574d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115750:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115757:	99                   	cltd   
f0115758:	f7 fe                	idiv   %esi
f011575a:	01 c8                	add    %ecx,%eax
f011575c:	83 ec 0c             	sub    $0xc,%esp
f011575f:	50                   	push   %eax
f0115760:	ff 75 c8             	pushl  -0x38(%ebp)
f0115763:	68 7c b0 12 f0       	push   $0xf012b07c
f0115768:	68 3d 06 00 00       	push   $0x63d
f011576d:	68 02 98 12 f0       	push   $0xf0129802
f0115772:	e8 5f ad fe ff       	call   f01004d6 <_warn>
f0115777:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011577a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011577e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115782:	74 04                	je     f0115788 <test_calculate_required_frames+0x23f>
f0115784:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115788:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f011578c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011578f:	89 d0                	mov    %edx,%eax
f0115791:	01 c0                	add    %eax,%eax
f0115793:	01 d0                	add    %edx,%eax
f0115795:	01 c0                	add    %eax,%eax
f0115797:	83 ec 04             	sub    $0x4,%esp
f011579a:	50                   	push   %eax
f011579b:	68 00 10 00 00       	push   $0x1000
f01157a0:	ff 75 d8             	pushl  -0x28(%ebp)
f01157a3:	e8 04 57 ff ff       	call   f010aeac <calculate_required_frames>
f01157a8:	83 c4 10             	add    $0x10,%esp
f01157ab:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01157ae:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01157b2:	74 23                	je     f01157d7 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01157b4:	83 ec 0c             	sub    $0xc,%esp
f01157b7:	6a 03                	push   $0x3
f01157b9:	ff 75 c8             	pushl  -0x38(%ebp)
f01157bc:	68 7c b0 12 f0       	push   $0xf012b07c
f01157c1:	68 49 06 00 00       	push   $0x649
f01157c6:	68 02 98 12 f0       	push   $0xf0129802
f01157cb:	e8 06 ad fe ff       	call   f01004d6 <_warn>
f01157d0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157d3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01157d7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01157db:	74 04                	je     f01157e1 <test_calculate_required_frames+0x298>
f01157dd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01157e1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01157e5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01157e8:	89 c2                	mov    %eax,%edx
f01157ea:	01 d2                	add    %edx,%edx
f01157ec:	01 d0                	add    %edx,%eax
f01157ee:	83 ec 04             	sub    $0x4,%esp
f01157f1:	50                   	push   %eax
f01157f2:	68 00 18 00 00       	push   $0x1800
f01157f7:	ff 75 d8             	pushl  -0x28(%ebp)
f01157fa:	e8 ad 56 ff ff       	call   f010aeac <calculate_required_frames>
f01157ff:	83 c4 10             	add    $0x10,%esp
f0115802:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115805:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115809:	74 23                	je     f011582e <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011580b:	83 ec 0c             	sub    $0xc,%esp
f011580e:	6a 03                	push   $0x3
f0115810:	ff 75 c8             	pushl  -0x38(%ebp)
f0115813:	68 7c b0 12 f0       	push   $0xf012b07c
f0115818:	68 53 06 00 00       	push   $0x653
f011581d:	68 02 98 12 f0       	push   $0xf0129802
f0115822:	e8 af ac fe ff       	call   f01004d6 <_warn>
f0115827:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011582a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011582e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115832:	74 04                	je     f0115838 <test_calculate_required_frames+0x2ef>
f0115834:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115838:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f011583c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011583f:	89 d0                	mov    %edx,%eax
f0115841:	c1 e0 02             	shl    $0x2,%eax
f0115844:	01 d0                	add    %edx,%eax
f0115846:	01 c0                	add    %eax,%eax
f0115848:	83 ec 04             	sub    $0x4,%esp
f011584b:	50                   	push   %eax
f011584c:	68 00 00 40 00       	push   $0x400000
f0115851:	ff 75 d8             	pushl  -0x28(%ebp)
f0115854:	e8 53 56 ff ff       	call   f010aeac <calculate_required_frames>
f0115859:	83 c4 10             	add    $0x10,%esp
f011585c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f011585f:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0115866:	74 26                	je     f011588e <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115868:	83 ec 0c             	sub    $0xc,%esp
f011586b:	68 03 0a 00 00       	push   $0xa03
f0115870:	ff 75 c8             	pushl  -0x38(%ebp)
f0115873:	68 7c b0 12 f0       	push   $0xf012b07c
f0115878:	68 5d 06 00 00       	push   $0x65d
f011587d:	68 02 98 12 f0       	push   $0xf0129802
f0115882:	e8 4f ac fe ff       	call   f01004d6 <_warn>
f0115887:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011588a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011588e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115892:	74 04                	je     f0115898 <test_calculate_required_frames+0x34f>
f0115894:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115898:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f011589c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011589f:	01 c0                	add    %eax,%eax
f01158a1:	83 ec 04             	sub    $0x4,%esp
f01158a4:	50                   	push   %eax
f01158a5:	68 00 00 70 00       	push   $0x700000
f01158aa:	ff 75 d8             	pushl  -0x28(%ebp)
f01158ad:	e8 fa 55 ff ff       	call   f010aeac <calculate_required_frames>
f01158b2:	83 c4 10             	add    $0x10,%esp
f01158b5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f01158b8:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f01158bf:	74 26                	je     f01158e7 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f01158c1:	83 ec 0c             	sub    $0xc,%esp
f01158c4:	68 02 02 00 00       	push   $0x202
f01158c9:	ff 75 c8             	pushl  -0x38(%ebp)
f01158cc:	68 7c b0 12 f0       	push   $0xf012b07c
f01158d1:	68 69 06 00 00       	push   $0x669
f01158d6:	68 02 98 12 f0       	push   $0xf0129802
f01158db:	e8 f6 ab fe ff       	call   f01004d6 <_warn>
f01158e0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158e3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01158e7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01158eb:	74 04                	je     f01158f1 <test_calculate_required_frames+0x3a8>
f01158ed:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01158f1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01158f5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01158f8:	83 ec 04             	sub    $0x4,%esp
f01158fb:	50                   	push   %eax
f01158fc:	68 ff ff 3f 00       	push   $0x3fffff
f0115901:	ff 75 d8             	pushl  -0x28(%ebp)
f0115904:	e8 a3 55 ff ff       	call   f010aeac <calculate_required_frames>
f0115909:	83 c4 10             	add    $0x10,%esp
f011590c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f011590f:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0115913:	74 23                	je     f0115938 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0115915:	83 ec 0c             	sub    $0xc,%esp
f0115918:	6a 04                	push   $0x4
f011591a:	ff 75 c8             	pushl  -0x38(%ebp)
f011591d:	68 7c b0 12 f0       	push   $0xf012b07c
f0115922:	68 73 06 00 00       	push   $0x673
f0115927:	68 02 98 12 f0       	push   $0xf0129802
f011592c:	e8 a5 ab fe ff       	call   f01004d6 <_warn>
f0115931:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115934:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115938:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011593c:	74 04                	je     f0115942 <test_calculate_required_frames+0x3f9>
f011593e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115942:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115946:	83 ec 0c             	sub    $0xc,%esp
f0115949:	68 b5 ab 12 f0       	push   $0xf012abb5
f011594e:	e8 38 b6 fe ff       	call   f0100f8b <cprintf>
f0115953:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115956:	83 ec 0c             	sub    $0xc,%esp
f0115959:	68 d4 b0 12 f0       	push   $0xf012b0d4
f011595e:	e8 28 b6 fe ff       	call   f0100f8b <cprintf>
f0115963:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115966:	83 ec 04             	sub    $0x4,%esp
f0115969:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011596f:	50                   	push   %eax
f0115970:	68 6e 9f 12 f0       	push   $0xf0129f6e
f0115975:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011597b:	50                   	push   %eax
f011597c:	e8 60 ab 00 00       	call   f01204e1 <strcconcat>
f0115981:	83 c4 10             	add    $0x10,%esp
f0115984:	83 ec 0c             	sub    $0xc,%esp
f0115987:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011598d:	50                   	push   %eax
f011598e:	e8 68 c5 fe ff       	call   f0101efb <execute_command>
f0115993:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115996:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115999:	c1 e0 03             	shl    $0x3,%eax
f011599c:	83 ec 04             	sub    $0x4,%esp
f011599f:	50                   	push   %eax
f01159a0:	6a 00                	push   $0x0
f01159a2:	ff 75 d8             	pushl  -0x28(%ebp)
f01159a5:	e8 02 55 ff ff       	call   f010aeac <calculate_required_frames>
f01159aa:	83 c4 10             	add    $0x10,%esp
f01159ad:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01159b0:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01159b7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01159ba:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01159bd:	74 24                	je     f01159e3 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01159bf:	83 ec 0c             	sub    $0xc,%esp
f01159c2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01159c5:	ff 75 c8             	pushl  -0x38(%ebp)
f01159c8:	68 7c b0 12 f0       	push   $0xf012b07c
f01159cd:	68 87 06 00 00       	push   $0x687
f01159d2:	68 02 98 12 f0       	push   $0xf0129802
f01159d7:	e8 fa aa fe ff       	call   f01004d6 <_warn>
f01159dc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159df:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01159e3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159e7:	74 04                	je     f01159ed <test_calculate_required_frames+0x4a4>
f01159e9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01159ed:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01159f1:	83 ec 04             	sub    $0x4,%esp
f01159f4:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01159fa:	50                   	push   %eax
f01159fb:	68 7b 9f 12 f0       	push   $0xf0129f7b
f0115a00:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115a06:	50                   	push   %eax
f0115a07:	e8 d5 aa 00 00       	call   f01204e1 <strcconcat>
f0115a0c:	83 c4 10             	add    $0x10,%esp
f0115a0f:	83 ec 0c             	sub    $0xc,%esp
f0115a12:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115a18:	50                   	push   %eax
f0115a19:	e8 dd c4 fe ff       	call   f0101efb <execute_command>
f0115a1e:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115a21:	83 ec 04             	sub    $0x4,%esp
f0115a24:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115a2a:	50                   	push   %eax
f0115a2b:	68 08 b1 12 f0       	push   $0xf012b108
f0115a30:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115a36:	50                   	push   %eax
f0115a37:	e8 a5 aa 00 00       	call   f01204e1 <strcconcat>
f0115a3c:	83 c4 10             	add    $0x10,%esp
f0115a3f:	83 ec 0c             	sub    $0xc,%esp
f0115a42:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115a48:	50                   	push   %eax
f0115a49:	e8 ad c4 fe ff       	call   f0101efb <execute_command>
f0115a4e:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0115a51:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a54:	c1 e0 03             	shl    $0x3,%eax
f0115a57:	83 ec 04             	sub    $0x4,%esp
f0115a5a:	50                   	push   %eax
f0115a5b:	6a 00                	push   $0x0
f0115a5d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a60:	e8 47 54 ff ff       	call   f010aeac <calculate_required_frames>
f0115a65:	83 c4 10             	add    $0x10,%esp
f0115a68:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0115a6b:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0115a72:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115a75:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115a78:	74 24                	je     f0115a9e <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115a7a:	83 ec 0c             	sub    $0xc,%esp
f0115a7d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115a80:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a83:	68 7c b0 12 f0       	push   $0xf012b07c
f0115a88:	68 95 06 00 00       	push   $0x695
f0115a8d:	68 02 98 12 f0       	push   $0xf0129802
f0115a92:	e8 3f aa fe ff       	call   f01004d6 <_warn>
f0115a97:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a9a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a9e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115aa2:	74 04                	je     f0115aa8 <test_calculate_required_frames+0x55f>
f0115aa4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115aa8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115aac:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115aaf:	c1 e0 0a             	shl    $0xa,%eax
f0115ab2:	83 ec 04             	sub    $0x4,%esp
f0115ab5:	50                   	push   %eax
f0115ab6:	6a 00                	push   $0x0
f0115ab8:	ff 75 d8             	pushl  -0x28(%ebp)
f0115abb:	e8 ec 53 ff ff       	call   f010aeac <calculate_required_frames>
f0115ac0:	83 c4 10             	add    $0x10,%esp
f0115ac3:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115ac6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115ac9:	c1 e0 0a             	shl    $0xa,%eax
f0115acc:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115acf:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115ad6:	99                   	cltd   
f0115ad7:	f7 fb                	idiv   %ebx
f0115ad9:	89 c1                	mov    %eax,%ecx
f0115adb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115ade:	c1 e0 0a             	shl    $0xa,%eax
f0115ae1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115ae4:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115aeb:	99                   	cltd   
f0115aec:	f7 fe                	idiv   %esi
f0115aee:	01 c8                	add    %ecx,%eax
f0115af0:	83 e8 05             	sub    $0x5,%eax
f0115af3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115af6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115af9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115afc:	74 24                	je     f0115b22 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115afe:	83 ec 0c             	sub    $0xc,%esp
f0115b01:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115b04:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b07:	68 7c b0 12 f0       	push   $0xf012b07c
f0115b0c:	68 a0 06 00 00       	push   $0x6a0
f0115b11:	68 02 98 12 f0       	push   $0xf0129802
f0115b16:	e8 bb a9 fe ff       	call   f01004d6 <_warn>
f0115b1b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b1e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115b22:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b26:	74 04                	je     f0115b2c <test_calculate_required_frames+0x5e3>
f0115b28:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115b2c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115b30:	83 ec 04             	sub    $0x4,%esp
f0115b33:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115b39:	50                   	push   %eax
f0115b3a:	68 14 b1 12 f0       	push   $0xf012b114
f0115b3f:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115b45:	50                   	push   %eax
f0115b46:	e8 96 a9 00 00       	call   f01204e1 <strcconcat>
f0115b4b:	83 c4 10             	add    $0x10,%esp
f0115b4e:	83 ec 0c             	sub    $0xc,%esp
f0115b51:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115b57:	50                   	push   %eax
f0115b58:	e8 9e c3 fe ff       	call   f0101efb <execute_command>
f0115b5d:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115b60:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115b63:	89 c2                	mov    %eax,%edx
f0115b65:	01 d2                	add    %edx,%edx
f0115b67:	01 d0                	add    %edx,%eax
f0115b69:	83 ec 04             	sub    $0x4,%esp
f0115b6c:	50                   	push   %eax
f0115b6d:	68 00 18 00 00       	push   $0x1800
f0115b72:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b75:	e8 32 53 ff ff       	call   f010aeac <calculate_required_frames>
f0115b7a:	83 c4 10             	add    $0x10,%esp
f0115b7d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115b80:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115b87:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115b8a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115b8d:	74 24                	je     f0115bb3 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115b8f:	83 ec 0c             	sub    $0xc,%esp
f0115b92:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115b95:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b98:	68 7c b0 12 f0       	push   $0xf012b07c
f0115b9d:	68 af 06 00 00       	push   $0x6af
f0115ba2:	68 02 98 12 f0       	push   $0xf0129802
f0115ba7:	e8 2a a9 fe ff       	call   f01004d6 <_warn>
f0115bac:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115baf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115bb3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115bb7:	74 04                	je     f0115bbd <test_calculate_required_frames+0x674>
f0115bb9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115bbd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115bc1:	83 ec 04             	sub    $0x4,%esp
f0115bc4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115bca:	50                   	push   %eax
f0115bcb:	68 d4 a1 12 f0       	push   $0xf012a1d4
f0115bd0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115bd6:	50                   	push   %eax
f0115bd7:	e8 05 a9 00 00       	call   f01204e1 <strcconcat>
f0115bdc:	83 c4 10             	add    $0x10,%esp
f0115bdf:	83 ec 0c             	sub    $0xc,%esp
f0115be2:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115be8:	50                   	push   %eax
f0115be9:	e8 0d c3 fe ff       	call   f0101efb <execute_command>
f0115bee:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115bf1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115bf4:	89 d0                	mov    %edx,%eax
f0115bf6:	c1 e0 02             	shl    $0x2,%eax
f0115bf9:	01 d0                	add    %edx,%eax
f0115bfb:	01 c0                	add    %eax,%eax
f0115bfd:	83 ec 04             	sub    $0x4,%esp
f0115c00:	50                   	push   %eax
f0115c01:	68 00 00 40 00       	push   $0x400000
f0115c06:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c09:	e8 9e 52 ff ff       	call   f010aeac <calculate_required_frames>
f0115c0e:	83 c4 10             	add    $0x10,%esp
f0115c11:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115c14:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f0115c1b:	74 26                	je     f0115c43 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115c1d:	83 ec 0c             	sub    $0xc,%esp
f0115c20:	68 03 0a 00 00       	push   $0xa03
f0115c25:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c28:	68 7c b0 12 f0       	push   $0xf012b07c
f0115c2d:	68 bb 06 00 00       	push   $0x6bb
f0115c32:	68 02 98 12 f0       	push   $0xf0129802
f0115c37:	e8 9a a8 fe ff       	call   f01004d6 <_warn>
f0115c3c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c3f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115c43:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115c47:	74 04                	je     f0115c4d <test_calculate_required_frames+0x704>
f0115c49:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115c4d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115c51:	83 ec 04             	sub    $0x4,%esp
f0115c54:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115c5a:	50                   	push   %eax
f0115c5b:	68 de a1 12 f0       	push   $0xf012a1de
f0115c60:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c66:	50                   	push   %eax
f0115c67:	e8 75 a8 00 00       	call   f01204e1 <strcconcat>
f0115c6c:	83 c4 10             	add    $0x10,%esp
f0115c6f:	83 ec 0c             	sub    $0xc,%esp
f0115c72:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115c78:	50                   	push   %eax
f0115c79:	e8 7d c2 fe ff       	call   f0101efb <execute_command>
f0115c7e:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115c81:	83 ec 04             	sub    $0x4,%esp
f0115c84:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115c8a:	50                   	push   %eax
f0115c8b:	68 1c b1 12 f0       	push   $0xf012b11c
f0115c90:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c96:	50                   	push   %eax
f0115c97:	e8 45 a8 00 00       	call   f01204e1 <strcconcat>
f0115c9c:	83 c4 10             	add    $0x10,%esp
f0115c9f:	83 ec 0c             	sub    $0xc,%esp
f0115ca2:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115ca8:	50                   	push   %eax
f0115ca9:	e8 4d c2 fe ff       	call   f0101efb <execute_command>
f0115cae:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115cb1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115cb4:	01 c0                	add    %eax,%eax
f0115cb6:	83 ec 04             	sub    $0x4,%esp
f0115cb9:	50                   	push   %eax
f0115cba:	68 00 00 70 00       	push   $0x700000
f0115cbf:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cc2:	e8 e5 51 ff ff       	call   f010aeac <calculate_required_frames>
f0115cc7:	83 c4 10             	add    $0x10,%esp
f0115cca:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115ccd:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115cd4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115cd7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115cda:	74 24                	je     f0115d00 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115cdc:	83 ec 0c             	sub    $0xc,%esp
f0115cdf:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115ce2:	ff 75 c8             	pushl  -0x38(%ebp)
f0115ce5:	68 7c b0 12 f0       	push   $0xf012b07c
f0115cea:	68 cb 06 00 00       	push   $0x6cb
f0115cef:	68 02 98 12 f0       	push   $0xf0129802
f0115cf4:	e8 dd a7 fe ff       	call   f01004d6 <_warn>
f0115cf9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115cfc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115d00:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d04:	74 04                	je     f0115d0a <test_calculate_required_frames+0x7c1>
f0115d06:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115d0a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115d0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115d11:	83 ec 04             	sub    $0x4,%esp
f0115d14:	50                   	push   %eax
f0115d15:	68 ff ff 3f 00       	push   $0x3fffff
f0115d1a:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d1d:	e8 8a 51 ff ff       	call   f010aeac <calculate_required_frames>
f0115d22:	83 c4 10             	add    $0x10,%esp
f0115d25:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f0115d28:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115d2f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115d32:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115d35:	74 24                	je     f0115d5b <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115d37:	83 ec 0c             	sub    $0xc,%esp
f0115d3a:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d3d:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d40:	68 7c b0 12 f0       	push   $0xf012b07c
f0115d45:	68 d6 06 00 00       	push   $0x6d6
f0115d4a:	68 02 98 12 f0       	push   $0xf0129802
f0115d4f:	e8 82 a7 fe ff       	call   f01004d6 <_warn>
f0115d54:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d57:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115d5b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d5f:	74 04                	je     f0115d65 <test_calculate_required_frames+0x81c>
f0115d61:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115d65:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0115d69:	83 ec 0c             	sub    $0xc,%esp
f0115d6c:	68 8f a1 12 f0       	push   $0xf012a18f
f0115d71:	e8 15 b2 fe ff       	call   f0100f8b <cprintf>
f0115d76:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0115d79:	83 ec 08             	sub    $0x8,%esp
f0115d7c:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115d7f:	68 28 b1 12 f0       	push   $0xf012b128
f0115d84:	e8 02 b2 fe ff       	call   f0100f8b <cprintf>
f0115d89:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115d8c:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115d90:	75 10                	jne    f0115da2 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115d92:	83 ec 0c             	sub    $0xc,%esp
f0115d95:	68 68 b1 12 f0       	push   $0xf012b168
f0115d9a:	e8 ec b1 fe ff       	call   f0100f8b <cprintf>
f0115d9f:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115da2:	a1 e4 f8 f1 f0       	mov    0xf0f1f8e4,%eax
f0115da7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115daa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115dad:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115db0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115db5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115db8:	5b                   	pop    %ebx
f0115db9:	5e                   	pop    %esi
f0115dba:	5f                   	pop    %edi
f0115dbb:	5d                   	pop    %ebp
f0115dbc:	c3                   	ret    

f0115dbd <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115dbd:	55                   	push   %ebp
f0115dbe:	89 e5                	mov    %esp,%ebp
f0115dc0:	57                   	push   %edi
f0115dc1:	56                   	push   %esi
f0115dc2:	53                   	push   %ebx
f0115dc3:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115dc9:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115dcc:	bb 04 9f 12 f0       	mov    $0xf0129f04,%ebx
f0115dd1:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115dd6:	89 c7                	mov    %eax,%edi
f0115dd8:	89 de                	mov    %ebx,%esi
f0115dda:	89 d1                	mov    %edx,%ecx
f0115ddc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115dde:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115de1:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115de6:	b0 00                	mov    $0x0,%al
f0115de8:	89 d7                	mov    %edx,%edi
f0115dea:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115dec:	6a 00                	push   $0x0
f0115dee:	6a 0a                	push   $0xa
f0115df0:	6a 14                	push   $0x14
f0115df2:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115df5:	50                   	push   %eax
f0115df6:	e8 ac 54 ff ff       	call   f010b2a7 <env_create>
f0115dfb:	83 c4 10             	add    $0x10,%esp
f0115dfe:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115e01:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115e04:	8b 40 64             	mov    0x64(%eax),%eax
f0115e07:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115e0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115e0d:	8b 40 68             	mov    0x68(%eax),%eax
f0115e10:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115e13:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115e16:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115e19:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115e20:	75 70 20 
f0115e23:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115e2a:	00 00 00 
f0115e2d:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115e30:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115e35:	b8 00 00 00 00       	mov    $0x0,%eax
f0115e3a:	89 d7                	mov    %edx,%edi
f0115e3c:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115e3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115e41:	8b 40 10             	mov    0x10(%eax),%eax
f0115e44:	83 ec 08             	sub    $0x8,%esp
f0115e47:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115e4d:	52                   	push   %edx
f0115e4e:	50                   	push   %eax
f0115e4f:	e8 b4 a5 00 00       	call   f0120408 <ltostr>
f0115e54:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115e57:	83 ec 04             	sub    $0x4,%esp
f0115e5a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115e60:	50                   	push   %eax
f0115e61:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115e67:	50                   	push   %eax
f0115e68:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115e6e:	50                   	push   %eax
f0115e6f:	e8 6d a6 00 00       	call   f01204e1 <strcconcat>
f0115e74:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115e77:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115e7e:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115e85:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0115e8c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115e90:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115e97:	00 00 00 
	uint32 num_tables = 0;
f0115e9a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115ea1:	00 00 00 
	ClearUserSpace(proc_directory);
f0115ea4:	83 ec 0c             	sub    $0xc,%esp
f0115ea7:	ff 75 d8             	pushl  -0x28(%ebp)
f0115eaa:	e8 8d 0e 00 00       	call   f0116d3c <ClearUserSpace>
f0115eaf:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115eb2:	83 ec 0c             	sub    $0xc,%esp
f0115eb5:	68 48 b0 12 f0       	push   $0xf012b048
f0115eba:	e8 cc b0 fe ff       	call   f0100f8b <cprintf>
f0115ebf:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115ec2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115ec5:	c1 e0 03             	shl    $0x3,%eax
f0115ec8:	89 c2                	mov    %eax,%edx
f0115eca:	83 ec 0c             	sub    $0xc,%esp
f0115ecd:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115ed3:	50                   	push   %eax
f0115ed4:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115eda:	50                   	push   %eax
f0115edb:	52                   	push   %edx
f0115edc:	6a 00                	push   $0x0
f0115ede:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ee1:	e8 ac 4f ff ff       	call   f010ae92 <calculate_allocated_space>
f0115ee6:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115ee9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115eef:	85 c0                	test   %eax,%eax
f0115ef1:	74 27                	je     f0115f1a <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115ef3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ef9:	83 ec 0c             	sub    $0xc,%esp
f0115efc:	6a 00                	push   $0x0
f0115efe:	50                   	push   %eax
f0115eff:	68 b4 b1 12 f0       	push   $0xf012b1b4
f0115f04:	68 0b 07 00 00       	push   $0x70b
f0115f09:	68 02 98 12 f0       	push   $0xf0129802
f0115f0e:	e8 c3 a5 fe ff       	call   f01004d6 <_warn>
f0115f13:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f16:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115f1a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f20:	85 c0                	test   %eax,%eax
f0115f22:	74 27                	je     f0115f4b <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115f24:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f2a:	83 ec 0c             	sub    $0xc,%esp
f0115f2d:	6a 00                	push   $0x0
f0115f2f:	50                   	push   %eax
f0115f30:	68 14 b2 12 f0       	push   $0xf012b214
f0115f35:	68 10 07 00 00       	push   $0x710
f0115f3a:	68 02 98 12 f0       	push   $0xf0129802
f0115f3f:	e8 92 a5 fe ff       	call   f01004d6 <_warn>
f0115f44:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f47:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f4b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f4f:	74 04                	je     f0115f55 <test_calculate_allocated_space+0x198>
f0115f51:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f55:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0115f59:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115f60:	00 00 00 
		num_pages = 0;
f0115f63:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115f6a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0115f6d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115f70:	c1 e0 02             	shl    $0x2,%eax
f0115f73:	89 c2                	mov    %eax,%edx
f0115f75:	83 ec 0c             	sub    $0xc,%esp
f0115f78:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f7e:	50                   	push   %eax
f0115f7f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f85:	50                   	push   %eax
f0115f86:	52                   	push   %edx
f0115f87:	6a 00                	push   $0x0
f0115f89:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f8c:	e8 01 4f ff ff       	call   f010ae92 <calculate_allocated_space>
f0115f91:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115f94:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f9a:	85 c0                	test   %eax,%eax
f0115f9c:	74 27                	je     f0115fc5 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115f9e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115fa4:	83 ec 0c             	sub    $0xc,%esp
f0115fa7:	6a 00                	push   $0x0
f0115fa9:	50                   	push   %eax
f0115faa:	68 b4 b1 12 f0       	push   $0xf012b1b4
f0115faf:	68 1c 07 00 00       	push   $0x71c
f0115fb4:	68 02 98 12 f0       	push   $0xf0129802
f0115fb9:	e8 18 a5 fe ff       	call   f01004d6 <_warn>
f0115fbe:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fc1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115fc5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fcb:	85 c0                	test   %eax,%eax
f0115fcd:	74 27                	je     f0115ff6 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115fcf:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fd5:	83 ec 0c             	sub    $0xc,%esp
f0115fd8:	6a 00                	push   $0x0
f0115fda:	50                   	push   %eax
f0115fdb:	68 14 b2 12 f0       	push   $0xf012b214
f0115fe0:	68 21 07 00 00       	push   $0x721
f0115fe5:	68 02 98 12 f0       	push   $0xf0129802
f0115fea:	e8 e7 a4 fe ff       	call   f01004d6 <_warn>
f0115fef:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ff2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115ff6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ffa:	74 04                	je     f0116000 <test_calculate_allocated_space+0x243>
f0115ffc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116000:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116004:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011600b:	00 00 00 
		num_pages = 0;
f011600e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116015:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0116018:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011601b:	c1 e0 0a             	shl    $0xa,%eax
f011601e:	89 c2                	mov    %eax,%edx
f0116020:	83 ec 0c             	sub    $0xc,%esp
f0116023:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116029:	50                   	push   %eax
f011602a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116030:	50                   	push   %eax
f0116031:	52                   	push   %edx
f0116032:	6a 00                	push   $0x0
f0116034:	ff 75 d8             	pushl  -0x28(%ebp)
f0116037:	e8 56 4e ff ff       	call   f010ae92 <calculate_allocated_space>
f011603c:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011603f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116045:	85 c0                	test   %eax,%eax
f0116047:	74 27                	je     f0116070 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116049:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011604f:	83 ec 0c             	sub    $0xc,%esp
f0116052:	6a 00                	push   $0x0
f0116054:	50                   	push   %eax
f0116055:	68 b4 b1 12 f0       	push   $0xf012b1b4
f011605a:	68 2d 07 00 00       	push   $0x72d
f011605f:	68 02 98 12 f0       	push   $0xf0129802
f0116064:	e8 6d a4 fe ff       	call   f01004d6 <_warn>
f0116069:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011606c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116070:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116076:	85 c0                	test   %eax,%eax
f0116078:	74 27                	je     f01160a1 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011607a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116080:	83 ec 0c             	sub    $0xc,%esp
f0116083:	6a 00                	push   $0x0
f0116085:	50                   	push   %eax
f0116086:	68 14 b2 12 f0       	push   $0xf012b214
f011608b:	68 32 07 00 00       	push   $0x732
f0116090:	68 02 98 12 f0       	push   $0xf0129802
f0116095:	e8 3c a4 fe ff       	call   f01004d6 <_warn>
f011609a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011609d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01160a1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160a5:	74 04                	je     f01160ab <test_calculate_allocated_space+0x2ee>
f01160a7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01160ab:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f01160af:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160b6:	00 00 00 
		num_pages = 0;
f01160b9:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01160c0:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f01160c3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01160c6:	89 d0                	mov    %edx,%eax
f01160c8:	01 c0                	add    %eax,%eax
f01160ca:	01 d0                	add    %edx,%eax
f01160cc:	01 c0                	add    %eax,%eax
f01160ce:	05 00 10 00 00       	add    $0x1000,%eax
f01160d3:	89 c2                	mov    %eax,%edx
f01160d5:	83 ec 0c             	sub    $0xc,%esp
f01160d8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01160de:	50                   	push   %eax
f01160df:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01160e5:	50                   	push   %eax
f01160e6:	52                   	push   %edx
f01160e7:	68 00 10 00 00       	push   $0x1000
f01160ec:	ff 75 d8             	pushl  -0x28(%ebp)
f01160ef:	e8 9e 4d ff ff       	call   f010ae92 <calculate_allocated_space>
f01160f4:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01160f7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160fd:	85 c0                	test   %eax,%eax
f01160ff:	74 27                	je     f0116128 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116101:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116107:	83 ec 0c             	sub    $0xc,%esp
f011610a:	6a 00                	push   $0x0
f011610c:	50                   	push   %eax
f011610d:	68 b4 b1 12 f0       	push   $0xf012b1b4
f0116112:	68 3f 07 00 00       	push   $0x73f
f0116117:	68 02 98 12 f0       	push   $0xf0129802
f011611c:	e8 b5 a3 fe ff       	call   f01004d6 <_warn>
f0116121:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116124:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116128:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011612e:	85 c0                	test   %eax,%eax
f0116130:	74 27                	je     f0116159 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116132:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116138:	83 ec 0c             	sub    $0xc,%esp
f011613b:	6a 00                	push   $0x0
f011613d:	50                   	push   %eax
f011613e:	68 14 b2 12 f0       	push   $0xf012b214
f0116143:	68 44 07 00 00       	push   $0x744
f0116148:	68 02 98 12 f0       	push   $0xf0129802
f011614d:	e8 84 a3 fe ff       	call   f01004d6 <_warn>
f0116152:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116155:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116159:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011615d:	74 04                	je     f0116163 <test_calculate_allocated_space+0x3a6>
f011615f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116163:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0116167:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011616e:	00 00 00 
		num_pages = 0;
f0116171:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116178:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f011617b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011617e:	89 c2                	mov    %eax,%edx
f0116180:	01 d2                	add    %edx,%edx
f0116182:	01 d0                	add    %edx,%eax
f0116184:	05 00 18 00 00       	add    $0x1800,%eax
f0116189:	89 c2                	mov    %eax,%edx
f011618b:	83 ec 0c             	sub    $0xc,%esp
f011618e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116194:	50                   	push   %eax
f0116195:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011619b:	50                   	push   %eax
f011619c:	52                   	push   %edx
f011619d:	68 00 18 00 00       	push   $0x1800
f01161a2:	ff 75 d8             	pushl  -0x28(%ebp)
f01161a5:	e8 e8 4c ff ff       	call   f010ae92 <calculate_allocated_space>
f01161aa:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01161ad:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161b3:	85 c0                	test   %eax,%eax
f01161b5:	74 27                	je     f01161de <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01161b7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161bd:	83 ec 0c             	sub    $0xc,%esp
f01161c0:	6a 00                	push   $0x0
f01161c2:	50                   	push   %eax
f01161c3:	68 b4 b1 12 f0       	push   $0xf012b1b4
f01161c8:	68 50 07 00 00       	push   $0x750
f01161cd:	68 02 98 12 f0       	push   $0xf0129802
f01161d2:	e8 ff a2 fe ff       	call   f01004d6 <_warn>
f01161d7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01161da:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01161de:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161e4:	85 c0                	test   %eax,%eax
f01161e6:	74 27                	je     f011620f <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01161e8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161ee:	83 ec 0c             	sub    $0xc,%esp
f01161f1:	6a 00                	push   $0x0
f01161f3:	50                   	push   %eax
f01161f4:	68 14 b2 12 f0       	push   $0xf012b214
f01161f9:	68 55 07 00 00       	push   $0x755
f01161fe:	68 02 98 12 f0       	push   $0xf0129802
f0116203:	e8 ce a2 fe ff       	call   f01004d6 <_warn>
f0116208:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011620b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011620f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116213:	74 04                	je     f0116219 <test_calculate_allocated_space+0x45c>
f0116215:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116219:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f011621d:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116224:	00 00 00 
		num_pages = 0;
f0116227:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011622e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116231:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116234:	89 d0                	mov    %edx,%eax
f0116236:	c1 e0 02             	shl    $0x2,%eax
f0116239:	01 d0                	add    %edx,%eax
f011623b:	01 c0                	add    %eax,%eax
f011623d:	05 00 00 40 00       	add    $0x400000,%eax
f0116242:	89 c2                	mov    %eax,%edx
f0116244:	83 ec 0c             	sub    $0xc,%esp
f0116247:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011624d:	50                   	push   %eax
f011624e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116254:	50                   	push   %eax
f0116255:	52                   	push   %edx
f0116256:	68 00 00 40 00       	push   $0x400000
f011625b:	ff 75 d8             	pushl  -0x28(%ebp)
f011625e:	e8 2f 4c ff ff       	call   f010ae92 <calculate_allocated_space>
f0116263:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116266:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011626c:	85 c0                	test   %eax,%eax
f011626e:	74 27                	je     f0116297 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116270:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116276:	83 ec 0c             	sub    $0xc,%esp
f0116279:	6a 00                	push   $0x0
f011627b:	50                   	push   %eax
f011627c:	68 b4 b1 12 f0       	push   $0xf012b1b4
f0116281:	68 61 07 00 00       	push   $0x761
f0116286:	68 02 98 12 f0       	push   $0xf0129802
f011628b:	e8 46 a2 fe ff       	call   f01004d6 <_warn>
f0116290:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116293:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116297:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011629d:	85 c0                	test   %eax,%eax
f011629f:	74 27                	je     f01162c8 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01162a1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01162a7:	83 ec 0c             	sub    $0xc,%esp
f01162aa:	6a 00                	push   $0x0
f01162ac:	50                   	push   %eax
f01162ad:	68 14 b2 12 f0       	push   $0xf012b214
f01162b2:	68 66 07 00 00       	push   $0x766
f01162b7:	68 02 98 12 f0       	push   $0xf0129802
f01162bc:	e8 15 a2 fe ff       	call   f01004d6 <_warn>
f01162c1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162c4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01162c8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162cc:	74 04                	je     f01162d2 <test_calculate_allocated_space+0x515>
f01162ce:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162d2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f01162d6:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01162dd:	00 00 00 
		num_pages = 0;
f01162e0:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01162e7:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01162ea:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01162ed:	05 00 00 38 00       	add    $0x380000,%eax
f01162f2:	01 c0                	add    %eax,%eax
f01162f4:	89 c2                	mov    %eax,%edx
f01162f6:	83 ec 0c             	sub    $0xc,%esp
f01162f9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01162ff:	50                   	push   %eax
f0116300:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116306:	50                   	push   %eax
f0116307:	52                   	push   %edx
f0116308:	68 00 00 70 00       	push   $0x700000
f011630d:	ff 75 d8             	pushl  -0x28(%ebp)
f0116310:	e8 7d 4b ff ff       	call   f010ae92 <calculate_allocated_space>
f0116315:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116318:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011631e:	85 c0                	test   %eax,%eax
f0116320:	74 27                	je     f0116349 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116322:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116328:	83 ec 0c             	sub    $0xc,%esp
f011632b:	6a 00                	push   $0x0
f011632d:	50                   	push   %eax
f011632e:	68 b4 b1 12 f0       	push   $0xf012b1b4
f0116333:	68 73 07 00 00       	push   $0x773
f0116338:	68 02 98 12 f0       	push   $0xf0129802
f011633d:	e8 94 a1 fe ff       	call   f01004d6 <_warn>
f0116342:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116345:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116349:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011634f:	85 c0                	test   %eax,%eax
f0116351:	74 27                	je     f011637a <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116353:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116359:	83 ec 0c             	sub    $0xc,%esp
f011635c:	6a 00                	push   $0x0
f011635e:	50                   	push   %eax
f011635f:	68 14 b2 12 f0       	push   $0xf012b214
f0116364:	68 78 07 00 00       	push   $0x778
f0116369:	68 02 98 12 f0       	push   $0xf0129802
f011636e:	e8 63 a1 fe ff       	call   f01004d6 <_warn>
f0116373:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116376:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011637a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011637e:	74 04                	je     f0116384 <test_calculate_allocated_space+0x5c7>
f0116380:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116384:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0116388:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011638f:	00 00 00 
		num_pages = 0;
f0116392:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116399:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f011639c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011639f:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01163a4:	89 c2                	mov    %eax,%edx
f01163a6:	83 ec 0c             	sub    $0xc,%esp
f01163a9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01163af:	50                   	push   %eax
f01163b0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01163b6:	50                   	push   %eax
f01163b7:	52                   	push   %edx
f01163b8:	68 ff ff 3f 00       	push   $0x3fffff
f01163bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01163c0:	e8 cd 4a ff ff       	call   f010ae92 <calculate_allocated_space>
f01163c5:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01163c8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163ce:	85 c0                	test   %eax,%eax
f01163d0:	74 27                	je     f01163f9 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01163d2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163d8:	83 ec 0c             	sub    $0xc,%esp
f01163db:	6a 00                	push   $0x0
f01163dd:	50                   	push   %eax
f01163de:	68 b4 b1 12 f0       	push   $0xf012b1b4
f01163e3:	68 84 07 00 00       	push   $0x784
f01163e8:	68 02 98 12 f0       	push   $0xf0129802
f01163ed:	e8 e4 a0 fe ff       	call   f01004d6 <_warn>
f01163f2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01163f5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01163f9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01163ff:	85 c0                	test   %eax,%eax
f0116401:	74 27                	je     f011642a <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116403:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116409:	83 ec 0c             	sub    $0xc,%esp
f011640c:	6a 00                	push   $0x0
f011640e:	50                   	push   %eax
f011640f:	68 14 b2 12 f0       	push   $0xf012b214
f0116414:	68 89 07 00 00       	push   $0x789
f0116419:	68 02 98 12 f0       	push   $0xf0129802
f011641e:	e8 b3 a0 fe ff       	call   f01004d6 <_warn>
f0116423:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116426:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011642a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011642e:	74 04                	je     f0116434 <test_calculate_allocated_space+0x677>
f0116430:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116434:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0116438:	83 ec 0c             	sub    $0xc,%esp
f011643b:	68 b5 ab 12 f0       	push   $0xf012abb5
f0116440:	e8 46 ab fe ff       	call   f0100f8b <cprintf>
f0116445:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0116448:	83 ec 0c             	sub    $0xc,%esp
f011644b:	68 d4 b0 12 f0       	push   $0xf012b0d4
f0116450:	e8 36 ab fe ff       	call   f0100f8b <cprintf>
f0116455:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0116458:	83 ec 04             	sub    $0x4,%esp
f011645b:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116461:	50                   	push   %eax
f0116462:	68 6e 9f 12 f0       	push   $0xf0129f6e
f0116467:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011646d:	50                   	push   %eax
f011646e:	e8 6e a0 00 00       	call   f01204e1 <strcconcat>
f0116473:	83 c4 10             	add    $0x10,%esp
f0116476:	83 ec 0c             	sub    $0xc,%esp
f0116479:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f011647f:	50                   	push   %eax
f0116480:	e8 76 ba fe ff       	call   f0101efb <execute_command>
f0116485:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0116488:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011648f:	00 00 00 
		num_pages = 0;
f0116492:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116499:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f011649c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011649f:	c1 e0 03             	shl    $0x3,%eax
f01164a2:	89 c2                	mov    %eax,%edx
f01164a4:	83 ec 0c             	sub    $0xc,%esp
f01164a7:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01164ad:	50                   	push   %eax
f01164ae:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01164b4:	50                   	push   %eax
f01164b5:	52                   	push   %edx
f01164b6:	6a 00                	push   $0x0
f01164b8:	ff 75 d8             	pushl  -0x28(%ebp)
f01164bb:	e8 d2 49 ff ff       	call   f010ae92 <calculate_allocated_space>
f01164c0:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01164c3:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f01164ca:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01164d1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01164d7:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01164da:	74 28                	je     f0116504 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01164dc:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01164e2:	83 ec 0c             	sub    $0xc,%esp
f01164e5:	ff 75 c8             	pushl  -0x38(%ebp)
f01164e8:	50                   	push   %eax
f01164e9:	68 b4 b1 12 f0       	push   $0xf012b1b4
f01164ee:	68 a0 07 00 00       	push   $0x7a0
f01164f3:	68 02 98 12 f0       	push   $0xf0129802
f01164f8:	e8 d9 9f fe ff       	call   f01004d6 <_warn>
f01164fd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116500:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116504:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011650a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011650d:	74 28                	je     f0116537 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011650f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116515:	83 ec 0c             	sub    $0xc,%esp
f0116518:	ff 75 c4             	pushl  -0x3c(%ebp)
f011651b:	50                   	push   %eax
f011651c:	68 14 b2 12 f0       	push   $0xf012b214
f0116521:	68 a5 07 00 00       	push   $0x7a5
f0116526:	68 02 98 12 f0       	push   $0xf0129802
f011652b:	e8 a6 9f fe ff       	call   f01004d6 <_warn>
f0116530:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116533:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116537:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011653b:	74 04                	je     f0116541 <test_calculate_allocated_space+0x784>
f011653d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116541:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0116545:	83 ec 04             	sub    $0x4,%esp
f0116548:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011654e:	50                   	push   %eax
f011654f:	68 7b 9f 12 f0       	push   $0xf0129f7b
f0116554:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011655a:	50                   	push   %eax
f011655b:	e8 81 9f 00 00       	call   f01204e1 <strcconcat>
f0116560:	83 c4 10             	add    $0x10,%esp
f0116563:	83 ec 0c             	sub    $0xc,%esp
f0116566:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011656c:	50                   	push   %eax
f011656d:	e8 89 b9 fe ff       	call   f0101efb <execute_command>
f0116572:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0116575:	83 ec 04             	sub    $0x4,%esp
f0116578:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011657e:	50                   	push   %eax
f011657f:	68 08 b1 12 f0       	push   $0xf012b108
f0116584:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011658a:	50                   	push   %eax
f011658b:	e8 51 9f 00 00       	call   f01204e1 <strcconcat>
f0116590:	83 c4 10             	add    $0x10,%esp
f0116593:	83 ec 0c             	sub    $0xc,%esp
f0116596:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011659c:	50                   	push   %eax
f011659d:	e8 59 b9 fe ff       	call   f0101efb <execute_command>
f01165a2:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f01165a5:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01165ac:	00 00 00 
		num_pages = 0;
f01165af:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01165b6:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f01165b9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01165bc:	c1 e0 03             	shl    $0x3,%eax
f01165bf:	89 c2                	mov    %eax,%edx
f01165c1:	83 ec 0c             	sub    $0xc,%esp
f01165c4:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01165ca:	50                   	push   %eax
f01165cb:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01165d1:	50                   	push   %eax
f01165d2:	52                   	push   %edx
f01165d3:	6a 00                	push   $0x0
f01165d5:	ff 75 d8             	pushl  -0x28(%ebp)
f01165d8:	e8 b5 48 ff ff       	call   f010ae92 <calculate_allocated_space>
f01165dd:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01165e0:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f01165e7:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01165ee:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01165f4:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01165f7:	74 28                	je     f0116621 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01165f9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01165ff:	83 ec 0c             	sub    $0xc,%esp
f0116602:	ff 75 c8             	pushl  -0x38(%ebp)
f0116605:	50                   	push   %eax
f0116606:	68 b4 b1 12 f0       	push   $0xf012b1b4
f011660b:	68 b6 07 00 00       	push   $0x7b6
f0116610:	68 02 98 12 f0       	push   $0xf0129802
f0116615:	e8 bc 9e fe ff       	call   f01004d6 <_warn>
f011661a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011661d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116621:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116627:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011662a:	74 28                	je     f0116654 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011662c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116632:	83 ec 0c             	sub    $0xc,%esp
f0116635:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116638:	50                   	push   %eax
f0116639:	68 14 b2 12 f0       	push   $0xf012b214
f011663e:	68 bb 07 00 00       	push   $0x7bb
f0116643:	68 02 98 12 f0       	push   $0xf0129802
f0116648:	e8 89 9e fe ff       	call   f01004d6 <_warn>
f011664d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116650:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116654:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116658:	74 04                	je     f011665e <test_calculate_allocated_space+0x8a1>
f011665a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011665e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116662:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116669:	00 00 00 
		num_pages = 0;
f011666c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116673:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0116676:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116679:	c1 e0 0a             	shl    $0xa,%eax
f011667c:	89 c2                	mov    %eax,%edx
f011667e:	83 ec 0c             	sub    $0xc,%esp
f0116681:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116687:	50                   	push   %eax
f0116688:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011668e:	50                   	push   %eax
f011668f:	52                   	push   %edx
f0116690:	6a 00                	push   $0x0
f0116692:	ff 75 d8             	pushl  -0x28(%ebp)
f0116695:	e8 f8 47 ff ff       	call   f010ae92 <calculate_allocated_space>
f011669a:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f011669d:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f01166a4:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01166ab:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166b1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01166b4:	74 28                	je     f01166de <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01166b6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166bc:	83 ec 0c             	sub    $0xc,%esp
f01166bf:	ff 75 c8             	pushl  -0x38(%ebp)
f01166c2:	50                   	push   %eax
f01166c3:	68 b4 b1 12 f0       	push   $0xf012b1b4
f01166c8:	68 c9 07 00 00       	push   $0x7c9
f01166cd:	68 02 98 12 f0       	push   $0xf0129802
f01166d2:	e8 ff 9d fe ff       	call   f01004d6 <_warn>
f01166d7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01166da:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01166de:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01166e4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01166e7:	74 28                	je     f0116711 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01166e9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01166ef:	83 ec 0c             	sub    $0xc,%esp
f01166f2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01166f5:	50                   	push   %eax
f01166f6:	68 14 b2 12 f0       	push   $0xf012b214
f01166fb:	68 ce 07 00 00       	push   $0x7ce
f0116700:	68 02 98 12 f0       	push   $0xf0129802
f0116705:	e8 cc 9d fe ff       	call   f01004d6 <_warn>
f011670a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011670d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116711:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116715:	74 04                	je     f011671b <test_calculate_allocated_space+0x95e>
f0116717:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011671b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f011671f:	83 ec 04             	sub    $0x4,%esp
f0116722:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116728:	50                   	push   %eax
f0116729:	68 14 b1 12 f0       	push   $0xf012b114
f011672e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116734:	50                   	push   %eax
f0116735:	e8 a7 9d 00 00       	call   f01204e1 <strcconcat>
f011673a:	83 c4 10             	add    $0x10,%esp
f011673d:	83 ec 0c             	sub    $0xc,%esp
f0116740:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116746:	50                   	push   %eax
f0116747:	e8 af b7 fe ff       	call   f0101efb <execute_command>
f011674c:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f011674f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116756:	00 00 00 
		num_pages = 0;
f0116759:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116760:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0116763:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116766:	89 c2                	mov    %eax,%edx
f0116768:	01 d2                	add    %edx,%edx
f011676a:	01 d0                	add    %edx,%eax
f011676c:	05 00 18 00 00       	add    $0x1800,%eax
f0116771:	89 c2                	mov    %eax,%edx
f0116773:	83 ec 0c             	sub    $0xc,%esp
f0116776:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011677c:	50                   	push   %eax
f011677d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116783:	50                   	push   %eax
f0116784:	52                   	push   %edx
f0116785:	68 00 18 00 00       	push   $0x1800
f011678a:	ff 75 d8             	pushl  -0x28(%ebp)
f011678d:	e8 00 47 ff ff       	call   f010ae92 <calculate_allocated_space>
f0116792:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116795:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011679c:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01167a3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167a9:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01167ac:	74 28                	je     f01167d6 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01167ae:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167b4:	83 ec 0c             	sub    $0xc,%esp
f01167b7:	ff 75 c8             	pushl  -0x38(%ebp)
f01167ba:	50                   	push   %eax
f01167bb:	68 b4 b1 12 f0       	push   $0xf012b1b4
f01167c0:	68 df 07 00 00       	push   $0x7df
f01167c5:	68 02 98 12 f0       	push   $0xf0129802
f01167ca:	e8 07 9d fe ff       	call   f01004d6 <_warn>
f01167cf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01167d2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01167d6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01167dc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01167df:	74 28                	je     f0116809 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01167e1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01167e7:	83 ec 0c             	sub    $0xc,%esp
f01167ea:	ff 75 c4             	pushl  -0x3c(%ebp)
f01167ed:	50                   	push   %eax
f01167ee:	68 14 b2 12 f0       	push   $0xf012b214
f01167f3:	68 e4 07 00 00       	push   $0x7e4
f01167f8:	68 02 98 12 f0       	push   $0xf0129802
f01167fd:	e8 d4 9c fe ff       	call   f01004d6 <_warn>
f0116802:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116805:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116809:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011680d:	74 04                	je     f0116813 <test_calculate_allocated_space+0xa56>
f011680f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116813:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0116817:	83 ec 04             	sub    $0x4,%esp
f011681a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116820:	50                   	push   %eax
f0116821:	68 d4 a1 12 f0       	push   $0xf012a1d4
f0116826:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011682c:	50                   	push   %eax
f011682d:	e8 af 9c 00 00       	call   f01204e1 <strcconcat>
f0116832:	83 c4 10             	add    $0x10,%esp
f0116835:	83 ec 0c             	sub    $0xc,%esp
f0116838:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011683e:	50                   	push   %eax
f011683f:	e8 b7 b6 fe ff       	call   f0101efb <execute_command>
f0116844:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0116847:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011684e:	00 00 00 
		num_pages = 0;
f0116851:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116858:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f011685b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011685e:	89 d0                	mov    %edx,%eax
f0116860:	c1 e0 02             	shl    $0x2,%eax
f0116863:	01 d0                	add    %edx,%eax
f0116865:	01 c0                	add    %eax,%eax
f0116867:	05 00 00 40 00       	add    $0x400000,%eax
f011686c:	89 c2                	mov    %eax,%edx
f011686e:	83 ec 0c             	sub    $0xc,%esp
f0116871:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116877:	50                   	push   %eax
f0116878:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011687e:	50                   	push   %eax
f011687f:	52                   	push   %edx
f0116880:	68 00 00 40 00       	push   $0x400000
f0116885:	ff 75 d8             	pushl  -0x28(%ebp)
f0116888:	e8 05 46 ff ff       	call   f010ae92 <calculate_allocated_space>
f011688d:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116890:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116897:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011689e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01168a4:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01168a7:	74 28                	je     f01168d1 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01168a9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01168af:	83 ec 0c             	sub    $0xc,%esp
f01168b2:	ff 75 c8             	pushl  -0x38(%ebp)
f01168b5:	50                   	push   %eax
f01168b6:	68 b4 b1 12 f0       	push   $0xf012b1b4
f01168bb:	68 f4 07 00 00       	push   $0x7f4
f01168c0:	68 02 98 12 f0       	push   $0xf0129802
f01168c5:	e8 0c 9c fe ff       	call   f01004d6 <_warn>
f01168ca:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01168cd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01168d1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01168d7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01168da:	74 28                	je     f0116904 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01168dc:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01168e2:	83 ec 0c             	sub    $0xc,%esp
f01168e5:	ff 75 c4             	pushl  -0x3c(%ebp)
f01168e8:	50                   	push   %eax
f01168e9:	68 14 b2 12 f0       	push   $0xf012b214
f01168ee:	68 f9 07 00 00       	push   $0x7f9
f01168f3:	68 02 98 12 f0       	push   $0xf0129802
f01168f8:	e8 d9 9b fe ff       	call   f01004d6 <_warn>
f01168fd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116900:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116904:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116908:	74 04                	je     f011690e <test_calculate_allocated_space+0xb51>
f011690a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011690e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0116912:	83 ec 04             	sub    $0x4,%esp
f0116915:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011691b:	50                   	push   %eax
f011691c:	68 de a1 12 f0       	push   $0xf012a1de
f0116921:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116927:	50                   	push   %eax
f0116928:	e8 b4 9b 00 00       	call   f01204e1 <strcconcat>
f011692d:	83 c4 10             	add    $0x10,%esp
f0116930:	83 ec 0c             	sub    $0xc,%esp
f0116933:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116939:	50                   	push   %eax
f011693a:	e8 bc b5 fe ff       	call   f0101efb <execute_command>
f011693f:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0116942:	83 ec 04             	sub    $0x4,%esp
f0116945:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011694b:	50                   	push   %eax
f011694c:	68 1c b1 12 f0       	push   $0xf012b11c
f0116951:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116957:	50                   	push   %eax
f0116958:	e8 84 9b 00 00       	call   f01204e1 <strcconcat>
f011695d:	83 c4 10             	add    $0x10,%esp
f0116960:	83 ec 0c             	sub    $0xc,%esp
f0116963:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116969:	50                   	push   %eax
f011696a:	e8 8c b5 fe ff       	call   f0101efb <execute_command>
f011696f:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0116972:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116979:	00 00 00 
		num_pages = 0;
f011697c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116983:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116986:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116989:	05 00 00 38 00       	add    $0x380000,%eax
f011698e:	01 c0                	add    %eax,%eax
f0116990:	89 c2                	mov    %eax,%edx
f0116992:	83 ec 0c             	sub    $0xc,%esp
f0116995:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011699b:	50                   	push   %eax
f011699c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01169a2:	50                   	push   %eax
f01169a3:	52                   	push   %edx
f01169a4:	68 00 00 70 00       	push   $0x700000
f01169a9:	ff 75 d8             	pushl  -0x28(%ebp)
f01169ac:	e8 e1 44 ff ff       	call   f010ae92 <calculate_allocated_space>
f01169b1:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01169b4:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f01169bb:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01169c2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169c8:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01169cb:	74 28                	je     f01169f5 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01169cd:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169d3:	83 ec 0c             	sub    $0xc,%esp
f01169d6:	ff 75 c8             	pushl  -0x38(%ebp)
f01169d9:	50                   	push   %eax
f01169da:	68 b4 b1 12 f0       	push   $0xf012b1b4
f01169df:	68 0b 08 00 00       	push   $0x80b
f01169e4:	68 02 98 12 f0       	push   $0xf0129802
f01169e9:	e8 e8 9a fe ff       	call   f01004d6 <_warn>
f01169ee:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01169f1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01169f5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01169fb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01169fe:	74 28                	je     f0116a28 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116a00:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116a06:	83 ec 0c             	sub    $0xc,%esp
f0116a09:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116a0c:	50                   	push   %eax
f0116a0d:	68 14 b2 12 f0       	push   $0xf012b214
f0116a12:	68 10 08 00 00       	push   $0x810
f0116a17:	68 02 98 12 f0       	push   $0xf0129802
f0116a1c:	e8 b5 9a fe ff       	call   f01004d6 <_warn>
f0116a21:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116a24:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116a28:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116a2c:	74 04                	je     f0116a32 <test_calculate_allocated_space+0xc75>
f0116a2e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116a32:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0116a36:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116a3d:	00 00 00 
		num_pages = 0;
f0116a40:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116a47:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116a4a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116a4d:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0116a52:	89 c2                	mov    %eax,%edx
f0116a54:	83 ec 0c             	sub    $0xc,%esp
f0116a57:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116a5d:	50                   	push   %eax
f0116a5e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116a64:	50                   	push   %eax
f0116a65:	52                   	push   %edx
f0116a66:	68 ff ff 3f 00       	push   $0x3fffff
f0116a6b:	ff 75 d8             	pushl  -0x28(%ebp)
f0116a6e:	e8 1f 44 ff ff       	call   f010ae92 <calculate_allocated_space>
f0116a73:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116a76:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0116a7d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116a84:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116a8a:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116a8d:	74 28                	je     f0116ab7 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116a8f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116a95:	83 ec 0c             	sub    $0xc,%esp
f0116a98:	ff 75 c8             	pushl  -0x38(%ebp)
f0116a9b:	50                   	push   %eax
f0116a9c:	68 b4 b1 12 f0       	push   $0xf012b1b4
f0116aa1:	68 1e 08 00 00       	push   $0x81e
f0116aa6:	68 02 98 12 f0       	push   $0xf0129802
f0116aab:	e8 26 9a fe ff       	call   f01004d6 <_warn>
f0116ab0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116ab3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116ab7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116abd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116ac0:	74 28                	je     f0116aea <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116ac2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ac8:	83 ec 0c             	sub    $0xc,%esp
f0116acb:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116ace:	50                   	push   %eax
f0116acf:	68 14 b2 12 f0       	push   $0xf012b214
f0116ad4:	68 23 08 00 00       	push   $0x823
f0116ad9:	68 02 98 12 f0       	push   $0xf0129802
f0116ade:	e8 f3 99 fe ff       	call   f01004d6 <_warn>
f0116ae3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116ae6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116aea:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116aee:	74 04                	je     f0116af4 <test_calculate_allocated_space+0xd37>
f0116af0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116af4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0116af8:	83 ec 0c             	sub    $0xc,%esp
f0116afb:	68 8f a1 12 f0       	push   $0xf012a18f
f0116b00:	e8 86 a4 fe ff       	call   f0100f8b <cprintf>
f0116b05:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0116b08:	83 ec 08             	sub    $0x8,%esp
f0116b0b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116b0e:	68 70 b2 12 f0       	push   $0xf012b270
f0116b13:	e8 73 a4 fe ff       	call   f0100f8b <cprintf>
f0116b18:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116b1b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116b1f:	75 10                	jne    f0116b31 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116b21:	83 ec 0c             	sub    $0xc,%esp
f0116b24:	68 b0 b2 12 f0       	push   $0xf012b2b0
f0116b29:	e8 5d a4 fe ff       	call   f0100f8b <cprintf>
f0116b2e:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116b31:	a1 e4 f8 f1 f0       	mov    0xf0f1f8e4,%eax
f0116b36:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0116b39:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116b3c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116b3f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116b44:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116b47:	5b                   	pop    %ebx
f0116b48:	5e                   	pop    %esi
f0116b49:	5f                   	pop    %edi
f0116b4a:	5d                   	pop    %ebp
f0116b4b:	c3                   	ret    

f0116b4c <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0116b4c:	55                   	push   %ebp
f0116b4d:	89 e5                	mov    %esp,%ebp
f0116b4f:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0116b52:	8b 45 10             	mov    0x10(%ebp),%eax
f0116b55:	ba 01 00 00 00       	mov    $0x1,%edx
f0116b5a:	88 c1                	mov    %al,%cl
f0116b5c:	d3 e2                	shl    %cl,%edx
f0116b5e:	89 d0                	mov    %edx,%eax
f0116b60:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116b63:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116b66:	c1 e8 16             	shr    $0x16,%eax
f0116b69:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116b70:	8b 45 08             	mov    0x8(%ebp),%eax
f0116b73:	01 d0                	add    %edx,%eax
f0116b75:	8b 00                	mov    (%eax),%eax
f0116b77:	83 e0 01             	and    $0x1,%eax
f0116b7a:	85 c0                	test   %eax,%eax
f0116b7c:	75 07                	jne    f0116b85 <CB+0x39>
f0116b7e:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b83:	eb 76                	jmp    f0116bfb <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116b85:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116b88:	c1 e8 16             	shr    $0x16,%eax
f0116b8b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0116b95:	01 d0                	add    %edx,%eax
f0116b97:	8b 00                	mov    (%eax),%eax
f0116b99:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116b9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116ba1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116ba4:	c1 e8 0c             	shr    $0xc,%eax
f0116ba7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0116baa:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0116baf:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116bb2:	72 17                	jb     f0116bcb <CB+0x7f>
f0116bb4:	ff 75 f0             	pushl  -0x10(%ebp)
f0116bb7:	68 fc b2 12 f0       	push   $0xf012b2fc
f0116bbc:	68 3e 08 00 00       	push   $0x83e
f0116bc1:	68 02 98 12 f0       	push   $0xf0129802
f0116bc6:	e8 6e 97 fe ff       	call   f0100339 <_panic>
f0116bcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116bce:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116bd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116bd6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116bd9:	c1 e8 0c             	shr    $0xc,%eax
f0116bdc:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116be1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116be8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116beb:	01 d0                	add    %edx,%eax
f0116bed:	8b 00                	mov    (%eax),%eax
f0116bef:	23 45 f4             	and    -0xc(%ebp),%eax
f0116bf2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116bf5:	0f 94 c0             	sete   %al
f0116bf8:	0f b6 c0             	movzbl %al,%eax
}
f0116bfb:	c9                   	leave  
f0116bfc:	c3                   	ret    

f0116bfd <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0116bfd:	55                   	push   %ebp
f0116bfe:	89 e5                	mov    %esp,%ebp
f0116c00:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116c03:	68 2b b3 12 f0       	push   $0xf012b32b
f0116c08:	68 3a b3 12 f0       	push   $0xf012b33a
f0116c0d:	68 43 08 00 00       	push   $0x843
f0116c12:	68 02 98 12 f0       	push   $0xf0129802
f0116c17:	e8 1d 97 fe ff       	call   f0100339 <_panic>

f0116c1c <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116c1c:	55                   	push   %ebp
f0116c1d:	89 e5                	mov    %esp,%ebp
f0116c1f:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116c22:	68 2b b3 12 f0       	push   $0xf012b32b
f0116c27:	68 3a b3 12 f0       	push   $0xf012b33a
f0116c2c:	68 4d 08 00 00       	push   $0x84d
f0116c31:	68 02 98 12 f0       	push   $0xf0129802
f0116c36:	e8 fe 96 fe ff       	call   f0100339 <_panic>

f0116c3b <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f0116c3b:	55                   	push   %ebp
f0116c3c:	89 e5                	mov    %esp,%ebp
f0116c3e:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116c41:	68 2b b3 12 f0       	push   $0xf012b32b
f0116c46:	68 3a b3 12 f0       	push   $0xf012b33a
f0116c4b:	68 5c 08 00 00       	push   $0x85c
f0116c50:	68 02 98 12 f0       	push   $0xf0129802
f0116c55:	e8 df 96 fe ff       	call   f0100339 <_panic>

f0116c5a <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f0116c5a:	55                   	push   %ebp
f0116c5b:	89 e5                	mov    %esp,%ebp
f0116c5d:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116c60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116c63:	c1 e8 16             	shr    $0x16,%eax
f0116c66:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116c6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0116c70:	01 d0                	add    %edx,%eax
f0116c72:	8b 00                	mov    (%eax),%eax
f0116c74:	83 e0 01             	and    $0x1,%eax
f0116c77:	85 c0                	test   %eax,%eax
f0116c79:	75 07                	jne    f0116c82 <CE+0x28>
f0116c7b:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c80:	eb 7a                	jmp    f0116cfc <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116c82:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116c85:	c1 e8 16             	shr    $0x16,%eax
f0116c88:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116c8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0116c92:	01 d0                	add    %edx,%eax
f0116c94:	8b 00                	mov    (%eax),%eax
f0116c96:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116c9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116c9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ca1:	c1 e8 0c             	shr    $0xc,%eax
f0116ca4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116ca7:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f0116cac:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116caf:	72 17                	jb     f0116cc8 <CE+0x6e>
f0116cb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0116cb4:	68 fc b2 12 f0       	push   $0xf012b2fc
f0116cb9:	68 65 08 00 00       	push   $0x865
f0116cbe:	68 02 98 12 f0       	push   $0xf0129802
f0116cc3:	e8 71 96 fe ff       	call   f0100339 <_panic>
f0116cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ccb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116cd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116cd3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116cd6:	c1 e8 0c             	shr    $0xc,%eax
f0116cd9:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116cde:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116ce5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116ce8:	01 d0                	add    %edx,%eax
f0116cea:	8b 00                	mov    (%eax),%eax
f0116cec:	85 c0                	test   %eax,%eax
f0116cee:	74 07                	je     f0116cf7 <CE+0x9d>
f0116cf0:	b8 00 00 00 00       	mov    $0x0,%eax
f0116cf5:	eb 05                	jmp    f0116cfc <CE+0xa2>
	return 1;
f0116cf7:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116cfc:	c9                   	leave  
f0116cfd:	c3                   	ret    

f0116cfe <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116cfe:	55                   	push   %ebp
f0116cff:	89 e5                	mov    %esp,%ebp
f0116d01:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116d04:	68 2b b3 12 f0       	push   $0xf012b32b
f0116d09:	68 3a b3 12 f0       	push   $0xf012b33a
f0116d0e:	68 6c 08 00 00       	push   $0x86c
f0116d13:	68 02 98 12 f0       	push   $0xf0129802
f0116d18:	e8 1c 96 fe ff       	call   f0100339 <_panic>

f0116d1d <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116d1d:	55                   	push   %ebp
f0116d1e:	89 e5                	mov    %esp,%ebp
f0116d20:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116d23:	68 2b b3 12 f0       	push   $0xf012b32b
f0116d28:	68 3a b3 12 f0       	push   $0xf012b33a
f0116d2d:	68 7c 08 00 00       	push   $0x87c
f0116d32:	68 02 98 12 f0       	push   $0xf0129802
f0116d37:	e8 fd 95 fe ff       	call   f0100339 <_panic>

f0116d3c <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f0116d3c:	55                   	push   %ebp
f0116d3d:	89 e5                	mov    %esp,%ebp
f0116d3f:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116d42:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116d49:	eb 18                	jmp    f0116d63 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116d4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116d4e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d55:	8b 45 08             	mov    0x8(%ebp),%eax
f0116d58:	01 d0                	add    %edx,%eax
f0116d5a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116d60:	ff 45 fc             	incl   -0x4(%ebp)
f0116d63:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116d66:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116d6b:	76 de                	jbe    f0116d4b <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116d6d:	90                   	nop
f0116d6e:	c9                   	leave  
f0116d6f:	c3                   	ret    

f0116d70 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116d70:	55                   	push   %ebp
f0116d71:	89 e5                	mov    %esp,%ebp
f0116d73:	83 ec 38             	sub    $0x38,%esp
f0116d76:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116d79:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116d7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116d7f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116d84:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116d87:	8b 45 10             	mov    0x10(%ebp),%eax
f0116d8a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116d8f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116d92:	e9 ea 01 00 00       	jmp    f0116f81 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116d97:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116d9b:	74 44                	je     f0116de1 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116d9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116da0:	83 ec 04             	sub    $0x4,%esp
f0116da3:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116da6:	52                   	push   %edx
f0116da7:	50                   	push   %eax
f0116da8:	ff 75 08             	pushl  0x8(%ebp)
f0116dab:	e8 e4 1c ff ff       	call   f0108a94 <get_frame_info>
f0116db0:	83 c4 10             	add    $0x10,%esp
f0116db3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116db6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116db9:	85 c0                	test   %eax,%eax
f0116dbb:	75 24                	jne    f0116de1 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116dbd:	83 ec 04             	sub    $0x4,%esp
f0116dc0:	68 50 b3 12 f0       	push   $0xf012b350
f0116dc5:	68 99 08 00 00       	push   $0x899
f0116dca:	68 02 98 12 f0       	push   $0xf0129802
f0116dcf:	e8 02 97 fe ff       	call   f01004d6 <_warn>
f0116dd4:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116dd7:	b8 00 00 00 00       	mov    $0x0,%eax
f0116ddc:	e9 b6 01 00 00       	jmp    f0116f97 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116de1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116de4:	83 ec 04             	sub    $0x4,%esp
f0116de7:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116dea:	52                   	push   %edx
f0116deb:	50                   	push   %eax
f0116dec:	ff 75 08             	pushl  0x8(%ebp)
f0116def:	e8 a0 1c ff ff       	call   f0108a94 <get_frame_info>
f0116df4:	83 c4 10             	add    $0x10,%esp
f0116df7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116dfa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116dfd:	85 c0                	test   %eax,%eax
f0116dff:	75 24                	jne    f0116e25 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116e01:	83 ec 04             	sub    $0x4,%esp
f0116e04:	68 7c b3 12 f0       	push   $0xf012b37c
f0116e09:	68 a0 08 00 00       	push   $0x8a0
f0116e0e:	68 02 98 12 f0       	push   $0xf0129802
f0116e13:	e8 be 96 fe ff       	call   f01004d6 <_warn>
f0116e18:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116e1b:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e20:	e9 72 01 00 00       	jmp    f0116f97 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116e25:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0116e29:	75 70                	jne    f0116e9b <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0116e2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116e2e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116e31:	c1 ea 0c             	shr    $0xc,%edx
f0116e34:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116e3a:	c1 e2 02             	shl    $0x2,%edx
f0116e3d:	01 d0                	add    %edx,%eax
f0116e3f:	8b 00                	mov    (%eax),%eax
f0116e41:	c1 e8 0c             	shr    $0xc,%eax
f0116e44:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0116e47:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116e4a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0116e4d:	c1 ea 0c             	shr    $0xc,%edx
f0116e50:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116e56:	c1 e2 02             	shl    $0x2,%edx
f0116e59:	01 d0                	add    %edx,%eax
f0116e5b:	8b 00                	mov    (%eax),%eax
f0116e5d:	c1 e8 0c             	shr    $0xc,%eax
f0116e60:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0116e63:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116e66:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0116e69:	74 30                	je     f0116e9b <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0116e6b:	83 ec 04             	sub    $0x4,%esp
f0116e6e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116e71:	ff 75 e8             	pushl  -0x18(%ebp)
f0116e74:	ff 75 f0             	pushl  -0x10(%ebp)
f0116e77:	ff 75 f4             	pushl  -0xc(%ebp)
f0116e7a:	68 a8 b3 12 f0       	push   $0xf012b3a8
f0116e7f:	68 aa 08 00 00       	push   $0x8aa
f0116e84:	68 02 98 12 f0       	push   $0xf0129802
f0116e89:	e8 48 96 fe ff       	call   f01004d6 <_warn>
f0116e8e:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116e91:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e96:	e9 fc 00 00 00       	jmp    f0116f97 <CCP+0x227>
			}
		}
		if (ref != -1)
f0116e9b:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116e9f:	74 52                	je     f0116ef3 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116ea1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116ea5:	74 0e                	je     f0116eb5 <CCP+0x145>
f0116ea7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116eaa:	8b 40 08             	mov    0x8(%eax),%eax
f0116ead:	0f b7 c0             	movzwl %ax,%eax
f0116eb0:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116eb3:	74 3e                	je     f0116ef3 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116eb5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116eb9:	74 0b                	je     f0116ec6 <CCP+0x156>
f0116ebb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116ebe:	8b 40 08             	mov    0x8(%eax),%eax
f0116ec1:	0f b7 c0             	movzwl %ax,%eax
f0116ec4:	eb 05                	jmp    f0116ecb <CCP+0x15b>
f0116ec6:	b8 00 00 00 00       	mov    $0x0,%eax
f0116ecb:	83 ec 0c             	sub    $0xc,%esp
f0116ece:	50                   	push   %eax
f0116ecf:	ff 75 f0             	pushl  -0x10(%ebp)
f0116ed2:	68 04 b4 12 f0       	push   $0xf012b404
f0116ed7:	68 b2 08 00 00       	push   $0x8b2
f0116edc:	68 02 98 12 f0       	push   $0xf0129802
f0116ee1:	e8 f0 95 fe ff       	call   f01004d6 <_warn>
f0116ee6:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116ee9:	b8 00 00 00 00       	mov    $0x0,%eax
f0116eee:	e9 a4 00 00 00       	jmp    f0116f97 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116ef3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116ef6:	ff 75 20             	pushl  0x20(%ebp)
f0116ef9:	ff 75 1c             	pushl  0x1c(%ebp)
f0116efc:	50                   	push   %eax
f0116efd:	ff 75 08             	pushl  0x8(%ebp)
f0116f00:	e8 17 fd ff ff       	call   f0116c1c <CPs>
f0116f05:	83 c4 10             	add    $0x10,%esp
f0116f08:	85 c0                	test   %eax,%eax
f0116f0a:	7f 21                	jg     f0116f2d <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116f0c:	83 ec 04             	sub    $0x4,%esp
f0116f0f:	68 74 b4 12 f0       	push   $0xf012b474
f0116f14:	68 b8 08 00 00       	push   $0x8b8
f0116f19:	68 02 98 12 f0       	push   $0xf0129802
f0116f1e:	e8 b3 95 fe ff       	call   f01004d6 <_warn>
f0116f23:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116f26:	b8 00 00 00 00       	mov    $0x0,%eax
f0116f2b:	eb 6a                	jmp    f0116f97 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116f2d:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116f31:	74 3a                	je     f0116f6d <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116f33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116f36:	ff 75 28             	pushl  0x28(%ebp)
f0116f39:	ff 75 24             	pushl  0x24(%ebp)
f0116f3c:	50                   	push   %eax
f0116f3d:	ff 75 08             	pushl  0x8(%ebp)
f0116f40:	e8 d7 fc ff ff       	call   f0116c1c <CPs>
f0116f45:	83 c4 10             	add    $0x10,%esp
f0116f48:	85 c0                	test   %eax,%eax
f0116f4a:	7f 21                	jg     f0116f6d <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0116f4c:	83 ec 04             	sub    $0x4,%esp
f0116f4f:	68 bc b4 12 f0       	push   $0xf012b4bc
f0116f54:	68 bf 08 00 00       	push   $0x8bf
f0116f59:	68 02 98 12 f0       	push   $0xf0129802
f0116f5e:	e8 73 95 fe ff       	call   f01004d6 <_warn>
f0116f63:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116f66:	b8 00 00 00 00       	mov    $0x0,%eax
f0116f6b:	eb 2a                	jmp    f0116f97 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0116f6d:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116f71:	74 07                	je     f0116f7a <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0116f73:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116f7a:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0116f81:	8b 55 10             	mov    0x10(%ebp),%edx
f0116f84:	8b 45 14             	mov    0x14(%ebp),%eax
f0116f87:	01 d0                	add    %edx,%eax
f0116f89:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0116f8c:	0f 87 05 fe ff ff    	ja     f0116d97 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0116f92:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116f97:	c9                   	leave  
f0116f98:	c3                   	ret    

f0116f99 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0116f99:	55                   	push   %ebp
f0116f9a:	89 e5                	mov    %esp,%ebp
f0116f9c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116f9f:	83 ec 04             	sub    $0x4,%esp
f0116fa2:	68 fc b4 12 f0       	push   $0xf012b4fc
f0116fa7:	6a 0e                	push   $0xe
f0116fa9:	68 0c b5 12 f0       	push   $0xf012b50c
f0116fae:	e8 86 93 fe ff       	call   f0100339 <_panic>

f0116fb3 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0116fb3:	55                   	push   %ebp
f0116fb4:	89 e5                	mov    %esp,%ebp
f0116fb6:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116fb9:	83 ec 04             	sub    $0x4,%esp
f0116fbc:	68 fc b4 12 f0       	push   $0xf012b4fc
f0116fc1:	68 d7 00 00 00       	push   $0xd7
f0116fc6:	68 0c b5 12 f0       	push   $0xf012b50c
f0116fcb:	e8 69 93 fe ff       	call   f0100339 <_panic>

f0116fd0 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0116fd0:	55                   	push   %ebp
f0116fd1:	89 e5                	mov    %esp,%ebp
f0116fd3:	57                   	push   %edi
f0116fd4:	53                   	push   %ebx
f0116fd5:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0116fdb:	83 ec 0c             	sub    $0xc,%esp
f0116fde:	68 28 b5 12 f0       	push   $0xf012b528
f0116fe3:	e8 a3 9f fe ff       	call   f0100f8b <cprintf>
f0116fe8:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0116feb:	83 ec 0c             	sub    $0xc,%esp
f0116fee:	68 58 b5 12 f0       	push   $0xf012b558
f0116ff3:	e8 93 9f fe ff       	call   f0100f8b <cprintf>
f0116ff8:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0116ffb:	83 ec 0c             	sub    $0xc,%esp
f0116ffe:	68 28 b5 12 f0       	push   $0xf012b528
f0117003:	e8 83 9f fe ff       	call   f0100f8b <cprintf>
f0117008:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011700b:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f011700f:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0117013:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0117019:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f011701f:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0117026:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f011702d:	e8 16 7c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117032:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0117035:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011703c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0117043:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0117049:	b9 14 00 00 00       	mov    $0x14,%ecx
f011704e:	b8 00 00 00 00       	mov    $0x0,%eax
f0117053:	89 d7                	mov    %edx,%edi
f0117055:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0117057:	83 ec 0c             	sub    $0xc,%esp
f011705a:	68 b1 b5 12 f0       	push   $0xf012b5b1
f011705f:	e8 27 9f fe ff       	call   f0100f8b <cprintf>
f0117064:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117067:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f011706e:	e8 d5 7b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117073:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117076:	e8 18 da fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011707b:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f011707e:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0117085:	83 ec 0c             	sub    $0xc,%esp
f0117088:	ff 75 cc             	pushl  -0x34(%ebp)
f011708b:	e8 3f 27 ff ff       	call   f01097cf <kmalloc>
f0117090:	83 c4 10             	add    $0x10,%esp
f0117093:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0117099:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011709f:	85 c0                	test   %eax,%eax
f01170a1:	74 17                	je     f01170ba <test_kmalloc+0xea>
f01170a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170aa:	83 ec 0c             	sub    $0xc,%esp
f01170ad:	68 d0 b5 12 f0       	push   $0xf012b5d0
f01170b2:	e8 d4 9e fe ff       	call   f0100f8b <cprintf>
f01170b7:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01170ba:	e8 d4 d9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01170bf:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01170c2:	74 17                	je     f01170db <test_kmalloc+0x10b>
f01170c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170cb:	83 ec 0c             	sub    $0xc,%esp
f01170ce:	68 04 b6 12 f0       	push   $0xf012b604
f01170d3:	e8 b3 9e fe ff       	call   f0100f8b <cprintf>
f01170d8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f01170db:	e8 68 7b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01170e0:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01170e3:	74 17                	je     f01170fc <test_kmalloc+0x12c>
f01170e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170ec:	83 ec 0c             	sub    $0xc,%esp
f01170ef:	68 70 b6 12 f0       	push   $0xf012b670
f01170f4:	e8 92 9e fe ff       	call   f0100f8b <cprintf>
f01170f9:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01170fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117100:	74 04                	je     f0117106 <test_kmalloc+0x136>
f0117102:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0117106:	83 ec 0c             	sub    $0xc,%esp
f0117109:	68 b4 b6 12 f0       	push   $0xf012b6b4
f011710e:	e8 78 9e fe ff       	call   f0100f8b <cprintf>
f0117113:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117116:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011711d:	e8 26 7b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117122:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117125:	e8 69 d9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011712a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011712d:	83 ec 0c             	sub    $0xc,%esp
f0117130:	68 00 fc 1f 00       	push   $0x1ffc00
f0117135:	e8 95 26 ff ff       	call   f01097cf <kmalloc>
f011713a:	83 c4 10             	add    $0x10,%esp
f011713d:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117143:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0117149:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011714e:	74 17                	je     f0117167 <test_kmalloc+0x197>
f0117150:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117157:	83 ec 0c             	sub    $0xc,%esp
f011715a:	68 f8 b6 12 f0       	push   $0xf012b6f8
f011715f:	e8 27 9e fe ff       	call   f0100f8b <cprintf>
f0117164:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117167:	e8 27 d9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011716c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011716f:	74 17                	je     f0117188 <test_kmalloc+0x1b8>
f0117171:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117178:	83 ec 0c             	sub    $0xc,%esp
f011717b:	68 4c b7 12 f0       	push   $0xf012b74c
f0117180:	e8 06 9e fe ff       	call   f0100f8b <cprintf>
f0117185:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117188:	e8 bb 7a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011718d:	89 c2                	mov    %eax,%edx
f011718f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117192:	29 d0                	sub    %edx,%eax
f0117194:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117199:	7f 17                	jg     f01171b2 <test_kmalloc+0x1e2>
f011719b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171a2:	83 ec 0c             	sub    $0xc,%esp
f01171a5:	68 b8 b7 12 f0       	push   $0xf012b7b8
f01171aa:	e8 dc 9d fe ff       	call   f0100f8b <cprintf>
f01171af:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01171b2:	e8 91 7a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01171b7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01171ba:	e8 d4 d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01171bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01171c2:	83 ec 0c             	sub    $0xc,%esp
f01171c5:	68 00 fc 1f 00       	push   $0x1ffc00
f01171ca:	e8 00 26 ff ff       	call   f01097cf <kmalloc>
f01171cf:	83 c4 10             	add    $0x10,%esp
f01171d2:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01171d8:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f01171de:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01171e3:	74 17                	je     f01171fc <test_kmalloc+0x22c>
f01171e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171ec:	83 ec 0c             	sub    $0xc,%esp
f01171ef:	68 fc b7 12 f0       	push   $0xf012b7fc
f01171f4:	e8 92 9d fe ff       	call   f0100f8b <cprintf>
f01171f9:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01171fc:	e8 92 d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117201:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117204:	74 17                	je     f011721d <test_kmalloc+0x24d>
f0117206:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011720d:	83 ec 0c             	sub    $0xc,%esp
f0117210:	68 50 b8 12 f0       	push   $0xf012b850
f0117215:	e8 71 9d fe ff       	call   f0100f8b <cprintf>
f011721a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011721d:	e8 26 7a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117222:	89 c2                	mov    %eax,%edx
f0117224:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117227:	29 d0                	sub    %edx,%eax
f0117229:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011722e:	7f 17                	jg     f0117247 <test_kmalloc+0x277>
f0117230:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117237:	83 ec 0c             	sub    $0xc,%esp
f011723a:	68 bc b8 12 f0       	push   $0xf012b8bc
f011723f:	e8 47 9d fe ff       	call   f0100f8b <cprintf>
f0117244:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0117247:	e8 fc 79 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011724c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011724f:	e8 3f d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117254:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0117257:	83 ec 0c             	sub    $0xc,%esp
f011725a:	68 ff 07 00 00       	push   $0x7ff
f011725f:	e8 6b 25 ff ff       	call   f01097cf <kmalloc>
f0117264:	83 c4 10             	add    $0x10,%esp
f0117267:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011726d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0117273:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117278:	76 28                	jbe    f01172a2 <test_kmalloc+0x2d2>
f011727a:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0117280:	83 ec 0c             	sub    $0xc,%esp
f0117283:	6a 00                	push   $0x0
f0117285:	e8 12 24 ff ff       	call   f010969c <sbrk>
f011728a:	83 c4 10             	add    $0x10,%esp
f011728d:	39 c3                	cmp    %eax,%ebx
f011728f:	73 11                	jae    f01172a2 <test_kmalloc+0x2d2>
f0117291:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0117297:	89 c2                	mov    %eax,%edx
f0117299:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011729e:	39 c2                	cmp    %eax,%edx
f01172a0:	72 17                	jb     f01172b9 <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01172a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172a9:	83 ec 0c             	sub    $0xc,%esp
f01172ac:	68 00 b9 12 f0       	push   $0xf012b900
f01172b1:	e8 d5 9c fe ff       	call   f0100f8b <cprintf>
f01172b6:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01172b9:	e8 d5 d7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01172be:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01172c1:	74 17                	je     f01172da <test_kmalloc+0x30a>
f01172c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172ca:	83 ec 0c             	sub    $0xc,%esp
f01172cd:	68 8c b9 12 f0       	push   $0xf012b98c
f01172d2:	e8 b4 9c fe ff       	call   f0100f8b <cprintf>
f01172d7:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01172da:	e8 b4 d7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01172df:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f01172e2:	83 ec 0c             	sub    $0xc,%esp
f01172e5:	68 ff 07 00 00       	push   $0x7ff
f01172ea:	e8 e0 24 ff ff       	call   f01097cf <kmalloc>
f01172ef:	83 c4 10             	add    $0x10,%esp
f01172f2:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f01172f8:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f01172fe:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117303:	76 28                	jbe    f011732d <test_kmalloc+0x35d>
f0117305:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f011730b:	83 ec 0c             	sub    $0xc,%esp
f011730e:	6a 00                	push   $0x0
f0117310:	e8 87 23 ff ff       	call   f010969c <sbrk>
f0117315:	83 c4 10             	add    $0x10,%esp
f0117318:	39 c3                	cmp    %eax,%ebx
f011731a:	73 11                	jae    f011732d <test_kmalloc+0x35d>
f011731c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117322:	89 c2                	mov    %eax,%edx
f0117324:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0117329:	39 c2                	cmp    %eax,%edx
f011732b:	72 17                	jb     f0117344 <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011732d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117334:	83 ec 0c             	sub    $0xc,%esp
f0117337:	68 f8 b9 12 f0       	push   $0xf012b9f8
f011733c:	e8 4a 9c fe ff       	call   f0100f8b <cprintf>
f0117341:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117344:	e8 4a d7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117349:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011734c:	74 17                	je     f0117365 <test_kmalloc+0x395>
f011734e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117355:	83 ec 0c             	sub    $0xc,%esp
f0117358:	68 84 ba 12 f0       	push   $0xf012ba84
f011735d:	e8 29 9c fe ff       	call   f0100f8b <cprintf>
f0117362:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f0117365:	e8 de 78 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011736a:	89 c2                	mov    %eax,%edx
f011736c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011736f:	29 d0                	sub    %edx,%eax
f0117371:	83 f8 01             	cmp    $0x1,%eax
f0117374:	74 17                	je     f011738d <test_kmalloc+0x3bd>
f0117376:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011737d:	83 ec 0c             	sub    $0xc,%esp
f0117380:	68 f0 ba 12 f0       	push   $0xf012baf0
f0117385:	e8 01 9c fe ff       	call   f0100f8b <cprintf>
f011738a:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011738d:	e8 b6 78 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117392:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117395:	e8 f9 d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011739a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f011739d:	83 ec 0c             	sub    $0xc,%esp
f01173a0:	68 00 1c 00 00       	push   $0x1c00
f01173a5:	e8 25 24 ff ff       	call   f01097cf <kmalloc>
f01173aa:	83 c4 10             	add    $0x10,%esp
f01173ad:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01173b3:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f01173b9:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01173be:	74 17                	je     f01173d7 <test_kmalloc+0x407>
f01173c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173c7:	83 ec 0c             	sub    $0xc,%esp
f01173ca:	68 10 bb 12 f0       	push   $0xf012bb10
f01173cf:	e8 b7 9b fe ff       	call   f0100f8b <cprintf>
f01173d4:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01173d7:	e8 b7 d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01173dc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01173df:	74 17                	je     f01173f8 <test_kmalloc+0x428>
f01173e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173e8:	83 ec 0c             	sub    $0xc,%esp
f01173eb:	68 64 bb 12 f0       	push   $0xf012bb64
f01173f0:	e8 96 9b fe ff       	call   f0100f8b <cprintf>
f01173f5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01173f8:	e8 4b 78 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01173fd:	89 c2                	mov    %eax,%edx
f01173ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117402:	29 d0                	sub    %edx,%eax
f0117404:	83 f8 01             	cmp    $0x1,%eax
f0117407:	7f 17                	jg     f0117420 <test_kmalloc+0x450>
f0117409:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117410:	83 ec 0c             	sub    $0xc,%esp
f0117413:	68 d0 bb 12 f0       	push   $0xf012bbd0
f0117418:	e8 6e 9b fe ff       	call   f0100f8b <cprintf>
f011741d:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117420:	e8 23 78 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117425:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117428:	e8 66 d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011742d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0117430:	83 ec 0c             	sub    $0xc,%esp
f0117433:	68 00 fc 2f 00       	push   $0x2ffc00
f0117438:	e8 92 23 ff ff       	call   f01097cf <kmalloc>
f011743d:	83 c4 10             	add    $0x10,%esp
f0117440:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117446:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011744c:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0117451:	74 17                	je     f011746a <test_kmalloc+0x49a>
f0117453:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011745a:	83 ec 0c             	sub    $0xc,%esp
f011745d:	68 14 bc 12 f0       	push   $0xf012bc14
f0117462:	e8 24 9b fe ff       	call   f0100f8b <cprintf>
f0117467:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011746a:	e8 24 d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011746f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117472:	74 17                	je     f011748b <test_kmalloc+0x4bb>
f0117474:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011747b:	83 ec 0c             	sub    $0xc,%esp
f011747e:	68 68 bc 12 f0       	push   $0xf012bc68
f0117483:	e8 03 9b fe ff       	call   f0100f8b <cprintf>
f0117488:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011748b:	e8 b8 77 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117490:	89 c2                	mov    %eax,%edx
f0117492:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117495:	29 d0                	sub    %edx,%eax
f0117497:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011749c:	7f 17                	jg     f01174b5 <test_kmalloc+0x4e5>
f011749e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174a5:	83 ec 0c             	sub    $0xc,%esp
f01174a8:	68 d4 bc 12 f0       	push   $0xf012bcd4
f01174ad:	e8 d9 9a fe ff       	call   f0100f8b <cprintf>
f01174b2:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01174b5:	e8 8e 77 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01174ba:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01174bd:	e8 d1 d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01174c2:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f01174c5:	83 ec 0c             	sub    $0xc,%esp
f01174c8:	68 00 fc 5f 00       	push   $0x5ffc00
f01174cd:	e8 fd 22 ff ff       	call   f01097cf <kmalloc>
f01174d2:	83 c4 10             	add    $0x10,%esp
f01174d5:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01174db:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01174e1:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01174e6:	74 17                	je     f01174ff <test_kmalloc+0x52f>
f01174e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174ef:	83 ec 0c             	sub    $0xc,%esp
f01174f2:	68 18 bd 12 f0       	push   $0xf012bd18
f01174f7:	e8 8f 9a fe ff       	call   f0100f8b <cprintf>
f01174fc:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01174ff:	e8 8f d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117504:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117507:	74 17                	je     f0117520 <test_kmalloc+0x550>
f0117509:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117510:	83 ec 0c             	sub    $0xc,%esp
f0117513:	68 6c bd 12 f0       	push   $0xf012bd6c
f0117518:	e8 6e 9a fe ff       	call   f0100f8b <cprintf>
f011751d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117520:	e8 23 77 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117525:	89 c2                	mov    %eax,%edx
f0117527:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011752a:	29 d0                	sub    %edx,%eax
f011752c:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0117531:	7f 17                	jg     f011754a <test_kmalloc+0x57a>
f0117533:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011753a:	83 ec 0c             	sub    $0xc,%esp
f011753d:	68 d8 bd 12 f0       	push   $0xf012bdd8
f0117542:	e8 44 9a fe ff       	call   f0100f8b <cprintf>
f0117547:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011754a:	e8 f9 76 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011754f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117552:	e8 3c d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117557:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f011755a:	83 ec 0c             	sub    $0xc,%esp
f011755d:	68 00 38 00 00       	push   $0x3800
f0117562:	e8 68 22 ff ff       	call   f01097cf <kmalloc>
f0117567:	83 c4 10             	add    $0x10,%esp
f011756a:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117570:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117576:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011757b:	74 17                	je     f0117594 <test_kmalloc+0x5c4>
f011757d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117584:	83 ec 0c             	sub    $0xc,%esp
f0117587:	68 1c be 12 f0       	push   $0xf012be1c
f011758c:	e8 fa 99 fe ff       	call   f0100f8b <cprintf>
f0117591:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117594:	e8 fa d4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117599:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011759c:	74 17                	je     f01175b5 <test_kmalloc+0x5e5>
f011759e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175a5:	83 ec 0c             	sub    $0xc,%esp
f01175a8:	68 70 be 12 f0       	push   $0xf012be70
f01175ad:	e8 d9 99 fe ff       	call   f0100f8b <cprintf>
f01175b2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01175b5:	e8 8e 76 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01175ba:	89 c2                	mov    %eax,%edx
f01175bc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01175bf:	29 d0                	sub    %edx,%eax
f01175c1:	83 f8 03             	cmp    $0x3,%eax
f01175c4:	7f 17                	jg     f01175dd <test_kmalloc+0x60d>
f01175c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175cd:	83 ec 0c             	sub    $0xc,%esp
f01175d0:	68 dc be 12 f0       	push   $0xf012bedc
f01175d5:	e8 b1 99 fe ff       	call   f0100f8b <cprintf>
f01175da:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01175dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01175e1:	74 04                	je     f01175e7 <test_kmalloc+0x617>
f01175e3:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01175e7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f01175ee:	83 ec 0c             	sub    $0xc,%esp
f01175f1:	68 20 bf 12 f0       	push   $0xf012bf20
f01175f6:	e8 90 99 fe ff       	call   f0100f8b <cprintf>
f01175fb:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f01175fe:	e8 45 76 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117603:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117606:	e8 88 d4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011760b:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f011760e:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0117615:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011761b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f011761e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117621:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117624:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0117626:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117629:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011762c:	01 c2                	add    %eax,%edx
f011762e:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117631:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0117633:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0117639:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f011763c:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f0117643:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117646:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117649:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f011764c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011764f:	01 c0                	add    %eax,%eax
f0117651:	89 c2                	mov    %eax,%edx
f0117653:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117656:	01 c2                	add    %eax,%edx
f0117658:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011765c:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f011765f:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0117665:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0117668:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f011766f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117672:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0117675:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0117677:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011767a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0117681:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117684:	01 c2                	add    %eax,%edx
f0117686:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117689:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f011768b:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117691:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f0117694:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f011769b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011769e:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01176a1:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f01176a3:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01176a6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01176a9:	01 c2                	add    %eax,%edx
f01176ab:	8a 45 ea             	mov    -0x16(%ebp),%al
f01176ae:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f01176b0:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f01176b6:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f01176b9:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f01176c0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01176c3:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01176c6:	88 10                	mov    %dl,(%eax)
f01176c8:	8b 55 a8             	mov    -0x58(%ebp),%edx
f01176cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01176ce:	66 89 42 02          	mov    %ax,0x2(%edx)
f01176d2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01176d5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01176d8:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f01176db:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01176de:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01176e5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01176e8:	01 c2                	add    %eax,%edx
f01176ea:	8a 45 ea             	mov    -0x16(%ebp),%al
f01176ed:	88 02                	mov    %al,(%edx)
f01176ef:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01176f2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01176f9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01176fc:	01 c2                	add    %eax,%edx
f01176fe:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117702:	66 89 42 02          	mov    %ax,0x2(%edx)
f0117706:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117709:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117710:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117713:	01 c2                	add    %eax,%edx
f0117715:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117718:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f011771b:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f0117722:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0117728:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f011772b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011772e:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117731:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0117733:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117736:	89 c2                	mov    %eax,%edx
f0117738:	c1 ea 1f             	shr    $0x1f,%edx
f011773b:	01 d0                	add    %edx,%eax
f011773d:	d1 f8                	sar    %eax
f011773f:	89 c2                	mov    %eax,%edx
f0117741:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117744:	01 c2                	add    %eax,%edx
f0117746:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117749:	88 c1                	mov    %al,%cl
f011774b:	c0 e9 07             	shr    $0x7,%cl
f011774e:	01 c8                	add    %ecx,%eax
f0117750:	d0 f8                	sar    %al
f0117752:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f0117754:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0117757:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011775a:	01 c2                	add    %eax,%edx
f011775c:	8a 45 ea             	mov    -0x16(%ebp),%al
f011775f:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f0117761:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117767:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f011776a:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f0117771:	8b 55 98             	mov    -0x68(%ebp),%edx
f0117774:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117777:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f011777a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011777d:	01 c0                	add    %eax,%eax
f011777f:	89 c2                	mov    %eax,%edx
f0117781:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117784:	01 c2                	add    %eax,%edx
f0117786:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011778a:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f011778d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117790:	8a 00                	mov    (%eax),%al
f0117792:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117795:	75 0f                	jne    f01177a6 <test_kmalloc+0x7d6>
f0117797:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011779a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011779d:	01 d0                	add    %edx,%eax
f011779f:	8a 00                	mov    (%eax),%al
f01177a1:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01177a4:	74 17                	je     f01177bd <test_kmalloc+0x7ed>
f01177a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177ad:	83 ec 0c             	sub    $0xc,%esp
f01177b0:	68 58 bf 12 f0       	push   $0xf012bf58
f01177b5:	e8 d1 97 fe ff       	call   f0100f8b <cprintf>
f01177ba:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f01177bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01177c0:	66 8b 00             	mov    (%eax),%ax
f01177c3:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01177c7:	75 15                	jne    f01177de <test_kmalloc+0x80e>
f01177c9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01177cc:	01 c0                	add    %eax,%eax
f01177ce:	89 c2                	mov    %eax,%edx
f01177d0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01177d3:	01 d0                	add    %edx,%eax
f01177d5:	66 8b 00             	mov    (%eax),%ax
f01177d8:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01177dc:	74 17                	je     f01177f5 <test_kmalloc+0x825>
f01177de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177e5:	83 ec 0c             	sub    $0xc,%esp
f01177e8:	68 90 bf 12 f0       	push   $0xf012bf90
f01177ed:	e8 99 97 fe ff       	call   f0100f8b <cprintf>
f01177f2:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f01177f5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01177f8:	8b 00                	mov    (%eax),%eax
f01177fa:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01177fd:	75 16                	jne    f0117815 <test_kmalloc+0x845>
f01177ff:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117802:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0117809:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011780c:	01 d0                	add    %edx,%eax
f011780e:	8b 00                	mov    (%eax),%eax
f0117810:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117813:	74 17                	je     f011782c <test_kmalloc+0x85c>
f0117815:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011781c:	83 ec 0c             	sub    $0xc,%esp
f011781f:	68 cc bf 12 f0       	push   $0xf012bfcc
f0117824:	e8 62 97 fe ff       	call   f0100f8b <cprintf>
f0117829:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f011782c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011782f:	8a 00                	mov    (%eax),%al
f0117831:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117834:	75 0f                	jne    f0117845 <test_kmalloc+0x875>
f0117836:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0117839:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011783c:	01 d0                	add    %edx,%eax
f011783e:	8a 00                	mov    (%eax),%al
f0117840:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0117843:	74 17                	je     f011785c <test_kmalloc+0x88c>
f0117845:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011784c:	83 ec 0c             	sub    $0xc,%esp
f011784f:	68 08 c0 12 f0       	push   $0xf012c008
f0117854:	e8 32 97 fe ff       	call   f0100f8b <cprintf>
f0117859:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f011785c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011785f:	8a 00                	mov    (%eax),%al
f0117861:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117864:	75 16                	jne    f011787c <test_kmalloc+0x8ac>
f0117866:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117869:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117870:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117873:	01 d0                	add    %edx,%eax
f0117875:	8a 00                	mov    (%eax),%al
f0117877:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011787a:	74 17                	je     f0117893 <test_kmalloc+0x8c3>
f011787c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117883:	83 ec 0c             	sub    $0xc,%esp
f0117886:	68 44 c0 12 f0       	push   $0xf012c044
f011788b:	e8 fb 96 fe ff       	call   f0100f8b <cprintf>
f0117890:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f0117893:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117896:	66 8b 40 02          	mov    0x2(%eax),%ax
f011789a:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011789e:	75 19                	jne    f01178b9 <test_kmalloc+0x8e9>
f01178a0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01178a3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01178aa:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01178ad:	01 d0                	add    %edx,%eax
f01178af:	66 8b 40 02          	mov    0x2(%eax),%ax
f01178b3:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01178b7:	74 17                	je     f01178d0 <test_kmalloc+0x900>
f01178b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178c0:	83 ec 0c             	sub    $0xc,%esp
f01178c3:	68 80 c0 12 f0       	push   $0xf012c080
f01178c8:	e8 be 96 fe ff       	call   f0100f8b <cprintf>
f01178cd:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f01178d0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01178d3:	8b 40 04             	mov    0x4(%eax),%eax
f01178d6:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01178d9:	75 17                	jne    f01178f2 <test_kmalloc+0x922>
f01178db:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01178de:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01178e5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01178e8:	01 d0                	add    %edx,%eax
f01178ea:	8b 40 04             	mov    0x4(%eax),%eax
f01178ed:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01178f0:	74 17                	je     f0117909 <test_kmalloc+0x939>
f01178f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178f9:	83 ec 0c             	sub    $0xc,%esp
f01178fc:	68 bc c0 12 f0       	push   $0xf012c0bc
f0117901:	e8 85 96 fe ff       	call   f0100f8b <cprintf>
f0117906:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0117909:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011790c:	8a 00                	mov    (%eax),%al
f011790e:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117911:	75 34                	jne    f0117947 <test_kmalloc+0x977>
f0117913:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117916:	89 c2                	mov    %eax,%edx
f0117918:	c1 ea 1f             	shr    $0x1f,%edx
f011791b:	01 d0                	add    %edx,%eax
f011791d:	d1 f8                	sar    %eax
f011791f:	89 c2                	mov    %eax,%edx
f0117921:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117924:	01 d0                	add    %edx,%eax
f0117926:	8a 10                	mov    (%eax),%dl
f0117928:	8a 45 ea             	mov    -0x16(%ebp),%al
f011792b:	88 c1                	mov    %al,%cl
f011792d:	c0 e9 07             	shr    $0x7,%cl
f0117930:	01 c8                	add    %ecx,%eax
f0117932:	d0 f8                	sar    %al
f0117934:	38 c2                	cmp    %al,%dl
f0117936:	75 0f                	jne    f0117947 <test_kmalloc+0x977>
f0117938:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011793b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011793e:	01 d0                	add    %edx,%eax
f0117940:	8a 00                	mov    (%eax),%al
f0117942:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0117945:	74 17                	je     f011795e <test_kmalloc+0x98e>
f0117947:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011794e:	83 ec 0c             	sub    $0xc,%esp
f0117951:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0117956:	e8 30 96 fe ff       	call   f0100f8b <cprintf>
f011795b:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f011795e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117961:	66 8b 00             	mov    (%eax),%ax
f0117964:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117968:	75 15                	jne    f011797f <test_kmalloc+0x9af>
f011796a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011796d:	01 c0                	add    %eax,%eax
f011796f:	89 c2                	mov    %eax,%edx
f0117971:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117974:	01 d0                	add    %edx,%eax
f0117976:	66 8b 00             	mov    (%eax),%ax
f0117979:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011797d:	74 17                	je     f0117996 <test_kmalloc+0x9c6>
f011797f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117986:	83 ec 0c             	sub    $0xc,%esp
f0117989:	68 30 c1 12 f0       	push   $0xf012c130
f011798e:	e8 f8 95 fe ff       	call   f0100f8b <cprintf>
f0117993:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117996:	e8 ad 72 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011799b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011799e:	74 17                	je     f01179b7 <test_kmalloc+0x9e7>
f01179a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179a7:	83 ec 0c             	sub    $0xc,%esp
f01179aa:	68 6c c1 12 f0       	push   $0xf012c16c
f01179af:	e8 d7 95 fe ff       	call   f0100f8b <cprintf>
f01179b4:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01179b7:	e8 d7 d0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01179bc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01179bf:	74 17                	je     f01179d8 <test_kmalloc+0xa08>
f01179c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179c8:	83 ec 0c             	sub    $0xc,%esp
f01179cb:	68 b0 c1 12 f0       	push   $0xf012c1b0
f01179d0:	e8 b6 95 fe ff       	call   f0100f8b <cprintf>
f01179d5:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f01179d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01179dc:	74 04                	je     f01179e2 <test_kmalloc+0xa12>
f01179de:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f01179e2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f01179e9:	83 ec 0c             	sub    $0xc,%esp
f01179ec:	68 1c c2 12 f0       	push   $0xf012c21c
f01179f1:	e8 95 95 fe ff       	call   f0100f8b <cprintf>
f01179f6:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f01179f9:	e8 4a 72 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01179fe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a01:	e8 8d d0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117a06:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo);
f0117a09:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f0117a10:	8b 45 90             	mov    -0x70(%ebp),%eax
f0117a13:	40                   	inc    %eax
f0117a14:	83 ec 0c             	sub    $0xc,%esp
f0117a17:	50                   	push   %eax
f0117a18:	e8 b2 1d ff ff       	call   f01097cf <kmalloc>
f0117a1d:	83 c4 10             	add    $0x10,%esp
f0117a20:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f0117a26:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0117a2c:	85 c0                	test   %eax,%eax
f0117a2e:	74 17                	je     f0117a47 <test_kmalloc+0xa77>
f0117a30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a37:	83 ec 0c             	sub    $0xc,%esp
f0117a3a:	68 40 c2 12 f0       	push   $0xf012c240
f0117a3f:	e8 47 95 fe ff       	call   f0100f8b <cprintf>
f0117a44:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a47:	e8 47 d0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117a4c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117a4f:	74 17                	je     f0117a68 <test_kmalloc+0xa98>
f0117a51:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a58:	83 ec 0c             	sub    $0xc,%esp
f0117a5b:	68 78 c2 12 f0       	push   $0xf012c278
f0117a60:	e8 26 95 fe ff       	call   f0100f8b <cprintf>
f0117a65:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117a68:	e8 db 71 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117a6d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117a70:	74 17                	je     f0117a89 <test_kmalloc+0xab9>
f0117a72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a79:	83 ec 0c             	sub    $0xc,%esp
f0117a7c:	68 e4 c2 12 f0       	push   $0xf012c2e4
f0117a81:	e8 05 95 fe ff       	call   f0100f8b <cprintf>
f0117a86:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117a89:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117a8d:	74 04                	je     f0117a93 <test_kmalloc+0xac3>
f0117a8f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117a93:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f0117a9a:	83 ec 0c             	sub    $0xc,%esp
f0117a9d:	68 28 c3 12 f0       	push   $0xf012c328
f0117aa2:	e8 e4 94 fe ff       	call   f0100f8b <cprintf>
f0117aa7:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f0117aaa:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117ab0:	05 00 40 00 00       	add    $0x4000,%eax
f0117ab5:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117ab8:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0117abf:	eb 6a                	jmp    f0117b2b <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0117ac1:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f0117ac6:	83 ec 04             	sub    $0x4,%esp
f0117ac9:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0117acf:	52                   	push   %edx
f0117ad0:	ff 75 ec             	pushl  -0x14(%ebp)
f0117ad3:	50                   	push   %eax
f0117ad4:	e8 41 0c ff ff       	call   f010871a <get_page_table>
f0117ad9:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0117adc:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0117ae2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0117ae5:	c1 ea 0c             	shr    $0xc,%edx
f0117ae8:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117aee:	c1 e2 02             	shl    $0x2,%edx
f0117af1:	01 d0                	add    %edx,%eax
f0117af3:	8b 00                	mov    (%eax),%eax
f0117af5:	25 ff 0f 00 00       	and    $0xfff,%eax
f0117afa:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f0117afd:	8b 45 88             	mov    -0x78(%ebp),%eax
f0117b00:	83 e0 04             	and    $0x4,%eax
f0117b03:	85 c0                	test   %eax,%eax
f0117b05:	74 1d                	je     f0117b24 <test_kmalloc+0xb54>
			{
				if (correct)
f0117b07:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117b0b:	74 17                	je     f0117b24 <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f0117b0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b14:	83 ec 0c             	sub    $0xc,%esp
f0117b17:	68 6c c3 12 f0       	push   $0xf012c36c
f0117b1c:	e8 6a 94 fe ff       	call   f0100f8b <cprintf>
f0117b21:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117b24:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f0117b2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117b2e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0117b31:	72 8e                	jb     f0117ac1 <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0117b33:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117b37:	74 04                	je     f0117b3d <test_kmalloc+0xb6d>
f0117b39:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f0117b3d:	83 ec 08             	sub    $0x8,%esp
f0117b40:	ff 75 f4             	pushl  -0xc(%ebp)
f0117b43:	68 bc c3 12 f0       	push   $0xf012c3bc
f0117b48:	e8 3e 94 fe ff       	call   f0100f8b <cprintf>
f0117b4d:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117b50:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0117b55:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0117b58:	5b                   	pop    %ebx
f0117b59:	5f                   	pop    %edi
f0117b5a:	5d                   	pop    %ebp
f0117b5b:	c3                   	ret    

f0117b5c <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f0117b5c:	55                   	push   %ebp
f0117b5d:	89 e5                	mov    %esp,%ebp
f0117b5f:	57                   	push   %edi
f0117b60:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117b63:	83 ec 0c             	sub    $0xc,%esp
f0117b66:	68 28 b5 12 f0       	push   $0xf012b528
f0117b6b:	e8 1b 94 fe ff       	call   f0100f8b <cprintf>
f0117b70:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117b73:	83 ec 0c             	sub    $0xc,%esp
f0117b76:	68 58 b5 12 f0       	push   $0xf012b558
f0117b7b:	e8 0b 94 fe ff       	call   f0100f8b <cprintf>
f0117b80:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117b83:	83 ec 0c             	sub    $0xc,%esp
f0117b86:	68 28 b5 12 f0       	push   $0xf012b528
f0117b8b:	e8 fb 93 fe ff       	call   f0100f8b <cprintf>
f0117b90:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117b93:	8d 55 98             	lea    -0x68(%ebp),%edx
f0117b96:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117b9b:	b8 00 00 00 00       	mov    $0x0,%eax
f0117ba0:	89 d7                	mov    %edx,%edi
f0117ba2:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117ba4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0117bab:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117bb2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f0117bb9:	83 ec 0c             	sub    $0xc,%esp
f0117bbc:	68 e8 c3 12 f0       	push   $0xf012c3e8
f0117bc1:	e8 c5 93 fe ff       	call   f0100f8b <cprintf>
f0117bc6:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117bc9:	e8 7a 70 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117bce:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117bd1:	e8 bd ce fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117bd6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f0117bd9:	83 ec 0c             	sub    $0xc,%esp
f0117bdc:	68 00 fc 0f 00       	push   $0xffc00
f0117be1:	e8 e9 1b ff ff       	call   f01097cf <kmalloc>
f0117be6:	83 c4 10             	add    $0x10,%esp
f0117be9:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f0117bec:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117bef:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117bf4:	74 17                	je     f0117c0d <test_kmalloc_firstfit1+0xb1>
f0117bf6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bfd:	83 ec 0c             	sub    $0xc,%esp
f0117c00:	68 28 c4 12 f0       	push   $0xf012c428
f0117c05:	e8 81 93 fe ff       	call   f0100f8b <cprintf>
f0117c0a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c0d:	e8 81 ce fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117c12:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c15:	74 17                	je     f0117c2e <test_kmalloc_firstfit1+0xd2>
f0117c17:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c1e:	83 ec 0c             	sub    $0xc,%esp
f0117c21:	68 4c b7 12 f0       	push   $0xf012b74c
f0117c26:	e8 60 93 fe ff       	call   f0100f8b <cprintf>
f0117c2b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f0117c2e:	e8 15 70 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117c33:	89 c2                	mov    %eax,%edx
f0117c35:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c38:	29 d0                	sub    %edx,%eax
f0117c3a:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117c3f:	7f 17                	jg     f0117c58 <test_kmalloc_firstfit1+0xfc>
f0117c41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c48:	83 ec 0c             	sub    $0xc,%esp
f0117c4b:	68 5b c4 12 f0       	push   $0xf012c45b
f0117c50:	e8 36 93 fe ff       	call   f0100f8b <cprintf>
f0117c55:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c58:	e8 eb 6f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117c5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c60:	e8 2e ce fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117c65:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0117c68:	83 ec 0c             	sub    $0xc,%esp
f0117c6b:	68 00 fc 0f 00       	push   $0xffc00
f0117c70:	e8 5a 1b ff ff       	call   f01097cf <kmalloc>
f0117c75:	83 c4 10             	add    $0x10,%esp
f0117c78:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0117c7b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117c7e:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117c83:	74 17                	je     f0117c9c <test_kmalloc_firstfit1+0x140>
f0117c85:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c8c:	83 ec 0c             	sub    $0xc,%esp
f0117c8f:	68 74 c4 12 f0       	push   $0xf012c474
f0117c94:	e8 f2 92 fe ff       	call   f0100f8b <cprintf>
f0117c99:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c9c:	e8 f2 cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117ca1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ca4:	74 17                	je     f0117cbd <test_kmalloc_firstfit1+0x161>
f0117ca6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cad:	83 ec 0c             	sub    $0xc,%esp
f0117cb0:	68 50 b8 12 f0       	push   $0xf012b850
f0117cb5:	e8 d1 92 fe ff       	call   f0100f8b <cprintf>
f0117cba:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117cbd:	e8 86 6f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117cc2:	89 c2                	mov    %eax,%edx
f0117cc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117cc7:	29 d0                	sub    %edx,%eax
f0117cc9:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117cce:	7f 17                	jg     f0117ce7 <test_kmalloc_firstfit1+0x18b>
f0117cd0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cd7:	83 ec 0c             	sub    $0xc,%esp
f0117cda:	68 a7 c4 12 f0       	push   $0xf012c4a7
f0117cdf:	e8 a7 92 fe ff       	call   f0100f8b <cprintf>
f0117ce4:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ce7:	e8 5c 6f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117cec:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117cef:	e8 9f cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117cf4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0117cf7:	83 ec 0c             	sub    $0xc,%esp
f0117cfa:	68 00 fc 0f 00       	push   $0xffc00
f0117cff:	e8 cb 1a ff ff       	call   f01097cf <kmalloc>
f0117d04:	83 c4 10             	add    $0x10,%esp
f0117d07:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117d0a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117d0d:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117d12:	74 17                	je     f0117d2b <test_kmalloc_firstfit1+0x1cf>
f0117d14:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d1b:	83 ec 0c             	sub    $0xc,%esp
f0117d1e:	68 c0 c4 12 f0       	push   $0xf012c4c0
f0117d23:	e8 63 92 fe ff       	call   f0100f8b <cprintf>
f0117d28:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d2b:	e8 63 cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117d30:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d33:	74 17                	je     f0117d4c <test_kmalloc_firstfit1+0x1f0>
f0117d35:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d3c:	83 ec 0c             	sub    $0xc,%esp
f0117d3f:	68 8c b9 12 f0       	push   $0xf012b98c
f0117d44:	e8 42 92 fe ff       	call   f0100f8b <cprintf>
f0117d49:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117d4c:	e8 f7 6e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117d51:	89 c2                	mov    %eax,%edx
f0117d53:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117d56:	29 d0                	sub    %edx,%eax
f0117d58:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117d5d:	7f 17                	jg     f0117d76 <test_kmalloc_firstfit1+0x21a>
f0117d5f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d66:	83 ec 0c             	sub    $0xc,%esp
f0117d69:	68 f3 c4 12 f0       	push   $0xf012c4f3
f0117d6e:	e8 18 92 fe ff       	call   f0100f8b <cprintf>
f0117d73:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d76:	e8 cd 6e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117d7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d7e:	e8 10 cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117d83:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0117d86:	83 ec 0c             	sub    $0xc,%esp
f0117d89:	68 00 fc 0f 00       	push   $0xffc00
f0117d8e:	e8 3c 1a ff ff       	call   f01097cf <kmalloc>
f0117d93:	83 c4 10             	add    $0x10,%esp
f0117d96:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117d99:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117d9c:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117da1:	74 17                	je     f0117dba <test_kmalloc_firstfit1+0x25e>
f0117da3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117daa:	83 ec 0c             	sub    $0xc,%esp
f0117dad:	68 0c c5 12 f0       	push   $0xf012c50c
f0117db2:	e8 d4 91 fe ff       	call   f0100f8b <cprintf>
f0117db7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117dba:	e8 d4 cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117dbf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117dc2:	74 17                	je     f0117ddb <test_kmalloc_firstfit1+0x27f>
f0117dc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dcb:	83 ec 0c             	sub    $0xc,%esp
f0117dce:	68 84 ba 12 f0       	push   $0xf012ba84
f0117dd3:	e8 b3 91 fe ff       	call   f0100f8b <cprintf>
f0117dd8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117ddb:	e8 68 6e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117de0:	89 c2                	mov    %eax,%edx
f0117de2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117de5:	29 d0                	sub    %edx,%eax
f0117de7:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117dec:	7f 17                	jg     f0117e05 <test_kmalloc_firstfit1+0x2a9>
f0117dee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117df5:	83 ec 0c             	sub    $0xc,%esp
f0117df8:	68 3f c5 12 f0       	push   $0xf012c53f
f0117dfd:	e8 89 91 fe ff       	call   f0100f8b <cprintf>
f0117e02:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e05:	e8 3e 6e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117e0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e0d:	e8 81 cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117e12:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0117e15:	83 ec 0c             	sub    $0xc,%esp
f0117e18:	68 00 fc 1f 00       	push   $0x1ffc00
f0117e1d:	e8 ad 19 ff ff       	call   f01097cf <kmalloc>
f0117e22:	83 c4 10             	add    $0x10,%esp
f0117e25:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f0117e28:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117e2b:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117e30:	74 17                	je     f0117e49 <test_kmalloc_firstfit1+0x2ed>
f0117e32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e39:	83 ec 0c             	sub    $0xc,%esp
f0117e3c:	68 58 c5 12 f0       	push   $0xf012c558
f0117e41:	e8 45 91 fe ff       	call   f0100f8b <cprintf>
f0117e46:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e49:	e8 45 cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117e4e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e51:	74 17                	je     f0117e6a <test_kmalloc_firstfit1+0x30e>
f0117e53:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e5a:	83 ec 0c             	sub    $0xc,%esp
f0117e5d:	68 64 bb 12 f0       	push   $0xf012bb64
f0117e62:	e8 24 91 fe ff       	call   f0100f8b <cprintf>
f0117e67:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0117e6a:	e8 d9 6d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117e6f:	89 c2                	mov    %eax,%edx
f0117e71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117e74:	29 d0                	sub    %edx,%eax
f0117e76:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117e7b:	7f 17                	jg     f0117e94 <test_kmalloc_firstfit1+0x338>
f0117e7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e84:	83 ec 0c             	sub    $0xc,%esp
f0117e87:	68 8b c5 12 f0       	push   $0xf012c58b
f0117e8c:	e8 fa 90 fe ff       	call   f0100f8b <cprintf>
f0117e91:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e94:	e8 af 6d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117e99:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e9c:	e8 f2 cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117ea1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0117ea4:	83 ec 0c             	sub    $0xc,%esp
f0117ea7:	68 00 fc 1f 00       	push   $0x1ffc00
f0117eac:	e8 1e 19 ff ff       	call   f01097cf <kmalloc>
f0117eb1:	83 c4 10             	add    $0x10,%esp
f0117eb4:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117eb7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117eba:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117ebf:	74 17                	je     f0117ed8 <test_kmalloc_firstfit1+0x37c>
f0117ec1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ec8:	83 ec 0c             	sub    $0xc,%esp
f0117ecb:	68 a4 c5 12 f0       	push   $0xf012c5a4
f0117ed0:	e8 b6 90 fe ff       	call   f0100f8b <cprintf>
f0117ed5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ed8:	e8 b6 cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117edd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ee0:	74 17                	je     f0117ef9 <test_kmalloc_firstfit1+0x39d>
f0117ee2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ee9:	83 ec 0c             	sub    $0xc,%esp
f0117eec:	68 68 bc 12 f0       	push   $0xf012bc68
f0117ef1:	e8 95 90 fe ff       	call   f0100f8b <cprintf>
f0117ef6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117ef9:	e8 4a 6d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117efe:	89 c2                	mov    %eax,%edx
f0117f00:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f03:	29 d0                	sub    %edx,%eax
f0117f05:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117f0a:	7f 17                	jg     f0117f23 <test_kmalloc_firstfit1+0x3c7>
f0117f0c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f13:	83 ec 0c             	sub    $0xc,%esp
f0117f16:	68 d7 c5 12 f0       	push   $0xf012c5d7
f0117f1b:	e8 6b 90 fe ff       	call   f0100f8b <cprintf>
f0117f20:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f23:	e8 20 6d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117f28:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f2b:	e8 63 cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117f30:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117f33:	83 ec 0c             	sub    $0xc,%esp
f0117f36:	68 00 fc 2f 00       	push   $0x2ffc00
f0117f3b:	e8 8f 18 ff ff       	call   f01097cf <kmalloc>
f0117f40:	83 c4 10             	add    $0x10,%esp
f0117f43:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0117f46:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117f49:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0117f4e:	74 17                	je     f0117f67 <test_kmalloc_firstfit1+0x40b>
f0117f50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f57:	83 ec 0c             	sub    $0xc,%esp
f0117f5a:	68 f0 c5 12 f0       	push   $0xf012c5f0
f0117f5f:	e8 27 90 fe ff       	call   f0100f8b <cprintf>
f0117f64:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f67:	e8 27 cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117f6c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f6f:	74 17                	je     f0117f88 <test_kmalloc_firstfit1+0x42c>
f0117f71:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f78:	83 ec 0c             	sub    $0xc,%esp
f0117f7b:	68 6c bd 12 f0       	push   $0xf012bd6c
f0117f80:	e8 06 90 fe ff       	call   f0100f8b <cprintf>
f0117f85:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0117f88:	e8 bb 6c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117f8d:	89 c2                	mov    %eax,%edx
f0117f8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f92:	29 d0                	sub    %edx,%eax
f0117f94:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117f99:	7f 17                	jg     f0117fb2 <test_kmalloc_firstfit1+0x456>
f0117f9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fa2:	83 ec 0c             	sub    $0xc,%esp
f0117fa5:	68 23 c6 12 f0       	push   $0xf012c623
f0117faa:	e8 dc 8f fe ff       	call   f0100f8b <cprintf>
f0117faf:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117fb2:	e8 91 6c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117fb7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117fba:	e8 d4 ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117fbf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0117fc2:	83 ec 0c             	sub    $0xc,%esp
f0117fc5:	68 00 fc 2f 00       	push   $0x2ffc00
f0117fca:	e8 00 18 ff ff       	call   f01097cf <kmalloc>
f0117fcf:	83 c4 10             	add    $0x10,%esp
f0117fd2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0117fd5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117fd8:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0117fdd:	74 17                	je     f0117ff6 <test_kmalloc_firstfit1+0x49a>
f0117fdf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fe6:	83 ec 0c             	sub    $0xc,%esp
f0117fe9:	68 3c c6 12 f0       	push   $0xf012c63c
f0117fee:	e8 98 8f fe ff       	call   f0100f8b <cprintf>
f0117ff3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ff6:	e8 98 ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117ffb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ffe:	74 17                	je     f0118017 <test_kmalloc_firstfit1+0x4bb>
f0118000:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118007:	83 ec 0c             	sub    $0xc,%esp
f011800a:	68 70 be 12 f0       	push   $0xf012be70
f011800f:	e8 77 8f fe ff       	call   f0100f8b <cprintf>
f0118014:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0118017:	e8 2c 6c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011801c:	89 c2                	mov    %eax,%edx
f011801e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118021:	29 d0                	sub    %edx,%eax
f0118023:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118028:	7f 17                	jg     f0118041 <test_kmalloc_firstfit1+0x4e5>
f011802a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118031:	83 ec 0c             	sub    $0xc,%esp
f0118034:	68 6f c6 12 f0       	push   $0xf012c66f
f0118039:	e8 4d 8f fe ff       	call   f0100f8b <cprintf>
f011803e:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118041:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118045:	74 04                	je     f011804b <test_kmalloc_firstfit1+0x4ef>
f0118047:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011804b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0118052:	83 ec 0c             	sub    $0xc,%esp
f0118055:	68 88 c6 12 f0       	push   $0xf012c688
f011805a:	e8 2c 8f fe ff       	call   f0100f8b <cprintf>
f011805f:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118062:	e8 e1 6b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118067:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011806a:	e8 24 ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011806f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0118072:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118075:	83 ec 0c             	sub    $0xc,%esp
f0118078:	50                   	push   %eax
f0118079:	e8 11 1a ff ff       	call   f0109a8f <kfree>
f011807e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118081:	e8 0d ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118086:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118089:	74 17                	je     f01180a2 <test_kmalloc_firstfit1+0x546>
f011808b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118092:	83 ec 0c             	sub    $0xc,%esp
f0118095:	68 b0 c6 12 f0       	push   $0xf012c6b0
f011809a:	e8 ec 8e fe ff       	call   f0100f8b <cprintf>
f011809f:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f01180a2:	e8 a1 6b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01180a7:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01180aa:	3d ff 00 00 00       	cmp    $0xff,%eax
f01180af:	7f 17                	jg     f01180c8 <test_kmalloc_firstfit1+0x56c>
f01180b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180b8:	83 ec 0c             	sub    $0xc,%esp
f01180bb:	68 1b c7 12 f0       	push   $0xf012c71b
f01180c0:	e8 c6 8e fe ff       	call   f0100f8b <cprintf>
f01180c5:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01180c8:	e8 7b 6b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01180cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01180d0:	e8 be c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01180d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f01180d8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01180db:	83 ec 0c             	sub    $0xc,%esp
f01180de:	50                   	push   %eax
f01180df:	e8 ab 19 ff ff       	call   f0109a8f <kfree>
f01180e4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01180e7:	e8 a7 c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01180ec:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01180ef:	74 17                	je     f0118108 <test_kmalloc_firstfit1+0x5ac>
f01180f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180f8:	83 ec 0c             	sub    $0xc,%esp
f01180fb:	68 2c c7 12 f0       	push   $0xf012c72c
f0118100:	e8 86 8e fe ff       	call   f0100f8b <cprintf>
f0118105:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f0118108:	e8 3b 6b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011810d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118110:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118115:	7f 17                	jg     f011812e <test_kmalloc_firstfit1+0x5d2>
f0118117:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011811e:	83 ec 0c             	sub    $0xc,%esp
f0118121:	68 98 c7 12 f0       	push   $0xf012c798
f0118126:	e8 60 8e fe ff       	call   f0100f8b <cprintf>
f011812b:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011812e:	e8 15 6b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118133:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118136:	e8 58 c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011813b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f011813e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118141:	83 ec 0c             	sub    $0xc,%esp
f0118144:	50                   	push   %eax
f0118145:	e8 45 19 ff ff       	call   f0109a8f <kfree>
f011814a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011814d:	e8 41 c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118152:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118155:	74 17                	je     f011816e <test_kmalloc_firstfit1+0x612>
f0118157:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011815e:	83 ec 0c             	sub    $0xc,%esp
f0118161:	68 ac c7 12 f0       	push   $0xf012c7ac
f0118166:	e8 20 8e fe ff       	call   f0100f8b <cprintf>
f011816b:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f011816e:	e8 d5 6a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118173:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118176:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011817b:	7f 17                	jg     f0118194 <test_kmalloc_firstfit1+0x638>
f011817d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118184:	83 ec 0c             	sub    $0xc,%esp
f0118187:	68 18 c8 12 f0       	push   $0xf012c818
f011818c:	e8 fa 8d fe ff       	call   f0100f8b <cprintf>
f0118191:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118194:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118198:	74 04                	je     f011819e <test_kmalloc_firstfit1+0x642>
f011819a:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011819e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f01181a5:	83 ec 0c             	sub    $0xc,%esp
f01181a8:	68 2c c8 12 f0       	push   $0xf012c82c
f01181ad:	e8 d9 8d fe ff       	call   f0100f8b <cprintf>
f01181b2:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01181b5:	e8 8e 6a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01181ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01181bd:	e8 d1 c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01181c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f01181c5:	83 ec 0c             	sub    $0xc,%esp
f01181c8:	68 00 fc 07 00       	push   $0x7fc00
f01181cd:	e8 fd 15 ff ff       	call   f01097cf <kmalloc>
f01181d2:	83 c4 10             	add    $0x10,%esp
f01181d5:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f01181d8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01181db:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f01181e0:	74 17                	je     f01181f9 <test_kmalloc_firstfit1+0x69d>
f01181e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181e9:	83 ec 0c             	sub    $0xc,%esp
f01181ec:	68 58 c8 12 f0       	push   $0xf012c858
f01181f1:	e8 95 8d fe ff       	call   f0100f8b <cprintf>
f01181f6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181f9:	e8 95 c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01181fe:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118201:	74 17                	je     f011821a <test_kmalloc_firstfit1+0x6be>
f0118203:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011820a:	83 ec 0c             	sub    $0xc,%esp
f011820d:	68 8c c8 12 f0       	push   $0xf012c88c
f0118212:	e8 74 8d fe ff       	call   f0100f8b <cprintf>
f0118217:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f011821a:	e8 29 6a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011821f:	89 c2                	mov    %eax,%edx
f0118221:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118224:	29 d0                	sub    %edx,%eax
f0118226:	83 f8 7f             	cmp    $0x7f,%eax
f0118229:	7f 17                	jg     f0118242 <test_kmalloc_firstfit1+0x6e6>
f011822b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118232:	83 ec 0c             	sub    $0xc,%esp
f0118235:	68 f8 c8 12 f0       	push   $0xf012c8f8
f011823a:	e8 4c 8d fe ff       	call   f0100f8b <cprintf>
f011823f:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118242:	e8 01 6a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118247:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011824a:	e8 44 c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011824f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f0118252:	83 ec 0c             	sub    $0xc,%esp
f0118255:	68 00 fc 0f 00       	push   $0xffc00
f011825a:	e8 70 15 ff ff       	call   f01097cf <kmalloc>
f011825f:	83 c4 10             	add    $0x10,%esp
f0118262:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0118265:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118268:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011826d:	74 17                	je     f0118286 <test_kmalloc_firstfit1+0x72a>
f011826f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118276:	83 ec 0c             	sub    $0xc,%esp
f0118279:	68 10 c9 12 f0       	push   $0xf012c910
f011827e:	e8 08 8d fe ff       	call   f0100f8b <cprintf>
f0118283:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118286:	e8 08 c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011828b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011828e:	74 17                	je     f01182a7 <test_kmalloc_firstfit1+0x74b>
f0118290:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118297:	83 ec 0c             	sub    $0xc,%esp
f011829a:	68 44 c9 12 f0       	push   $0xf012c944
f011829f:	e8 e7 8c fe ff       	call   f0100f8b <cprintf>
f01182a4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f01182a7:	e8 9c 69 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01182ac:	89 c2                	mov    %eax,%edx
f01182ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01182b1:	29 d0                	sub    %edx,%eax
f01182b3:	3d ff 00 00 00       	cmp    $0xff,%eax
f01182b8:	7f 17                	jg     f01182d1 <test_kmalloc_firstfit1+0x775>
f01182ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182c1:	83 ec 0c             	sub    $0xc,%esp
f01182c4:	68 b0 c9 12 f0       	push   $0xf012c9b0
f01182c9:	e8 bd 8c fe ff       	call   f0100f8b <cprintf>
f01182ce:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01182d1:	e8 72 69 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01182d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01182d9:	e8 b5 c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01182de:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f01182e1:	83 ec 0c             	sub    $0xc,%esp
f01182e4:	68 00 fc 03 00       	push   $0x3fc00
f01182e9:	e8 e1 14 ff ff       	call   f01097cf <kmalloc>
f01182ee:	83 c4 10             	add    $0x10,%esp
f01182f1:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f01182f4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01182f7:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f01182fc:	74 17                	je     f0118315 <test_kmalloc_firstfit1+0x7b9>
f01182fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118305:	83 ec 0c             	sub    $0xc,%esp
f0118308:	68 c8 c9 12 f0       	push   $0xf012c9c8
f011830d:	e8 79 8c fe ff       	call   f0100f8b <cprintf>
f0118312:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118315:	e8 79 c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011831a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011831d:	74 17                	je     f0118336 <test_kmalloc_firstfit1+0x7da>
f011831f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118326:	83 ec 0c             	sub    $0xc,%esp
f0118329:	68 fc c9 12 f0       	push   $0xf012c9fc
f011832e:	e8 58 8c fe ff       	call   f0100f8b <cprintf>
f0118333:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0118336:	e8 0d 69 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011833b:	89 c2                	mov    %eax,%edx
f011833d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118340:	29 d0                	sub    %edx,%eax
f0118342:	83 f8 3f             	cmp    $0x3f,%eax
f0118345:	7f 17                	jg     f011835e <test_kmalloc_firstfit1+0x802>
f0118347:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011834e:	83 ec 0c             	sub    $0xc,%esp
f0118351:	68 68 ca 12 f0       	push   $0xf012ca68
f0118356:	e8 30 8c fe ff       	call   f0100f8b <cprintf>
f011835b:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011835e:	e8 e5 68 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118363:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118366:	e8 28 c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011836b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f011836e:	83 ec 0c             	sub    $0xc,%esp
f0118371:	68 00 00 20 00       	push   $0x200000
f0118376:	e8 54 14 ff ff       	call   f01097cf <kmalloc>
f011837b:	83 c4 10             	add    $0x10,%esp
f011837e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f0118381:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118384:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0118389:	74 17                	je     f01183a2 <test_kmalloc_firstfit1+0x846>
f011838b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118392:	83 ec 0c             	sub    $0xc,%esp
f0118395:	68 80 ca 12 f0       	push   $0xf012ca80
f011839a:	e8 ec 8b fe ff       	call   f0100f8b <cprintf>
f011839f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f01183a2:	e8 a1 68 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01183a7:	89 c2                	mov    %eax,%edx
f01183a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01183ac:	29 d0                	sub    %edx,%eax
f01183ae:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01183b3:	7f 17                	jg     f01183cc <test_kmalloc_firstfit1+0x870>
f01183b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183bc:	83 ec 0c             	sub    $0xc,%esp
f01183bf:	68 b4 ca 12 f0       	push   $0xf012cab4
f01183c4:	e8 c2 8b fe ff       	call   f0100f8b <cprintf>
f01183c9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01183cc:	e8 c2 c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01183d1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01183d4:	74 17                	je     f01183ed <test_kmalloc_firstfit1+0x891>
f01183d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183dd:	83 ec 0c             	sub    $0xc,%esp
f01183e0:	68 cc ca 12 f0       	push   $0xf012cacc
f01183e5:	e8 a1 8b fe ff       	call   f0100f8b <cprintf>
f01183ea:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f01183ed:	e8 56 68 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01183f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01183f5:	e8 99 c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01183fa:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f01183fd:	83 ec 0c             	sub    $0xc,%esp
f0118400:	68 00 fc 3f 00       	push   $0x3ffc00
f0118405:	e8 c5 13 ff ff       	call   f01097cf <kmalloc>
f011840a:	83 c4 10             	add    $0x10,%esp
f011840d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0118410:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118413:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f0118418:	74 17                	je     f0118431 <test_kmalloc_firstfit1+0x8d5>
f011841a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118421:	83 ec 0c             	sub    $0xc,%esp
f0118424:	68 38 cb 12 f0       	push   $0xf012cb38
f0118429:	e8 5d 8b fe ff       	call   f0100f8b <cprintf>
f011842e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118431:	e8 5d c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118436:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118439:	74 17                	je     f0118452 <test_kmalloc_firstfit1+0x8f6>
f011843b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118442:	83 ec 0c             	sub    $0xc,%esp
f0118445:	68 6c cb 12 f0       	push   $0xf012cb6c
f011844a:	e8 3c 8b fe ff       	call   f0100f8b <cprintf>
f011844f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f0118452:	e8 f1 67 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118457:	89 c2                	mov    %eax,%edx
f0118459:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011845c:	29 d0                	sub    %edx,%eax
f011845e:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f0118463:	7f 17                	jg     f011847c <test_kmalloc_firstfit1+0x920>
f0118465:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011846c:	83 ec 0c             	sub    $0xc,%esp
f011846f:	68 d8 cb 12 f0       	push   $0xf012cbd8
f0118474:	e8 12 8b fe ff       	call   f0100f8b <cprintf>
f0118479:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f011847c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118480:	74 04                	je     f0118486 <test_kmalloc_firstfit1+0x92a>
f0118482:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0118486:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f011848d:	83 ec 0c             	sub    $0xc,%esp
f0118490:	68 f0 cb 12 f0       	push   $0xf012cbf0
f0118495:	e8 f1 8a fe ff       	call   f0100f8b <cprintf>
f011849a:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011849d:	e8 a6 67 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01184a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01184a5:	e8 e9 c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01184aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f01184ad:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01184b0:	83 ec 0c             	sub    $0xc,%esp
f01184b3:	50                   	push   %eax
f01184b4:	e8 d6 15 ff ff       	call   f0109a8f <kfree>
f01184b9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184bc:	e8 d2 c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01184c1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01184c4:	74 17                	je     f01184dd <test_kmalloc_firstfit1+0x981>
f01184c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184cd:	83 ec 0c             	sub    $0xc,%esp
f01184d0:	68 b0 c1 12 f0       	push   $0xf012c1b0
f01184d5:	e8 b1 8a fe ff       	call   f0100f8b <cprintf>
f01184da:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f01184dd:	e8 66 67 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01184e2:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01184e5:	3d ff 00 00 00       	cmp    $0xff,%eax
f01184ea:	7f 17                	jg     f0118503 <test_kmalloc_firstfit1+0x9a7>
f01184ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184f3:	83 ec 0c             	sub    $0xc,%esp
f01184f6:	68 24 cc 12 f0       	push   $0xf012cc24
f01184fb:	e8 8b 8a fe ff       	call   f0100f8b <cprintf>
f0118500:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0118503:	e8 40 67 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118508:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011850b:	e8 83 c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118510:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0118513:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118516:	83 ec 0c             	sub    $0xc,%esp
f0118519:	50                   	push   %eax
f011851a:	e8 70 15 ff ff       	call   f0109a8f <kfree>
f011851f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118522:	e8 6c c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118527:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011852a:	74 17                	je     f0118543 <test_kmalloc_firstfit1+0x9e7>
f011852c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118533:	83 ec 0c             	sub    $0xc,%esp
f0118536:	68 78 c2 12 f0       	push   $0xf012c278
f011853b:	e8 4b 8a fe ff       	call   f0100f8b <cprintf>
f0118540:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f0118543:	e8 00 67 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118548:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011854b:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118550:	7f 17                	jg     f0118569 <test_kmalloc_firstfit1+0xa0d>
f0118552:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118559:	83 ec 0c             	sub    $0xc,%esp
f011855c:	68 35 cc 12 f0       	push   $0xf012cc35
f0118561:	e8 25 8a fe ff       	call   f0100f8b <cprintf>
f0118566:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118569:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011856d:	74 04                	je     f0118573 <test_kmalloc_firstfit1+0xa17>
f011856f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118573:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f011857a:	83 ec 0c             	sub    $0xc,%esp
f011857d:	68 48 cc 12 f0       	push   $0xf012cc48
f0118582:	e8 04 8a fe ff       	call   f0100f8b <cprintf>
f0118587:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f011858a:	e8 b9 66 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011858f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118592:	e8 fc c4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118597:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f011859a:	83 ec 0c             	sub    $0xc,%esp
f011859d:	68 00 00 10 00       	push   $0x100000
f01185a2:	e8 28 12 ff ff       	call   f01097cf <kmalloc>
f01185a7:	83 c4 10             	add    $0x10,%esp
f01185aa:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f01185ad:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01185b0:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f01185b5:	74 17                	je     f01185ce <test_kmalloc_firstfit1+0xa72>
f01185b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185be:	83 ec 0c             	sub    $0xc,%esp
f01185c1:	68 88 cc 12 f0       	push   $0xf012cc88
f01185c6:	e8 c0 89 fe ff       	call   f0100f8b <cprintf>
f01185cb:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185ce:	e8 c0 c4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01185d3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01185d6:	74 17                	je     f01185ef <test_kmalloc_firstfit1+0xa93>
f01185d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185df:	83 ec 0c             	sub    $0xc,%esp
f01185e2:	68 bc cc 12 f0       	push   $0xf012ccbc
f01185e7:	e8 9f 89 fe ff       	call   f0100f8b <cprintf>
f01185ec:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f01185ef:	e8 54 66 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01185f4:	89 c2                	mov    %eax,%edx
f01185f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01185f9:	29 d0                	sub    %edx,%eax
f01185fb:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118600:	7f 17                	jg     f0118619 <test_kmalloc_firstfit1+0xabd>
f0118602:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118609:	83 ec 0c             	sub    $0xc,%esp
f011860c:	68 28 cd 12 f0       	push   $0xf012cd28
f0118611:	e8 75 89 fe ff       	call   f0100f8b <cprintf>
f0118616:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0118619:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011861d:	74 04                	je     f0118623 <test_kmalloc_firstfit1+0xac7>
f011861f:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0118623:	83 ec 08             	sub    $0x8,%esp
f0118626:	ff 75 f4             	pushl  -0xc(%ebp)
f0118629:	68 40 cd 12 f0       	push   $0xf012cd40
f011862e:	e8 58 89 fe ff       	call   f0100f8b <cprintf>
f0118633:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118636:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011863b:	8b 7d fc             	mov    -0x4(%ebp),%edi
f011863e:	c9                   	leave  
f011863f:	c3                   	ret    

f0118640 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f0118640:	55                   	push   %ebp
f0118641:	89 e5                	mov    %esp,%ebp
f0118643:	57                   	push   %edi
f0118644:	53                   	push   %ebx
f0118645:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118648:	83 ec 0c             	sub    $0xc,%esp
f011864b:	68 28 b5 12 f0       	push   $0xf012b528
f0118650:	e8 36 89 fe ff       	call   f0100f8b <cprintf>
f0118655:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118658:	83 ec 0c             	sub    $0xc,%esp
f011865b:	68 58 b5 12 f0       	push   $0xf012b558
f0118660:	e8 26 89 fe ff       	call   f0100f8b <cprintf>
f0118665:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118668:	83 ec 0c             	sub    $0xc,%esp
f011866b:	68 28 b5 12 f0       	push   $0xf012b528
f0118670:	e8 16 89 fe ff       	call   f0100f8b <cprintf>
f0118675:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0118678:	8d 55 98             	lea    -0x68(%ebp),%edx
f011867b:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118680:	b8 00 00 00 00       	mov    $0x0,%eax
f0118685:	89 d7                	mov    %edx,%edi
f0118687:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0118689:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0118690:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0118697:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f011869e:	83 ec 0c             	sub    $0xc,%esp
f01186a1:	68 78 cd 12 f0       	push   $0xf012cd78
f01186a6:	e8 e0 88 fe ff       	call   f0100f8b <cprintf>
f01186ab:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f01186ae:	83 ec 0c             	sub    $0xc,%esp
f01186b1:	68 01 e0 ff 07       	push   $0x7ffe001
f01186b6:	e8 14 11 ff ff       	call   f01097cf <kmalloc>
f01186bb:	83 c4 10             	add    $0x10,%esp
f01186be:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f01186c1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01186c4:	85 c0                	test   %eax,%eax
f01186c6:	74 17                	je     f01186df <test_kmalloc_firstfit2+0x9f>
f01186c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186cf:	83 ec 0c             	sub    $0xc,%esp
f01186d2:	68 ac cd 12 f0       	push   $0xf012cdac
f01186d7:	e8 af 88 fe ff       	call   f0100f8b <cprintf>
f01186dc:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01186df:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01186e3:	74 04                	je     f01186e9 <test_kmalloc_firstfit2+0xa9>
f01186e5:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01186e9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f01186f0:	83 ec 0c             	sub    $0xc,%esp
f01186f3:	68 f4 cd 12 f0       	push   $0xf012cdf4
f01186f8:	e8 8e 88 fe ff       	call   f0100f8b <cprintf>
f01186fd:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118700:	e8 43 65 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118705:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118708:	e8 86 c3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011870d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0118710:	83 ec 0c             	sub    $0xc,%esp
f0118713:	68 00 fc 1f 00       	push   $0x1ffc00
f0118718:	e8 b2 10 ff ff       	call   f01097cf <kmalloc>
f011871d:	83 c4 10             	add    $0x10,%esp
f0118720:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0118723:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118726:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011872b:	74 17                	je     f0118744 <test_kmalloc_firstfit2+0x104>
f011872d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118734:	83 ec 0c             	sub    $0xc,%esp
f0118737:	68 74 c4 12 f0       	push   $0xf012c474
f011873c:	e8 4a 88 fe ff       	call   f0100f8b <cprintf>
f0118741:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118744:	e8 4a c3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118749:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011874c:	74 17                	je     f0118765 <test_kmalloc_firstfit2+0x125>
f011874e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118755:	83 ec 0c             	sub    $0xc,%esp
f0118758:	68 50 b8 12 f0       	push   $0xf012b850
f011875d:	e8 29 88 fe ff       	call   f0100f8b <cprintf>
f0118762:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0118765:	e8 de 64 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011876a:	89 c2                	mov    %eax,%edx
f011876c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011876f:	29 d0                	sub    %edx,%eax
f0118771:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118776:	7f 17                	jg     f011878f <test_kmalloc_firstfit2+0x14f>
f0118778:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011877f:	83 ec 0c             	sub    $0xc,%esp
f0118782:	68 a7 c4 12 f0       	push   $0xf012c4a7
f0118787:	e8 ff 87 fe ff       	call   f0100f8b <cprintf>
f011878c:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011878f:	e8 b4 64 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118794:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118797:	e8 f7 c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011879c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011879f:	83 ec 0c             	sub    $0xc,%esp
f01187a2:	68 00 fc 1f 00       	push   $0x1ffc00
f01187a7:	e8 23 10 ff ff       	call   f01097cf <kmalloc>
f01187ac:	83 c4 10             	add    $0x10,%esp
f01187af:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f01187b2:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01187b5:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01187ba:	74 17                	je     f01187d3 <test_kmalloc_firstfit2+0x193>
f01187bc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187c3:	83 ec 0c             	sub    $0xc,%esp
f01187c6:	68 c0 c4 12 f0       	push   $0xf012c4c0
f01187cb:	e8 bb 87 fe ff       	call   f0100f8b <cprintf>
f01187d0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187d3:	e8 bb c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01187d8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01187db:	74 17                	je     f01187f4 <test_kmalloc_firstfit2+0x1b4>
f01187dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187e4:	83 ec 0c             	sub    $0xc,%esp
f01187e7:	68 8c b9 12 f0       	push   $0xf012b98c
f01187ec:	e8 9a 87 fe ff       	call   f0100f8b <cprintf>
f01187f1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01187f4:	e8 4f 64 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01187f9:	89 c2                	mov    %eax,%edx
f01187fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01187fe:	29 d0                	sub    %edx,%eax
f0118800:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118805:	7f 17                	jg     f011881e <test_kmalloc_firstfit2+0x1de>
f0118807:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011880e:	83 ec 0c             	sub    $0xc,%esp
f0118811:	68 f3 c4 12 f0       	push   $0xf012c4f3
f0118816:	e8 70 87 fe ff       	call   f0100f8b <cprintf>
f011881b:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011881e:	e8 25 64 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118823:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118826:	e8 68 c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011882b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011882e:	83 ec 0c             	sub    $0xc,%esp
f0118831:	68 00 1c 00 00       	push   $0x1c00
f0118836:	e8 94 0f ff ff       	call   f01097cf <kmalloc>
f011883b:	83 c4 10             	add    $0x10,%esp
f011883e:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0118841:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118844:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118849:	74 17                	je     f0118862 <test_kmalloc_firstfit2+0x222>
f011884b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118852:	83 ec 0c             	sub    $0xc,%esp
f0118855:	68 0c c5 12 f0       	push   $0xf012c50c
f011885a:	e8 2c 87 fe ff       	call   f0100f8b <cprintf>
f011885f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118862:	e8 2c c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118867:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011886a:	74 17                	je     f0118883 <test_kmalloc_firstfit2+0x243>
f011886c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118873:	83 ec 0c             	sub    $0xc,%esp
f0118876:	68 84 ba 12 f0       	push   $0xf012ba84
f011887b:	e8 0b 87 fe ff       	call   f0100f8b <cprintf>
f0118880:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0118883:	e8 c0 63 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118888:	89 c2                	mov    %eax,%edx
f011888a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011888d:	29 d0                	sub    %edx,%eax
f011888f:	83 f8 01             	cmp    $0x1,%eax
f0118892:	7f 17                	jg     f01188ab <test_kmalloc_firstfit2+0x26b>
f0118894:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011889b:	83 ec 0c             	sub    $0xc,%esp
f011889e:	68 3f c5 12 f0       	push   $0xf012c53f
f01188a3:	e8 e3 86 fe ff       	call   f0100f8b <cprintf>
f01188a8:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01188ab:	e8 98 63 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01188b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01188b3:	e8 db c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01188b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f01188bb:	8b 45 98             	mov    -0x68(%ebp),%eax
f01188be:	83 ec 0c             	sub    $0xc,%esp
f01188c1:	50                   	push   %eax
f01188c2:	e8 c8 11 ff ff       	call   f0109a8f <kfree>
f01188c7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01188ca:	e8 c4 c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01188cf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01188d2:	74 17                	je     f01188eb <test_kmalloc_firstfit2+0x2ab>
f01188d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188db:	83 ec 0c             	sub    $0xc,%esp
f01188de:	68 64 bb 12 f0       	push   $0xf012bb64
f01188e3:	e8 a3 86 fe ff       	call   f0100f8b <cprintf>
f01188e8:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f01188eb:	e8 58 63 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01188f0:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01188f3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01188f8:	7f 17                	jg     f0118911 <test_kmalloc_firstfit2+0x2d1>
f01188fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118901:	83 ec 0c             	sub    $0xc,%esp
f0118904:	68 3a ce 12 f0       	push   $0xf012ce3a
f0118909:	e8 7d 86 fe ff       	call   f0100f8b <cprintf>
f011890e:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118911:	e8 32 63 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118916:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118919:	e8 75 c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011891e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0118921:	83 ec 0c             	sub    $0xc,%esp
f0118924:	68 00 fc 2f 00       	push   $0x2ffc00
f0118929:	e8 a1 0e ff ff       	call   f01097cf <kmalloc>
f011892e:	83 c4 10             	add    $0x10,%esp
f0118931:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0118934:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118937:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011893c:	74 17                	je     f0118955 <test_kmalloc_firstfit2+0x315>
f011893e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118945:	83 ec 0c             	sub    $0xc,%esp
f0118948:	68 a4 c5 12 f0       	push   $0xf012c5a4
f011894d:	e8 39 86 fe ff       	call   f0100f8b <cprintf>
f0118952:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118955:	e8 39 c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011895a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011895d:	74 17                	je     f0118976 <test_kmalloc_firstfit2+0x336>
f011895f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118966:	83 ec 0c             	sub    $0xc,%esp
f0118969:	68 68 bc 12 f0       	push   $0xf012bc68
f011896e:	e8 18 86 fe ff       	call   f0100f8b <cprintf>
f0118973:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0118976:	e8 cd 62 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011897b:	89 c2                	mov    %eax,%edx
f011897d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118980:	29 d0                	sub    %edx,%eax
f0118982:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118987:	7f 17                	jg     f01189a0 <test_kmalloc_firstfit2+0x360>
f0118989:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118990:	83 ec 0c             	sub    $0xc,%esp
f0118993:	68 d7 c5 12 f0       	push   $0xf012c5d7
f0118998:	e8 ee 85 fe ff       	call   f0100f8b <cprintf>
f011899d:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01189a0:	e8 a3 62 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01189a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01189a8:	e8 e6 c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01189ad:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f01189b0:	83 ec 0c             	sub    $0xc,%esp
f01189b3:	68 00 18 20 00       	push   $0x201800
f01189b8:	e8 12 0e ff ff       	call   f01097cf <kmalloc>
f01189bd:	83 c4 10             	add    $0x10,%esp
f01189c0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f01189c3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01189c6:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01189cb:	74 17                	je     f01189e4 <test_kmalloc_firstfit2+0x3a4>
f01189cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189d4:	83 ec 0c             	sub    $0xc,%esp
f01189d7:	68 f0 c5 12 f0       	push   $0xf012c5f0
f01189dc:	e8 aa 85 fe ff       	call   f0100f8b <cprintf>
f01189e1:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01189e4:	e8 aa c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01189e9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01189ec:	74 17                	je     f0118a05 <test_kmalloc_firstfit2+0x3c5>
f01189ee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189f5:	83 ec 0c             	sub    $0xc,%esp
f01189f8:	68 6c bd 12 f0       	push   $0xf012bd6c
f01189fd:	e8 89 85 fe ff       	call   f0100f8b <cprintf>
f0118a02:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0118a05:	e8 3e 62 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118a0a:	89 c2                	mov    %eax,%edx
f0118a0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a0f:	29 d0                	sub    %edx,%eax
f0118a11:	3d 01 02 00 00       	cmp    $0x201,%eax
f0118a16:	7f 17                	jg     f0118a2f <test_kmalloc_firstfit2+0x3ef>
f0118a18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a1f:	83 ec 0c             	sub    $0xc,%esp
f0118a22:	68 23 c6 12 f0       	push   $0xf012c623
f0118a27:	e8 5f 85 fe ff       	call   f0100f8b <cprintf>
f0118a2c:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118a2f:	e8 14 62 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118a34:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a37:	e8 57 c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118a3c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0118a3f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118a42:	83 ec 0c             	sub    $0xc,%esp
f0118a45:	50                   	push   %eax
f0118a46:	e8 44 10 ff ff       	call   f0109a8f <kfree>
f0118a4b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a4e:	e8 40 c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118a53:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a56:	74 17                	je     f0118a6f <test_kmalloc_firstfit2+0x42f>
f0118a58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a5f:	83 ec 0c             	sub    $0xc,%esp
f0118a62:	68 70 be 12 f0       	push   $0xf012be70
f0118a67:	e8 1f 85 fe ff       	call   f0100f8b <cprintf>
f0118a6c:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f0118a6f:	e8 d4 61 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118a74:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118a77:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118a7c:	7f 17                	jg     f0118a95 <test_kmalloc_firstfit2+0x455>
f0118a7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a85:	83 ec 0c             	sub    $0xc,%esp
f0118a88:	68 4a ce 12 f0       	push   $0xf012ce4a
f0118a8d:	e8 f9 84 fe ff       	call   f0100f8b <cprintf>
f0118a92:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0118a95:	e8 ae 61 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118a9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a9d:	e8 f1 bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118aa2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0118aa5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118aa8:	83 ec 0c             	sub    $0xc,%esp
f0118aab:	50                   	push   %eax
f0118aac:	e8 de 0f ff ff       	call   f0109a8f <kfree>
f0118ab1:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f0118ab4:	e8 8f 61 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118ab9:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118abc:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118ac1:	7f 17                	jg     f0118ada <test_kmalloc_firstfit2+0x49a>
f0118ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118aca:	83 ec 0c             	sub    $0xc,%esp
f0118acd:	68 1b c7 12 f0       	push   $0xf012c71b
f0118ad2:	e8 b4 84 fe ff       	call   f0100f8b <cprintf>
f0118ad7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ada:	e8 b4 bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118adf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ae2:	74 17                	je     f0118afb <test_kmalloc_firstfit2+0x4bb>
f0118ae4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118aeb:	83 ec 0c             	sub    $0xc,%esp
f0118aee:	68 b0 c6 12 f0       	push   $0xf012c6b0
f0118af3:	e8 93 84 fe ff       	call   f0100f8b <cprintf>
f0118af8:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118afb:	e8 48 61 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118b00:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b03:	e8 8b bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118b08:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f0118b0b:	83 ec 0c             	sub    $0xc,%esp
f0118b0e:	68 00 fc 4f 00       	push   $0x4ffc00
f0118b13:	e8 b7 0c ff ff       	call   f01097cf <kmalloc>
f0118b18:	83 c4 10             	add    $0x10,%esp
f0118b1b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f0118b1e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118b21:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0118b26:	74 17                	je     f0118b3f <test_kmalloc_firstfit2+0x4ff>
f0118b28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b2f:	83 ec 0c             	sub    $0xc,%esp
f0118b32:	68 5c ce 12 f0       	push   $0xf012ce5c
f0118b37:	e8 4f 84 fe ff       	call   f0100f8b <cprintf>
f0118b3c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b3f:	e8 4f bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118b44:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b47:	74 17                	je     f0118b60 <test_kmalloc_firstfit2+0x520>
f0118b49:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b50:	83 ec 0c             	sub    $0xc,%esp
f0118b53:	68 2c c7 12 f0       	push   $0xf012c72c
f0118b58:	e8 2e 84 fe ff       	call   f0100f8b <cprintf>
f0118b5d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f0118b60:	e8 e3 60 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118b65:	89 c2                	mov    %eax,%edx
f0118b67:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118b6a:	29 d0                	sub    %edx,%eax
f0118b6c:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f0118b71:	7f 17                	jg     f0118b8a <test_kmalloc_firstfit2+0x54a>
f0118b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b7a:	83 ec 0c             	sub    $0xc,%esp
f0118b7d:	68 90 ce 12 f0       	push   $0xf012ce90
f0118b82:	e8 04 84 fe ff       	call   f0100f8b <cprintf>
f0118b87:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0118b8a:	e8 b9 60 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118b8f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b92:	e8 fc be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118b97:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0118b9a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118b9d:	83 ec 0c             	sub    $0xc,%esp
f0118ba0:	50                   	push   %eax
f0118ba1:	e8 e9 0e ff ff       	call   f0109a8f <kfree>
f0118ba6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ba9:	e8 e5 be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118bae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118bb1:	74 17                	je     f0118bca <test_kmalloc_firstfit2+0x58a>
f0118bb3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bba:	83 ec 0c             	sub    $0xc,%esp
f0118bbd:	68 ac c7 12 f0       	push   $0xf012c7ac
f0118bc2:	e8 c4 83 fe ff       	call   f0100f8b <cprintf>
f0118bc7:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f0118bca:	e8 79 60 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118bcf:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118bd2:	83 f8 01             	cmp    $0x1,%eax
f0118bd5:	7f 17                	jg     f0118bee <test_kmalloc_firstfit2+0x5ae>
f0118bd7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bde:	83 ec 0c             	sub    $0xc,%esp
f0118be1:	68 18 c8 12 f0       	push   $0xf012c818
f0118be6:	e8 a0 83 fe ff       	call   f0100f8b <cprintf>
f0118beb:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f0118bee:	e8 55 60 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118bf3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118bf6:	e8 98 be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118bfb:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0118bfe:	83 ec 0c             	sub    $0xc,%esp
f0118c01:	68 00 04 00 00       	push   $0x400
f0118c06:	e8 c4 0b ff ff       	call   f01097cf <kmalloc>
f0118c0b:	83 c4 10             	add    $0x10,%esp
f0118c0e:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118c11:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118c14:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118c19:	76 22                	jbe    f0118c3d <test_kmalloc_firstfit2+0x5fd>
f0118c1b:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f0118c1e:	83 ec 0c             	sub    $0xc,%esp
f0118c21:	6a 00                	push   $0x0
f0118c23:	e8 74 0a ff ff       	call   f010969c <sbrk>
f0118c28:	83 c4 10             	add    $0x10,%esp
f0118c2b:	39 c3                	cmp    %eax,%ebx
f0118c2d:	73 0e                	jae    f0118c3d <test_kmalloc_firstfit2+0x5fd>
f0118c2f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118c32:	89 c2                	mov    %eax,%edx
f0118c34:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0118c39:	39 c2                	cmp    %eax,%edx
f0118c3b:	72 17                	jb     f0118c54 <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118c3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c44:	83 ec 0c             	sub    $0xc,%esp
f0118c47:	68 a8 ce 12 f0       	push   $0xf012cea8
f0118c4c:	e8 3a 83 fe ff       	call   f0100f8b <cprintf>
f0118c51:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c54:	e8 3a be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118c59:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c5c:	74 17                	je     f0118c75 <test_kmalloc_firstfit2+0x635>
f0118c5e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c65:	83 ec 0c             	sub    $0xc,%esp
f0118c68:	68 8c c8 12 f0       	push   $0xf012c88c
f0118c6d:	e8 19 83 fe ff       	call   f0100f8b <cprintf>
f0118c72:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118c75:	e8 19 be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118c7a:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0118c7d:	83 ec 0c             	sub    $0xc,%esp
f0118c80:	68 00 08 00 00       	push   $0x800
f0118c85:	e8 45 0b ff ff       	call   f01097cf <kmalloc>
f0118c8a:	83 c4 10             	add    $0x10,%esp
f0118c8d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0118c90:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118c93:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118c98:	76 22                	jbe    f0118cbc <test_kmalloc_firstfit2+0x67c>
f0118c9a:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0118c9d:	83 ec 0c             	sub    $0xc,%esp
f0118ca0:	6a 00                	push   $0x0
f0118ca2:	e8 f5 09 ff ff       	call   f010969c <sbrk>
f0118ca7:	83 c4 10             	add    $0x10,%esp
f0118caa:	39 c3                	cmp    %eax,%ebx
f0118cac:	73 0e                	jae    f0118cbc <test_kmalloc_firstfit2+0x67c>
f0118cae:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118cb1:	89 c2                	mov    %eax,%edx
f0118cb3:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0118cb8:	39 c2                	cmp    %eax,%edx
f0118cba:	72 17                	jb     f0118cd3 <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118cbc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cc3:	83 ec 0c             	sub    $0xc,%esp
f0118cc6:	68 34 cf 12 f0       	push   $0xf012cf34
f0118ccb:	e8 bb 82 fe ff       	call   f0100f8b <cprintf>
f0118cd0:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118cd3:	e8 bb bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118cd8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118cdb:	74 17                	je     f0118cf4 <test_kmalloc_firstfit2+0x6b4>
f0118cdd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ce4:	83 ec 0c             	sub    $0xc,%esp
f0118ce7:	68 44 c9 12 f0       	push   $0xf012c944
f0118cec:	e8 9a 82 fe ff       	call   f0100f8b <cprintf>
f0118cf1:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118cf4:	e8 9a bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118cf9:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f0118cfc:	83 ec 0c             	sub    $0xc,%esp
f0118cff:	68 00 04 00 00       	push   $0x400
f0118d04:	e8 c6 0a ff ff       	call   f01097cf <kmalloc>
f0118d09:	83 c4 10             	add    $0x10,%esp
f0118d0c:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0118d0f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118d12:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118d17:	76 22                	jbe    f0118d3b <test_kmalloc_firstfit2+0x6fb>
f0118d19:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0118d1c:	83 ec 0c             	sub    $0xc,%esp
f0118d1f:	6a 00                	push   $0x0
f0118d21:	e8 76 09 ff ff       	call   f010969c <sbrk>
f0118d26:	83 c4 10             	add    $0x10,%esp
f0118d29:	39 c3                	cmp    %eax,%ebx
f0118d2b:	73 0e                	jae    f0118d3b <test_kmalloc_firstfit2+0x6fb>
f0118d2d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118d30:	89 c2                	mov    %eax,%edx
f0118d32:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0118d37:	39 c2                	cmp    %eax,%edx
f0118d39:	72 17                	jb     f0118d52 <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118d3b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d42:	83 ec 0c             	sub    $0xc,%esp
f0118d45:	68 c0 cf 12 f0       	push   $0xf012cfc0
f0118d4a:	e8 3c 82 fe ff       	call   f0100f8b <cprintf>
f0118d4f:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d52:	e8 3c bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118d57:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d5a:	74 17                	je     f0118d73 <test_kmalloc_firstfit2+0x733>
f0118d5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d63:	83 ec 0c             	sub    $0xc,%esp
f0118d66:	68 fc c9 12 f0       	push   $0xf012c9fc
f0118d6b:	e8 1b 82 fe ff       	call   f0100f8b <cprintf>
f0118d70:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f0118d73:	e8 d0 5e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118d78:	89 c2                	mov    %eax,%edx
f0118d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118d7d:	29 d0                	sub    %edx,%eax
f0118d7f:	83 f8 01             	cmp    $0x1,%eax
f0118d82:	74 17                	je     f0118d9b <test_kmalloc_firstfit2+0x75b>
f0118d84:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d8b:	83 ec 0c             	sub    $0xc,%esp
f0118d8e:	68 4c d0 12 f0       	push   $0xf012d04c
f0118d93:	e8 f3 81 fe ff       	call   f0100f8b <cprintf>
f0118d98:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0118d9b:	e8 a8 5e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118da0:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118da3:	e8 eb bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118da8:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0118dab:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118dae:	83 ec 0c             	sub    $0xc,%esp
f0118db1:	50                   	push   %eax
f0118db2:	e8 d8 0c ff ff       	call   f0109a8f <kfree>
f0118db7:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118dba:	e8 d4 bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118dbf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118dc2:	74 17                	je     f0118ddb <test_kmalloc_firstfit2+0x79b>
f0118dc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118dcb:	83 ec 0c             	sub    $0xc,%esp
f0118dce:	68 cc ca 12 f0       	push   $0xf012cacc
f0118dd3:	e8 b3 81 fe ff       	call   f0100f8b <cprintf>
f0118dd8:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118ddb:	e8 68 5e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118de0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118de3:	74 17                	je     f0118dfc <test_kmalloc_firstfit2+0x7bc>
f0118de5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118dec:	83 ec 0c             	sub    $0xc,%esp
f0118def:	68 70 d0 12 f0       	push   $0xf012d070
f0118df4:	e8 92 81 fe ff       	call   f0100f8b <cprintf>
f0118df9:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f0118dfc:	e8 47 5e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118e01:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118e04:	e8 8a bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118e09:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f0118e0c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118e0f:	83 ec 0c             	sub    $0xc,%esp
f0118e12:	50                   	push   %eax
f0118e13:	e8 77 0c ff ff       	call   f0109a8f <kfree>
f0118e18:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e1b:	e8 73 bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118e20:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e23:	74 17                	je     f0118e3c <test_kmalloc_firstfit2+0x7fc>
f0118e25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e2c:	83 ec 0c             	sub    $0xc,%esp
f0118e2f:	68 6c cb 12 f0       	push   $0xf012cb6c
f0118e34:	e8 52 81 fe ff       	call   f0100f8b <cprintf>
f0118e39:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118e3c:	e8 07 5e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118e41:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118e44:	74 17                	je     f0118e5d <test_kmalloc_firstfit2+0x81d>
f0118e46:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e4d:	83 ec 0c             	sub    $0xc,%esp
f0118e50:	68 d0 d0 12 f0       	push   $0xf012d0d0
f0118e55:	e8 31 81 fe ff       	call   f0100f8b <cprintf>
f0118e5a:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0118e5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118e61:	74 04                	je     f0118e67 <test_kmalloc_firstfit2+0x827>
f0118e63:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118e67:	83 ec 0c             	sub    $0xc,%esp
f0118e6a:	68 30 d1 12 f0       	push   $0xf012d130
f0118e6f:	e8 17 81 fe ff       	call   f0100f8b <cprintf>
f0118e74:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118e77:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118e7e:	e8 c5 5d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118e83:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118e86:	e8 08 bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118e8b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0118e8e:	83 ec 0c             	sub    $0xc,%esp
f0118e91:	68 00 08 00 00       	push   $0x800
f0118e96:	e8 34 09 ff ff       	call   f01097cf <kmalloc>
f0118e9b:	83 c4 10             	add    $0x10,%esp
f0118e9e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118ea1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118ea4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118ea7:	39 c2                	cmp    %eax,%edx
f0118ea9:	74 17                	je     f0118ec2 <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0118eab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118eb2:	83 ec 0c             	sub    $0xc,%esp
f0118eb5:	68 68 d1 12 f0       	push   $0xf012d168
f0118eba:	e8 cc 80 fe ff       	call   f0100f8b <cprintf>
f0118ebf:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ec2:	e8 cc bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118ec7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118eca:	74 17                	je     f0118ee3 <test_kmalloc_firstfit2+0x8a3>
f0118ecc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ed3:	83 ec 0c             	sub    $0xc,%esp
f0118ed6:	68 b0 c1 12 f0       	push   $0xf012c1b0
f0118edb:	e8 ab 80 fe ff       	call   f0100f8b <cprintf>
f0118ee0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0118ee3:	e8 60 5d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118ee8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118eeb:	74 17                	je     f0118f04 <test_kmalloc_firstfit2+0x8c4>
f0118eed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ef4:	83 ec 0c             	sub    $0xc,%esp
f0118ef7:	68 9c d1 12 f0       	push   $0xf012d19c
f0118efc:	e8 8a 80 fe ff       	call   f0100f8b <cprintf>
f0118f01:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118f04:	e8 3f 5d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118f09:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118f0c:	e8 82 bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118f11:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0118f14:	83 ec 0c             	sub    $0xc,%esp
f0118f17:	68 00 04 00 00       	push   $0x400
f0118f1c:	e8 ae 08 ff ff       	call   f01097cf <kmalloc>
f0118f21:	83 c4 10             	add    $0x10,%esp
f0118f24:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0118f27:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118f2a:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118f2d:	81 c2 08 08 00 00    	add    $0x808,%edx
f0118f33:	39 d0                	cmp    %edx,%eax
f0118f35:	74 17                	je     f0118f4e <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0118f37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f3e:	83 ec 0c             	sub    $0xc,%esp
f0118f41:	68 b4 d1 12 f0       	push   $0xf012d1b4
f0118f46:	e8 40 80 fe ff       	call   f0100f8b <cprintf>
f0118f4b:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118f4e:	e8 40 bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118f53:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f56:	74 17                	je     f0118f6f <test_kmalloc_firstfit2+0x92f>
f0118f58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f5f:	83 ec 0c             	sub    $0xc,%esp
f0118f62:	68 78 c2 12 f0       	push   $0xf012c278
f0118f67:	e8 1f 80 fe ff       	call   f0100f8b <cprintf>
f0118f6c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0118f6f:	e8 d4 5c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118f74:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118f77:	74 17                	je     f0118f90 <test_kmalloc_firstfit2+0x950>
f0118f79:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f80:	83 ec 0c             	sub    $0xc,%esp
f0118f83:	68 e8 d1 12 f0       	push   $0xf012d1e8
f0118f88:	e8 fe 7f fe ff       	call   f0100f8b <cprintf>
f0118f8d:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0118f90:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118f94:	74 04                	je     f0118f9a <test_kmalloc_firstfit2+0x95a>
f0118f96:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118f9a:	83 ec 0c             	sub    $0xc,%esp
f0118f9d:	68 00 d2 12 f0       	push   $0xf012d200
f0118fa2:	e8 e4 7f fe ff       	call   f0100f8b <cprintf>
f0118fa7:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118faa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118fb1:	e8 92 5c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118fb6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118fb9:	e8 d5 ba fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118fbe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0118fc1:	83 ec 0c             	sub    $0xc,%esp
f0118fc4:	68 00 04 70 00       	push   $0x700400
f0118fc9:	e8 01 08 ff ff       	call   f01097cf <kmalloc>
f0118fce:	83 c4 10             	add    $0x10,%esp
f0118fd1:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118fd4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118fd7:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118fdc:	74 17                	je     f0118ff5 <test_kmalloc_firstfit2+0x9b5>
f0118fde:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118fe5:	83 ec 0c             	sub    $0xc,%esp
f0118fe8:	68 88 cc 12 f0       	push   $0xf012cc88
f0118fed:	e8 99 7f fe ff       	call   f0100f8b <cprintf>
f0118ff2:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ff5:	e8 99 ba fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118ffa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ffd:	74 17                	je     f0119016 <test_kmalloc_firstfit2+0x9d6>
f0118fff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119006:	83 ec 0c             	sub    $0xc,%esp
f0119009:	68 bc cc 12 f0       	push   $0xf012ccbc
f011900e:	e8 78 7f fe ff       	call   f0100f8b <cprintf>
f0119013:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0119016:	e8 2d 5c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011901b:	89 c2                	mov    %eax,%edx
f011901d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119020:	29 d0                	sub    %edx,%eax
f0119022:	3d 00 07 00 00       	cmp    $0x700,%eax
f0119027:	7f 17                	jg     f0119040 <test_kmalloc_firstfit2+0xa00>
f0119029:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119030:	83 ec 0c             	sub    $0xc,%esp
f0119033:	68 28 cd 12 f0       	push   $0xf012cd28
f0119038:	e8 4e 7f fe ff       	call   f0100f8b <cprintf>
f011903d:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119040:	e8 03 5c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119045:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119048:	e8 46 ba fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011904d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f0119050:	83 ec 0c             	sub    $0xc,%esp
f0119053:	68 00 0c 00 00       	push   $0xc00
f0119058:	e8 72 07 ff ff       	call   f01097cf <kmalloc>
f011905d:	83 c4 10             	add    $0x10,%esp
f0119060:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0119063:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119066:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f011906b:	74 17                	je     f0119084 <test_kmalloc_firstfit2+0xa44>
f011906d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119074:	83 ec 0c             	sub    $0xc,%esp
f0119077:	68 34 d2 12 f0       	push   $0xf012d234
f011907c:	e8 0a 7f fe ff       	call   f0100f8b <cprintf>
f0119081:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119084:	e8 0a ba fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119089:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011908c:	74 17                	je     f01190a5 <test_kmalloc_firstfit2+0xa65>
f011908e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119095:	83 ec 0c             	sub    $0xc,%esp
f0119098:	68 68 d2 12 f0       	push   $0xf012d268
f011909d:	e8 e9 7e fe ff       	call   f0100f8b <cprintf>
f01190a2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f01190a5:	e8 9e 5b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01190aa:	89 c2                	mov    %eax,%edx
f01190ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01190af:	29 d0                	sub    %edx,%eax
f01190b1:	85 c0                	test   %eax,%eax
f01190b3:	7f 17                	jg     f01190cc <test_kmalloc_firstfit2+0xa8c>
f01190b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190bc:	83 ec 0c             	sub    $0xc,%esp
f01190bf:	68 d4 d2 12 f0       	push   $0xf012d2d4
f01190c4:	e8 c2 7e fe ff       	call   f0100f8b <cprintf>
f01190c9:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f01190cc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01190d0:	74 04                	je     f01190d6 <test_kmalloc_firstfit2+0xa96>
f01190d2:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f01190d6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f01190dd:	83 ec 0c             	sub    $0xc,%esp
f01190e0:	68 ec d2 12 f0       	push   $0xf012d2ec
f01190e5:	e8 a1 7e fe ff       	call   f0100f8b <cprintf>
f01190ea:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f01190ed:	83 ec 0c             	sub    $0xc,%esp
f01190f0:	68 00 e0 1f 07       	push   $0x71fe000
f01190f5:	e8 d5 06 ff ff       	call   f01097cf <kmalloc>
f01190fa:	83 c4 10             	add    $0x10,%esp
f01190fd:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0119100:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119103:	85 c0                	test   %eax,%eax
f0119105:	74 17                	je     f011911e <test_kmalloc_firstfit2+0xade>
f0119107:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011910e:	83 ec 0c             	sub    $0xc,%esp
f0119111:	68 40 d3 12 f0       	push   $0xf012d340
f0119116:	e8 70 7e fe ff       	call   f0100f8b <cprintf>
f011911b:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f011911e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119122:	74 04                	je     f0119128 <test_kmalloc_firstfit2+0xae8>
f0119124:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f0119128:	83 ec 08             	sub    $0x8,%esp
f011912b:	ff 75 f4             	pushl  -0xc(%ebp)
f011912e:	68 a8 d3 12 f0       	push   $0xf012d3a8
f0119133:	e8 53 7e fe ff       	call   f0100f8b <cprintf>
f0119138:	83 c4 10             	add    $0x10,%esp

	return 1;
f011913b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0119140:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0119143:	5b                   	pop    %ebx
f0119144:	5f                   	pop    %edi
f0119145:	5d                   	pop    %ebp
f0119146:	c3                   	ret    

f0119147 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0119147:	55                   	push   %ebp
f0119148:	89 e5                	mov    %esp,%ebp
f011914a:	53                   	push   %ebx
f011914b:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011914e:	83 ec 0c             	sub    $0xc,%esp
f0119151:	68 28 b5 12 f0       	push   $0xf012b528
f0119156:	e8 30 7e fe ff       	call   f0100f8b <cprintf>
f011915b:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011915e:	83 ec 0c             	sub    $0xc,%esp
f0119161:	68 58 b5 12 f0       	push   $0xf012b558
f0119166:	e8 20 7e fe ff       	call   f0100f8b <cprintf>
f011916b:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011916e:	83 ec 0c             	sub    $0xc,%esp
f0119171:	68 28 b5 12 f0       	push   $0xf012b528
f0119176:	e8 10 7e fe ff       	call   f0100f8b <cprintf>
f011917b:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f011917e:	e8 c5 5a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119183:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f0119186:	e8 08 b9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011918b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f011918e:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f0119195:	83 ec 0c             	sub    $0xc,%esp
f0119198:	68 dd d3 12 f0       	push   $0xf012d3dd
f011919d:	e8 e9 7d fe ff       	call   f0100f8b <cprintf>
f01191a2:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f01191a5:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f01191aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01191af:	f7 75 e4             	divl   -0x1c(%ebp)
f01191b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f01191b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01191bc:	eb 1d                	jmp    f01191db <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f01191be:	83 ec 0c             	sub    $0xc,%esp
f01191c1:	ff 75 e4             	pushl  -0x1c(%ebp)
f01191c4:	e8 06 06 ff ff       	call   f01097cf <kmalloc>
f01191c9:	83 c4 10             	add    $0x10,%esp
f01191cc:	89 c2                	mov    %eax,%edx
f01191ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01191d1:	89 14 85 20 6e 6f f0 	mov    %edx,-0xf9091e0(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f01191d8:	ff 45 f4             	incl   -0xc(%ebp)
f01191db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01191de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01191e1:	7c db                	jl     f01191be <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f01191e3:	83 ec 0c             	sub    $0xc,%esp
f01191e6:	68 e1 d3 12 f0       	push   $0xf012d3e1
f01191eb:	e8 9b 7d fe ff       	call   f0100f8b <cprintf>
f01191f0:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f01191f3:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f01191f8:	ba 00 00 00 00       	mov    $0x0,%edx
f01191fd:	f7 75 e4             	divl   -0x1c(%ebp)
f0119200:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0119203:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0119207:	74 1e                	je     f0119227 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0119209:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f011920c:	8d 43 01             	lea    0x1(%ebx),%eax
f011920f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0119212:	83 ec 0c             	sub    $0xc,%esp
f0119215:	ff 75 e0             	pushl  -0x20(%ebp)
f0119218:	e8 b2 05 ff ff       	call   f01097cf <kmalloc>
f011921d:	83 c4 10             	add    $0x10,%esp
f0119220:	89 04 9d 20 6e 6f f0 	mov    %eax,-0xf9091e0(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0119227:	83 ec 04             	sub    $0x4,%esp
f011922a:	ff 75 f0             	pushl  -0x10(%ebp)
f011922d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119230:	68 e8 d3 12 f0       	push   $0xf012d3e8
f0119235:	e8 51 7d fe ff       	call   f0100f8b <cprintf>
f011923a:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f011923d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119244:	eb 36                	jmp    f011927c <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0119246:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119249:	8b 04 85 20 6e 6f f0 	mov    -0xf9091e0(,%eax,4),%eax
f0119250:	89 c2                	mov    %eax,%edx
f0119252:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119255:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119259:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f011925e:	39 c2                	cmp    %eax,%edx
f0119260:	74 17                	je     f0119279 <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0119262:	83 ec 04             	sub    $0x4,%esp
f0119265:	68 30 d4 12 f0       	push   $0xf012d430
f011926a:	68 e3 02 00 00       	push   $0x2e3
f011926f:	68 73 d4 12 f0       	push   $0xf012d473
f0119274:	e8 c0 70 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0119279:	ff 45 f4             	incl   -0xc(%ebp)
f011927c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011927f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0119282:	7c c2                	jl     f0119246 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119284:	e8 0a b8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119289:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011928c:	74 17                	je     f01192a5 <test_fastfirstfit+0x15e>
f011928e:	83 ec 04             	sub    $0x4,%esp
f0119291:	68 8c d4 12 f0       	push   $0xf012d48c
f0119296:	68 e6 02 00 00       	push   $0x2e6
f011929b:	68 73 d4 12 f0       	push   $0xf012d473
f01192a0:	e8 94 70 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f01192a5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01192a8:	e8 9b 59 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01192ad:	29 c3                	sub    %eax,%ebx
f01192af:	89 d8                	mov    %ebx,%eax
f01192b1:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f01192b6:	77 17                	ja     f01192cf <test_fastfirstfit+0x188>
f01192b8:	83 ec 04             	sub    $0x4,%esp
f01192bb:	68 f4 d4 12 f0       	push   $0xf012d4f4
f01192c0:	68 e7 02 00 00       	push   $0x2e7
f01192c5:	68 73 d4 12 f0       	push   $0xf012d473
f01192ca:	e8 6a 70 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f01192cf:	e8 bf b7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01192d4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f01192d7:	e8 6c 59 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01192dc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f01192df:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f01192e3:	7f 17                	jg     f01192fc <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f01192e5:	83 ec 04             	sub    $0x4,%esp
f01192e8:	68 08 d5 12 f0       	push   $0xf012d508
f01192ed:	68 ee 02 00 00       	push   $0x2ee
f01192f2:	68 73 d4 12 f0       	push   $0xf012d473
f01192f7:	e8 3d 70 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f01192fc:	a1 20 6e 6f f0       	mov    0xf06f6e20,%eax
f0119301:	83 ec 0c             	sub    $0xc,%esp
f0119304:	50                   	push   %eax
f0119305:	e8 85 07 ff ff       	call   f0109a8f <kfree>
f011930a:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f011930d:	a1 28 6e 6f f0       	mov    0xf06f6e28,%eax
f0119312:	83 ec 0c             	sub    $0xc,%esp
f0119315:	50                   	push   %eax
f0119316:	e8 74 07 ff ff       	call   f0109a8f <kfree>
f011931b:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f011931e:	a1 2c 6e 6f f0       	mov    0xf06f6e2c,%eax
f0119323:	83 ec 0c             	sub    $0xc,%esp
f0119326:	50                   	push   %eax
f0119327:	e8 63 07 ff ff       	call   f0109a8f <kfree>
f011932c:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f011932f:	a1 34 6e 6f f0       	mov    0xf06f6e34,%eax
f0119334:	83 ec 0c             	sub    $0xc,%esp
f0119337:	50                   	push   %eax
f0119338:	e8 52 07 ff ff       	call   f0109a8f <kfree>
f011933d:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f0119340:	a1 48 6e 6f f0       	mov    0xf06f6e48,%eax
f0119345:	83 ec 0c             	sub    $0xc,%esp
f0119348:	50                   	push   %eax
f0119349:	e8 41 07 ff ff       	call   f0109a8f <kfree>
f011934e:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f0119351:	a1 50 6e 6f f0       	mov    0xf06f6e50,%eax
f0119356:	83 ec 0c             	sub    $0xc,%esp
f0119359:	50                   	push   %eax
f011935a:	e8 30 07 ff ff       	call   f0109a8f <kfree>
f011935f:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f0119362:	a1 4c 6e 6f f0       	mov    0xf06f6e4c,%eax
f0119367:	83 ec 0c             	sub    $0xc,%esp
f011936a:	50                   	push   %eax
f011936b:	e8 1f 07 ff ff       	call   f0109a8f <kfree>
f0119370:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f0119373:	a1 70 6e 6f f0       	mov    0xf06f6e70,%eax
f0119378:	83 ec 0c             	sub    $0xc,%esp
f011937b:	50                   	push   %eax
f011937c:	e8 0e 07 ff ff       	call   f0109a8f <kfree>
f0119381:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f0119384:	a1 84 6e 6f f0       	mov    0xf06f6e84,%eax
f0119389:	83 ec 0c             	sub    $0xc,%esp
f011938c:	50                   	push   %eax
f011938d:	e8 fd 06 ff ff       	call   f0109a8f <kfree>
f0119392:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f0119395:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119398:	83 e8 02             	sub    $0x2,%eax
f011939b:	8b 04 85 20 6e 6f f0 	mov    -0xf9091e0(,%eax,4),%eax
f01193a2:	83 ec 0c             	sub    $0xc,%esp
f01193a5:	50                   	push   %eax
f01193a6:	e8 e4 06 ff ff       	call   f0109a8f <kfree>
f01193ab:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f01193ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01193b1:	83 e8 03             	sub    $0x3,%eax
f01193b4:	8b 04 85 20 6e 6f f0 	mov    -0xf9091e0(,%eax,4),%eax
f01193bb:	83 ec 0c             	sub    $0xc,%esp
f01193be:	50                   	push   %eax
f01193bf:	e8 cb 06 ff ff       	call   f0109a8f <kfree>
f01193c4:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01193c7:	e8 c7 b6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01193cc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01193cf:	74 17                	je     f01193e8 <test_fastfirstfit+0x2a1>
f01193d1:	83 ec 04             	sub    $0x4,%esp
f01193d4:	68 8c d4 12 f0       	push   $0xf012d48c
f01193d9:	68 fb 02 00 00       	push   $0x2fb
f01193de:	68 73 d4 12 f0       	push   $0xf012d473
f01193e3:	e8 51 6f fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f01193e8:	e8 5b 58 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01193ed:	89 c2                	mov    %eax,%edx
f01193ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01193f2:	89 d1                	mov    %edx,%ecx
f01193f4:	29 c1                	sub    %eax,%ecx
f01193f6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01193f9:	89 d0                	mov    %edx,%eax
f01193fb:	c1 e0 02             	shl    $0x2,%eax
f01193fe:	01 d0                	add    %edx,%eax
f0119400:	01 c0                	add    %eax,%eax
f0119402:	01 d0                	add    %edx,%eax
f0119404:	c1 e8 0c             	shr    $0xc,%eax
f0119407:	39 c1                	cmp    %eax,%ecx
f0119409:	74 17                	je     f0119422 <test_fastfirstfit+0x2db>
f011940b:	83 ec 04             	sub    $0x4,%esp
f011940e:	68 44 d5 12 f0       	push   $0xf012d544
f0119413:	68 fc 02 00 00       	push   $0x2fc
f0119418:	68 73 d4 12 f0       	push   $0xf012d473
f011941d:	e8 17 6f fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f0119422:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119425:	01 c0                	add    %eax,%eax
f0119427:	89 c2                	mov    %eax,%edx
f0119429:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011942c:	d1 e8                	shr    %eax
f011942e:	01 d0                	add    %edx,%eax
f0119430:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119433:	e8 5b b6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119438:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011943b:	e8 08 58 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119440:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119443:	83 ec 0c             	sub    $0xc,%esp
f0119446:	ff 75 dc             	pushl  -0x24(%ebp)
f0119449:	e8 81 03 ff ff       	call   f01097cf <kmalloc>
f011944e:	83 c4 10             	add    $0x10,%esp
f0119451:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f0119454:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119457:	89 d0                	mov    %edx,%eax
f0119459:	c1 e0 02             	shl    $0x2,%eax
f011945c:	01 d0                	add    %edx,%eax
f011945e:	01 c0                	add    %eax,%eax
f0119460:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119466:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119469:	39 c2                	cmp    %eax,%edx
f011946b:	74 17                	je     f0119484 <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f011946d:	83 ec 04             	sub    $0x4,%esp
f0119470:	68 84 d5 12 f0       	push   $0xf012d584
f0119475:	68 07 03 00 00       	push   $0x307
f011947a:	68 73 d4 12 f0       	push   $0xf012d473
f011947f:	e8 b5 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119484:	e8 0a b6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119489:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011948c:	74 17                	je     f01194a5 <test_fastfirstfit+0x35e>
f011948e:	83 ec 04             	sub    $0x4,%esp
f0119491:	68 8c d4 12 f0       	push   $0xf012d48c
f0119496:	68 08 03 00 00       	push   $0x308
f011949b:	68 73 d4 12 f0       	push   $0xf012d473
f01194a0:	e8 94 6e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01194a5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01194a8:	e8 9b 57 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01194ad:	29 c3                	sub    %eax,%ebx
f01194af:	89 da                	mov    %ebx,%edx
f01194b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01194b4:	c1 e8 0c             	shr    $0xc,%eax
f01194b7:	39 c2                	cmp    %eax,%edx
f01194b9:	73 17                	jae    f01194d2 <test_fastfirstfit+0x38b>
f01194bb:	83 ec 04             	sub    $0x4,%esp
f01194be:	68 f4 d4 12 f0       	push   $0xf012d4f4
f01194c3:	68 09 03 00 00       	push   $0x309
f01194c8:	68 73 d4 12 f0       	push   $0xf012d473
f01194cd:	e8 67 6e fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f01194d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01194d5:	01 c0                	add    %eax,%eax
f01194d7:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01194da:	e8 b4 b5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01194df:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01194e2:	e8 61 57 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01194e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01194ea:	83 ec 0c             	sub    $0xc,%esp
f01194ed:	ff 75 dc             	pushl  -0x24(%ebp)
f01194f0:	e8 da 02 ff ff       	call   f01097cf <kmalloc>
f01194f5:	83 c4 10             	add    $0x10,%esp
f01194f8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f01194fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01194fe:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0119503:	01 c0                	add    %eax,%eax
f0119505:	89 c2                	mov    %eax,%edx
f0119507:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011950a:	39 c2                	cmp    %eax,%edx
f011950c:	74 17                	je     f0119525 <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f011950e:	83 ec 04             	sub    $0x4,%esp
f0119511:	68 84 d5 12 f0       	push   $0xf012d584
f0119516:	68 13 03 00 00       	push   $0x313
f011951b:	68 73 d4 12 f0       	push   $0xf012d473
f0119520:	e8 14 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119525:	e8 69 b5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011952a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011952d:	74 17                	je     f0119546 <test_fastfirstfit+0x3ff>
f011952f:	83 ec 04             	sub    $0x4,%esp
f0119532:	68 8c d4 12 f0       	push   $0xf012d48c
f0119537:	68 14 03 00 00       	push   $0x314
f011953c:	68 73 d4 12 f0       	push   $0xf012d473
f0119541:	e8 f3 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119546:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119549:	e8 fa 56 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011954e:	29 c3                	sub    %eax,%ebx
f0119550:	89 da                	mov    %ebx,%edx
f0119552:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119555:	c1 e8 0c             	shr    $0xc,%eax
f0119558:	39 c2                	cmp    %eax,%edx
f011955a:	73 17                	jae    f0119573 <test_fastfirstfit+0x42c>
f011955c:	83 ec 04             	sub    $0x4,%esp
f011955f:	68 f4 d4 12 f0       	push   $0xf012d4f4
f0119564:	68 15 03 00 00       	push   $0x315
f0119569:	68 73 d4 12 f0       	push   $0xf012d473
f011956e:	e8 c6 6d fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f0119573:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119576:	89 c2                	mov    %eax,%edx
f0119578:	01 d2                	add    %edx,%edx
f011957a:	01 d0                	add    %edx,%eax
f011957c:	d1 e8                	shr    %eax
f011957e:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119581:	e8 0d b5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119586:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119589:	e8 ba 56 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011958e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119591:	83 ec 0c             	sub    $0xc,%esp
f0119594:	ff 75 dc             	pushl  -0x24(%ebp)
f0119597:	e8 33 02 ff ff       	call   f01097cf <kmalloc>
f011959c:	83 c4 10             	add    $0x10,%esp
f011959f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f01195a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01195a5:	83 e8 03             	sub    $0x3,%eax
f01195a8:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01195ac:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01195b2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01195b5:	39 c2                	cmp    %eax,%edx
f01195b7:	74 17                	je     f01195d0 <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f01195b9:	83 ec 04             	sub    $0x4,%esp
f01195bc:	68 84 d5 12 f0       	push   $0xf012d584
f01195c1:	68 1f 03 00 00       	push   $0x31f
f01195c6:	68 73 d4 12 f0       	push   $0xf012d473
f01195cb:	e8 69 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01195d0:	e8 be b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01195d5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01195d8:	74 17                	je     f01195f1 <test_fastfirstfit+0x4aa>
f01195da:	83 ec 04             	sub    $0x4,%esp
f01195dd:	68 8c d4 12 f0       	push   $0xf012d48c
f01195e2:	68 20 03 00 00       	push   $0x320
f01195e7:	68 73 d4 12 f0       	push   $0xf012d473
f01195ec:	e8 48 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01195f1:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01195f4:	e8 4f 56 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01195f9:	29 c3                	sub    %eax,%ebx
f01195fb:	89 da                	mov    %ebx,%edx
f01195fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119600:	c1 e8 0c             	shr    $0xc,%eax
f0119603:	39 c2                	cmp    %eax,%edx
f0119605:	73 17                	jae    f011961e <test_fastfirstfit+0x4d7>
f0119607:	83 ec 04             	sub    $0x4,%esp
f011960a:	68 f4 d4 12 f0       	push   $0xf012d4f4
f011960f:	68 21 03 00 00       	push   $0x321
f0119614:	68 73 d4 12 f0       	push   $0xf012d473
f0119619:	e8 1b 6d fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f011961e:	e8 70 b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119623:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119626:	e8 1d 56 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011962b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f011962e:	83 ec 0c             	sub    $0xc,%esp
f0119631:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119634:	e8 96 01 ff ff       	call   f01097cf <kmalloc>
f0119639:	83 c4 10             	add    $0x10,%esp
f011963c:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f011963f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119642:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119647:	74 17                	je     f0119660 <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0119649:	83 ec 04             	sub    $0x4,%esp
f011964c:	68 84 d5 12 f0       	push   $0xf012d584
f0119651:	68 2a 03 00 00       	push   $0x32a
f0119656:	68 73 d4 12 f0       	push   $0xf012d473
f011965b:	e8 d9 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119660:	e8 2e b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119665:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119668:	74 17                	je     f0119681 <test_fastfirstfit+0x53a>
f011966a:	83 ec 04             	sub    $0x4,%esp
f011966d:	68 8c d4 12 f0       	push   $0xf012d48c
f0119672:	68 2b 03 00 00       	push   $0x32b
f0119677:	68 73 d4 12 f0       	push   $0xf012d473
f011967c:	e8 b8 6c fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119681:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119684:	e8 bf 55 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119689:	29 c3                	sub    %eax,%ebx
f011968b:	89 da                	mov    %ebx,%edx
f011968d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119690:	c1 e8 0c             	shr    $0xc,%eax
f0119693:	39 c2                	cmp    %eax,%edx
f0119695:	73 17                	jae    f01196ae <test_fastfirstfit+0x567>
f0119697:	83 ec 04             	sub    $0x4,%esp
f011969a:	68 f4 d4 12 f0       	push   $0xf012d4f4
f011969f:	68 2c 03 00 00       	push   $0x32c
f01196a4:	68 73 d4 12 f0       	push   $0xf012d473
f01196a9:	e8 8b 6c fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01196ae:	e8 e0 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01196b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01196b6:	e8 8d 55 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01196bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01196be:	83 ec 0c             	sub    $0xc,%esp
f01196c1:	ff 75 e4             	pushl  -0x1c(%ebp)
f01196c4:	e8 06 01 ff ff       	call   f01097cf <kmalloc>
f01196c9:	83 c4 10             	add    $0x10,%esp
f01196cc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f01196cf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01196d2:	89 d0                	mov    %edx,%eax
f01196d4:	c1 e0 02             	shl    $0x2,%eax
f01196d7:	01 d0                	add    %edx,%eax
f01196d9:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01196df:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01196e2:	39 c2                	cmp    %eax,%edx
f01196e4:	74 17                	je     f01196fd <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f01196e6:	83 ec 04             	sub    $0x4,%esp
f01196e9:	68 84 d5 12 f0       	push   $0xf012d584
f01196ee:	68 35 03 00 00       	push   $0x335
f01196f3:	68 73 d4 12 f0       	push   $0xf012d473
f01196f8:	e8 3c 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01196fd:	e8 91 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119702:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119705:	74 17                	je     f011971e <test_fastfirstfit+0x5d7>
f0119707:	83 ec 04             	sub    $0x4,%esp
f011970a:	68 8c d4 12 f0       	push   $0xf012d48c
f011970f:	68 36 03 00 00       	push   $0x336
f0119714:	68 73 d4 12 f0       	push   $0xf012d473
f0119719:	e8 1b 6c fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011971e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119721:	e8 22 55 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119726:	29 c3                	sub    %eax,%ebx
f0119728:	89 da                	mov    %ebx,%edx
f011972a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011972d:	c1 e8 0c             	shr    $0xc,%eax
f0119730:	39 c2                	cmp    %eax,%edx
f0119732:	73 17                	jae    f011974b <test_fastfirstfit+0x604>
f0119734:	83 ec 04             	sub    $0x4,%esp
f0119737:	68 f4 d4 12 f0       	push   $0xf012d4f4
f011973c:	68 37 03 00 00       	push   $0x337
f0119741:	68 73 d4 12 f0       	push   $0xf012d473
f0119746:	e8 ee 6b fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f011974b:	e8 43 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119750:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119753:	e8 f0 54 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119758:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f011975b:	83 ec 0c             	sub    $0xc,%esp
f011975e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119761:	e8 69 00 ff ff       	call   f01097cf <kmalloc>
f0119766:	83 c4 10             	add    $0x10,%esp
f0119769:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f011976c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011976f:	89 d0                	mov    %edx,%eax
f0119771:	c1 e0 02             	shl    $0x2,%eax
f0119774:	01 d0                	add    %edx,%eax
f0119776:	c1 e0 02             	shl    $0x2,%eax
f0119779:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011977f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119782:	39 c2                	cmp    %eax,%edx
f0119784:	74 17                	je     f011979d <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f0119786:	83 ec 04             	sub    $0x4,%esp
f0119789:	68 84 d5 12 f0       	push   $0xf012d584
f011978e:	68 40 03 00 00       	push   $0x340
f0119793:	68 73 d4 12 f0       	push   $0xf012d473
f0119798:	e8 9c 6b fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011979d:	e8 f1 b2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01197a2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01197a5:	74 17                	je     f01197be <test_fastfirstfit+0x677>
f01197a7:	83 ec 04             	sub    $0x4,%esp
f01197aa:	68 8c d4 12 f0       	push   $0xf012d48c
f01197af:	68 41 03 00 00       	push   $0x341
f01197b4:	68 73 d4 12 f0       	push   $0xf012d473
f01197b9:	e8 7b 6b fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01197be:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01197c1:	e8 82 54 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01197c6:	29 c3                	sub    %eax,%ebx
f01197c8:	89 da                	mov    %ebx,%edx
f01197ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01197cd:	c1 e8 0c             	shr    $0xc,%eax
f01197d0:	39 c2                	cmp    %eax,%edx
f01197d2:	73 17                	jae    f01197eb <test_fastfirstfit+0x6a4>
f01197d4:	83 ec 04             	sub    $0x4,%esp
f01197d7:	68 f4 d4 12 f0       	push   $0xf012d4f4
f01197dc:	68 42 03 00 00       	push   $0x342
f01197e1:	68 73 d4 12 f0       	push   $0xf012d473
f01197e6:	e8 4e 6b fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01197eb:	e8 a3 b2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01197f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01197f3:	e8 50 54 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01197f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01197fb:	83 ec 0c             	sub    $0xc,%esp
f01197fe:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119801:	e8 c9 ff fe ff       	call   f01097cf <kmalloc>
f0119806:	83 c4 10             	add    $0x10,%esp
f0119809:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f011980c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011980f:	89 d0                	mov    %edx,%eax
f0119811:	c1 e0 02             	shl    $0x2,%eax
f0119814:	01 d0                	add    %edx,%eax
f0119816:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011981d:	01 d0                	add    %edx,%eax
f011981f:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119825:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119828:	39 c2                	cmp    %eax,%edx
f011982a:	74 17                	je     f0119843 <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f011982c:	83 ec 04             	sub    $0x4,%esp
f011982f:	68 84 d5 12 f0       	push   $0xf012d584
f0119834:	68 4b 03 00 00       	push   $0x34b
f0119839:	68 73 d4 12 f0       	push   $0xf012d473
f011983e:	e8 f6 6a fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119843:	e8 4b b2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119848:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011984b:	74 17                	je     f0119864 <test_fastfirstfit+0x71d>
f011984d:	83 ec 04             	sub    $0x4,%esp
f0119850:	68 8c d4 12 f0       	push   $0xf012d48c
f0119855:	68 4c 03 00 00       	push   $0x34c
f011985a:	68 73 d4 12 f0       	push   $0xf012d473
f011985f:	e8 d5 6a fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119864:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119867:	e8 dc 53 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011986c:	29 c3                	sub    %eax,%ebx
f011986e:	89 da                	mov    %ebx,%edx
f0119870:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119873:	c1 e8 0c             	shr    $0xc,%eax
f0119876:	39 c2                	cmp    %eax,%edx
f0119878:	73 17                	jae    f0119891 <test_fastfirstfit+0x74a>
f011987a:	83 ec 04             	sub    $0x4,%esp
f011987d:	68 f4 d4 12 f0       	push   $0xf012d4f4
f0119882:	68 4d 03 00 00       	push   $0x34d
f0119887:	68 73 d4 12 f0       	push   $0xf012d473
f011988c:	e8 a8 6a fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0119891:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119894:	d1 e8                	shr    %eax
f0119896:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119899:	e8 f5 b1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011989e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01198a1:	e8 a2 53 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01198a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01198a9:	83 ec 0c             	sub    $0xc,%esp
f01198ac:	ff 75 dc             	pushl  -0x24(%ebp)
f01198af:	e8 1b ff fe ff       	call   f01097cf <kmalloc>
f01198b4:	83 c4 10             	add    $0x10,%esp
f01198b7:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f01198ba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01198bd:	89 d0                	mov    %edx,%eax
f01198bf:	c1 e0 02             	shl    $0x2,%eax
f01198c2:	01 d0                	add    %edx,%eax
f01198c4:	01 c0                	add    %eax,%eax
f01198c6:	89 c1                	mov    %eax,%ecx
f01198c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01198cb:	89 d0                	mov    %edx,%eax
f01198cd:	c1 e0 02             	shl    $0x2,%eax
f01198d0:	01 d0                	add    %edx,%eax
f01198d2:	d1 e8                	shr    %eax
f01198d4:	01 c8                	add    %ecx,%eax
f01198d6:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01198dc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01198df:	39 c2                	cmp    %eax,%edx
f01198e1:	74 17                	je     f01198fa <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f01198e3:	83 ec 04             	sub    $0x4,%esp
f01198e6:	68 84 d5 12 f0       	push   $0xf012d584
f01198eb:	68 57 03 00 00       	push   $0x357
f01198f0:	68 73 d4 12 f0       	push   $0xf012d473
f01198f5:	e8 3f 6a fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01198fa:	e8 94 b1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01198ff:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119902:	74 17                	je     f011991b <test_fastfirstfit+0x7d4>
f0119904:	83 ec 04             	sub    $0x4,%esp
f0119907:	68 8c d4 12 f0       	push   $0xf012d48c
f011990c:	68 58 03 00 00       	push   $0x358
f0119911:	68 73 d4 12 f0       	push   $0xf012d473
f0119916:	e8 1e 6a fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011991b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011991e:	e8 25 53 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119923:	29 c3                	sub    %eax,%ebx
f0119925:	89 da                	mov    %ebx,%edx
f0119927:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011992a:	c1 e8 0c             	shr    $0xc,%eax
f011992d:	39 c2                	cmp    %eax,%edx
f011992f:	73 17                	jae    f0119948 <test_fastfirstfit+0x801>
f0119931:	83 ec 04             	sub    $0x4,%esp
f0119934:	68 f4 d4 12 f0       	push   $0xf012d4f4
f0119939:	68 59 03 00 00       	push   $0x359
f011993e:	68 73 d4 12 f0       	push   $0xf012d473
f0119943:	e8 f1 69 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0119948:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011994b:	d1 e8                	shr    %eax
f011994d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119950:	e8 3e b1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119955:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119958:	e8 eb 52 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011995d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119960:	83 ec 0c             	sub    $0xc,%esp
f0119963:	ff 75 dc             	pushl  -0x24(%ebp)
f0119966:	e8 64 fe fe ff       	call   f01097cf <kmalloc>
f011996b:	83 c4 10             	add    $0x10,%esp
f011996e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f0119971:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119974:	83 e8 03             	sub    $0x3,%eax
f0119977:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f011997b:	89 c2                	mov    %eax,%edx
f011997d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119980:	89 c1                	mov    %eax,%ecx
f0119982:	01 c9                	add    %ecx,%ecx
f0119984:	01 c8                	add    %ecx,%eax
f0119986:	d1 e8                	shr    %eax
f0119988:	01 d0                	add    %edx,%eax
f011998a:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119990:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119993:	39 c2                	cmp    %eax,%edx
f0119995:	74 17                	je     f01199ae <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f0119997:	83 ec 04             	sub    $0x4,%esp
f011999a:	68 84 d5 12 f0       	push   $0xf012d584
f011999f:	68 63 03 00 00       	push   $0x363
f01199a4:	68 73 d4 12 f0       	push   $0xf012d473
f01199a9:	e8 8b 69 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01199ae:	e8 e0 b0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01199b3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01199b6:	74 17                	je     f01199cf <test_fastfirstfit+0x888>
f01199b8:	83 ec 04             	sub    $0x4,%esp
f01199bb:	68 8c d4 12 f0       	push   $0xf012d48c
f01199c0:	68 64 03 00 00       	push   $0x364
f01199c5:	68 73 d4 12 f0       	push   $0xf012d473
f01199ca:	e8 6a 69 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01199cf:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01199d2:	e8 71 52 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01199d7:	29 c3                	sub    %eax,%ebx
f01199d9:	89 da                	mov    %ebx,%edx
f01199db:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01199de:	c1 e8 0c             	shr    $0xc,%eax
f01199e1:	39 c2                	cmp    %eax,%edx
f01199e3:	73 17                	jae    f01199fc <test_fastfirstfit+0x8b5>
f01199e5:	83 ec 04             	sub    $0x4,%esp
f01199e8:	68 f4 d4 12 f0       	push   $0xf012d4f4
f01199ed:	68 65 03 00 00       	push   $0x365
f01199f2:	68 73 d4 12 f0       	push   $0xf012d473
f01199f7:	e8 3d 69 fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f01199fc:	83 ec 0c             	sub    $0xc,%esp
f01199ff:	68 a4 d5 12 f0       	push   $0xf012d5a4
f0119a04:	e8 82 75 fe ff       	call   f0100f8b <cprintf>
f0119a09:	83 c4 10             	add    $0x10,%esp
	return 1;
f0119a0c:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0119a11:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0119a14:	c9                   	leave  
f0119a15:	c3                   	ret    

f0119a16 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f0119a16:	55                   	push   %ebp
f0119a17:	89 e5                	mov    %esp,%ebp
f0119a19:	57                   	push   %edi
f0119a1a:	53                   	push   %ebx
f0119a1b:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119a21:	83 ec 0c             	sub    $0xc,%esp
f0119a24:	68 28 b5 12 f0       	push   $0xf012b528
f0119a29:	e8 5d 75 fe ff       	call   f0100f8b <cprintf>
f0119a2e:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0119a31:	83 ec 0c             	sub    $0xc,%esp
f0119a34:	68 58 b5 12 f0       	push   $0xf012b558
f0119a39:	e8 4d 75 fe ff       	call   f0100f8b <cprintf>
f0119a3e:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0119a41:	83 ec 0c             	sub    $0xc,%esp
f0119a44:	68 28 b5 12 f0       	push   $0xf012b528
f0119a49:	e8 3d 75 fe ff       	call   f0100f8b <cprintf>
f0119a4e:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0119a51:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f0119a55:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f0119a59:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f0119a5f:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f0119a65:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0119a6c:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f0119a73:	e8 d0 51 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119a78:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0119a7b:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f0119a81:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119a86:	b8 00 00 00 00       	mov    $0x0,%eax
f0119a8b:	89 d7                	mov    %edx,%edi
f0119a8d:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f0119a8f:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f0119a95:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119a9a:	b8 00 00 00 00       	mov    $0x0,%eax
f0119a9f:	89 d7                	mov    %edx,%edi
f0119aa1:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f0119aa3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f0119aaa:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f0119ab1:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f0119ab8:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f0119abe:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119ac3:	b8 00 00 00 00       	mov    $0x0,%eax
f0119ac8:	89 d7                	mov    %edx,%edi
f0119aca:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f0119acc:	83 ec 0c             	sub    $0xc,%esp
f0119acf:	68 e8 d5 12 f0       	push   $0xf012d5e8
f0119ad4:	e8 b2 74 fe ff       	call   f0100f8b <cprintf>
f0119ad9:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119adc:	e8 67 51 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119ae1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119ae4:	e8 aa af fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119ae9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119aec:	83 ec 0c             	sub    $0xc,%esp
f0119aef:	68 00 fc 1f 00       	push   $0x1ffc00
f0119af4:	e8 d6 fc fe ff       	call   f01097cf <kmalloc>
f0119af9:	83 c4 10             	add    $0x10,%esp
f0119afc:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119b02:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119b08:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119b0d:	74 17                	je     f0119b26 <test_kfree_bestfirstfit+0x110>
f0119b0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b16:	83 ec 0c             	sub    $0xc,%esp
f0119b19:	68 20 d6 12 f0       	push   $0xf012d620
f0119b1e:	e8 68 74 fe ff       	call   f0100f8b <cprintf>
f0119b23:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b26:	e8 68 af fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119b2b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119b2e:	74 17                	je     f0119b47 <test_kfree_bestfirstfit+0x131>
f0119b30:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b37:	83 ec 0c             	sub    $0xc,%esp
f0119b3a:	68 74 d6 12 f0       	push   $0xf012d674
f0119b3f:	e8 47 74 fe ff       	call   f0100f8b <cprintf>
f0119b44:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119b47:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119b4a:	e8 f9 50 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119b4f:	29 c3                	sub    %eax,%ebx
f0119b51:	89 d8                	mov    %ebx,%eax
f0119b53:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119b58:	77 17                	ja     f0119b71 <test_kfree_bestfirstfit+0x15b>
f0119b5a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b61:	83 ec 0c             	sub    $0xc,%esp
f0119b64:	68 e4 d6 12 f0       	push   $0xf012d6e4
f0119b69:	e8 1d 74 fe ff       	call   f0100f8b <cprintf>
f0119b6e:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f0119b71:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f0119b78:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119b7b:	e8 c8 50 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119b80:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119b83:	e8 0b af fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119b88:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0119b8b:	83 ec 0c             	sub    $0xc,%esp
f0119b8e:	68 00 fc 1f 00       	push   $0x1ffc00
f0119b93:	e8 37 fc fe ff       	call   f01097cf <kmalloc>
f0119b98:	83 c4 10             	add    $0x10,%esp
f0119b9b:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119ba1:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119ba7:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119bac:	74 17                	je     f0119bc5 <test_kfree_bestfirstfit+0x1af>
f0119bae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bb5:	83 ec 0c             	sub    $0xc,%esp
f0119bb8:	68 2c d7 12 f0       	push   $0xf012d72c
f0119bbd:	e8 c9 73 fe ff       	call   f0100f8b <cprintf>
f0119bc2:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119bc5:	e8 c9 ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119bca:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119bcd:	74 17                	je     f0119be6 <test_kfree_bestfirstfit+0x1d0>
f0119bcf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bd6:	83 ec 0c             	sub    $0xc,%esp
f0119bd9:	68 80 d7 12 f0       	push   $0xf012d780
f0119bde:	e8 a8 73 fe ff       	call   f0100f8b <cprintf>
f0119be3:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119be6:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119be9:	e8 5a 50 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119bee:	29 c3                	sub    %eax,%ebx
f0119bf0:	89 d8                	mov    %ebx,%eax
f0119bf2:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119bf7:	77 17                	ja     f0119c10 <test_kfree_bestfirstfit+0x1fa>
f0119bf9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c00:	83 ec 0c             	sub    $0xc,%esp
f0119c03:	68 f0 d7 12 f0       	push   $0xf012d7f0
f0119c08:	e8 7e 73 fe ff       	call   f0100f8b <cprintf>
f0119c0d:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f0119c10:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f0119c17:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f0119c1a:	e8 29 50 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119c1f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119c22:	e8 6c ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119c27:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f0119c2a:	83 ec 0c             	sub    $0xc,%esp
f0119c2d:	68 00 1c 00 00       	push   $0x1c00
f0119c32:	e8 98 fb fe ff       	call   f01097cf <kmalloc>
f0119c37:	83 c4 10             	add    $0x10,%esp
f0119c3a:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119c40:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119c46:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119c4b:	74 17                	je     f0119c64 <test_kfree_bestfirstfit+0x24e>
f0119c4d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c54:	83 ec 0c             	sub    $0xc,%esp
f0119c57:	68 38 d8 12 f0       	push   $0xf012d838
f0119c5c:	e8 2a 73 fe ff       	call   f0100f8b <cprintf>
f0119c61:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c64:	e8 2a ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119c69:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119c6c:	74 17                	je     f0119c85 <test_kfree_bestfirstfit+0x26f>
f0119c6e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c75:	83 ec 0c             	sub    $0xc,%esp
f0119c78:	68 8c d8 12 f0       	push   $0xf012d88c
f0119c7d:	e8 09 73 fe ff       	call   f0100f8b <cprintf>
f0119c82:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119c85:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119c88:	e8 bb 4f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119c8d:	29 c3                	sub    %eax,%ebx
f0119c8f:	89 d8                	mov    %ebx,%eax
f0119c91:	83 f8 01             	cmp    $0x1,%eax
f0119c94:	77 17                	ja     f0119cad <test_kfree_bestfirstfit+0x297>
f0119c96:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c9d:	83 ec 0c             	sub    $0xc,%esp
f0119ca0:	68 fc d8 12 f0       	push   $0xf012d8fc
f0119ca5:	e8 e1 72 fe ff       	call   f0100f8b <cprintf>
f0119caa:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f0119cad:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f0119cb4:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f0119cb7:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119cbd:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f0119cc0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119cc7:	eb 0e                	jmp    f0119cd7 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f0119cc9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119ccc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119ccf:	01 d0                	add    %edx,%eax
f0119cd1:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f0119cd4:	ff 45 f4             	incl   -0xc(%ebp)
f0119cd7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119cdd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119ce0:	7f e7                	jg     f0119cc9 <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0119ce2:	e8 61 4f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119ce7:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119cea:	e8 a4 ad fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119cef:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0119cf2:	83 ec 0c             	sub    $0xc,%esp
f0119cf5:	68 00 fc 2f 00       	push   $0x2ffc00
f0119cfa:	e8 d0 fa fe ff       	call   f01097cf <kmalloc>
f0119cff:	83 c4 10             	add    $0x10,%esp
f0119d02:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119d08:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119d0e:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119d13:	74 17                	je     f0119d2c <test_kfree_bestfirstfit+0x316>
f0119d15:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d1c:	83 ec 0c             	sub    $0xc,%esp
f0119d1f:	68 44 d9 12 f0       	push   $0xf012d944
f0119d24:	e8 62 72 fe ff       	call   f0100f8b <cprintf>
f0119d29:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d2c:	e8 62 ad fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119d31:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119d34:	74 17                	je     f0119d4d <test_kfree_bestfirstfit+0x337>
f0119d36:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d3d:	83 ec 0c             	sub    $0xc,%esp
f0119d40:	68 98 d9 12 f0       	push   $0xf012d998
f0119d45:	e8 41 72 fe ff       	call   f0100f8b <cprintf>
f0119d4a:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119d4d:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119d50:	e8 f3 4e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119d55:	29 c3                	sub    %eax,%ebx
f0119d57:	89 d8                	mov    %ebx,%eax
f0119d59:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119d5e:	77 17                	ja     f0119d77 <test_kfree_bestfirstfit+0x361>
f0119d60:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d67:	83 ec 0c             	sub    $0xc,%esp
f0119d6a:	68 08 da 12 f0       	push   $0xf012da08
f0119d6f:	e8 17 72 fe ff       	call   f0100f8b <cprintf>
f0119d74:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f0119d77:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f0119d7e:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f0119d81:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119d87:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f0119d8a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119d91:	eb 0e                	jmp    f0119da1 <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f0119d93:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119d96:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119d99:	01 d0                	add    %edx,%eax
f0119d9b:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119d9e:	ff 45 f4             	incl   -0xc(%ebp)
f0119da1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119da7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119daa:	7f e7                	jg     f0119d93 <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0119dac:	e8 97 4e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119db1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119db4:	e8 da ac fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119db9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0119dbc:	83 ec 0c             	sub    $0xc,%esp
f0119dbf:	68 00 fc 5f 00       	push   $0x5ffc00
f0119dc4:	e8 06 fa fe ff       	call   f01097cf <kmalloc>
f0119dc9:	83 c4 10             	add    $0x10,%esp
f0119dcc:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119dd2:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119dd8:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119ddd:	74 17                	je     f0119df6 <test_kfree_bestfirstfit+0x3e0>
f0119ddf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119de6:	83 ec 0c             	sub    $0xc,%esp
f0119de9:	68 50 da 12 f0       	push   $0xf012da50
f0119dee:	e8 98 71 fe ff       	call   f0100f8b <cprintf>
f0119df3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119df6:	e8 98 ac fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119dfb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119dfe:	74 17                	je     f0119e17 <test_kfree_bestfirstfit+0x401>
f0119e00:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e07:	83 ec 0c             	sub    $0xc,%esp
f0119e0a:	68 a4 da 12 f0       	push   $0xf012daa4
f0119e0f:	e8 77 71 fe ff       	call   f0100f8b <cprintf>
f0119e14:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119e17:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119e1a:	e8 29 4e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119e1f:	29 c3                	sub    %eax,%ebx
f0119e21:	89 d8                	mov    %ebx,%eax
f0119e23:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119e28:	77 17                	ja     f0119e41 <test_kfree_bestfirstfit+0x42b>
f0119e2a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e31:	83 ec 0c             	sub    $0xc,%esp
f0119e34:	68 14 db 12 f0       	push   $0xf012db14
f0119e39:	e8 4d 71 fe ff       	call   f0100f8b <cprintf>
f0119e3e:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f0119e41:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f0119e48:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f0119e4b:	e8 f8 4d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119e50:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119e53:	e8 3b ac fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119e58:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0119e5b:	83 ec 0c             	sub    $0xc,%esp
f0119e5e:	68 00 38 00 00       	push   $0x3800
f0119e63:	e8 67 f9 fe ff       	call   f01097cf <kmalloc>
f0119e68:	83 c4 10             	add    $0x10,%esp
f0119e6b:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119e71:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119e77:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0119e7c:	74 17                	je     f0119e95 <test_kfree_bestfirstfit+0x47f>
f0119e7e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e85:	83 ec 0c             	sub    $0xc,%esp
f0119e88:	68 5c db 12 f0       	push   $0xf012db5c
f0119e8d:	e8 f9 70 fe ff       	call   f0100f8b <cprintf>
f0119e92:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e95:	e8 f9 ab fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119e9a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119e9d:	74 17                	je     f0119eb6 <test_kfree_bestfirstfit+0x4a0>
f0119e9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ea6:	83 ec 0c             	sub    $0xc,%esp
f0119ea9:	68 b0 db 12 f0       	push   $0xf012dbb0
f0119eae:	e8 d8 70 fe ff       	call   f0100f8b <cprintf>
f0119eb3:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119eb6:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119eb9:	e8 8a 4d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119ebe:	29 c3                	sub    %eax,%ebx
f0119ec0:	89 d8                	mov    %ebx,%eax
f0119ec2:	83 f8 03             	cmp    $0x3,%eax
f0119ec5:	77 17                	ja     f0119ede <test_kfree_bestfirstfit+0x4c8>
f0119ec7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ece:	83 ec 0c             	sub    $0xc,%esp
f0119ed1:	68 20 dc 12 f0       	push   $0xf012dc20
f0119ed6:	e8 b0 70 fe ff       	call   f0100f8b <cprintf>
f0119edb:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119ede:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0119ee5:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119eeb:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119eee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119ef5:	eb 0e                	jmp    f0119f05 <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0119ef7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119efa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119efd:	01 d0                	add    %edx,%eax
f0119eff:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0119f02:	ff 45 f4             	incl   -0xc(%ebp)
f0119f05:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119f08:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119f0b:	7f ea                	jg     f0119ef7 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0119f0d:	e8 36 4d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119f12:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119f15:	e8 79 ab fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119f1a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0119f1d:	83 ec 0c             	sub    $0xc,%esp
f0119f20:	68 00 08 00 00       	push   $0x800
f0119f25:	e8 a5 f8 fe ff       	call   f01097cf <kmalloc>
f0119f2a:	83 c4 10             	add    $0x10,%esp
f0119f2d:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119f33:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119f39:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119f3e:	76 28                	jbe    f0119f68 <test_kfree_bestfirstfit+0x552>
f0119f40:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f0119f46:	83 ec 0c             	sub    $0xc,%esp
f0119f49:	6a 00                	push   $0x0
f0119f4b:	e8 4c f7 fe ff       	call   f010969c <sbrk>
f0119f50:	83 c4 10             	add    $0x10,%esp
f0119f53:	39 c3                	cmp    %eax,%ebx
f0119f55:	73 11                	jae    f0119f68 <test_kfree_bestfirstfit+0x552>
f0119f57:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119f5d:	89 c2                	mov    %eax,%edx
f0119f5f:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0119f64:	39 c2                	cmp    %eax,%edx
f0119f66:	72 17                	jb     f0119f7f <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119f68:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f6f:	83 ec 0c             	sub    $0xc,%esp
f0119f72:	68 68 dc 12 f0       	push   $0xf012dc68
f0119f77:	e8 0f 70 fe ff       	call   f0100f8b <cprintf>
f0119f7c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f7f:	e8 0f ab fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119f84:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119f87:	74 17                	je     f0119fa0 <test_kfree_bestfirstfit+0x58a>
f0119f89:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f90:	83 ec 0c             	sub    $0xc,%esp
f0119f93:	68 f4 dc 12 f0       	push   $0xf012dcf4
f0119f98:	e8 ee 6f fe ff       	call   f0100f8b <cprintf>
f0119f9d:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0119fa0:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0119fa7:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0119faa:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119fb0:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0119fb3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119fba:	eb 0e                	jmp    f0119fca <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0119fbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119fbf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119fc2:	01 d0                	add    %edx,%eax
f0119fc4:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0119fc7:	ff 45 f4             	incl   -0xc(%ebp)
f0119fca:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0119fd0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119fd3:	7f e7                	jg     f0119fbc <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119fd5:	e8 b9 aa fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119fda:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119fdd:	83 ec 0c             	sub    $0xc,%esp
f0119fe0:	68 00 08 00 00       	push   $0x800
f0119fe5:	e8 e5 f7 fe ff       	call   f01097cf <kmalloc>
f0119fea:	83 c4 10             	add    $0x10,%esp
f0119fed:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119ff3:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119ff9:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119ffe:	76 28                	jbe    f011a028 <test_kfree_bestfirstfit+0x612>
f011a000:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f011a006:	83 ec 0c             	sub    $0xc,%esp
f011a009:	6a 00                	push   $0x0
f011a00b:	e8 8c f6 fe ff       	call   f010969c <sbrk>
f011a010:	83 c4 10             	add    $0x10,%esp
f011a013:	39 c3                	cmp    %eax,%ebx
f011a015:	73 11                	jae    f011a028 <test_kfree_bestfirstfit+0x612>
f011a017:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a01d:	89 c2                	mov    %eax,%edx
f011a01f:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011a024:	39 c2                	cmp    %eax,%edx
f011a026:	72 17                	jb     f011a03f <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a028:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a02f:	83 ec 0c             	sub    $0xc,%esp
f011a032:	68 64 dd 12 f0       	push   $0xf012dd64
f011a037:	e8 4f 6f fe ff       	call   f0100f8b <cprintf>
f011a03c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a03f:	e8 4f aa fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a044:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a047:	74 17                	je     f011a060 <test_kfree_bestfirstfit+0x64a>
f011a049:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a050:	83 ec 0c             	sub    $0xc,%esp
f011a053:	68 f0 dd 12 f0       	push   $0xf012ddf0
f011a058:	e8 2e 6f fe ff       	call   f0100f8b <cprintf>
f011a05d:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f011a060:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f011a067:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f011a06a:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a070:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f011a073:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a07a:	eb 0e                	jmp    f011a08a <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f011a07c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a07f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a082:	01 d0                	add    %edx,%eax
f011a084:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f011a087:	ff 45 f4             	incl   -0xc(%ebp)
f011a08a:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a090:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a093:	7f e7                	jg     f011a07c <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f011a095:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a098:	e8 ab 4b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a09d:	29 c3                	sub    %eax,%ebx
f011a09f:	89 d8                	mov    %ebx,%eax
f011a0a1:	83 f8 01             	cmp    $0x1,%eax
f011a0a4:	74 17                	je     f011a0bd <test_kfree_bestfirstfit+0x6a7>
f011a0a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0ad:	83 ec 0c             	sub    $0xc,%esp
f011a0b0:	68 60 de 12 f0       	push   $0xf012de60
f011a0b5:	e8 d1 6e fe ff       	call   f0100f8b <cprintf>
f011a0ba:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f011a0bd:	83 ec 0c             	sub    $0xc,%esp
f011a0c0:	68 84 de 12 f0       	push   $0xf012de84
f011a0c5:	e8 c1 6e fe ff       	call   f0100f8b <cprintf>
f011a0ca:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011a0cd:	e8 76 4b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a0d2:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011a0d5:	e8 b9 a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a0da:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011a0dd:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011a0e3:	83 ec 0c             	sub    $0xc,%esp
f011a0e6:	50                   	push   %eax
f011a0e7:	e8 a3 f9 fe ff       	call   f0109a8f <kfree>
f011a0ec:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a0ef:	e8 9f a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a0f4:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a0f7:	74 17                	je     f011a110 <test_kfree_bestfirstfit+0x6fa>
f011a0f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a100:	83 ec 0c             	sub    $0xc,%esp
f011a103:	68 b4 de 12 f0       	push   $0xf012deb4
f011a108:	e8 7e 6e fe ff       	call   f0100f8b <cprintf>
f011a10d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a110:	e8 33 4b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a115:	89 c2                	mov    %eax,%edx
f011a117:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a11a:	29 c2                	sub    %eax,%edx
f011a11c:	89 d0                	mov    %edx,%eax
f011a11e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a123:	77 17                	ja     f011a13c <test_kfree_bestfirstfit+0x726>
f011a125:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a12c:	83 ec 0c             	sub    $0xc,%esp
f011a12f:	68 24 df 12 f0       	push   $0xf012df24
f011a134:	e8 52 6e fe ff       	call   f0100f8b <cprintf>
f011a139:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f011a13c:	e8 07 4b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a141:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a144:	e8 4a a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a149:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f011a14c:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a152:	83 ec 0c             	sub    $0xc,%esp
f011a155:	50                   	push   %eax
f011a156:	e8 34 f9 fe ff       	call   f0109a8f <kfree>
f011a15b:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a15e:	e8 30 a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a163:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a166:	74 17                	je     f011a17f <test_kfree_bestfirstfit+0x769>
f011a168:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a16f:	83 ec 0c             	sub    $0xc,%esp
f011a172:	68 60 df 12 f0       	push   $0xf012df60
f011a177:	e8 0f 6e fe ff       	call   f0100f8b <cprintf>
f011a17c:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a17f:	e8 c4 4a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a184:	89 c2                	mov    %eax,%edx
f011a186:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a189:	39 c2                	cmp    %eax,%edx
f011a18b:	74 17                	je     f011a1a4 <test_kfree_bestfirstfit+0x78e>
f011a18d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a194:	83 ec 0c             	sub    $0xc,%esp
f011a197:	68 d0 df 12 f0       	push   $0xf012dfd0
f011a19c:	e8 ea 6d fe ff       	call   f0100f8b <cprintf>
f011a1a1:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a1a4:	e8 9f 4a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a1a9:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a1ac:	e8 e2 a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a1b1:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f011a1b4:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011a1ba:	83 ec 0c             	sub    $0xc,%esp
f011a1bd:	50                   	push   %eax
f011a1be:	e8 cc f8 fe ff       	call   f0109a8f <kfree>
f011a1c3:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a1c6:	e8 c8 a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a1cb:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a1ce:	74 17                	je     f011a1e7 <test_kfree_bestfirstfit+0x7d1>
f011a1d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1d7:	83 ec 0c             	sub    $0xc,%esp
f011a1da:	68 30 e0 12 f0       	push   $0xf012e030
f011a1df:	e8 a7 6d fe ff       	call   f0100f8b <cprintf>
f011a1e4:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a1e7:	e8 5c 4a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a1ec:	89 c2                	mov    %eax,%edx
f011a1ee:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a1f1:	29 c2                	sub    %eax,%edx
f011a1f3:	89 d0                	mov    %edx,%eax
f011a1f5:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a1fa:	77 17                	ja     f011a213 <test_kfree_bestfirstfit+0x7fd>
f011a1fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a203:	83 ec 0c             	sub    $0xc,%esp
f011a206:	68 a0 e0 12 f0       	push   $0xf012e0a0
f011a20b:	e8 7b 6d fe ff       	call   f0100f8b <cprintf>
f011a210:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011a213:	e8 30 4a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a218:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a21b:	e8 73 a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a220:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f011a223:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011a229:	83 ec 0c             	sub    $0xc,%esp
f011a22c:	50                   	push   %eax
f011a22d:	e8 5d f8 fe ff       	call   f0109a8f <kfree>
f011a232:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a235:	e8 59 a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a23a:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a23d:	74 17                	je     f011a256 <test_kfree_bestfirstfit+0x840>
f011a23f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a246:	83 ec 0c             	sub    $0xc,%esp
f011a249:	68 dc e0 12 f0       	push   $0xf012e0dc
f011a24e:	e8 38 6d fe ff       	call   f0100f8b <cprintf>
f011a253:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a256:	e8 ed 49 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a25b:	89 c2                	mov    %eax,%edx
f011a25d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a260:	29 c2                	sub    %eax,%edx
f011a262:	89 d0                	mov    %edx,%eax
f011a264:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a269:	77 17                	ja     f011a282 <test_kfree_bestfirstfit+0x86c>
f011a26b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a272:	83 ec 0c             	sub    $0xc,%esp
f011a275:	68 4c e1 12 f0       	push   $0xf012e14c
f011a27a:	e8 0c 6d fe ff       	call   f0100f8b <cprintf>
f011a27f:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a282:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a286:	74 04                	je     f011a28c <test_kfree_bestfirstfit+0x876>
f011a288:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a28c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f011a293:	83 ec 0c             	sub    $0xc,%esp
f011a296:	68 88 e1 12 f0       	push   $0xf012e188
f011a29b:	e8 eb 6c fe ff       	call   f0100f8b <cprintf>
f011a2a0:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011a2a3:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a2a9:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011a2ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a2b3:	eb 1e                	jmp    f011a2d3 <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f011a2b5:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011a2bb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a2be:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a2c1:	01 c8                	add    %ecx,%eax
f011a2c3:	8a 00                	mov    (%eax),%al
f011a2c5:	0f be c0             	movsbl %al,%eax
f011a2c8:	01 d0                	add    %edx,%eax
f011a2ca:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f011a2d0:	ff 45 f4             	incl   -0xc(%ebp)
f011a2d3:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a2d9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a2dc:	7f d7                	jg     f011a2b5 <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f011a2de:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011a2e4:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a2ea:	89 c1                	mov    %eax,%ecx
f011a2ec:	01 c9                	add    %ecx,%ecx
f011a2ee:	01 c8                	add    %ecx,%eax
f011a2f0:	39 c2                	cmp    %eax,%edx
f011a2f2:	74 17                	je     f011a30b <test_kfree_bestfirstfit+0x8f5>
f011a2f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2fb:	83 ec 0c             	sub    $0xc,%esp
f011a2fe:	68 d0 e1 12 f0       	push   $0xf012e1d0
f011a303:	e8 83 6c fe ff       	call   f0100f8b <cprintf>
f011a308:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011a30b:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a311:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011a314:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a31b:	eb 1e                	jmp    f011a33b <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f011a31d:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011a323:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a326:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a329:	01 c8                	add    %ecx,%eax
f011a32b:	8a 00                	mov    (%eax),%al
f011a32d:	0f be c0             	movsbl %al,%eax
f011a330:	01 d0                	add    %edx,%eax
f011a332:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011a338:	ff 45 f4             	incl   -0xc(%ebp)
f011a33b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011a341:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a344:	7f d7                	jg     f011a31d <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f011a346:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a34c:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f011a352:	c1 e2 02             	shl    $0x2,%edx
f011a355:	39 d0                	cmp    %edx,%eax
f011a357:	74 17                	je     f011a370 <test_kfree_bestfirstfit+0x95a>
f011a359:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a360:	83 ec 0c             	sub    $0xc,%esp
f011a363:	68 08 e2 12 f0       	push   $0xf012e208
f011a368:	e8 1e 6c fe ff       	call   f0100f8b <cprintf>
f011a36d:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011a370:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a376:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011a379:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a380:	eb 1e                	jmp    f011a3a0 <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f011a382:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011a388:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a38b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a38e:	01 c8                	add    %ecx,%eax
f011a390:	8a 00                	mov    (%eax),%al
f011a392:	0f be c0             	movsbl %al,%eax
f011a395:	01 d0                	add    %edx,%eax
f011a397:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011a39d:	ff 45 f4             	incl   -0xc(%ebp)
f011a3a0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a3a6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a3a9:	7f d7                	jg     f011a382 <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f011a3ab:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f011a3b1:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011a3b7:	89 d0                	mov    %edx,%eax
f011a3b9:	c1 e0 02             	shl    $0x2,%eax
f011a3bc:	01 d0                	add    %edx,%eax
f011a3be:	39 c1                	cmp    %eax,%ecx
f011a3c0:	74 17                	je     f011a3d9 <test_kfree_bestfirstfit+0x9c3>
f011a3c2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3c9:	83 ec 0c             	sub    $0xc,%esp
f011a3cc:	68 40 e2 12 f0       	push   $0xf012e240
f011a3d1:	e8 b5 6b fe ff       	call   f0100f8b <cprintf>
f011a3d6:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011a3d9:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a3df:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011a3e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a3e9:	eb 1e                	jmp    f011a409 <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f011a3eb:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011a3f1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a3f4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a3f7:	01 c8                	add    %ecx,%eax
f011a3f9:	8a 00                	mov    (%eax),%al
f011a3fb:	0f be c0             	movsbl %al,%eax
f011a3fe:	01 d0                	add    %edx,%eax
f011a400:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011a406:	ff 45 f4             	incl   -0xc(%ebp)
f011a409:	8b 45 80             	mov    -0x80(%ebp),%eax
f011a40c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a40f:	7f da                	jg     f011a3eb <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f011a411:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f011a417:	8b 55 80             	mov    -0x80(%ebp),%edx
f011a41a:	89 d0                	mov    %edx,%eax
f011a41c:	01 c0                	add    %eax,%eax
f011a41e:	01 d0                	add    %edx,%eax
f011a420:	01 c0                	add    %eax,%eax
f011a422:	01 d0                	add    %edx,%eax
f011a424:	39 c1                	cmp    %eax,%ecx
f011a426:	74 17                	je     f011a43f <test_kfree_bestfirstfit+0xa29>
f011a428:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a42f:	83 ec 0c             	sub    $0xc,%esp
f011a432:	68 78 e2 12 f0       	push   $0xf012e278
f011a437:	e8 4f 6b fe ff       	call   f0100f8b <cprintf>
f011a43c:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a43f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a443:	74 04                	je     f011a449 <test_kfree_bestfirstfit+0xa33>
f011a445:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a449:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f011a450:	83 ec 0c             	sub    $0xc,%esp
f011a453:	68 b0 e2 12 f0       	push   $0xf012e2b0
f011a458:	e8 2e 6b fe ff       	call   f0100f8b <cprintf>
f011a45d:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011a460:	e8 e3 47 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a465:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a468:	e8 26 a6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a46d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011a470:	83 ec 0c             	sub    $0xc,%esp
f011a473:	68 00 04 00 00       	push   $0x400
f011a478:	e8 52 f3 fe ff       	call   f01097cf <kmalloc>
f011a47d:	83 c4 10             	add    $0x10,%esp
f011a480:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f011a486:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f011a48c:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a492:	39 c2                	cmp    %eax,%edx
f011a494:	74 17                	je     f011a4ad <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a496:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a49d:	83 ec 0c             	sub    $0xc,%esp
f011a4a0:	68 d0 e2 12 f0       	push   $0xf012e2d0
f011a4a5:	e8 e1 6a fe ff       	call   f0100f8b <cprintf>
f011a4aa:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a4ad:	e8 e1 a5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a4b2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a4b5:	74 17                	je     f011a4ce <test_kfree_bestfirstfit+0xab8>
f011a4b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4be:	83 ec 0c             	sub    $0xc,%esp
f011a4c1:	68 24 e3 12 f0       	push   $0xf012e324
f011a4c6:	e8 c0 6a fe ff       	call   f0100f8b <cprintf>
f011a4cb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a4ce:	e8 75 47 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a4d3:	89 c2                	mov    %eax,%edx
f011a4d5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a4d8:	39 c2                	cmp    %eax,%edx
f011a4da:	74 17                	je     f011a4f3 <test_kfree_bestfirstfit+0xadd>
f011a4dc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4e3:	83 ec 0c             	sub    $0xc,%esp
f011a4e6:	68 94 e3 12 f0       	push   $0xf012e394
f011a4eb:	e8 9b 6a fe ff       	call   f0100f8b <cprintf>
f011a4f0:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011a4f3:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f011a4fa:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a500:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011a503:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a50a:	eb 0e                	jmp    f011a51a <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f011a50c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a50f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a512:	01 d0                	add    %edx,%eax
f011a514:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011a517:	ff 45 f4             	incl   -0xc(%ebp)
f011a51a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a51d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a520:	7f ea                	jg     f011a50c <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011a522:	e8 21 47 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a527:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a52a:	e8 64 a5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a52f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011a532:	83 ec 0c             	sub    $0xc,%esp
f011a535:	68 00 00 30 00       	push   $0x300000
f011a53a:	e8 90 f2 fe ff       	call   f01097cf <kmalloc>
f011a53f:	83 c4 10             	add    $0x10,%esp
f011a542:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a548:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a54e:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a553:	74 17                	je     f011a56c <test_kfree_bestfirstfit+0xb56>
f011a555:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a55c:	83 ec 0c             	sub    $0xc,%esp
f011a55f:	68 10 e4 12 f0       	push   $0xf012e410
f011a564:	e8 22 6a fe ff       	call   f0100f8b <cprintf>
f011a569:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a56c:	e8 22 a5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a571:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a574:	74 17                	je     f011a58d <test_kfree_bestfirstfit+0xb77>
f011a576:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a57d:	83 ec 0c             	sub    $0xc,%esp
f011a580:	68 64 e4 12 f0       	push   $0xf012e464
f011a585:	e8 01 6a fe ff       	call   f0100f8b <cprintf>
f011a58a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a58d:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a590:	e8 b3 46 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a595:	29 c3                	sub    %eax,%ebx
f011a597:	89 d8                	mov    %ebx,%eax
f011a599:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a59e:	77 17                	ja     f011a5b7 <test_kfree_bestfirstfit+0xba1>
f011a5a0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5a7:	83 ec 0c             	sub    $0xc,%esp
f011a5aa:	68 d4 e4 12 f0       	push   $0xf012e4d4
f011a5af:	e8 d7 69 fe ff       	call   f0100f8b <cprintf>
f011a5b4:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011a5b7:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f011a5be:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a5c4:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011a5c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a5ce:	eb 0e                	jmp    f011a5de <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f011a5d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a5d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a5d6:	01 d0                	add    %edx,%eax
f011a5d8:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011a5db:	ff 45 f4             	incl   -0xc(%ebp)
f011a5de:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011a5e1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a5e4:	7f ea                	jg     f011a5d0 <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011a5e6:	e8 5d 46 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a5eb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a5ee:	e8 a0 a4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a5f3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011a5f6:	83 ec 0c             	sub    $0xc,%esp
f011a5f9:	68 00 00 10 00       	push   $0x100000
f011a5fe:	e8 cc f1 fe ff       	call   f01097cf <kmalloc>
f011a603:	83 c4 10             	add    $0x10,%esp
f011a606:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a60c:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a612:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011a617:	74 17                	je     f011a630 <test_kfree_bestfirstfit+0xc1a>
f011a619:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a620:	83 ec 0c             	sub    $0xc,%esp
f011a623:	68 1c e5 12 f0       	push   $0xf012e51c
f011a628:	e8 5e 69 fe ff       	call   f0100f8b <cprintf>
f011a62d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a630:	e8 5e a4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a635:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a638:	74 17                	je     f011a651 <test_kfree_bestfirstfit+0xc3b>
f011a63a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a641:	83 ec 0c             	sub    $0xc,%esp
f011a644:	68 70 e5 12 f0       	push   $0xf012e570
f011a649:	e8 3d 69 fe ff       	call   f0100f8b <cprintf>
f011a64e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a651:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a654:	e8 ef 45 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a659:	29 c3                	sub    %eax,%ebx
f011a65b:	89 d8                	mov    %ebx,%eax
f011a65d:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a662:	77 17                	ja     f011a67b <test_kfree_bestfirstfit+0xc65>
f011a664:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a66b:	83 ec 0c             	sub    $0xc,%esp
f011a66e:	68 e0 e5 12 f0       	push   $0xf012e5e0
f011a673:	e8 13 69 fe ff       	call   f0100f8b <cprintf>
f011a678:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011a67b:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f011a682:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a688:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011a68b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a692:	eb 0e                	jmp    f011a6a2 <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f011a694:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a697:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a69a:	01 d0                	add    %edx,%eax
f011a69c:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011a69f:	ff 45 f4             	incl   -0xc(%ebp)
f011a6a2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a6a5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a6a8:	7f ea                	jg     f011a694 <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f011a6aa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6ae:	74 04                	je     f011a6b4 <test_kfree_bestfirstfit+0xc9e>
f011a6b0:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a6b4:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f011a6bb:	83 ec 0c             	sub    $0xc,%esp
f011a6be:	68 28 e6 12 f0       	push   $0xf012e628
f011a6c3:	e8 c3 68 fe ff       	call   f0100f8b <cprintf>
f011a6c8:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f011a6cb:	e8 78 45 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a6d0:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a6d3:	e8 bb a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a6d8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f011a6db:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a6e1:	83 ec 0c             	sub    $0xc,%esp
f011a6e4:	50                   	push   %eax
f011a6e5:	e8 a5 f3 fe ff       	call   f0109a8f <kfree>
f011a6ea:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a6ed:	e8 a1 a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a6f2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a6f5:	74 17                	je     f011a70e <test_kfree_bestfirstfit+0xcf8>
f011a6f7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6fe:	83 ec 0c             	sub    $0xc,%esp
f011a701:	68 54 e6 12 f0       	push   $0xf012e654
f011a706:	e8 80 68 fe ff       	call   f0100f8b <cprintf>
f011a70b:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a70e:	e8 35 45 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a713:	89 c2                	mov    %eax,%edx
f011a715:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a718:	29 c2                	sub    %eax,%edx
f011a71a:	89 d0                	mov    %edx,%eax
f011a71c:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a721:	77 17                	ja     f011a73a <test_kfree_bestfirstfit+0xd24>
f011a723:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a72a:	83 ec 0c             	sub    $0xc,%esp
f011a72d:	68 c4 e6 12 f0       	push   $0xf012e6c4
f011a732:	e8 54 68 fe ff       	call   f0100f8b <cprintf>
f011a737:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f011a73a:	e8 09 45 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a73f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a742:	e8 4c a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a747:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f011a74a:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a750:	83 ec 0c             	sub    $0xc,%esp
f011a753:	50                   	push   %eax
f011a754:	e8 36 f3 fe ff       	call   f0109a8f <kfree>
f011a759:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a75c:	e8 32 a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a761:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a764:	74 17                	je     f011a77d <test_kfree_bestfirstfit+0xd67>
f011a766:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a76d:	83 ec 0c             	sub    $0xc,%esp
f011a770:	68 00 e7 12 f0       	push   $0xf012e700
f011a775:	e8 11 68 fe ff       	call   f0100f8b <cprintf>
f011a77a:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a77d:	e8 c6 44 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a782:	89 c2                	mov    %eax,%edx
f011a784:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a787:	29 c2                	sub    %eax,%edx
f011a789:	89 d0                	mov    %edx,%eax
f011a78b:	83 f8 01             	cmp    $0x1,%eax
f011a78e:	77 17                	ja     f011a7a7 <test_kfree_bestfirstfit+0xd91>
f011a790:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a797:	83 ec 0c             	sub    $0xc,%esp
f011a79a:	68 70 e7 12 f0       	push   $0xf012e770
f011a79f:	e8 e7 67 fe ff       	call   f0100f8b <cprintf>
f011a7a4:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f011a7a7:	e8 9c 44 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a7ac:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a7af:	e8 df a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a7b4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f011a7b7:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a7bd:	83 ec 0c             	sub    $0xc,%esp
f011a7c0:	50                   	push   %eax
f011a7c1:	e8 c9 f2 fe ff       	call   f0109a8f <kfree>
f011a7c6:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a7c9:	e8 c5 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a7ce:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a7d1:	74 17                	je     f011a7ea <test_kfree_bestfirstfit+0xdd4>
f011a7d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7da:	83 ec 0c             	sub    $0xc,%esp
f011a7dd:	68 ac e7 12 f0       	push   $0xf012e7ac
f011a7e2:	e8 a4 67 fe ff       	call   f0100f8b <cprintf>
f011a7e7:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a7ea:	e8 59 44 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a7ef:	89 c2                	mov    %eax,%edx
f011a7f1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a7f4:	29 c2                	sub    %eax,%edx
f011a7f6:	89 d0                	mov    %edx,%eax
f011a7f8:	83 f8 03             	cmp    $0x3,%eax
f011a7fb:	77 17                	ja     f011a814 <test_kfree_bestfirstfit+0xdfe>
f011a7fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a804:	83 ec 0c             	sub    $0xc,%esp
f011a807:	68 1c e8 12 f0       	push   $0xf012e81c
f011a80c:	e8 7a 67 fe ff       	call   f0100f8b <cprintf>
f011a811:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f011a814:	e8 2f 44 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a819:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a81c:	e8 72 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a821:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f011a824:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a82a:	83 ec 0c             	sub    $0xc,%esp
f011a82d:	50                   	push   %eax
f011a82e:	e8 5c f2 fe ff       	call   f0109a8f <kfree>
f011a833:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a836:	e8 58 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a83b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a83e:	74 17                	je     f011a857 <test_kfree_bestfirstfit+0xe41>
f011a840:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a847:	83 ec 0c             	sub    $0xc,%esp
f011a84a:	68 58 e8 12 f0       	push   $0xf012e858
f011a84f:	e8 37 67 fe ff       	call   f0100f8b <cprintf>
f011a854:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a857:	e8 ec 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a85c:	89 c2                	mov    %eax,%edx
f011a85e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a861:	29 c2                	sub    %eax,%edx
f011a863:	89 d0                	mov    %edx,%eax
f011a865:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a86a:	77 17                	ja     f011a883 <test_kfree_bestfirstfit+0xe6d>
f011a86c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a873:	83 ec 0c             	sub    $0xc,%esp
f011a876:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011a87b:	e8 0b 67 fe ff       	call   f0100f8b <cprintf>
f011a880:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f011a883:	e8 c0 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a888:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a88b:	e8 03 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a890:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f011a893:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a899:	83 ec 0c             	sub    $0xc,%esp
f011a89c:	50                   	push   %eax
f011a89d:	e8 ed f1 fe ff       	call   f0109a8f <kfree>
f011a8a2:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a8a5:	e8 e9 a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a8aa:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a8ad:	74 17                	je     f011a8c6 <test_kfree_bestfirstfit+0xeb0>
f011a8af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8b6:	83 ec 0c             	sub    $0xc,%esp
f011a8b9:	68 04 e9 12 f0       	push   $0xf012e904
f011a8be:	e8 c8 66 fe ff       	call   f0100f8b <cprintf>
f011a8c3:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a8c6:	e8 7d 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a8cb:	89 c2                	mov    %eax,%edx
f011a8cd:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a8d0:	29 c2                	sub    %eax,%edx
f011a8d2:	89 d0                	mov    %edx,%eax
f011a8d4:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a8d9:	77 17                	ja     f011a8f2 <test_kfree_bestfirstfit+0xedc>
f011a8db:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8e2:	83 ec 0c             	sub    $0xc,%esp
f011a8e5:	68 74 e9 12 f0       	push   $0xf012e974
f011a8ea:	e8 9c 66 fe ff       	call   f0100f8b <cprintf>
f011a8ef:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f011a8f2:	e8 51 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a8f7:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a8fa:	e8 94 a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a8ff:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f011a902:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a908:	83 ec 0c             	sub    $0xc,%esp
f011a90b:	50                   	push   %eax
f011a90c:	e8 7e f1 fe ff       	call   f0109a8f <kfree>
f011a911:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a914:	e8 7a a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a919:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a91c:	74 17                	je     f011a935 <test_kfree_bestfirstfit+0xf1f>
f011a91e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a925:	83 ec 0c             	sub    $0xc,%esp
f011a928:	68 b0 e9 12 f0       	push   $0xf012e9b0
f011a92d:	e8 59 66 fe ff       	call   f0100f8b <cprintf>
f011a932:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a935:	e8 0e 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a93a:	89 c2                	mov    %eax,%edx
f011a93c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a93f:	39 c2                	cmp    %eax,%edx
f011a941:	74 17                	je     f011a95a <test_kfree_bestfirstfit+0xf44>
f011a943:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a94a:	83 ec 0c             	sub    $0xc,%esp
f011a94d:	68 20 ea 12 f0       	push   $0xf012ea20
f011a952:	e8 34 66 fe ff       	call   f0100f8b <cprintf>
f011a957:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f011a95a:	e8 e9 42 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a95f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a962:	e8 2c a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a967:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f011a96a:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a970:	83 ec 0c             	sub    $0xc,%esp
f011a973:	50                   	push   %eax
f011a974:	e8 16 f1 fe ff       	call   f0109a8f <kfree>
f011a979:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a97c:	e8 12 a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a981:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a984:	74 17                	je     f011a99d <test_kfree_bestfirstfit+0xf87>
f011a986:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a98d:	83 ec 0c             	sub    $0xc,%esp
f011a990:	68 5c ea 12 f0       	push   $0xf012ea5c
f011a995:	e8 f1 65 fe ff       	call   f0100f8b <cprintf>
f011a99a:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a99d:	e8 a6 42 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a9a2:	89 c2                	mov    %eax,%edx
f011a9a4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a9a7:	39 c2                	cmp    %eax,%edx
f011a9a9:	74 17                	je     f011a9c2 <test_kfree_bestfirstfit+0xfac>
f011a9ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9b2:	83 ec 0c             	sub    $0xc,%esp
f011a9b5:	68 cc ea 12 f0       	push   $0xf012eacc
f011a9ba:	e8 cc 65 fe ff       	call   f0100f8b <cprintf>
f011a9bf:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011a9c2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a9c6:	74 04                	je     f011a9cc <test_kfree_bestfirstfit+0xfb6>
f011a9c8:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a9cc:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011a9d3:	83 ec 0c             	sub    $0xc,%esp
f011a9d6:	68 2c eb 12 f0       	push   $0xf012eb2c
f011a9db:	e8 ab 65 fe ff       	call   f0100f8b <cprintf>
f011a9e0:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011a9e3:	83 ec 0c             	sub    $0xc,%esp
f011a9e6:	6a 03                	push   $0x3
f011a9e8:	e8 84 46 ff ff       	call   f010f071 <sys_bypassPageFault>
f011a9ed:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011a9f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a9f7:	e9 af 00 00 00       	jmp    f011aaab <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011a9fc:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011aa00:	0f 84 a1 00 00 00    	je     f011aaa7 <test_kfree_bestfirstfit+0x1091>
f011aa06:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011aa0a:	0f 84 97 00 00 00    	je     f011aaa7 <test_kfree_bestfirstfit+0x1091>
f011aa10:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011aa14:	0f 84 8d 00 00 00    	je     f011aaa7 <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011aa1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011aa1d:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011aa24:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011aa27:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aa2a:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011aa2d:	e8 2d 46 ff ff       	call   f010f05f <sys_rcr2>
f011aa32:	89 c2                	mov    %eax,%edx
f011aa34:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aa37:	39 c2                	cmp    %eax,%edx
f011aa39:	74 1d                	je     f011aa58 <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011aa3b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aa3f:	74 17                	je     f011aa58 <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011aa41:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa48:	83 ec 0c             	sub    $0xc,%esp
f011aa4b:	68 6c eb 12 f0       	push   $0xf012eb6c
f011aa50:	e8 36 65 fe ff       	call   f0100f8b <cprintf>
f011aa55:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011aa58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011aa5b:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011aa62:	89 c2                	mov    %eax,%edx
f011aa64:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aa67:	01 d0                	add    %edx,%eax
f011aa69:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011aa6c:	e8 ee 45 ff ff       	call   f010f05f <sys_rcr2>
f011aa71:	89 c2                	mov    %eax,%edx
f011aa73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011aa76:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011aa7d:	89 c1                	mov    %eax,%ecx
f011aa7f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aa82:	01 c8                	add    %ecx,%eax
f011aa84:	39 c2                	cmp    %eax,%edx
f011aa86:	74 20                	je     f011aaa8 <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011aa88:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aa8c:	74 1a                	je     f011aaa8 <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011aa8e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa95:	83 ec 0c             	sub    $0xc,%esp
f011aa98:	68 b8 eb 12 f0       	push   $0xf012ebb8
f011aa9d:	e8 e9 64 fe ff       	call   f0100f8b <cprintf>
f011aaa2:	83 c4 10             	add    $0x10,%esp
f011aaa5:	eb 01                	jmp    f011aaa8 <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011aaa7:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011aaa8:	ff 45 f4             	incl   -0xc(%ebp)
f011aaab:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011aaaf:	0f 8e 47 ff ff ff    	jle    f011a9fc <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011aab5:	83 ec 0c             	sub    $0xc,%esp
f011aab8:	6a 00                	push   $0x0
f011aaba:	e8 b2 45 ff ff       	call   f010f071 <sys_bypassPageFault>
f011aabf:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011aac2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aac6:	74 04                	je     f011aacc <test_kfree_bestfirstfit+0x10b6>
f011aac8:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011aacc:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011aad3:	83 ec 0c             	sub    $0xc,%esp
f011aad6:	68 04 ec 12 f0       	push   $0xf012ec04
f011aadb:	e8 ab 64 fe ff       	call   f0100f8b <cprintf>
f011aae0:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011aae3:	e8 60 41 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011aae8:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aaeb:	e8 a3 9f fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011aaf0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011aaf3:	83 ec 0c             	sub    $0xc,%esp
f011aaf6:	68 00 04 00 00       	push   $0x400
f011aafb:	e8 cf ec fe ff       	call   f01097cf <kmalloc>
f011ab00:	83 c4 10             	add    $0x10,%esp
f011ab03:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011ab09:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011ab0f:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011ab15:	39 c2                	cmp    %eax,%edx
f011ab17:	74 17                	je     f011ab30 <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ab19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab20:	83 ec 0c             	sub    $0xc,%esp
f011ab23:	68 28 ec 12 f0       	push   $0xf012ec28
f011ab28:	e8 5e 64 fe ff       	call   f0100f8b <cprintf>
f011ab2d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab30:	e8 5e 9f fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ab35:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ab38:	74 17                	je     f011ab51 <test_kfree_bestfirstfit+0x113b>
f011ab3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab41:	83 ec 0c             	sub    $0xc,%esp
f011ab44:	68 7c ec 12 f0       	push   $0xf012ec7c
f011ab49:	e8 3d 64 fe ff       	call   f0100f8b <cprintf>
f011ab4e:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011ab51:	e8 f2 40 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ab56:	89 c2                	mov    %eax,%edx
f011ab58:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ab5b:	39 c2                	cmp    %eax,%edx
f011ab5d:	74 17                	je     f011ab76 <test_kfree_bestfirstfit+0x1160>
f011ab5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab66:	83 ec 0c             	sub    $0xc,%esp
f011ab69:	68 ec ec 12 f0       	push   $0xf012ecec
f011ab6e:	e8 18 64 fe ff       	call   f0100f8b <cprintf>
f011ab73:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011ab76:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011ab7d:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011ab83:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011ab86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab8d:	eb 0e                	jmp    f011ab9d <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011ab8f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ab92:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab95:	01 d0                	add    %edx,%eax
f011ab97:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011ab9a:	ff 45 f4             	incl   -0xc(%ebp)
f011ab9d:	8b 45 90             	mov    -0x70(%ebp),%eax
f011aba0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aba3:	7f ea                	jg     f011ab8f <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011aba5:	e8 9e 40 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011abaa:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011abad:	e8 e1 9e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011abb2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011abb5:	83 ec 0c             	sub    $0xc,%esp
f011abb8:	68 00 08 00 00       	push   $0x800
f011abbd:	e8 0d ec fe ff       	call   f01097cf <kmalloc>
f011abc2:	83 c4 10             	add    $0x10,%esp
f011abc5:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011abcb:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011abd1:	05 08 04 00 00       	add    $0x408,%eax
f011abd6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011abd9:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011abdf:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011abe2:	74 35                	je     f011ac19 <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011abe4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011abeb:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011abf1:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011abf7:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011abfd:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011ac03:	81 c2 00 04 00 00    	add    $0x400,%edx
f011ac09:	50                   	push   %eax
f011ac0a:	51                   	push   %ecx
f011ac0b:	52                   	push   %edx
f011ac0c:	68 68 ed 12 f0       	push   $0xf012ed68
f011ac11:	e8 75 63 fe ff       	call   f0100f8b <cprintf>
f011ac16:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ac19:	e8 75 9e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ac1e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ac21:	74 17                	je     f011ac3a <test_kfree_bestfirstfit+0x1224>
f011ac23:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac2a:	83 ec 0c             	sub    $0xc,%esp
f011ac2d:	68 dc ed 12 f0       	push   $0xf012eddc
f011ac32:	e8 54 63 fe ff       	call   f0100f8b <cprintf>
f011ac37:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011ac3a:	e8 09 40 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ac3f:	89 c2                	mov    %eax,%edx
f011ac41:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ac44:	39 c2                	cmp    %eax,%edx
f011ac46:	74 17                	je     f011ac5f <test_kfree_bestfirstfit+0x1249>
f011ac48:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac4f:	83 ec 0c             	sub    $0xc,%esp
f011ac52:	68 4c ee 12 f0       	push   $0xf012ee4c
f011ac57:	e8 2f 63 fe ff       	call   f0100f8b <cprintf>
f011ac5c:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011ac5f:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011ac66:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011ac6c:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011ac6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac76:	eb 0e                	jmp    f011ac86 <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011ac78:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ac7b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac7e:	01 d0                	add    %edx,%eax
f011ac80:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011ac83:	ff 45 f4             	incl   -0xc(%ebp)
f011ac86:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ac89:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ac8c:	7f ea                	jg     f011ac78 <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011ac8e:	e8 b5 3f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ac93:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ac96:	e8 f8 9d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ac9b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011ac9e:	83 ec 0c             	sub    $0xc,%esp
f011aca1:	68 00 06 00 00       	push   $0x600
f011aca6:	e8 24 eb fe ff       	call   f01097cf <kmalloc>
f011acab:	83 c4 10             	add    $0x10,%esp
f011acae:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011acb4:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011acba:	05 10 0c 00 00       	add    $0xc10,%eax
f011acbf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011acc2:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011acc8:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011accb:	74 17                	je     f011ace4 <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011accd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acd4:	83 ec 0c             	sub    $0xc,%esp
f011acd7:	68 c8 ee 12 f0       	push   $0xf012eec8
f011acdc:	e8 aa 62 fe ff       	call   f0100f8b <cprintf>
f011ace1:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ace4:	e8 aa 9d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ace9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011acec:	74 17                	je     f011ad05 <test_kfree_bestfirstfit+0x12ef>
f011acee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acf5:	83 ec 0c             	sub    $0xc,%esp
f011acf8:	68 1c ef 12 f0       	push   $0xf012ef1c
f011acfd:	e8 89 62 fe ff       	call   f0100f8b <cprintf>
f011ad02:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011ad05:	e8 3e 3f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ad0a:	89 c2                	mov    %eax,%edx
f011ad0c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ad0f:	39 c2                	cmp    %eax,%edx
f011ad11:	74 17                	je     f011ad2a <test_kfree_bestfirstfit+0x1314>
f011ad13:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad1a:	83 ec 0c             	sub    $0xc,%esp
f011ad1d:	68 8c ef 12 f0       	push   $0xf012ef8c
f011ad22:	e8 64 62 fe ff       	call   f0100f8b <cprintf>
f011ad27:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011ad2a:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011ad31:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011ad37:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011ad3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ad41:	eb 0e                	jmp    f011ad51 <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011ad43:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad46:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ad49:	01 d0                	add    %edx,%eax
f011ad4b:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011ad4e:	ff 45 f4             	incl   -0xc(%ebp)
f011ad51:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ad54:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ad57:	7f ea                	jg     f011ad43 <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011ad59:	e8 ea 3e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ad5e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ad61:	e8 2d 9d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ad66:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011ad69:	83 ec 0c             	sub    $0xc,%esp
f011ad6c:	68 00 00 e0 01       	push   $0x1e00000
f011ad71:	e8 59 ea fe ff       	call   f01097cf <kmalloc>
f011ad76:	83 c4 10             	add    $0x10,%esp
f011ad79:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ad7f:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ad85:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ad8a:	74 17                	je     f011ada3 <test_kfree_bestfirstfit+0x138d>
f011ad8c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad93:	83 ec 0c             	sub    $0xc,%esp
f011ad96:	68 08 f0 12 f0       	push   $0xf012f008
f011ad9b:	e8 eb 61 fe ff       	call   f0100f8b <cprintf>
f011ada0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ada3:	e8 eb 9c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ada8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011adab:	74 17                	je     f011adc4 <test_kfree_bestfirstfit+0x13ae>
f011adad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011adb4:	83 ec 0c             	sub    $0xc,%esp
f011adb7:	68 5c f0 12 f0       	push   $0xf012f05c
f011adbc:	e8 ca 61 fe ff       	call   f0100f8b <cprintf>
f011adc1:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011adc4:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011adc7:	e8 7c 3e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011adcc:	29 c3                	sub    %eax,%ebx
f011adce:	89 d8                	mov    %ebx,%eax
f011add0:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011add5:	77 17                	ja     f011adee <test_kfree_bestfirstfit+0x13d8>
f011add7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011adde:	83 ec 0c             	sub    $0xc,%esp
f011ade1:	68 cc f0 12 f0       	push   $0xf012f0cc
f011ade6:	e8 a0 61 fe ff       	call   f0100f8b <cprintf>
f011adeb:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011adee:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011adf5:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011adfb:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011adfe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ae05:	eb 0e                	jmp    f011ae15 <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011ae07:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ae0a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ae0d:	01 d0                	add    %edx,%eax
f011ae0f:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011ae12:	ff 45 f4             	incl   -0xc(%ebp)
f011ae15:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ae18:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ae1b:	7f ea                	jg     f011ae07 <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011ae1d:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ae23:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011ae26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ae2d:	eb 1e                	jmp    f011ae4d <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011ae2f:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011ae35:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ae38:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ae3b:	01 c8                	add    %ecx,%eax
f011ae3d:	8a 00                	mov    (%eax),%al
f011ae3f:	0f be c0             	movsbl %al,%eax
f011ae42:	01 d0                	add    %edx,%eax
f011ae44:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011ae4a:	ff 45 f4             	incl   -0xc(%ebp)
f011ae4d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ae50:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ae53:	7f da                	jg     f011ae2f <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011ae55:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011ae5b:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011ae5e:	89 d0                	mov    %edx,%eax
f011ae60:	c1 e0 02             	shl    $0x2,%eax
f011ae63:	01 d0                	add    %edx,%eax
f011ae65:	01 c0                	add    %eax,%eax
f011ae67:	39 c1                	cmp    %eax,%ecx
f011ae69:	74 17                	je     f011ae82 <test_kfree_bestfirstfit+0x146c>
f011ae6b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae72:	83 ec 0c             	sub    $0xc,%esp
f011ae75:	68 14 f1 12 f0       	push   $0xf012f114
f011ae7a:	e8 0c 61 fe ff       	call   f0100f8b <cprintf>
f011ae7f:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011ae82:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011ae88:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011ae8b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ae92:	eb 1e                	jmp    f011aeb2 <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011ae94:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011ae9a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ae9d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aea0:	01 c8                	add    %ecx,%eax
f011aea2:	8a 00                	mov    (%eax),%al
f011aea4:	0f be c0             	movsbl %al,%eax
f011aea7:	01 d0                	add    %edx,%eax
f011aea9:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011aeaf:	ff 45 f4             	incl   -0xc(%ebp)
f011aeb2:	8b 45 90             	mov    -0x70(%ebp),%eax
f011aeb5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aeb8:	7f da                	jg     f011ae94 <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011aeba:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011aec0:	8b 55 90             	mov    -0x70(%ebp),%edx
f011aec3:	89 d0                	mov    %edx,%eax
f011aec5:	c1 e0 02             	shl    $0x2,%eax
f011aec8:	01 d0                	add    %edx,%eax
f011aeca:	01 c0                	add    %eax,%eax
f011aecc:	01 d0                	add    %edx,%eax
f011aece:	39 c1                	cmp    %eax,%ecx
f011aed0:	74 17                	je     f011aee9 <test_kfree_bestfirstfit+0x14d3>
f011aed2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aed9:	83 ec 0c             	sub    $0xc,%esp
f011aedc:	68 44 f1 12 f0       	push   $0xf012f144
f011aee1:	e8 a5 60 fe ff       	call   f0100f8b <cprintf>
f011aee6:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011aee9:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011aeef:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011aef2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aef9:	eb 1e                	jmp    f011af19 <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011aefb:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011af01:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011af04:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011af07:	01 c8                	add    %ecx,%eax
f011af09:	8a 00                	mov    (%eax),%al
f011af0b:	0f be c0             	movsbl %al,%eax
f011af0e:	01 d0                	add    %edx,%eax
f011af10:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011af16:	ff 45 f4             	incl   -0xc(%ebp)
f011af19:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011af1c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011af1f:	7f da                	jg     f011aefb <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011af21:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011af27:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011af2a:	89 d0                	mov    %edx,%eax
f011af2c:	01 c0                	add    %eax,%eax
f011af2e:	01 d0                	add    %edx,%eax
f011af30:	c1 e0 02             	shl    $0x2,%eax
f011af33:	39 c1                	cmp    %eax,%ecx
f011af35:	74 17                	je     f011af4e <test_kfree_bestfirstfit+0x1538>
f011af37:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af3e:	83 ec 0c             	sub    $0xc,%esp
f011af41:	68 74 f1 12 f0       	push   $0xf012f174
f011af46:	e8 40 60 fe ff       	call   f0100f8b <cprintf>
f011af4b:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011af4e:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011af54:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011af57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011af5e:	eb 1e                	jmp    f011af7e <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011af60:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011af66:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011af69:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011af6c:	01 c8                	add    %ecx,%eax
f011af6e:	8a 00                	mov    (%eax),%al
f011af70:	0f be c0             	movsbl %al,%eax
f011af73:	01 d0                	add    %edx,%eax
f011af75:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011af7b:	ff 45 f4             	incl   -0xc(%ebp)
f011af7e:	8b 45 98             	mov    -0x68(%ebp),%eax
f011af81:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011af84:	7f da                	jg     f011af60 <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011af86:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011af8c:	8b 55 98             	mov    -0x68(%ebp),%edx
f011af8f:	89 d0                	mov    %edx,%eax
f011af91:	01 c0                	add    %eax,%eax
f011af93:	01 d0                	add    %edx,%eax
f011af95:	c1 e0 02             	shl    $0x2,%eax
f011af98:	01 d0                	add    %edx,%eax
f011af9a:	39 c1                	cmp    %eax,%ecx
f011af9c:	74 17                	je     f011afb5 <test_kfree_bestfirstfit+0x159f>
f011af9e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afa5:	83 ec 0c             	sub    $0xc,%esp
f011afa8:	68 a4 f1 12 f0       	push   $0xf012f1a4
f011afad:	e8 d9 5f fe ff       	call   f0100f8b <cprintf>
f011afb2:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011afb5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011afb9:	74 04                	je     f011afbf <test_kfree_bestfirstfit+0x15a9>
f011afbb:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011afbf:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011afc6:	83 ec 0c             	sub    $0xc,%esp
f011afc9:	68 d1 f1 12 f0       	push   $0xf012f1d1
f011afce:	e8 b8 5f fe ff       	call   f0100f8b <cprintf>
f011afd3:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011afd6:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011afdd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011afe4:	eb 4e                	jmp    f011b034 <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011afe6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011afe9:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011afee:	83 ec 04             	sub    $0x4,%esp
f011aff1:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011aff7:	51                   	push   %ecx
f011aff8:	52                   	push   %edx
f011aff9:	50                   	push   %eax
f011affa:	e8 1b d7 fe ff       	call   f010871a <get_page_table>
f011afff:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b002:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011b008:	85 c0                	test   %eax,%eax
f011b00a:	75 1d                	jne    f011b029 <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011b00c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b010:	74 17                	je     f011b029 <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011b012:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b019:	83 ec 0c             	sub    $0xc,%esp
f011b01c:	68 f0 f1 12 f0       	push   $0xf012f1f0
f011b021:	e8 65 5f fe ff       	call   f0100f8b <cprintf>
f011b026:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011b029:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011b030:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011b034:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b038:	78 ac                	js     f011afe6 <test_kfree_bestfirstfit+0x15d0>
f011b03a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b03e:	7f 09                	jg     f011b049 <test_kfree_bestfirstfit+0x1633>
f011b040:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011b047:	76 9d                	jbe    f011afe6 <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011b049:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b04d:	74 04                	je     f011b053 <test_kfree_bestfirstfit+0x163d>
f011b04f:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011b053:	83 ec 08             	sub    $0x8,%esp
f011b056:	ff 75 f0             	pushl  -0x10(%ebp)
f011b059:	68 58 f2 12 f0       	push   $0xf012f258
f011b05e:	e8 28 5f fe ff       	call   f0100f8b <cprintf>
f011b063:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b066:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011b06b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b06e:	5b                   	pop    %ebx
f011b06f:	5f                   	pop    %edi
f011b070:	5d                   	pop    %ebp
f011b071:	c3                   	ret    

f011b072 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011b072:	55                   	push   %ebp
f011b073:	89 e5                	mov    %esp,%ebp
f011b075:	57                   	push   %edi
f011b076:	53                   	push   %ebx
f011b077:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b07d:	83 ec 0c             	sub    $0xc,%esp
f011b080:	68 28 b5 12 f0       	push   $0xf012b528
f011b085:	e8 01 5f fe ff       	call   f0100f8b <cprintf>
f011b08a:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b08d:	83 ec 0c             	sub    $0xc,%esp
f011b090:	68 58 b5 12 f0       	push   $0xf012b558
f011b095:	e8 f1 5e fe ff       	call   f0100f8b <cprintf>
f011b09a:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b09d:	83 ec 0c             	sub    $0xc,%esp
f011b0a0:	68 28 b5 12 f0       	push   $0xf012b528
f011b0a5:	e8 e1 5e fe ff       	call   f0100f8b <cprintf>
f011b0aa:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011b0ad:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011b0b1:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011b0b5:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011b0bb:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011b0c1:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011b0c8:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011b0cf:	e8 74 3b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b0d4:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011b0d7:	83 ec 0c             	sub    $0xc,%esp
f011b0da:	68 7c f2 12 f0       	push   $0xf012f27c
f011b0df:	e8 a7 5e fe ff       	call   f0100f8b <cprintf>
f011b0e4:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011b0e7:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011b0ed:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b0f2:	b8 00 00 00 00       	mov    $0x0,%eax
f011b0f7:	89 d7                	mov    %edx,%edi
f011b0f9:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011b0fb:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011b101:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b106:	b8 00 00 00 00       	mov    $0x0,%eax
f011b10b:	89 d7                	mov    %edx,%edi
f011b10d:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011b10f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011b116:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011b11d:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011b123:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b128:	b8 00 00 00 00       	mov    $0x0,%eax
f011b12d:	89 d7                	mov    %edx,%edi
f011b12f:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b131:	e8 12 3b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b136:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b139:	e8 55 99 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b13e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b141:	83 ec 0c             	sub    $0xc,%esp
f011b144:	68 00 fc 1f 00       	push   $0x1ffc00
f011b149:	e8 81 e6 fe ff       	call   f01097cf <kmalloc>
f011b14e:	83 c4 10             	add    $0x10,%esp
f011b151:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b157:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b15d:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b162:	74 17                	je     f011b17b <test_kheap_phys_addr+0x109>
f011b164:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b16b:	83 ec 0c             	sub    $0xc,%esp
f011b16e:	68 20 d6 12 f0       	push   $0xf012d620
f011b173:	e8 13 5e fe ff       	call   f0100f8b <cprintf>
f011b178:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b17b:	e8 13 99 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b180:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b183:	74 17                	je     f011b19c <test_kheap_phys_addr+0x12a>
f011b185:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b18c:	83 ec 0c             	sub    $0xc,%esp
f011b18f:	68 74 d6 12 f0       	push   $0xf012d674
f011b194:	e8 f2 5d fe ff       	call   f0100f8b <cprintf>
f011b199:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b19c:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b19f:	e8 a4 3a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b1a4:	29 c3                	sub    %eax,%ebx
f011b1a6:	89 d8                	mov    %ebx,%eax
f011b1a8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b1ad:	77 17                	ja     f011b1c6 <test_kheap_phys_addr+0x154>
f011b1af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1b6:	83 ec 0c             	sub    $0xc,%esp
f011b1b9:	68 e4 d6 12 f0       	push   $0xf012d6e4
f011b1be:	e8 c8 5d fe ff       	call   f0100f8b <cprintf>
f011b1c3:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b1c6:	e8 7d 3a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b1cb:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b1ce:	e8 c0 98 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b1d3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b1d6:	83 ec 0c             	sub    $0xc,%esp
f011b1d9:	68 00 fc 1f 00       	push   $0x1ffc00
f011b1de:	e8 ec e5 fe ff       	call   f01097cf <kmalloc>
f011b1e3:	83 c4 10             	add    $0x10,%esp
f011b1e6:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b1ec:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b1f2:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011b1f7:	74 17                	je     f011b210 <test_kheap_phys_addr+0x19e>
f011b1f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b200:	83 ec 0c             	sub    $0xc,%esp
f011b203:	68 2c d7 12 f0       	push   $0xf012d72c
f011b208:	e8 7e 5d fe ff       	call   f0100f8b <cprintf>
f011b20d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b210:	e8 7e 98 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b215:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b218:	74 17                	je     f011b231 <test_kheap_phys_addr+0x1bf>
f011b21a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b221:	83 ec 0c             	sub    $0xc,%esp
f011b224:	68 80 d7 12 f0       	push   $0xf012d780
f011b229:	e8 5d 5d fe ff       	call   f0100f8b <cprintf>
f011b22e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b231:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b234:	e8 0f 3a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b239:	29 c3                	sub    %eax,%ebx
f011b23b:	89 d8                	mov    %ebx,%eax
f011b23d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b242:	77 17                	ja     f011b25b <test_kheap_phys_addr+0x1e9>
f011b244:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b24b:	83 ec 0c             	sub    $0xc,%esp
f011b24e:	68 f0 d7 12 f0       	push   $0xf012d7f0
f011b253:	e8 33 5d fe ff       	call   f0100f8b <cprintf>
f011b258:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011b25b:	e8 e8 39 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b260:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b263:	e8 2b 98 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b268:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011b26b:	83 ec 0c             	sub    $0xc,%esp
f011b26e:	68 00 04 00 00       	push   $0x400
f011b273:	e8 57 e5 fe ff       	call   f01097cf <kmalloc>
f011b278:	83 c4 10             	add    $0x10,%esp
f011b27b:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011b281:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b287:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b28c:	76 28                	jbe    f011b2b6 <test_kheap_phys_addr+0x244>
f011b28e:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011b294:	83 ec 0c             	sub    $0xc,%esp
f011b297:	6a 00                	push   $0x0
f011b299:	e8 fe e3 fe ff       	call   f010969c <sbrk>
f011b29e:	83 c4 10             	add    $0x10,%esp
f011b2a1:	39 c3                	cmp    %eax,%ebx
f011b2a3:	73 11                	jae    f011b2b6 <test_kheap_phys_addr+0x244>
f011b2a5:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b2ab:	89 c2                	mov    %eax,%edx
f011b2ad:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b2b2:	39 c2                	cmp    %eax,%edx
f011b2b4:	72 17                	jb     f011b2cd <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b2b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2bd:	83 ec 0c             	sub    $0xc,%esp
f011b2c0:	68 ac f2 12 f0       	push   $0xf012f2ac
f011b2c5:	e8 c1 5c fe ff       	call   f0100f8b <cprintf>
f011b2ca:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b2cd:	e8 c1 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b2d2:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b2d5:	74 17                	je     f011b2ee <test_kheap_phys_addr+0x27c>
f011b2d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2de:	83 ec 0c             	sub    $0xc,%esp
f011b2e1:	68 8c d8 12 f0       	push   $0xf012d88c
f011b2e6:	e8 a0 5c fe ff       	call   f0100f8b <cprintf>
f011b2eb:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011b2ee:	e8 55 39 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b2f3:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b2f6:	e8 98 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b2fb:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011b2fe:	83 ec 0c             	sub    $0xc,%esp
f011b301:	68 00 08 00 00       	push   $0x800
f011b306:	e8 c4 e4 fe ff       	call   f01097cf <kmalloc>
f011b30b:	83 c4 10             	add    $0x10,%esp
f011b30e:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b314:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b31a:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b31f:	76 28                	jbe    f011b349 <test_kheap_phys_addr+0x2d7>
f011b321:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011b327:	83 ec 0c             	sub    $0xc,%esp
f011b32a:	6a 00                	push   $0x0
f011b32c:	e8 6b e3 fe ff       	call   f010969c <sbrk>
f011b331:	83 c4 10             	add    $0x10,%esp
f011b334:	39 c3                	cmp    %eax,%ebx
f011b336:	73 11                	jae    f011b349 <test_kheap_phys_addr+0x2d7>
f011b338:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b33e:	89 c2                	mov    %eax,%edx
f011b340:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b345:	39 c2                	cmp    %eax,%edx
f011b347:	72 17                	jb     f011b360 <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b349:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b350:	83 ec 0c             	sub    $0xc,%esp
f011b353:	68 38 f3 12 f0       	push   $0xf012f338
f011b358:	e8 2e 5c fe ff       	call   f0100f8b <cprintf>
f011b35d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b360:	e8 2e 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b365:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b368:	74 17                	je     f011b381 <test_kheap_phys_addr+0x30f>
f011b36a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b371:	83 ec 0c             	sub    $0xc,%esp
f011b374:	68 98 d9 12 f0       	push   $0xf012d998
f011b379:	e8 0d 5c fe ff       	call   f0100f8b <cprintf>
f011b37e:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b381:	e8 c2 38 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b386:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b389:	e8 05 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b38e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011b391:	83 ec 0c             	sub    $0xc,%esp
f011b394:	68 00 06 00 00       	push   $0x600
f011b399:	e8 31 e4 fe ff       	call   f01097cf <kmalloc>
f011b39e:	83 c4 10             	add    $0x10,%esp
f011b3a1:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b3a7:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b3ad:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b3b2:	76 28                	jbe    f011b3dc <test_kheap_phys_addr+0x36a>
f011b3b4:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011b3ba:	83 ec 0c             	sub    $0xc,%esp
f011b3bd:	6a 00                	push   $0x0
f011b3bf:	e8 d8 e2 fe ff       	call   f010969c <sbrk>
f011b3c4:	83 c4 10             	add    $0x10,%esp
f011b3c7:	39 c3                	cmp    %eax,%ebx
f011b3c9:	73 11                	jae    f011b3dc <test_kheap_phys_addr+0x36a>
f011b3cb:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b3d1:	89 c2                	mov    %eax,%edx
f011b3d3:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b3d8:	39 c2                	cmp    %eax,%edx
f011b3da:	72 17                	jb     f011b3f3 <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b3dc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b3e3:	83 ec 0c             	sub    $0xc,%esp
f011b3e6:	68 c4 f3 12 f0       	push   $0xf012f3c4
f011b3eb:	e8 9b 5b fe ff       	call   f0100f8b <cprintf>
f011b3f0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b3f3:	e8 9b 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b3f8:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b3fb:	74 17                	je     f011b414 <test_kheap_phys_addr+0x3a2>
f011b3fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b404:	83 ec 0c             	sub    $0xc,%esp
f011b407:	68 a4 da 12 f0       	push   $0xf012daa4
f011b40c:	e8 7a 5b fe ff       	call   f0100f8b <cprintf>
f011b411:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b414:	e8 2f 38 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b419:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b41c:	e8 72 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b421:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b424:	83 ec 0c             	sub    $0xc,%esp
f011b427:	68 00 1c 00 00       	push   $0x1c00
f011b42c:	e8 9e e3 fe ff       	call   f01097cf <kmalloc>
f011b431:	83 c4 10             	add    $0x10,%esp
f011b434:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b43a:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b440:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b445:	74 17                	je     f011b45e <test_kheap_phys_addr+0x3ec>
f011b447:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b44e:	83 ec 0c             	sub    $0xc,%esp
f011b451:	68 5c db 12 f0       	push   $0xf012db5c
f011b456:	e8 30 5b fe ff       	call   f0100f8b <cprintf>
f011b45b:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b45e:	e8 30 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b463:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b466:	74 17                	je     f011b47f <test_kheap_phys_addr+0x40d>
f011b468:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b46f:	83 ec 0c             	sub    $0xc,%esp
f011b472:	68 b0 db 12 f0       	push   $0xf012dbb0
f011b477:	e8 0f 5b fe ff       	call   f0100f8b <cprintf>
f011b47c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b47f:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b482:	e8 c1 37 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b487:	29 c3                	sub    %eax,%ebx
f011b489:	89 d8                	mov    %ebx,%eax
f011b48b:	83 f8 01             	cmp    $0x1,%eax
f011b48e:	77 17                	ja     f011b4a7 <test_kheap_phys_addr+0x435>
f011b490:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b497:	83 ec 0c             	sub    $0xc,%esp
f011b49a:	68 20 dc 12 f0       	push   $0xf012dc20
f011b49f:	e8 e7 5a fe ff       	call   f0100f8b <cprintf>
f011b4a4:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b4a7:	e8 9c 37 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b4ac:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b4af:	e8 df 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b4b4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b4b7:	83 ec 0c             	sub    $0xc,%esp
f011b4ba:	68 00 fc 2f 00       	push   $0x2ffc00
f011b4bf:	e8 0b e3 fe ff       	call   f01097cf <kmalloc>
f011b4c4:	83 c4 10             	add    $0x10,%esp
f011b4c7:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b4cd:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b4d3:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b4d8:	74 17                	je     f011b4f1 <test_kheap_phys_addr+0x47f>
f011b4da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b4e1:	83 ec 0c             	sub    $0xc,%esp
f011b4e4:	68 50 f4 12 f0       	push   $0xf012f450
f011b4e9:	e8 9d 5a fe ff       	call   f0100f8b <cprintf>
f011b4ee:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b4f1:	e8 9d 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b4f6:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b4f9:	74 17                	je     f011b512 <test_kheap_phys_addr+0x4a0>
f011b4fb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b502:	83 ec 0c             	sub    $0xc,%esp
f011b505:	68 f4 dc 12 f0       	push   $0xf012dcf4
f011b50a:	e8 7c 5a fe ff       	call   f0100f8b <cprintf>
f011b50f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b512:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b515:	e8 2e 37 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b51a:	29 c3                	sub    %eax,%ebx
f011b51c:	89 d8                	mov    %ebx,%eax
f011b51e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b523:	77 17                	ja     f011b53c <test_kheap_phys_addr+0x4ca>
f011b525:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b52c:	83 ec 0c             	sub    $0xc,%esp
f011b52f:	68 a4 f4 12 f0       	push   $0xf012f4a4
f011b534:	e8 52 5a fe ff       	call   f0100f8b <cprintf>
f011b539:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b53c:	e8 07 37 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b541:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b544:	e8 4a 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b549:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b54c:	83 ec 0c             	sub    $0xc,%esp
f011b54f:	68 00 fc 5f 00       	push   $0x5ffc00
f011b554:	e8 76 e2 fe ff       	call   f01097cf <kmalloc>
f011b559:	83 c4 10             	add    $0x10,%esp
f011b55c:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b562:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b568:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b56d:	74 17                	je     f011b586 <test_kheap_phys_addr+0x514>
f011b56f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b576:	83 ec 0c             	sub    $0xc,%esp
f011b579:	68 ec f4 12 f0       	push   $0xf012f4ec
f011b57e:	e8 08 5a fe ff       	call   f0100f8b <cprintf>
f011b583:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b586:	e8 08 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b58b:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b58e:	74 17                	je     f011b5a7 <test_kheap_phys_addr+0x535>
f011b590:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b597:	83 ec 0c             	sub    $0xc,%esp
f011b59a:	68 f0 dd 12 f0       	push   $0xf012ddf0
f011b59f:	e8 e7 59 fe ff       	call   f0100f8b <cprintf>
f011b5a4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b5a7:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b5aa:	e8 99 36 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b5af:	29 c3                	sub    %eax,%ebx
f011b5b1:	89 d8                	mov    %ebx,%eax
f011b5b3:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b5b8:	77 17                	ja     f011b5d1 <test_kheap_phys_addr+0x55f>
f011b5ba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5c1:	83 ec 0c             	sub    $0xc,%esp
f011b5c4:	68 40 f5 12 f0       	push   $0xf012f540
f011b5c9:	e8 bd 59 fe ff       	call   f0100f8b <cprintf>
f011b5ce:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011b5d1:	e8 72 36 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b5d6:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b5d9:	e8 b5 94 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b5de:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011b5e1:	83 ec 0c             	sub    $0xc,%esp
f011b5e4:	68 00 38 00 00       	push   $0x3800
f011b5e9:	e8 e1 e1 fe ff       	call   f01097cf <kmalloc>
f011b5ee:	83 c4 10             	add    $0x10,%esp
f011b5f1:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b5f7:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011b5fd:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011b602:	74 17                	je     f011b61b <test_kheap_phys_addr+0x5a9>
f011b604:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b60b:	83 ec 0c             	sub    $0xc,%esp
f011b60e:	68 88 f5 12 f0       	push   $0xf012f588
f011b613:	e8 73 59 fe ff       	call   f0100f8b <cprintf>
f011b618:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b61b:	e8 73 94 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b620:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b623:	74 17                	je     f011b63c <test_kheap_phys_addr+0x5ca>
f011b625:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b62c:	83 ec 0c             	sub    $0xc,%esp
f011b62f:	68 dc f5 12 f0       	push   $0xf012f5dc
f011b634:	e8 52 59 fe ff       	call   f0100f8b <cprintf>
f011b639:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b63c:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b63f:	e8 04 36 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b644:	29 c3                	sub    %eax,%ebx
f011b646:	89 d8                	mov    %ebx,%eax
f011b648:	83 f8 03             	cmp    $0x3,%eax
f011b64b:	77 17                	ja     f011b664 <test_kheap_phys_addr+0x5f2>
f011b64d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b654:	83 ec 0c             	sub    $0xc,%esp
f011b657:	68 4c f6 12 f0       	push   $0xf012f64c
f011b65c:	e8 2a 59 fe ff       	call   f0100f8b <cprintf>
f011b661:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011b664:	83 ec 0c             	sub    $0xc,%esp
f011b667:	68 94 f6 12 f0       	push   $0xf012f694
f011b66c:	e8 1a 59 fe ff       	call   f0100f8b <cprintf>
f011b671:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b674:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b67b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011b682:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b689:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b68e:	05 00 10 00 00       	add    $0x1000,%eax
f011b693:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b696:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b699:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b69c:	eb 2e                	jmp    f011b6cc <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b69e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b6a1:	8d 43 01             	lea    0x1(%ebx),%eax
f011b6a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b6a7:	83 ec 0c             	sub    $0xc,%esp
f011b6aa:	ff 75 e8             	pushl  -0x18(%ebp)
f011b6ad:	e8 03 e5 fe ff       	call   f0109bb5 <kheap_physical_address>
f011b6b2:	83 c4 10             	add    $0x10,%esp
f011b6b5:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b6bc:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b6bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b6c2:	01 d0                	add    %edx,%eax
f011b6c4:	05 00 10 00 00       	add    $0x1000,%eax
f011b6c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b6cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b6cf:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b6d2:	72 ca                	jb     f011b69e <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b6d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b6d7:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011b6da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b6e1:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b6e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b6e7:	e9 ce 00 00 00       	jmp    f011b7ba <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b6ec:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011b6f1:	83 ec 04             	sub    $0x4,%esp
f011b6f4:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b6fa:	52                   	push   %edx
f011b6fb:	ff 75 e8             	pushl  -0x18(%ebp)
f011b6fe:	50                   	push   %eax
f011b6ff:	e8 16 d0 fe ff       	call   f010871a <get_page_table>
f011b704:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b707:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b70d:	85 c0                	test   %eax,%eax
f011b70f:	75 1e                	jne    f011b72f <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b711:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b718:	83 ec 04             	sub    $0x4,%esp
f011b71b:	68 e0 f6 12 f0       	push   $0xf012f6e0
f011b720:	68 e7 05 00 00       	push   $0x5e7
f011b725:	68 73 d4 12 f0       	push   $0xf012d473
f011b72a:	e8 0a 4c fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b72f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b732:	c1 e8 0c             	shr    $0xc,%eax
f011b735:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b73a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011b73d:	eb 62                	jmp    f011b7a1 <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011b73f:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b745:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b748:	c1 e2 02             	shl    $0x2,%edx
f011b74b:	01 d0                	add    %edx,%eax
f011b74d:	8b 00                	mov    (%eax),%eax
f011b74f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b754:	89 c2                	mov    %eax,%edx
f011b756:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b759:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b75e:	01 c2                	add    %eax,%edx
f011b760:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b763:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b76a:	39 c2                	cmp    %eax,%edx
f011b76c:	74 1d                	je     f011b78b <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b76e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b772:	74 17                	je     f011b78b <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011b774:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b77b:	83 ec 0c             	sub    $0xc,%esp
f011b77e:	68 40 f7 12 f0       	push   $0xf012f740
f011b783:	e8 03 58 fe ff       	call   f0100f8b <cprintf>
f011b788:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011b78b:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b78e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b791:	01 d0                	add    %edx,%eax
f011b793:	05 00 10 00 00       	add    $0x1000,%eax
f011b798:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b79b:	ff 45 e4             	incl   -0x1c(%ebp)
f011b79e:	ff 45 f4             	incl   -0xc(%ebp)
f011b7a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b7a4:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011b7a7:	7d 11                	jge    f011b7ba <test_kheap_phys_addr+0x748>
f011b7a9:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011b7b0:	7f 08                	jg     f011b7ba <test_kheap_phys_addr+0x748>
f011b7b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b7b5:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b7b8:	72 85                	jb     f011b73f <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b7ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b7bd:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b7c0:	0f 82 26 ff ff ff    	jb     f011b6ec <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011b7c6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b7ca:	74 04                	je     f011b7d0 <test_kheap_phys_addr+0x75e>
f011b7cc:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b7d0:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011b7d7:	83 ec 0c             	sub    $0xc,%esp
f011b7da:	68 64 f7 12 f0       	push   $0xf012f764
f011b7df:	e8 a7 57 fe ff       	call   f0100f8b <cprintf>
f011b7e4:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b7e7:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011b7ee:	e9 b0 00 00 00       	jmp    f011b8a3 <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011b7f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b7f6:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011b7fd:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011b800:	83 ec 0c             	sub    $0xc,%esp
f011b803:	ff 75 90             	pushl  -0x70(%ebp)
f011b806:	e8 aa e3 fe ff       	call   f0109bb5 <kheap_physical_address>
f011b80b:	83 c4 10             	add    $0x10,%esp
f011b80e:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b811:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011b816:	83 ec 04             	sub    $0x4,%esp
f011b819:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011b81f:	52                   	push   %edx
f011b820:	ff 75 90             	pushl  -0x70(%ebp)
f011b823:	50                   	push   %eax
f011b824:	e8 f1 ce fe ff       	call   f010871a <get_page_table>
f011b829:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b82c:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b832:	85 c0                	test   %eax,%eax
f011b834:	75 1e                	jne    f011b854 <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b836:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b83d:	83 ec 04             	sub    $0x4,%esp
f011b840:	68 b4 f7 12 f0       	push   $0xf012f7b4
f011b845:	68 04 06 00 00       	push   $0x604
f011b84a:	68 73 d4 12 f0       	push   $0xf012d473
f011b84f:	e8 e5 4a fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b854:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b85a:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b85d:	c1 ea 0c             	shr    $0xc,%edx
f011b860:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b866:	c1 e2 02             	shl    $0x2,%edx
f011b869:	01 d0                	add    %edx,%eax
f011b86b:	8b 00                	mov    (%eax),%eax
f011b86d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b872:	89 c2                	mov    %eax,%edx
f011b874:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b877:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b87c:	01 d0                	add    %edx,%eax
f011b87e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b881:	74 1d                	je     f011b8a0 <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b883:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b887:	74 17                	je     f011b8a0 <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011b889:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b890:	83 ec 0c             	sub    $0xc,%esp
f011b893:	68 14 f8 12 f0       	push   $0xf012f814
f011b898:	e8 ee 56 fe ff       	call   f0100f8b <cprintf>
f011b89d:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b8a0:	ff 45 e0             	incl   -0x20(%ebp)
f011b8a3:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011b8a7:	0f 8e 46 ff ff ff    	jle    f011b7f3 <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011b8ad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b8b1:	74 04                	je     f011b8b7 <test_kheap_phys_addr+0x845>
f011b8b3:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011b8b7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011b8be:	83 ec 0c             	sub    $0xc,%esp
f011b8c1:	68 38 f8 12 f0       	push   $0xf012f838
f011b8c6:	e8 c0 56 fe ff       	call   f0100f8b <cprintf>
f011b8cb:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011b8ce:	e8 75 33 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b8d3:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011b8d6:	e8 b8 91 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b8db:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011b8de:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b8e4:	83 ec 0c             	sub    $0xc,%esp
f011b8e7:	50                   	push   %eax
f011b8e8:	e8 a2 e1 fe ff       	call   f0109a8f <kfree>
f011b8ed:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b8f0:	e8 9e 91 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b8f5:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b8f8:	74 17                	je     f011b911 <test_kheap_phys_addr+0x89f>
f011b8fa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b901:	83 ec 0c             	sub    $0xc,%esp
f011b904:	68 24 e3 12 f0       	push   $0xf012e324
f011b909:	e8 7d 56 fe ff       	call   f0100f8b <cprintf>
f011b90e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b911:	e8 32 33 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b916:	89 c2                	mov    %eax,%edx
f011b918:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b91b:	29 c2                	sub    %eax,%edx
f011b91d:	89 d0                	mov    %edx,%eax
f011b91f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b924:	77 17                	ja     f011b93d <test_kheap_phys_addr+0x8cb>
f011b926:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b92d:	83 ec 0c             	sub    $0xc,%esp
f011b930:	68 60 f8 12 f0       	push   $0xf012f860
f011b935:	e8 51 56 fe ff       	call   f0100f8b <cprintf>
f011b93a:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b93d:	e8 06 33 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b942:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b945:	e8 49 91 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b94a:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011b94d:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b953:	83 ec 0c             	sub    $0xc,%esp
f011b956:	50                   	push   %eax
f011b957:	e8 33 e1 fe ff       	call   f0109a8f <kfree>
f011b95c:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b95f:	e8 2f 91 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b964:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b967:	74 17                	je     f011b980 <test_kheap_phys_addr+0x90e>
f011b969:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b970:	83 ec 0c             	sub    $0xc,%esp
f011b973:	68 64 e4 12 f0       	push   $0xf012e464
f011b978:	e8 0e 56 fe ff       	call   f0100f8b <cprintf>
f011b97d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b980:	e8 c3 32 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b985:	89 c2                	mov    %eax,%edx
f011b987:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b98a:	29 c2                	sub    %eax,%edx
f011b98c:	89 d0                	mov    %edx,%eax
f011b98e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b993:	77 17                	ja     f011b9ac <test_kheap_phys_addr+0x93a>
f011b995:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b99c:	83 ec 0c             	sub    $0xc,%esp
f011b99f:	68 9c f8 12 f0       	push   $0xf012f89c
f011b9a4:	e8 e2 55 fe ff       	call   f0100f8b <cprintf>
f011b9a9:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b9ac:	e8 97 32 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b9b1:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b9b4:	e8 da 90 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b9b9:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b9bc:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b9c2:	83 ec 0c             	sub    $0xc,%esp
f011b9c5:	50                   	push   %eax
f011b9c6:	e8 c4 e0 fe ff       	call   f0109a8f <kfree>
f011b9cb:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b9ce:	e8 c0 90 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b9d3:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b9d6:	74 17                	je     f011b9ef <test_kheap_phys_addr+0x97d>
f011b9d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9df:	83 ec 0c             	sub    $0xc,%esp
f011b9e2:	68 70 e5 12 f0       	push   $0xf012e570
f011b9e7:	e8 9f 55 fe ff       	call   f0100f8b <cprintf>
f011b9ec:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b9ef:	e8 54 32 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b9f4:	89 c2                	mov    %eax,%edx
f011b9f6:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b9f9:	29 c2                	sub    %eax,%edx
f011b9fb:	89 d0                	mov    %edx,%eax
f011b9fd:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ba02:	77 17                	ja     f011ba1b <test_kheap_phys_addr+0x9a9>
f011ba04:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba0b:	83 ec 0c             	sub    $0xc,%esp
f011ba0e:	68 d8 f8 12 f0       	push   $0xf012f8d8
f011ba13:	e8 73 55 fe ff       	call   f0100f8b <cprintf>
f011ba18:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011ba1b:	83 ec 0c             	sub    $0xc,%esp
f011ba1e:	68 14 f9 12 f0       	push   $0xf012f914
f011ba23:	e8 63 55 fe ff       	call   f0100f8b <cprintf>
f011ba28:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011ba2b:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011ba32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011ba39:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011ba40:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011ba43:	8b 15 38 0e 18 f0    	mov    0xf0180e38,%edx
f011ba49:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011ba4f:	01 d0                	add    %edx,%eax
f011ba51:	05 00 10 00 00       	add    $0x1000,%eax
f011ba56:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011ba5c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ba62:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011ba65:	eb 25                	jmp    f011ba8c <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011ba67:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011ba6a:	8d 43 01             	lea    0x1(%ebx),%eax
f011ba6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ba70:	83 ec 0c             	sub    $0xc,%esp
f011ba73:	ff 75 d8             	pushl  -0x28(%ebp)
f011ba76:	e8 3a e1 fe ff       	call   f0109bb5 <kheap_physical_address>
f011ba7b:	83 c4 10             	add    $0x10,%esp
f011ba7e:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011ba85:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011ba8c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ba8f:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011ba92:	72 d3                	jb     f011ba67 <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011ba94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ba97:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011ba9d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011baa4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011baaa:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011baad:	e9 f4 00 00 00       	jmp    f011bba6 <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bab2:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011bab7:	83 ec 04             	sub    $0x4,%esp
f011baba:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011bac0:	52                   	push   %edx
f011bac1:	ff 75 d8             	pushl  -0x28(%ebp)
f011bac4:	50                   	push   %eax
f011bac5:	e8 50 cc fe ff       	call   f010871a <get_page_table>
f011baca:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bacd:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011bad3:	85 c0                	test   %eax,%eax
f011bad5:	75 24                	jne    f011bafb <test_kheap_phys_addr+0xa89>
				if (correct)
f011bad7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011badb:	74 1e                	je     f011bafb <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011badd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bae4:	83 ec 04             	sub    $0x4,%esp
f011bae7:	68 64 f9 12 f0       	push   $0xf012f964
f011baec:	68 42 06 00 00       	push   $0x642
f011baf1:	68 73 d4 12 f0       	push   $0xf012d473
f011baf6:	e8 3e 48 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bafb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bafe:	c1 e8 0c             	shr    $0xc,%eax
f011bb01:	25 ff 03 00 00       	and    $0x3ff,%eax
f011bb06:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011bb09:	eb 7b                	jmp    f011bb86 <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011bb0b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011bb12:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011bb18:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011bb1b:	c1 e2 02             	shl    $0x2,%edx
f011bb1e:	01 d0                	add    %edx,%eax
f011bb20:	8b 00                	mov    (%eax),%eax
f011bb22:	83 e0 01             	and    $0x1,%eax
f011bb25:	85 c0                	test   %eax,%eax
f011bb27:	74 24                	je     f011bb4d <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011bb29:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011bb2f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011bb32:	c1 e2 02             	shl    $0x2,%edx
f011bb35:	01 d0                	add    %edx,%eax
f011bb37:	8b 00                	mov    (%eax),%eax
f011bb39:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bb3e:	89 c2                	mov    %eax,%edx
f011bb40:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bb43:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bb48:	01 d0                	add    %edx,%eax
f011bb4a:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011bb4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bb50:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011bb57:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011bb5a:	74 1d                	je     f011bb79 <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011bb5c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bb60:	74 17                	je     f011bb79 <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011bb62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb69:	83 ec 0c             	sub    $0xc,%esp
f011bb6c:	68 c4 f9 12 f0       	push   $0xf012f9c4
f011bb71:	e8 15 54 fe ff       	call   f0100f8b <cprintf>
f011bb76:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011bb79:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bb80:	ff 45 d4             	incl   -0x2c(%ebp)
f011bb83:	ff 45 f4             	incl   -0xc(%ebp)
f011bb86:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bb89:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011bb8f:	7d 15                	jge    f011bba6 <test_kheap_phys_addr+0xb34>
f011bb91:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011bb98:	7f 0c                	jg     f011bba6 <test_kheap_phys_addr+0xb34>
f011bb9a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bb9d:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011bba0:	0f 82 65 ff ff ff    	jb     f011bb0b <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011bba6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bba9:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011bbac:	0f 82 00 ff ff ff    	jb     f011bab2 <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011bbb2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bbb6:	74 04                	je     f011bbbc <test_kheap_phys_addr+0xb4a>
f011bbb8:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011bbbc:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011bbc3:	83 ec 0c             	sub    $0xc,%esp
f011bbc6:	68 e8 f9 12 f0       	push   $0xf012f9e8
f011bbcb:	e8 bb 53 fe ff       	call   f0100f8b <cprintf>
f011bbd0:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011bbd3:	83 ec 0c             	sub    $0xc,%esp
f011bbd6:	6a 00                	push   $0x0
f011bbd8:	e8 bf da fe ff       	call   f010969c <sbrk>
f011bbdd:	83 c4 10             	add    $0x10,%esp
f011bbe0:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011bbe5:	77 17                	ja     f011bbfe <test_kheap_phys_addr+0xb8c>
f011bbe7:	83 ec 04             	sub    $0x4,%esp
f011bbea:	68 40 fa 12 f0       	push   $0xf012fa40
f011bbef:	68 5d 06 00 00       	push   $0x65d
f011bbf4:	68 73 d4 12 f0       	push   $0xf012d473
f011bbf9:	e8 3b 47 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011bbfe:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011bc05:	e9 af 00 00 00       	jmp    f011bcb9 <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011bc0a:	83 ec 0c             	sub    $0xc,%esp
f011bc0d:	ff 75 d0             	pushl  -0x30(%ebp)
f011bc10:	e8 a0 df fe ff       	call   f0109bb5 <kheap_physical_address>
f011bc15:	83 c4 10             	add    $0x10,%esp
f011bc18:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bc1e:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011bc23:	83 ec 04             	sub    $0x4,%esp
f011bc26:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011bc2c:	52                   	push   %edx
f011bc2d:	ff 75 d0             	pushl  -0x30(%ebp)
f011bc30:	50                   	push   %eax
f011bc31:	e8 e4 ca fe ff       	call   f010871a <get_page_table>
f011bc36:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bc39:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011bc3f:	85 c0                	test   %eax,%eax
f011bc41:	75 24                	jne    f011bc67 <test_kheap_phys_addr+0xbf5>
				if (correct)
f011bc43:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bc47:	74 1e                	je     f011bc67 <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bc49:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc50:	83 ec 04             	sub    $0x4,%esp
f011bc53:	68 5c fa 12 f0       	push   $0xf012fa5c
f011bc58:	68 65 06 00 00       	push   $0x665
f011bc5d:	68 73 d4 12 f0       	push   $0xf012d473
f011bc62:	e8 d2 46 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011bc67:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011bc6d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bc70:	c1 ea 0c             	shr    $0xc,%edx
f011bc73:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011bc79:	c1 e2 02             	shl    $0x2,%edx
f011bc7c:	01 d0                	add    %edx,%eax
f011bc7e:	8b 00                	mov    (%eax),%eax
f011bc80:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bc85:	89 c2                	mov    %eax,%edx
f011bc87:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bc8a:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bc8f:	01 d0                	add    %edx,%eax
f011bc91:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011bc97:	74 1d                	je     f011bcb6 <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011bc99:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bc9d:	74 17                	je     f011bcb6 <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011bc9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bca6:	83 ec 0c             	sub    $0xc,%esp
f011bca9:	68 bc fa 12 f0       	push   $0xf012fabc
f011bcae:	e8 d8 52 fe ff       	call   f0100f8b <cprintf>
f011bcb3:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011bcb6:	ff 45 d0             	incl   -0x30(%ebp)
f011bcb9:	83 ec 0c             	sub    $0xc,%esp
f011bcbc:	6a 00                	push   $0x0
f011bcbe:	e8 d9 d9 fe ff       	call   f010969c <sbrk>
f011bcc3:	83 c4 10             	add    $0x10,%esp
f011bcc6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011bcc9:	0f 87 3b ff ff ff    	ja     f011bc0a <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011bccf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bcd3:	74 04                	je     f011bcd9 <test_kheap_phys_addr+0xc67>
f011bcd5:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011bcd9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011bce0:	83 ec 0c             	sub    $0xc,%esp
f011bce3:	68 e0 fa 12 f0       	push   $0xf012fae0
f011bce8:	e8 9e 52 fe ff       	call   f0100f8b <cprintf>
f011bced:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011bcf0:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011bcf7:	10 00 f9 
		i = 0;
f011bcfa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011bd01:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bd07:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011bd0a:	eb 0a                	jmp    f011bd16 <test_kheap_phys_addr+0xca4>
		{
			i++;
f011bd0c:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011bd0f:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011bd16:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011bd1d:	76 ed                	jbe    f011bd0c <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011bd1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bd22:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011bd28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011bd2f:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bd35:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011bd38:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011bd3f:	e9 cb 00 00 00       	jmp    f011be0f <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011bd44:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011bd47:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011bd4c:	83 ec 04             	sub    $0x4,%esp
f011bd4f:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011bd55:	51                   	push   %ecx
f011bd56:	52                   	push   %edx
f011bd57:	50                   	push   %eax
f011bd58:	e8 bd c9 fe ff       	call   f010871a <get_page_table>
f011bd5d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bd60:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011bd66:	85 c0                	test   %eax,%eax
f011bd68:	75 24                	jne    f011bd8e <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011bd6a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bd6e:	74 1e                	je     f011bd8e <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bd70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd77:	83 ec 04             	sub    $0x4,%esp
f011bd7a:	68 1c fb 12 f0       	push   $0xf012fb1c
f011bd7f:	68 87 06 00 00       	push   $0x687
f011bd84:	68 73 d4 12 f0       	push   $0xf012d473
f011bd89:	e8 ab 45 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011bd8e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011bd95:	eb 59                	jmp    f011bdf0 <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011bd97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bd9a:	c1 e0 0c             	shl    $0xc,%eax
f011bd9d:	89 c2                	mov    %eax,%edx
f011bd9f:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bda5:	01 d0                	add    %edx,%eax
f011bda7:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011bdad:	83 ec 0c             	sub    $0xc,%esp
f011bdb0:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011bdb6:	e8 fa dd fe ff       	call   f0109bb5 <kheap_physical_address>
f011bdbb:	83 c4 10             	add    $0x10,%esp
f011bdbe:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011bdc4:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011bdcb:	74 1d                	je     f011bdea <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011bdcd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bdd1:	74 17                	je     f011bdea <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011bdd3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bdda:	83 ec 0c             	sub    $0xc,%esp
f011bddd:	68 7c fb 12 f0       	push   $0xf012fb7c
f011bde2:	e8 a4 51 fe ff       	call   f0100f8b <cprintf>
f011bde7:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011bdea:	ff 45 c8             	incl   -0x38(%ebp)
f011bded:	ff 45 f4             	incl   -0xc(%ebp)
f011bdf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bdf3:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011bdf9:	7d 09                	jge    f011be04 <test_kheap_phys_addr+0xd92>
f011bdfb:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011be02:	7e 93                	jle    f011bd97 <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011be04:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011be0b:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011be0f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011be13:	0f 88 2b ff ff ff    	js     f011bd44 <test_kheap_phys_addr+0xcd2>
f011be19:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011be1d:	7f 0d                	jg     f011be2c <test_kheap_phys_addr+0xdba>
f011be1f:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011be26:	0f 86 18 ff ff ff    	jbe    f011bd44 <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011be2c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011be30:	74 04                	je     f011be36 <test_kheap_phys_addr+0xdc4>
f011be32:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011be36:	83 ec 08             	sub    $0x8,%esp
f011be39:	ff 75 f0             	pushl  -0x10(%ebp)
f011be3c:	68 a0 fb 12 f0       	push   $0xf012fba0
f011be41:	e8 45 51 fe ff       	call   f0100f8b <cprintf>
f011be46:	83 c4 10             	add    $0x10,%esp

	return 1;
f011be49:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011be4e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011be51:	5b                   	pop    %ebx
f011be52:	5f                   	pop    %edi
f011be53:	5d                   	pop    %ebp
f011be54:	c3                   	ret    

f011be55 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011be55:	55                   	push   %ebp
f011be56:	89 e5                	mov    %esp,%ebp
f011be58:	57                   	push   %edi
f011be59:	56                   	push   %esi
f011be5a:	53                   	push   %ebx
f011be5b:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011be61:	89 e0                	mov    %esp,%eax
f011be63:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011be65:	83 ec 0c             	sub    $0xc,%esp
f011be68:	68 28 b5 12 f0       	push   $0xf012b528
f011be6d:	e8 19 51 fe ff       	call   f0100f8b <cprintf>
f011be72:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011be75:	83 ec 0c             	sub    $0xc,%esp
f011be78:	68 58 b5 12 f0       	push   $0xf012b558
f011be7d:	e8 09 51 fe ff       	call   f0100f8b <cprintf>
f011be82:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011be85:	83 ec 0c             	sub    $0xc,%esp
f011be88:	68 28 b5 12 f0       	push   $0xf012b528
f011be8d:	e8 f9 50 fe ff       	call   f0100f8b <cprintf>
f011be92:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011be95:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011be99:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011be9d:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011bea3:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011bea9:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011beb0:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011beb7:	e8 8c 2d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011bebc:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011bebf:	83 ec 0c             	sub    $0xc,%esp
f011bec2:	68 7c f2 12 f0       	push   $0xf012f27c
f011bec7:	e8 bf 50 fe ff       	call   f0100f8b <cprintf>
f011becc:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011becf:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011bed5:	b9 14 00 00 00       	mov    $0x14,%ecx
f011beda:	b8 00 00 00 00       	mov    $0x0,%eax
f011bedf:	89 d7                	mov    %edx,%edi
f011bee1:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011bee3:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011bee9:	b9 14 00 00 00       	mov    $0x14,%ecx
f011beee:	b8 00 00 00 00       	mov    $0x0,%eax
f011bef3:	89 d7                	mov    %edx,%edi
f011bef5:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011bef7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011befe:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011bf05:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011bf0b:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bf10:	b8 00 00 00 00       	mov    $0x0,%eax
f011bf15:	89 d7                	mov    %edx,%edi
f011bf17:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bf19:	e8 2a 2d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011bf1e:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bf21:	e8 6d 8b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011bf26:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011bf29:	83 ec 0c             	sub    $0xc,%esp
f011bf2c:	68 00 fc 1f 00       	push   $0x1ffc00
f011bf31:	e8 99 d8 fe ff       	call   f01097cf <kmalloc>
f011bf36:	83 c4 10             	add    $0x10,%esp
f011bf39:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bf3f:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bf45:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011bf4a:	74 17                	je     f011bf63 <test_kheap_virt_addr+0x10e>
f011bf4c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf53:	83 ec 0c             	sub    $0xc,%esp
f011bf56:	68 20 d6 12 f0       	push   $0xf012d620
f011bf5b:	e8 2b 50 fe ff       	call   f0100f8b <cprintf>
f011bf60:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf63:	e8 2b 8b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011bf68:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bf6b:	74 17                	je     f011bf84 <test_kheap_virt_addr+0x12f>
f011bf6d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf74:	83 ec 0c             	sub    $0xc,%esp
f011bf77:	68 74 d6 12 f0       	push   $0xf012d674
f011bf7c:	e8 0a 50 fe ff       	call   f0100f8b <cprintf>
f011bf81:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bf84:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bf87:	e8 bc 2c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011bf8c:	29 c3                	sub    %eax,%ebx
f011bf8e:	89 d8                	mov    %ebx,%eax
f011bf90:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bf95:	77 17                	ja     f011bfae <test_kheap_virt_addr+0x159>
f011bf97:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf9e:	83 ec 0c             	sub    $0xc,%esp
f011bfa1:	68 e4 d6 12 f0       	push   $0xf012d6e4
f011bfa6:	e8 e0 4f fe ff       	call   f0100f8b <cprintf>
f011bfab:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bfae:	e8 95 2c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011bfb3:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bfb6:	e8 d8 8a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011bfbb:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011bfbe:	83 ec 0c             	sub    $0xc,%esp
f011bfc1:	68 00 fc 1f 00       	push   $0x1ffc00
f011bfc6:	e8 04 d8 fe ff       	call   f01097cf <kmalloc>
f011bfcb:	83 c4 10             	add    $0x10,%esp
f011bfce:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bfd4:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bfda:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011bfdf:	74 17                	je     f011bff8 <test_kheap_virt_addr+0x1a3>
f011bfe1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfe8:	83 ec 0c             	sub    $0xc,%esp
f011bfeb:	68 2c d7 12 f0       	push   $0xf012d72c
f011bff0:	e8 96 4f fe ff       	call   f0100f8b <cprintf>
f011bff5:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bff8:	e8 96 8a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011bffd:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c000:	74 17                	je     f011c019 <test_kheap_virt_addr+0x1c4>
f011c002:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c009:	83 ec 0c             	sub    $0xc,%esp
f011c00c:	68 80 d7 12 f0       	push   $0xf012d780
f011c011:	e8 75 4f fe ff       	call   f0100f8b <cprintf>
f011c016:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c019:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c01c:	e8 27 2c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c021:	29 c3                	sub    %eax,%ebx
f011c023:	89 d8                	mov    %ebx,%eax
f011c025:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c02a:	77 17                	ja     f011c043 <test_kheap_virt_addr+0x1ee>
f011c02c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c033:	83 ec 0c             	sub    $0xc,%esp
f011c036:	68 f0 d7 12 f0       	push   $0xf012d7f0
f011c03b:	e8 4b 4f fe ff       	call   f0100f8b <cprintf>
f011c040:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011c043:	e8 00 2c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c048:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c04b:	e8 43 8a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c050:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011c053:	83 ec 0c             	sub    $0xc,%esp
f011c056:	68 00 04 00 00       	push   $0x400
f011c05b:	e8 6f d7 fe ff       	call   f01097cf <kmalloc>
f011c060:	83 c4 10             	add    $0x10,%esp
f011c063:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011c069:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c06f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c074:	76 28                	jbe    f011c09e <test_kheap_virt_addr+0x249>
f011c076:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011c07c:	83 ec 0c             	sub    $0xc,%esp
f011c07f:	6a 00                	push   $0x0
f011c081:	e8 16 d6 fe ff       	call   f010969c <sbrk>
f011c086:	83 c4 10             	add    $0x10,%esp
f011c089:	39 c3                	cmp    %eax,%ebx
f011c08b:	73 11                	jae    f011c09e <test_kheap_virt_addr+0x249>
f011c08d:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c093:	89 c2                	mov    %eax,%edx
f011c095:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c09a:	39 c2                	cmp    %eax,%edx
f011c09c:	72 17                	jb     f011c0b5 <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c09e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0a5:	83 ec 0c             	sub    $0xc,%esp
f011c0a8:	68 ac f2 12 f0       	push   $0xf012f2ac
f011c0ad:	e8 d9 4e fe ff       	call   f0100f8b <cprintf>
f011c0b2:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c0b5:	e8 d9 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c0ba:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c0bd:	74 17                	je     f011c0d6 <test_kheap_virt_addr+0x281>
f011c0bf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0c6:	83 ec 0c             	sub    $0xc,%esp
f011c0c9:	68 8c d8 12 f0       	push   $0xf012d88c
f011c0ce:	e8 b8 4e fe ff       	call   f0100f8b <cprintf>
f011c0d3:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c0d6:	e8 6d 2b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c0db:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c0de:	e8 b0 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c0e3:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011c0e6:	83 ec 0c             	sub    $0xc,%esp
f011c0e9:	68 00 08 00 00       	push   $0x800
f011c0ee:	e8 dc d6 fe ff       	call   f01097cf <kmalloc>
f011c0f3:	83 c4 10             	add    $0x10,%esp
f011c0f6:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011c0fc:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c102:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c107:	76 28                	jbe    f011c131 <test_kheap_virt_addr+0x2dc>
f011c109:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011c10f:	83 ec 0c             	sub    $0xc,%esp
f011c112:	6a 00                	push   $0x0
f011c114:	e8 83 d5 fe ff       	call   f010969c <sbrk>
f011c119:	83 c4 10             	add    $0x10,%esp
f011c11c:	39 c3                	cmp    %eax,%ebx
f011c11e:	73 11                	jae    f011c131 <test_kheap_virt_addr+0x2dc>
f011c120:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c126:	89 c2                	mov    %eax,%edx
f011c128:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c12d:	39 c2                	cmp    %eax,%edx
f011c12f:	72 17                	jb     f011c148 <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c131:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c138:	83 ec 0c             	sub    $0xc,%esp
f011c13b:	68 38 f3 12 f0       	push   $0xf012f338
f011c140:	e8 46 4e fe ff       	call   f0100f8b <cprintf>
f011c145:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c148:	e8 46 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c14d:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c150:	74 17                	je     f011c169 <test_kheap_virt_addr+0x314>
f011c152:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c159:	83 ec 0c             	sub    $0xc,%esp
f011c15c:	68 98 d9 12 f0       	push   $0xf012d998
f011c161:	e8 25 4e fe ff       	call   f0100f8b <cprintf>
f011c166:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011c169:	e8 da 2a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c16e:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c171:	e8 1d 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c176:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011c179:	83 ec 0c             	sub    $0xc,%esp
f011c17c:	68 00 06 00 00       	push   $0x600
f011c181:	e8 49 d6 fe ff       	call   f01097cf <kmalloc>
f011c186:	83 c4 10             	add    $0x10,%esp
f011c189:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011c18f:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c195:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c19a:	76 28                	jbe    f011c1c4 <test_kheap_virt_addr+0x36f>
f011c19c:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011c1a2:	83 ec 0c             	sub    $0xc,%esp
f011c1a5:	6a 00                	push   $0x0
f011c1a7:	e8 f0 d4 fe ff       	call   f010969c <sbrk>
f011c1ac:	83 c4 10             	add    $0x10,%esp
f011c1af:	39 c3                	cmp    %eax,%ebx
f011c1b1:	73 11                	jae    f011c1c4 <test_kheap_virt_addr+0x36f>
f011c1b3:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c1b9:	89 c2                	mov    %eax,%edx
f011c1bb:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c1c0:	39 c2                	cmp    %eax,%edx
f011c1c2:	72 17                	jb     f011c1db <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c1c4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c1cb:	83 ec 0c             	sub    $0xc,%esp
f011c1ce:	68 c4 f3 12 f0       	push   $0xf012f3c4
f011c1d3:	e8 b3 4d fe ff       	call   f0100f8b <cprintf>
f011c1d8:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c1db:	e8 b3 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c1e0:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c1e3:	74 17                	je     f011c1fc <test_kheap_virt_addr+0x3a7>
f011c1e5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c1ec:	83 ec 0c             	sub    $0xc,%esp
f011c1ef:	68 a4 da 12 f0       	push   $0xf012daa4
f011c1f4:	e8 92 4d fe ff       	call   f0100f8b <cprintf>
f011c1f9:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011c1fc:	e8 47 2a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c201:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c204:	e8 8a 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c209:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011c20c:	83 ec 0c             	sub    $0xc,%esp
f011c20f:	68 00 1c 00 00       	push   $0x1c00
f011c214:	e8 b6 d5 fe ff       	call   f01097cf <kmalloc>
f011c219:	83 c4 10             	add    $0x10,%esp
f011c21c:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c222:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011c228:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011c22d:	74 17                	je     f011c246 <test_kheap_virt_addr+0x3f1>
f011c22f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c236:	83 ec 0c             	sub    $0xc,%esp
f011c239:	68 5c db 12 f0       	push   $0xf012db5c
f011c23e:	e8 48 4d fe ff       	call   f0100f8b <cprintf>
f011c243:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c246:	e8 48 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c24b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c24e:	74 17                	je     f011c267 <test_kheap_virt_addr+0x412>
f011c250:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c257:	83 ec 0c             	sub    $0xc,%esp
f011c25a:	68 b0 db 12 f0       	push   $0xf012dbb0
f011c25f:	e8 27 4d fe ff       	call   f0100f8b <cprintf>
f011c264:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c267:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c26a:	e8 d9 29 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c26f:	29 c3                	sub    %eax,%ebx
f011c271:	89 d8                	mov    %ebx,%eax
f011c273:	83 f8 01             	cmp    $0x1,%eax
f011c276:	77 17                	ja     f011c28f <test_kheap_virt_addr+0x43a>
f011c278:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c27f:	83 ec 0c             	sub    $0xc,%esp
f011c282:	68 20 dc 12 f0       	push   $0xf012dc20
f011c287:	e8 ff 4c fe ff       	call   f0100f8b <cprintf>
f011c28c:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011c28f:	e8 b4 29 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c294:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c297:	e8 f7 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c29c:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011c29f:	83 ec 0c             	sub    $0xc,%esp
f011c2a2:	68 00 fc 2f 00       	push   $0x2ffc00
f011c2a7:	e8 23 d5 fe ff       	call   f01097cf <kmalloc>
f011c2ac:	83 c4 10             	add    $0x10,%esp
f011c2af:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c2b5:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011c2bb:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011c2c0:	74 17                	je     f011c2d9 <test_kheap_virt_addr+0x484>
f011c2c2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2c9:	83 ec 0c             	sub    $0xc,%esp
f011c2cc:	68 50 f4 12 f0       	push   $0xf012f450
f011c2d1:	e8 b5 4c fe ff       	call   f0100f8b <cprintf>
f011c2d6:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c2d9:	e8 b5 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c2de:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c2e1:	74 17                	je     f011c2fa <test_kheap_virt_addr+0x4a5>
f011c2e3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2ea:	83 ec 0c             	sub    $0xc,%esp
f011c2ed:	68 f4 dc 12 f0       	push   $0xf012dcf4
f011c2f2:	e8 94 4c fe ff       	call   f0100f8b <cprintf>
f011c2f7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c2fa:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c2fd:	e8 46 29 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c302:	29 c3                	sub    %eax,%ebx
f011c304:	89 d8                	mov    %ebx,%eax
f011c306:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011c30b:	77 17                	ja     f011c324 <test_kheap_virt_addr+0x4cf>
f011c30d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c314:	83 ec 0c             	sub    $0xc,%esp
f011c317:	68 a4 f4 12 f0       	push   $0xf012f4a4
f011c31c:	e8 6a 4c fe ff       	call   f0100f8b <cprintf>
f011c321:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c324:	e8 1f 29 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c329:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c32c:	e8 62 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c331:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011c334:	83 ec 0c             	sub    $0xc,%esp
f011c337:	68 00 fc 5f 00       	push   $0x5ffc00
f011c33c:	e8 8e d4 fe ff       	call   f01097cf <kmalloc>
f011c341:	83 c4 10             	add    $0x10,%esp
f011c344:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c34a:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c350:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011c355:	74 17                	je     f011c36e <test_kheap_virt_addr+0x519>
f011c357:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c35e:	83 ec 0c             	sub    $0xc,%esp
f011c361:	68 ec f4 12 f0       	push   $0xf012f4ec
f011c366:	e8 20 4c fe ff       	call   f0100f8b <cprintf>
f011c36b:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c36e:	e8 20 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c373:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c376:	74 17                	je     f011c38f <test_kheap_virt_addr+0x53a>
f011c378:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c37f:	83 ec 0c             	sub    $0xc,%esp
f011c382:	68 f0 dd 12 f0       	push   $0xf012ddf0
f011c387:	e8 ff 4b fe ff       	call   f0100f8b <cprintf>
f011c38c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c38f:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c392:	e8 b1 28 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c397:	29 c3                	sub    %eax,%ebx
f011c399:	89 d8                	mov    %ebx,%eax
f011c39b:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c3a0:	77 17                	ja     f011c3b9 <test_kheap_virt_addr+0x564>
f011c3a2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3a9:	83 ec 0c             	sub    $0xc,%esp
f011c3ac:	68 40 f5 12 f0       	push   $0xf012f540
f011c3b1:	e8 d5 4b fe ff       	call   f0100f8b <cprintf>
f011c3b6:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011c3b9:	e8 8a 28 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c3be:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c3c1:	e8 cd 86 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c3c6:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011c3c9:	83 ec 0c             	sub    $0xc,%esp
f011c3cc:	68 00 38 00 00       	push   $0x3800
f011c3d1:	e8 f9 d3 fe ff       	call   f01097cf <kmalloc>
f011c3d6:	83 c4 10             	add    $0x10,%esp
f011c3d9:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c3df:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011c3e5:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011c3ea:	74 17                	je     f011c403 <test_kheap_virt_addr+0x5ae>
f011c3ec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3f3:	83 ec 0c             	sub    $0xc,%esp
f011c3f6:	68 88 f5 12 f0       	push   $0xf012f588
f011c3fb:	e8 8b 4b fe ff       	call   f0100f8b <cprintf>
f011c400:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c403:	e8 8b 86 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c408:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c40b:	74 17                	je     f011c424 <test_kheap_virt_addr+0x5cf>
f011c40d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c414:	83 ec 0c             	sub    $0xc,%esp
f011c417:	68 dc f5 12 f0       	push   $0xf012f5dc
f011c41c:	e8 6a 4b fe ff       	call   f0100f8b <cprintf>
f011c421:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c424:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c427:	e8 1c 28 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c42c:	29 c3                	sub    %eax,%ebx
f011c42e:	89 d8                	mov    %ebx,%eax
f011c430:	83 f8 03             	cmp    $0x3,%eax
f011c433:	77 17                	ja     f011c44c <test_kheap_virt_addr+0x5f7>
f011c435:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c43c:	83 ec 0c             	sub    $0xc,%esp
f011c43f:	68 4c f6 12 f0       	push   $0xf012f64c
f011c444:	e8 42 4b fe ff       	call   f0100f8b <cprintf>
f011c449:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011c44c:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011c453:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c456:	c1 e8 0c             	shr    $0xc,%eax
f011c459:	89 c2                	mov    %eax,%edx
f011c45b:	4a                   	dec    %edx
f011c45c:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011c45f:	c1 e0 02             	shl    $0x2,%eax
f011c462:	8d 50 03             	lea    0x3(%eax),%edx
f011c465:	b8 10 00 00 00       	mov    $0x10,%eax
f011c46a:	48                   	dec    %eax
f011c46b:	01 d0                	add    %edx,%eax
f011c46d:	bf 10 00 00 00       	mov    $0x10,%edi
f011c472:	ba 00 00 00 00       	mov    $0x0,%edx
f011c477:	f7 f7                	div    %edi
f011c479:	6b c0 10             	imul   $0x10,%eax,%eax
f011c47c:	29 c4                	sub    %eax,%esp
f011c47e:	89 e0                	mov    %esp,%eax
f011c480:	83 c0 03             	add    $0x3,%eax
f011c483:	c1 e8 02             	shr    $0x2,%eax
f011c486:	c1 e0 02             	shl    $0x2,%eax
f011c489:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011c48c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c48f:	c1 e8 0c             	shr    $0xc,%eax
f011c492:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011c495:	83 ec 0c             	sub    $0xc,%esp
f011c498:	68 d4 fb 12 f0       	push   $0xf012fbd4
f011c49d:	e8 e9 4a fe ff       	call   f0100f8b <cprintf>
f011c4a2:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c4a5:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c4ac:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c4b1:	05 00 10 00 00       	add    $0x1000,%eax
f011c4b6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011c4b9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c4c0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c4c3:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c4c6:	e9 2d 01 00 00       	jmp    f011c5f8 <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c4cb:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011c4d0:	83 ec 04             	sub    $0x4,%esp
f011c4d3:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c4d9:	52                   	push   %edx
f011c4da:	ff 75 dc             	pushl  -0x24(%ebp)
f011c4dd:	50                   	push   %eax
f011c4de:	e8 37 c2 fe ff       	call   f010871a <get_page_table>
f011c4e3:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c4e6:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c4ec:	85 c0                	test   %eax,%eax
f011c4ee:	75 1e                	jne    f011c50e <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c4f0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4f7:	83 ec 04             	sub    $0x4,%esp
f011c4fa:	68 e0 f6 12 f0       	push   $0xf012f6e0
f011c4ff:	68 26 07 00 00       	push   $0x726
f011c504:	68 73 d4 12 f0       	push   $0xf012d473
f011c509:	e8 2b 3e fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c50e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c511:	c1 e8 0c             	shr    $0xc,%eax
f011c514:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c519:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c51c:	e9 ba 00 00 00       	jmp    f011c5db <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011c521:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c524:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011c527:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c52d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c530:	c1 e2 02             	shl    $0x2,%edx
f011c533:	01 d0                	add    %edx,%eax
f011c535:	8b 00                	mov    (%eax),%eax
f011c537:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c53c:	89 c2                	mov    %eax,%edx
f011c53e:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c541:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c544:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c547:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c54a:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c54d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c550:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c553:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c556:	83 ec 0c             	sub    $0xc,%esp
f011c559:	50                   	push   %eax
f011c55a:	e8 b3 d6 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c55f:	83 c4 10             	add    $0x10,%esp
f011c562:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011c565:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c568:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c56b:	01 d0                	add    %edx,%eax
f011c56d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c570:	74 5c                	je     f011c5ce <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011c572:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c576:	74 56                	je     f011c5ce <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011c578:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c57b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c57e:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c581:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011c587:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011c58a:	c1 e1 02             	shl    $0x2,%ecx
f011c58d:	01 ca                	add    %ecx,%edx
f011c58f:	8b 12                	mov    (%edx),%edx
f011c591:	89 d1                	mov    %edx,%ecx
f011c593:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011c599:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011c59c:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c59f:	01 da                	add    %ebx,%edx
f011c5a1:	83 ec 0c             	sub    $0xc,%esp
f011c5a4:	50                   	push   %eax
f011c5a5:	51                   	push   %ecx
f011c5a6:	52                   	push   %edx
f011c5a7:	ff 75 8c             	pushl  -0x74(%ebp)
f011c5aa:	68 20 fc 12 f0       	push   $0xf012fc20
f011c5af:	e8 d7 49 fe ff       	call   f0100f8b <cprintf>
f011c5b4:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011c5b7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5be:	83 ec 0c             	sub    $0xc,%esp
f011c5c1:	68 64 fc 12 f0       	push   $0xf012fc64
f011c5c6:	e8 c0 49 fe ff       	call   f0100f8b <cprintf>
f011c5cb:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011c5ce:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c5d5:	ff 45 d4             	incl   -0x2c(%ebp)
f011c5d8:	ff 45 d8             	incl   -0x28(%ebp)
f011c5db:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c5de:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011c5e1:	7d 15                	jge    f011c5f8 <test_kheap_virt_addr+0x7a3>
f011c5e3:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011c5ea:	7f 0c                	jg     f011c5f8 <test_kheap_virt_addr+0x7a3>
f011c5ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c5ef:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c5f2:	0f 82 29 ff ff ff    	jb     f011c521 <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c5f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c5fb:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c5fe:	0f 82 c7 fe ff ff    	jb     f011c4cb <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c604:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c608:	74 04                	je     f011c60e <test_kheap_virt_addr+0x7b9>
f011c60a:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c60e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011c615:	83 ec 0c             	sub    $0xc,%esp
f011c618:	68 88 fc 12 f0       	push   $0xf012fc88
f011c61d:	e8 69 49 fe ff       	call   f0100f8b <cprintf>
f011c622:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c625:	e8 1e 26 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c62a:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c62d:	e8 61 84 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c632:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c635:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c63b:	83 ec 0c             	sub    $0xc,%esp
f011c63e:	50                   	push   %eax
f011c63f:	e8 4b d4 fe ff       	call   f0109a8f <kfree>
f011c644:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c647:	e8 47 84 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c64c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c64f:	74 17                	je     f011c668 <test_kheap_virt_addr+0x813>
f011c651:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c658:	83 ec 0c             	sub    $0xc,%esp
f011c65b:	68 b0 fc 12 f0       	push   $0xf012fcb0
f011c660:	e8 26 49 fe ff       	call   f0100f8b <cprintf>
f011c665:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c668:	e8 db 25 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c66d:	89 c2                	mov    %eax,%edx
f011c66f:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c672:	29 c2                	sub    %eax,%edx
f011c674:	89 d0                	mov    %edx,%eax
f011c676:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c67b:	77 17                	ja     f011c694 <test_kheap_virt_addr+0x83f>
f011c67d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c684:	83 ec 0c             	sub    $0xc,%esp
f011c687:	68 20 fd 12 f0       	push   $0xf012fd20
f011c68c:	e8 fa 48 fe ff       	call   f0100f8b <cprintf>
f011c691:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c694:	e8 af 25 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c699:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c69c:	e8 f2 83 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c6a1:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c6a4:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c6aa:	83 ec 0c             	sub    $0xc,%esp
f011c6ad:	50                   	push   %eax
f011c6ae:	e8 dc d3 fe ff       	call   f0109a8f <kfree>
f011c6b3:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c6b6:	e8 d8 83 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c6bb:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c6be:	74 17                	je     f011c6d7 <test_kheap_virt_addr+0x882>
f011c6c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6c7:	83 ec 0c             	sub    $0xc,%esp
f011c6ca:	68 5c fd 12 f0       	push   $0xf012fd5c
f011c6cf:	e8 b7 48 fe ff       	call   f0100f8b <cprintf>
f011c6d4:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c6d7:	e8 6c 25 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c6dc:	89 c2                	mov    %eax,%edx
f011c6de:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c6e1:	29 c2                	sub    %eax,%edx
f011c6e3:	89 d0                	mov    %edx,%eax
f011c6e5:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c6ea:	77 17                	ja     f011c703 <test_kheap_virt_addr+0x8ae>
f011c6ec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6f3:	83 ec 0c             	sub    $0xc,%esp
f011c6f6:	68 cc fd 12 f0       	push   $0xf012fdcc
f011c6fb:	e8 8b 48 fe ff       	call   f0100f8b <cprintf>
f011c700:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c703:	e8 40 25 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c708:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c70b:	e8 83 83 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c710:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c713:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c719:	83 ec 0c             	sub    $0xc,%esp
f011c71c:	50                   	push   %eax
f011c71d:	e8 6d d3 fe ff       	call   f0109a8f <kfree>
f011c722:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c725:	e8 69 83 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c72a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c72d:	74 17                	je     f011c746 <test_kheap_virt_addr+0x8f1>
f011c72f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c736:	83 ec 0c             	sub    $0xc,%esp
f011c739:	68 08 fe 12 f0       	push   $0xf012fe08
f011c73e:	e8 48 48 fe ff       	call   f0100f8b <cprintf>
f011c743:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c746:	e8 fd 24 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c74b:	89 c2                	mov    %eax,%edx
f011c74d:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c750:	29 c2                	sub    %eax,%edx
f011c752:	89 d0                	mov    %edx,%eax
f011c754:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c759:	77 17                	ja     f011c772 <test_kheap_virt_addr+0x91d>
f011c75b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c762:	83 ec 0c             	sub    $0xc,%esp
f011c765:	68 78 fe 12 f0       	push   $0xf012fe78
f011c76a:	e8 1c 48 fe ff       	call   f0100f8b <cprintf>
f011c76f:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011c772:	83 ec 0c             	sub    $0xc,%esp
f011c775:	68 b4 fe 12 f0       	push   $0xf012feb4
f011c77a:	e8 0c 48 fe ff       	call   f0100f8b <cprintf>
f011c77f:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c782:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c789:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c78e:	05 00 10 00 00       	add    $0x1000,%eax
f011c793:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011c799:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011c7a0:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011c7a7:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c7aa:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c7b0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c7b3:	eb 44                	jmp    f011c7f9 <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c7b5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c7b8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c7bb:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c7be:	83 ec 0c             	sub    $0xc,%esp
f011c7c1:	50                   	push   %eax
f011c7c2:	e8 4b d4 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c7c7:	83 c4 10             	add    $0x10,%esp
f011c7ca:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011c7d0:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011c7d7:	74 1d                	je     f011c7f6 <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011c7d9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c7dd:	74 17                	je     f011c7f6 <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011c7df:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7e6:	83 ec 0c             	sub    $0xc,%esp
f011c7e9:	68 04 ff 12 f0       	push   $0xf012ff04
f011c7ee:	e8 98 47 fe ff       	call   f0100f8b <cprintf>
f011c7f3:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c7f6:	ff 45 d0             	incl   -0x30(%ebp)
f011c7f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c7ff:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011c805:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c808:	39 c2                	cmp    %eax,%edx
f011c80a:	77 a9                	ja     f011c7b5 <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c80c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c812:	05 00 04 00 00       	add    $0x400,%eax
f011c817:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c81a:	eb 64                	jmp    f011c880 <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c81c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c81f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c822:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c825:	83 ec 0c             	sub    $0xc,%esp
f011c828:	50                   	push   %eax
f011c829:	e8 e4 d3 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c82e:	83 c4 10             	add    $0x10,%esp
f011c831:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c837:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c83a:	c1 e0 0c             	shl    $0xc,%eax
f011c83d:	89 c2                	mov    %eax,%edx
f011c83f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c845:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c848:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c84b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c84e:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c851:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c856:	01 c8                	add    %ecx,%eax
f011c858:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011c85e:	74 1d                	je     f011c87d <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011c860:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c864:	74 17                	je     f011c87d <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011c866:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c86d:	83 ec 0c             	sub    $0xc,%esp
f011c870:	68 28 ff 12 f0       	push   $0xf012ff28
f011c875:	e8 11 47 fe ff       	call   f0100f8b <cprintf>
f011c87a:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c87d:	ff 45 d0             	incl   -0x30(%ebp)
f011c880:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c886:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011c88c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c88f:	39 c2                	cmp    %eax,%edx
f011c891:	77 89                	ja     f011c81c <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c893:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c899:	05 02 07 00 00       	add    $0x702,%eax
f011c89e:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c8a1:	eb 44                	jmp    f011c8e7 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c8a3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c8a6:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c8a9:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c8ac:	83 ec 0c             	sub    $0xc,%esp
f011c8af:	50                   	push   %eax
f011c8b0:	e8 5d d3 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c8b5:	83 c4 10             	add    $0x10,%esp
f011c8b8:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011c8be:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011c8c5:	74 1d                	je     f011c8e4 <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011c8c7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c8cb:	74 17                	je     f011c8e4 <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011c8cd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8d4:	83 ec 0c             	sub    $0xc,%esp
f011c8d7:	68 4c ff 12 f0       	push   $0xf012ff4c
f011c8dc:	e8 aa 46 fe ff       	call   f0100f8b <cprintf>
f011c8e1:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c8e4:	ff 45 d0             	incl   -0x30(%ebp)
f011c8e7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c8ed:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011c8f3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c8f6:	39 c2                	cmp    %eax,%edx
f011c8f8:	77 a9                	ja     f011c8a3 <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c8fa:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c900:	05 02 0d 00 00       	add    $0xd02,%eax
f011c905:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c908:	eb 64                	jmp    f011c96e <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c90a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c90d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c910:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c913:	83 ec 0c             	sub    $0xc,%esp
f011c916:	50                   	push   %eax
f011c917:	e8 f6 d2 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c91c:	83 c4 10             	add    $0x10,%esp
f011c91f:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c925:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c928:	c1 e0 0c             	shl    $0xc,%eax
f011c92b:	89 c2                	mov    %eax,%edx
f011c92d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c933:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c936:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c939:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c93c:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c93f:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c944:	01 c8                	add    %ecx,%eax
f011c946:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011c94c:	74 1d                	je     f011c96b <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011c94e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c952:	74 17                	je     f011c96b <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011c954:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c95b:	83 ec 0c             	sub    $0xc,%esp
f011c95e:	68 70 ff 12 f0       	push   $0xf012ff70
f011c963:	e8 23 46 fe ff       	call   f0100f8b <cprintf>
f011c968:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c96b:	ff 45 d0             	incl   -0x30(%ebp)
f011c96e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c974:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011c97a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c97d:	39 c2                	cmp    %eax,%edx
f011c97f:	77 89                	ja     f011c90a <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011c981:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c985:	74 04                	je     f011c98b <test_kheap_virt_addr+0xb36>
f011c987:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c98b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011c992:	83 ec 0c             	sub    $0xc,%esp
f011c995:	68 94 ff 12 f0       	push   $0xf012ff94
f011c99a:	e8 ec 45 fe ff       	call   f0100f8b <cprintf>
f011c99f:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011c9a2:	83 ec 0c             	sub    $0xc,%esp
f011c9a5:	6a 00                	push   $0x0
f011c9a7:	e8 f0 cc fe ff       	call   f010969c <sbrk>
f011c9ac:	83 c4 10             	add    $0x10,%esp
f011c9af:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011c9b4:	77 17                	ja     f011c9cd <test_kheap_virt_addr+0xb78>
f011c9b6:	83 ec 04             	sub    $0x4,%esp
f011c9b9:	68 db ff 12 f0       	push   $0xf012ffdb
f011c9be:	68 91 07 00 00       	push   $0x791
f011c9c3:	68 73 d4 12 f0       	push   $0xf012d473
f011c9c8:	e8 6c 39 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c9cd:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011c9d4:	e9 d1 00 00 00       	jmp    f011caaa <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c9d9:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011c9de:	83 ec 04             	sub    $0x4,%esp
f011c9e1:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c9e7:	52                   	push   %edx
f011c9e8:	ff 75 cc             	pushl  -0x34(%ebp)
f011c9eb:	50                   	push   %eax
f011c9ec:	e8 29 bd fe ff       	call   f010871a <get_page_table>
f011c9f1:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c9f4:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c9fa:	85 c0                	test   %eax,%eax
f011c9fc:	75 1e                	jne    f011ca1c <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c9fe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca05:	83 ec 04             	sub    $0x4,%esp
f011ca08:	68 64 f9 12 f0       	push   $0xf012f964
f011ca0d:	68 97 07 00 00       	push   $0x797
f011ca12:	68 73 d4 12 f0       	push   $0xf012d473
f011ca17:	e8 1d 39 fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011ca1c:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011ca22:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011ca25:	c1 ea 0c             	shr    $0xc,%edx
f011ca28:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011ca2e:	c1 e2 02             	shl    $0x2,%edx
f011ca31:	01 d0                	add    %edx,%eax
f011ca33:	8b 00                	mov    (%eax),%eax
f011ca35:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ca3a:	89 c2                	mov    %eax,%edx
f011ca3c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ca3f:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ca44:	01 d0                	add    %edx,%eax
f011ca46:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011ca4c:	83 ec 0c             	sub    $0xc,%esp
f011ca4f:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011ca55:	e8 b8 d1 fe ff       	call   f0109c12 <kheap_virtual_address>
f011ca5a:	83 c4 10             	add    $0x10,%esp
f011ca5d:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011ca63:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011ca69:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011ca6c:	74 39                	je     f011caa7 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011ca6e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ca72:	74 33                	je     f011caa7 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011ca74:	ff 75 cc             	pushl  -0x34(%ebp)
f011ca77:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011ca7d:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011ca83:	68 f4 ff 12 f0       	push   $0xf012fff4
f011ca88:	e8 fe 44 fe ff       	call   f0100f8b <cprintf>
f011ca8d:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011ca90:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca97:	83 ec 0c             	sub    $0xc,%esp
f011ca9a:	68 20 00 13 f0       	push   $0xf0130020
f011ca9f:	e8 e7 44 fe ff       	call   f0100f8b <cprintf>
f011caa4:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011caa7:	ff 45 cc             	incl   -0x34(%ebp)
f011caaa:	83 ec 0c             	sub    $0xc,%esp
f011caad:	6a 00                	push   $0x0
f011caaf:	e8 e8 cb fe ff       	call   f010969c <sbrk>
f011cab4:	83 c4 10             	add    $0x10,%esp
f011cab7:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011caba:	0f 87 19 ff ff ff    	ja     f011c9d9 <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011cac0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cac4:	74 04                	je     f011caca <test_kheap_virt_addr+0xc75>
f011cac6:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011caca:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011cad1:	83 ec 0c             	sub    $0xc,%esp
f011cad4:	68 44 00 13 f0       	push   $0xf0130044
f011cad9:	e8 ad 44 fe ff       	call   f0100f8b <cprintf>
f011cade:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011cae1:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011cae8:	eb 5a                	jmp    f011cb44 <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011caea:	83 ec 0c             	sub    $0xc,%esp
f011caed:	ff 75 c8             	pushl  -0x38(%ebp)
f011caf0:	e8 1d d1 fe ff       	call   f0109c12 <kheap_virtual_address>
f011caf5:	83 c4 10             	add    $0x10,%esp
f011caf8:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011cafe:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011cb05:	74 36                	je     f011cb3d <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011cb07:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cb0b:	74 30                	je     f011cb3d <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011cb0d:	83 ec 04             	sub    $0x4,%esp
f011cb10:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011cb16:	ff 75 c8             	pushl  -0x38(%ebp)
f011cb19:	68 83 00 13 f0       	push   $0xf0130083
f011cb1e:	e8 68 44 fe ff       	call   f0100f8b <cprintf>
f011cb23:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011cb26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb2d:	83 ec 0c             	sub    $0xc,%esp
f011cb30:	68 a0 00 13 f0       	push   $0xf01300a0
f011cb35:	e8 51 44 fe ff       	call   f0100f8b <cprintf>
f011cb3a:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011cb3d:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011cb44:	b8 d0 22 6b 02       	mov    $0x26b22d0,%eax
f011cb49:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011cb4c:	72 9c                	jb     f011caea <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011cb4e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cb52:	74 04                	je     f011cb58 <test_kheap_virt_addr+0xd03>
f011cb54:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011cb58:	83 ec 08             	sub    $0x8,%esp
f011cb5b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011cb5e:	68 c4 00 13 f0       	push   $0xf01300c4
f011cb63:	e8 23 44 fe ff       	call   f0100f8b <cprintf>
f011cb68:	83 c4 10             	add    $0x10,%esp

	return 1;
f011cb6b:	b8 01 00 00 00       	mov    $0x1,%eax
f011cb70:	89 f4                	mov    %esi,%esp

}
f011cb72:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011cb75:	5b                   	pop    %ebx
f011cb76:	5e                   	pop    %esi
f011cb77:	5f                   	pop    %edi
f011cb78:	5d                   	pop    %ebp
f011cb79:	c3                   	ret    

f011cb7a <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011cb7a:	55                   	push   %ebp
f011cb7b:	89 e5                	mov    %esp,%ebp
f011cb7d:	57                   	push   %edi
f011cb7e:	56                   	push   %esi
f011cb7f:	53                   	push   %ebx
f011cb80:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011cb86:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011cb8c:	b9 14 00 00 00       	mov    $0x14,%ecx
f011cb91:	b8 00 00 00 00       	mov    $0x0,%eax
f011cb96:	89 d7                	mov    %edx,%edi
f011cb98:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011cb9a:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011cba1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011cba8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011cbaf:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f011cbb4:	0f b6 c0             	movzbl %al,%eax
f011cbb7:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011cbba:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011cbc1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cbc4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011cbc7:	39 c2                	cmp    %eax,%edx
f011cbc9:	73 02                	jae    f011cbcd <test_ksbrk+0x53>
f011cbcb:	89 c2                	mov    %eax,%edx
f011cbcd:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f011cbd2:	0f b6 c0             	movzbl %al,%eax
f011cbd5:	c1 e0 04             	shl    $0x4,%eax
f011cbd8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011cbdb:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011cbe2:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011cbe5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011cbe8:	39 c8                	cmp    %ecx,%eax
f011cbea:	73 02                	jae    f011cbee <test_ksbrk+0x74>
f011cbec:	89 c8                	mov    %ecx,%eax
f011cbee:	01 d0                	add    %edx,%eax
f011cbf0:	83 c0 10             	add    $0x10,%eax
f011cbf3:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011cbf8:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011cbfb:	83 ec 0c             	sub    $0xc,%esp
f011cbfe:	68 f8 00 13 f0       	push   $0xf01300f8
f011cc03:	e8 83 43 fe ff       	call   f0100f8b <cprintf>
f011cc08:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011cc0b:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cc12:	e8 31 20 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cc17:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cc1a:	e8 74 7e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cc1f:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011cc22:	83 ec 10             	sub    $0x10,%esp
f011cc25:	89 e0                	mov    %esp,%eax
f011cc27:	89 c2                	mov    %eax,%edx
f011cc29:	bb b0 f1 b1 f0       	mov    $0xf0b1f1b0,%ebx
f011cc2e:	b8 04 00 00 00       	mov    $0x4,%eax
f011cc33:	89 d7                	mov    %edx,%edi
f011cc35:	89 de                	mov    %ebx,%esi
f011cc37:	89 c1                	mov    %eax,%ecx
f011cc39:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011cc3b:	e8 53 3e 00 00       	call   f0120a93 <print_blocks_list>
f011cc40:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011cc43:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cc46:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cc49:	29 c2                	sub    %eax,%edx
f011cc4b:	89 d0                	mov    %edx,%eax
f011cc4d:	83 ec 0c             	sub    $0xc,%esp
f011cc50:	50                   	push   %eax
f011cc51:	e8 79 cb fe ff       	call   f01097cf <kmalloc>
f011cc56:	83 c4 10             	add    $0x10,%esp
f011cc59:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011cc5f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cc62:	89 c2                	mov    %eax,%edx
f011cc64:	c1 ea 1f             	shr    $0x1f,%edx
f011cc67:	01 d0                	add    %edx,%eax
f011cc69:	d1 f8                	sar    %eax
f011cc6b:	89 c2                	mov    %eax,%edx
f011cc6d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011cc70:	01 d0                	add    %edx,%eax
f011cc72:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011cc75:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011cc7b:	6a 01                	push   $0x1
f011cc7d:	ff 75 b8             	pushl  -0x48(%ebp)
f011cc80:	ff 75 ac             	pushl  -0x54(%ebp)
f011cc83:	50                   	push   %eax
f011cc84:	e8 db 43 ff ff       	call   f0111064 <check_block>
f011cc89:	83 c4 10             	add    $0x10,%esp
f011cc8c:	85 c0                	test   %eax,%eax
f011cc8e:	75 17                	jne    f011cca7 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011cc90:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc97:	83 ec 0c             	sub    $0xc,%esp
f011cc9a:	68 49 01 13 f0       	push   $0xf0130149
f011cc9f:	e8 e7 42 fe ff       	call   f0100f8b <cprintf>
f011cca4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cca7:	e8 9c 1f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ccac:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ccaf:	74 17                	je     f011ccc8 <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011ccb1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ccb8:	83 ec 0c             	sub    $0xc,%esp
f011ccbb:	68 60 01 13 f0       	push   $0xf0130160
f011ccc0:	e8 c6 42 fe ff       	call   f0100f8b <cprintf>
f011ccc5:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ccc8:	e8 c6 7d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cccd:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ccd0:	74 17                	je     f011cce9 <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ccd2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ccd9:	83 ec 0c             	sub    $0xc,%esp
f011ccdc:	68 80 01 13 f0       	push   $0xf0130180
f011cce1:	e8 a5 42 fe ff       	call   f0100f8b <cprintf>
f011cce6:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011cce9:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f011ccee:	0f b6 c0             	movzbl %al,%eax
f011ccf1:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011ccf4:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011ccfb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011ccfe:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011cd01:	39 c2                	cmp    %eax,%edx
f011cd03:	73 02                	jae    f011cd07 <test_ksbrk+0x18d>
f011cd05:	89 c2                	mov    %eax,%edx
f011cd07:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f011cd0c:	0f b6 c0             	movzbl %al,%eax
f011cd0f:	c1 e0 04             	shl    $0x4,%eax
f011cd12:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011cd15:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011cd1c:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011cd1f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cd22:	39 c8                	cmp    %ecx,%eax
f011cd24:	73 02                	jae    f011cd28 <test_ksbrk+0x1ae>
f011cd26:	89 c8                	mov    %ecx,%eax
f011cd28:	01 d0                	add    %edx,%eax
f011cd2a:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011cd2f:	29 c2                	sub    %eax,%edx
f011cd31:	89 d0                	mov    %edx,%eax
f011cd33:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cd36:	e8 0d 1f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cd3b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cd3e:	e8 50 7d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cd43:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011cd46:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd49:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cd4c:	29 c2                	sub    %eax,%edx
f011cd4e:	89 d0                	mov    %edx,%eax
f011cd50:	83 ec 0c             	sub    $0xc,%esp
f011cd53:	50                   	push   %eax
f011cd54:	e8 76 ca fe ff       	call   f01097cf <kmalloc>
f011cd59:	83 c4 10             	add    $0x10,%esp
f011cd5c:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011cd62:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd65:	89 c2                	mov    %eax,%edx
f011cd67:	c1 ea 1f             	shr    $0x1f,%edx
f011cd6a:	01 d0                	add    %edx,%eax
f011cd6c:	d1 f8                	sar    %eax
f011cd6e:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011cd74:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011cd77:	01 d0                	add    %edx,%eax
f011cd79:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011cd7c:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011cd82:	6a 01                	push   $0x1
f011cd84:	ff 75 b8             	pushl  -0x48(%ebp)
f011cd87:	ff 75 ac             	pushl  -0x54(%ebp)
f011cd8a:	50                   	push   %eax
f011cd8b:	e8 d4 42 ff ff       	call   f0111064 <check_block>
f011cd90:	83 c4 10             	add    $0x10,%esp
f011cd93:	85 c0                	test   %eax,%eax
f011cd95:	75 17                	jne    f011cdae <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011cd97:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd9e:	83 ec 0c             	sub    $0xc,%esp
f011cda1:	68 ee 01 13 f0       	push   $0xf01301ee
f011cda6:	e8 e0 41 fe ff       	call   f0100f8b <cprintf>
f011cdab:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cdae:	e8 95 1e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cdb3:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cdb6:	74 17                	je     f011cdcf <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011cdb8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cdbf:	83 ec 0c             	sub    $0xc,%esp
f011cdc2:	68 08 02 13 f0       	push   $0xf0130208
f011cdc7:	e8 bf 41 fe ff       	call   f0100f8b <cprintf>
f011cdcc:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cdcf:	e8 bf 7c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cdd4:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cdd7:	74 17                	je     f011cdf0 <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cdd9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cde0:	83 ec 0c             	sub    $0xc,%esp
f011cde3:	68 28 02 13 f0       	push   $0xf0130228
f011cde8:	e8 9e 41 fe ff       	call   f0100f8b <cprintf>
f011cded:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011cdf0:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011cdf7:	e8 4c 1e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cdfc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cdff:	e8 8f 7c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ce04:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011ce07:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ce0a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ce0d:	29 c2                	sub    %eax,%edx
f011ce0f:	89 d0                	mov    %edx,%eax
f011ce11:	83 ec 0c             	sub    $0xc,%esp
f011ce14:	50                   	push   %eax
f011ce15:	e8 b5 c9 fe ff       	call   f01097cf <kmalloc>
f011ce1a:	83 c4 10             	add    $0x10,%esp
f011ce1d:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011ce23:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ce26:	89 c2                	mov    %eax,%edx
f011ce28:	c1 ea 1f             	shr    $0x1f,%edx
f011ce2b:	01 d0                	add    %edx,%eax
f011ce2d:	d1 f8                	sar    %eax
f011ce2f:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011ce34:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011ce37:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011ce3d:	6a 01                	push   $0x1
f011ce3f:	ff 75 b8             	pushl  -0x48(%ebp)
f011ce42:	ff 75 ac             	pushl  -0x54(%ebp)
f011ce45:	50                   	push   %eax
f011ce46:	e8 19 42 ff ff       	call   f0111064 <check_block>
f011ce4b:	83 c4 10             	add    $0x10,%esp
f011ce4e:	85 c0                	test   %eax,%eax
f011ce50:	75 17                	jne    f011ce69 <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011ce52:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce59:	83 ec 0c             	sub    $0xc,%esp
f011ce5c:	68 96 02 13 f0       	push   $0xf0130296
f011ce61:	e8 25 41 fe ff       	call   f0100f8b <cprintf>
f011ce66:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011ce69:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ce6c:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011ce6f:	b8 00 10 00 00       	mov    $0x1000,%eax
f011ce74:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011ce77:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011ce7a:	6a 00                	push   $0x0
f011ce7c:	ff 75 98             	pushl  -0x68(%ebp)
f011ce7f:	ff 75 ac             	pushl  -0x54(%ebp)
f011ce82:	ff 75 ac             	pushl  -0x54(%ebp)
f011ce85:	e8 da 41 ff ff       	call   f0111064 <check_block>
f011ce8a:	83 c4 10             	add    $0x10,%esp
f011ce8d:	85 c0                	test   %eax,%eax
f011ce8f:	75 17                	jne    f011cea8 <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011ce91:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce98:	83 ec 0c             	sub    $0xc,%esp
f011ce9b:	68 ad 02 13 f0       	push   $0xf01302ad
f011cea0:	e8 e6 40 fe ff       	call   f0100f8b <cprintf>
f011cea5:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011cea8:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011ceaf:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ceb2:	8b 00                	mov    (%eax),%eax
f011ceb4:	83 f8 01             	cmp    $0x1,%eax
f011ceb7:	74 17                	je     f011ced0 <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011ceb9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cec0:	83 ec 0c             	sub    $0xc,%esp
f011cec3:	68 c4 02 13 f0       	push   $0xf01302c4
f011cec8:	e8 be 40 fe ff       	call   f0100f8b <cprintf>
f011cecd:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011ced0:	83 ec 0c             	sub    $0xc,%esp
f011ced3:	6a 00                	push   $0x0
f011ced5:	e8 c2 c7 fe ff       	call   f010969c <sbrk>
f011ceda:	83 c4 10             	add    $0x10,%esp
f011cedd:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011cee0:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011cee7:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ceea:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011ceed:	74 1d                	je     f011cf0c <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011ceef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cef6:	83 ec 04             	sub    $0x4,%esp
f011cef9:	ff 75 90             	pushl  -0x70(%ebp)
f011cefc:	ff 75 8c             	pushl  -0x74(%ebp)
f011ceff:	68 f0 02 13 f0       	push   $0xf01302f0
f011cf04:	e8 82 40 fe ff       	call   f0100f8b <cprintf>
f011cf09:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cf0c:	e8 37 1d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cf11:	89 c2                	mov    %eax,%edx
f011cf13:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cf16:	29 d0                	sub    %edx,%eax
f011cf18:	83 f8 01             	cmp    $0x1,%eax
f011cf1b:	74 17                	je     f011cf34 <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011cf1d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf24:	83 ec 0c             	sub    $0xc,%esp
f011cf27:	68 24 03 13 f0       	push   $0xf0130324
f011cf2c:	e8 5a 40 fe ff       	call   f0100f8b <cprintf>
f011cf31:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cf34:	e8 5a 7b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cf39:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cf3c:	74 17                	je     f011cf55 <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cf3e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf45:	83 ec 0c             	sub    $0xc,%esp
f011cf48:	68 44 03 13 f0       	push   $0xf0130344
f011cf4d:	e8 39 40 fe ff       	call   f0100f8b <cprintf>
f011cf52:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011cf55:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cf5c:	e8 e7 1c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cf61:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cf64:	e8 2a 7b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cf69:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011cf6c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cf6f:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cf72:	29 c2                	sub    %eax,%edx
f011cf74:	89 d0                	mov    %edx,%eax
f011cf76:	83 ec 0c             	sub    $0xc,%esp
f011cf79:	50                   	push   %eax
f011cf7a:	e8 50 c8 fe ff       	call   f01097cf <kmalloc>
f011cf7f:	83 c4 10             	add    $0x10,%esp
f011cf82:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011cf88:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011cf8f:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011cf95:	6a 01                	push   $0x1
f011cf97:	ff 75 b8             	pushl  -0x48(%ebp)
f011cf9a:	ff 75 ac             	pushl  -0x54(%ebp)
f011cf9d:	50                   	push   %eax
f011cf9e:	e8 c1 40 ff ff       	call   f0111064 <check_block>
f011cfa3:	83 c4 10             	add    $0x10,%esp
f011cfa6:	85 c0                	test   %eax,%eax
f011cfa8:	75 17                	jne    f011cfc1 <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011cfaa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfb1:	83 ec 0c             	sub    $0xc,%esp
f011cfb4:	68 b3 03 13 f0       	push   $0xf01303b3
f011cfb9:	e8 cd 3f fe ff       	call   f0100f8b <cprintf>
f011cfbe:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cfc1:	e8 82 1c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cfc6:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cfc9:	74 17                	je     f011cfe2 <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011cfcb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfd2:	83 ec 0c             	sub    $0xc,%esp
f011cfd5:	68 cc 03 13 f0       	push   $0xf01303cc
f011cfda:	e8 ac 3f fe ff       	call   f0100f8b <cprintf>
f011cfdf:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cfe2:	e8 ac 7a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cfe7:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cfea:	74 17                	je     f011d003 <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cfec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cff3:	83 ec 0c             	sub    $0xc,%esp
f011cff6:	68 ec 03 13 f0       	push   $0xf01303ec
f011cffb:	e8 8b 3f fe ff       	call   f0100f8b <cprintf>
f011d000:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011d003:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d007:	74 04                	je     f011d00d <test_ksbrk+0x493>
		eval += 25;
f011d009:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011d00d:	83 ec 0c             	sub    $0xc,%esp
f011d010:	68 5c 04 13 f0       	push   $0xf013045c
f011d015:	e8 71 3f fe ff       	call   f0100f8b <cprintf>
f011d01a:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011d01d:	83 ec 0c             	sub    $0xc,%esp
f011d020:	6a 00                	push   $0x0
f011d022:	e8 75 c6 fe ff       	call   f010969c <sbrk>
f011d027:	83 c4 10             	add    $0x10,%esp
f011d02a:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011d02d:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d034:	e8 0f 1c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d039:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d03c:	e8 52 7a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d041:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011d044:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d047:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d04a:	29 c2                	sub    %eax,%edx
f011d04c:	89 d0                	mov    %edx,%eax
f011d04e:	83 ec 0c             	sub    $0xc,%esp
f011d051:	50                   	push   %eax
f011d052:	e8 78 c7 fe ff       	call   f01097cf <kmalloc>
f011d057:	83 c4 10             	add    $0x10,%esp
f011d05a:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011d060:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d063:	89 c2                	mov    %eax,%edx
f011d065:	c1 ea 1f             	shr    $0x1f,%edx
f011d068:	01 d0                	add    %edx,%eax
f011d06a:	d1 f8                	sar    %eax
f011d06c:	89 c2                	mov    %eax,%edx
f011d06e:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d071:	01 d0                	add    %edx,%eax
f011d073:	83 e8 04             	sub    $0x4,%eax
f011d076:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011d079:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011d07f:	6a 01                	push   $0x1
f011d081:	ff 75 b8             	pushl  -0x48(%ebp)
f011d084:	ff 75 ac             	pushl  -0x54(%ebp)
f011d087:	50                   	push   %eax
f011d088:	e8 d7 3f ff ff       	call   f0111064 <check_block>
f011d08d:	83 c4 10             	add    $0x10,%esp
f011d090:	85 c0                	test   %eax,%eax
f011d092:	75 17                	jne    f011d0ab <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011d094:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d09b:	83 ec 0c             	sub    $0xc,%esp
f011d09e:	68 bf 04 13 f0       	push   $0xf01304bf
f011d0a3:	e8 e3 3e fe ff       	call   f0100f8b <cprintf>
f011d0a8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d0ab:	e8 98 1b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d0b0:	89 c2                	mov    %eax,%edx
f011d0b2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d0b5:	29 d0                	sub    %edx,%eax
f011d0b7:	83 f8 01             	cmp    $0x1,%eax
f011d0ba:	74 17                	je     f011d0d3 <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011d0bc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d0c3:	83 ec 0c             	sub    $0xc,%esp
f011d0c6:	68 d8 04 13 f0       	push   $0xf01304d8
f011d0cb:	e8 bb 3e fe ff       	call   f0100f8b <cprintf>
f011d0d0:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d0d3:	e8 bb 79 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d0d8:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d0db:	74 17                	je     f011d0f4 <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d0dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d0e4:	83 ec 0c             	sub    $0xc,%esp
f011d0e7:	68 f8 04 13 f0       	push   $0xf01304f8
f011d0ec:	e8 9a 3e fe ff       	call   f0100f8b <cprintf>
f011d0f1:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011d0f4:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d0fb:	e8 48 1b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d100:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d103:	e8 8b 79 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d108:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011d10b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d10e:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d111:	29 c2                	sub    %eax,%edx
f011d113:	89 d0                	mov    %edx,%eax
f011d115:	83 ec 0c             	sub    $0xc,%esp
f011d118:	50                   	push   %eax
f011d119:	e8 b1 c6 fe ff       	call   f01097cf <kmalloc>
f011d11e:	83 c4 10             	add    $0x10,%esp
f011d121:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011d127:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011d12e:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011d134:	6a 01                	push   $0x1
f011d136:	ff 75 b8             	pushl  -0x48(%ebp)
f011d139:	ff 75 ac             	pushl  -0x54(%ebp)
f011d13c:	50                   	push   %eax
f011d13d:	e8 22 3f ff ff       	call   f0111064 <check_block>
f011d142:	83 c4 10             	add    $0x10,%esp
f011d145:	85 c0                	test   %eax,%eax
f011d147:	75 17                	jne    f011d160 <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011d149:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d150:	83 ec 0c             	sub    $0xc,%esp
f011d153:	68 66 05 13 f0       	push   $0xf0130566
f011d158:	e8 2e 3e fe ff       	call   f0100f8b <cprintf>
f011d15d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d160:	e8 e3 1a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d165:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d168:	74 17                	je     f011d181 <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011d16a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d171:	83 ec 0c             	sub    $0xc,%esp
f011d174:	68 80 05 13 f0       	push   $0xf0130580
f011d179:	e8 0d 3e fe ff       	call   f0100f8b <cprintf>
f011d17e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d181:	e8 0d 79 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d186:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d189:	74 17                	je     f011d1a2 <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d18b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d192:	83 ec 0c             	sub    $0xc,%esp
f011d195:	68 a0 05 13 f0       	push   $0xf01305a0
f011d19a:	e8 ec 3d fe ff       	call   f0100f8b <cprintf>
f011d19f:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011d1a2:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011d1a9:	e8 9a 1a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d1ae:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d1b1:	e8 dd 78 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d1b6:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011d1b9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d1bc:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d1bf:	29 c2                	sub    %eax,%edx
f011d1c1:	89 d0                	mov    %edx,%eax
f011d1c3:	83 ec 0c             	sub    $0xc,%esp
f011d1c6:	50                   	push   %eax
f011d1c7:	e8 03 c6 fe ff       	call   f01097cf <kmalloc>
f011d1cc:	83 c4 10             	add    $0x10,%esp
f011d1cf:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011d1d5:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011d1dc:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011d1e2:	6a 01                	push   $0x1
f011d1e4:	ff 75 b8             	pushl  -0x48(%ebp)
f011d1e7:	ff 75 ac             	pushl  -0x54(%ebp)
f011d1ea:	50                   	push   %eax
f011d1eb:	e8 74 3e ff ff       	call   f0111064 <check_block>
f011d1f0:	83 c4 10             	add    $0x10,%esp
f011d1f3:	85 c0                	test   %eax,%eax
f011d1f5:	75 17                	jne    f011d20e <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011d1f7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d1fe:	83 ec 0c             	sub    $0xc,%esp
f011d201:	68 0e 06 13 f0       	push   $0xf013060e
f011d206:	e8 80 3d fe ff       	call   f0100f8b <cprintf>
f011d20b:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011d20e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d211:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011d214:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011d21b:	6a 00                	push   $0x0
f011d21d:	ff 75 98             	pushl  -0x68(%ebp)
f011d220:	ff 75 ac             	pushl  -0x54(%ebp)
f011d223:	ff 75 ac             	pushl  -0x54(%ebp)
f011d226:	e8 39 3e ff ff       	call   f0111064 <check_block>
f011d22b:	83 c4 10             	add    $0x10,%esp
f011d22e:	85 c0                	test   %eax,%eax
f011d230:	75 17                	jne    f011d249 <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011d232:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d239:	83 ec 0c             	sub    $0xc,%esp
f011d23c:	68 25 06 13 f0       	push   $0xf0130625
f011d241:	e8 45 3d fe ff       	call   f0100f8b <cprintf>
f011d246:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011d249:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d24c:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011d251:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011d254:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011d257:	8b 00                	mov    (%eax),%eax
f011d259:	83 f8 01             	cmp    $0x1,%eax
f011d25c:	74 17                	je     f011d275 <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011d25e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d265:	83 ec 0c             	sub    $0xc,%esp
f011d268:	68 3c 06 13 f0       	push   $0xf013063c
f011d26d:	e8 19 3d fe ff       	call   f0100f8b <cprintf>
f011d272:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011d275:	83 ec 0c             	sub    $0xc,%esp
f011d278:	6a 00                	push   $0x0
f011d27a:	e8 1d c4 fe ff       	call   f010969c <sbrk>
f011d27f:	83 c4 10             	add    $0x10,%esp
f011d282:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011d285:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d288:	05 00 20 00 00       	add    $0x2000,%eax
f011d28d:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011d290:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d293:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011d296:	74 1d                	je     f011d2b5 <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011d298:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d29f:	83 ec 04             	sub    $0x4,%esp
f011d2a2:	ff 75 90             	pushl  -0x70(%ebp)
f011d2a5:	ff 75 8c             	pushl  -0x74(%ebp)
f011d2a8:	68 68 06 13 f0       	push   $0xf0130668
f011d2ad:	e8 d9 3c fe ff       	call   f0100f8b <cprintf>
f011d2b2:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d2b5:	e8 8e 19 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d2ba:	89 c2                	mov    %eax,%edx
f011d2bc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d2bf:	29 d0                	sub    %edx,%eax
f011d2c1:	83 f8 01             	cmp    $0x1,%eax
f011d2c4:	74 17                	je     f011d2dd <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011d2c6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d2cd:	83 ec 0c             	sub    $0xc,%esp
f011d2d0:	68 9c 06 13 f0       	push   $0xf013069c
f011d2d5:	e8 b1 3c fe ff       	call   f0100f8b <cprintf>
f011d2da:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d2dd:	e8 b1 77 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d2e2:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d2e5:	74 17                	je     f011d2fe <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d2e7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d2ee:	83 ec 0c             	sub    $0xc,%esp
f011d2f1:	68 bc 06 13 f0       	push   $0xf01306bc
f011d2f6:	e8 90 3c fe ff       	call   f0100f8b <cprintf>
f011d2fb:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011d2fe:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d302:	74 04                	je     f011d308 <test_ksbrk+0x78e>
		eval += 25;
f011d304:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011d308:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011d30f:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011d315:	bb f8 09 13 f0       	mov    $0xf01309f8,%ebx
f011d31a:	ba 05 00 00 00       	mov    $0x5,%edx
f011d31f:	89 c7                	mov    %eax,%edi
f011d321:	89 de                	mov    %ebx,%esi
f011d323:	89 d1                	mov    %edx,%ecx
f011d325:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011d327:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011d32d:	bb 0c 0a 13 f0       	mov    $0xf0130a0c,%ebx
f011d332:	ba 05 00 00 00       	mov    $0x5,%edx
f011d337:	89 c7                	mov    %eax,%edi
f011d339:	89 de                	mov    %ebx,%esi
f011d33b:	89 d1                	mov    %edx,%ecx
f011d33d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011d33f:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011d345:	bb 20 0a 13 f0       	mov    $0xf0130a20,%ebx
f011d34a:	ba 05 00 00 00       	mov    $0x5,%edx
f011d34f:	89 c7                	mov    %eax,%edi
f011d351:	89 de                	mov    %ebx,%esi
f011d353:	89 d1                	mov    %edx,%ecx
f011d355:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011d357:	83 ec 04             	sub    $0x4,%esp
f011d35a:	68 00 00 00 f8       	push   $0xf8000000
f011d35f:	68 00 10 00 00       	push   $0x1000
f011d364:	68 00 00 00 f6       	push   $0xf6000000
f011d369:	e8 02 c2 fe ff       	call   f0109570 <initialize_kheap_dynamic_allocator>
f011d36e:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d371:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011d378:	eb 1b                	jmp    f011d395 <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011d37a:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011d37f:	83 ec 08             	sub    $0x8,%esp
f011d382:	ff 75 dc             	pushl  -0x24(%ebp)
f011d385:	50                   	push   %eax
f011d386:	e8 7f b7 fe ff       	call   f0108b0a <unmap_frame>
f011d38b:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d38e:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011d395:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011d39c:	76 dc                	jbe    f011d37a <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011d39e:	83 ec 0c             	sub    $0xc,%esp
f011d3a1:	68 2c 07 13 f0       	push   $0xf013072c
f011d3a6:	e8 e0 3b fe ff       	call   f0100f8b <cprintf>
f011d3ab:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d3ae:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d3b5:	e9 21 01 00 00       	jmp    f011d4db <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d3ba:	e8 89 18 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d3bf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d3c2:	e8 cc 76 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d3c7:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d3ca:	83 ec 0c             	sub    $0xc,%esp
f011d3cd:	6a 00                	push   $0x0
f011d3cf:	e8 c8 c2 fe ff       	call   f010969c <sbrk>
f011d3d4:	83 c4 10             	add    $0x10,%esp
f011d3d7:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d3da:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d3dd:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d3e4:	83 ec 0c             	sub    $0xc,%esp
f011d3e7:	50                   	push   %eax
f011d3e8:	e8 af c2 fe ff       	call   f010969c <sbrk>
f011d3ed:	83 c4 10             	add    $0x10,%esp
f011d3f0:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011d3f3:	83 ec 0c             	sub    $0xc,%esp
f011d3f6:	6a 00                	push   $0x0
f011d3f8:	e8 9f c2 fe ff       	call   f010969c <sbrk>
f011d3fd:	83 c4 10             	add    $0x10,%esp
f011d400:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d403:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d40a:	e8 84 76 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d40f:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d412:	74 1a                	je     f011d42e <test_ksbrk+0x8b4>
			{
				correct = 0;
f011d414:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d41b:	83 ec 08             	sub    $0x8,%esp
f011d41e:	ff 75 d8             	pushl  -0x28(%ebp)
f011d421:	68 70 07 13 f0       	push   $0xf0130770
f011d426:	e8 60 3b fe ff       	call   f0100f8b <cprintf>
f011d42b:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011d42e:	e8 15 18 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d433:	89 c2                	mov    %eax,%edx
f011d435:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d438:	29 d0                	sub    %edx,%eax
f011d43a:	89 c2                	mov    %eax,%edx
f011d43c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d43f:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d446:	39 c2                	cmp    %eax,%edx
f011d448:	74 1a                	je     f011d464 <test_ksbrk+0x8ea>
			{
				correct = 0;
f011d44a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011d451:	83 ec 08             	sub    $0x8,%esp
f011d454:	ff 75 d8             	pushl  -0x28(%ebp)
f011d457:	68 e0 07 13 f0       	push   $0xf01307e0
f011d45c:	e8 2a 3b fe ff       	call   f0100f8b <cprintf>
f011d461:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d464:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d467:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d46e:	8b 45 80             	mov    -0x80(%ebp),%eax
f011d471:	39 c2                	cmp    %eax,%edx
f011d473:	74 25                	je     f011d49a <test_ksbrk+0x920>
			{
				correct = 0;
f011d475:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d47c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d47f:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d486:	ff 75 80             	pushl  -0x80(%ebp)
f011d489:	50                   	push   %eax
f011d48a:	ff 75 d8             	pushl  -0x28(%ebp)
f011d48d:	68 00 08 13 f0       	push   $0xf0130800
f011d492:	e8 f4 3a fe ff       	call   f0100f8b <cprintf>
f011d497:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d49a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d49d:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d4a4:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d4a7:	74 25                	je     f011d4ce <test_ksbrk+0x954>
			{
				correct = 0;
f011d4a9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d4b0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d4b3:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d4ba:	ff 75 90             	pushl  -0x70(%ebp)
f011d4bd:	50                   	push   %eax
f011d4be:	ff 75 d8             	pushl  -0x28(%ebp)
f011d4c1:	68 38 08 13 f0       	push   $0xf0130838
f011d4c6:	e8 c0 3a fe ff       	call   f0100f8b <cprintf>
f011d4cb:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d4ce:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d4d2:	74 04                	je     f011d4d8 <test_ksbrk+0x95e>
				eval += 10;
f011d4d4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d4d8:	ff 45 d8             	incl   -0x28(%ebp)
f011d4db:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d4de:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d4e1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d4e4:	39 c2                	cmp    %eax,%edx
f011d4e6:	0f 87 ce fe ff ff    	ja     f011d3ba <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011d4ec:	83 ec 0c             	sub    $0xc,%esp
f011d4ef:	68 6c 08 13 f0       	push   $0xf013086c
f011d4f4:	e8 92 3a fe ff       	call   f0100f8b <cprintf>
f011d4f9:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d4fc:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d4ff:	48                   	dec    %eax
f011d500:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011d503:	e9 18 01 00 00       	jmp    f011d620 <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d508:	e8 3b 17 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d50d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d510:	e8 7e 75 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d515:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d518:	83 ec 0c             	sub    $0xc,%esp
f011d51b:	6a 00                	push   $0x0
f011d51d:	e8 7a c1 fe ff       	call   f010969c <sbrk>
f011d522:	83 c4 10             	add    $0x10,%esp
f011d525:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d528:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d52b:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d532:	83 ec 0c             	sub    $0xc,%esp
f011d535:	50                   	push   %eax
f011d536:	e8 61 c1 fe ff       	call   f010969c <sbrk>
f011d53b:	83 c4 10             	add    $0x10,%esp
f011d53e:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011d544:	83 ec 0c             	sub    $0xc,%esp
f011d547:	6a 00                	push   $0x0
f011d549:	e8 4e c1 fe ff       	call   f010969c <sbrk>
f011d54e:	83 c4 10             	add    $0x10,%esp
f011d551:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d554:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d55b:	e8 33 75 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d560:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d563:	74 1a                	je     f011d57f <test_ksbrk+0xa05>
			{
				correct = 0;
f011d565:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d56c:	83 ec 08             	sub    $0x8,%esp
f011d56f:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d572:	68 bc 08 13 f0       	push   $0xf01308bc
f011d577:	e8 0f 3a fe ff       	call   f0100f8b <cprintf>
f011d57c:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d57f:	e8 c4 16 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d584:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d587:	74 1a                	je     f011d5a3 <test_ksbrk+0xa29>
			{
				correct = 0;
f011d589:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011d590:	83 ec 08             	sub    $0x8,%esp
f011d593:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d596:	68 2c 09 13 f0       	push   $0xf013092c
f011d59b:	e8 eb 39 fe ff       	call   f0100f8b <cprintf>
f011d5a0:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d5a3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d5a6:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d5ad:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d5b3:	39 c2                	cmp    %eax,%edx
f011d5b5:	74 28                	je     f011d5df <test_ksbrk+0xa65>
			{
				correct = 0;
f011d5b7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d5be:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d5c1:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d5c8:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011d5ce:	50                   	push   %eax
f011d5cf:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d5d2:	68 4c 09 13 f0       	push   $0xf013094c
f011d5d7:	e8 af 39 fe ff       	call   f0100f8b <cprintf>
f011d5dc:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d5df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d5e2:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d5e9:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d5ec:	74 25                	je     f011d613 <test_ksbrk+0xa99>
			{
				correct = 0;
f011d5ee:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d5f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d5f8:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d5ff:	ff 75 90             	pushl  -0x70(%ebp)
f011d602:	50                   	push   %eax
f011d603:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d606:	68 84 09 13 f0       	push   $0xf0130984
f011d60b:	e8 7b 39 fe ff       	call   f0100f8b <cprintf>
f011d610:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d613:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d617:	74 04                	je     f011d61d <test_ksbrk+0xaa3>
				eval += 10;
f011d619:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d61d:	ff 45 d4             	incl   -0x2c(%ebp)
f011d620:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d623:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011d626:	0f 82 dc fe ff ff    	jb     f011d508 <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011d62c:	83 ec 08             	sub    $0x8,%esp
f011d62f:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d632:	68 b8 09 13 f0       	push   $0xf01309b8
f011d637:	e8 4f 39 fe ff       	call   f0100f8b <cprintf>
f011d63c:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011d63f:	83 ec 0c             	sub    $0xc,%esp
f011d642:	68 e2 09 13 f0       	push   $0xf01309e2
f011d647:	e8 3f 39 fe ff       	call   f0100f8b <cprintf>
f011d64c:	83 c4 10             	add    $0x10,%esp
	return 0;
f011d64f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011d654:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d657:	5b                   	pop    %ebx
f011d658:	5e                   	pop    %esi
f011d659:	5f                   	pop    %edi
f011d65a:	5d                   	pop    %ebp
f011d65b:	c3                   	ret    

f011d65c <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011d65c:	55                   	push   %ebp
f011d65d:	89 e5                	mov    %esp,%ebp
f011d65f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d662:	83 ec 04             	sub    $0x4,%esp
f011d665:	68 34 0a 13 f0       	push   $0xf0130a34
f011d66a:	68 c2 08 00 00       	push   $0x8c2
f011d66f:	68 73 d4 12 f0       	push   $0xf012d473
f011d674:	e8 c0 2c fe ff       	call   f0100339 <_panic>

f011d679 <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011d679:	55                   	push   %ebp
f011d67a:	89 e5                	mov    %esp,%ebp
f011d67c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d67f:	83 ec 04             	sub    $0x4,%esp
f011d682:	68 34 0a 13 f0       	push   $0xf0130a34
f011d687:	68 c7 08 00 00       	push   $0x8c7
f011d68c:	68 73 d4 12 f0       	push   $0xf012d473
f011d691:	e8 a3 2c fe ff       	call   f0100339 <_panic>

f011d696 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011d696:	55                   	push   %ebp
f011d697:	89 e5                	mov    %esp,%ebp
f011d699:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d69c:	83 ec 04             	sub    $0x4,%esp
f011d69f:	68 34 0a 13 f0       	push   $0xf0130a34
f011d6a4:	68 cc 08 00 00       	push   $0x8cc
f011d6a9:	68 73 d4 12 f0       	push   $0xf012d473
f011d6ae:	e8 86 2c fe ff       	call   f0100339 <_panic>

f011d6b3 <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011d6b3:	55                   	push   %ebp
f011d6b4:	89 e5                	mov    %esp,%ebp
f011d6b6:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d6b9:	83 ec 04             	sub    $0x4,%esp
f011d6bc:	68 34 0a 13 f0       	push   $0xf0130a34
f011d6c1:	68 d1 08 00 00       	push   $0x8d1
f011d6c6:	68 73 d4 12 f0       	push   $0xf012d473
f011d6cb:	e8 69 2c fe ff       	call   f0100339 <_panic>

f011d6d0 <test_kfree>:
}

int test_kfree()
{
f011d6d0:	55                   	push   %ebp
f011d6d1:	89 e5                	mov    %esp,%ebp
f011d6d3:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d6d6:	83 ec 04             	sub    $0x4,%esp
f011d6d9:	68 34 0a 13 f0       	push   $0xf0130a34
f011d6de:	68 d6 08 00 00       	push   $0x8d6
f011d6e3:	68 73 d4 12 f0       	push   $0xf012d473
f011d6e8:	e8 4c 2c fe ff       	call   f0100339 <_panic>

f011d6ed <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011d6ed:	55                   	push   %ebp
f011d6ee:	89 e5                	mov    %esp,%ebp
f011d6f0:	57                   	push   %edi
f011d6f1:	56                   	push   %esi
f011d6f2:	53                   	push   %ebx
f011d6f3:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011d6f9:	a0 3c 0e 18 f0       	mov    0xf0180e3c,%al
f011d6fe:	84 c0                	test   %al,%al
f011d700:	74 56                	je     f011d758 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011d702:	c6 05 3c 0e 18 f0 00 	movb   $0x0,0xf0180e3c
		initFreeFrames = sys_calculate_free_frames() ;
f011d709:	e8 3a 15 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d70e:	a3 e8 1f 6b f2       	mov    %eax,0xf26b1fe8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011d713:	e8 7b 73 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d718:	a3 e4 1f 6b f2       	mov    %eax,0xf26b1fe4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011d71d:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d723:	bb 99 0b 13 f0       	mov    $0xf0130b99,%ebx
f011d728:	ba 11 00 00 00       	mov    $0x11,%edx
f011d72d:	89 c7                	mov    %eax,%edi
f011d72f:	89 de                	mov    %ebx,%esi
f011d731:	89 d1                	mov    %edx,%ecx
f011d733:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011d735:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011d73b:	b9 53 00 00 00       	mov    $0x53,%ecx
f011d740:	b0 00                	mov    $0x0,%al
f011d742:	89 d7                	mov    %edx,%edi
f011d744:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011d746:	83 ec 0c             	sub    $0xc,%esp
f011d749:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d74f:	50                   	push   %eax
f011d750:	e8 a6 47 fe ff       	call   f0101efb <execute_command>
f011d755:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011d758:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011d75f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d766:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f011d76b:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d76e:	eb 2b                	jmp    f011d79b <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011d770:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d773:	83 c0 20             	add    $0x20,%eax
f011d776:	83 ec 08             	sub    $0x8,%esp
f011d779:	68 44 0a 13 f0       	push   $0xf0130a44
f011d77e:	50                   	push   %eax
f011d77f:	e8 ea 28 00 00       	call   f012006e <strcmp>
f011d784:	83 c4 10             	add    $0x10,%esp
f011d787:	85 c0                	test   %eax,%eax
f011d789:	75 08                	jne    f011d793 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011d78b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d78e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011d791:	eb 2f                	jmp    f011d7c2 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d793:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f011d798:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d79b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d79f:	74 08                	je     f011d7a9 <test_three_creation_functions+0xbc>
f011d7a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d7a4:	8b 40 08             	mov    0x8(%eax),%eax
f011d7a7:	eb 05                	jmp    f011d7ae <test_three_creation_functions+0xc1>
f011d7a9:	b8 00 00 00 00       	mov    $0x0,%eax
f011d7ae:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f011d7b3:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f011d7b8:	85 c0                	test   %eax,%eax
f011d7ba:	75 b4                	jne    f011d770 <test_three_creation_functions+0x83>
f011d7bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d7c0:	75 ae                	jne    f011d770 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011d7c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d7c5:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011d7cb:	85 c0                	test   %eax,%eax
f011d7cd:	74 17                	je     f011d7e6 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011d7cf:	83 ec 04             	sub    $0x4,%esp
f011d7d2:	68 4c 0a 13 f0       	push   $0xf0130a4c
f011d7d7:	68 f7 08 00 00       	push   $0x8f7
f011d7dc:	68 73 d4 12 f0       	push   $0xf012d473
f011d7e1:	e8 53 2b fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011d7e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d7e9:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011d7ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011d7f2:	e8 51 14 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d7f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011d7fa:	e8 94 72 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d7ff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d802:	a1 e4 1f 6b f2       	mov    0xf26b1fe4,%eax
f011d807:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011d80a:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d80d:	74 17                	je     f011d826 <test_three_creation_functions+0x139>
f011d80f:	83 ec 04             	sub    $0x4,%esp
f011d812:	68 8c d4 12 f0       	push   $0xf012d48c
f011d817:	68 01 09 00 00       	push   $0x901
f011d81c:	68 73 d4 12 f0       	push   $0xf012d473
f011d821:	e8 13 2b fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011d826:	a1 e8 1f 6b f2       	mov    0xf26b1fe8,%eax
f011d82b:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011d82e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d831:	83 c2 15             	add    $0x15,%edx
f011d834:	39 d0                	cmp    %edx,%eax
f011d836:	74 17                	je     f011d84f <test_three_creation_functions+0x162>
f011d838:	83 ec 04             	sub    $0x4,%esp
f011d83b:	68 9c 0a 13 f0       	push   $0xf0130a9c
f011d840:	68 03 09 00 00       	push   $0x903
f011d845:	68 73 d4 12 f0       	push   $0xf012d473
f011d84a:	e8 ea 2a fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011d84f:	83 ec 0c             	sub    $0xc,%esp
f011d852:	68 00 10 00 00       	push   $0x1000
f011d857:	e8 73 bf fe ff       	call   f01097cf <kmalloc>
f011d85c:	83 c4 10             	add    $0x10,%esp
f011d85f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011d862:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d865:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011d86a:	74 17                	je     f011d883 <test_three_creation_functions+0x196>
f011d86c:	83 ec 04             	sub    $0x4,%esp
f011d86f:	68 dc 0a 13 f0       	push   $0xf0130adc
f011d874:	68 07 09 00 00       	push   $0x907
f011d879:	68 73 d4 12 f0       	push   $0xf012d473
f011d87e:	e8 b6 2a fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011d883:	83 ec 0c             	sub    $0xc,%esp
f011d886:	68 4c 0b 13 f0       	push   $0xf0130b4c
f011d88b:	e8 fb 36 fe ff       	call   f0100f8b <cprintf>
f011d890:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d893:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011d898:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d89b:	5b                   	pop    %ebx
f011d89c:	5e                   	pop    %esi
f011d89d:	5f                   	pop    %edi
f011d89e:	5d                   	pop    %ebp
f011d89f:	c3                   	ret    

f011d8a0 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011d8a0:	55                   	push   %ebp
f011d8a1:	89 e5                	mov    %esp,%ebp
f011d8a3:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d8a6:	83 ec 04             	sub    $0x4,%esp
f011d8a9:	68 34 0a 13 f0       	push   $0xf0130a34
f011d8ae:	68 15 09 00 00       	push   $0x915
f011d8b3:	68 73 d4 12 f0       	push   $0xf012d473
f011d8b8:	e8 7c 2a fe ff       	call   f0100339 <_panic>

f011d8bd <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011d8bd:	55                   	push   %ebp
f011d8be:	89 e5                	mov    %esp,%ebp
f011d8c0:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d8c3:	83 ec 04             	sub    $0x4,%esp
f011d8c6:	68 34 0a 13 f0       	push   $0xf0130a34
f011d8cb:	68 1d 09 00 00       	push   $0x91d
f011d8d0:	68 73 d4 12 f0       	push   $0xf012d473
f011d8d5:	e8 5f 2a fe ff       	call   f0100339 <_panic>

f011d8da <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011d8da:	55                   	push   %ebp
f011d8db:	89 e5                	mov    %esp,%ebp
f011d8dd:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d8e0:	83 ec 04             	sub    $0x4,%esp
f011d8e3:	68 34 0a 13 f0       	push   $0xf0130a34
f011d8e8:	68 24 09 00 00       	push   $0x924
f011d8ed:	68 73 d4 12 f0       	push   $0xf012d473
f011d8f2:	e8 42 2a fe ff       	call   f0100339 <_panic>

f011d8f7 <test_kfreelast>:

}


int test_kfreelast()
{
f011d8f7:	55                   	push   %ebp
f011d8f8:	89 e5                	mov    %esp,%ebp
f011d8fa:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d8fd:	83 ec 04             	sub    $0x4,%esp
f011d900:	68 34 0a 13 f0       	push   $0xf0130a34
f011d905:	68 2b 09 00 00       	push   $0x92b
f011d90a:	68 73 d4 12 f0       	push   $0xf012d473
f011d90f:	e8 25 2a fe ff       	call   f0100339 <_panic>

f011d914 <test_krealloc>:

}

int test_krealloc() {
f011d914:	55                   	push   %ebp
f011d915:	89 e5                	mov    %esp,%ebp
f011d917:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d91a:	83 ec 04             	sub    $0x4,%esp
f011d91d:	68 34 0a 13 f0       	push   $0xf0130a34
f011d922:	68 30 09 00 00       	push   $0x930
f011d927:	68 73 d4 12 f0       	push   $0xf012d473
f011d92c:	e8 08 2a fe ff       	call   f0100339 <_panic>

f011d931 <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011d931:	55                   	push   %ebp
f011d932:	89 e5                	mov    %esp,%ebp
f011d934:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d937:	83 ec 04             	sub    $0x4,%esp
f011d93a:	68 34 0a 13 f0       	push   $0xf0130a34
f011d93f:	68 35 09 00 00       	push   $0x935
f011d944:	68 73 d4 12 f0       	push   $0xf012d473
f011d949:	e8 eb 29 fe ff       	call   f0100339 <_panic>

f011d94e <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011d94e:	55                   	push   %ebp
f011d94f:	89 e5                	mov    %esp,%ebp
f011d951:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d954:	83 ec 04             	sub    $0x4,%esp
f011d957:	68 34 0a 13 f0       	push   $0xf0130a34
f011d95c:	68 3b 09 00 00       	push   $0x93b
f011d961:	68 73 d4 12 f0       	push   $0xf012d473
f011d966:	e8 ce 29 fe ff       	call   f0100339 <_panic>

f011d96b <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011d96b:	55                   	push   %ebp
f011d96c:	89 e5                	mov    %esp,%ebp
f011d96e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d971:	83 ec 04             	sub    $0x4,%esp
f011d974:	68 34 0a 13 f0       	push   $0xf0130a34
f011d979:	68 40 09 00 00       	push   $0x940
f011d97e:	68 73 d4 12 f0       	push   $0xf012d473
f011d983:	e8 b1 29 fe ff       	call   f0100339 <_panic>

f011d988 <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011d988:	55                   	push   %ebp
f011d989:	89 e5                	mov    %esp,%ebp
f011d98b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d98e:	83 ec 04             	sub    $0x4,%esp
f011d991:	68 34 0a 13 f0       	push   $0xf0130a34
f011d996:	68 46 09 00 00       	push   $0x946
f011d99b:	68 73 d4 12 f0       	push   $0xf012d473
f011d9a0:	e8 94 29 fe ff       	call   f0100339 <_panic>

f011d9a5 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011d9a5:	55                   	push   %ebp
f011d9a6:	89 e5                	mov    %esp,%ebp
f011d9a8:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d9ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d9b2:	e9 84 00 00 00       	jmp    f011da3b <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011d9b7:	83 ec 08             	sub    $0x8,%esp
f011d9ba:	ff 75 f4             	pushl  -0xc(%ebp)
f011d9bd:	68 00 0c 13 f0       	push   $0xf0130c00
f011d9c2:	e8 c4 35 fe ff       	call   f0100f8b <cprintf>
f011d9c7:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d9ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d9d1:	eb 4c                	jmp    f011da1f <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011d9d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d9d6:	89 d0                	mov    %edx,%eax
f011d9d8:	c1 e0 02             	shl    $0x2,%eax
f011d9db:	01 d0                	add    %edx,%eax
f011d9dd:	c1 e0 03             	shl    $0x3,%eax
f011d9e0:	89 c2                	mov    %eax,%edx
f011d9e2:	8b 45 08             	mov    0x8(%ebp),%eax
f011d9e5:	01 c2                	add    %eax,%edx
f011d9e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d9ea:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d9ed:	85 c0                	test   %eax,%eax
f011d9ef:	74 36                	je     f011da27 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011d9f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d9f4:	89 d0                	mov    %edx,%eax
f011d9f6:	c1 e0 02             	shl    $0x2,%eax
f011d9f9:	01 d0                	add    %edx,%eax
f011d9fb:	c1 e0 03             	shl    $0x3,%eax
f011d9fe:	89 c2                	mov    %eax,%edx
f011da00:	8b 45 08             	mov    0x8(%ebp),%eax
f011da03:	01 c2                	add    %eax,%edx
f011da05:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011da08:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011da0b:	83 ec 08             	sub    $0x8,%esp
f011da0e:	50                   	push   %eax
f011da0f:	68 08 0c 13 f0       	push   $0xf0130c08
f011da14:	e8 72 35 fe ff       	call   f0100f8b <cprintf>
f011da19:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011da1c:	ff 45 f0             	incl   -0x10(%ebp)
f011da1f:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011da23:	7e ae                	jle    f011d9d3 <print_order+0x2e>
f011da25:	eb 01                	jmp    f011da28 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011da27:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011da28:	83 ec 0c             	sub    $0xc,%esp
f011da2b:	68 0d 0c 13 f0       	push   $0xf0130c0d
f011da30:	e8 56 35 fe ff       	call   f0100f8b <cprintf>
f011da35:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011da38:	ff 45 f4             	incl   -0xc(%ebp)
f011da3b:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011da3f:	0f 8e 72 ff ff ff    	jle    f011d9b7 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011da45:	90                   	nop
f011da46:	c9                   	leave  
f011da47:	c3                   	ret    

f011da48 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011da48:	55                   	push   %ebp
f011da49:	89 e5                	mov    %esp,%ebp
f011da4b:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011da4e:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011da55:	83 ec 0c             	sub    $0xc,%esp
f011da58:	68 80 f0 71 f0       	push   $0xf071f080
f011da5d:	e8 52 25 ff ff       	call   f010ffb4 <acquire_spinlock>
f011da62:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011da65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011da6c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011da73:	8b 55 0c             	mov    0xc(%ebp),%edx
f011da76:	8b 45 10             	mov    0x10(%ebp),%eax
f011da79:	01 d0                	add    %edx,%eax
f011da7b:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011da7e:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011da83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011da86:	a1 04 f1 71 f0       	mov    0xf071f104,%eax
f011da8b:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011da8e:	ff 75 e8             	pushl  -0x18(%ebp)
f011da91:	ff 75 0c             	pushl  0xc(%ebp)
f011da94:	ff 75 08             	pushl  0x8(%ebp)
f011da97:	68 10 0c 13 f0       	push   $0xf0130c10
f011da9c:	e8 ea 34 fe ff       	call   f0100f8b <cprintf>
f011daa1:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011daa4:	eb 34                	jmp    f011dada <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011daa6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011daa9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011daac:	7d 05                	jge    f011dab3 <find_in_range+0x6b>
			{
				i++;
f011daae:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011dab1:	eb 1e                	jmp    f011dad1 <find_in_range+0x89>
			}
			if (i >= end)
f011dab3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dab6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011dab9:	7d 29                	jge    f011dae4 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011dabb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dabe:	8b 40 10             	mov    0x10(%eax),%eax
f011dac1:	3b 45 08             	cmp    0x8(%ebp),%eax
f011dac4:	75 08                	jne    f011dace <find_in_range+0x86>
			{
				ret = i;
f011dac6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dac9:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011dacc:	eb 17                	jmp    f011dae5 <find_in_range+0x9d>
			}
			i++;
f011dace:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011dad1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dad4:	8b 40 0c             	mov    0xc(%eax),%eax
f011dad7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011dada:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dadd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011dae0:	7c c4                	jl     f011daa6 <find_in_range+0x5e>
f011dae2:	eb 01                	jmp    f011dae5 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011dae4:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011dae5:	83 ec 0c             	sub    $0xc,%esp
f011dae8:	68 80 f0 71 f0       	push   $0xf071f080
f011daed:	e8 49 25 ff ff       	call   f011003b <release_spinlock>
f011daf2:	83 c4 10             	add    $0x10,%esp
	return ret;
f011daf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011daf8:	c9                   	leave  
f011daf9:	c3                   	ret    

f011dafa <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011dafa:	55                   	push   %ebp
f011dafb:	89 e5                	mov    %esp,%ebp
f011dafd:	57                   	push   %edi
f011dafe:	56                   	push   %esi
f011daff:	53                   	push   %ebx
f011db00:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011db03:	a0 3d 0e 18 f0       	mov    0xf0180e3d,%al
f011db08:	84 c0                	test   %al,%al
f011db0a:	0f 84 9b 01 00 00    	je     f011dcab <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011db10:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
		int nice_values[] = {-10, -5, 0, 5, 10};
f011db17:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011db1a:	bb 88 0d 13 f0       	mov    $0xf0130d88,%ebx
f011db1f:	ba 05 00 00 00       	mov    $0x5,%edx
f011db24:	89 c7                	mov    %eax,%edi
f011db26:	89 de                	mov    %ebx,%esi
f011db28:	89 d1                	mov    %edx,%ecx
f011db2a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011db2c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011db33:	e9 44 01 00 00       	jmp    f011dc7c <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011db38:	6a 00                	push   $0x0
f011db3a:	6a 00                	push   $0x0
f011db3c:	68 f4 01 00 00       	push   $0x1f4
f011db41:	68 41 0c 13 f0       	push   $0xf0130c41
f011db46:	e8 5c d7 fe ff       	call   f010b2a7 <env_create>
f011db4b:	83 c4 10             	add    $0x10,%esp
f011db4e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011db51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011db54:	b9 05 00 00 00       	mov    $0x5,%ecx
f011db59:	99                   	cltd   
f011db5a:	f7 f9                	idiv   %ecx
f011db5c:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011db5f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011db62:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011db66:	83 ec 08             	sub    $0x8,%esp
f011db69:	50                   	push   %eax
f011db6a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011db6d:	e8 7f 8d fe ff       	call   f01068f1 <env_set_nice>
f011db72:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011db75:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011db79:	75 14                	jne    f011db8f <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011db7b:	83 ec 04             	sub    $0x4,%esp
f011db7e:	68 49 0c 13 f0       	push   $0xf0130c49
f011db83:	6a 53                	push   $0x53
f011db85:	68 62 0c 13 f0       	push   $0xf0130c62
f011db8a:	e8 aa 27 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011db8f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011db92:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011db98:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011db9d:	74 14                	je     f011dbb3 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011db9f:	83 ec 04             	sub    $0x4,%esp
f011dba2:	68 80 0c 13 f0       	push   $0xf0130c80
f011dba7:	6a 55                	push   $0x55
f011dba9:	68 62 0c 13 f0       	push   $0xf0130c62
f011dbae:	e8 86 27 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011dbb3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dbb6:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dbba:	83 c0 0a             	add    $0xa,%eax
f011dbbd:	83 f8 14             	cmp    $0x14,%eax
f011dbc0:	0f 87 a5 00 00 00    	ja     f011dc6b <test_bsd_nice_0+0x171>
f011dbc6:	8b 04 85 9c 0d 13 f0 	mov    -0xfecf264(,%eax,4),%eax
f011dbcd:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011dbcf:	a1 1c ee 71 f0       	mov    0xf071ee1c,%eax
f011dbd4:	8d 50 01             	lea    0x1(%eax),%edx
f011dbd7:	89 15 1c ee 71 f0    	mov    %edx,0xf071ee1c
f011dbdd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dbe0:	8b 52 10             	mov    0x10(%edx),%edx
f011dbe3:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011dbea:	eb 7f                	jmp    f011dc6b <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011dbec:	a1 20 ee 71 f0       	mov    0xf071ee20,%eax
f011dbf1:	8d 50 01             	lea    0x1(%eax),%edx
f011dbf4:	89 15 20 ee 71 f0    	mov    %edx,0xf071ee20
f011dbfa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dbfd:	8b 52 10             	mov    0x10(%edx),%edx
f011dc00:	83 c0 0a             	add    $0xa,%eax
f011dc03:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011dc0a:	eb 5f                	jmp    f011dc6b <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011dc0c:	a1 24 ee 71 f0       	mov    0xf071ee24,%eax
f011dc11:	8d 50 01             	lea    0x1(%eax),%edx
f011dc14:	89 15 24 ee 71 f0    	mov    %edx,0xf071ee24
f011dc1a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dc1d:	8b 52 10             	mov    0x10(%edx),%edx
f011dc20:	83 c0 14             	add    $0x14,%eax
f011dc23:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011dc2a:	eb 3f                	jmp    f011dc6b <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011dc2c:	a1 28 ee 71 f0       	mov    0xf071ee28,%eax
f011dc31:	8d 50 01             	lea    0x1(%eax),%edx
f011dc34:	89 15 28 ee 71 f0    	mov    %edx,0xf071ee28
f011dc3a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dc3d:	8b 52 10             	mov    0x10(%edx),%edx
f011dc40:	83 c0 1e             	add    $0x1e,%eax
f011dc43:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011dc4a:	eb 1f                	jmp    f011dc6b <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011dc4c:	a1 2c ee 71 f0       	mov    0xf071ee2c,%eax
f011dc51:	8d 50 01             	lea    0x1(%eax),%edx
f011dc54:	89 15 2c ee 71 f0    	mov    %edx,0xf071ee2c
f011dc5a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dc5d:	8b 52 10             	mov    0x10(%edx),%edx
f011dc60:	83 c0 28             	add    $0x28,%eax
f011dc63:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011dc6a:	90                   	nop
			}
			sched_new_env(env);
f011dc6b:	83 ec 0c             	sub    $0xc,%esp
f011dc6e:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dc71:	e8 11 7d fe ff       	call   f0105987 <sched_new_env>
f011dc76:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011dc79:	ff 45 e4             	incl   -0x1c(%ebp)
f011dc7c:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011dc80:	0f 8e b2 fe ff ff    	jle    f011db38 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011dc86:	83 ec 0c             	sub    $0xc,%esp
f011dc89:	68 b0 0c 13 f0       	push   $0xf0130cb0
f011dc8e:	e8 f8 32 fe ff       	call   f0100f8b <cprintf>
f011dc93:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011dc96:	83 ec 0c             	sub    $0xc,%esp
f011dc99:	68 ff 0c 13 f0       	push   $0xf0130cff
f011dc9e:	e8 58 42 fe ff       	call   f0101efb <execute_command>
f011dca3:	83 c4 10             	add    $0x10,%esp
f011dca6:	e9 c0 00 00 00       	jmp    f011dd6b <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011dcab:	83 ec 0c             	sub    $0xc,%esp
f011dcae:	68 06 0d 13 f0       	push   $0xf0130d06
f011dcb3:	e8 d3 32 fe ff       	call   f0100f8b <cprintf>
f011dcb8:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011dcbb:	e8 ff 83 fe ff       	call   f01060bf <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011dcc0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011dcc7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011dcce:	e9 87 00 00 00       	jmp    f011dd5a <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011dcd3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011dcda:	eb 52                	jmp    f011dd2e <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011dcdc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dcdf:	8b 14 85 1c ee 71 f0 	mov    -0xf8e11e4(,%eax,4),%edx
f011dce6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011dce9:	89 c8                	mov    %ecx,%eax
f011dceb:	c1 e0 02             	shl    $0x2,%eax
f011dcee:	01 c8                	add    %ecx,%eax
f011dcf0:	01 c0                	add    %eax,%eax
f011dcf2:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011dcf5:	01 c8                	add    %ecx,%eax
f011dcf7:	8b 04 85 00 20 6b f2 	mov    -0xd94e000(,%eax,4),%eax
f011dcfe:	83 ec 04             	sub    $0x4,%esp
f011dd01:	52                   	push   %edx
f011dd02:	ff 75 e0             	pushl  -0x20(%ebp)
f011dd05:	50                   	push   %eax
f011dd06:	e8 3d fd ff ff       	call   f011da48 <find_in_range>
f011dd0b:	83 c4 10             	add    $0x10,%esp
f011dd0e:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011dd11:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011dd15:	75 14                	jne    f011dd2b <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011dd17:	83 ec 04             	sub    $0x4,%esp
f011dd1a:	68 18 0d 13 f0       	push   $0xf0130d18
f011dd1f:	6a 7b                	push   $0x7b
f011dd21:	68 62 0c 13 f0       	push   $0xf0130c62
f011dd26:	e8 0e 26 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011dd2b:	ff 45 d8             	incl   -0x28(%ebp)
f011dd2e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011dd31:	89 d0                	mov    %edx,%eax
f011dd33:	c1 e0 02             	shl    $0x2,%eax
f011dd36:	01 d0                	add    %edx,%eax
f011dd38:	01 c0                	add    %eax,%eax
f011dd3a:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011dd3d:	01 d0                	add    %edx,%eax
f011dd3f:	8b 04 85 00 20 6b f2 	mov    -0xd94e000(,%eax,4),%eax
f011dd46:	85 c0                	test   %eax,%eax
f011dd48:	75 92                	jne    f011dcdc <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011dd4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dd4d:	8b 04 85 1c ee 71 f0 	mov    -0xf8e11e4(,%eax,4),%eax
f011dd54:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011dd57:	ff 45 dc             	incl   -0x24(%ebp)
f011dd5a:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011dd5e:	0f 8e 6f ff ff ff    	jle    f011dcd3 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011dd64:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011dd6b:	83 ec 0c             	sub    $0xc,%esp
f011dd6e:	68 4c 0d 13 f0       	push   $0xf0130d4c
f011dd73:	e8 13 32 fe ff       	call   f0100f8b <cprintf>
f011dd78:	83 c4 10             	add    $0x10,%esp
}
f011dd7b:	90                   	nop
f011dd7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011dd7f:	5b                   	pop    %ebx
f011dd80:	5e                   	pop    %esi
f011dd81:	5f                   	pop    %edi
f011dd82:	5d                   	pop    %ebp
f011dd83:	c3                   	ret    

f011dd84 <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011dd84:	55                   	push   %ebp
f011dd85:	89 e5                	mov    %esp,%ebp
f011dd87:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011dd8a:	a0 3d 0e 18 f0       	mov    0xf0180e3d,%al
f011dd8f:	84 c0                	test   %al,%al
f011dd91:	0f 84 50 01 00 00    	je     f011dee7 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011dd97:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011dd9e:	6a 00                	push   $0x0
f011dda0:	6a 00                	push   $0x0
f011dda2:	68 f4 01 00 00       	push   $0x1f4
f011dda7:	68 41 0c 13 f0       	push   $0xf0130c41
f011ddac:	e8 f6 d4 fe ff       	call   f010b2a7 <env_create>
f011ddb1:	83 c4 10             	add    $0x10,%esp
f011ddb4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011ddb7:	6a 00                	push   $0x0
f011ddb9:	6a 00                	push   $0x0
f011ddbb:	68 f4 01 00 00       	push   $0x1f4
f011ddc0:	68 f0 0d 13 f0       	push   $0xf0130df0
f011ddc5:	e8 dd d4 fe ff       	call   f010b2a7 <env_create>
f011ddca:	83 c4 10             	add    $0x10,%esp
f011ddcd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011ddd0:	6a 00                	push   $0x0
f011ddd2:	6a 00                	push   $0x0
f011ddd4:	68 f4 01 00 00       	push   $0x1f4
f011ddd9:	68 fd 0d 13 f0       	push   $0xf0130dfd
f011ddde:	e8 c4 d4 fe ff       	call   f010b2a7 <env_create>
f011dde3:	83 c4 10             	add    $0x10,%esp
f011dde6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011dde9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011dded:	74 0c                	je     f011ddfb <test_bsd_nice_1+0x77>
f011ddef:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011ddf3:	74 06                	je     f011ddfb <test_bsd_nice_1+0x77>
f011ddf5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ddf9:	75 17                	jne    f011de12 <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011ddfb:	83 ec 04             	sub    $0x4,%esp
f011ddfe:	68 49 0c 13 f0       	push   $0xf0130c49
f011de03:	68 8e 00 00 00       	push   $0x8e
f011de08:	68 62 0c 13 f0       	push   $0xf0130c62
f011de0d:	e8 27 25 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011de12:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011de15:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011de1b:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011de20:	75 20                	jne    f011de42 <test_bsd_nice_1+0xbe>
f011de22:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011de25:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011de2b:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011de30:	75 10                	jne    f011de42 <test_bsd_nice_1+0xbe>
f011de32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011de35:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011de3b:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011de40:	74 35                	je     f011de77 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011de42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011de45:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011de4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011de4e:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011de54:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011de57:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011de5d:	83 ec 08             	sub    $0x8,%esp
f011de60:	51                   	push   %ecx
f011de61:	52                   	push   %edx
f011de62:	50                   	push   %eax
f011de63:	68 0c 0e 13 f0       	push   $0xf0130e0c
f011de68:	68 90 00 00 00       	push   $0x90
f011de6d:	68 62 0c 13 f0       	push   $0xf0130c62
f011de72:	e8 c2 24 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011de77:	83 ec 0c             	sub    $0xc,%esp
f011de7a:	ff 75 ec             	pushl  -0x14(%ebp)
f011de7d:	e8 05 7b fe ff       	call   f0105987 <sched_new_env>
f011de82:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011de85:	83 ec 0c             	sub    $0xc,%esp
f011de88:	ff 75 e8             	pushl  -0x18(%ebp)
f011de8b:	e8 f7 7a fe ff       	call   f0105987 <sched_new_env>
f011de90:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011de93:	83 ec 0c             	sub    $0xc,%esp
f011de96:	ff 75 e4             	pushl  -0x1c(%ebp)
f011de99:	e8 e9 7a fe ff       	call   f0105987 <sched_new_env>
f011de9e:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011dea1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dea4:	8b 40 10             	mov    0x10(%eax),%eax
f011dea7:	a3 00 20 6b f2       	mov    %eax,0xf26b2000
		prog_orders[1][0] = fibEnv->env_id;
f011deac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011deaf:	8b 40 10             	mov    0x10(%eax),%eax
f011deb2:	a3 28 20 6b f2       	mov    %eax,0xf26b2028
		prog_orders[2][0] = fibposnEnv->env_id;
f011deb7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011deba:	8b 40 10             	mov    0x10(%eax),%eax
f011debd:	a3 50 20 6b f2       	mov    %eax,0xf26b2050
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011dec2:	83 ec 0c             	sub    $0xc,%esp
f011dec5:	68 b0 0c 13 f0       	push   $0xf0130cb0
f011deca:	e8 bc 30 fe ff       	call   f0100f8b <cprintf>
f011decf:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011ded2:	83 ec 0c             	sub    $0xc,%esp
f011ded5:	68 ff 0c 13 f0       	push   $0xf0130cff
f011deda:	e8 1c 40 fe ff       	call   f0101efb <execute_command>
f011dedf:	83 c4 10             	add    $0x10,%esp
f011dee2:	e9 9e 00 00 00       	jmp    f011df85 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011dee7:	83 ec 0c             	sub    $0xc,%esp
f011deea:	68 06 0d 13 f0       	push   $0xf0130d06
f011deef:	e8 97 30 fe ff       	call   f0100f8b <cprintf>
f011def4:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011def7:	e8 c3 81 fe ff       	call   f01060bf <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011defc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011df03:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011df0a:	83 ec 0c             	sub    $0xc,%esp
f011df0d:	68 80 f0 71 f0       	push   $0xf071f080
f011df12:	e8 9d 20 ff ff       	call   f010ffb4 <acquire_spinlock>
f011df17:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011df1a:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011df1f:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011df22:	a1 04 f1 71 f0       	mov    0xf071f104,%eax
f011df27:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011df2a:	eb 41                	jmp    f011df6d <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011df2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011df2f:	89 d0                	mov    %edx,%eax
f011df31:	c1 e0 02             	shl    $0x2,%eax
f011df34:	01 d0                	add    %edx,%eax
f011df36:	c1 e0 03             	shl    $0x3,%eax
f011df39:	05 00 20 6b f2       	add    $0xf26b2000,%eax
f011df3e:	8b 10                	mov    (%eax),%edx
f011df40:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011df43:	8b 40 10             	mov    0x10(%eax),%eax
f011df46:	39 c2                	cmp    %eax,%edx
f011df48:	74 17                	je     f011df61 <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011df4a:	83 ec 04             	sub    $0x4,%esp
f011df4d:	68 18 0d 13 f0       	push   $0xf0130d18
f011df52:	68 ab 00 00 00       	push   $0xab
f011df57:	68 62 0c 13 f0       	push   $0xf0130c62
f011df5c:	e8 d8 23 fe ff       	call   f0100339 <_panic>
				i++;
f011df61:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011df64:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011df67:	8b 40 0c             	mov    0xc(%eax),%eax
f011df6a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011df6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011df70:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011df73:	7c b7                	jl     f011df2c <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011df75:	83 ec 0c             	sub    $0xc,%esp
f011df78:	68 80 f0 71 f0       	push   $0xf071f080
f011df7d:	e8 b9 20 ff ff       	call   f011003b <release_spinlock>
f011df82:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011df85:	83 ec 0c             	sub    $0xc,%esp
f011df88:	68 78 0e 13 f0       	push   $0xf0130e78
f011df8d:	e8 f9 2f fe ff       	call   f0100f8b <cprintf>
f011df92:	83 c4 10             	add    $0x10,%esp
}
f011df95:	90                   	nop
f011df96:	c9                   	leave  
f011df97:	c3                   	ret    

f011df98 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011df98:	55                   	push   %ebp
f011df99:	89 e5                	mov    %esp,%ebp
f011df9b:	57                   	push   %edi
f011df9c:	56                   	push   %esi
f011df9d:	53                   	push   %ebx
f011df9e:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011dfa1:	a0 3d 0e 18 f0       	mov    0xf0180e3d,%al
f011dfa6:	84 c0                	test   %al,%al
f011dfa8:	0f 84 ae 01 00 00    	je     f011e15c <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011dfae:	83 ec 0c             	sub    $0xc,%esp
f011dfb1:	6a 01                	push   $0x1
f011dfb3:	e8 fe 10 00 00       	call   f011f0b6 <chksch>
f011dfb8:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011dfbb:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
		int nice_values[] = {15, 5, 0, -5, -15};
f011dfc2:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011dfc5:	bb fc 0e 13 f0       	mov    $0xf0130efc,%ebx
f011dfca:	ba 05 00 00 00       	mov    $0x5,%edx
f011dfcf:	89 c7                	mov    %eax,%edi
f011dfd1:	89 de                	mov    %ebx,%esi
f011dfd3:	89 d1                	mov    %edx,%ecx
f011dfd5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011dfd7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011dfde:	e9 4a 01 00 00       	jmp    f011e12d <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011dfe3:	6a 00                	push   $0x0
f011dfe5:	6a 00                	push   $0x0
f011dfe7:	68 10 27 00 00       	push   $0x2710
f011dfec:	68 b4 0e 13 f0       	push   $0xf0130eb4
f011dff1:	e8 b1 d2 fe ff       	call   f010b2a7 <env_create>
f011dff6:	83 c4 10             	add    $0x10,%esp
f011dff9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011dffc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dfff:	b9 05 00 00 00       	mov    $0x5,%ecx
f011e004:	99                   	cltd   
f011e005:	f7 f9                	idiv   %ecx
f011e007:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011e00a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e00d:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e011:	83 ec 08             	sub    $0x8,%esp
f011e014:	50                   	push   %eax
f011e015:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e018:	e8 d4 88 fe ff       	call   f01068f1 <env_set_nice>
f011e01d:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011e020:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011e024:	75 17                	jne    f011e03d <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011e026:	83 ec 04             	sub    $0x4,%esp
f011e029:	68 49 0c 13 f0       	push   $0xf0130c49
f011e02e:	68 c1 00 00 00       	push   $0xc1
f011e033:	68 62 0c 13 f0       	push   $0xf0130c62
f011e038:	e8 fc 22 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011e03d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e040:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011e046:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011e04b:	74 17                	je     f011e064 <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011e04d:	83 ec 04             	sub    $0x4,%esp
f011e050:	68 80 0c 13 f0       	push   $0xf0130c80
f011e055:	68 c3 00 00 00       	push   $0xc3
f011e05a:	68 62 0c 13 f0       	push   $0xf0130c62
f011e05f:	e8 d5 22 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011e064:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e067:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e06b:	83 c0 0f             	add    $0xf,%eax
f011e06e:	83 f8 1e             	cmp    $0x1e,%eax
f011e071:	0f 87 a5 00 00 00    	ja     f011e11c <test_bsd_nice_2+0x184>
f011e077:	8b 04 85 10 0f 13 f0 	mov    -0xfecf0f0(,%eax,4),%eax
f011e07e:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011e080:	a1 1c ee 71 f0       	mov    0xf071ee1c,%eax
f011e085:	8d 50 01             	lea    0x1(%eax),%edx
f011e088:	89 15 1c ee 71 f0    	mov    %edx,0xf071ee1c
f011e08e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e091:	8b 52 10             	mov    0x10(%edx),%edx
f011e094:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011e09b:	eb 7f                	jmp    f011e11c <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011e09d:	a1 20 ee 71 f0       	mov    0xf071ee20,%eax
f011e0a2:	8d 50 01             	lea    0x1(%eax),%edx
f011e0a5:	89 15 20 ee 71 f0    	mov    %edx,0xf071ee20
f011e0ab:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e0ae:	8b 52 10             	mov    0x10(%edx),%edx
f011e0b1:	83 c0 0a             	add    $0xa,%eax
f011e0b4:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011e0bb:	eb 5f                	jmp    f011e11c <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011e0bd:	a1 24 ee 71 f0       	mov    0xf071ee24,%eax
f011e0c2:	8d 50 01             	lea    0x1(%eax),%edx
f011e0c5:	89 15 24 ee 71 f0    	mov    %edx,0xf071ee24
f011e0cb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e0ce:	8b 52 10             	mov    0x10(%edx),%edx
f011e0d1:	83 c0 14             	add    $0x14,%eax
f011e0d4:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011e0db:	eb 3f                	jmp    f011e11c <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011e0dd:	a1 28 ee 71 f0       	mov    0xf071ee28,%eax
f011e0e2:	8d 50 01             	lea    0x1(%eax),%edx
f011e0e5:	89 15 28 ee 71 f0    	mov    %edx,0xf071ee28
f011e0eb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e0ee:	8b 52 10             	mov    0x10(%edx),%edx
f011e0f1:	83 c0 1e             	add    $0x1e,%eax
f011e0f4:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011e0fb:	eb 1f                	jmp    f011e11c <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011e0fd:	a1 2c ee 71 f0       	mov    0xf071ee2c,%eax
f011e102:	8d 50 01             	lea    0x1(%eax),%edx
f011e105:	89 15 2c ee 71 f0    	mov    %edx,0xf071ee2c
f011e10b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e10e:	8b 52 10             	mov    0x10(%edx),%edx
f011e111:	83 c0 28             	add    $0x28,%eax
f011e114:	89 14 85 00 20 6b f2 	mov    %edx,-0xd94e000(,%eax,4)
				break;
f011e11b:	90                   	nop
			}
			sched_new_env(env);
f011e11c:	83 ec 0c             	sub    $0xc,%esp
f011e11f:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e122:	e8 60 78 fe ff       	call   f0105987 <sched_new_env>
f011e127:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011e12a:	ff 45 e4             	incl   -0x1c(%ebp)
f011e12d:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011e131:	0f 8e ac fe ff ff    	jle    f011dfe3 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011e137:	83 ec 0c             	sub    $0xc,%esp
f011e13a:	68 b0 0c 13 f0       	push   $0xf0130cb0
f011e13f:	e8 47 2e fe ff       	call   f0100f8b <cprintf>
f011e144:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011e147:	83 ec 0c             	sub    $0xc,%esp
f011e14a:	68 ff 0c 13 f0       	push   $0xf0130cff
f011e14f:	e8 a7 3d fe ff       	call   f0101efb <execute_command>
f011e154:	83 c4 10             	add    $0x10,%esp
f011e157:	e9 d0 00 00 00       	jmp    f011e22c <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011e15c:	83 ec 0c             	sub    $0xc,%esp
f011e15f:	6a 00                	push   $0x0
f011e161:	e8 50 0f 00 00       	call   f011f0b6 <chksch>
f011e166:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011e169:	83 ec 0c             	sub    $0xc,%esp
f011e16c:	68 06 0d 13 f0       	push   $0xf0130d06
f011e171:	e8 15 2e fe ff       	call   f0100f8b <cprintf>
f011e176:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011e179:	e8 41 7f fe ff       	call   f01060bf <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011e17e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e185:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011e18c:	e9 8a 00 00 00       	jmp    f011e21b <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e191:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011e198:	eb 55                	jmp    f011e1ef <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011e19a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e19d:	8b 14 85 1c ee 71 f0 	mov    -0xf8e11e4(,%eax,4),%edx
f011e1a4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011e1a7:	89 c8                	mov    %ecx,%eax
f011e1a9:	c1 e0 02             	shl    $0x2,%eax
f011e1ac:	01 c8                	add    %ecx,%eax
f011e1ae:	01 c0                	add    %eax,%eax
f011e1b0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011e1b3:	01 c8                	add    %ecx,%eax
f011e1b5:	8b 04 85 00 20 6b f2 	mov    -0xd94e000(,%eax,4),%eax
f011e1bc:	83 ec 04             	sub    $0x4,%esp
f011e1bf:	52                   	push   %edx
f011e1c0:	ff 75 e0             	pushl  -0x20(%ebp)
f011e1c3:	50                   	push   %eax
f011e1c4:	e8 7f f8 ff ff       	call   f011da48 <find_in_range>
f011e1c9:	83 c4 10             	add    $0x10,%esp
f011e1cc:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011e1cf:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011e1d3:	75 17                	jne    f011e1ec <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011e1d5:	83 ec 04             	sub    $0x4,%esp
f011e1d8:	68 18 0d 13 f0       	push   $0xf0130d18
f011e1dd:	68 ea 00 00 00       	push   $0xea
f011e1e2:	68 62 0c 13 f0       	push   $0xf0130c62
f011e1e7:	e8 4d 21 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e1ec:	ff 45 d8             	incl   -0x28(%ebp)
f011e1ef:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011e1f2:	89 d0                	mov    %edx,%eax
f011e1f4:	c1 e0 02             	shl    $0x2,%eax
f011e1f7:	01 d0                	add    %edx,%eax
f011e1f9:	01 c0                	add    %eax,%eax
f011e1fb:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011e1fe:	01 d0                	add    %edx,%eax
f011e200:	8b 04 85 00 20 6b f2 	mov    -0xd94e000(,%eax,4),%eax
f011e207:	85 c0                	test   %eax,%eax
f011e209:	75 8f                	jne    f011e19a <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011e20b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e20e:	8b 04 85 1c ee 71 f0 	mov    -0xf8e11e4(,%eax,4),%eax
f011e215:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e218:	ff 45 dc             	incl   -0x24(%ebp)
f011e21b:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011e21f:	0f 8e 6c ff ff ff    	jle    f011e191 <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011e225:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011e22c:	83 ec 0c             	sub    $0xc,%esp
f011e22f:	68 c0 0e 13 f0       	push   $0xf0130ec0
f011e234:	e8 52 2d fe ff       	call   f0100f8b <cprintf>
f011e239:	83 c4 10             	add    $0x10,%esp
}
f011e23c:	90                   	nop
f011e23d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011e240:	5b                   	pop    %ebx
f011e241:	5e                   	pop    %esi
f011e242:	5f                   	pop    %edi
f011e243:	5d                   	pop    %ebp
f011e244:	c3                   	ret    

f011e245 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011e245:	55                   	push   %ebp
f011e246:	89 e5                	mov    %esp,%ebp
f011e248:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011e24b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e24e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011e251:	8b 45 08             	mov    0x8(%ebp),%eax
f011e254:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011e257:	89 10                	mov    %edx,(%eax)
}
f011e259:	8b 45 08             	mov    0x8(%ebp),%eax
f011e25c:	c9                   	leave  
f011e25d:	c2 04 00             	ret    $0x4

f011e260 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011e260:	55                   	push   %ebp
f011e261:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011e263:	8b 45 08             	mov    0x8(%ebp),%eax
f011e266:	85 c0                	test   %eax,%eax
f011e268:	78 16                	js     f011e280 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011e26a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e26d:	05 00 20 00 00       	add    $0x2000,%eax
f011e272:	85 c0                	test   %eax,%eax
f011e274:	79 05                	jns    f011e27b <fix_round+0x1b>
f011e276:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011e27b:	c1 f8 0e             	sar    $0xe,%eax
f011e27e:	eb 14                	jmp    f011e294 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011e280:	8b 45 08             	mov    0x8(%ebp),%eax
f011e283:	2d 00 20 00 00       	sub    $0x2000,%eax
f011e288:	85 c0                	test   %eax,%eax
f011e28a:	79 05                	jns    f011e291 <fix_round+0x31>
f011e28c:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011e291:	c1 f8 0e             	sar    $0xe,%eax
}
f011e294:	5d                   	pop    %ebp
f011e295:	c3                   	ret    

f011e296 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011e296:	55                   	push   %ebp
f011e297:	89 e5                	mov    %esp,%ebp
f011e299:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011e29c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011e2a0:	79 16                	jns    f011e2b8 <fix_scale+0x22>
f011e2a2:	68 8c 0f 13 f0       	push   $0xf0130f8c
f011e2a7:	68 93 0f 13 f0       	push   $0xf0130f93
f011e2ac:	6a 5a                	push   $0x5a
f011e2ae:	68 a8 0f 13 f0       	push   $0xf0130fa8
f011e2b3:	e8 81 20 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011e2b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e2bb:	0f af 45 10          	imul   0x10(%ebp),%eax
f011e2bf:	89 c2                	mov    %eax,%edx
f011e2c1:	8b 45 08             	mov    0x8(%ebp),%eax
f011e2c4:	83 ec 08             	sub    $0x8,%esp
f011e2c7:	52                   	push   %edx
f011e2c8:	50                   	push   %eax
f011e2c9:	e8 77 ff ff ff       	call   f011e245 <__mk_fix>
f011e2ce:	83 c4 0c             	add    $0xc,%esp
}
f011e2d1:	8b 45 08             	mov    0x8(%ebp),%eax
f011e2d4:	c9                   	leave  
f011e2d5:	c2 04 00             	ret    $0x4

f011e2d8 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011e2d8:	55                   	push   %ebp
f011e2d9:	89 e5                	mov    %esp,%ebp
f011e2db:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011e2de:	83 ec 08             	sub    $0x8,%esp
f011e2e1:	68 bc 0f 13 f0       	push   $0xf0130fbc
f011e2e6:	68 00 f9 f1 f0       	push   $0xf0f1f900
f011e2eb:	e8 93 1c ff ff       	call   f010ff83 <init_spinlock>
f011e2f0:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011e2f3:	83 ec 0c             	sub    $0xc,%esp
f011e2f6:	68 00 f9 f1 f0       	push   $0xf0f1f900
f011e2fb:	e8 b4 1c ff ff       	call   f010ffb4 <acquire_spinlock>
f011e300:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011e303:	c7 05 68 ef 71 f0 00 	movl   $0x0,0xf071ef68
f011e30a:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011e30d:	83 ec 0c             	sub    $0xc,%esp
f011e310:	68 00 f9 f1 f0       	push   $0xf0f1f900
f011e315:	e8 21 1d ff ff       	call   f011003b <release_spinlock>
f011e31a:	83 c4 10             	add    $0x10,%esp
}
f011e31d:	90                   	nop
f011e31e:	c9                   	leave  
f011e31f:	c3                   	ret    

f011e320 <inctst>:
void inctst()
{
f011e320:	55                   	push   %ebp
f011e321:	89 e5                	mov    %esp,%ebp
f011e323:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011e326:	83 ec 0c             	sub    $0xc,%esp
f011e329:	68 00 f9 f1 f0       	push   $0xf0f1f900
f011e32e:	e8 81 1c ff ff       	call   f010ffb4 <acquire_spinlock>
f011e333:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011e336:	a1 68 ef 71 f0       	mov    0xf071ef68,%eax
f011e33b:	40                   	inc    %eax
f011e33c:	a3 68 ef 71 f0       	mov    %eax,0xf071ef68
	}
	release_spinlock(&tstcntlock);
f011e341:	83 ec 0c             	sub    $0xc,%esp
f011e344:	68 00 f9 f1 f0       	push   $0xf0f1f900
f011e349:	e8 ed 1c ff ff       	call   f011003b <release_spinlock>
f011e34e:	83 c4 10             	add    $0x10,%esp
}
f011e351:	90                   	nop
f011e352:	c9                   	leave  
f011e353:	c3                   	ret    

f011e354 <gettst>:
uint32 gettst()
{
f011e354:	55                   	push   %ebp
f011e355:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011e357:	a1 68 ef 71 f0       	mov    0xf071ef68,%eax
}
f011e35c:	5d                   	pop    %ebp
f011e35d:	c3                   	ret    

f011e35e <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011e35e:	55                   	push   %ebp
f011e35f:	89 e5                	mov    %esp,%ebp
f011e361:	83 ec 28             	sub    $0x28,%esp
f011e364:	8b 45 14             	mov    0x14(%ebp),%eax
f011e367:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011e36a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011e371:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011e375:	83 f8 65             	cmp    $0x65,%eax
f011e378:	74 5d                	je     f011e3d7 <tst+0x79>
f011e37a:	83 f8 65             	cmp    $0x65,%eax
f011e37d:	7f 0a                	jg     f011e389 <tst+0x2b>
f011e37f:	83 f8 62             	cmp    $0x62,%eax
f011e382:	74 73                	je     f011e3f7 <tst+0x99>
f011e384:	e9 91 00 00 00       	jmp    f011e41a <tst+0xbc>
f011e389:	83 f8 67             	cmp    $0x67,%eax
f011e38c:	74 29                	je     f011e3b7 <tst+0x59>
f011e38e:	83 f8 6c             	cmp    $0x6c,%eax
f011e391:	0f 85 83 00 00 00    	jne    f011e41a <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011e397:	8b 45 08             	mov    0x8(%ebp),%eax
f011e39a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e39d:	73 09                	jae    f011e3a8 <tst+0x4a>
			chk = 1;
f011e39f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e3a6:	eb 68                	jmp    f011e410 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011e3a8:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e3ac:	74 62                	je     f011e410 <tst+0xb2>
			chk = 1;
f011e3ae:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e3b5:	eb 59                	jmp    f011e410 <tst+0xb2>
	case 'g':
		if (n > v1)
f011e3b7:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3ba:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e3bd:	76 09                	jbe    f011e3c8 <tst+0x6a>
			chk = 1;
f011e3bf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e3c6:	eb 4b                	jmp    f011e413 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011e3c8:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e3cc:	74 45                	je     f011e413 <tst+0xb5>
			chk = 1;
f011e3ce:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e3d5:	eb 3c                	jmp    f011e413 <tst+0xb5>
	case 'e':
		if (n == v1)
f011e3d7:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3da:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e3dd:	75 09                	jne    f011e3e8 <tst+0x8a>
			chk = 1;
f011e3df:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e3e6:	eb 2e                	jmp    f011e416 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011e3e8:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e3ec:	74 28                	je     f011e416 <tst+0xb8>
			chk = 1;
f011e3ee:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e3f5:	eb 1f                	jmp    f011e416 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011e3f7:	8b 45 08             	mov    0x8(%ebp),%eax
f011e3fa:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e3fd:	72 1a                	jb     f011e419 <tst+0xbb>
f011e3ff:	8b 45 08             	mov    0x8(%ebp),%eax
f011e402:	3b 45 10             	cmp    0x10(%ebp),%eax
f011e405:	77 12                	ja     f011e419 <tst+0xbb>
			chk = 1;
f011e407:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e40e:	eb 09                	jmp    f011e419 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e410:	90                   	nop
f011e411:	eb 07                	jmp    f011e41a <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e413:	90                   	nop
f011e414:	eb 04                	jmp    f011e41a <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e416:	90                   	nop
f011e417:	eb 01                	jmp    f011e41a <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011e419:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011e41a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e41e:	75 14                	jne    f011e434 <tst+0xd6>
f011e420:	83 ec 04             	sub    $0x4,%esp
f011e423:	68 c8 0f 13 f0       	push   $0xf0130fc8
f011e428:	6a 48                	push   $0x48
f011e42a:	68 db 0f 13 f0       	push   $0xf0130fdb
f011e42f:	e8 05 1f fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011e434:	83 ec 0c             	sub    $0xc,%esp
f011e437:	68 00 f9 f1 f0       	push   $0xf0f1f900
f011e43c:	e8 73 1b ff ff       	call   f010ffb4 <acquire_spinlock>
f011e441:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011e444:	a1 68 ef 71 f0       	mov    0xf071ef68,%eax
f011e449:	40                   	inc    %eax
f011e44a:	a3 68 ef 71 f0       	mov    %eax,0xf071ef68
	}
	release_spinlock(&tstcntlock);
f011e44f:	83 ec 0c             	sub    $0xc,%esp
f011e452:	68 00 f9 f1 f0       	push   $0xf0f1f900
f011e457:	e8 df 1b ff ff       	call   f011003b <release_spinlock>
f011e45c:	83 c4 10             	add    $0x10,%esp

	return;
f011e45f:	90                   	nop
}
f011e460:	c9                   	leave  
f011e461:	c3                   	ret    

f011e462 <chktst>:

void chktst(uint32 n)
{
f011e462:	55                   	push   %ebp
f011e463:	89 e5                	mov    %esp,%ebp
f011e465:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011e468:	83 ec 0c             	sub    $0xc,%esp
f011e46b:	68 00 f9 f1 f0       	push   $0xf0f1f900
f011e470:	e8 3f 1b ff ff       	call   f010ffb4 <acquire_spinlock>
f011e475:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011e478:	a1 68 ef 71 f0       	mov    0xf071ef68,%eax
f011e47d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011e480:	83 ec 0c             	sub    $0xc,%esp
f011e483:	68 00 f9 f1 f0       	push   $0xf0f1f900
f011e488:	e8 ae 1b ff ff       	call   f011003b <release_spinlock>
f011e48d:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011e490:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e493:	3b 45 08             	cmp    0x8(%ebp),%eax
f011e496:	75 12                	jne    f011e4aa <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011e498:	83 ec 0c             	sub    $0xc,%esp
f011e49b:	68 f4 0f 13 f0       	push   $0xf0130ff4
f011e4a0:	e8 e6 2a fe ff       	call   f0100f8b <cprintf>
f011e4a5:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011e4a8:	eb 14                	jmp    f011e4be <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011e4aa:	83 ec 04             	sub    $0x4,%esp
f011e4ad:	68 20 10 13 f0       	push   $0xf0131020
f011e4b2:	6a 5e                	push   $0x5e
f011e4b4:	68 db 0f 13 f0       	push   $0xf0130fdb
f011e4b9:	e8 7b 1e fe ff       	call   f0100339 <_panic>
}
f011e4be:	c9                   	leave  
f011e4bf:	c3                   	ret    

f011e4c0 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011e4c0:	55                   	push   %ebp
f011e4c1:	89 e5                	mov    %esp,%ebp
f011e4c3:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e4c6:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e4ca:	77 07                	ja     f011e4d3 <nearest_pow2_ceil+0x13>
f011e4cc:	b8 01 00 00 00       	mov    $0x1,%eax
f011e4d1:	eb 20                	jmp    f011e4f3 <nearest_pow2_ceil+0x33>
	int power = 2;
f011e4d3:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e4da:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e4dd:	eb 08                	jmp    f011e4e7 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011e4df:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e4e2:	01 c0                	add    %eax,%eax
f011e4e4:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011e4e7:	d1 6d 08             	shrl   0x8(%ebp)
f011e4ea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e4ee:	75 ef                	jne    f011e4df <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011e4f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e4f3:	c9                   	leave  
f011e4f4:	c3                   	ret    

f011e4f5 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011e4f5:	55                   	push   %ebp
f011e4f6:	89 e5                	mov    %esp,%ebp
f011e4f8:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e4fb:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e4ff:	77 07                	ja     f011e508 <log2_ceil+0x13>
f011e501:	b8 01 00 00 00       	mov    $0x1,%eax
f011e506:	eb 1b                	jmp    f011e523 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011e508:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e50f:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e512:	eb 03                	jmp    f011e517 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011e514:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011e517:	d1 6d 08             	shrl   0x8(%ebp)
f011e51a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e51e:	75 f4                	jne    f011e514 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011e520:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e523:	c9                   	leave  
f011e524:	c3                   	ret    

f011e525 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011e525:	55                   	push   %ebp
f011e526:	89 e5                	mov    %esp,%ebp
f011e528:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011e52b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011e532:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e539:	eb 12                	jmp    f011e54d <fixedPt2Str+0x28>
		mulFactor *= 10;
f011e53b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e53e:	89 d0                	mov    %edx,%eax
f011e540:	c1 e0 02             	shl    $0x2,%eax
f011e543:	01 d0                	add    %edx,%eax
f011e545:	01 c0                	add    %eax,%eax
f011e547:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011e54a:	ff 45 f0             	incl   -0x10(%ebp)
f011e54d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e550:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e553:	7c e6                	jl     f011e53b <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011e555:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011e558:	83 ec 04             	sub    $0x4,%esp
f011e55b:	ff 75 f4             	pushl  -0xc(%ebp)
f011e55e:	ff 75 08             	pushl  0x8(%ebp)
f011e561:	50                   	push   %eax
f011e562:	e8 2f fd ff ff       	call   f011e296 <fix_scale>
f011e567:	83 c4 0c             	add    $0xc,%esp
f011e56a:	83 ec 0c             	sub    $0xc,%esp
f011e56d:	ff 75 dc             	pushl  -0x24(%ebp)
f011e570:	e8 eb fc ff ff       	call   f011e260 <fix_round>
f011e575:	83 c4 10             	add    $0x10,%esp
f011e578:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011e57b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e57e:	99                   	cltd   
f011e57f:	f7 7d f4             	idivl  -0xc(%ebp)
f011e582:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011e585:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e588:	99                   	cltd   
f011e589:	f7 7d f4             	idivl  -0xc(%ebp)
f011e58c:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011e58f:	83 ec 08             	sub    $0x8,%esp
f011e592:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e595:	50                   	push   %eax
f011e596:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e599:	e8 6a 1e 00 00       	call   f0120408 <ltostr>
f011e59e:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011e5a1:	83 ec 08             	sub    $0x8,%esp
f011e5a4:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e5a7:	50                   	push   %eax
f011e5a8:	ff 75 e0             	pushl  -0x20(%ebp)
f011e5ab:	e8 58 1e 00 00       	call   f0120408 <ltostr>
f011e5b0:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011e5b3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011e5b6:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e5bb:	f7 e9                	imul   %ecx
f011e5bd:	c1 fa 02             	sar    $0x2,%edx
f011e5c0:	89 c8                	mov    %ecx,%eax
f011e5c2:	c1 f8 1f             	sar    $0x1f,%eax
f011e5c5:	29 c2                	sub    %eax,%edx
f011e5c7:	89 d0                	mov    %edx,%eax
f011e5c9:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011e5cc:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011e5d3:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011e5da:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011e5e0:	eb 31                	jmp    f011e613 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011e5e2:	83 ec 04             	sub    $0x4,%esp
f011e5e5:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e5e8:	50                   	push   %eax
f011e5e9:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e5ec:	50                   	push   %eax
f011e5ed:	68 3c 10 13 f0       	push   $0xf013103c
f011e5f2:	e8 ea 1e 00 00       	call   f01204e1 <strcconcat>
f011e5f7:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011e5fa:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011e5fd:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e602:	f7 e9                	imul   %ecx
f011e604:	c1 fa 02             	sar    $0x2,%edx
f011e607:	89 c8                	mov    %ecx,%eax
f011e609:	c1 f8 1f             	sar    $0x1f,%eax
f011e60c:	29 c2                	sub    %eax,%edx
f011e60e:	89 d0                	mov    %edx,%eax
f011e610:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011e613:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e616:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e619:	7c c7                	jl     f011e5e2 <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011e61b:	83 ec 04             	sub    $0x4,%esp
f011e61e:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e621:	50                   	push   %eax
f011e622:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e625:	50                   	push   %eax
f011e626:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e629:	50                   	push   %eax
f011e62a:	e8 b2 1e 00 00       	call   f01204e1 <strcconcat>
f011e62f:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011e632:	83 ec 04             	sub    $0x4,%esp
f011e635:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e638:	50                   	push   %eax
f011e639:	68 3e 10 13 f0       	push   $0xf013103e
f011e63e:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e641:	50                   	push   %eax
f011e642:	e8 9a 1e 00 00       	call   f01204e1 <strcconcat>
f011e647:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011e64a:	83 ec 04             	sub    $0x4,%esp
f011e64d:	ff 75 10             	pushl  0x10(%ebp)
f011e650:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e653:	50                   	push   %eax
f011e654:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e657:	50                   	push   %eax
f011e658:	e8 84 1e 00 00       	call   f01204e1 <strcconcat>
f011e65d:	83 c4 10             	add    $0x10,%esp

}
f011e660:	90                   	nop
f011e661:	c9                   	leave  
f011e662:	c3                   	ret    

f011e663 <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011e663:	55                   	push   %ebp
f011e664:	89 e5                	mov    %esp,%ebp
f011e666:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011e66c:	83 ec 0c             	sub    $0xc,%esp
f011e66f:	68 40 10 13 f0       	push   $0xf0131040
f011e674:	e8 e9 18 00 00       	call   f011ff62 <strlen>
f011e679:	83 c4 10             	add    $0x10,%esp
f011e67c:	83 ec 04             	sub    $0x4,%esp
f011e67f:	50                   	push   %eax
f011e680:	68 40 10 13 f0       	push   $0xf0131040
f011e685:	ff 75 08             	pushl  0x8(%ebp)
f011e688:	e8 19 1a 00 00       	call   f01200a6 <strncmp>
f011e68d:	83 c4 10             	add    $0x10,%esp
f011e690:	85 c0                	test   %eax,%eax
f011e692:	0f 85 8a 00 00 00    	jne    f011e722 <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e698:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011e69b:	50                   	push   %eax
f011e69c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e6a2:	50                   	push   %eax
f011e6a3:	68 4e 10 13 f0       	push   $0xf013104e
f011e6a8:	ff 75 08             	pushl  0x8(%ebp)
f011e6ab:	e8 c7 1e 00 00       	call   f0120577 <strsplit>
f011e6b0:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011e6b3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e6b9:	83 ec 04             	sub    $0x4,%esp
f011e6bc:	6a 0a                	push   $0xa
f011e6be:	6a 00                	push   $0x0
f011e6c0:	50                   	push   %eax
f011e6c1:	e8 fc 1b 00 00       	call   f01202c2 <strtol>
f011e6c6:	83 c4 10             	add    $0x10,%esp
f011e6c9:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011e6cc:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011e6d3:	83 ec 04             	sub    $0x4,%esp
f011e6d6:	6a 00                	push   $0x0
f011e6d8:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e6db:	50                   	push   %eax
f011e6dc:	ff 75 e0             	pushl  -0x20(%ebp)
f011e6df:	e8 91 d6 fe ff       	call   f010bd75 <envid2env>
f011e6e4:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011e6e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e6ea:	8b 40 10             	mov    0x10(%eax),%eax
f011e6ed:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e6f0:	74 19                	je     f011e70b <sys_utilities+0xa8>
f011e6f2:	68 50 10 13 f0       	push   $0xf0131050
f011e6f7:	68 93 0f 13 f0       	push   $0xf0130f93
f011e6fc:	68 a4 00 00 00       	push   $0xa4
f011e701:	68 db 0f 13 f0       	push   $0xf0130fdb
f011e706:	e8 2e 1c fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011e70b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e70e:	83 ec 08             	sub    $0x8,%esp
f011e711:	ff 75 0c             	pushl  0xc(%ebp)
f011e714:	50                   	push   %eax
f011e715:	e8 d7 81 fe ff       	call   f01068f1 <env_set_nice>
f011e71a:	83 c4 10             	add    $0x10,%esp
f011e71d:	e9 12 04 00 00       	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011e722:	83 ec 0c             	sub    $0xc,%esp
f011e725:	68 65 10 13 f0       	push   $0xf0131065
f011e72a:	e8 33 18 00 00       	call   f011ff62 <strlen>
f011e72f:	83 c4 10             	add    $0x10,%esp
f011e732:	83 ec 04             	sub    $0x4,%esp
f011e735:	50                   	push   %eax
f011e736:	68 65 10 13 f0       	push   $0xf0131065
f011e73b:	ff 75 08             	pushl  0x8(%ebp)
f011e73e:	e8 63 19 00 00       	call   f01200a6 <strncmp>
f011e743:	83 c4 10             	add    $0x10,%esp
f011e746:	85 c0                	test   %eax,%eax
f011e748:	0f 85 a6 01 00 00    	jne    f011e8f4 <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011e74e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e751:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e754:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e757:	50                   	push   %eax
f011e758:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e75e:	50                   	push   %eax
f011e75f:	68 4e 10 13 f0       	push   $0xf013104e
f011e764:	ff 75 08             	pushl  0x8(%ebp)
f011e767:	e8 0b 1e 00 00       	call   f0120577 <strsplit>
f011e76c:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011e76f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e775:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011e778:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011e77f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011e786:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011e78d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e790:	8b 00                	mov    (%eax),%eax
f011e792:	85 c0                	test   %eax,%eax
f011e794:	79 1c                	jns    f011e7b2 <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011e796:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011e79d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e7a0:	8b 00                	mov    (%eax),%eax
f011e7a2:	f7 d8                	neg    %eax
f011e7a4:	89 c2                	mov    %eax,%edx
f011e7a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e7a9:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011e7ab:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011e7b2:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011e7b9:	83 ec 0c             	sub    $0xc,%esp
f011e7bc:	68 80 f0 71 f0       	push   $0xf071f080
f011e7c1:	e8 ee 17 ff ff       	call   f010ffb4 <acquire_spinlock>
f011e7c6:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e7c9:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011e7ce:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e7d1:	a1 04 f1 71 f0       	mov    0xf071f104,%eax
f011e7d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e7d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e7dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e7df:	eb 6c                	jmp    f011e84d <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011e7e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e7e4:	83 c0 20             	add    $0x20,%eax
f011e7e7:	83 ec 08             	sub    $0x8,%esp
f011e7ea:	ff 75 d8             	pushl  -0x28(%ebp)
f011e7ed:	50                   	push   %eax
f011e7ee:	e8 7b 18 00 00       	call   f012006e <strcmp>
f011e7f3:	83 c4 10             	add    $0x10,%esp
f011e7f6:	85 c0                	test   %eax,%eax
f011e7f8:	75 46                	jne    f011e840 <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011e7fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e7fd:	8b 00                	mov    (%eax),%eax
f011e7ff:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e802:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e805:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011e807:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e80b:	74 14                	je     f011e821 <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011e80d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e810:	8b 40 10             	mov    0x10(%eax),%eax
f011e813:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e816:	7d 1d                	jge    f011e835 <sys_utilities+0x1d2>
					{
						success = 0;
f011e818:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e81f:	eb 32                	jmp    f011e853 <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011e821:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e824:	8b 40 10             	mov    0x10(%eax),%eax
f011e827:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e82a:	7e 09                	jle    f011e835 <sys_utilities+0x1d2>
					{
						success = 0;
f011e82c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e833:	eb 1e                	jmp    f011e853 <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011e835:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e838:	8b 40 10             	mov    0x10(%eax),%eax
f011e83b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e83e:	eb 01                	jmp    f011e841 <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011e840:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e841:	ff 4d e4             	decl   -0x1c(%ebp)
f011e844:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e847:	8b 40 0c             	mov    0xc(%eax),%eax
f011e84a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e84d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e851:	7f 8e                	jg     f011e7e1 <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e853:	83 ec 0c             	sub    $0xc,%esp
f011e856:	68 80 f0 71 f0       	push   $0xf071f080
f011e85b:	e8 db 17 ff ff       	call   f011003b <release_spinlock>
f011e860:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011e863:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e866:	8b 00                	mov    (%eax),%eax
f011e868:	85 c0                	test   %eax,%eax
f011e86a:	75 06                	jne    f011e872 <sys_utilities+0x20f>
f011e86c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011e870:	75 41                	jne    f011e8b3 <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011e872:	83 ec 0c             	sub    $0xc,%esp
f011e875:	68 78 10 13 f0       	push   $0xf0131078
f011e87a:	e8 0c 27 fe ff       	call   f0100f8b <cprintf>
f011e87f:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011e882:	83 ec 08             	sub    $0x8,%esp
f011e885:	ff 75 d8             	pushl  -0x28(%ebp)
f011e888:	68 a8 10 13 f0       	push   $0xf01310a8
f011e88d:	e8 f9 26 fe ff       	call   f0100f8b <cprintf>
f011e892:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011e895:	83 ec 0c             	sub    $0xc,%esp
f011e898:	68 78 10 13 f0       	push   $0xf0131078
f011e89d:	e8 e9 26 fe ff       	call   f0100f8b <cprintf>
f011e8a2:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011e8a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e8a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011e8ae:	e9 81 02 00 00       	jmp    f011eb34 <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011e8b3:	83 ec 0c             	sub    $0xc,%esp
f011e8b6:	68 c8 10 13 f0       	push   $0xf01310c8
f011e8bb:	e8 cb 26 fe ff       	call   f0100f8b <cprintf>
f011e8c0:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011e8c3:	83 ec 08             	sub    $0x8,%esp
f011e8c6:	ff 75 d8             	pushl  -0x28(%ebp)
f011e8c9:	68 00 11 13 f0       	push   $0xf0131100
f011e8ce:	e8 b8 26 fe ff       	call   f0100f8b <cprintf>
f011e8d3:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011e8d6:	83 ec 0c             	sub    $0xc,%esp
f011e8d9:	68 c8 10 13 f0       	push   $0xf01310c8
f011e8de:	e8 a8 26 fe ff       	call   f0100f8b <cprintf>
f011e8e3:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011e8e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e8e9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011e8ef:	e9 40 02 00 00       	jmp    f011eb34 <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011e8f4:	83 ec 08             	sub    $0x8,%esp
f011e8f7:	68 23 11 13 f0       	push   $0xf0131123
f011e8fc:	ff 75 08             	pushl  0x8(%ebp)
f011e8ff:	e8 6a 17 00 00       	call   f012006e <strcmp>
f011e904:	83 c4 10             	add    $0x10,%esp
f011e907:	85 c0                	test   %eax,%eax
f011e909:	75 77                	jne    f011e982 <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011e90b:	a1 40 0e 18 f0       	mov    0xf0180e40,%eax
f011e910:	85 c0                	test   %eax,%eax
f011e912:	74 34                	je     f011e948 <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011e914:	c7 05 40 0e 18 f0 00 	movl   $0x0,0xf0180e40
f011e91b:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011e91e:	83 ec 08             	sub    $0x8,%esp
f011e921:	68 2d 11 13 f0       	push   $0xf013112d
f011e926:	68 e0 20 6b f2       	push   $0xf26b20e0
f011e92b:	e8 44 1a ff ff       	call   f0110374 <init_channel>
f011e930:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011e933:	83 ec 08             	sub    $0x8,%esp
f011e936:	68 3a 11 13 f0       	push   $0xf013113a
f011e93b:	68 60 22 6b f2       	push   $0xf26b2260
f011e940:	e8 3e 16 ff ff       	call   f010ff83 <init_spinlock>
f011e945:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011e948:	83 ec 0c             	sub    $0xc,%esp
f011e94b:	68 60 22 6b f2       	push   $0xf26b2260
f011e950:	e8 5f 16 ff ff       	call   f010ffb4 <acquire_spinlock>
f011e955:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011e958:	83 ec 08             	sub    $0x8,%esp
f011e95b:	68 60 22 6b f2       	push   $0xf26b2260
f011e960:	68 e0 20 6b f2       	push   $0xf26b20e0
f011e965:	e8 37 1a ff ff       	call   f01103a1 <sleep>
f011e96a:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011e96d:	83 ec 0c             	sub    $0xc,%esp
f011e970:	68 60 22 6b f2       	push   $0xf26b2260
f011e975:	e8 c1 16 ff ff       	call   f011003b <release_spinlock>
f011e97a:	83 c4 10             	add    $0x10,%esp
f011e97d:	e9 b2 01 00 00       	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011e982:	83 ec 08             	sub    $0x8,%esp
f011e985:	68 4c 11 13 f0       	push   $0xf013114c
f011e98a:	ff 75 08             	pushl  0x8(%ebp)
f011e98d:	e8 dc 16 00 00       	call   f012006e <strcmp>
f011e992:	83 c4 10             	add    $0x10,%esp
f011e995:	85 c0                	test   %eax,%eax
f011e997:	75 15                	jne    f011e9ae <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011e999:	83 ec 0c             	sub    $0xc,%esp
f011e99c:	68 e0 20 6b f2       	push   $0xf26b20e0
f011e9a1:	e8 68 1a ff ff       	call   f011040e <wakeup_one>
f011e9a6:	83 c4 10             	add    $0x10,%esp
f011e9a9:	e9 86 01 00 00       	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011e9ae:	83 ec 08             	sub    $0x8,%esp
f011e9b1:	68 5a 11 13 f0       	push   $0xf013115a
f011e9b6:	ff 75 08             	pushl  0x8(%ebp)
f011e9b9:	e8 b0 16 00 00       	call   f012006e <strcmp>
f011e9be:	83 c4 10             	add    $0x10,%esp
f011e9c1:	85 c0                	test   %eax,%eax
f011e9c3:	75 15                	jne    f011e9da <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011e9c5:	83 ec 0c             	sub    $0xc,%esp
f011e9c8:	68 e0 20 6b f2       	push   $0xf26b20e0
f011e9cd:	e8 c0 1a ff ff       	call   f0110492 <wakeup_all>
f011e9d2:	83 c4 10             	add    $0x10,%esp
f011e9d5:	e9 5a 01 00 00       	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011e9da:	83 ec 08             	sub    $0x8,%esp
f011e9dd:	68 68 11 13 f0       	push   $0xf0131168
f011e9e2:	ff 75 08             	pushl  0x8(%ebp)
f011e9e5:	e8 84 16 00 00       	call   f012006e <strcmp>
f011e9ea:	83 c4 10             	add    $0x10,%esp
f011e9ed:	85 c0                	test   %eax,%eax
f011e9ef:	75 17                	jne    f011ea08 <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011e9f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e9f4:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011e9f7:	a1 ec 20 6b f2       	mov    0xf26b20ec,%eax
f011e9fc:	89 c2                	mov    %eax,%edx
f011e9fe:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ea01:	89 10                	mov    %edx,(%eax)
f011ea03:	e9 2c 01 00 00       	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011ea08:	83 ec 08             	sub    $0x8,%esp
f011ea0b:	68 7d 11 13 f0       	push   $0xf013117d
f011ea10:	ff 75 08             	pushl  0x8(%ebp)
f011ea13:	e8 56 16 00 00       	call   f012006e <strcmp>
f011ea18:	83 c4 10             	add    $0x10,%esp
f011ea1b:	85 c0                	test   %eax,%eax
f011ea1d:	75 1a                	jne    f011ea39 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011ea1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea22:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011ea25:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011ea2a:	8b 40 0c             	mov    0xc(%eax),%eax
f011ea2d:	89 c2                	mov    %eax,%edx
f011ea2f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ea32:	89 10                	mov    %edx,(%eax)
f011ea34:	e9 fb 00 00 00       	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011ea39:	83 ec 08             	sub    $0x8,%esp
f011ea3c:	68 93 11 13 f0       	push   $0xf0131193
f011ea41:	ff 75 08             	pushl  0x8(%ebp)
f011ea44:	e8 25 16 00 00       	call   f012006e <strcmp>
f011ea49:	83 c4 10             	add    $0x10,%esp
f011ea4c:	85 c0                	test   %eax,%eax
f011ea4e:	75 3d                	jne    f011ea8d <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011ea50:	a1 44 0e 18 f0       	mov    0xf0180e44,%eax
f011ea55:	85 c0                	test   %eax,%eax
f011ea57:	74 1f                	je     f011ea78 <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011ea59:	c7 05 44 0e 18 f0 00 	movl   $0x0,0xf0180e44
f011ea60:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011ea63:	83 ec 08             	sub    $0x8,%esp
f011ea66:	68 a8 11 13 f0       	push   $0xf01311a8
f011ea6b:	68 40 21 6b f2       	push   $0xf26b2140
f011ea70:	e8 99 17 ff ff       	call   f011020e <init_sleeplock>
f011ea75:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011ea78:	83 ec 0c             	sub    $0xc,%esp
f011ea7b:	68 40 21 6b f2       	push   $0xf26b2140
f011ea80:	e8 4d 18 ff ff       	call   f01102d2 <acquire_sleeplock>
f011ea85:	83 c4 10             	add    $0x10,%esp
f011ea88:	e9 a7 00 00 00       	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011ea8d:	83 ec 08             	sub    $0x8,%esp
f011ea90:	68 b8 11 13 f0       	push   $0xf01311b8
f011ea95:	ff 75 08             	pushl  0x8(%ebp)
f011ea98:	e8 d1 15 00 00       	call   f012006e <strcmp>
f011ea9d:	83 c4 10             	add    $0x10,%esp
f011eaa0:	85 c0                	test   %eax,%eax
f011eaa2:	75 12                	jne    f011eab6 <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011eaa4:	83 ec 0c             	sub    $0xc,%esp
f011eaa7:	68 40 21 6b f2       	push   $0xf26b2140
f011eaac:	e8 7b 18 ff ff       	call   f011032c <release_sleeplock>
f011eab1:	83 c4 10             	add    $0x10,%esp
f011eab4:	eb 7e                	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011eab6:	83 ec 08             	sub    $0x8,%esp
f011eab9:	68 cd 11 13 f0       	push   $0xf01311cd
f011eabe:	ff 75 08             	pushl  0x8(%ebp)
f011eac1:	e8 a8 15 00 00       	call   f012006e <strcmp>
f011eac6:	83 c4 10             	add    $0x10,%esp
f011eac9:	85 c0                	test   %eax,%eax
f011eacb:	75 14                	jne    f011eae1 <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011eacd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ead0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011ead3:	a1 c0 21 6b f2       	mov    0xf26b21c0,%eax
f011ead8:	89 c2                	mov    %eax,%edx
f011eada:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011eadd:	89 10                	mov    %edx,(%eax)
f011eadf:	eb 53                	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011eae1:	83 ec 08             	sub    $0x8,%esp
f011eae4:	68 e2 11 13 f0       	push   $0xf01311e2
f011eae9:	ff 75 08             	pushl  0x8(%ebp)
f011eaec:	e8 7d 15 00 00       	call   f012006e <strcmp>
f011eaf1:	83 c4 10             	add    $0x10,%esp
f011eaf4:	85 c0                	test   %eax,%eax
f011eaf6:	75 13                	jne    f011eb0b <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011eaf8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eafb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011eafe:	8b 15 40 21 6b f2    	mov    0xf26b2140,%edx
f011eb04:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011eb07:	89 10                	mov    %edx,(%eax)
f011eb09:	eb 29                	jmp    f011eb34 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011eb0b:	83 ec 08             	sub    $0x8,%esp
f011eb0e:	68 f3 11 13 f0       	push   $0xf01311f3
f011eb13:	ff 75 08             	pushl  0x8(%ebp)
f011eb16:	e8 53 15 00 00       	call   f012006e <strcmp>
f011eb1b:	83 c4 10             	add    $0x10,%esp
f011eb1e:	85 c0                	test   %eax,%eax
f011eb20:	75 12                	jne    f011eb34 <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011eb22:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eb25:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011eb28:	a1 44 22 6b f2       	mov    0xf26b2244,%eax
f011eb2d:	89 c2                	mov    %eax,%edx
f011eb2f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011eb32:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011eb34:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011eb38:	79 5b                	jns    f011eb95 <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011eb3a:	83 ec 08             	sub    $0x8,%esp
f011eb3d:	68 04 12 13 f0       	push   $0xf0131204
f011eb42:	ff 75 08             	pushl  0x8(%ebp)
f011eb45:	e8 24 15 00 00       	call   f012006e <strcmp>
f011eb4a:	83 c4 10             	add    $0x10,%esp
f011eb4d:	85 c0                	test   %eax,%eax
f011eb4f:	75 44                	jne    f011eb95 <sys_utilities+0x532>
		{
			switch (value)
f011eb51:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eb54:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011eb57:	74 07                	je     f011eb60 <sys_utilities+0x4fd>
f011eb59:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011eb5c:	74 19                	je     f011eb77 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011eb5e:	eb 35                	jmp    f011eb95 <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011eb60:	83 ec 0c             	sub    $0xc,%esp
f011eb63:	68 14 12 13 f0       	push   $0xf0131214
f011eb68:	e8 1e 24 fe ff       	call   f0100f8b <cprintf>
f011eb6d:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011eb70:	e8 a4 0d ff ff       	call   f010f919 <setPageReplacmentAlgorithmFIFO>
				break;
f011eb75:	eb 1e                	jmp    f011eb95 <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011eb77:	83 ec 0c             	sub    $0xc,%esp
f011eb7a:	68 84 12 13 f0       	push   $0xf0131284
f011eb7f:	e8 07 24 fe ff       	call   f0100f8b <cprintf>
f011eb84:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011eb87:	83 ec 0c             	sub    $0xc,%esp
f011eb8a:	6a 02                	push   $0x2
f011eb8c:	e8 45 0d ff ff       	call   f010f8d6 <setPageReplacmentAlgorithmLRU>
f011eb91:	83 c4 10             	add    $0x10,%esp
				break;
f011eb94:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011eb95:	90                   	nop
f011eb96:	c9                   	leave  
f011eb97:	c3                   	ret    

f011eb98 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011eb98:	55                   	push   %ebp
f011eb99:	89 e5                	mov    %esp,%ebp
f011eb9b:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011eb9e:	8b 45 08             	mov    0x8(%ebp),%eax
f011eba1:	8b 00                	mov    (%eax),%eax
f011eba3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011eba6:	8b 45 08             	mov    0x8(%ebp),%eax
f011eba9:	8b 00                	mov    (%eax),%eax
f011ebab:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011ebae:	eb 52                	jmp    f011ec02 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011ebb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ebb3:	8b 00                	mov    (%eax),%eax
f011ebb5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011ebb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ebbb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ebbe:	75 12                	jne    f011ebd2 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011ebc0:	83 ec 0c             	sub    $0xc,%esp
f011ebc3:	68 f8 12 13 f0       	push   $0xf01312f8
f011ebc8:	e8 be 23 fe ff       	call   f0100f8b <cprintf>
f011ebcd:	83 c4 10             	add    $0x10,%esp
			break;
f011ebd0:	eb 3f                	jmp    f011ec11 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011ebd2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ebd6:	74 38                	je     f011ec10 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011ebd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ebdb:	8b 00                	mov    (%eax),%eax
f011ebdd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011ebe0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ebe3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ebe6:	75 12                	jne    f011ebfa <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011ebe8:	83 ec 0c             	sub    $0xc,%esp
f011ebeb:	68 14 13 13 f0       	push   $0xf0131314
f011ebf0:	e8 96 23 fe ff       	call   f0100f8b <cprintf>
f011ebf5:	83 c4 10             	add    $0x10,%esp
			break;
f011ebf8:	eb 17                	jmp    f011ec11 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011ebfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ebfd:	8b 00                	mov    (%eax),%eax
f011ebff:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011ec02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ec06:	74 09                	je     f011ec11 <detect_loop_in_FrameInfo_list+0x79>
f011ec08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ec0c:	75 a2                	jne    f011ebb0 <detect_loop_in_FrameInfo_list+0x18>
f011ec0e:	eb 01                	jmp    f011ec11 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011ec10:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011ec11:	83 ec 0c             	sub    $0xc,%esp
f011ec14:	68 2b 13 13 f0       	push   $0xf013132b
f011ec19:	e8 6d 23 fe ff       	call   f0100f8b <cprintf>
f011ec1e:	83 c4 10             	add    $0x10,%esp
}
f011ec21:	90                   	nop
f011ec22:	c9                   	leave  
f011ec23:	c3                   	ret    

f011ec24 <scarce_memory>:

void scarce_memory()
{
f011ec24:	55                   	push   %ebp
f011ec25:	89 e5                	mov    %esp,%ebp
f011ec27:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011ec2a:	a1 50 f2 b1 f0       	mov    0xf0b1f250,%eax
f011ec2f:	ba 64 00 00 00       	mov    $0x64,%edx
f011ec34:	29 c2                	sub    %eax,%edx
f011ec36:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f011ec3b:	0f af c2             	imul   %edx,%eax
f011ec3e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ec43:	f7 e2                	mul    %edx
f011ec45:	89 d0                	mov    %edx,%eax
f011ec47:	c1 e8 05             	shr    $0x5,%eax
f011ec4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011ec4d:	a1 50 f2 b1 f0       	mov    0xf0b1f250,%eax
f011ec52:	ba 64 00 00 00       	mov    $0x64,%edx
f011ec57:	29 c2                	sub    %eax,%edx
f011ec59:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f011ec5e:	89 d1                	mov    %edx,%ecx
f011ec60:	0f af c8             	imul   %eax,%ecx
f011ec63:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ec68:	f7 e1                	mul    %ecx
f011ec6a:	c1 ea 05             	shr    $0x5,%edx
f011ec6d:	89 d0                	mov    %edx,%eax
f011ec6f:	c1 e0 02             	shl    $0x2,%eax
f011ec72:	01 d0                	add    %edx,%eax
f011ec74:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ec7b:	01 d0                	add    %edx,%eax
f011ec7d:	c1 e0 02             	shl    $0x2,%eax
f011ec80:	29 c1                	sub    %eax,%ecx
f011ec82:	89 ca                	mov    %ecx,%edx
f011ec84:	85 d2                	test   %edx,%edx
f011ec86:	74 03                	je     f011ec8b <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011ec88:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011ec8b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011ec92:	83 ec 0c             	sub    $0xc,%esp
f011ec95:	68 40 f1 b1 f0       	push   $0xf0b1f140
f011ec9a:	e8 15 13 ff ff       	call   f010ffb4 <acquire_spinlock>
f011ec9f:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011eca2:	a1 2c f1 b1 f0       	mov    0xf0b1f12c,%eax
f011eca7:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011ecaa:	8b 15 18 f3 b1 f0    	mov    0xf0b1f318,%edx
f011ecb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ecb3:	29 c2                	sub    %eax,%edx
f011ecb5:	89 d0                	mov    %edx,%eax
f011ecb7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011ecba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ecbd:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011ecc0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011ecc3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011ecca:	eb 12                	jmp    f011ecde <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011eccc:	83 ec 0c             	sub    $0xc,%esp
f011eccf:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011ecd2:	50                   	push   %eax
f011ecd3:	e8 05 98 fe ff       	call   f01084dd <allocate_frame>
f011ecd8:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011ecdb:	ff 45 f0             	incl   -0x10(%ebp)
f011ecde:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ece1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011ece4:	76 e6                	jbe    f011eccc <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011ece6:	83 ec 0c             	sub    $0xc,%esp
f011ece9:	68 40 f1 b1 f0       	push   $0xf0b1f140
f011ecee:	e8 48 13 ff ff       	call   f011003b <release_spinlock>
f011ecf3:	83 c4 10             	add    $0x10,%esp

}
f011ecf6:	90                   	nop
f011ecf7:	c9                   	leave  
f011ecf8:	c3                   	ret    

f011ecf9 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011ecf9:	55                   	push   %ebp
f011ecfa:	89 e5                	mov    %esp,%ebp
f011ecfc:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011ecff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011ed06:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011ed0d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011ed14:	e8 0c d0 fe ff       	call   f010bd25 <get_cpu_proc>
f011ed19:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011ed1c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011ed20:	75 19                	jne    f011ed3b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011ed22:	68 45 13 13 f0       	push   $0xf0131345
f011ed27:	68 93 0f 13 f0       	push   $0xf0130f93
f011ed2c:	68 79 01 00 00       	push   $0x179
f011ed31:	68 db 0f 13 f0       	push   $0xf0130fdb
f011ed36:	e8 fe 15 fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011ed3b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ed3f:	0f 85 d6 01 00 00    	jne    f011ef1b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011ed45:	83 ec 0c             	sub    $0xc,%esp
f011ed48:	68 80 f0 71 f0       	push   $0xf071f080
f011ed4d:	e8 62 12 ff ff       	call   f010ffb4 <acquire_spinlock>
f011ed52:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011ed55:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011ed5c:	e9 d2 00 00 00       	jmp    f011ee33 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011ed61:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ed68:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011ed6d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ed70:	c1 e2 04             	shl    $0x4,%edx
f011ed73:	01 d0                	add    %edx,%eax
f011ed75:	8b 00                	mov    (%eax),%eax
f011ed77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ed7a:	eb 7c                	jmp    f011edf8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011ed7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ed7f:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ed85:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ed88:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ed8b:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ed91:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ed94:	0f af c2             	imul   %edx,%eax
f011ed97:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ed9c:	f7 e2                	mul    %edx
f011ed9e:	89 d0                	mov    %edx,%eax
f011eda0:	c1 e8 05             	shr    $0x5,%eax
f011eda3:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011eda6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eda9:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011edaf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011edb2:	89 d1                	mov    %edx,%ecx
f011edb4:	0f af c8             	imul   %eax,%ecx
f011edb7:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011edbc:	f7 e1                	mul    %ecx
f011edbe:	c1 ea 05             	shr    $0x5,%edx
f011edc1:	89 d0                	mov    %edx,%eax
f011edc3:	c1 e0 02             	shl    $0x2,%eax
f011edc6:	01 d0                	add    %edx,%eax
f011edc8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011edcf:	01 d0                	add    %edx,%eax
f011edd1:	c1 e0 02             	shl    $0x2,%eax
f011edd4:	29 c1                	sub    %eax,%ecx
f011edd6:	89 ca                	mov    %ecx,%edx
f011edd8:	85 d2                	test   %edx,%edx
f011edda:	74 03                	je     f011eddf <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011eddc:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011eddf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ede2:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ede5:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011edea:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eded:	c1 e2 04             	shl    $0x4,%edx
f011edf0:	01 d0                	add    %edx,%eax
f011edf2:	8b 40 08             	mov    0x8(%eax),%eax
f011edf5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011edf8:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011edfd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ee00:	c1 e2 04             	shl    $0x4,%edx
f011ee03:	01 d0                	add    %edx,%eax
f011ee05:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ee09:	74 08                	je     f011ee13 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011ee0b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011ee0e:	8b 52 08             	mov    0x8(%edx),%edx
f011ee11:	eb 05                	jmp    f011ee18 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011ee13:	ba 00 00 00 00       	mov    $0x0,%edx
f011ee18:	89 50 08             	mov    %edx,0x8(%eax)
f011ee1b:	8b 40 08             	mov    0x8(%eax),%eax
f011ee1e:	85 c0                	test   %eax,%eax
f011ee20:	0f 85 56 ff ff ff    	jne    f011ed7c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011ee26:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ee2a:	0f 85 4c ff ff ff    	jne    f011ed7c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011ee30:	ff 45 e8             	incl   -0x18(%ebp)
f011ee33:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f011ee38:	0f b6 c0             	movzbl %al,%eax
f011ee3b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ee3e:	0f 8f 1d ff ff ff    	jg     f011ed61 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011ee44:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011ee4b:	a1 00 f1 71 f0       	mov    0xf071f100,%eax
f011ee50:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ee53:	eb 1a                	jmp    f011ee6f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011ee55:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ee58:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ee5e:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011ee61:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ee64:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011ee67:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f011ee6c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ee6f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ee73:	74 08                	je     f011ee7d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011ee75:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ee78:	8b 40 08             	mov    0x8(%eax),%eax
f011ee7b:	eb 05                	jmp    f011ee82 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011ee7d:	b8 00 00 00 00       	mov    $0x0,%eax
f011ee82:	a3 08 f1 71 f0       	mov    %eax,0xf071f108
f011ee87:	a1 08 f1 71 f0       	mov    0xf071f108,%eax
f011ee8c:	85 c0                	test   %eax,%eax
f011ee8e:	75 c5                	jne    f011ee55 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011ee90:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ee94:	75 bf                	jne    f011ee55 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011ee96:	83 ec 0c             	sub    $0xc,%esp
f011ee99:	68 80 f0 71 f0       	push   $0xf071f080
f011ee9e:	e8 98 11 ff ff       	call   f011003b <release_spinlock>
f011eea3:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011eea6:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011eeaa:	0f 84 d4 00 00 00    	je     f011ef84 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011eeb0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eeb3:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eeb9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011eebc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eebf:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eec5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011eec8:	0f af c2             	imul   %edx,%eax
f011eecb:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011eed0:	f7 e2                	mul    %edx
f011eed2:	89 d0                	mov    %edx,%eax
f011eed4:	c1 e8 05             	shr    $0x5,%eax
f011eed7:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011eeda:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eedd:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eee3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011eee6:	89 d1                	mov    %edx,%ecx
f011eee8:	0f af c8             	imul   %eax,%ecx
f011eeeb:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011eef0:	f7 e1                	mul    %ecx
f011eef2:	c1 ea 05             	shr    $0x5,%edx
f011eef5:	89 d0                	mov    %edx,%eax
f011eef7:	c1 e0 02             	shl    $0x2,%eax
f011eefa:	01 d0                	add    %edx,%eax
f011eefc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ef03:	01 d0                	add    %edx,%eax
f011ef05:	c1 e0 02             	shl    $0x2,%eax
f011ef08:	29 c1                	sub    %eax,%ecx
f011ef0a:	89 ca                	mov    %ecx,%edx
f011ef0c:	85 d2                	test   %edx,%edx
f011ef0e:	74 03                	je     f011ef13 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011ef10:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ef13:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ef16:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ef19:	eb 69                	jmp    f011ef84 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011ef1b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ef1e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ef24:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ef27:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ef2a:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ef30:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ef33:	0f af c2             	imul   %edx,%eax
f011ef36:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ef3b:	f7 e2                	mul    %edx
f011ef3d:	89 d0                	mov    %edx,%eax
f011ef3f:	c1 e8 05             	shr    $0x5,%eax
f011ef42:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ef45:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ef48:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ef4e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ef51:	89 d1                	mov    %edx,%ecx
f011ef53:	0f af c8             	imul   %eax,%ecx
f011ef56:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ef5b:	f7 e1                	mul    %ecx
f011ef5d:	c1 ea 05             	shr    $0x5,%edx
f011ef60:	89 d0                	mov    %edx,%eax
f011ef62:	c1 e0 02             	shl    $0x2,%eax
f011ef65:	01 d0                	add    %edx,%eax
f011ef67:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ef6e:	01 d0                	add    %edx,%eax
f011ef70:	c1 e0 02             	shl    $0x2,%eax
f011ef73:	29 c1                	sub    %eax,%ecx
f011ef75:	89 ca                	mov    %ecx,%edx
f011ef77:	85 d2                	test   %edx,%edx
f011ef79:	74 03                	je     f011ef7e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011ef7b:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ef7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ef81:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011ef84:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ef87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ef8a:	01 c2                	add    %eax,%edx
f011ef8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ef8f:	01 d0                	add    %edx,%eax
}
f011ef91:	c9                   	leave  
f011ef92:	c3                   	ret    

f011ef93 <schenv>:


void schenv()
{
f011ef93:	55                   	push   %ebp
f011ef94:	89 e5                	mov    %esp,%ebp
f011ef96:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011ef99:	c6 05 e0 f8 f1 f0 00 	movb   $0x0,0xf0f1f8e0
	__ne = NULL;
f011efa0:	c7 05 6c f5 b1 f0 00 	movl   $0x0,0xf0b1f56c
f011efa7:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011efaa:	83 ec 0c             	sub    $0xc,%esp
f011efad:	68 80 f0 71 f0       	push   $0xf071f080
f011efb2:	e8 fd 0f ff ff       	call   f010ffb4 <acquire_spinlock>
f011efb7:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011efba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011efc1:	eb 3f                	jmp    f011f002 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011efc3:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011efc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011efcb:	c1 e2 04             	shl    $0x4,%edx
f011efce:	01 d0                	add    %edx,%eax
f011efd0:	83 ec 0c             	sub    $0xc,%esp
f011efd3:	50                   	push   %eax
f011efd4:	e8 a7 61 fe ff       	call   f0105180 <queue_size>
f011efd9:	83 c4 10             	add    $0x10,%esp
f011efdc:	85 c0                	test   %eax,%eax
f011efde:	74 1f                	je     f011efff <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011efe0:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011efe5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011efe8:	c1 e2 04             	shl    $0x4,%edx
f011efeb:	01 d0                	add    %edx,%eax
f011efed:	8b 40 04             	mov    0x4(%eax),%eax
f011eff0:	a3 6c f5 b1 f0       	mov    %eax,0xf0b1f56c
				__nl = i;
f011eff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eff8:	a2 e0 f8 f1 f0       	mov    %al,0xf0f1f8e0
				break;
f011effd:	eb 10                	jmp    f011f00f <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011efff:	ff 45 f4             	incl   -0xc(%ebp)
f011f002:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f011f007:	0f b6 c0             	movzbl %al,%eax
f011f00a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f00d:	7f b4                	jg     f011efc3 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011f00f:	83 ec 0c             	sub    $0xc,%esp
f011f012:	68 80 f0 71 f0       	push   $0xf071f080
f011f017:	e8 1f 10 ff ff       	call   f011003b <release_spinlock>
f011f01c:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011f01f:	e8 01 cd fe ff       	call   f010bd25 <get_cpu_proc>
f011f024:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011f027:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f02b:	0f 84 82 00 00 00    	je     f011f0b3 <schenv+0x120>
	{
		if (__ne != NULL)
f011f031:	a1 6c f5 b1 f0       	mov    0xf0b1f56c,%eax
f011f036:	85 c0                	test   %eax,%eax
f011f038:	74 49                	je     f011f083 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011f03a:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011f03f:	0f b6 c0             	movzbl %al,%eax
f011f042:	8d 50 01             	lea    0x1(%eax),%edx
f011f045:	a0 e0 f8 f1 f0       	mov    0xf0f1f8e0,%al
f011f04a:	0f b6 c0             	movzbl %al,%eax
f011f04d:	39 c2                	cmp    %eax,%edx
f011f04f:	7d 62                	jge    f011f0b3 <schenv+0x120>
			{
				__ne = cur_env;
f011f051:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f054:	a3 6c f5 b1 f0       	mov    %eax,0xf0b1f56c
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011f059:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011f05e:	0f b6 c0             	movzbl %al,%eax
f011f061:	8a 15 44 f8 f1 f0    	mov    0xf0f1f844,%dl
f011f067:	0f b6 d2             	movzbl %dl,%edx
f011f06a:	4a                   	dec    %edx
f011f06b:	39 d0                	cmp    %edx,%eax
f011f06d:	7d 08                	jge    f011f077 <schenv+0xe4>
f011f06f:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011f074:	40                   	inc    %eax
f011f075:	eb 05                	jmp    f011f07c <schenv+0xe9>
f011f077:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011f07c:	a2 e0 f8 f1 f0       	mov    %al,0xf0f1f8e0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011f081:	eb 30                	jmp    f011f0b3 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011f083:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f086:	a3 6c f5 b1 f0       	mov    %eax,0xf0b1f56c
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011f08b:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011f090:	0f b6 c0             	movzbl %al,%eax
f011f093:	8a 15 44 f8 f1 f0    	mov    0xf0f1f844,%dl
f011f099:	0f b6 d2             	movzbl %dl,%edx
f011f09c:	4a                   	dec    %edx
f011f09d:	39 d0                	cmp    %edx,%eax
f011f09f:	7d 08                	jge    f011f0a9 <schenv+0x116>
f011f0a1:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011f0a6:	40                   	inc    %eax
f011f0a7:	eb 05                	jmp    f011f0ae <schenv+0x11b>
f011f0a9:	a0 61 f0 71 f0       	mov    0xf071f061,%al
f011f0ae:	a2 e0 f8 f1 f0       	mov    %al,0xf0f1f8e0
		}
	}
}
f011f0b3:	90                   	nop
f011f0b4:	c9                   	leave  
f011f0b5:	c3                   	ret    

f011f0b6 <chksch>:

void chksch(uint8 onoff)
{
f011f0b6:	55                   	push   %ebp
f011f0b7:	89 e5                	mov    %esp,%ebp
f011f0b9:	83 ec 18             	sub    $0x18,%esp
f011f0bc:	8b 45 08             	mov    0x8(%ebp),%eax
f011f0bf:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f0c2:	e8 f4 78 fe ff       	call   f01069bb <isSchedMethodBSD>
f011f0c7:	85 c0                	test   %eax,%eax
f011f0c9:	74 48                	je     f011f113 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011f0cb:	e8 5b 78 fe ff       	call   f010692b <get_load_average>
f011f0d0:	a3 68 f8 f1 f0       	mov    %eax,0xf0f1f868
f011f0d5:	a1 68 f8 f1 f0       	mov    0xf0f1f868,%eax
f011f0da:	a3 1c f3 b1 f0       	mov    %eax,0xf0b1f31c
		acquire_spinlock(&ProcessQueues.qlock);
f011f0df:	83 ec 0c             	sub    $0xc,%esp
f011f0e2:	68 80 f0 71 f0       	push   $0xf071f080
f011f0e7:	e8 c8 0e ff ff       	call   f010ffb4 <acquire_spinlock>
f011f0ec:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011f0ef:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011f0f4:	a3 c0 f1 b1 f0       	mov    %eax,0xf0b1f1c0
		}
		release_spinlock(&ProcessQueues.qlock);
f011f0f9:	83 ec 0c             	sub    $0xc,%esp
f011f0fc:	68 80 f0 71 f0       	push   $0xf071f080
f011f101:	e8 35 0f ff ff       	call   f011003b <release_spinlock>
f011f106:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011f109:	c7 05 7c f5 b1 f0 01 	movl   $0x1,0xf0b1f57c
f011f110:	00 00 00 
	}
	__chkstatus = onoff;
f011f113:	8a 45 f4             	mov    -0xc(%ebp),%al
f011f116:	a2 68 f5 b1 f0       	mov    %al,0xf0b1f568
}
f011f11b:	90                   	nop
f011f11c:	c9                   	leave  
f011f11d:	c3                   	ret    

f011f11e <chk1>:
void chk1()
{
f011f11e:	55                   	push   %ebp
f011f11f:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011f121:	90                   	nop
f011f122:	5d                   	pop    %ebp
f011f123:	c3                   	ret    

f011f124 <chk2>:
void chk2(struct Env* __se)
{
f011f124:	55                   	push   %ebp
f011f125:	89 e5                	mov    %esp,%ebp
f011f127:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011f12a:	a0 68 f5 b1 f0       	mov    0xf0b1f568,%al
f011f12f:	84 c0                	test   %al,%al
f011f131:	0f 84 59 03 00 00    	je     f011f490 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f137:	e8 7f 78 fe ff       	call   f01069bb <isSchedMethodBSD>
f011f13c:	85 c0                	test   %eax,%eax
f011f13e:	0f 84 4d 03 00 00    	je     f011f491 <chk2+0x36d>
	{
		__nla = get_load_average();
f011f144:	e8 e2 77 fe ff       	call   f010692b <get_load_average>
f011f149:	a3 54 f2 b1 f0       	mov    %eax,0xf0b1f254
		acquire_spinlock(&ProcessQueues.qlock);
f011f14e:	83 ec 0c             	sub    $0xc,%esp
f011f151:	68 80 f0 71 f0       	push   $0xf071f080
f011f156:	e8 59 0e ff ff       	call   f010ffb4 <acquire_spinlock>
f011f15b:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011f15e:	a1 0c f1 71 f0       	mov    0xf071f10c,%eax
f011f163:	a3 70 f5 b1 f0       	mov    %eax,0xf0b1f570
		}
		release_spinlock(&ProcessQueues.qlock);
f011f168:	83 ec 0c             	sub    $0xc,%esp
f011f16b:	68 80 f0 71 f0       	push   $0xf071f080
f011f170:	e8 c6 0e ff ff       	call   f011003b <release_spinlock>
f011f175:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011f178:	a1 7c f5 b1 f0       	mov    0xf0b1f57c,%eax
f011f17d:	85 c0                	test   %eax,%eax
f011f17f:	74 72                	je     f011f1f3 <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011f181:	83 ec 0c             	sub    $0xc,%esp
f011f184:	68 80 f0 71 f0       	push   $0xf071f080
f011f189:	e8 26 0e ff ff       	call   f010ffb4 <acquire_spinlock>
f011f18e:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011f191:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f195:	0f 95 c0             	setne  %al
f011f198:	0f b6 c0             	movzbl %al,%eax
f011f19b:	a3 34 f7 b1 f0       	mov    %eax,0xf0b1f734
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f1a0:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f011f1a5:	0f b6 c0             	movzbl %al,%eax
f011f1a8:	48                   	dec    %eax
f011f1a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f1ac:	eb 20                	jmp    f011f1ce <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f1ae:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011f1b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f1b6:	c1 e2 04             	shl    $0x4,%edx
f011f1b9:	01 d0                	add    %edx,%eax
f011f1bb:	8b 40 0c             	mov    0xc(%eax),%eax
f011f1be:	8b 15 34 f7 b1 f0    	mov    0xf0b1f734,%edx
f011f1c4:	01 d0                	add    %edx,%eax
f011f1c6:	a3 34 f7 b1 f0       	mov    %eax,0xf0b1f734
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f1cb:	ff 4d f4             	decl   -0xc(%ebp)
f011f1ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f1d2:	79 da                	jns    f011f1ae <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011f1d4:	c7 05 7c f5 b1 f0 00 	movl   $0x0,0xf0b1f57c
f011f1db:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011f1de:	83 ec 0c             	sub    $0xc,%esp
f011f1e1:	68 80 f0 71 f0       	push   $0xf071f080
f011f1e6:	e8 50 0e ff ff       	call   f011003b <release_spinlock>
f011f1eb:	83 c4 10             	add    $0x10,%esp
f011f1ee:	e9 91 02 00 00       	jmp    f011f484 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011f1f3:	8b 15 c0 f1 b1 f0    	mov    0xf0b1f1c0,%edx
f011f1f9:	a1 70 f5 b1 f0       	mov    0xf0b1f570,%eax
f011f1fe:	39 c2                	cmp    %eax,%edx
f011f200:	74 63                	je     f011f265 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011f202:	83 ec 0c             	sub    $0xc,%esp
f011f205:	68 80 f0 71 f0       	push   $0xf071f080
f011f20a:	e8 a5 0d ff ff       	call   f010ffb4 <acquire_spinlock>
f011f20f:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011f212:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f216:	0f 95 c0             	setne  %al
f011f219:	0f b6 c0             	movzbl %al,%eax
f011f21c:	a3 34 f7 b1 f0       	mov    %eax,0xf0b1f734
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f221:	a0 44 f8 f1 f0       	mov    0xf0f1f844,%al
f011f226:	0f b6 c0             	movzbl %al,%eax
f011f229:	48                   	dec    %eax
f011f22a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f22d:	eb 20                	jmp    f011f24f <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f22f:	a1 10 f1 71 f0       	mov    0xf071f110,%eax
f011f234:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f237:	c1 e2 04             	shl    $0x4,%edx
f011f23a:	01 d0                	add    %edx,%eax
f011f23c:	8b 40 0c             	mov    0xc(%eax),%eax
f011f23f:	8b 15 34 f7 b1 f0    	mov    0xf0b1f734,%edx
f011f245:	01 d0                	add    %edx,%eax
f011f247:	a3 34 f7 b1 f0       	mov    %eax,0xf0b1f734
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f24c:	ff 4d f0             	decl   -0x10(%ebp)
f011f24f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f253:	79 da                	jns    f011f22f <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011f255:	83 ec 0c             	sub    $0xc,%esp
f011f258:	68 80 f0 71 f0       	push   $0xf071f080
f011f25d:	e8 d9 0d ff ff       	call   f011003b <release_spinlock>
f011f262:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011f265:	e8 5a 76 fe ff       	call   f01068c4 <timer_ticks>
f011f26a:	6a 00                	push   $0x0
f011f26c:	68 e8 03 00 00       	push   $0x3e8
f011f271:	52                   	push   %edx
f011f272:	50                   	push   %eax
f011f273:	e8 bc 31 00 00       	call   f0122434 <__moddi3>
f011f278:	83 c4 10             	add    $0x10,%esp
f011f27b:	09 d0                	or     %edx,%eax
f011f27d:	85 c0                	test   %eax,%eax
f011f27f:	75 32                	jne    f011f2b3 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011f281:	8b 15 1c f3 b1 f0    	mov    0xf0b1f31c,%edx
f011f287:	a1 54 f2 b1 f0       	mov    0xf0b1f254,%eax
f011f28c:	39 c2                	cmp    %eax,%edx
f011f28e:	75 19                	jne    f011f2a9 <chk2+0x185>
f011f290:	68 55 13 13 f0       	push   $0xf0131355
f011f295:	68 93 0f 13 f0       	push   $0xf0130f93
f011f29a:	68 35 02 00 00       	push   $0x235
f011f29f:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f2a4:	e8 20 11 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011f2a9:	a1 54 f2 b1 f0       	mov    0xf0b1f254,%eax
f011f2ae:	a3 1c f3 b1 f0       	mov    %eax,0xf0b1f31c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011f2b3:	e8 0c 76 fe ff       	call   f01068c4 <timer_ticks>
f011f2b8:	6a 00                	push   $0x0
f011f2ba:	6a 64                	push   $0x64
f011f2bc:	52                   	push   %edx
f011f2bd:	50                   	push   %eax
f011f2be:	e8 71 31 00 00       	call   f0122434 <__moddi3>
f011f2c3:	83 c4 10             	add    $0x10,%esp
f011f2c6:	09 d0                	or     %edx,%eax
f011f2c8:	85 c0                	test   %eax,%eax
f011f2ca:	0f 85 b4 01 00 00    	jne    f011f484 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011f2d0:	8b 0d 68 f8 f1 f0    	mov    0xf0f1f868,%ecx
f011f2d6:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f2db:	f7 e9                	imul   %ecx
f011f2dd:	c1 fa 05             	sar    $0x5,%edx
f011f2e0:	89 c8                	mov    %ecx,%eax
f011f2e2:	c1 f8 1f             	sar    $0x1f,%eax
f011f2e5:	29 c2                	sub    %eax,%edx
f011f2e7:	89 d0                	mov    %edx,%eax
f011f2e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011f2ec:	8b 0d 68 f8 f1 f0    	mov    0xf0f1f868,%ecx
f011f2f2:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f2f7:	f7 e9                	imul   %ecx
f011f2f9:	c1 fa 05             	sar    $0x5,%edx
f011f2fc:	89 c8                	mov    %ecx,%eax
f011f2fe:	c1 f8 1f             	sar    $0x1f,%eax
f011f301:	29 c2                	sub    %eax,%edx
f011f303:	89 d0                	mov    %edx,%eax
f011f305:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f308:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f30b:	89 d0                	mov    %edx,%eax
f011f30d:	c1 e0 02             	shl    $0x2,%eax
f011f310:	01 d0                	add    %edx,%eax
f011f312:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f319:	01 d0                	add    %edx,%eax
f011f31b:	c1 e0 02             	shl    $0x2,%eax
f011f31e:	29 c1                	sub    %eax,%ecx
f011f320:	89 c8                	mov    %ecx,%eax
f011f322:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011f325:	8b 0d 54 f2 b1 f0    	mov    0xf0b1f254,%ecx
f011f32b:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f330:	f7 e9                	imul   %ecx
f011f332:	c1 fa 05             	sar    $0x5,%edx
f011f335:	89 c8                	mov    %ecx,%eax
f011f337:	c1 f8 1f             	sar    $0x1f,%eax
f011f33a:	29 c2                	sub    %eax,%edx
f011f33c:	89 d0                	mov    %edx,%eax
f011f33e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011f341:	8b 0d 54 f2 b1 f0    	mov    0xf0b1f254,%ecx
f011f347:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f34c:	f7 e9                	imul   %ecx
f011f34e:	c1 fa 05             	sar    $0x5,%edx
f011f351:	89 c8                	mov    %ecx,%eax
f011f353:	c1 f8 1f             	sar    $0x1f,%eax
f011f356:	29 c2                	sub    %eax,%edx
f011f358:	89 d0                	mov    %edx,%eax
f011f35a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f35d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f360:	89 d0                	mov    %edx,%eax
f011f362:	c1 e0 02             	shl    $0x2,%eax
f011f365:	01 d0                	add    %edx,%eax
f011f367:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f36e:	01 d0                	add    %edx,%eax
f011f370:	c1 e0 02             	shl    $0x2,%eax
f011f373:	29 c1                	sub    %eax,%ecx
f011f375:	89 c8                	mov    %ecx,%eax
f011f377:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011f37a:	8b 15 70 f5 b1 f0    	mov    0xf0b1f570,%edx
f011f380:	a1 c0 f1 b1 f0       	mov    0xf0b1f1c0,%eax
f011f385:	39 c2                	cmp    %eax,%edx
f011f387:	0f 85 ed 00 00 00    	jne    f011f47a <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011f38d:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f392:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f395:	7e 5b                	jle    f011f3f2 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f397:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f39c:	83 ec 08             	sub    $0x8,%esp
f011f39f:	ff 75 e0             	pushl  -0x20(%ebp)
f011f3a2:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f3a5:	ff 75 e8             	pushl  -0x18(%ebp)
f011f3a8:	ff 75 ec             	pushl  -0x14(%ebp)
f011f3ab:	50                   	push   %eax
f011f3ac:	68 68 13 13 f0       	push   $0xf0131368
f011f3b1:	e8 d5 1b fe ff       	call   f0100f8b <cprintf>
f011f3b6:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011f3b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f3bc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f3bf:	0f 8f b5 00 00 00    	jg     f011f47a <chk2+0x356>
f011f3c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f3c8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f3cb:	75 0c                	jne    f011f3d9 <chk2+0x2b5>
f011f3cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f3d0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f3d3:	0f 8d a1 00 00 00    	jge    f011f47a <chk2+0x356>
f011f3d9:	68 b0 13 13 f0       	push   $0xf01313b0
f011f3de:	68 93 0f 13 f0       	push   $0xf0130f93
f011f3e3:	68 4a 02 00 00       	push   $0x24a
f011f3e8:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f3ed:	e8 d7 0f fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011f3f2:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f3f7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f3fa:	7d 53                	jge    f011f44f <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f3fc:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f401:	83 ec 08             	sub    $0x8,%esp
f011f404:	ff 75 e0             	pushl  -0x20(%ebp)
f011f407:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f40a:	ff 75 e8             	pushl  -0x18(%ebp)
f011f40d:	ff 75 ec             	pushl  -0x14(%ebp)
f011f410:	50                   	push   %eax
f011f411:	68 f0 13 13 f0       	push   $0xf01313f0
f011f416:	e8 70 1b fe ff       	call   f0100f8b <cprintf>
f011f41b:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011f41e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f421:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f424:	7c 54                	jl     f011f47a <chk2+0x356>
f011f426:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f429:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f42c:	75 08                	jne    f011f436 <chk2+0x312>
f011f42e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f431:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f434:	7e 44                	jle    f011f47a <chk2+0x356>
f011f436:	68 38 14 13 f0       	push   $0xf0131438
f011f43b:	68 93 0f 13 f0       	push   $0xf0130f93
f011f440:	68 50 02 00 00       	push   $0x250
f011f445:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f44a:	e8 7a 0f fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011f44f:	a1 34 f7 b1 f0       	mov    0xf0b1f734,%eax
f011f454:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f457:	75 21                	jne    f011f47a <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011f459:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f45c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f45f:	74 19                	je     f011f47a <chk2+0x356>
f011f461:	68 78 14 13 f0       	push   $0xf0131478
f011f466:	68 93 0f 13 f0       	push   $0xf0130f93
f011f46b:	68 54 02 00 00       	push   $0x254
f011f470:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f475:	e8 4f 0f fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011f47a:	a1 54 f2 b1 f0       	mov    0xf0b1f254,%eax
f011f47f:	a3 68 f8 f1 f0       	mov    %eax,0xf0f1f868
			}
		}
		__pnexit = __nnexit;
f011f484:	a1 70 f5 b1 f0       	mov    0xf0b1f570,%eax
f011f489:	a3 c0 f1 b1 f0       	mov    %eax,0xf0b1f1c0
f011f48e:	eb 01                	jmp    f011f491 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011f490:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011f491:	c9                   	leave  
f011f492:	c3                   	ret    

f011f493 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011f493:	55                   	push   %ebp
f011f494:	89 e5                	mov    %esp,%ebp
f011f496:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f499:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f4a0:	eb 40                	jmp    f011f4e2 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011f4a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f4a5:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f4ab:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011f4b0:	83 ec 08             	sub    $0x8,%esp
f011f4b3:	52                   	push   %edx
f011f4b4:	50                   	push   %eax
f011f4b5:	e8 af 01 00 00       	call   f011f669 <check_va2pa>
f011f4ba:	83 c4 10             	add    $0x10,%esp
f011f4bd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f4c0:	74 19                	je     f011f4db <check_boot_pgdir+0x48>
f011f4c2:	68 8c 14 13 f0       	push   $0xf013148c
f011f4c7:	68 93 0f 13 f0       	push   $0xf0130f93
f011f4cc:	68 9b 02 00 00       	push   $0x29b
f011f4d1:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f4d6:	e8 5e 0e fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f4db:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f4e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f4e5:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f4eb:	a1 b0 f7 f1 f0       	mov    0xf0f1f7b0,%eax
f011f4f0:	39 c2                	cmp    %eax,%edx
f011f4f2:	72 ae                	jb     f011f4a2 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f4f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f4fb:	e9 81 00 00 00       	jmp    f011f581 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011f500:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f503:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011f508:	85 c0                	test   %eax,%eax
f011f50a:	74 6d                	je     f011f579 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011f50c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f50f:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011f515:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011f51a:	83 ec 08             	sub    $0x8,%esp
f011f51d:	52                   	push   %edx
f011f51e:	50                   	push   %eax
f011f51f:	e8 45 01 00 00       	call   f011f669 <check_va2pa>
f011f524:	83 c4 10             	add    $0x10,%esp
f011f527:	c7 45 f0 00 80 17 f0 	movl   $0xf0178000,-0x10(%ebp)
f011f52e:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011f535:	77 17                	ja     f011f54e <check_boot_pgdir+0xbb>
f011f537:	ff 75 f0             	pushl  -0x10(%ebp)
f011f53a:	68 c4 14 13 f0       	push   $0xf01314c4
f011f53f:	68 a9 02 00 00       	push   $0x2a9
f011f544:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f549:	e8 eb 0d fe ff       	call   f0100339 <_panic>
f011f54e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f551:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011f557:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f55a:	01 ca                	add    %ecx,%edx
f011f55c:	39 d0                	cmp    %edx,%eax
f011f55e:	74 1a                	je     f011f57a <check_boot_pgdir+0xe7>
f011f560:	68 f8 14 13 f0       	push   $0xf01314f8
f011f565:	68 93 0f 13 f0       	push   $0xf0130f93
f011f56a:	68 a9 02 00 00       	push   $0x2a9
f011f56f:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f574:	e8 c0 0d fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011f579:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f57a:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f581:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011f588:	0f 86 72 ff ff ff    	jbe    f011f500 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f58e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f595:	e9 af 00 00 00       	jmp    f011f649 <check_boot_pgdir+0x1b6>
		switch (i) {
f011f59a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f59d:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f5a2:	74 11                	je     f011f5b5 <check_boot_pgdir+0x122>
f011f5a4:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f5a9:	72 36                	jb     f011f5e1 <check_boot_pgdir+0x14e>
f011f5ab:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011f5b0:	83 f8 02             	cmp    $0x2,%eax
f011f5b3:	77 2c                	ja     f011f5e1 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011f5b5:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011f5ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f5bd:	c1 e2 02             	shl    $0x2,%edx
f011f5c0:	01 d0                	add    %edx,%eax
f011f5c2:	8b 00                	mov    (%eax),%eax
f011f5c4:	85 c0                	test   %eax,%eax
f011f5c6:	75 7a                	jne    f011f642 <check_boot_pgdir+0x1af>
f011f5c8:	68 7e 15 13 f0       	push   $0xf013157e
f011f5cd:	68 93 0f 13 f0       	push   $0xf0130f93
f011f5d2:	68 b4 02 00 00       	push   $0x2b4
f011f5d7:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f5dc:	e8 58 0d fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011f5e1:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011f5e8:	76 2c                	jbe    f011f616 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011f5ea:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011f5ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f5f2:	c1 e2 02             	shl    $0x2,%edx
f011f5f5:	01 d0                	add    %edx,%eax
f011f5f7:	8b 00                	mov    (%eax),%eax
f011f5f9:	85 c0                	test   %eax,%eax
f011f5fb:	75 48                	jne    f011f645 <check_boot_pgdir+0x1b2>
f011f5fd:	68 7e 15 13 f0       	push   $0xf013157e
f011f602:	68 93 0f 13 f0       	push   $0xf0130f93
f011f607:	68 b8 02 00 00       	push   $0x2b8
f011f60c:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f611:	e8 23 0d fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011f616:	a1 b4 f7 f1 f0       	mov    0xf0f1f7b4,%eax
f011f61b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f61e:	c1 e2 02             	shl    $0x2,%edx
f011f621:	01 d0                	add    %edx,%eax
f011f623:	8b 00                	mov    (%eax),%eax
f011f625:	85 c0                	test   %eax,%eax
f011f627:	74 1c                	je     f011f645 <check_boot_pgdir+0x1b2>
f011f629:	68 94 15 13 f0       	push   $0xf0131594
f011f62e:	68 93 0f 13 f0       	push   $0xf0130f93
f011f633:	68 ba 02 00 00       	push   $0x2ba
f011f638:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f63d:	e8 f7 0c fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011f642:	90                   	nop
f011f643:	eb 01                	jmp    f011f646 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011f645:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f646:	ff 45 f4             	incl   -0xc(%ebp)
f011f649:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011f650:	0f 86 44 ff ff ff    	jbe    f011f59a <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011f656:	83 ec 0c             	sub    $0xc,%esp
f011f659:	68 b0 15 13 f0       	push   $0xf01315b0
f011f65e:	e8 28 19 fe ff       	call   f0100f8b <cprintf>
f011f663:	83 c4 10             	add    $0x10,%esp
}
f011f666:	90                   	nop
f011f667:	c9                   	leave  
f011f668:	c3                   	ret    

f011f669 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011f669:	55                   	push   %ebp
f011f66a:	89 e5                	mov    %esp,%ebp
f011f66c:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011f66f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f672:	c1 e8 16             	shr    $0x16,%eax
f011f675:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f67c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f67f:	01 d0                	add    %edx,%eax
f011f681:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011f684:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f687:	8b 00                	mov    (%eax),%eax
f011f689:	83 e0 01             	and    $0x1,%eax
f011f68c:	85 c0                	test   %eax,%eax
f011f68e:	75 0a                	jne    f011f69a <check_va2pa+0x31>
		return ~0;
f011f690:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f695:	e9 87 00 00 00       	jmp    f011f721 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011f69a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f69d:	8b 00                	mov    (%eax),%eax
f011f69f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011f6a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f6a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f6aa:	c1 e8 0c             	shr    $0xc,%eax
f011f6ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f6b0:	a1 18 f3 b1 f0       	mov    0xf0b1f318,%eax
f011f6b5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011f6b8:	72 17                	jb     f011f6d1 <check_va2pa+0x68>
f011f6ba:	ff 75 f0             	pushl  -0x10(%ebp)
f011f6bd:	68 d4 15 13 f0       	push   $0xf01315d4
f011f6c2:	68 d0 02 00 00       	push   $0x2d0
f011f6c7:	68 db 0f 13 f0       	push   $0xf0130fdb
f011f6cc:	e8 68 0c fe ff       	call   f0100339 <_panic>
f011f6d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f6d4:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011f6d9:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011f6dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f6df:	c1 e8 0c             	shr    $0xc,%eax
f011f6e2:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f6e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f6ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f6f1:	01 d0                	add    %edx,%eax
f011f6f3:	8b 00                	mov    (%eax),%eax
f011f6f5:	83 e0 01             	and    $0x1,%eax
f011f6f8:	85 c0                	test   %eax,%eax
f011f6fa:	75 07                	jne    f011f703 <check_va2pa+0x9a>
		return ~0;
f011f6fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f701:	eb 1e                	jmp    f011f721 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011f703:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f706:	c1 e8 0c             	shr    $0xc,%eax
f011f709:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f70e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f715:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f718:	01 d0                	add    %edx,%eax
f011f71a:	8b 00                	mov    (%eax),%eax
f011f71c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011f721:	c9                   	leave  
f011f722:	c3                   	ret    

f011f723 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011f723:	55                   	push   %ebp
f011f724:	89 e5                	mov    %esp,%ebp
f011f726:	53                   	push   %ebx
f011f727:	83 ec 14             	sub    $0x14,%esp
f011f72a:	8b 45 10             	mov    0x10(%ebp),%eax
f011f72d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f730:	8b 45 14             	mov    0x14(%ebp),%eax
f011f733:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011f736:	8b 45 18             	mov    0x18(%ebp),%eax
f011f739:	ba 00 00 00 00       	mov    $0x0,%edx
f011f73e:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f741:	77 55                	ja     f011f798 <printnum+0x75>
f011f743:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f746:	72 05                	jb     f011f74d <printnum+0x2a>
f011f748:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f74b:	77 4b                	ja     f011f798 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011f74d:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011f750:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011f753:	8b 45 18             	mov    0x18(%ebp),%eax
f011f756:	ba 00 00 00 00       	mov    $0x0,%edx
f011f75b:	52                   	push   %edx
f011f75c:	50                   	push   %eax
f011f75d:	ff 75 f4             	pushl  -0xc(%ebp)
f011f760:	ff 75 f0             	pushl  -0x10(%ebp)
f011f763:	e8 64 2e 00 00       	call   f01225cc <__udivdi3>
f011f768:	83 c4 10             	add    $0x10,%esp
f011f76b:	83 ec 04             	sub    $0x4,%esp
f011f76e:	ff 75 20             	pushl  0x20(%ebp)
f011f771:	53                   	push   %ebx
f011f772:	ff 75 18             	pushl  0x18(%ebp)
f011f775:	52                   	push   %edx
f011f776:	50                   	push   %eax
f011f777:	ff 75 0c             	pushl  0xc(%ebp)
f011f77a:	ff 75 08             	pushl  0x8(%ebp)
f011f77d:	e8 a1 ff ff ff       	call   f011f723 <printnum>
f011f782:	83 c4 20             	add    $0x20,%esp
f011f785:	eb 1a                	jmp    f011f7a1 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011f787:	83 ec 08             	sub    $0x8,%esp
f011f78a:	ff 75 0c             	pushl  0xc(%ebp)
f011f78d:	ff 75 20             	pushl  0x20(%ebp)
f011f790:	8b 45 08             	mov    0x8(%ebp),%eax
f011f793:	ff d0                	call   *%eax
f011f795:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011f798:	ff 4d 1c             	decl   0x1c(%ebp)
f011f79b:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011f79f:	7f e6                	jg     f011f787 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011f7a1:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011f7a4:	bb 00 00 00 00       	mov    $0x0,%ebx
f011f7a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f7ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f7af:	53                   	push   %ebx
f011f7b0:	51                   	push   %ecx
f011f7b1:	52                   	push   %edx
f011f7b2:	50                   	push   %eax
f011f7b3:	e8 24 2f 00 00       	call   f01226dc <__umoddi3>
f011f7b8:	83 c4 10             	add    $0x10,%esp
f011f7bb:	05 34 18 13 f0       	add    $0xf0131834,%eax
f011f7c0:	8a 00                	mov    (%eax),%al
f011f7c2:	0f be c0             	movsbl %al,%eax
f011f7c5:	83 ec 08             	sub    $0x8,%esp
f011f7c8:	ff 75 0c             	pushl  0xc(%ebp)
f011f7cb:	50                   	push   %eax
f011f7cc:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7cf:	ff d0                	call   *%eax
f011f7d1:	83 c4 10             	add    $0x10,%esp
}
f011f7d4:	90                   	nop
f011f7d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f7d8:	c9                   	leave  
f011f7d9:	c3                   	ret    

f011f7da <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011f7da:	55                   	push   %ebp
f011f7db:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f7dd:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f7e1:	7e 1c                	jle    f011f7ff <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011f7e3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7e6:	8b 00                	mov    (%eax),%eax
f011f7e8:	8d 50 08             	lea    0x8(%eax),%edx
f011f7eb:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7ee:	89 10                	mov    %edx,(%eax)
f011f7f0:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7f3:	8b 00                	mov    (%eax),%eax
f011f7f5:	83 e8 08             	sub    $0x8,%eax
f011f7f8:	8b 50 04             	mov    0x4(%eax),%edx
f011f7fb:	8b 00                	mov    (%eax),%eax
f011f7fd:	eb 40                	jmp    f011f83f <getuint+0x65>
	else if (lflag)
f011f7ff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f803:	74 1e                	je     f011f823 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011f805:	8b 45 08             	mov    0x8(%ebp),%eax
f011f808:	8b 00                	mov    (%eax),%eax
f011f80a:	8d 50 04             	lea    0x4(%eax),%edx
f011f80d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f810:	89 10                	mov    %edx,(%eax)
f011f812:	8b 45 08             	mov    0x8(%ebp),%eax
f011f815:	8b 00                	mov    (%eax),%eax
f011f817:	83 e8 04             	sub    $0x4,%eax
f011f81a:	8b 00                	mov    (%eax),%eax
f011f81c:	ba 00 00 00 00       	mov    $0x0,%edx
f011f821:	eb 1c                	jmp    f011f83f <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011f823:	8b 45 08             	mov    0x8(%ebp),%eax
f011f826:	8b 00                	mov    (%eax),%eax
f011f828:	8d 50 04             	lea    0x4(%eax),%edx
f011f82b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f82e:	89 10                	mov    %edx,(%eax)
f011f830:	8b 45 08             	mov    0x8(%ebp),%eax
f011f833:	8b 00                	mov    (%eax),%eax
f011f835:	83 e8 04             	sub    $0x4,%eax
f011f838:	8b 00                	mov    (%eax),%eax
f011f83a:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011f83f:	5d                   	pop    %ebp
f011f840:	c3                   	ret    

f011f841 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011f841:	55                   	push   %ebp
f011f842:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f844:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f848:	7e 1c                	jle    f011f866 <getint+0x25>
		return va_arg(*ap, long long);
f011f84a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f84d:	8b 00                	mov    (%eax),%eax
f011f84f:	8d 50 08             	lea    0x8(%eax),%edx
f011f852:	8b 45 08             	mov    0x8(%ebp),%eax
f011f855:	89 10                	mov    %edx,(%eax)
f011f857:	8b 45 08             	mov    0x8(%ebp),%eax
f011f85a:	8b 00                	mov    (%eax),%eax
f011f85c:	83 e8 08             	sub    $0x8,%eax
f011f85f:	8b 50 04             	mov    0x4(%eax),%edx
f011f862:	8b 00                	mov    (%eax),%eax
f011f864:	eb 38                	jmp    f011f89e <getint+0x5d>
	else if (lflag)
f011f866:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f86a:	74 1a                	je     f011f886 <getint+0x45>
		return va_arg(*ap, long);
f011f86c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f86f:	8b 00                	mov    (%eax),%eax
f011f871:	8d 50 04             	lea    0x4(%eax),%edx
f011f874:	8b 45 08             	mov    0x8(%ebp),%eax
f011f877:	89 10                	mov    %edx,(%eax)
f011f879:	8b 45 08             	mov    0x8(%ebp),%eax
f011f87c:	8b 00                	mov    (%eax),%eax
f011f87e:	83 e8 04             	sub    $0x4,%eax
f011f881:	8b 00                	mov    (%eax),%eax
f011f883:	99                   	cltd   
f011f884:	eb 18                	jmp    f011f89e <getint+0x5d>
	else
		return va_arg(*ap, int);
f011f886:	8b 45 08             	mov    0x8(%ebp),%eax
f011f889:	8b 00                	mov    (%eax),%eax
f011f88b:	8d 50 04             	lea    0x4(%eax),%edx
f011f88e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f891:	89 10                	mov    %edx,(%eax)
f011f893:	8b 45 08             	mov    0x8(%ebp),%eax
f011f896:	8b 00                	mov    (%eax),%eax
f011f898:	83 e8 04             	sub    $0x4,%eax
f011f89b:	8b 00                	mov    (%eax),%eax
f011f89d:	99                   	cltd   
}
f011f89e:	5d                   	pop    %ebp
f011f89f:	c3                   	ret    

f011f8a0 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011f8a0:	55                   	push   %ebp
f011f8a1:	89 e5                	mov    %esp,%ebp
f011f8a3:	56                   	push   %esi
f011f8a4:	53                   	push   %ebx
f011f8a5:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f8a8:	eb 17                	jmp    f011f8c1 <vprintfmt+0x21>
			if (ch == '\0')
f011f8aa:	85 db                	test   %ebx,%ebx
f011f8ac:	0f 84 c1 03 00 00    	je     f011fc73 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011f8b2:	83 ec 08             	sub    $0x8,%esp
f011f8b5:	ff 75 0c             	pushl  0xc(%ebp)
f011f8b8:	53                   	push   %ebx
f011f8b9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8bc:	ff d0                	call   *%eax
f011f8be:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f8c1:	8b 45 10             	mov    0x10(%ebp),%eax
f011f8c4:	8d 50 01             	lea    0x1(%eax),%edx
f011f8c7:	89 55 10             	mov    %edx,0x10(%ebp)
f011f8ca:	8a 00                	mov    (%eax),%al
f011f8cc:	0f b6 d8             	movzbl %al,%ebx
f011f8cf:	83 fb 25             	cmp    $0x25,%ebx
f011f8d2:	75 d6                	jne    f011f8aa <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011f8d4:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011f8d8:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011f8df:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011f8e6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011f8ed:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011f8f4:	8b 45 10             	mov    0x10(%ebp),%eax
f011f8f7:	8d 50 01             	lea    0x1(%eax),%edx
f011f8fa:	89 55 10             	mov    %edx,0x10(%ebp)
f011f8fd:	8a 00                	mov    (%eax),%al
f011f8ff:	0f b6 d8             	movzbl %al,%ebx
f011f902:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011f905:	83 f8 5b             	cmp    $0x5b,%eax
f011f908:	0f 87 3d 03 00 00    	ja     f011fc4b <vprintfmt+0x3ab>
f011f90e:	8b 04 85 58 18 13 f0 	mov    -0xfece7a8(,%eax,4),%eax
f011f915:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011f917:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011f91b:	eb d7                	jmp    f011f8f4 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011f91d:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011f921:	eb d1                	jmp    f011f8f4 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f923:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011f92a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f92d:	89 d0                	mov    %edx,%eax
f011f92f:	c1 e0 02             	shl    $0x2,%eax
f011f932:	01 d0                	add    %edx,%eax
f011f934:	01 c0                	add    %eax,%eax
f011f936:	01 d8                	add    %ebx,%eax
f011f938:	83 e8 30             	sub    $0x30,%eax
f011f93b:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011f93e:	8b 45 10             	mov    0x10(%ebp),%eax
f011f941:	8a 00                	mov    (%eax),%al
f011f943:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011f946:	83 fb 2f             	cmp    $0x2f,%ebx
f011f949:	7e 3e                	jle    f011f989 <vprintfmt+0xe9>
f011f94b:	83 fb 39             	cmp    $0x39,%ebx
f011f94e:	7f 39                	jg     f011f989 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f950:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011f953:	eb d5                	jmp    f011f92a <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011f955:	8b 45 14             	mov    0x14(%ebp),%eax
f011f958:	83 c0 04             	add    $0x4,%eax
f011f95b:	89 45 14             	mov    %eax,0x14(%ebp)
f011f95e:	8b 45 14             	mov    0x14(%ebp),%eax
f011f961:	83 e8 04             	sub    $0x4,%eax
f011f964:	8b 00                	mov    (%eax),%eax
f011f966:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011f969:	eb 1f                	jmp    f011f98a <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011f96b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f96f:	79 83                	jns    f011f8f4 <vprintfmt+0x54>
				width = 0;
f011f971:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011f978:	e9 77 ff ff ff       	jmp    f011f8f4 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011f97d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011f984:	e9 6b ff ff ff       	jmp    f011f8f4 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011f989:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011f98a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f98e:	0f 89 60 ff ff ff    	jns    f011f8f4 <vprintfmt+0x54>
				width = precision, precision = -1;
f011f994:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f997:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f99a:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011f9a1:	e9 4e ff ff ff       	jmp    f011f8f4 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011f9a6:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011f9a9:	e9 46 ff ff ff       	jmp    f011f8f4 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011f9ae:	8b 45 14             	mov    0x14(%ebp),%eax
f011f9b1:	83 c0 04             	add    $0x4,%eax
f011f9b4:	89 45 14             	mov    %eax,0x14(%ebp)
f011f9b7:	8b 45 14             	mov    0x14(%ebp),%eax
f011f9ba:	83 e8 04             	sub    $0x4,%eax
f011f9bd:	8b 00                	mov    (%eax),%eax
f011f9bf:	83 ec 08             	sub    $0x8,%esp
f011f9c2:	ff 75 0c             	pushl  0xc(%ebp)
f011f9c5:	50                   	push   %eax
f011f9c6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9c9:	ff d0                	call   *%eax
f011f9cb:	83 c4 10             	add    $0x10,%esp
			break;
f011f9ce:	e9 9b 02 00 00       	jmp    f011fc6e <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011f9d3:	8b 45 14             	mov    0x14(%ebp),%eax
f011f9d6:	83 c0 04             	add    $0x4,%eax
f011f9d9:	89 45 14             	mov    %eax,0x14(%ebp)
f011f9dc:	8b 45 14             	mov    0x14(%ebp),%eax
f011f9df:	83 e8 04             	sub    $0x4,%eax
f011f9e2:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011f9e4:	85 db                	test   %ebx,%ebx
f011f9e6:	79 02                	jns    f011f9ea <vprintfmt+0x14a>
				err = -err;
f011f9e8:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011f9ea:	83 fb 64             	cmp    $0x64,%ebx
f011f9ed:	7f 0b                	jg     f011f9fa <vprintfmt+0x15a>
f011f9ef:	8b 34 9d a0 16 13 f0 	mov    -0xfece960(,%ebx,4),%esi
f011f9f6:	85 f6                	test   %esi,%esi
f011f9f8:	75 19                	jne    f011fa13 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011f9fa:	53                   	push   %ebx
f011f9fb:	68 45 18 13 f0       	push   $0xf0131845
f011fa00:	ff 75 0c             	pushl  0xc(%ebp)
f011fa03:	ff 75 08             	pushl  0x8(%ebp)
f011fa06:	e8 70 02 00 00       	call   f011fc7b <printfmt>
f011fa0b:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011fa0e:	e9 5b 02 00 00       	jmp    f011fc6e <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011fa13:	56                   	push   %esi
f011fa14:	68 4e 18 13 f0       	push   $0xf013184e
f011fa19:	ff 75 0c             	pushl  0xc(%ebp)
f011fa1c:	ff 75 08             	pushl  0x8(%ebp)
f011fa1f:	e8 57 02 00 00       	call   f011fc7b <printfmt>
f011fa24:	83 c4 10             	add    $0x10,%esp
			break;
f011fa27:	e9 42 02 00 00       	jmp    f011fc6e <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011fa2c:	8b 45 14             	mov    0x14(%ebp),%eax
f011fa2f:	83 c0 04             	add    $0x4,%eax
f011fa32:	89 45 14             	mov    %eax,0x14(%ebp)
f011fa35:	8b 45 14             	mov    0x14(%ebp),%eax
f011fa38:	83 e8 04             	sub    $0x4,%eax
f011fa3b:	8b 30                	mov    (%eax),%esi
f011fa3d:	85 f6                	test   %esi,%esi
f011fa3f:	75 05                	jne    f011fa46 <vprintfmt+0x1a6>
				p = "(null)";
f011fa41:	be 51 18 13 f0       	mov    $0xf0131851,%esi
			if (width > 0 && padc != '-')
f011fa46:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011fa4a:	7e 6d                	jle    f011fab9 <vprintfmt+0x219>
f011fa4c:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011fa50:	74 67                	je     f011fab9 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011fa52:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fa55:	83 ec 08             	sub    $0x8,%esp
f011fa58:	50                   	push   %eax
f011fa59:	56                   	push   %esi
f011fa5a:	e8 26 05 00 00       	call   f011ff85 <strnlen>
f011fa5f:	83 c4 10             	add    $0x10,%esp
f011fa62:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011fa65:	eb 16                	jmp    f011fa7d <vprintfmt+0x1dd>
					putch(padc, putdat);
f011fa67:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011fa6b:	83 ec 08             	sub    $0x8,%esp
f011fa6e:	ff 75 0c             	pushl  0xc(%ebp)
f011fa71:	50                   	push   %eax
f011fa72:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa75:	ff d0                	call   *%eax
f011fa77:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011fa7a:	ff 4d e4             	decl   -0x1c(%ebp)
f011fa7d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011fa81:	7f e4                	jg     f011fa67 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011fa83:	eb 34                	jmp    f011fab9 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011fa85:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011fa89:	74 1c                	je     f011faa7 <vprintfmt+0x207>
f011fa8b:	83 fb 1f             	cmp    $0x1f,%ebx
f011fa8e:	7e 05                	jle    f011fa95 <vprintfmt+0x1f5>
f011fa90:	83 fb 7e             	cmp    $0x7e,%ebx
f011fa93:	7e 12                	jle    f011faa7 <vprintfmt+0x207>
					putch('?', putdat);
f011fa95:	83 ec 08             	sub    $0x8,%esp
f011fa98:	ff 75 0c             	pushl  0xc(%ebp)
f011fa9b:	6a 3f                	push   $0x3f
f011fa9d:	8b 45 08             	mov    0x8(%ebp),%eax
f011faa0:	ff d0                	call   *%eax
f011faa2:	83 c4 10             	add    $0x10,%esp
f011faa5:	eb 0f                	jmp    f011fab6 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011faa7:	83 ec 08             	sub    $0x8,%esp
f011faaa:	ff 75 0c             	pushl  0xc(%ebp)
f011faad:	53                   	push   %ebx
f011faae:	8b 45 08             	mov    0x8(%ebp),%eax
f011fab1:	ff d0                	call   *%eax
f011fab3:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011fab6:	ff 4d e4             	decl   -0x1c(%ebp)
f011fab9:	89 f0                	mov    %esi,%eax
f011fabb:	8d 70 01             	lea    0x1(%eax),%esi
f011fabe:	8a 00                	mov    (%eax),%al
f011fac0:	0f be d8             	movsbl %al,%ebx
f011fac3:	85 db                	test   %ebx,%ebx
f011fac5:	74 24                	je     f011faeb <vprintfmt+0x24b>
f011fac7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011facb:	78 b8                	js     f011fa85 <vprintfmt+0x1e5>
f011facd:	ff 4d e0             	decl   -0x20(%ebp)
f011fad0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fad4:	79 af                	jns    f011fa85 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011fad6:	eb 13                	jmp    f011faeb <vprintfmt+0x24b>
				putch(' ', putdat);
f011fad8:	83 ec 08             	sub    $0x8,%esp
f011fadb:	ff 75 0c             	pushl  0xc(%ebp)
f011fade:	6a 20                	push   $0x20
f011fae0:	8b 45 08             	mov    0x8(%ebp),%eax
f011fae3:	ff d0                	call   *%eax
f011fae5:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011fae8:	ff 4d e4             	decl   -0x1c(%ebp)
f011faeb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011faef:	7f e7                	jg     f011fad8 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011faf1:	e9 78 01 00 00       	jmp    f011fc6e <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011faf6:	83 ec 08             	sub    $0x8,%esp
f011faf9:	ff 75 e8             	pushl  -0x18(%ebp)
f011fafc:	8d 45 14             	lea    0x14(%ebp),%eax
f011faff:	50                   	push   %eax
f011fb00:	e8 3c fd ff ff       	call   f011f841 <getint>
f011fb05:	83 c4 10             	add    $0x10,%esp
f011fb08:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fb0b:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011fb0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fb11:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb14:	85 d2                	test   %edx,%edx
f011fb16:	79 23                	jns    f011fb3b <vprintfmt+0x29b>
				putch('-', putdat);
f011fb18:	83 ec 08             	sub    $0x8,%esp
f011fb1b:	ff 75 0c             	pushl  0xc(%ebp)
f011fb1e:	6a 2d                	push   $0x2d
f011fb20:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb23:	ff d0                	call   *%eax
f011fb25:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011fb28:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fb2b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb2e:	f7 d8                	neg    %eax
f011fb30:	83 d2 00             	adc    $0x0,%edx
f011fb33:	f7 da                	neg    %edx
f011fb35:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fb38:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011fb3b:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011fb42:	e9 bc 00 00 00       	jmp    f011fc03 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011fb47:	83 ec 08             	sub    $0x8,%esp
f011fb4a:	ff 75 e8             	pushl  -0x18(%ebp)
f011fb4d:	8d 45 14             	lea    0x14(%ebp),%eax
f011fb50:	50                   	push   %eax
f011fb51:	e8 84 fc ff ff       	call   f011f7da <getuint>
f011fb56:	83 c4 10             	add    $0x10,%esp
f011fb59:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fb5c:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011fb5f:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011fb66:	e9 98 00 00 00       	jmp    f011fc03 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011fb6b:	83 ec 08             	sub    $0x8,%esp
f011fb6e:	ff 75 0c             	pushl  0xc(%ebp)
f011fb71:	6a 58                	push   $0x58
f011fb73:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb76:	ff d0                	call   *%eax
f011fb78:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011fb7b:	83 ec 08             	sub    $0x8,%esp
f011fb7e:	ff 75 0c             	pushl  0xc(%ebp)
f011fb81:	6a 58                	push   $0x58
f011fb83:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb86:	ff d0                	call   *%eax
f011fb88:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011fb8b:	83 ec 08             	sub    $0x8,%esp
f011fb8e:	ff 75 0c             	pushl  0xc(%ebp)
f011fb91:	6a 58                	push   $0x58
f011fb93:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb96:	ff d0                	call   *%eax
f011fb98:	83 c4 10             	add    $0x10,%esp
			break;
f011fb9b:	e9 ce 00 00 00       	jmp    f011fc6e <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011fba0:	83 ec 08             	sub    $0x8,%esp
f011fba3:	ff 75 0c             	pushl  0xc(%ebp)
f011fba6:	6a 30                	push   $0x30
f011fba8:	8b 45 08             	mov    0x8(%ebp),%eax
f011fbab:	ff d0                	call   *%eax
f011fbad:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011fbb0:	83 ec 08             	sub    $0x8,%esp
f011fbb3:	ff 75 0c             	pushl  0xc(%ebp)
f011fbb6:	6a 78                	push   $0x78
f011fbb8:	8b 45 08             	mov    0x8(%ebp),%eax
f011fbbb:	ff d0                	call   *%eax
f011fbbd:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011fbc0:	8b 45 14             	mov    0x14(%ebp),%eax
f011fbc3:	83 c0 04             	add    $0x4,%eax
f011fbc6:	89 45 14             	mov    %eax,0x14(%ebp)
f011fbc9:	8b 45 14             	mov    0x14(%ebp),%eax
f011fbcc:	83 e8 04             	sub    $0x4,%eax
f011fbcf:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011fbd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fbd4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011fbdb:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011fbe2:	eb 1f                	jmp    f011fc03 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011fbe4:	83 ec 08             	sub    $0x8,%esp
f011fbe7:	ff 75 e8             	pushl  -0x18(%ebp)
f011fbea:	8d 45 14             	lea    0x14(%ebp),%eax
f011fbed:	50                   	push   %eax
f011fbee:	e8 e7 fb ff ff       	call   f011f7da <getuint>
f011fbf3:	83 c4 10             	add    $0x10,%esp
f011fbf6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fbf9:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011fbfc:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011fc03:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011fc07:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fc0a:	83 ec 04             	sub    $0x4,%esp
f011fc0d:	52                   	push   %edx
f011fc0e:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fc11:	50                   	push   %eax
f011fc12:	ff 75 f4             	pushl  -0xc(%ebp)
f011fc15:	ff 75 f0             	pushl  -0x10(%ebp)
f011fc18:	ff 75 0c             	pushl  0xc(%ebp)
f011fc1b:	ff 75 08             	pushl  0x8(%ebp)
f011fc1e:	e8 00 fb ff ff       	call   f011f723 <printnum>
f011fc23:	83 c4 20             	add    $0x20,%esp
			break;
f011fc26:	eb 46                	jmp    f011fc6e <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011fc28:	83 ec 08             	sub    $0x8,%esp
f011fc2b:	ff 75 0c             	pushl  0xc(%ebp)
f011fc2e:	53                   	push   %ebx
f011fc2f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc32:	ff d0                	call   *%eax
f011fc34:	83 c4 10             	add    $0x10,%esp
			break;
f011fc37:	eb 35                	jmp    f011fc6e <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011fc39:	c6 05 60 f0 71 f0 00 	movb   $0x0,0xf071f060
			break;
f011fc40:	eb 2c                	jmp    f011fc6e <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011fc42:	c6 05 60 f0 71 f0 01 	movb   $0x1,0xf071f060
			break;
f011fc49:	eb 23                	jmp    f011fc6e <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011fc4b:	83 ec 08             	sub    $0x8,%esp
f011fc4e:	ff 75 0c             	pushl  0xc(%ebp)
f011fc51:	6a 25                	push   $0x25
f011fc53:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc56:	ff d0                	call   *%eax
f011fc58:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011fc5b:	ff 4d 10             	decl   0x10(%ebp)
f011fc5e:	eb 03                	jmp    f011fc63 <vprintfmt+0x3c3>
f011fc60:	ff 4d 10             	decl   0x10(%ebp)
f011fc63:	8b 45 10             	mov    0x10(%ebp),%eax
f011fc66:	48                   	dec    %eax
f011fc67:	8a 00                	mov    (%eax),%al
f011fc69:	3c 25                	cmp    $0x25,%al
f011fc6b:	75 f3                	jne    f011fc60 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011fc6d:	90                   	nop
		}
	}
f011fc6e:	e9 35 fc ff ff       	jmp    f011f8a8 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011fc73:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011fc74:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011fc77:	5b                   	pop    %ebx
f011fc78:	5e                   	pop    %esi
f011fc79:	5d                   	pop    %ebp
f011fc7a:	c3                   	ret    

f011fc7b <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011fc7b:	55                   	push   %ebp
f011fc7c:	89 e5                	mov    %esp,%ebp
f011fc7e:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011fc81:	8d 45 10             	lea    0x10(%ebp),%eax
f011fc84:	83 c0 04             	add    $0x4,%eax
f011fc87:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011fc8a:	8b 45 10             	mov    0x10(%ebp),%eax
f011fc8d:	ff 75 f4             	pushl  -0xc(%ebp)
f011fc90:	50                   	push   %eax
f011fc91:	ff 75 0c             	pushl  0xc(%ebp)
f011fc94:	ff 75 08             	pushl  0x8(%ebp)
f011fc97:	e8 04 fc ff ff       	call   f011f8a0 <vprintfmt>
f011fc9c:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011fc9f:	90                   	nop
f011fca0:	c9                   	leave  
f011fca1:	c3                   	ret    

f011fca2 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011fca2:	55                   	push   %ebp
f011fca3:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011fca5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fca8:	8b 40 08             	mov    0x8(%eax),%eax
f011fcab:	8d 50 01             	lea    0x1(%eax),%edx
f011fcae:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcb1:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011fcb4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcb7:	8b 10                	mov    (%eax),%edx
f011fcb9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcbc:	8b 40 04             	mov    0x4(%eax),%eax
f011fcbf:	39 c2                	cmp    %eax,%edx
f011fcc1:	73 12                	jae    f011fcd5 <sprintputch+0x33>
		*b->buf++ = ch;
f011fcc3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcc6:	8b 00                	mov    (%eax),%eax
f011fcc8:	8d 48 01             	lea    0x1(%eax),%ecx
f011fccb:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fcce:	89 0a                	mov    %ecx,(%edx)
f011fcd0:	8b 55 08             	mov    0x8(%ebp),%edx
f011fcd3:	88 10                	mov    %dl,(%eax)
}
f011fcd5:	90                   	nop
f011fcd6:	5d                   	pop    %ebp
f011fcd7:	c3                   	ret    

f011fcd8 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011fcd8:	55                   	push   %ebp
f011fcd9:	89 e5                	mov    %esp,%ebp
f011fcdb:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011fcde:	8b 45 08             	mov    0x8(%ebp),%eax
f011fce1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011fce4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fce7:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fcea:	8b 45 08             	mov    0x8(%ebp),%eax
f011fced:	01 d0                	add    %edx,%eax
f011fcef:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fcf2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011fcf9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fcfd:	74 06                	je     f011fd05 <vsnprintf+0x2d>
f011fcff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fd03:	7f 07                	jg     f011fd0c <vsnprintf+0x34>
		return -E_INVAL;
f011fd05:	b8 03 00 00 00       	mov    $0x3,%eax
f011fd0a:	eb 20                	jmp    f011fd2c <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011fd0c:	ff 75 14             	pushl  0x14(%ebp)
f011fd0f:	ff 75 10             	pushl  0x10(%ebp)
f011fd12:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011fd15:	50                   	push   %eax
f011fd16:	68 a2 fc 11 f0       	push   $0xf011fca2
f011fd1b:	e8 80 fb ff ff       	call   f011f8a0 <vprintfmt>
f011fd20:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011fd23:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fd26:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011fd29:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011fd2c:	c9                   	leave  
f011fd2d:	c3                   	ret    

f011fd2e <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011fd2e:	55                   	push   %ebp
f011fd2f:	89 e5                	mov    %esp,%ebp
f011fd31:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011fd34:	8d 45 10             	lea    0x10(%ebp),%eax
f011fd37:	83 c0 04             	add    $0x4,%eax
f011fd3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011fd3d:	8b 45 10             	mov    0x10(%ebp),%eax
f011fd40:	ff 75 f4             	pushl  -0xc(%ebp)
f011fd43:	50                   	push   %eax
f011fd44:	ff 75 0c             	pushl  0xc(%ebp)
f011fd47:	ff 75 08             	pushl  0x8(%ebp)
f011fd4a:	e8 89 ff ff ff       	call   f011fcd8 <vsnprintf>
f011fd4f:	83 c4 10             	add    $0x10,%esp
f011fd52:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011fd55:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011fd58:	c9                   	leave  
f011fd59:	c3                   	ret    

f011fd5a <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011fd5a:	55                   	push   %ebp
f011fd5b:	89 e5                	mov    %esp,%ebp
f011fd5d:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011fd60:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fd64:	74 13                	je     f011fd79 <readline+0x1f>
		cprintf("%s", prompt);
f011fd66:	83 ec 08             	sub    $0x8,%esp
f011fd69:	ff 75 08             	pushl  0x8(%ebp)
f011fd6c:	68 c8 19 13 f0       	push   $0xf01319c8
f011fd71:	e8 15 12 fe ff       	call   f0100f8b <cprintf>
f011fd76:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011fd79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011fd80:	83 ec 0c             	sub    $0xc,%esp
f011fd83:	6a 00                	push   $0x0
f011fd85:	e8 0e 11 fe ff       	call   f0100e98 <iscons>
f011fd8a:	83 c4 10             	add    $0x10,%esp
f011fd8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011fd90:	e8 ea 10 fe ff       	call   f0100e7f <getchar>
f011fd95:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011fd98:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fd9c:	79 22                	jns    f011fdc0 <readline+0x66>
			if (c != -E_EOF)
f011fd9e:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fda2:	0f 84 ad 00 00 00    	je     f011fe55 <readline+0xfb>
				cprintf("read error: %e\n", c);
f011fda8:	83 ec 08             	sub    $0x8,%esp
f011fdab:	ff 75 ec             	pushl  -0x14(%ebp)
f011fdae:	68 cb 19 13 f0       	push   $0xf01319cb
f011fdb3:	e8 d3 11 fe ff       	call   f0100f8b <cprintf>
f011fdb8:	83 c4 10             	add    $0x10,%esp
			break;
f011fdbb:	e9 95 00 00 00       	jmp    f011fe55 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011fdc0:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fdc4:	7e 34                	jle    f011fdfa <readline+0xa0>
f011fdc6:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fdcd:	7f 2b                	jg     f011fdfa <readline+0xa0>
			if (echoing)
f011fdcf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fdd3:	74 0e                	je     f011fde3 <readline+0x89>
				cputchar(c);
f011fdd5:	83 ec 0c             	sub    $0xc,%esp
f011fdd8:	ff 75 ec             	pushl  -0x14(%ebp)
f011fddb:	e8 88 10 fe ff       	call   f0100e68 <cputchar>
f011fde0:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011fde3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fde6:	8d 50 01             	lea    0x1(%eax),%edx
f011fde9:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fdec:	89 c2                	mov    %eax,%edx
f011fdee:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fdf1:	01 d0                	add    %edx,%eax
f011fdf3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fdf6:	88 10                	mov    %dl,(%eax)
f011fdf8:	eb 56                	jmp    f011fe50 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011fdfa:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fdfe:	75 1f                	jne    f011fe1f <readline+0xc5>
f011fe00:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fe04:	7e 19                	jle    f011fe1f <readline+0xc5>
			if (echoing)
f011fe06:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fe0a:	74 0e                	je     f011fe1a <readline+0xc0>
				cputchar(c);
f011fe0c:	83 ec 0c             	sub    $0xc,%esp
f011fe0f:	ff 75 ec             	pushl  -0x14(%ebp)
f011fe12:	e8 51 10 fe ff       	call   f0100e68 <cputchar>
f011fe17:	83 c4 10             	add    $0x10,%esp

			i--;
f011fe1a:	ff 4d f4             	decl   -0xc(%ebp)
f011fe1d:	eb 31                	jmp    f011fe50 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011fe1f:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fe23:	74 0a                	je     f011fe2f <readline+0xd5>
f011fe25:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fe29:	0f 85 61 ff ff ff    	jne    f011fd90 <readline+0x36>
			if (echoing)
f011fe2f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fe33:	74 0e                	je     f011fe43 <readline+0xe9>
				cputchar(c);
f011fe35:	83 ec 0c             	sub    $0xc,%esp
f011fe38:	ff 75 ec             	pushl  -0x14(%ebp)
f011fe3b:	e8 28 10 fe ff       	call   f0100e68 <cputchar>
f011fe40:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011fe43:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fe46:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe49:	01 d0                	add    %edx,%eax
f011fe4b:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011fe4e:	eb 06                	jmp    f011fe56 <readline+0xfc>
		}
	}
f011fe50:	e9 3b ff ff ff       	jmp    f011fd90 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011fe55:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011fe56:	90                   	nop
f011fe57:	c9                   	leave  
f011fe58:	c3                   	ret    

f011fe59 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011fe59:	55                   	push   %ebp
f011fe5a:	89 e5                	mov    %esp,%ebp
f011fe5c:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011fe5f:	e8 53 ec fe ff       	call   f010eab7 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011fe64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fe68:	74 13                	je     f011fe7d <atomic_readline+0x24>
			cprintf("%s", prompt);
f011fe6a:	83 ec 08             	sub    $0x8,%esp
f011fe6d:	ff 75 08             	pushl  0x8(%ebp)
f011fe70:	68 c8 19 13 f0       	push   $0xf01319c8
f011fe75:	e8 11 11 fe ff       	call   f0100f8b <cprintf>
f011fe7a:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011fe7d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011fe84:	83 ec 0c             	sub    $0xc,%esp
f011fe87:	6a 00                	push   $0x0
f011fe89:	e8 0a 10 fe ff       	call   f0100e98 <iscons>
f011fe8e:	83 c4 10             	add    $0x10,%esp
f011fe91:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011fe94:	e8 e6 0f fe ff       	call   f0100e7f <getchar>
f011fe99:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011fe9c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fea0:	79 22                	jns    f011fec4 <atomic_readline+0x6b>
				if (c != -E_EOF)
f011fea2:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fea6:	0f 84 ad 00 00 00    	je     f011ff59 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011feac:	83 ec 08             	sub    $0x8,%esp
f011feaf:	ff 75 ec             	pushl  -0x14(%ebp)
f011feb2:	68 cb 19 13 f0       	push   $0xf01319cb
f011feb7:	e8 cf 10 fe ff       	call   f0100f8b <cprintf>
f011febc:	83 c4 10             	add    $0x10,%esp
				break;
f011febf:	e9 95 00 00 00       	jmp    f011ff59 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011fec4:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fec8:	7e 34                	jle    f011fefe <atomic_readline+0xa5>
f011feca:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fed1:	7f 2b                	jg     f011fefe <atomic_readline+0xa5>
				if (echoing)
f011fed3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fed7:	74 0e                	je     f011fee7 <atomic_readline+0x8e>
					cputchar(c);
f011fed9:	83 ec 0c             	sub    $0xc,%esp
f011fedc:	ff 75 ec             	pushl  -0x14(%ebp)
f011fedf:	e8 84 0f fe ff       	call   f0100e68 <cputchar>
f011fee4:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011fee7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011feea:	8d 50 01             	lea    0x1(%eax),%edx
f011feed:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fef0:	89 c2                	mov    %eax,%edx
f011fef2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fef5:	01 d0                	add    %edx,%eax
f011fef7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fefa:	88 10                	mov    %dl,(%eax)
f011fefc:	eb 56                	jmp    f011ff54 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011fefe:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011ff02:	75 1f                	jne    f011ff23 <atomic_readline+0xca>
f011ff04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ff08:	7e 19                	jle    f011ff23 <atomic_readline+0xca>
				if (echoing)
f011ff0a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ff0e:	74 0e                	je     f011ff1e <atomic_readline+0xc5>
					cputchar(c);
f011ff10:	83 ec 0c             	sub    $0xc,%esp
f011ff13:	ff 75 ec             	pushl  -0x14(%ebp)
f011ff16:	e8 4d 0f fe ff       	call   f0100e68 <cputchar>
f011ff1b:	83 c4 10             	add    $0x10,%esp
				i--;
f011ff1e:	ff 4d f4             	decl   -0xc(%ebp)
f011ff21:	eb 31                	jmp    f011ff54 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011ff23:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011ff27:	74 0a                	je     f011ff33 <atomic_readline+0xda>
f011ff29:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011ff2d:	0f 85 61 ff ff ff    	jne    f011fe94 <atomic_readline+0x3b>
				if (echoing)
f011ff33:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ff37:	74 0e                	je     f011ff47 <atomic_readline+0xee>
					cputchar(c);
f011ff39:	83 ec 0c             	sub    $0xc,%esp
f011ff3c:	ff 75 ec             	pushl  -0x14(%ebp)
f011ff3f:	e8 24 0f fe ff       	call   f0100e68 <cputchar>
f011ff44:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011ff47:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ff4a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff4d:	01 d0                	add    %edx,%eax
f011ff4f:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011ff52:	eb 06                	jmp    f011ff5a <atomic_readline+0x101>
			}
		}
f011ff54:	e9 3b ff ff ff       	jmp    f011fe94 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011ff59:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011ff5a:	e8 66 eb fe ff       	call   f010eac5 <sys_unlock_cons>
}
f011ff5f:	90                   	nop
f011ff60:	c9                   	leave  
f011ff61:	c3                   	ret    

f011ff62 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011ff62:	55                   	push   %ebp
f011ff63:	89 e5                	mov    %esp,%ebp
f011ff65:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011ff68:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ff6f:	eb 06                	jmp    f011ff77 <strlen+0x15>
		n++;
f011ff71:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011ff74:	ff 45 08             	incl   0x8(%ebp)
f011ff77:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff7a:	8a 00                	mov    (%eax),%al
f011ff7c:	84 c0                	test   %al,%al
f011ff7e:	75 f1                	jne    f011ff71 <strlen+0xf>
		n++;
	return n;
f011ff80:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ff83:	c9                   	leave  
f011ff84:	c3                   	ret    

f011ff85 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011ff85:	55                   	push   %ebp
f011ff86:	89 e5                	mov    %esp,%ebp
f011ff88:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011ff8b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ff92:	eb 09                	jmp    f011ff9d <strnlen+0x18>
		n++;
f011ff94:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011ff97:	ff 45 08             	incl   0x8(%ebp)
f011ff9a:	ff 4d 0c             	decl   0xc(%ebp)
f011ff9d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ffa1:	74 09                	je     f011ffac <strnlen+0x27>
f011ffa3:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffa6:	8a 00                	mov    (%eax),%al
f011ffa8:	84 c0                	test   %al,%al
f011ffaa:	75 e8                	jne    f011ff94 <strnlen+0xf>
		n++;
	return n;
f011ffac:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ffaf:	c9                   	leave  
f011ffb0:	c3                   	ret    

f011ffb1 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011ffb1:	55                   	push   %ebp
f011ffb2:	89 e5                	mov    %esp,%ebp
f011ffb4:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011ffb7:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffba:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011ffbd:	90                   	nop
f011ffbe:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffc1:	8d 50 01             	lea    0x1(%eax),%edx
f011ffc4:	89 55 08             	mov    %edx,0x8(%ebp)
f011ffc7:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ffca:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ffcd:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ffd0:	8a 12                	mov    (%edx),%dl
f011ffd2:	88 10                	mov    %dl,(%eax)
f011ffd4:	8a 00                	mov    (%eax),%al
f011ffd6:	84 c0                	test   %al,%al
f011ffd8:	75 e4                	jne    f011ffbe <strcpy+0xd>
		/* do nothing */;
	return ret;
f011ffda:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ffdd:	c9                   	leave  
f011ffde:	c3                   	ret    

f011ffdf <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011ffdf:	55                   	push   %ebp
f011ffe0:	89 e5                	mov    %esp,%ebp
f011ffe2:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011ffe5:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffe8:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011ffeb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fff2:	eb 1f                	jmp    f0120013 <strncpy+0x34>
		*dst++ = *src;
f011fff4:	8b 45 08             	mov    0x8(%ebp),%eax
f011fff7:	8d 50 01             	lea    0x1(%eax),%edx
f011fffa:	89 55 08             	mov    %edx,0x8(%ebp)
f011fffd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120000:	8a 12                	mov    (%edx),%dl
f0120002:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f0120004:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120007:	8a 00                	mov    (%eax),%al
f0120009:	84 c0                	test   %al,%al
f012000b:	74 03                	je     f0120010 <strncpy+0x31>
			src++;
f012000d:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f0120010:	ff 45 fc             	incl   -0x4(%ebp)
f0120013:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120016:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120019:	72 d9                	jb     f011fff4 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f012001b:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f012001e:	c9                   	leave  
f012001f:	c3                   	ret    

f0120020 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f0120020:	55                   	push   %ebp
f0120021:	89 e5                	mov    %esp,%ebp
f0120023:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f0120026:	8b 45 08             	mov    0x8(%ebp),%eax
f0120029:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f012002c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120030:	74 30                	je     f0120062 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f0120032:	eb 16                	jmp    f012004a <strlcpy+0x2a>
			*dst++ = *src++;
f0120034:	8b 45 08             	mov    0x8(%ebp),%eax
f0120037:	8d 50 01             	lea    0x1(%eax),%edx
f012003a:	89 55 08             	mov    %edx,0x8(%ebp)
f012003d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120040:	8d 4a 01             	lea    0x1(%edx),%ecx
f0120043:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f0120046:	8a 12                	mov    (%edx),%dl
f0120048:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f012004a:	ff 4d 10             	decl   0x10(%ebp)
f012004d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120051:	74 09                	je     f012005c <strlcpy+0x3c>
f0120053:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120056:	8a 00                	mov    (%eax),%al
f0120058:	84 c0                	test   %al,%al
f012005a:	75 d8                	jne    f0120034 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f012005c:	8b 45 08             	mov    0x8(%ebp),%eax
f012005f:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f0120062:	8b 55 08             	mov    0x8(%ebp),%edx
f0120065:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120068:	29 c2                	sub    %eax,%edx
f012006a:	89 d0                	mov    %edx,%eax
}
f012006c:	c9                   	leave  
f012006d:	c3                   	ret    

f012006e <strcmp>:

int
strcmp(const char *p, const char *q)
{
f012006e:	55                   	push   %ebp
f012006f:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f0120071:	eb 06                	jmp    f0120079 <strcmp+0xb>
		p++, q++;
f0120073:	ff 45 08             	incl   0x8(%ebp)
f0120076:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f0120079:	8b 45 08             	mov    0x8(%ebp),%eax
f012007c:	8a 00                	mov    (%eax),%al
f012007e:	84 c0                	test   %al,%al
f0120080:	74 0e                	je     f0120090 <strcmp+0x22>
f0120082:	8b 45 08             	mov    0x8(%ebp),%eax
f0120085:	8a 10                	mov    (%eax),%dl
f0120087:	8b 45 0c             	mov    0xc(%ebp),%eax
f012008a:	8a 00                	mov    (%eax),%al
f012008c:	38 c2                	cmp    %al,%dl
f012008e:	74 e3                	je     f0120073 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f0120090:	8b 45 08             	mov    0x8(%ebp),%eax
f0120093:	8a 00                	mov    (%eax),%al
f0120095:	0f b6 d0             	movzbl %al,%edx
f0120098:	8b 45 0c             	mov    0xc(%ebp),%eax
f012009b:	8a 00                	mov    (%eax),%al
f012009d:	0f b6 c0             	movzbl %al,%eax
f01200a0:	29 c2                	sub    %eax,%edx
f01200a2:	89 d0                	mov    %edx,%eax
}
f01200a4:	5d                   	pop    %ebp
f01200a5:	c3                   	ret    

f01200a6 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f01200a6:	55                   	push   %ebp
f01200a7:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f01200a9:	eb 09                	jmp    f01200b4 <strncmp+0xe>
		n--, p++, q++;
f01200ab:	ff 4d 10             	decl   0x10(%ebp)
f01200ae:	ff 45 08             	incl   0x8(%ebp)
f01200b1:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f01200b4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01200b8:	74 17                	je     f01200d1 <strncmp+0x2b>
f01200ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01200bd:	8a 00                	mov    (%eax),%al
f01200bf:	84 c0                	test   %al,%al
f01200c1:	74 0e                	je     f01200d1 <strncmp+0x2b>
f01200c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01200c6:	8a 10                	mov    (%eax),%dl
f01200c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200cb:	8a 00                	mov    (%eax),%al
f01200cd:	38 c2                	cmp    %al,%dl
f01200cf:	74 da                	je     f01200ab <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f01200d1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01200d5:	75 07                	jne    f01200de <strncmp+0x38>
		return 0;
f01200d7:	b8 00 00 00 00       	mov    $0x0,%eax
f01200dc:	eb 14                	jmp    f01200f2 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f01200de:	8b 45 08             	mov    0x8(%ebp),%eax
f01200e1:	8a 00                	mov    (%eax),%al
f01200e3:	0f b6 d0             	movzbl %al,%edx
f01200e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200e9:	8a 00                	mov    (%eax),%al
f01200eb:	0f b6 c0             	movzbl %al,%eax
f01200ee:	29 c2                	sub    %eax,%edx
f01200f0:	89 d0                	mov    %edx,%eax
}
f01200f2:	5d                   	pop    %ebp
f01200f3:	c3                   	ret    

f01200f4 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f01200f4:	55                   	push   %ebp
f01200f5:	89 e5                	mov    %esp,%ebp
f01200f7:	83 ec 04             	sub    $0x4,%esp
f01200fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200fd:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f0120100:	eb 12                	jmp    f0120114 <strchr+0x20>
		if (*s == c)
f0120102:	8b 45 08             	mov    0x8(%ebp),%eax
f0120105:	8a 00                	mov    (%eax),%al
f0120107:	3a 45 fc             	cmp    -0x4(%ebp),%al
f012010a:	75 05                	jne    f0120111 <strchr+0x1d>
			return (char *) s;
f012010c:	8b 45 08             	mov    0x8(%ebp),%eax
f012010f:	eb 11                	jmp    f0120122 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f0120111:	ff 45 08             	incl   0x8(%ebp)
f0120114:	8b 45 08             	mov    0x8(%ebp),%eax
f0120117:	8a 00                	mov    (%eax),%al
f0120119:	84 c0                	test   %al,%al
f012011b:	75 e5                	jne    f0120102 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f012011d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120122:	c9                   	leave  
f0120123:	c3                   	ret    

f0120124 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f0120124:	55                   	push   %ebp
f0120125:	89 e5                	mov    %esp,%ebp
f0120127:	83 ec 04             	sub    $0x4,%esp
f012012a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012012d:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f0120130:	eb 0d                	jmp    f012013f <strfind+0x1b>
		if (*s == c)
f0120132:	8b 45 08             	mov    0x8(%ebp),%eax
f0120135:	8a 00                	mov    (%eax),%al
f0120137:	3a 45 fc             	cmp    -0x4(%ebp),%al
f012013a:	74 0e                	je     f012014a <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f012013c:	ff 45 08             	incl   0x8(%ebp)
f012013f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120142:	8a 00                	mov    (%eax),%al
f0120144:	84 c0                	test   %al,%al
f0120146:	75 ea                	jne    f0120132 <strfind+0xe>
f0120148:	eb 01                	jmp    f012014b <strfind+0x27>
		if (*s == c)
			break;
f012014a:	90                   	nop
	return (char *) s;
f012014b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012014e:	c9                   	leave  
f012014f:	c3                   	ret    

f0120150 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f0120150:	55                   	push   %ebp
f0120151:	89 e5                	mov    %esp,%ebp
f0120153:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f0120156:	8b 45 08             	mov    0x8(%ebp),%eax
f0120159:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f012015c:	8b 45 10             	mov    0x10(%ebp),%eax
f012015f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f0120162:	eb 0e                	jmp    f0120172 <memset+0x22>
		*p++ = c;
f0120164:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120167:	8d 50 01             	lea    0x1(%eax),%edx
f012016a:	89 55 fc             	mov    %edx,-0x4(%ebp)
f012016d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120170:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f0120172:	ff 4d f8             	decl   -0x8(%ebp)
f0120175:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f0120179:	79 e9                	jns    f0120164 <memset+0x14>
		*p++ = c;

	return v;
f012017b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012017e:	c9                   	leave  
f012017f:	c3                   	ret    

f0120180 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f0120180:	55                   	push   %ebp
f0120181:	89 e5                	mov    %esp,%ebp
f0120183:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f0120186:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120189:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f012018c:	8b 45 08             	mov    0x8(%ebp),%eax
f012018f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f0120192:	eb 16                	jmp    f01201aa <memcpy+0x2a>
		*d++ = *s++;
f0120194:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120197:	8d 50 01             	lea    0x1(%eax),%edx
f012019a:	89 55 f8             	mov    %edx,-0x8(%ebp)
f012019d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01201a0:	8d 4a 01             	lea    0x1(%edx),%ecx
f01201a3:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f01201a6:	8a 12                	mov    (%edx),%dl
f01201a8:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f01201aa:	8b 45 10             	mov    0x10(%ebp),%eax
f01201ad:	8d 50 ff             	lea    -0x1(%eax),%edx
f01201b0:	89 55 10             	mov    %edx,0x10(%ebp)
f01201b3:	85 c0                	test   %eax,%eax
f01201b5:	75 dd                	jne    f0120194 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f01201b7:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01201ba:	c9                   	leave  
f01201bb:	c3                   	ret    

f01201bc <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f01201bc:	55                   	push   %ebp
f01201bd:	89 e5                	mov    %esp,%ebp
f01201bf:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f01201c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f01201c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01201cb:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f01201ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01201d1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01201d4:	73 50                	jae    f0120226 <memmove+0x6a>
f01201d6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01201d9:	8b 45 10             	mov    0x10(%ebp),%eax
f01201dc:	01 d0                	add    %edx,%eax
f01201de:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01201e1:	76 43                	jbe    f0120226 <memmove+0x6a>
		s += n;
f01201e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01201e6:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f01201e9:	8b 45 10             	mov    0x10(%ebp),%eax
f01201ec:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f01201ef:	eb 10                	jmp    f0120201 <memmove+0x45>
			*--d = *--s;
f01201f1:	ff 4d f8             	decl   -0x8(%ebp)
f01201f4:	ff 4d fc             	decl   -0x4(%ebp)
f01201f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01201fa:	8a 10                	mov    (%eax),%dl
f01201fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01201ff:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f0120201:	8b 45 10             	mov    0x10(%ebp),%eax
f0120204:	8d 50 ff             	lea    -0x1(%eax),%edx
f0120207:	89 55 10             	mov    %edx,0x10(%ebp)
f012020a:	85 c0                	test   %eax,%eax
f012020c:	75 e3                	jne    f01201f1 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f012020e:	eb 23                	jmp    f0120233 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f0120210:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120213:	8d 50 01             	lea    0x1(%eax),%edx
f0120216:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0120219:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012021c:	8d 4a 01             	lea    0x1(%edx),%ecx
f012021f:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f0120222:	8a 12                	mov    (%edx),%dl
f0120224:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f0120226:	8b 45 10             	mov    0x10(%ebp),%eax
f0120229:	8d 50 ff             	lea    -0x1(%eax),%edx
f012022c:	89 55 10             	mov    %edx,0x10(%ebp)
f012022f:	85 c0                	test   %eax,%eax
f0120231:	75 dd                	jne    f0120210 <memmove+0x54>
			*d++ = *s++;

	return dst;
f0120233:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120236:	c9                   	leave  
f0120237:	c3                   	ret    

f0120238 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f0120238:	55                   	push   %ebp
f0120239:	89 e5                	mov    %esp,%ebp
f012023b:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f012023e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120241:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f0120244:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120247:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f012024a:	eb 2a                	jmp    f0120276 <memcmp+0x3e>
		if (*s1 != *s2)
f012024c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012024f:	8a 10                	mov    (%eax),%dl
f0120251:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120254:	8a 00                	mov    (%eax),%al
f0120256:	38 c2                	cmp    %al,%dl
f0120258:	74 16                	je     f0120270 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f012025a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012025d:	8a 00                	mov    (%eax),%al
f012025f:	0f b6 d0             	movzbl %al,%edx
f0120262:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120265:	8a 00                	mov    (%eax),%al
f0120267:	0f b6 c0             	movzbl %al,%eax
f012026a:	29 c2                	sub    %eax,%edx
f012026c:	89 d0                	mov    %edx,%eax
f012026e:	eb 18                	jmp    f0120288 <memcmp+0x50>
		s1++, s2++;
f0120270:	ff 45 fc             	incl   -0x4(%ebp)
f0120273:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f0120276:	8b 45 10             	mov    0x10(%ebp),%eax
f0120279:	8d 50 ff             	lea    -0x1(%eax),%edx
f012027c:	89 55 10             	mov    %edx,0x10(%ebp)
f012027f:	85 c0                	test   %eax,%eax
f0120281:	75 c9                	jne    f012024c <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f0120283:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120288:	c9                   	leave  
f0120289:	c3                   	ret    

f012028a <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f012028a:	55                   	push   %ebp
f012028b:	89 e5                	mov    %esp,%ebp
f012028d:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f0120290:	8b 55 08             	mov    0x8(%ebp),%edx
f0120293:	8b 45 10             	mov    0x10(%ebp),%eax
f0120296:	01 d0                	add    %edx,%eax
f0120298:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f012029b:	eb 15                	jmp    f01202b2 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f012029d:	8b 45 08             	mov    0x8(%ebp),%eax
f01202a0:	8a 00                	mov    (%eax),%al
f01202a2:	0f b6 d0             	movzbl %al,%edx
f01202a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202a8:	0f b6 c0             	movzbl %al,%eax
f01202ab:	39 c2                	cmp    %eax,%edx
f01202ad:	74 0d                	je     f01202bc <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f01202af:	ff 45 08             	incl   0x8(%ebp)
f01202b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01202b5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f01202b8:	72 e3                	jb     f012029d <memfind+0x13>
f01202ba:	eb 01                	jmp    f01202bd <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f01202bc:	90                   	nop
	return (void *) s;
f01202bd:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01202c0:	c9                   	leave  
f01202c1:	c3                   	ret    

f01202c2 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f01202c2:	55                   	push   %ebp
f01202c3:	89 e5                	mov    %esp,%ebp
f01202c5:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f01202c8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f01202cf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f01202d6:	eb 03                	jmp    f01202db <strtol+0x19>
		s++;
f01202d8:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f01202db:	8b 45 08             	mov    0x8(%ebp),%eax
f01202de:	8a 00                	mov    (%eax),%al
f01202e0:	3c 20                	cmp    $0x20,%al
f01202e2:	74 f4                	je     f01202d8 <strtol+0x16>
f01202e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01202e7:	8a 00                	mov    (%eax),%al
f01202e9:	3c 09                	cmp    $0x9,%al
f01202eb:	74 eb                	je     f01202d8 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f01202ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01202f0:	8a 00                	mov    (%eax),%al
f01202f2:	3c 2b                	cmp    $0x2b,%al
f01202f4:	75 05                	jne    f01202fb <strtol+0x39>
		s++;
f01202f6:	ff 45 08             	incl   0x8(%ebp)
f01202f9:	eb 13                	jmp    f012030e <strtol+0x4c>
	else if (*s == '-')
f01202fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01202fe:	8a 00                	mov    (%eax),%al
f0120300:	3c 2d                	cmp    $0x2d,%al
f0120302:	75 0a                	jne    f012030e <strtol+0x4c>
		s++, neg = 1;
f0120304:	ff 45 08             	incl   0x8(%ebp)
f0120307:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f012030e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120312:	74 06                	je     f012031a <strtol+0x58>
f0120314:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f0120318:	75 20                	jne    f012033a <strtol+0x78>
f012031a:	8b 45 08             	mov    0x8(%ebp),%eax
f012031d:	8a 00                	mov    (%eax),%al
f012031f:	3c 30                	cmp    $0x30,%al
f0120321:	75 17                	jne    f012033a <strtol+0x78>
f0120323:	8b 45 08             	mov    0x8(%ebp),%eax
f0120326:	40                   	inc    %eax
f0120327:	8a 00                	mov    (%eax),%al
f0120329:	3c 78                	cmp    $0x78,%al
f012032b:	75 0d                	jne    f012033a <strtol+0x78>
		s += 2, base = 16;
f012032d:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f0120331:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f0120338:	eb 28                	jmp    f0120362 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f012033a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012033e:	75 15                	jne    f0120355 <strtol+0x93>
f0120340:	8b 45 08             	mov    0x8(%ebp),%eax
f0120343:	8a 00                	mov    (%eax),%al
f0120345:	3c 30                	cmp    $0x30,%al
f0120347:	75 0c                	jne    f0120355 <strtol+0x93>
		s++, base = 8;
f0120349:	ff 45 08             	incl   0x8(%ebp)
f012034c:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f0120353:	eb 0d                	jmp    f0120362 <strtol+0xa0>
	else if (base == 0)
f0120355:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120359:	75 07                	jne    f0120362 <strtol+0xa0>
		base = 10;
f012035b:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f0120362:	8b 45 08             	mov    0x8(%ebp),%eax
f0120365:	8a 00                	mov    (%eax),%al
f0120367:	3c 2f                	cmp    $0x2f,%al
f0120369:	7e 19                	jle    f0120384 <strtol+0xc2>
f012036b:	8b 45 08             	mov    0x8(%ebp),%eax
f012036e:	8a 00                	mov    (%eax),%al
f0120370:	3c 39                	cmp    $0x39,%al
f0120372:	7f 10                	jg     f0120384 <strtol+0xc2>
			dig = *s - '0';
f0120374:	8b 45 08             	mov    0x8(%ebp),%eax
f0120377:	8a 00                	mov    (%eax),%al
f0120379:	0f be c0             	movsbl %al,%eax
f012037c:	83 e8 30             	sub    $0x30,%eax
f012037f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120382:	eb 42                	jmp    f01203c6 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f0120384:	8b 45 08             	mov    0x8(%ebp),%eax
f0120387:	8a 00                	mov    (%eax),%al
f0120389:	3c 60                	cmp    $0x60,%al
f012038b:	7e 19                	jle    f01203a6 <strtol+0xe4>
f012038d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120390:	8a 00                	mov    (%eax),%al
f0120392:	3c 7a                	cmp    $0x7a,%al
f0120394:	7f 10                	jg     f01203a6 <strtol+0xe4>
			dig = *s - 'a' + 10;
f0120396:	8b 45 08             	mov    0x8(%ebp),%eax
f0120399:	8a 00                	mov    (%eax),%al
f012039b:	0f be c0             	movsbl %al,%eax
f012039e:	83 e8 57             	sub    $0x57,%eax
f01203a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01203a4:	eb 20                	jmp    f01203c6 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f01203a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01203a9:	8a 00                	mov    (%eax),%al
f01203ab:	3c 40                	cmp    $0x40,%al
f01203ad:	7e 39                	jle    f01203e8 <strtol+0x126>
f01203af:	8b 45 08             	mov    0x8(%ebp),%eax
f01203b2:	8a 00                	mov    (%eax),%al
f01203b4:	3c 5a                	cmp    $0x5a,%al
f01203b6:	7f 30                	jg     f01203e8 <strtol+0x126>
			dig = *s - 'A' + 10;
f01203b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01203bb:	8a 00                	mov    (%eax),%al
f01203bd:	0f be c0             	movsbl %al,%eax
f01203c0:	83 e8 37             	sub    $0x37,%eax
f01203c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f01203c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203c9:	3b 45 10             	cmp    0x10(%ebp),%eax
f01203cc:	7d 19                	jge    f01203e7 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f01203ce:	ff 45 08             	incl   0x8(%ebp)
f01203d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01203d4:	0f af 45 10          	imul   0x10(%ebp),%eax
f01203d8:	89 c2                	mov    %eax,%edx
f01203da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203dd:	01 d0                	add    %edx,%eax
f01203df:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f01203e2:	e9 7b ff ff ff       	jmp    f0120362 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f01203e7:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f01203e8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01203ec:	74 08                	je     f01203f6 <strtol+0x134>
		*endptr = (char *) s;
f01203ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01203f1:	8b 55 08             	mov    0x8(%ebp),%edx
f01203f4:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f01203f6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01203fa:	74 07                	je     f0120403 <strtol+0x141>
f01203fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01203ff:	f7 d8                	neg    %eax
f0120401:	eb 03                	jmp    f0120406 <strtol+0x144>
f0120403:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0120406:	c9                   	leave  
f0120407:	c3                   	ret    

f0120408 <ltostr>:

void
ltostr(long value, char *str)
{
f0120408:	55                   	push   %ebp
f0120409:	89 e5                	mov    %esp,%ebp
f012040b:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f012040e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f0120415:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f012041c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120420:	79 13                	jns    f0120435 <ltostr+0x2d>
	{
		neg = 1;
f0120422:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f0120429:	8b 45 0c             	mov    0xc(%ebp),%eax
f012042c:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f012042f:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f0120432:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f0120435:	8b 45 08             	mov    0x8(%ebp),%eax
f0120438:	b9 0a 00 00 00       	mov    $0xa,%ecx
f012043d:	99                   	cltd   
f012043e:	f7 f9                	idiv   %ecx
f0120440:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f0120443:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120446:	8d 50 01             	lea    0x1(%eax),%edx
f0120449:	89 55 f8             	mov    %edx,-0x8(%ebp)
f012044c:	89 c2                	mov    %eax,%edx
f012044e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120451:	01 d0                	add    %edx,%eax
f0120453:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120456:	83 c2 30             	add    $0x30,%edx
f0120459:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f012045b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f012045e:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0120463:	f7 e9                	imul   %ecx
f0120465:	c1 fa 02             	sar    $0x2,%edx
f0120468:	89 c8                	mov    %ecx,%eax
f012046a:	c1 f8 1f             	sar    $0x1f,%eax
f012046d:	29 c2                	sub    %eax,%edx
f012046f:	89 d0                	mov    %edx,%eax
f0120471:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f0120474:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120478:	75 bb                	jne    f0120435 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f012047a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f0120481:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120484:	48                   	dec    %eax
f0120485:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f0120488:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f012048c:	74 3d                	je     f01204cb <ltostr+0xc3>
		start = 1 ;
f012048e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f0120495:	eb 34                	jmp    f01204cb <ltostr+0xc3>
	{
		char tmp = str[start] ;
f0120497:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012049a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012049d:	01 d0                	add    %edx,%eax
f012049f:	8a 00                	mov    (%eax),%al
f01204a1:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f01204a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01204a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204aa:	01 c2                	add    %eax,%edx
f01204ac:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f01204af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204b2:	01 c8                	add    %ecx,%eax
f01204b4:	8a 00                	mov    (%eax),%al
f01204b6:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f01204b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01204bb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204be:	01 c2                	add    %eax,%edx
f01204c0:	8a 45 eb             	mov    -0x15(%ebp),%al
f01204c3:	88 02                	mov    %al,(%edx)
		start++ ;
f01204c5:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f01204c8:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f01204cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01204ce:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01204d1:	7c c4                	jl     f0120497 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f01204d3:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01204d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204d9:	01 d0                	add    %edx,%eax
f01204db:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f01204de:	90                   	nop
f01204df:	c9                   	leave  
f01204e0:	c3                   	ret    

f01204e1 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f01204e1:	55                   	push   %ebp
f01204e2:	89 e5                	mov    %esp,%ebp
f01204e4:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f01204e7:	ff 75 08             	pushl  0x8(%ebp)
f01204ea:	e8 73 fa ff ff       	call   f011ff62 <strlen>
f01204ef:	83 c4 04             	add    $0x4,%esp
f01204f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f01204f5:	ff 75 0c             	pushl  0xc(%ebp)
f01204f8:	e8 65 fa ff ff       	call   f011ff62 <strlen>
f01204fd:	83 c4 04             	add    $0x4,%esp
f0120500:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f0120503:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f012050a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120511:	eb 17                	jmp    f012052a <strcconcat+0x49>
		final[s] = str1[s] ;
f0120513:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120516:	8b 45 10             	mov    0x10(%ebp),%eax
f0120519:	01 c2                	add    %eax,%edx
f012051b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f012051e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120521:	01 c8                	add    %ecx,%eax
f0120523:	8a 00                	mov    (%eax),%al
f0120525:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f0120527:	ff 45 fc             	incl   -0x4(%ebp)
f012052a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012052d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0120530:	7c e1                	jl     f0120513 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f0120532:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f0120539:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f0120540:	eb 1f                	jmp    f0120561 <strcconcat+0x80>
		final[s++] = str2[i] ;
f0120542:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120545:	8d 50 01             	lea    0x1(%eax),%edx
f0120548:	89 55 fc             	mov    %edx,-0x4(%ebp)
f012054b:	89 c2                	mov    %eax,%edx
f012054d:	8b 45 10             	mov    0x10(%ebp),%eax
f0120550:	01 c2                	add    %eax,%edx
f0120552:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f0120555:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120558:	01 c8                	add    %ecx,%eax
f012055a:	8a 00                	mov    (%eax),%al
f012055c:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f012055e:	ff 45 f8             	incl   -0x8(%ebp)
f0120561:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120564:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120567:	7c d9                	jl     f0120542 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f0120569:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012056c:	8b 45 10             	mov    0x10(%ebp),%eax
f012056f:	01 d0                	add    %edx,%eax
f0120571:	c6 00 00             	movb   $0x0,(%eax)
}
f0120574:	90                   	nop
f0120575:	c9                   	leave  
f0120576:	c3                   	ret    

f0120577 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f0120577:	55                   	push   %ebp
f0120578:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f012057a:	8b 45 14             	mov    0x14(%ebp),%eax
f012057d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f0120583:	8b 45 14             	mov    0x14(%ebp),%eax
f0120586:	8b 00                	mov    (%eax),%eax
f0120588:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f012058f:	8b 45 10             	mov    0x10(%ebp),%eax
f0120592:	01 d0                	add    %edx,%eax
f0120594:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f012059a:	eb 0c                	jmp    f01205a8 <strsplit+0x31>
			*string++ = 0;
f012059c:	8b 45 08             	mov    0x8(%ebp),%eax
f012059f:	8d 50 01             	lea    0x1(%eax),%edx
f01205a2:	89 55 08             	mov    %edx,0x8(%ebp)
f01205a5:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f01205a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01205ab:	8a 00                	mov    (%eax),%al
f01205ad:	84 c0                	test   %al,%al
f01205af:	74 18                	je     f01205c9 <strsplit+0x52>
f01205b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01205b4:	8a 00                	mov    (%eax),%al
f01205b6:	0f be c0             	movsbl %al,%eax
f01205b9:	50                   	push   %eax
f01205ba:	ff 75 0c             	pushl  0xc(%ebp)
f01205bd:	e8 32 fb ff ff       	call   f01200f4 <strchr>
f01205c2:	83 c4 08             	add    $0x8,%esp
f01205c5:	85 c0                	test   %eax,%eax
f01205c7:	75 d3                	jne    f012059c <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f01205c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01205cc:	8a 00                	mov    (%eax),%al
f01205ce:	84 c0                	test   %al,%al
f01205d0:	74 5a                	je     f012062c <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f01205d2:	8b 45 14             	mov    0x14(%ebp),%eax
f01205d5:	8b 00                	mov    (%eax),%eax
f01205d7:	83 f8 0f             	cmp    $0xf,%eax
f01205da:	75 07                	jne    f01205e3 <strsplit+0x6c>
		{
			return 0;
f01205dc:	b8 00 00 00 00       	mov    $0x0,%eax
f01205e1:	eb 66                	jmp    f0120649 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f01205e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01205e6:	8b 00                	mov    (%eax),%eax
f01205e8:	8d 48 01             	lea    0x1(%eax),%ecx
f01205eb:	8b 55 14             	mov    0x14(%ebp),%edx
f01205ee:	89 0a                	mov    %ecx,(%edx)
f01205f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01205f7:	8b 45 10             	mov    0x10(%ebp),%eax
f01205fa:	01 c2                	add    %eax,%edx
f01205fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01205ff:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120601:	eb 03                	jmp    f0120606 <strsplit+0x8f>
			string++;
f0120603:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120606:	8b 45 08             	mov    0x8(%ebp),%eax
f0120609:	8a 00                	mov    (%eax),%al
f012060b:	84 c0                	test   %al,%al
f012060d:	74 8b                	je     f012059a <strsplit+0x23>
f012060f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120612:	8a 00                	mov    (%eax),%al
f0120614:	0f be c0             	movsbl %al,%eax
f0120617:	50                   	push   %eax
f0120618:	ff 75 0c             	pushl  0xc(%ebp)
f012061b:	e8 d4 fa ff ff       	call   f01200f4 <strchr>
f0120620:	83 c4 08             	add    $0x8,%esp
f0120623:	85 c0                	test   %eax,%eax
f0120625:	74 dc                	je     f0120603 <strsplit+0x8c>
			string++;
	}
f0120627:	e9 6e ff ff ff       	jmp    f012059a <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f012062c:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f012062d:	8b 45 14             	mov    0x14(%ebp),%eax
f0120630:	8b 00                	mov    (%eax),%eax
f0120632:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120639:	8b 45 10             	mov    0x10(%ebp),%eax
f012063c:	01 d0                	add    %edx,%eax
f012063e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f0120644:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0120649:	c9                   	leave  
f012064a:	c3                   	ret    

f012064b <str2lower>:


char* str2lower(char *dst, const char *src)
{
f012064b:	55                   	push   %ebp
f012064c:	89 e5                	mov    %esp,%ebp
f012064e:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f0120651:	83 ec 04             	sub    $0x4,%esp
f0120654:	68 dc 19 13 f0       	push   $0xf01319dc
f0120659:	68 3f 01 00 00       	push   $0x13f
f012065e:	68 fe 19 13 f0       	push   $0xf01319fe
f0120663:	e8 d1 fc fd ff       	call   f0100339 <_panic>

f0120668 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f0120668:	55                   	push   %ebp
f0120669:	89 e5                	mov    %esp,%ebp
f012066b:	83 ec 18             	sub    $0x18,%esp
f012066e:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0120675:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120678:	89 c2                	mov    %eax,%edx
f012067a:	ec                   	in     (%dx),%al
f012067b:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f012067e:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0120681:	0f b6 c0             	movzbl %al,%eax
f0120684:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120687:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012068a:	25 c0 00 00 00       	and    $0xc0,%eax
f012068f:	83 f8 40             	cmp    $0x40,%eax
f0120692:	75 10                	jne    f01206a4 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f0120694:	83 ec 0c             	sub    $0xc,%esp
f0120697:	68 80 ef 71 f0       	push   $0xf071ef80
f012069c:	e8 6d fd fe ff       	call   f011040e <wakeup_one>
f01206a1:	83 c4 10             	add    $0x10,%esp
	}

}
f01206a4:	90                   	nop
f01206a5:	c9                   	leave  
f01206a6:	c3                   	ret    

f01206a7 <ide_init>:

void ide_init()
{
f01206a7:	55                   	push   %ebp
f01206a8:	89 e5                	mov    %esp,%ebp
f01206aa:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f01206ad:	83 ec 08             	sub    $0x8,%esp
f01206b0:	68 68 06 12 f0       	push   $0xf0120668
f01206b5:	6a 0e                	push   $0xe
f01206b7:	e8 02 df fe ff       	call   f010e5be <irq_install_handler>
f01206bc:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f01206bf:	83 ec 08             	sub    $0x8,%esp
f01206c2:	68 0c 1a 13 f0       	push   $0xf0131a0c
f01206c7:	68 80 ef 71 f0       	push   $0xf071ef80
f01206cc:	e8 a3 fc fe ff       	call   f0110374 <init_channel>
f01206d1:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f01206d4:	83 ec 08             	sub    $0x8,%esp
f01206d7:	68 19 1a 13 f0       	push   $0xf0131a19
f01206dc:	68 a0 f5 b1 f0       	push   $0xf0b1f5a0
f01206e1:	e8 9d f8 fe ff       	call   f010ff83 <init_spinlock>
f01206e6:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f01206e9:	90                   	nop
f01206ea:	c9                   	leave  
f01206eb:	c3                   	ret    

f01206ec <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f01206ec:	55                   	push   %ebp
f01206ed:	89 e5                	mov    %esp,%ebp
f01206ef:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f01206f2:	90                   	nop
f01206f3:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01206fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01206fd:	89 c2                	mov    %eax,%edx
f01206ff:	ec                   	in     (%dx),%al
f0120700:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120703:	8a 45 ef             	mov    -0x11(%ebp),%al
f0120706:	0f b6 c0             	movzbl %al,%eax
f0120709:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012070c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012070f:	25 c0 00 00 00       	and    $0xc0,%eax
f0120714:	83 f8 40             	cmp    $0x40,%eax
f0120717:	75 da                	jne    f01206f3 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f0120719:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012071d:	74 24                	je     f0120743 <ide_wait_ready+0x57>
f012071f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120722:	83 e0 21             	and    $0x21,%eax
f0120725:	85 c0                	test   %eax,%eax
f0120727:	74 1a                	je     f0120743 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f0120729:	83 ec 0c             	sub    $0xc,%esp
f012072c:	ff 75 f4             	pushl  -0xc(%ebp)
f012072f:	ff 75 f4             	pushl  -0xc(%ebp)
f0120732:	68 2c 1a 13 f0       	push   $0xf0131a2c
f0120737:	6a 5d                	push   $0x5d
f0120739:	68 4f 1a 13 f0       	push   $0xf0131a4f
f012073e:	e8 f6 fb fd ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f0120743:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120748:	c9                   	leave  
f0120749:	c3                   	ret    

f012074a <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f012074a:	55                   	push   %ebp
f012074b:	89 e5                	mov    %esp,%ebp
f012074d:	57                   	push   %edi
f012074e:	53                   	push   %ebx
f012074f:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f0120752:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120759:	76 16                	jbe    f0120771 <ide_read+0x27>
f012075b:	68 5a 1a 13 f0       	push   $0xf0131a5a
f0120760:	68 67 1a 13 f0       	push   $0xf0131a67
f0120765:	6a 68                	push   $0x68
f0120767:	68 4f 1a 13 f0       	push   $0xf0131a4f
f012076c:	e8 c8 fb fd ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f0120771:	83 ec 0c             	sub    $0xc,%esp
f0120774:	6a 00                	push   $0x0
f0120776:	e8 71 ff ff ff       	call   f01206ec <ide_wait_ready>
f012077b:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f012077e:	8b 45 10             	mov    0x10(%ebp),%eax
f0120781:	0f b6 c0             	movzbl %al,%eax
f0120784:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f012078b:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f012078e:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0120791:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120794:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0120795:	8b 45 08             	mov    0x8(%ebp),%eax
f0120798:	0f b6 c0             	movzbl %al,%eax
f012079b:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f01207a2:	88 45 d3             	mov    %al,-0x2d(%ebp)
f01207a5:	8a 45 d3             	mov    -0x2d(%ebp),%al
f01207a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01207ab:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f01207ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01207af:	c1 e8 08             	shr    $0x8,%eax
f01207b2:	0f b6 c0             	movzbl %al,%eax
f01207b5:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f01207bc:	88 45 d4             	mov    %al,-0x2c(%ebp)
f01207bf:	8a 45 d4             	mov    -0x2c(%ebp),%al
f01207c2:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01207c5:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f01207c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01207c9:	c1 e8 10             	shr    $0x10,%eax
f01207cc:	0f b6 c0             	movzbl %al,%eax
f01207cf:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f01207d6:	88 45 d5             	mov    %al,-0x2b(%ebp)
f01207d9:	8a 45 d5             	mov    -0x2b(%ebp),%al
f01207dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01207df:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f01207e0:	a1 30 ee 71 f0       	mov    0xf071ee30,%eax
f01207e5:	83 e0 01             	and    $0x1,%eax
f01207e8:	c1 e0 04             	shl    $0x4,%eax
f01207eb:	88 c2                	mov    %al,%dl
f01207ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01207f0:	c1 e8 18             	shr    $0x18,%eax
f01207f3:	83 e0 0f             	and    $0xf,%eax
f01207f6:	09 d0                	or     %edx,%eax
f01207f8:	83 c8 e0             	or     $0xffffffe0,%eax
f01207fb:	0f b6 c0             	movzbl %al,%eax
f01207fe:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120805:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120808:	8a 45 d6             	mov    -0x2a(%ebp),%al
f012080b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012080e:	ee                   	out    %al,(%dx)
f012080f:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120816:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f012081a:	8a 45 d7             	mov    -0x29(%ebp),%al
f012081d:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120820:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120821:	eb 55                	jmp    f0120878 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f0120823:	83 ec 0c             	sub    $0xc,%esp
f0120826:	6a 01                	push   $0x1
f0120828:	e8 bf fe ff ff       	call   f01206ec <ide_wait_ready>
f012082d:	83 c4 10             	add    $0x10,%esp
f0120830:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120833:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120837:	79 05                	jns    f012083e <ide_read+0xf4>
			return r;
f0120839:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012083c:	eb 45                	jmp    f0120883 <ide_read+0x139>
f012083e:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0120845:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120848:	89 45 cc             	mov    %eax,-0x34(%ebp)
f012084b:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f0120852:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120855:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120858:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012085b:	89 cb                	mov    %ecx,%ebx
f012085d:	89 df                	mov    %ebx,%edi
f012085f:	89 c1                	mov    %eax,%ecx
f0120861:	fc                   	cld    
f0120862:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0120864:	89 c8                	mov    %ecx,%eax
f0120866:	89 fb                	mov    %edi,%ebx
f0120868:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f012086b:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f012086e:	ff 4d 10             	decl   0x10(%ebp)
f0120871:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120878:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012087c:	75 a5                	jne    f0120823 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f012087e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120883:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120886:	5b                   	pop    %ebx
f0120887:	5f                   	pop    %edi
f0120888:	5d                   	pop    %ebp
f0120889:	c3                   	ret    

f012088a <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f012088a:	55                   	push   %ebp
f012088b:	89 e5                	mov    %esp,%ebp
f012088d:	56                   	push   %esi
f012088e:	53                   	push   %ebx
f012088f:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f0120892:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120899:	76 19                	jbe    f01208b4 <ide_write+0x2a>
f012089b:	68 5a 1a 13 f0       	push   $0xf0131a5a
f01208a0:	68 67 1a 13 f0       	push   $0xf0131a67
f01208a5:	68 82 00 00 00       	push   $0x82
f01208aa:	68 4f 1a 13 f0       	push   $0xf0131a4f
f01208af:	e8 85 fa fd ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f01208b4:	83 ec 0c             	sub    $0xc,%esp
f01208b7:	6a 00                	push   $0x0
f01208b9:	e8 2e fe ff ff       	call   f01206ec <ide_wait_ready>
f01208be:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f01208c1:	8b 45 10             	mov    0x10(%ebp),%eax
f01208c4:	0f b6 c0             	movzbl %al,%eax
f01208c7:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f01208ce:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01208d1:	8a 45 d2             	mov    -0x2e(%ebp),%al
f01208d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01208d7:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f01208d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01208db:	0f b6 c0             	movzbl %al,%eax
f01208de:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f01208e5:	88 45 d3             	mov    %al,-0x2d(%ebp)
f01208e8:	8a 45 d3             	mov    -0x2d(%ebp),%al
f01208eb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01208ee:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f01208ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01208f2:	c1 e8 08             	shr    $0x8,%eax
f01208f5:	0f b6 c0             	movzbl %al,%eax
f01208f8:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f01208ff:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120902:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0120905:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120908:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120909:	8b 45 08             	mov    0x8(%ebp),%eax
f012090c:	c1 e8 10             	shr    $0x10,%eax
f012090f:	0f b6 c0             	movzbl %al,%eax
f0120912:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120919:	88 45 d5             	mov    %al,-0x2b(%ebp)
f012091c:	8a 45 d5             	mov    -0x2b(%ebp),%al
f012091f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120922:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120923:	a1 30 ee 71 f0       	mov    0xf071ee30,%eax
f0120928:	83 e0 01             	and    $0x1,%eax
f012092b:	c1 e0 04             	shl    $0x4,%eax
f012092e:	88 c2                	mov    %al,%dl
f0120930:	8b 45 08             	mov    0x8(%ebp),%eax
f0120933:	c1 e8 18             	shr    $0x18,%eax
f0120936:	83 e0 0f             	and    $0xf,%eax
f0120939:	09 d0                	or     %edx,%eax
f012093b:	83 c8 e0             	or     $0xffffffe0,%eax
f012093e:	0f b6 c0             	movzbl %al,%eax
f0120941:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120948:	88 45 d6             	mov    %al,-0x2a(%ebp)
f012094b:	8a 45 d6             	mov    -0x2a(%ebp),%al
f012094e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120951:	ee                   	out    %al,(%dx)
f0120952:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120959:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f012095d:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120960:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120963:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120964:	eb 55                	jmp    f01209bb <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f0120966:	83 ec 0c             	sub    $0xc,%esp
f0120969:	6a 01                	push   $0x1
f012096b:	e8 7c fd ff ff       	call   f01206ec <ide_wait_ready>
f0120970:	83 c4 10             	add    $0x10,%esp
f0120973:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120976:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012097a:	79 05                	jns    f0120981 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f012097c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012097f:	eb 45                	jmp    f01209c6 <ide_write+0x13c>
f0120981:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0120988:	8b 45 0c             	mov    0xc(%ebp),%eax
f012098b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f012098e:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f0120995:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120998:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f012099b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012099e:	89 cb                	mov    %ecx,%ebx
f01209a0:	89 de                	mov    %ebx,%esi
f01209a2:	89 c1                	mov    %eax,%ecx
f01209a4:	fc                   	cld    
f01209a5:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f01209a7:	89 c8                	mov    %ecx,%eax
f01209a9:	89 f3                	mov    %esi,%ebx
f01209ab:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f01209ae:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f01209b1:	ff 4d 10             	decl   0x10(%ebp)
f01209b4:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f01209bb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01209bf:	75 a5                	jne    f0120966 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f01209c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01209c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01209c9:	5b                   	pop    %ebx
f01209ca:	5e                   	pop    %esi
f01209cb:	5d                   	pop    %ebp
f01209cc:	c3                   	ret    

f01209cd <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f01209cd:	55                   	push   %ebp
f01209ce:	89 e5                	mov    %esp,%ebp
f01209d0:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f01209d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01209d6:	83 e8 04             	sub    $0x4,%eax
f01209d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f01209dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01209df:	8b 00                	mov    (%eax),%eax
f01209e1:	83 e0 fe             	and    $0xfffffffe,%eax
}
f01209e4:	c9                   	leave  
f01209e5:	c3                   	ret    

f01209e6 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f01209e6:	55                   	push   %ebp
f01209e7:	89 e5                	mov    %esp,%ebp
f01209e9:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f01209ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01209ef:	83 e8 04             	sub    $0x4,%eax
f01209f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f01209f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01209f8:	8b 00                	mov    (%eax),%eax
f01209fa:	83 e0 01             	and    $0x1,%eax
f01209fd:	85 c0                	test   %eax,%eax
f01209ff:	0f 94 c0             	sete   %al
}
f0120a02:	c9                   	leave  
f0120a03:	c3                   	ret    

f0120a04 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f0120a04:	55                   	push   %ebp
f0120a05:	89 e5                	mov    %esp,%ebp
f0120a07:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f0120a0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0120a11:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a14:	83 f8 02             	cmp    $0x2,%eax
f0120a17:	74 2b                	je     f0120a44 <alloc_block+0x40>
f0120a19:	83 f8 02             	cmp    $0x2,%eax
f0120a1c:	7f 07                	jg     f0120a25 <alloc_block+0x21>
f0120a1e:	83 f8 01             	cmp    $0x1,%eax
f0120a21:	74 0e                	je     f0120a31 <alloc_block+0x2d>
f0120a23:	eb 58                	jmp    f0120a7d <alloc_block+0x79>
f0120a25:	83 f8 03             	cmp    $0x3,%eax
f0120a28:	74 2d                	je     f0120a57 <alloc_block+0x53>
f0120a2a:	83 f8 04             	cmp    $0x4,%eax
f0120a2d:	74 3b                	je     f0120a6a <alloc_block+0x66>
f0120a2f:	eb 4c                	jmp    f0120a7d <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f0120a31:	83 ec 0c             	sub    $0xc,%esp
f0120a34:	ff 75 08             	pushl  0x8(%ebp)
f0120a37:	e8 11 03 00 00       	call   f0120d4d <alloc_block_FF>
f0120a3c:	83 c4 10             	add    $0x10,%esp
f0120a3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120a42:	eb 4a                	jmp    f0120a8e <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f0120a44:	83 ec 0c             	sub    $0xc,%esp
f0120a47:	ff 75 08             	pushl  0x8(%ebp)
f0120a4a:	e8 c7 19 00 00       	call   f0122416 <alloc_block_NF>
f0120a4f:	83 c4 10             	add    $0x10,%esp
f0120a52:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120a55:	eb 37                	jmp    f0120a8e <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f0120a57:	83 ec 0c             	sub    $0xc,%esp
f0120a5a:	ff 75 08             	pushl  0x8(%ebp)
f0120a5d:	e8 a7 07 00 00       	call   f0121209 <alloc_block_BF>
f0120a62:	83 c4 10             	add    $0x10,%esp
f0120a65:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120a68:	eb 24                	jmp    f0120a8e <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f0120a6a:	83 ec 0c             	sub    $0xc,%esp
f0120a6d:	ff 75 08             	pushl  0x8(%ebp)
f0120a70:	e8 84 19 00 00       	call   f01223f9 <alloc_block_WF>
f0120a75:	83 c4 10             	add    $0x10,%esp
f0120a78:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120a7b:	eb 11                	jmp    f0120a8e <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f0120a7d:	83 ec 0c             	sub    $0xc,%esp
f0120a80:	68 7c 1a 13 f0       	push   $0xf0131a7c
f0120a85:	e8 01 05 fe ff       	call   f0100f8b <cprintf>
f0120a8a:	83 c4 10             	add    $0x10,%esp
		break;
f0120a8d:	90                   	nop
	}
	return va;
f0120a8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0120a91:	c9                   	leave  
f0120a92:	c3                   	ret    

f0120a93 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f0120a93:	55                   	push   %ebp
f0120a94:	89 e5                	mov    %esp,%ebp
f0120a96:	53                   	push   %ebx
f0120a97:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f0120a9a:	83 ec 0c             	sub    $0xc,%esp
f0120a9d:	68 9c 1a 13 f0       	push   $0xf0131a9c
f0120aa2:	e8 e4 04 fe ff       	call   f0100f8b <cprintf>
f0120aa7:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f0120aaa:	83 ec 0c             	sub    $0xc,%esp
f0120aad:	68 c7 1a 13 f0       	push   $0xf0131ac7
f0120ab2:	e8 d4 04 fe ff       	call   f0100f8b <cprintf>
f0120ab7:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f0120aba:	8b 45 08             	mov    0x8(%ebp),%eax
f0120abd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120ac0:	eb 37                	jmp    f0120af9 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0120ac2:	83 ec 0c             	sub    $0xc,%esp
f0120ac5:	ff 75 f4             	pushl  -0xc(%ebp)
f0120ac8:	e8 19 ff ff ff       	call   f01209e6 <is_free_block>
f0120acd:	83 c4 10             	add    $0x10,%esp
f0120ad0:	0f be d8             	movsbl %al,%ebx
f0120ad3:	83 ec 0c             	sub    $0xc,%esp
f0120ad6:	ff 75 f4             	pushl  -0xc(%ebp)
f0120ad9:	e8 ef fe ff ff       	call   f01209cd <get_block_size>
f0120ade:	83 c4 10             	add    $0x10,%esp
f0120ae1:	83 ec 04             	sub    $0x4,%esp
f0120ae4:	53                   	push   %ebx
f0120ae5:	50                   	push   %eax
f0120ae6:	68 df 1a 13 f0       	push   $0xf0131adf
f0120aeb:	e8 9b 04 fe ff       	call   f0100f8b <cprintf>
f0120af0:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0120af3:	8b 45 10             	mov    0x10(%ebp),%eax
f0120af6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120af9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120afd:	74 07                	je     f0120b06 <print_blocks_list+0x73>
f0120aff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b02:	8b 00                	mov    (%eax),%eax
f0120b04:	eb 05                	jmp    f0120b0b <print_blocks_list+0x78>
f0120b06:	b8 00 00 00 00       	mov    $0x0,%eax
f0120b0b:	89 45 10             	mov    %eax,0x10(%ebp)
f0120b0e:	8b 45 10             	mov    0x10(%ebp),%eax
f0120b11:	85 c0                	test   %eax,%eax
f0120b13:	75 ad                	jne    f0120ac2 <print_blocks_list+0x2f>
f0120b15:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120b19:	75 a7                	jne    f0120ac2 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f0120b1b:	83 ec 0c             	sub    $0xc,%esp
f0120b1e:	68 9c 1a 13 f0       	push   $0xf0131a9c
f0120b23:	e8 63 04 fe ff       	call   f0100f8b <cprintf>
f0120b28:	83 c4 10             	add    $0x10,%esp

}
f0120b2b:	90                   	nop
f0120b2c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0120b2f:	c9                   	leave  
f0120b30:	c3                   	ret    

f0120b31 <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0120b31:	55                   	push   %ebp
f0120b32:	89 e5                	mov    %esp,%ebp
f0120b34:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f0120b37:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120b3a:	83 e0 01             	and    $0x1,%eax
f0120b3d:	85 c0                	test   %eax,%eax
f0120b3f:	74 03                	je     f0120b44 <initialize_dynamic_allocator+0x13>
f0120b41:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f0120b44:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120b48:	0f 84 c7 01 00 00    	je     f0120d15 <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f0120b4e:	c7 05 34 ee 71 f0 01 	movl   $0x1,0xf071ee34
f0120b55:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f0120b58:	8b 55 08             	mov    0x8(%ebp),%edx
f0120b5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120b5e:	01 d0                	add    %edx,%eax
f0120b60:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f0120b65:	0f 87 ad 01 00 00    	ja     f0120d18 <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f0120b6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b6e:	85 c0                	test   %eax,%eax
f0120b70:	0f 89 a5 01 00 00    	jns    f0120d1b <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f0120b76:	8b 55 08             	mov    0x8(%ebp),%edx
f0120b79:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120b7c:	01 d0                	add    %edx,%eax
f0120b7e:	83 e8 04             	sub    $0x4,%eax
f0120b81:	a3 54 f8 f1 f0       	mov    %eax,0xf0f1f854
     struct BlockElement * element = NULL;
f0120b86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f0120b8d:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0120b92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120b95:	e9 87 00 00 00       	jmp    f0120c21 <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f0120b9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120b9e:	75 14                	jne    f0120bb4 <initialize_dynamic_allocator+0x83>
f0120ba0:	83 ec 04             	sub    $0x4,%esp
f0120ba3:	68 f7 1a 13 f0       	push   $0xf0131af7
f0120ba8:	6a 79                	push   $0x79
f0120baa:	68 15 1b 13 f0       	push   $0xf0131b15
f0120baf:	e8 85 f7 fd ff       	call   f0100339 <_panic>
f0120bb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bb7:	8b 00                	mov    (%eax),%eax
f0120bb9:	85 c0                	test   %eax,%eax
f0120bbb:	74 10                	je     f0120bcd <initialize_dynamic_allocator+0x9c>
f0120bbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bc0:	8b 00                	mov    (%eax),%eax
f0120bc2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120bc5:	8b 52 04             	mov    0x4(%edx),%edx
f0120bc8:	89 50 04             	mov    %edx,0x4(%eax)
f0120bcb:	eb 0b                	jmp    f0120bd8 <initialize_dynamic_allocator+0xa7>
f0120bcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bd0:	8b 40 04             	mov    0x4(%eax),%eax
f0120bd3:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120bd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bdb:	8b 40 04             	mov    0x4(%eax),%eax
f0120bde:	85 c0                	test   %eax,%eax
f0120be0:	74 0f                	je     f0120bf1 <initialize_dynamic_allocator+0xc0>
f0120be2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120be5:	8b 40 04             	mov    0x4(%eax),%eax
f0120be8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120beb:	8b 12                	mov    (%edx),%edx
f0120bed:	89 10                	mov    %edx,(%eax)
f0120bef:	eb 0a                	jmp    f0120bfb <initialize_dynamic_allocator+0xca>
f0120bf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bf4:	8b 00                	mov    (%eax),%eax
f0120bf6:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0120bfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bfe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120c04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c07:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120c0e:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120c13:	48                   	dec    %eax
f0120c14:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f0120c19:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0120c1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120c21:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120c25:	74 07                	je     f0120c2e <initialize_dynamic_allocator+0xfd>
f0120c27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c2a:	8b 00                	mov    (%eax),%eax
f0120c2c:	eb 05                	jmp    f0120c33 <initialize_dynamic_allocator+0x102>
f0120c2e:	b8 00 00 00 00       	mov    $0x0,%eax
f0120c33:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f0120c38:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0120c3d:	85 c0                	test   %eax,%eax
f0120c3f:	0f 85 55 ff ff ff    	jne    f0120b9a <initialize_dynamic_allocator+0x69>
f0120c45:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120c49:	0f 85 4b ff ff ff    	jne    f0120b9a <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f0120c4f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c52:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f0120c55:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c58:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f0120c5e:	a1 54 f8 f1 f0       	mov    0xf0f1f854,%eax
f0120c63:	a3 10 f6 b1 f0       	mov    %eax,0xf0b1f610
    end_block->info = 1;
f0120c68:	a1 10 f6 b1 f0       	mov    0xf0b1f610,%eax
f0120c6d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f0120c73:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c76:	83 c0 08             	add    $0x8,%eax
f0120c79:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120c7c:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c7f:	83 c0 04             	add    $0x4,%eax
f0120c82:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120c85:	83 ea 08             	sub    $0x8,%edx
f0120c88:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120c8a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120c8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c90:	01 d0                	add    %edx,%eax
f0120c92:	83 e8 08             	sub    $0x8,%eax
f0120c95:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120c98:	83 ea 08             	sub    $0x8,%edx
f0120c9b:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f0120c9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120ca0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f0120ca6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120ca9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f0120cb0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120cb4:	75 17                	jne    f0120ccd <initialize_dynamic_allocator+0x19c>
f0120cb6:	83 ec 04             	sub    $0x4,%esp
f0120cb9:	68 30 1b 13 f0       	push   $0xf0131b30
f0120cbe:	68 90 00 00 00       	push   $0x90
f0120cc3:	68 15 1b 13 f0       	push   $0xf0131b15
f0120cc8:	e8 6c f6 fd ff       	call   f0100339 <_panic>
f0120ccd:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0120cd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120cd6:	89 10                	mov    %edx,(%eax)
f0120cd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120cdb:	8b 00                	mov    (%eax),%eax
f0120cdd:	85 c0                	test   %eax,%eax
f0120cdf:	74 0d                	je     f0120cee <initialize_dynamic_allocator+0x1bd>
f0120ce1:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0120ce6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120ce9:	89 50 04             	mov    %edx,0x4(%eax)
f0120cec:	eb 08                	jmp    f0120cf6 <initialize_dynamic_allocator+0x1c5>
f0120cee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120cf1:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120cf6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120cf9:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0120cfe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120d01:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120d08:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120d0d:	40                   	inc    %eax
f0120d0e:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0120d13:	eb 07                	jmp    f0120d1c <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f0120d15:	90                   	nop
f0120d16:	eb 04                	jmp    f0120d1c <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f0120d18:	90                   	nop
f0120d19:	eb 01                	jmp    f0120d1c <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f0120d1b:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f0120d1c:	c9                   	leave  
f0120d1d:	c3                   	ret    

f0120d1e <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f0120d1e:	55                   	push   %ebp
f0120d1f:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f0120d21:	8b 45 10             	mov    0x10(%ebp),%eax
f0120d24:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f0120d27:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d2a:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120d2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120d30:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f0120d32:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d35:	83 e8 04             	sub    $0x4,%eax
f0120d38:	8b 00                	mov    (%eax),%eax
f0120d3a:	83 e0 fe             	and    $0xfffffffe,%eax
f0120d3d:	8d 50 f8             	lea    -0x8(%eax),%edx
f0120d40:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d43:	01 c2                	add    %eax,%edx
f0120d45:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120d48:	89 02                	mov    %eax,(%edx)
}
f0120d4a:	90                   	nop
f0120d4b:	5d                   	pop    %ebp
f0120d4c:	c3                   	ret    

f0120d4d <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f0120d4d:	55                   	push   %ebp
f0120d4e:	89 e5                	mov    %esp,%ebp
f0120d50:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120d53:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d56:	83 e0 01             	and    $0x1,%eax
f0120d59:	85 c0                	test   %eax,%eax
f0120d5b:	74 03                	je     f0120d60 <alloc_block_FF+0x13>
f0120d5d:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120d60:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120d64:	77 07                	ja     f0120d6d <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120d66:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120d6d:	a1 34 ee 71 f0       	mov    0xf071ee34,%eax
f0120d72:	85 c0                	test   %eax,%eax
f0120d74:	75 73                	jne    f0120de9 <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120d76:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d79:	83 c0 10             	add    $0x10,%eax
f0120d7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120d7f:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0120d86:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120d89:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120d8c:	01 d0                	add    %edx,%eax
f0120d8e:	48                   	dec    %eax
f0120d8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0120d92:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120d95:	ba 00 00 00 00       	mov    $0x0,%edx
f0120d9a:	f7 75 ec             	divl   -0x14(%ebp)
f0120d9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120da0:	29 d0                	sub    %edx,%eax
f0120da2:	c1 e8 0c             	shr    $0xc,%eax
f0120da5:	83 ec 0c             	sub    $0xc,%esp
f0120da8:	50                   	push   %eax
f0120da9:	e8 ee 88 fe ff       	call   f010969c <sbrk>
f0120dae:	83 c4 10             	add    $0x10,%esp
f0120db1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120db4:	83 ec 0c             	sub    $0xc,%esp
f0120db7:	6a 00                	push   $0x0
f0120db9:	e8 de 88 fe ff       	call   f010969c <sbrk>
f0120dbe:	83 c4 10             	add    $0x10,%esp
f0120dc1:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120dc4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120dc7:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0120dca:	83 ec 08             	sub    $0x8,%esp
f0120dcd:	50                   	push   %eax
f0120dce:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120dd1:	e8 5b fd ff ff       	call   f0120b31 <initialize_dynamic_allocator>
f0120dd6:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120dd9:	83 ec 0c             	sub    $0xc,%esp
f0120ddc:	68 53 1b 13 f0       	push   $0xf0131b53
f0120de1:	e8 a5 01 fe ff       	call   f0100f8b <cprintf>
f0120de6:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0120de9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120ded:	75 0a                	jne    f0120df9 <alloc_block_FF+0xac>
	        return NULL;
f0120def:	b8 00 00 00 00       	mov    $0x0,%eax
f0120df4:	e9 0e 04 00 00       	jmp    f0121207 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f0120df9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120e00:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0120e05:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120e08:	e9 f3 02 00 00       	jmp    f0121100 <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f0120e0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e10:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f0120e13:	83 ec 0c             	sub    $0xc,%esp
f0120e16:	ff 75 bc             	pushl  -0x44(%ebp)
f0120e19:	e8 af fb ff ff       	call   f01209cd <get_block_size>
f0120e1e:	83 c4 10             	add    $0x10,%esp
f0120e21:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f0120e24:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e27:	83 c0 08             	add    $0x8,%eax
f0120e2a:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120e2d:	0f 87 c5 02 00 00    	ja     f01210f8 <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120e33:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e36:	83 c0 18             	add    $0x18,%eax
f0120e39:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120e3c:	0f 87 19 02 00 00    	ja     f012105b <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f0120e42:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120e45:	2b 45 08             	sub    0x8(%ebp),%eax
f0120e48:	83 e8 08             	sub    $0x8,%eax
f0120e4b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f0120e4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e51:	8d 50 08             	lea    0x8(%eax),%edx
f0120e54:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120e57:	01 d0                	add    %edx,%eax
f0120e59:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f0120e5c:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e5f:	83 c0 08             	add    $0x8,%eax
f0120e62:	83 ec 04             	sub    $0x4,%esp
f0120e65:	6a 01                	push   $0x1
f0120e67:	50                   	push   %eax
f0120e68:	ff 75 bc             	pushl  -0x44(%ebp)
f0120e6b:	e8 ae fe ff ff       	call   f0120d1e <set_block_data>
f0120e70:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f0120e73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e76:	8b 40 04             	mov    0x4(%eax),%eax
f0120e79:	85 c0                	test   %eax,%eax
f0120e7b:	75 68                	jne    f0120ee5 <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120e7d:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120e81:	75 17                	jne    f0120e9a <alloc_block_FF+0x14d>
f0120e83:	83 ec 04             	sub    $0x4,%esp
f0120e86:	68 30 1b 13 f0       	push   $0xf0131b30
f0120e8b:	68 d7 00 00 00       	push   $0xd7
f0120e90:	68 15 1b 13 f0       	push   $0xf0131b15
f0120e95:	e8 9f f4 fd ff       	call   f0100339 <_panic>
f0120e9a:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0120ea0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ea3:	89 10                	mov    %edx,(%eax)
f0120ea5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ea8:	8b 00                	mov    (%eax),%eax
f0120eaa:	85 c0                	test   %eax,%eax
f0120eac:	74 0d                	je     f0120ebb <alloc_block_FF+0x16e>
f0120eae:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0120eb3:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120eb6:	89 50 04             	mov    %edx,0x4(%eax)
f0120eb9:	eb 08                	jmp    f0120ec3 <alloc_block_FF+0x176>
f0120ebb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ebe:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120ec3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ec6:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0120ecb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ece:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120ed5:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120eda:	40                   	inc    %eax
f0120edb:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0120ee0:	e9 dc 00 00 00       	jmp    f0120fc1 <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0120ee5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ee8:	8b 00                	mov    (%eax),%eax
f0120eea:	85 c0                	test   %eax,%eax
f0120eec:	75 65                	jne    f0120f53 <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120eee:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120ef2:	75 17                	jne    f0120f0b <alloc_block_FF+0x1be>
f0120ef4:	83 ec 04             	sub    $0x4,%esp
f0120ef7:	68 64 1b 13 f0       	push   $0xf0131b64
f0120efc:	68 db 00 00 00       	push   $0xdb
f0120f01:	68 15 1b 13 f0       	push   $0xf0131b15
f0120f06:	e8 2e f4 fd ff       	call   f0100339 <_panic>
f0120f0b:	8b 15 b4 f1 b1 f0    	mov    0xf0b1f1b4,%edx
f0120f11:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f14:	89 50 04             	mov    %edx,0x4(%eax)
f0120f17:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f1a:	8b 40 04             	mov    0x4(%eax),%eax
f0120f1d:	85 c0                	test   %eax,%eax
f0120f1f:	74 0c                	je     f0120f2d <alloc_block_FF+0x1e0>
f0120f21:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0120f26:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120f29:	89 10                	mov    %edx,(%eax)
f0120f2b:	eb 08                	jmp    f0120f35 <alloc_block_FF+0x1e8>
f0120f2d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f30:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0120f35:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f38:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120f3d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f40:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120f46:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120f4b:	40                   	inc    %eax
f0120f4c:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0120f51:	eb 6e                	jmp    f0120fc1 <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f0120f53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120f57:	74 06                	je     f0120f5f <alloc_block_FF+0x212>
f0120f59:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120f5d:	75 17                	jne    f0120f76 <alloc_block_FF+0x229>
f0120f5f:	83 ec 04             	sub    $0x4,%esp
f0120f62:	68 88 1b 13 f0       	push   $0xf0131b88
f0120f67:	68 df 00 00 00       	push   $0xdf
f0120f6c:	68 15 1b 13 f0       	push   $0xf0131b15
f0120f71:	e8 c3 f3 fd ff       	call   f0100339 <_panic>
f0120f76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f79:	8b 10                	mov    (%eax),%edx
f0120f7b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f7e:	89 10                	mov    %edx,(%eax)
f0120f80:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f83:	8b 00                	mov    (%eax),%eax
f0120f85:	85 c0                	test   %eax,%eax
f0120f87:	74 0b                	je     f0120f94 <alloc_block_FF+0x247>
f0120f89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f8c:	8b 00                	mov    (%eax),%eax
f0120f8e:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120f91:	89 50 04             	mov    %edx,0x4(%eax)
f0120f94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f97:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120f9a:	89 10                	mov    %edx,(%eax)
f0120f9c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120fa2:	89 50 04             	mov    %edx,0x4(%eax)
f0120fa5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120fa8:	8b 00                	mov    (%eax),%eax
f0120faa:	85 c0                	test   %eax,%eax
f0120fac:	75 08                	jne    f0120fb6 <alloc_block_FF+0x269>
f0120fae:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120fb1:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0120fb6:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0120fbb:	40                   	inc    %eax
f0120fbc:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
				}
				LIST_REMOVE(&freeBlocksList, blk);
f0120fc1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120fc5:	75 17                	jne    f0120fde <alloc_block_FF+0x291>
f0120fc7:	83 ec 04             	sub    $0x4,%esp
f0120fca:	68 f7 1a 13 f0       	push   $0xf0131af7
f0120fcf:	68 e1 00 00 00       	push   $0xe1
f0120fd4:	68 15 1b 13 f0       	push   $0xf0131b15
f0120fd9:	e8 5b f3 fd ff       	call   f0100339 <_panic>
f0120fde:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fe1:	8b 00                	mov    (%eax),%eax
f0120fe3:	85 c0                	test   %eax,%eax
f0120fe5:	74 10                	je     f0120ff7 <alloc_block_FF+0x2aa>
f0120fe7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fea:	8b 00                	mov    (%eax),%eax
f0120fec:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120fef:	8b 52 04             	mov    0x4(%edx),%edx
f0120ff2:	89 50 04             	mov    %edx,0x4(%eax)
f0120ff5:	eb 0b                	jmp    f0121002 <alloc_block_FF+0x2b5>
f0120ff7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ffa:	8b 40 04             	mov    0x4(%eax),%eax
f0120ffd:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121002:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121005:	8b 40 04             	mov    0x4(%eax),%eax
f0121008:	85 c0                	test   %eax,%eax
f012100a:	74 0f                	je     f012101b <alloc_block_FF+0x2ce>
f012100c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012100f:	8b 40 04             	mov    0x4(%eax),%eax
f0121012:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121015:	8b 12                	mov    (%edx),%edx
f0121017:	89 10                	mov    %edx,(%eax)
f0121019:	eb 0a                	jmp    f0121025 <alloc_block_FF+0x2d8>
f012101b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012101e:	8b 00                	mov    (%eax),%eax
f0121020:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121025:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121028:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012102e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121031:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121038:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f012103d:	48                   	dec    %eax
f012103e:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
				set_block_data(new_block_va, remaining_size, 0);
f0121043:	83 ec 04             	sub    $0x4,%esp
f0121046:	6a 00                	push   $0x0
f0121048:	ff 75 b4             	pushl  -0x4c(%ebp)
f012104b:	ff 75 b0             	pushl  -0x50(%ebp)
f012104e:	e8 cb fc ff ff       	call   f0120d1e <set_block_data>
f0121053:	83 c4 10             	add    $0x10,%esp
f0121056:	e9 95 00 00 00       	jmp    f01210f0 <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f012105b:	83 ec 04             	sub    $0x4,%esp
f012105e:	6a 01                	push   $0x1
f0121060:	ff 75 b8             	pushl  -0x48(%ebp)
f0121063:	ff 75 bc             	pushl  -0x44(%ebp)
f0121066:	e8 b3 fc ff ff       	call   f0120d1e <set_block_data>
f012106b:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f012106e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121072:	75 17                	jne    f012108b <alloc_block_FF+0x33e>
f0121074:	83 ec 04             	sub    $0x4,%esp
f0121077:	68 f7 1a 13 f0       	push   $0xf0131af7
f012107c:	68 e8 00 00 00       	push   $0xe8
f0121081:	68 15 1b 13 f0       	push   $0xf0131b15
f0121086:	e8 ae f2 fd ff       	call   f0100339 <_panic>
f012108b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012108e:	8b 00                	mov    (%eax),%eax
f0121090:	85 c0                	test   %eax,%eax
f0121092:	74 10                	je     f01210a4 <alloc_block_FF+0x357>
f0121094:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121097:	8b 00                	mov    (%eax),%eax
f0121099:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012109c:	8b 52 04             	mov    0x4(%edx),%edx
f012109f:	89 50 04             	mov    %edx,0x4(%eax)
f01210a2:	eb 0b                	jmp    f01210af <alloc_block_FF+0x362>
f01210a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210a7:	8b 40 04             	mov    0x4(%eax),%eax
f01210aa:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01210af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210b2:	8b 40 04             	mov    0x4(%eax),%eax
f01210b5:	85 c0                	test   %eax,%eax
f01210b7:	74 0f                	je     f01210c8 <alloc_block_FF+0x37b>
f01210b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210bc:	8b 40 04             	mov    0x4(%eax),%eax
f01210bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01210c2:	8b 12                	mov    (%edx),%edx
f01210c4:	89 10                	mov    %edx,(%eax)
f01210c6:	eb 0a                	jmp    f01210d2 <alloc_block_FF+0x385>
f01210c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210cb:	8b 00                	mov    (%eax),%eax
f01210cd:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f01210d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210d5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01210db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210de:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01210e5:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01210ea:	48                   	dec    %eax
f01210eb:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
	            }
	            return va;
f01210f0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01210f3:	e9 0f 01 00 00       	jmp    f0121207 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f01210f8:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f01210fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121100:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121104:	74 07                	je     f012110d <alloc_block_FF+0x3c0>
f0121106:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121109:	8b 00                	mov    (%eax),%eax
f012110b:	eb 05                	jmp    f0121112 <alloc_block_FF+0x3c5>
f012110d:	b8 00 00 00 00       	mov    $0x0,%eax
f0121112:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f0121117:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f012111c:	85 c0                	test   %eax,%eax
f012111e:	0f 85 e9 fc ff ff    	jne    f0120e0d <alloc_block_FF+0xc0>
f0121124:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121128:	0f 85 df fc ff ff    	jne    f0120e0d <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f012112e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121131:	83 c0 08             	add    $0x8,%eax
f0121134:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0121137:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f012113e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121141:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121144:	01 d0                	add    %edx,%eax
f0121146:	48                   	dec    %eax
f0121147:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f012114a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012114d:	ba 00 00 00 00       	mov    $0x0,%edx
f0121152:	f7 75 d8             	divl   -0x28(%ebp)
f0121155:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121158:	29 d0                	sub    %edx,%eax
f012115a:	c1 e8 0c             	shr    $0xc,%eax
f012115d:	83 ec 0c             	sub    $0xc,%esp
f0121160:	50                   	push   %eax
f0121161:	e8 36 85 fe ff       	call   f010969c <sbrk>
f0121166:	83 c4 10             	add    $0x10,%esp
f0121169:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f012116c:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f0121170:	75 0a                	jne    f012117c <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f0121172:	b8 00 00 00 00       	mov    $0x0,%eax
f0121177:	e9 8b 00 00 00       	jmp    f0121207 <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f012117c:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0121183:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121186:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121189:	01 d0                	add    %edx,%eax
f012118b:	48                   	dec    %eax
f012118c:	89 45 c8             	mov    %eax,-0x38(%ebp)
f012118f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121192:	ba 00 00 00 00       	mov    $0x0,%edx
f0121197:	f7 75 cc             	divl   -0x34(%ebp)
f012119a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012119d:	29 d0                	sub    %edx,%eax
f012119f:	8d 50 fc             	lea    -0x4(%eax),%edx
f01211a2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01211a5:	01 d0                	add    %edx,%eax
f01211a7:	a3 10 f6 b1 f0       	mov    %eax,0xf0b1f610
			end_block->info = 1;
f01211ac:	a1 10 f6 b1 f0       	mov    0xf0b1f610,%eax
f01211b1:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f01211b7:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f01211be:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01211c1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01211c4:	01 d0                	add    %edx,%eax
f01211c6:	48                   	dec    %eax
f01211c7:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01211ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01211cd:	ba 00 00 00 00       	mov    $0x0,%edx
f01211d2:	f7 75 c4             	divl   -0x3c(%ebp)
f01211d5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01211d8:	29 d0                	sub    %edx,%eax
f01211da:	83 ec 04             	sub    $0x4,%esp
f01211dd:	6a 01                	push   $0x1
f01211df:	50                   	push   %eax
f01211e0:	ff 75 d0             	pushl  -0x30(%ebp)
f01211e3:	e8 36 fb ff ff       	call   f0120d1e <set_block_data>
f01211e8:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f01211eb:	83 ec 0c             	sub    $0xc,%esp
f01211ee:	ff 75 d0             	pushl  -0x30(%ebp)
f01211f1:	e8 f8 09 00 00       	call   f0121bee <free_block>
f01211f6:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f01211f9:	83 ec 0c             	sub    $0xc,%esp
f01211fc:	ff 75 08             	pushl  0x8(%ebp)
f01211ff:	e8 49 fb ff ff       	call   f0120d4d <alloc_block_FF>
f0121204:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f0121207:	c9                   	leave  
f0121208:	c3                   	ret    

f0121209 <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f0121209:	55                   	push   %ebp
f012120a:	89 e5                	mov    %esp,%ebp
f012120c:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f012120f:	8b 45 08             	mov    0x8(%ebp),%eax
f0121212:	83 e0 01             	and    $0x1,%eax
f0121215:	85 c0                	test   %eax,%eax
f0121217:	74 03                	je     f012121c <alloc_block_BF+0x13>
f0121219:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f012121c:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0121220:	77 07                	ja     f0121229 <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0121222:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0121229:	a1 34 ee 71 f0       	mov    0xf071ee34,%eax
f012122e:	85 c0                	test   %eax,%eax
f0121230:	75 73                	jne    f01212a5 <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0121232:	8b 45 08             	mov    0x8(%ebp),%eax
f0121235:	83 c0 10             	add    $0x10,%eax
f0121238:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f012123b:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f0121242:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121245:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121248:	01 d0                	add    %edx,%eax
f012124a:	48                   	dec    %eax
f012124b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f012124e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121251:	ba 00 00 00 00       	mov    $0x0,%edx
f0121256:	f7 75 e0             	divl   -0x20(%ebp)
f0121259:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012125c:	29 d0                	sub    %edx,%eax
f012125e:	c1 e8 0c             	shr    $0xc,%eax
f0121261:	83 ec 0c             	sub    $0xc,%esp
f0121264:	50                   	push   %eax
f0121265:	e8 32 84 fe ff       	call   f010969c <sbrk>
f012126a:	83 c4 10             	add    $0x10,%esp
f012126d:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0121270:	83 ec 0c             	sub    $0xc,%esp
f0121273:	6a 00                	push   $0x0
f0121275:	e8 22 84 fe ff       	call   f010969c <sbrk>
f012127a:	83 c4 10             	add    $0x10,%esp
f012127d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0121280:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121283:	2b 45 d8             	sub    -0x28(%ebp),%eax
f0121286:	83 ec 08             	sub    $0x8,%esp
f0121289:	50                   	push   %eax
f012128a:	ff 75 d8             	pushl  -0x28(%ebp)
f012128d:	e8 9f f8 ff ff       	call   f0120b31 <initialize_dynamic_allocator>
f0121292:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0121295:	83 ec 0c             	sub    $0xc,%esp
f0121298:	68 53 1b 13 f0       	push   $0xf0131b53
f012129d:	e8 e9 fc fd ff       	call   f0100f8b <cprintf>
f01212a2:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f01212a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f01212ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f01212b3:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f01212ba:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f01212c1:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f01212c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01212c9:	e9 1d 01 00 00       	jmp    f01213eb <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f01212ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212d1:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f01212d4:	83 ec 0c             	sub    $0xc,%esp
f01212d7:	ff 75 a8             	pushl  -0x58(%ebp)
f01212da:	e8 ee f6 ff ff       	call   f01209cd <get_block_size>
f01212df:	83 c4 10             	add    $0x10,%esp
f01212e2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f01212e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01212e8:	83 c0 08             	add    $0x8,%eax
f01212eb:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01212ee:	0f 87 ef 00 00 00    	ja     f01213e3 <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f01212f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01212f7:	83 c0 18             	add    $0x18,%eax
f01212fa:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01212fd:	77 1d                	ja     f012131c <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f01212ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121302:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121305:	0f 86 d8 00 00 00    	jbe    f01213e3 <alloc_block_BF+0x1da>
				{
					best_va = va;
f012130b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f012130e:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f0121311:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0121314:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0121317:	e9 c7 00 00 00       	jmp    f01213e3 <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f012131c:	8b 45 08             	mov    0x8(%ebp),%eax
f012131f:	83 c0 08             	add    $0x8,%eax
f0121322:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121325:	0f 85 9d 00 00 00    	jne    f01213c8 <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f012132b:	83 ec 04             	sub    $0x4,%esp
f012132e:	6a 01                	push   $0x1
f0121330:	ff 75 a4             	pushl  -0x5c(%ebp)
f0121333:	ff 75 a8             	pushl  -0x58(%ebp)
f0121336:	e8 e3 f9 ff ff       	call   f0120d1e <set_block_data>
f012133b:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f012133e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121342:	75 17                	jne    f012135b <alloc_block_BF+0x152>
f0121344:	83 ec 04             	sub    $0x4,%esp
f0121347:	68 f7 1a 13 f0       	push   $0xf0131af7
f012134c:	68 2c 01 00 00       	push   $0x12c
f0121351:	68 15 1b 13 f0       	push   $0xf0131b15
f0121356:	e8 de ef fd ff       	call   f0100339 <_panic>
f012135b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012135e:	8b 00                	mov    (%eax),%eax
f0121360:	85 c0                	test   %eax,%eax
f0121362:	74 10                	je     f0121374 <alloc_block_BF+0x16b>
f0121364:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121367:	8b 00                	mov    (%eax),%eax
f0121369:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012136c:	8b 52 04             	mov    0x4(%edx),%edx
f012136f:	89 50 04             	mov    %edx,0x4(%eax)
f0121372:	eb 0b                	jmp    f012137f <alloc_block_BF+0x176>
f0121374:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121377:	8b 40 04             	mov    0x4(%eax),%eax
f012137a:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f012137f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121382:	8b 40 04             	mov    0x4(%eax),%eax
f0121385:	85 c0                	test   %eax,%eax
f0121387:	74 0f                	je     f0121398 <alloc_block_BF+0x18f>
f0121389:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012138c:	8b 40 04             	mov    0x4(%eax),%eax
f012138f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121392:	8b 12                	mov    (%edx),%edx
f0121394:	89 10                	mov    %edx,(%eax)
f0121396:	eb 0a                	jmp    f01213a2 <alloc_block_BF+0x199>
f0121398:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012139b:	8b 00                	mov    (%eax),%eax
f012139d:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f01213a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01213a5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01213ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01213ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01213b5:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01213ba:	48                   	dec    %eax
f01213bb:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
					return va;
f01213c0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01213c3:	e9 01 04 00 00       	jmp    f01217c9 <alloc_block_BF+0x5c0>
				}
				else
				{
					if (best_blk_size > blk_size)
f01213c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01213cb:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01213ce:	76 13                	jbe    f01213e3 <alloc_block_BF+0x1da>
					{
						internal = 1;
f01213d0:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f01213d7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01213da:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f01213dd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01213e0:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f01213e3:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f01213e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01213eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01213ef:	74 07                	je     f01213f8 <alloc_block_BF+0x1ef>
f01213f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01213f4:	8b 00                	mov    (%eax),%eax
f01213f6:	eb 05                	jmp    f01213fd <alloc_block_BF+0x1f4>
f01213f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01213fd:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f0121402:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0121407:	85 c0                	test   %eax,%eax
f0121409:	0f 85 bf fe ff ff    	jne    f01212ce <alloc_block_BF+0xc5>
f012140f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121413:	0f 85 b5 fe ff ff    	jne    f01212ce <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f0121419:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012141d:	0f 84 26 02 00 00    	je     f0121649 <alloc_block_BF+0x440>
f0121423:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0121427:	0f 85 1c 02 00 00    	jne    f0121649 <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f012142d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121430:	2b 45 08             	sub    0x8(%ebp),%eax
f0121433:	83 e8 08             	sub    $0x8,%eax
f0121436:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f0121439:	8b 45 08             	mov    0x8(%ebp),%eax
f012143c:	8d 50 08             	lea    0x8(%eax),%edx
f012143f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121442:	01 d0                	add    %edx,%eax
f0121444:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f0121447:	8b 45 08             	mov    0x8(%ebp),%eax
f012144a:	83 c0 08             	add    $0x8,%eax
f012144d:	83 ec 04             	sub    $0x4,%esp
f0121450:	6a 01                	push   $0x1
f0121452:	50                   	push   %eax
f0121453:	ff 75 f0             	pushl  -0x10(%ebp)
f0121456:	e8 c3 f8 ff ff       	call   f0120d1e <set_block_data>
f012145b:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f012145e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121461:	8b 40 04             	mov    0x4(%eax),%eax
f0121464:	85 c0                	test   %eax,%eax
f0121466:	75 68                	jne    f01214d0 <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0121468:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f012146c:	75 17                	jne    f0121485 <alloc_block_BF+0x27c>
f012146e:	83 ec 04             	sub    $0x4,%esp
f0121471:	68 30 1b 13 f0       	push   $0xf0131b30
f0121476:	68 45 01 00 00       	push   $0x145
f012147b:	68 15 1b 13 f0       	push   $0xf0131b15
f0121480:	e8 b4 ee fd ff       	call   f0100339 <_panic>
f0121485:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f012148b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012148e:	89 10                	mov    %edx,(%eax)
f0121490:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121493:	8b 00                	mov    (%eax),%eax
f0121495:	85 c0                	test   %eax,%eax
f0121497:	74 0d                	je     f01214a6 <alloc_block_BF+0x29d>
f0121499:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f012149e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01214a1:	89 50 04             	mov    %edx,0x4(%eax)
f01214a4:	eb 08                	jmp    f01214ae <alloc_block_BF+0x2a5>
f01214a6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01214a9:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01214ae:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01214b1:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f01214b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01214b9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01214c0:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01214c5:	40                   	inc    %eax
f01214c6:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f01214cb:	e9 dc 00 00 00       	jmp    f01215ac <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f01214d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01214d3:	8b 00                	mov    (%eax),%eax
f01214d5:	85 c0                	test   %eax,%eax
f01214d7:	75 65                	jne    f012153e <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f01214d9:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01214dd:	75 17                	jne    f01214f6 <alloc_block_BF+0x2ed>
f01214df:	83 ec 04             	sub    $0x4,%esp
f01214e2:	68 64 1b 13 f0       	push   $0xf0131b64
f01214e7:	68 4a 01 00 00       	push   $0x14a
f01214ec:	68 15 1b 13 f0       	push   $0xf0131b15
f01214f1:	e8 43 ee fd ff       	call   f0100339 <_panic>
f01214f6:	8b 15 b4 f1 b1 f0    	mov    0xf0b1f1b4,%edx
f01214fc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01214ff:	89 50 04             	mov    %edx,0x4(%eax)
f0121502:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121505:	8b 40 04             	mov    0x4(%eax),%eax
f0121508:	85 c0                	test   %eax,%eax
f012150a:	74 0c                	je     f0121518 <alloc_block_BF+0x30f>
f012150c:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0121511:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0121514:	89 10                	mov    %edx,(%eax)
f0121516:	eb 08                	jmp    f0121520 <alloc_block_BF+0x317>
f0121518:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012151b:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121520:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121523:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121528:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012152b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121531:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121536:	40                   	inc    %eax
f0121537:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f012153c:	eb 6e                	jmp    f01215ac <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f012153e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121542:	74 06                	je     f012154a <alloc_block_BF+0x341>
f0121544:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121548:	75 17                	jne    f0121561 <alloc_block_BF+0x358>
f012154a:	83 ec 04             	sub    $0x4,%esp
f012154d:	68 88 1b 13 f0       	push   $0xf0131b88
f0121552:	68 4f 01 00 00       	push   $0x14f
f0121557:	68 15 1b 13 f0       	push   $0xf0131b15
f012155c:	e8 d8 ed fd ff       	call   f0100339 <_panic>
f0121561:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121564:	8b 10                	mov    (%eax),%edx
f0121566:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121569:	89 10                	mov    %edx,(%eax)
f012156b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012156e:	8b 00                	mov    (%eax),%eax
f0121570:	85 c0                	test   %eax,%eax
f0121572:	74 0b                	je     f012157f <alloc_block_BF+0x376>
f0121574:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121577:	8b 00                	mov    (%eax),%eax
f0121579:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012157c:	89 50 04             	mov    %edx,0x4(%eax)
f012157f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121582:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0121585:	89 10                	mov    %edx,(%eax)
f0121587:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012158a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012158d:	89 50 04             	mov    %edx,0x4(%eax)
f0121590:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121593:	8b 00                	mov    (%eax),%eax
f0121595:	85 c0                	test   %eax,%eax
f0121597:	75 08                	jne    f01215a1 <alloc_block_BF+0x398>
f0121599:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012159c:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01215a1:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01215a6:	40                   	inc    %eax
f01215a7:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f01215ac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01215b0:	75 17                	jne    f01215c9 <alloc_block_BF+0x3c0>
f01215b2:	83 ec 04             	sub    $0x4,%esp
f01215b5:	68 f7 1a 13 f0       	push   $0xf0131af7
f01215ba:	68 51 01 00 00       	push   $0x151
f01215bf:	68 15 1b 13 f0       	push   $0xf0131b15
f01215c4:	e8 70 ed fd ff       	call   f0100339 <_panic>
f01215c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215cc:	8b 00                	mov    (%eax),%eax
f01215ce:	85 c0                	test   %eax,%eax
f01215d0:	74 10                	je     f01215e2 <alloc_block_BF+0x3d9>
f01215d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215d5:	8b 00                	mov    (%eax),%eax
f01215d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01215da:	8b 52 04             	mov    0x4(%edx),%edx
f01215dd:	89 50 04             	mov    %edx,0x4(%eax)
f01215e0:	eb 0b                	jmp    f01215ed <alloc_block_BF+0x3e4>
f01215e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215e5:	8b 40 04             	mov    0x4(%eax),%eax
f01215e8:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01215ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215f0:	8b 40 04             	mov    0x4(%eax),%eax
f01215f3:	85 c0                	test   %eax,%eax
f01215f5:	74 0f                	je     f0121606 <alloc_block_BF+0x3fd>
f01215f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01215fa:	8b 40 04             	mov    0x4(%eax),%eax
f01215fd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121600:	8b 12                	mov    (%edx),%edx
f0121602:	89 10                	mov    %edx,(%eax)
f0121604:	eb 0a                	jmp    f0121610 <alloc_block_BF+0x407>
f0121606:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121609:	8b 00                	mov    (%eax),%eax
f012160b:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121610:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121613:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121619:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012161c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121623:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121628:	48                   	dec    %eax
f0121629:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
			set_block_data(new_block_va, remaining_size, 0);
f012162e:	83 ec 04             	sub    $0x4,%esp
f0121631:	6a 00                	push   $0x0
f0121633:	ff 75 d0             	pushl  -0x30(%ebp)
f0121636:	ff 75 cc             	pushl  -0x34(%ebp)
f0121639:	e8 e0 f6 ff ff       	call   f0120d1e <set_block_data>
f012163e:	83 c4 10             	add    $0x10,%esp
			return best_va;
f0121641:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121644:	e9 80 01 00 00       	jmp    f01217c9 <alloc_block_BF+0x5c0>
	}
	else if(internal == 1)
f0121649:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f012164d:	0f 85 9d 00 00 00    	jne    f01216f0 <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f0121653:	83 ec 04             	sub    $0x4,%esp
f0121656:	6a 01                	push   $0x1
f0121658:	ff 75 ec             	pushl  -0x14(%ebp)
f012165b:	ff 75 f0             	pushl  -0x10(%ebp)
f012165e:	e8 bb f6 ff ff       	call   f0120d1e <set_block_data>
f0121663:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f0121666:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012166a:	75 17                	jne    f0121683 <alloc_block_BF+0x47a>
f012166c:	83 ec 04             	sub    $0x4,%esp
f012166f:	68 f7 1a 13 f0       	push   $0xf0131af7
f0121674:	68 58 01 00 00       	push   $0x158
f0121679:	68 15 1b 13 f0       	push   $0xf0131b15
f012167e:	e8 b6 ec fd ff       	call   f0100339 <_panic>
f0121683:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121686:	8b 00                	mov    (%eax),%eax
f0121688:	85 c0                	test   %eax,%eax
f012168a:	74 10                	je     f012169c <alloc_block_BF+0x493>
f012168c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012168f:	8b 00                	mov    (%eax),%eax
f0121691:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121694:	8b 52 04             	mov    0x4(%edx),%edx
f0121697:	89 50 04             	mov    %edx,0x4(%eax)
f012169a:	eb 0b                	jmp    f01216a7 <alloc_block_BF+0x49e>
f012169c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012169f:	8b 40 04             	mov    0x4(%eax),%eax
f01216a2:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01216a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216aa:	8b 40 04             	mov    0x4(%eax),%eax
f01216ad:	85 c0                	test   %eax,%eax
f01216af:	74 0f                	je     f01216c0 <alloc_block_BF+0x4b7>
f01216b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216b4:	8b 40 04             	mov    0x4(%eax),%eax
f01216b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01216ba:	8b 12                	mov    (%edx),%edx
f01216bc:	89 10                	mov    %edx,(%eax)
f01216be:	eb 0a                	jmp    f01216ca <alloc_block_BF+0x4c1>
f01216c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216c3:	8b 00                	mov    (%eax),%eax
f01216c5:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f01216ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01216d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216d6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01216dd:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01216e2:	48                   	dec    %eax
f01216e3:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
		return best_va;
f01216e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216eb:	e9 d9 00 00 00       	jmp    f01217c9 <alloc_block_BF+0x5c0>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f01216f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01216f3:	83 c0 08             	add    $0x8,%eax
f01216f6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f01216f9:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0121700:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121703:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121706:	01 d0                	add    %edx,%eax
f0121708:	48                   	dec    %eax
f0121709:	89 45 c0             	mov    %eax,-0x40(%ebp)
f012170c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012170f:	ba 00 00 00 00       	mov    $0x0,%edx
f0121714:	f7 75 c4             	divl   -0x3c(%ebp)
f0121717:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012171a:	29 d0                	sub    %edx,%eax
f012171c:	c1 e8 0c             	shr    $0xc,%eax
f012171f:	83 ec 0c             	sub    $0xc,%esp
f0121722:	50                   	push   %eax
f0121723:	e8 74 7f fe ff       	call   f010969c <sbrk>
f0121728:	83 c4 10             	add    $0x10,%esp
f012172b:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f012172e:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f0121732:	75 0a                	jne    f012173e <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f0121734:	b8 00 00 00 00       	mov    $0x0,%eax
f0121739:	e9 8b 00 00 00       	jmp    f01217c9 <alloc_block_BF+0x5c0>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f012173e:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f0121745:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121748:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012174b:	01 d0                	add    %edx,%eax
f012174d:	48                   	dec    %eax
f012174e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0121751:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0121754:	ba 00 00 00 00       	mov    $0x0,%edx
f0121759:	f7 75 b8             	divl   -0x48(%ebp)
f012175c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f012175f:	29 d0                	sub    %edx,%eax
f0121761:	8d 50 fc             	lea    -0x4(%eax),%edx
f0121764:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0121767:	01 d0                	add    %edx,%eax
f0121769:	a3 10 f6 b1 f0       	mov    %eax,0xf0b1f610
				end_block->info = 1;
f012176e:	a1 10 f6 b1 f0       	mov    0xf0b1f610,%eax
f0121773:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				
			
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0121779:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f0121780:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121783:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0121786:	01 d0                	add    %edx,%eax
f0121788:	48                   	dec    %eax
f0121789:	89 45 ac             	mov    %eax,-0x54(%ebp)
f012178c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f012178f:	ba 00 00 00 00       	mov    $0x0,%edx
f0121794:	f7 75 b0             	divl   -0x50(%ebp)
f0121797:	8b 45 ac             	mov    -0x54(%ebp),%eax
f012179a:	29 d0                	sub    %edx,%eax
f012179c:	83 ec 04             	sub    $0x4,%esp
f012179f:	6a 01                	push   $0x1
f01217a1:	50                   	push   %eax
f01217a2:	ff 75 bc             	pushl  -0x44(%ebp)
f01217a5:	e8 74 f5 ff ff       	call   f0120d1e <set_block_data>
f01217aa:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f01217ad:	83 ec 0c             	sub    $0xc,%esp
f01217b0:	ff 75 bc             	pushl  -0x44(%ebp)
f01217b3:	e8 36 04 00 00       	call   f0121bee <free_block>
f01217b8:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f01217bb:	83 ec 0c             	sub    $0xc,%esp
f01217be:	ff 75 08             	pushl  0x8(%ebp)
f01217c1:	e8 43 fa ff ff       	call   f0121209 <alloc_block_BF>
f01217c6:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f01217c9:	c9                   	leave  
f01217ca:	c3                   	ret    

f01217cb <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f01217cb:	55                   	push   %ebp
f01217cc:	89 e5                	mov    %esp,%ebp
f01217ce:	53                   	push   %ebx
f01217cf:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f01217d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01217d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f01217e0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01217e4:	74 1e                	je     f0121804 <merging+0x39>
f01217e6:	ff 75 08             	pushl  0x8(%ebp)
f01217e9:	e8 df f1 ff ff       	call   f01209cd <get_block_size>
f01217ee:	83 c4 04             	add    $0x4,%esp
f01217f1:	89 c2                	mov    %eax,%edx
f01217f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01217f6:	01 d0                	add    %edx,%eax
f01217f8:	3b 45 10             	cmp    0x10(%ebp),%eax
f01217fb:	75 07                	jne    f0121804 <merging+0x39>
		prev_is_free = 1;
f01217fd:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f0121804:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121808:	74 1e                	je     f0121828 <merging+0x5d>
f012180a:	ff 75 10             	pushl  0x10(%ebp)
f012180d:	e8 bb f1 ff ff       	call   f01209cd <get_block_size>
f0121812:	83 c4 04             	add    $0x4,%esp
f0121815:	89 c2                	mov    %eax,%edx
f0121817:	8b 45 10             	mov    0x10(%ebp),%eax
f012181a:	01 d0                	add    %edx,%eax
f012181c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f012181f:	75 07                	jne    f0121828 <merging+0x5d>
		next_is_free = 1;
f0121821:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f0121828:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012182c:	0f 84 cc 00 00 00    	je     f01218fe <merging+0x133>
f0121832:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121836:	0f 84 c2 00 00 00    	je     f01218fe <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f012183c:	ff 75 08             	pushl  0x8(%ebp)
f012183f:	e8 89 f1 ff ff       	call   f01209cd <get_block_size>
f0121844:	83 c4 04             	add    $0x4,%esp
f0121847:	89 c3                	mov    %eax,%ebx
f0121849:	ff 75 10             	pushl  0x10(%ebp)
f012184c:	e8 7c f1 ff ff       	call   f01209cd <get_block_size>
f0121851:	83 c4 04             	add    $0x4,%esp
f0121854:	01 c3                	add    %eax,%ebx
f0121856:	ff 75 0c             	pushl  0xc(%ebp)
f0121859:	e8 6f f1 ff ff       	call   f01209cd <get_block_size>
f012185e:	83 c4 04             	add    $0x4,%esp
f0121861:	01 d8                	add    %ebx,%eax
f0121863:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0121866:	6a 00                	push   $0x0
f0121868:	ff 75 ec             	pushl  -0x14(%ebp)
f012186b:	ff 75 08             	pushl  0x8(%ebp)
f012186e:	e8 ab f4 ff ff       	call   f0120d1e <set_block_data>
f0121873:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f0121876:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012187a:	75 17                	jne    f0121893 <merging+0xc8>
f012187c:	83 ec 04             	sub    $0x4,%esp
f012187f:	68 f7 1a 13 f0       	push   $0xf0131af7
f0121884:	68 7d 01 00 00       	push   $0x17d
f0121889:	68 15 1b 13 f0       	push   $0xf0131b15
f012188e:	e8 a6 ea fd ff       	call   f0100339 <_panic>
f0121893:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121896:	8b 00                	mov    (%eax),%eax
f0121898:	85 c0                	test   %eax,%eax
f012189a:	74 10                	je     f01218ac <merging+0xe1>
f012189c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012189f:	8b 00                	mov    (%eax),%eax
f01218a1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01218a4:	8b 52 04             	mov    0x4(%edx),%edx
f01218a7:	89 50 04             	mov    %edx,0x4(%eax)
f01218aa:	eb 0b                	jmp    f01218b7 <merging+0xec>
f01218ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f01218af:	8b 40 04             	mov    0x4(%eax),%eax
f01218b2:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f01218b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01218ba:	8b 40 04             	mov    0x4(%eax),%eax
f01218bd:	85 c0                	test   %eax,%eax
f01218bf:	74 0f                	je     f01218d0 <merging+0x105>
f01218c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01218c4:	8b 40 04             	mov    0x4(%eax),%eax
f01218c7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01218ca:	8b 12                	mov    (%edx),%edx
f01218cc:	89 10                	mov    %edx,(%eax)
f01218ce:	eb 0a                	jmp    f01218da <merging+0x10f>
f01218d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01218d3:	8b 00                	mov    (%eax),%eax
f01218d5:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f01218da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01218dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01218e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01218e6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01218ed:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01218f2:	48                   	dec    %eax
f01218f3:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f01218f8:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01218f9:	e9 ea 02 00 00       	jmp    f0121be8 <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f01218fe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121902:	74 3b                	je     f012193f <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f0121904:	83 ec 0c             	sub    $0xc,%esp
f0121907:	ff 75 08             	pushl  0x8(%ebp)
f012190a:	e8 be f0 ff ff       	call   f01209cd <get_block_size>
f012190f:	83 c4 10             	add    $0x10,%esp
f0121912:	89 c3                	mov    %eax,%ebx
f0121914:	83 ec 0c             	sub    $0xc,%esp
f0121917:	ff 75 10             	pushl  0x10(%ebp)
f012191a:	e8 ae f0 ff ff       	call   f01209cd <get_block_size>
f012191f:	83 c4 10             	add    $0x10,%esp
f0121922:	01 d8                	add    %ebx,%eax
f0121924:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0121927:	83 ec 04             	sub    $0x4,%esp
f012192a:	6a 00                	push   $0x0
f012192c:	ff 75 e8             	pushl  -0x18(%ebp)
f012192f:	ff 75 08             	pushl  0x8(%ebp)
f0121932:	e8 e7 f3 ff ff       	call   f0120d1e <set_block_data>
f0121937:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f012193a:	e9 a9 02 00 00       	jmp    f0121be8 <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f012193f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121943:	0f 84 2d 01 00 00    	je     f0121a76 <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f0121949:	83 ec 0c             	sub    $0xc,%esp
f012194c:	ff 75 10             	pushl  0x10(%ebp)
f012194f:	e8 79 f0 ff ff       	call   f01209cd <get_block_size>
f0121954:	83 c4 10             	add    $0x10,%esp
f0121957:	89 c3                	mov    %eax,%ebx
f0121959:	83 ec 0c             	sub    $0xc,%esp
f012195c:	ff 75 0c             	pushl  0xc(%ebp)
f012195f:	e8 69 f0 ff ff       	call   f01209cd <get_block_size>
f0121964:	83 c4 10             	add    $0x10,%esp
f0121967:	01 d8                	add    %ebx,%eax
f0121969:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f012196c:	83 ec 04             	sub    $0x4,%esp
f012196f:	6a 00                	push   $0x0
f0121971:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121974:	ff 75 10             	pushl  0x10(%ebp)
f0121977:	e8 a2 f3 ff ff       	call   f0120d1e <set_block_data>
f012197c:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f012197f:	8b 45 10             	mov    0x10(%ebp),%eax
f0121982:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f0121985:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121989:	74 06                	je     f0121991 <merging+0x1c6>
f012198b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f012198f:	75 17                	jne    f01219a8 <merging+0x1dd>
f0121991:	83 ec 04             	sub    $0x4,%esp
f0121994:	68 bc 1b 13 f0       	push   $0xf0131bbc
f0121999:	68 8d 01 00 00       	push   $0x18d
f012199e:	68 15 1b 13 f0       	push   $0xf0131b15
f01219a3:	e8 91 e9 fd ff       	call   f0100339 <_panic>
f01219a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219ab:	8b 50 04             	mov    0x4(%eax),%edx
f01219ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01219b1:	89 50 04             	mov    %edx,0x4(%eax)
f01219b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01219b7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01219ba:	89 10                	mov    %edx,(%eax)
f01219bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219bf:	8b 40 04             	mov    0x4(%eax),%eax
f01219c2:	85 c0                	test   %eax,%eax
f01219c4:	74 0d                	je     f01219d3 <merging+0x208>
f01219c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219c9:	8b 40 04             	mov    0x4(%eax),%eax
f01219cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01219cf:	89 10                	mov    %edx,(%eax)
f01219d1:	eb 08                	jmp    f01219db <merging+0x210>
f01219d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01219d6:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f01219db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219de:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01219e1:	89 50 04             	mov    %edx,0x4(%eax)
f01219e4:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01219e9:	40                   	inc    %eax
f01219ea:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
		LIST_REMOVE(&freeBlocksList, next_block);
f01219ef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01219f3:	75 17                	jne    f0121a0c <merging+0x241>
f01219f5:	83 ec 04             	sub    $0x4,%esp
f01219f8:	68 f7 1a 13 f0       	push   $0xf0131af7
f01219fd:	68 8e 01 00 00       	push   $0x18e
f0121a02:	68 15 1b 13 f0       	push   $0xf0131b15
f0121a07:	e8 2d e9 fd ff       	call   f0100339 <_panic>
f0121a0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a0f:	8b 00                	mov    (%eax),%eax
f0121a11:	85 c0                	test   %eax,%eax
f0121a13:	74 10                	je     f0121a25 <merging+0x25a>
f0121a15:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a18:	8b 00                	mov    (%eax),%eax
f0121a1a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121a1d:	8b 52 04             	mov    0x4(%edx),%edx
f0121a20:	89 50 04             	mov    %edx,0x4(%eax)
f0121a23:	eb 0b                	jmp    f0121a30 <merging+0x265>
f0121a25:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a28:	8b 40 04             	mov    0x4(%eax),%eax
f0121a2b:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121a30:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a33:	8b 40 04             	mov    0x4(%eax),%eax
f0121a36:	85 c0                	test   %eax,%eax
f0121a38:	74 0f                	je     f0121a49 <merging+0x27e>
f0121a3a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a3d:	8b 40 04             	mov    0x4(%eax),%eax
f0121a40:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121a43:	8b 12                	mov    (%edx),%edx
f0121a45:	89 10                	mov    %edx,(%eax)
f0121a47:	eb 0a                	jmp    f0121a53 <merging+0x288>
f0121a49:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a4c:	8b 00                	mov    (%eax),%eax
f0121a4e:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121a53:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a56:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121a5c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a5f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121a66:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121a6b:	48                   	dec    %eax
f0121a6c:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121a71:	e9 72 01 00 00       	jmp    f0121be8 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f0121a76:	8b 45 10             	mov    0x10(%ebp),%eax
f0121a79:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0121a7c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121a80:	74 79                	je     f0121afb <merging+0x330>
f0121a82:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121a86:	74 73                	je     f0121afb <merging+0x330>
f0121a88:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121a8c:	74 06                	je     f0121a94 <merging+0x2c9>
f0121a8e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121a92:	75 17                	jne    f0121aab <merging+0x2e0>
f0121a94:	83 ec 04             	sub    $0x4,%esp
f0121a97:	68 88 1b 13 f0       	push   $0xf0131b88
f0121a9c:	68 94 01 00 00       	push   $0x194
f0121aa1:	68 15 1b 13 f0       	push   $0xf0131b15
f0121aa6:	e8 8e e8 fd ff       	call   f0100339 <_panic>
f0121aab:	8b 45 08             	mov    0x8(%ebp),%eax
f0121aae:	8b 10                	mov    (%eax),%edx
f0121ab0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121ab3:	89 10                	mov    %edx,(%eax)
f0121ab5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121ab8:	8b 00                	mov    (%eax),%eax
f0121aba:	85 c0                	test   %eax,%eax
f0121abc:	74 0b                	je     f0121ac9 <merging+0x2fe>
f0121abe:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ac1:	8b 00                	mov    (%eax),%eax
f0121ac3:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121ac6:	89 50 04             	mov    %edx,0x4(%eax)
f0121ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0121acc:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121acf:	89 10                	mov    %edx,(%eax)
f0121ad1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121ad4:	8b 55 08             	mov    0x8(%ebp),%edx
f0121ad7:	89 50 04             	mov    %edx,0x4(%eax)
f0121ada:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121add:	8b 00                	mov    (%eax),%eax
f0121adf:	85 c0                	test   %eax,%eax
f0121ae1:	75 08                	jne    f0121aeb <merging+0x320>
f0121ae3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121ae6:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121aeb:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121af0:	40                   	inc    %eax
f0121af1:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121af6:	e9 ce 00 00 00       	jmp    f0121bc9 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0121afb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121aff:	74 65                	je     f0121b66 <merging+0x39b>
f0121b01:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121b05:	75 17                	jne    f0121b1e <merging+0x353>
f0121b07:	83 ec 04             	sub    $0x4,%esp
f0121b0a:	68 64 1b 13 f0       	push   $0xf0131b64
f0121b0f:	68 95 01 00 00       	push   $0x195
f0121b14:	68 15 1b 13 f0       	push   $0xf0131b15
f0121b19:	e8 1b e8 fd ff       	call   f0100339 <_panic>
f0121b1e:	8b 15 b4 f1 b1 f0    	mov    0xf0b1f1b4,%edx
f0121b24:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b27:	89 50 04             	mov    %edx,0x4(%eax)
f0121b2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b2d:	8b 40 04             	mov    0x4(%eax),%eax
f0121b30:	85 c0                	test   %eax,%eax
f0121b32:	74 0c                	je     f0121b40 <merging+0x375>
f0121b34:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0121b39:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121b3c:	89 10                	mov    %edx,(%eax)
f0121b3e:	eb 08                	jmp    f0121b48 <merging+0x37d>
f0121b40:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b43:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121b48:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b4b:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121b50:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b53:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121b59:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121b5e:	40                   	inc    %eax
f0121b5f:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121b64:	eb 63                	jmp    f0121bc9 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f0121b66:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121b6a:	75 17                	jne    f0121b83 <merging+0x3b8>
f0121b6c:	83 ec 04             	sub    $0x4,%esp
f0121b6f:	68 30 1b 13 f0       	push   $0xf0131b30
f0121b74:	68 98 01 00 00       	push   $0x198
f0121b79:	68 15 1b 13 f0       	push   $0xf0131b15
f0121b7e:	e8 b6 e7 fd ff       	call   f0100339 <_panic>
f0121b83:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0121b89:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b8c:	89 10                	mov    %edx,(%eax)
f0121b8e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b91:	8b 00                	mov    (%eax),%eax
f0121b93:	85 c0                	test   %eax,%eax
f0121b95:	74 0d                	je     f0121ba4 <merging+0x3d9>
f0121b97:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121b9c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121b9f:	89 50 04             	mov    %edx,0x4(%eax)
f0121ba2:	eb 08                	jmp    f0121bac <merging+0x3e1>
f0121ba4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121ba7:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121bac:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121baf:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121bb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121bb7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121bbe:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121bc3:	40                   	inc    %eax
f0121bc4:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
		}
		set_block_data(va, get_block_size(va), 0);
f0121bc9:	83 ec 0c             	sub    $0xc,%esp
f0121bcc:	ff 75 10             	pushl  0x10(%ebp)
f0121bcf:	e8 f9 ed ff ff       	call   f01209cd <get_block_size>
f0121bd4:	83 c4 10             	add    $0x10,%esp
f0121bd7:	83 ec 04             	sub    $0x4,%esp
f0121bda:	6a 00                	push   $0x0
f0121bdc:	50                   	push   %eax
f0121bdd:	ff 75 10             	pushl  0x10(%ebp)
f0121be0:	e8 39 f1 ff ff       	call   f0120d1e <set_block_data>
f0121be5:	83 c4 10             	add    $0x10,%esp
	}
}
f0121be8:	90                   	nop
f0121be9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121bec:	c9                   	leave  
f0121bed:	c3                   	ret    

f0121bee <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121bee:	55                   	push   %ebp
f0121bef:	89 e5                	mov    %esp,%ebp
f0121bf1:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f0121bf4:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121bf9:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0121bfc:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0121c01:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121c04:	73 1b                	jae    f0121c21 <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f0121c06:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0121c0b:	83 ec 04             	sub    $0x4,%esp
f0121c0e:	ff 75 08             	pushl  0x8(%ebp)
f0121c11:	6a 00                	push   $0x0
f0121c13:	50                   	push   %eax
f0121c14:	e8 b2 fb ff ff       	call   f01217cb <merging>
f0121c19:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121c1c:	e9 8b 00 00 00       	jmp    f0121cac <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f0121c21:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121c26:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121c29:	76 18                	jbe    f0121c43 <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f0121c2b:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121c30:	83 ec 04             	sub    $0x4,%esp
f0121c33:	ff 75 08             	pushl  0x8(%ebp)
f0121c36:	50                   	push   %eax
f0121c37:	6a 00                	push   $0x0
f0121c39:	e8 8d fb ff ff       	call   f01217cb <merging>
f0121c3e:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121c41:	eb 69                	jmp    f0121cac <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121c43:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121c48:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121c4b:	eb 39                	jmp    f0121c86 <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f0121c4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121c50:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121c53:	73 29                	jae    f0121c7e <free_block+0x90>
f0121c55:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121c58:	8b 00                	mov    (%eax),%eax
f0121c5a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121c5d:	76 1f                	jbe    f0121c7e <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f0121c5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121c62:	8b 00                	mov    (%eax),%eax
f0121c64:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f0121c67:	83 ec 04             	sub    $0x4,%esp
f0121c6a:	ff 75 08             	pushl  0x8(%ebp)
f0121c6d:	ff 75 f0             	pushl  -0x10(%ebp)
f0121c70:	ff 75 f4             	pushl  -0xc(%ebp)
f0121c73:	e8 53 fb ff ff       	call   f01217cb <merging>
f0121c78:	83 c4 10             	add    $0x10,%esp
			break;
f0121c7b:	90                   	nop
		}
	}
}
f0121c7c:	eb 2e                	jmp    f0121cac <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121c7e:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0121c83:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121c86:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121c8a:	74 07                	je     f0121c93 <free_block+0xa5>
f0121c8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121c8f:	8b 00                	mov    (%eax),%eax
f0121c91:	eb 05                	jmp    f0121c98 <free_block+0xaa>
f0121c93:	b8 00 00 00 00       	mov    $0x0,%eax
f0121c98:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f0121c9d:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0121ca2:	85 c0                	test   %eax,%eax
f0121ca4:	75 a7                	jne    f0121c4d <free_block+0x5f>
f0121ca6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121caa:	75 a1                	jne    f0121c4d <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121cac:	90                   	nop
f0121cad:	c9                   	leave  
f0121cae:	c3                   	ret    

f0121caf <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f0121caf:	55                   	push   %ebp
f0121cb0:	89 e5                	mov    %esp,%ebp
f0121cb2:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f0121cb5:	ff 75 08             	pushl  0x8(%ebp)
f0121cb8:	e8 10 ed ff ff       	call   f01209cd <get_block_size>
f0121cbd:	83 c4 04             	add    $0x4,%esp
f0121cc0:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f0121cc3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121cca:	eb 17                	jmp    f0121ce3 <copy_data+0x34>
f0121ccc:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0121ccf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121cd2:	01 c2                	add    %eax,%edx
f0121cd4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0121cd7:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cda:	01 c8                	add    %ecx,%eax
f0121cdc:	8a 00                	mov    (%eax),%al
f0121cde:	88 02                	mov    %al,(%edx)
f0121ce0:	ff 45 fc             	incl   -0x4(%ebp)
f0121ce3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0121ce6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0121ce9:	72 e1                	jb     f0121ccc <copy_data+0x1d>
}
f0121ceb:	90                   	nop
f0121cec:	c9                   	leave  
f0121ced:	c3                   	ret    

f0121cee <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0121cee:	55                   	push   %ebp
f0121cef:	89 e5                	mov    %esp,%ebp
f0121cf1:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f0121cf4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121cf8:	75 23                	jne    f0121d1d <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0121cfa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121cfe:	74 13                	je     f0121d13 <realloc_block_FF+0x25>
f0121d00:	83 ec 0c             	sub    $0xc,%esp
f0121d03:	ff 75 0c             	pushl  0xc(%ebp)
f0121d06:	e8 42 f0 ff ff       	call   f0120d4d <alloc_block_FF>
f0121d0b:	83 c4 10             	add    $0x10,%esp
f0121d0e:	e9 e4 06 00 00       	jmp    f01223f7 <realloc_block_FF+0x709>
		return NULL;
f0121d13:	b8 00 00 00 00       	mov    $0x0,%eax
f0121d18:	e9 da 06 00 00       	jmp    f01223f7 <realloc_block_FF+0x709>
	}

	if(new_size == 0)
f0121d1d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121d21:	75 18                	jne    f0121d3b <realloc_block_FF+0x4d>
	{
		free_block(va);
f0121d23:	83 ec 0c             	sub    $0xc,%esp
f0121d26:	ff 75 08             	pushl  0x8(%ebp)
f0121d29:	e8 c0 fe ff ff       	call   f0121bee <free_block>
f0121d2e:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0121d31:	b8 00 00 00 00       	mov    $0x0,%eax
f0121d36:	e9 bc 06 00 00       	jmp    f01223f7 <realloc_block_FF+0x709>
	}


	if(new_size < 8) new_size = 8;
f0121d3b:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f0121d3f:	77 07                	ja     f0121d48 <realloc_block_FF+0x5a>
f0121d41:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f0121d48:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121d4b:	83 e0 01             	and    $0x1,%eax
f0121d4e:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f0121d51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121d54:	83 c0 08             	add    $0x8,%eax
f0121d57:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f0121d5a:	83 ec 0c             	sub    $0xc,%esp
f0121d5d:	ff 75 08             	pushl  0x8(%ebp)
f0121d60:	e8 68 ec ff ff       	call   f01209cd <get_block_size>
f0121d65:	83 c4 10             	add    $0x10,%esp
f0121d68:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121d6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121d6e:	83 e8 08             	sub    $0x8,%eax
f0121d71:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f0121d74:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d77:	83 e8 04             	sub    $0x4,%eax
f0121d7a:	8b 00                	mov    (%eax),%eax
f0121d7c:	83 e0 fe             	and    $0xfffffffe,%eax
f0121d7f:	89 c2                	mov    %eax,%edx
f0121d81:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d84:	01 d0                	add    %edx,%eax
f0121d86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0121d89:	83 ec 0c             	sub    $0xc,%esp
f0121d8c:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121d8f:	e8 39 ec ff ff       	call   f01209cd <get_block_size>
f0121d94:	83 c4 10             	add    $0x10,%esp
f0121d97:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121d9a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121d9d:	83 e8 08             	sub    $0x8,%eax
f0121da0:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f0121da3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121da6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121da9:	75 08                	jne    f0121db3 <realloc_block_FF+0xc5>
	{
		 return va;
f0121dab:	8b 45 08             	mov    0x8(%ebp),%eax
f0121dae:	e9 44 06 00 00       	jmp    f01223f7 <realloc_block_FF+0x709>

	}


	if(new_size < cur_size)
f0121db3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121db6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121db9:	0f 83 d5 03 00 00    	jae    f0122194 <realloc_block_FF+0x4a6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121dbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121dc2:	2b 45 0c             	sub    0xc(%ebp),%eax
f0121dc5:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0121dc8:	83 ec 0c             	sub    $0xc,%esp
f0121dcb:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121dce:	e8 13 ec ff ff       	call   f01209e6 <is_free_block>
f0121dd3:	83 c4 10             	add    $0x10,%esp
f0121dd6:	84 c0                	test   %al,%al
f0121dd8:	0f 84 3b 01 00 00    	je     f0121f19 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0121dde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121de1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121de4:	01 d0                	add    %edx,%eax
f0121de6:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0121de9:	83 ec 04             	sub    $0x4,%esp
f0121dec:	6a 01                	push   $0x1
f0121dee:	ff 75 f0             	pushl  -0x10(%ebp)
f0121df1:	ff 75 08             	pushl  0x8(%ebp)
f0121df4:	e8 25 ef ff ff       	call   f0120d1e <set_block_data>
f0121df9:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0121dfc:	8b 45 08             	mov    0x8(%ebp),%eax
f0121dff:	83 e8 04             	sub    $0x4,%eax
f0121e02:	8b 00                	mov    (%eax),%eax
f0121e04:	83 e0 fe             	and    $0xfffffffe,%eax
f0121e07:	89 c2                	mov    %eax,%edx
f0121e09:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e0c:	01 d0                	add    %edx,%eax
f0121e0e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f0121e11:	83 ec 04             	sub    $0x4,%esp
f0121e14:	6a 00                	push   $0x0
f0121e16:	ff 75 cc             	pushl  -0x34(%ebp)
f0121e19:	ff 75 c8             	pushl  -0x38(%ebp)
f0121e1c:	e8 fd ee ff ff       	call   f0120d1e <set_block_data>
f0121e21:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0121e24:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121e28:	74 06                	je     f0121e30 <realloc_block_FF+0x142>
f0121e2a:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0121e2e:	75 17                	jne    f0121e47 <realloc_block_FF+0x159>
f0121e30:	83 ec 04             	sub    $0x4,%esp
f0121e33:	68 88 1b 13 f0       	push   $0xf0131b88
f0121e38:	68 f6 01 00 00       	push   $0x1f6
f0121e3d:	68 15 1b 13 f0       	push   $0xf0131b15
f0121e42:	e8 f2 e4 fd ff       	call   f0100339 <_panic>
f0121e47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e4a:	8b 10                	mov    (%eax),%edx
f0121e4c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121e4f:	89 10                	mov    %edx,(%eax)
f0121e51:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121e54:	8b 00                	mov    (%eax),%eax
f0121e56:	85 c0                	test   %eax,%eax
f0121e58:	74 0b                	je     f0121e65 <realloc_block_FF+0x177>
f0121e5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e5d:	8b 00                	mov    (%eax),%eax
f0121e5f:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121e62:	89 50 04             	mov    %edx,0x4(%eax)
f0121e65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121e68:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121e6b:	89 10                	mov    %edx,(%eax)
f0121e6d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121e70:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121e73:	89 50 04             	mov    %edx,0x4(%eax)
f0121e76:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121e79:	8b 00                	mov    (%eax),%eax
f0121e7b:	85 c0                	test   %eax,%eax
f0121e7d:	75 08                	jne    f0121e87 <realloc_block_FF+0x199>
f0121e7f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121e82:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121e87:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121e8c:	40                   	inc    %eax
f0121e8d:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121e92:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121e96:	75 17                	jne    f0121eaf <realloc_block_FF+0x1c1>
f0121e98:	83 ec 04             	sub    $0x4,%esp
f0121e9b:	68 f7 1a 13 f0       	push   $0xf0131af7
f0121ea0:	68 f7 01 00 00       	push   $0x1f7
f0121ea5:	68 15 1b 13 f0       	push   $0xf0131b15
f0121eaa:	e8 8a e4 fd ff       	call   f0100339 <_panic>
f0121eaf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121eb2:	8b 00                	mov    (%eax),%eax
f0121eb4:	85 c0                	test   %eax,%eax
f0121eb6:	74 10                	je     f0121ec8 <realloc_block_FF+0x1da>
f0121eb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ebb:	8b 00                	mov    (%eax),%eax
f0121ebd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121ec0:	8b 52 04             	mov    0x4(%edx),%edx
f0121ec3:	89 50 04             	mov    %edx,0x4(%eax)
f0121ec6:	eb 0b                	jmp    f0121ed3 <realloc_block_FF+0x1e5>
f0121ec8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ecb:	8b 40 04             	mov    0x4(%eax),%eax
f0121ece:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121ed3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ed6:	8b 40 04             	mov    0x4(%eax),%eax
f0121ed9:	85 c0                	test   %eax,%eax
f0121edb:	74 0f                	je     f0121eec <realloc_block_FF+0x1fe>
f0121edd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ee0:	8b 40 04             	mov    0x4(%eax),%eax
f0121ee3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121ee6:	8b 12                	mov    (%edx),%edx
f0121ee8:	89 10                	mov    %edx,(%eax)
f0121eea:	eb 0a                	jmp    f0121ef6 <realloc_block_FF+0x208>
f0121eec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121eef:	8b 00                	mov    (%eax),%eax
f0121ef1:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121ef6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ef9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121eff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f02:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121f09:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121f0e:	48                   	dec    %eax
f0121f0f:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121f14:	e9 73 02 00 00       	jmp    f012218c <realloc_block_FF+0x49e>
		}
		else
		{
			if(remaining_size>=16)
f0121f19:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f0121f1d:	0f 86 69 02 00 00    	jbe    f012218c <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f0121f23:	83 ec 04             	sub    $0x4,%esp
f0121f26:	6a 01                	push   $0x1
f0121f28:	ff 75 f0             	pushl  -0x10(%ebp)
f0121f2b:	ff 75 08             	pushl  0x8(%ebp)
f0121f2e:	e8 eb ed ff ff       	call   f0120d1e <set_block_data>
f0121f33:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121f36:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f39:	83 e8 04             	sub    $0x4,%eax
f0121f3c:	8b 00                	mov    (%eax),%eax
f0121f3e:	83 e0 fe             	and    $0xfffffffe,%eax
f0121f41:	89 c2                	mov    %eax,%edx
f0121f43:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f46:	01 d0                	add    %edx,%eax
f0121f48:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f0121f4b:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121f50:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f0121f53:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121f57:	75 68                	jne    f0121fc1 <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121f59:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121f5d:	75 17                	jne    f0121f76 <realloc_block_FF+0x288>
f0121f5f:	83 ec 04             	sub    $0x4,%esp
f0121f62:	68 30 1b 13 f0       	push   $0xf0131b30
f0121f67:	68 06 02 00 00       	push   $0x206
f0121f6c:	68 15 1b 13 f0       	push   $0xf0131b15
f0121f71:	e8 c3 e3 fd ff       	call   f0100339 <_panic>
f0121f76:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0121f7c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121f7f:	89 10                	mov    %edx,(%eax)
f0121f81:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121f84:	8b 00                	mov    (%eax),%eax
f0121f86:	85 c0                	test   %eax,%eax
f0121f88:	74 0d                	je     f0121f97 <realloc_block_FF+0x2a9>
f0121f8a:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121f8f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121f92:	89 50 04             	mov    %edx,0x4(%eax)
f0121f95:	eb 08                	jmp    f0121f9f <realloc_block_FF+0x2b1>
f0121f97:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121f9a:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0121f9f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121fa2:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0121fa7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121faa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121fb1:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0121fb6:	40                   	inc    %eax
f0121fb7:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f0121fbc:	e9 b0 01 00 00       	jmp    f0122171 <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f0121fc1:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0121fc6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121fc9:	76 68                	jbe    f0122033 <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121fcb:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121fcf:	75 17                	jne    f0121fe8 <realloc_block_FF+0x2fa>
f0121fd1:	83 ec 04             	sub    $0x4,%esp
f0121fd4:	68 30 1b 13 f0       	push   $0xf0131b30
f0121fd9:	68 0b 02 00 00       	push   $0x20b
f0121fde:	68 15 1b 13 f0       	push   $0xf0131b15
f0121fe3:	e8 51 e3 fd ff       	call   f0100339 <_panic>
f0121fe8:	8b 15 b0 f1 b1 f0    	mov    0xf0b1f1b0,%edx
f0121fee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ff1:	89 10                	mov    %edx,(%eax)
f0121ff3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ff6:	8b 00                	mov    (%eax),%eax
f0121ff8:	85 c0                	test   %eax,%eax
f0121ffa:	74 0d                	je     f0122009 <realloc_block_FF+0x31b>
f0121ffc:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0122001:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0122004:	89 50 04             	mov    %edx,0x4(%eax)
f0122007:	eb 08                	jmp    f0122011 <realloc_block_FF+0x323>
f0122009:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012200c:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0122011:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122014:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0122019:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012201c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122023:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0122028:	40                   	inc    %eax
f0122029:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f012202e:	e9 3e 01 00 00       	jmp    f0122171 <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f0122033:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f0122038:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f012203b:	73 68                	jae    f01220a5 <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f012203d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0122041:	75 17                	jne    f012205a <realloc_block_FF+0x36c>
f0122043:	83 ec 04             	sub    $0x4,%esp
f0122046:	68 64 1b 13 f0       	push   $0xf0131b64
f012204b:	68 10 02 00 00       	push   $0x210
f0122050:	68 15 1b 13 f0       	push   $0xf0131b15
f0122055:	e8 df e2 fd ff       	call   f0100339 <_panic>
f012205a:	8b 15 b4 f1 b1 f0    	mov    0xf0b1f1b4,%edx
f0122060:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122063:	89 50 04             	mov    %edx,0x4(%eax)
f0122066:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122069:	8b 40 04             	mov    0x4(%eax),%eax
f012206c:	85 c0                	test   %eax,%eax
f012206e:	74 0c                	je     f012207c <realloc_block_FF+0x38e>
f0122070:	a1 b4 f1 b1 f0       	mov    0xf0b1f1b4,%eax
f0122075:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0122078:	89 10                	mov    %edx,(%eax)
f012207a:	eb 08                	jmp    f0122084 <realloc_block_FF+0x396>
f012207c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012207f:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0122084:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122087:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f012208c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012208f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0122095:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f012209a:	40                   	inc    %eax
f012209b:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
f01220a0:	e9 cc 00 00 00       	jmp    f0122171 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f01220a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f01220ac:	a1 b0 f1 b1 f0       	mov    0xf0b1f1b0,%eax
f01220b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01220b4:	e9 8a 00 00 00       	jmp    f0122143 <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f01220b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01220bc:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01220bf:	73 7a                	jae    f012213b <realloc_block_FF+0x44d>
f01220c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01220c4:	8b 00                	mov    (%eax),%eax
f01220c6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01220c9:	73 70                	jae    f012213b <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f01220cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01220cf:	74 06                	je     f01220d7 <realloc_block_FF+0x3e9>
f01220d1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01220d5:	75 17                	jne    f01220ee <realloc_block_FF+0x400>
f01220d7:	83 ec 04             	sub    $0x4,%esp
f01220da:	68 88 1b 13 f0       	push   $0xf0131b88
f01220df:	68 1a 02 00 00       	push   $0x21a
f01220e4:	68 15 1b 13 f0       	push   $0xf0131b15
f01220e9:	e8 4b e2 fd ff       	call   f0100339 <_panic>
f01220ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01220f1:	8b 10                	mov    (%eax),%edx
f01220f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01220f6:	89 10                	mov    %edx,(%eax)
f01220f8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01220fb:	8b 00                	mov    (%eax),%eax
f01220fd:	85 c0                	test   %eax,%eax
f01220ff:	74 0b                	je     f012210c <realloc_block_FF+0x41e>
f0122101:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122104:	8b 00                	mov    (%eax),%eax
f0122106:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0122109:	89 50 04             	mov    %edx,0x4(%eax)
f012210c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012210f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0122112:	89 10                	mov    %edx,(%eax)
f0122114:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122117:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012211a:	89 50 04             	mov    %edx,0x4(%eax)
f012211d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122120:	8b 00                	mov    (%eax),%eax
f0122122:	85 c0                	test   %eax,%eax
f0122124:	75 08                	jne    f012212e <realloc_block_FF+0x440>
f0122126:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122129:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f012212e:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f0122133:	40                   	inc    %eax
f0122134:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
							break;
f0122139:	eb 36                	jmp    f0122171 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f012213b:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f0122140:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122143:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122147:	74 07                	je     f0122150 <realloc_block_FF+0x462>
f0122149:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012214c:	8b 00                	mov    (%eax),%eax
f012214e:	eb 05                	jmp    f0122155 <realloc_block_FF+0x467>
f0122150:	b8 00 00 00 00       	mov    $0x0,%eax
f0122155:	a3 b8 f1 b1 f0       	mov    %eax,0xf0b1f1b8
f012215a:	a1 b8 f1 b1 f0       	mov    0xf0b1f1b8,%eax
f012215f:	85 c0                	test   %eax,%eax
f0122161:	0f 85 52 ff ff ff    	jne    f01220b9 <realloc_block_FF+0x3cb>
f0122167:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012216b:	0f 85 48 ff ff ff    	jne    f01220b9 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f0122171:	83 ec 04             	sub    $0x4,%esp
f0122174:	6a 00                	push   $0x0
f0122176:	ff 75 d8             	pushl  -0x28(%ebp)
f0122179:	ff 75 d4             	pushl  -0x2c(%ebp)
f012217c:	e8 9d eb ff ff       	call   f0120d1e <set_block_data>
f0122181:	83 c4 10             	add    $0x10,%esp
				return va;
f0122184:	8b 45 08             	mov    0x8(%ebp),%eax
f0122187:	e9 6b 02 00 00       	jmp    f01223f7 <realloc_block_FF+0x709>
			}
			
		}
		return va;
f012218c:	8b 45 08             	mov    0x8(%ebp),%eax
f012218f:	e9 63 02 00 00       	jmp    f01223f7 <realloc_block_FF+0x709>
	}

	if(new_size > cur_size)
f0122194:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122197:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f012219a:	0f 86 4d 02 00 00    	jbe    f01223ed <realloc_block_FF+0x6ff>
	{
		if(is_free_block(next_va))
f01221a0:	83 ec 0c             	sub    $0xc,%esp
f01221a3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01221a6:	e8 3b e8 ff ff       	call   f01209e6 <is_free_block>
f01221ab:	83 c4 10             	add    $0x10,%esp
f01221ae:	84 c0                	test   %al,%al
f01221b0:	0f 84 37 02 00 00    	je     f01223ed <realloc_block_FF+0x6ff>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f01221b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01221b9:	2b 45 e8             	sub    -0x18(%ebp),%eax
f01221bc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f01221bf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01221c2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01221c5:	76 38                	jbe    f01221ff <realloc_block_FF+0x511>
			{
				void *new_va = alloc_block_FF(new_size); //new allocation
f01221c7:	83 ec 0c             	sub    $0xc,%esp
f01221ca:	ff 75 0c             	pushl  0xc(%ebp)
f01221cd:	e8 7b eb ff ff       	call   f0120d4d <alloc_block_FF>
f01221d2:	83 c4 10             	add    $0x10,%esp
f01221d5:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f01221d8:	83 ec 08             	sub    $0x8,%esp
f01221db:	ff 75 c0             	pushl  -0x40(%ebp)
f01221de:	ff 75 08             	pushl  0x8(%ebp)
f01221e1:	e8 c9 fa ff ff       	call   f0121caf <copy_data>
f01221e6:	83 c4 10             	add    $0x10,%esp
				free_block(va); //set it free
f01221e9:	83 ec 0c             	sub    $0xc,%esp
f01221ec:	ff 75 08             	pushl  0x8(%ebp)
f01221ef:	e8 fa f9 ff ff       	call   f0121bee <free_block>
f01221f4:	83 c4 10             	add    $0x10,%esp
				return new_va;
f01221f7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01221fa:	e9 f8 01 00 00       	jmp    f01223f7 <realloc_block_FF+0x709>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f01221ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0122202:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f0122205:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f0122208:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f012220c:	0f 87 a0 00 00 00    	ja     f01222b2 <realloc_block_FF+0x5c4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f0122212:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122216:	75 17                	jne    f012222f <realloc_block_FF+0x541>
f0122218:	83 ec 04             	sub    $0x4,%esp
f012221b:	68 f7 1a 13 f0       	push   $0xf0131af7
f0122220:	68 38 02 00 00       	push   $0x238
f0122225:	68 15 1b 13 f0       	push   $0xf0131b15
f012222a:	e8 0a e1 fd ff       	call   f0100339 <_panic>
f012222f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122232:	8b 00                	mov    (%eax),%eax
f0122234:	85 c0                	test   %eax,%eax
f0122236:	74 10                	je     f0122248 <realloc_block_FF+0x55a>
f0122238:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012223b:	8b 00                	mov    (%eax),%eax
f012223d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122240:	8b 52 04             	mov    0x4(%edx),%edx
f0122243:	89 50 04             	mov    %edx,0x4(%eax)
f0122246:	eb 0b                	jmp    f0122253 <realloc_block_FF+0x565>
f0122248:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012224b:	8b 40 04             	mov    0x4(%eax),%eax
f012224e:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0122253:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122256:	8b 40 04             	mov    0x4(%eax),%eax
f0122259:	85 c0                	test   %eax,%eax
f012225b:	74 0f                	je     f012226c <realloc_block_FF+0x57e>
f012225d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122260:	8b 40 04             	mov    0x4(%eax),%eax
f0122263:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122266:	8b 12                	mov    (%edx),%edx
f0122268:	89 10                	mov    %edx,(%eax)
f012226a:	eb 0a                	jmp    f0122276 <realloc_block_FF+0x588>
f012226c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012226f:	8b 00                	mov    (%eax),%eax
f0122271:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f0122276:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122279:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012227f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122282:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122289:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f012228e:	48                   	dec    %eax
f012228f:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f0122294:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122297:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012229a:	01 d0                	add    %edx,%eax
f012229c:	83 ec 04             	sub    $0x4,%esp
f012229f:	6a 01                	push   $0x1
f01222a1:	50                   	push   %eax
f01222a2:	ff 75 08             	pushl  0x8(%ebp)
f01222a5:	e8 74 ea ff ff       	call   f0120d1e <set_block_data>
f01222aa:	83 c4 10             	add    $0x10,%esp
f01222ad:	e9 36 01 00 00       	jmp    f01223e8 <realloc_block_FF+0x6fa>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f01222b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01222b5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01222b8:	01 d0                	add    %edx,%eax
f01222ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f01222bd:	83 ec 04             	sub    $0x4,%esp
f01222c0:	6a 01                	push   $0x1
f01222c2:	ff 75 f0             	pushl  -0x10(%ebp)
f01222c5:	ff 75 08             	pushl  0x8(%ebp)
f01222c8:	e8 51 ea ff ff       	call   f0120d1e <set_block_data>
f01222cd:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f01222d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01222d3:	83 e8 04             	sub    $0x4,%eax
f01222d6:	8b 00                	mov    (%eax),%eax
f01222d8:	83 e0 fe             	and    $0xfffffffe,%eax
f01222db:	89 c2                	mov    %eax,%edx
f01222dd:	8b 45 08             	mov    0x8(%ebp),%eax
f01222e0:	01 d0                	add    %edx,%eax
f01222e2:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f01222e5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01222e9:	74 06                	je     f01222f1 <realloc_block_FF+0x603>
f01222eb:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f01222ef:	75 17                	jne    f0122308 <realloc_block_FF+0x61a>
f01222f1:	83 ec 04             	sub    $0x4,%esp
f01222f4:	68 88 1b 13 f0       	push   $0xf0131b88
f01222f9:	68 44 02 00 00       	push   $0x244
f01222fe:	68 15 1b 13 f0       	push   $0xf0131b15
f0122303:	e8 31 e0 fd ff       	call   f0100339 <_panic>
f0122308:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012230b:	8b 10                	mov    (%eax),%edx
f012230d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122310:	89 10                	mov    %edx,(%eax)
f0122312:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122315:	8b 00                	mov    (%eax),%eax
f0122317:	85 c0                	test   %eax,%eax
f0122319:	74 0b                	je     f0122326 <realloc_block_FF+0x638>
f012231b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012231e:	8b 00                	mov    (%eax),%eax
f0122320:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0122323:	89 50 04             	mov    %edx,0x4(%eax)
f0122326:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122329:	8b 55 b8             	mov    -0x48(%ebp),%edx
f012232c:	89 10                	mov    %edx,(%eax)
f012232e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122331:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122334:	89 50 04             	mov    %edx,0x4(%eax)
f0122337:	8b 45 b8             	mov    -0x48(%ebp),%eax
f012233a:	8b 00                	mov    (%eax),%eax
f012233c:	85 c0                	test   %eax,%eax
f012233e:	75 08                	jne    f0122348 <realloc_block_FF+0x65a>
f0122340:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0122343:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0122348:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f012234d:	40                   	inc    %eax
f012234e:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0122353:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122357:	75 17                	jne    f0122370 <realloc_block_FF+0x682>
f0122359:	83 ec 04             	sub    $0x4,%esp
f012235c:	68 f7 1a 13 f0       	push   $0xf0131af7
f0122361:	68 45 02 00 00       	push   $0x245
f0122366:	68 15 1b 13 f0       	push   $0xf0131b15
f012236b:	e8 c9 df fd ff       	call   f0100339 <_panic>
f0122370:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122373:	8b 00                	mov    (%eax),%eax
f0122375:	85 c0                	test   %eax,%eax
f0122377:	74 10                	je     f0122389 <realloc_block_FF+0x69b>
f0122379:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012237c:	8b 00                	mov    (%eax),%eax
f012237e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122381:	8b 52 04             	mov    0x4(%edx),%edx
f0122384:	89 50 04             	mov    %edx,0x4(%eax)
f0122387:	eb 0b                	jmp    f0122394 <realloc_block_FF+0x6a6>
f0122389:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012238c:	8b 40 04             	mov    0x4(%eax),%eax
f012238f:	a3 b4 f1 b1 f0       	mov    %eax,0xf0b1f1b4
f0122394:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122397:	8b 40 04             	mov    0x4(%eax),%eax
f012239a:	85 c0                	test   %eax,%eax
f012239c:	74 0f                	je     f01223ad <realloc_block_FF+0x6bf>
f012239e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01223a1:	8b 40 04             	mov    0x4(%eax),%eax
f01223a4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01223a7:	8b 12                	mov    (%edx),%edx
f01223a9:	89 10                	mov    %edx,(%eax)
f01223ab:	eb 0a                	jmp    f01223b7 <realloc_block_FF+0x6c9>
f01223ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01223b0:	8b 00                	mov    (%eax),%eax
f01223b2:	a3 b0 f1 b1 f0       	mov    %eax,0xf0b1f1b0
f01223b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01223ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01223c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01223c3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01223ca:	a1 bc f1 b1 f0       	mov    0xf0b1f1bc,%eax
f01223cf:	48                   	dec    %eax
f01223d0:	a3 bc f1 b1 f0       	mov    %eax,0xf0b1f1bc
				set_block_data(next_new_va, remaining_size, 0);
f01223d5:	83 ec 04             	sub    $0x4,%esp
f01223d8:	6a 00                	push   $0x0
f01223da:	ff 75 bc             	pushl  -0x44(%ebp)
f01223dd:	ff 75 b8             	pushl  -0x48(%ebp)
f01223e0:	e8 39 e9 ff ff       	call   f0120d1e <set_block_data>
f01223e5:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f01223e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01223eb:	eb 0a                	jmp    f01223f7 <realloc_block_FF+0x709>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f01223ed:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f01223f4:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01223f7:	c9                   	leave  
f01223f8:	c3                   	ret    

f01223f9 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f01223f9:	55                   	push   %ebp
f01223fa:	89 e5                	mov    %esp,%ebp
f01223fc:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f01223ff:	83 ec 04             	sub    $0x4,%esp
f0122402:	68 f4 1b 13 f0       	push   $0xf0131bf4
f0122407:	68 58 02 00 00       	push   $0x258
f012240c:	68 15 1b 13 f0       	push   $0xf0131b15
f0122411:	e8 23 df fd ff       	call   f0100339 <_panic>

f0122416 <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0122416:	55                   	push   %ebp
f0122417:	89 e5                	mov    %esp,%ebp
f0122419:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f012241c:	83 ec 04             	sub    $0x4,%esp
f012241f:	68 1c 1c 13 f0       	push   $0xf0131c1c
f0122424:	68 61 02 00 00       	push   $0x261
f0122429:	68 15 1b 13 f0       	push   $0xf0131b15
f012242e:	e8 06 df fd ff       	call   f0100339 <_panic>
f0122433:	90                   	nop

f0122434 <__moddi3>:
f0122434:	55                   	push   %ebp
f0122435:	57                   	push   %edi
f0122436:	56                   	push   %esi
f0122437:	53                   	push   %ebx
f0122438:	83 ec 2c             	sub    $0x2c,%esp
f012243b:	8b 74 24 40          	mov    0x40(%esp),%esi
f012243f:	8b 7c 24 44          	mov    0x44(%esp),%edi
f0122443:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0122447:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f012244b:	89 d8                	mov    %ebx,%eax
f012244d:	85 ff                	test   %edi,%edi
f012244f:	0f 88 d3 00 00 00    	js     f0122528 <__moddi3+0xf4>
f0122455:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f012245c:	00 
f012245d:	85 c0                	test   %eax,%eax
f012245f:	0f 88 ab 00 00 00    	js     f0122510 <__moddi3+0xdc>
f0122465:	89 0c 24             	mov    %ecx,(%esp)
f0122468:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f012246c:	89 74 24 10          	mov    %esi,0x10(%esp)
f0122470:	89 fb                	mov    %edi,%ebx
f0122472:	8b 14 24             	mov    (%esp),%edx
f0122475:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0122479:	89 d0                	mov    %edx,%eax
f012247b:	89 54 24 18          	mov    %edx,0x18(%esp)
f012247f:	89 ca                	mov    %ecx,%edx
f0122481:	8b 0c 24             	mov    (%esp),%ecx
f0122484:	89 34 24             	mov    %esi,(%esp)
f0122487:	89 7c 24 14          	mov    %edi,0x14(%esp)
f012248b:	85 d2                	test   %edx,%edx
f012248d:	75 15                	jne    f01224a4 <__moddi3+0x70>
f012248f:	89 c7                	mov    %eax,%edi
f0122491:	39 d8                	cmp    %ebx,%eax
f0122493:	76 5b                	jbe    f01224f0 <__moddi3+0xbc>
f0122495:	89 f0                	mov    %esi,%eax
f0122497:	89 da                	mov    %ebx,%edx
f0122499:	f7 f7                	div    %edi
f012249b:	89 d3                	mov    %edx,%ebx
f012249d:	89 d8                	mov    %ebx,%eax
f012249f:	31 d2                	xor    %edx,%edx
f01224a1:	eb 09                	jmp    f01224ac <__moddi3+0x78>
f01224a3:	90                   	nop
f01224a4:	39 fa                	cmp    %edi,%edx
f01224a6:	76 1c                	jbe    f01224c4 <__moddi3+0x90>
f01224a8:	89 f0                	mov    %esi,%eax
f01224aa:	89 fa                	mov    %edi,%edx
f01224ac:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f01224b0:	85 c9                	test   %ecx,%ecx
f01224b2:	74 07                	je     f01224bb <__moddi3+0x87>
f01224b4:	f7 d8                	neg    %eax
f01224b6:	83 d2 00             	adc    $0x0,%edx
f01224b9:	f7 da                	neg    %edx
f01224bb:	83 c4 2c             	add    $0x2c,%esp
f01224be:	5b                   	pop    %ebx
f01224bf:	5e                   	pop    %esi
f01224c0:	5f                   	pop    %edi
f01224c1:	5d                   	pop    %ebp
f01224c2:	c3                   	ret    
f01224c3:	90                   	nop
f01224c4:	0f bd c2             	bsr    %edx,%eax
f01224c7:	83 f0 1f             	xor    $0x1f,%eax
f01224ca:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f01224ce:	75 6c                	jne    f012253c <__moddi3+0x108>
f01224d0:	39 fa                	cmp    %edi,%edx
f01224d2:	72 05                	jb     f01224d9 <__moddi3+0xa5>
f01224d4:	3b 0c 24             	cmp    (%esp),%ecx
f01224d7:	77 0e                	ja     f01224e7 <__moddi3+0xb3>
f01224d9:	8b 34 24             	mov    (%esp),%esi
f01224dc:	29 ce                	sub    %ecx,%esi
f01224de:	19 d3                	sbb    %edx,%ebx
f01224e0:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f01224e4:	89 34 24             	mov    %esi,(%esp)
f01224e7:	8b 04 24             	mov    (%esp),%eax
f01224ea:	8b 54 24 14          	mov    0x14(%esp),%edx
f01224ee:	eb bc                	jmp    f01224ac <__moddi3+0x78>
f01224f0:	85 c9                	test   %ecx,%ecx
f01224f2:	75 0b                	jne    f01224ff <__moddi3+0xcb>
f01224f4:	b8 01 00 00 00       	mov    $0x1,%eax
f01224f9:	31 d2                	xor    %edx,%edx
f01224fb:	f7 f1                	div    %ecx
f01224fd:	89 c1                	mov    %eax,%ecx
f01224ff:	89 d8                	mov    %ebx,%eax
f0122501:	31 d2                	xor    %edx,%edx
f0122503:	f7 f1                	div    %ecx
f0122505:	8b 04 24             	mov    (%esp),%eax
f0122508:	f7 f1                	div    %ecx
f012250a:	89 d3                	mov    %edx,%ebx
f012250c:	eb 8f                	jmp    f012249d <__moddi3+0x69>
f012250e:	66 90                	xchg   %ax,%ax
f0122510:	89 c8                	mov    %ecx,%eax
f0122512:	89 da                	mov    %ebx,%edx
f0122514:	f7 d8                	neg    %eax
f0122516:	83 d2 00             	adc    $0x0,%edx
f0122519:	f7 da                	neg    %edx
f012251b:	89 04 24             	mov    %eax,(%esp)
f012251e:	89 54 24 04          	mov    %edx,0x4(%esp)
f0122522:	e9 45 ff ff ff       	jmp    f012246c <__moddi3+0x38>
f0122527:	90                   	nop
f0122528:	f7 de                	neg    %esi
f012252a:	83 d7 00             	adc    $0x0,%edi
f012252d:	f7 df                	neg    %edi
f012252f:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0122536:	ff 
f0122537:	e9 21 ff ff ff       	jmp    f012245d <__moddi3+0x29>
f012253c:	b8 20 00 00 00       	mov    $0x20,%eax
f0122541:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0122545:	29 f8                	sub    %edi,%eax
f0122547:	89 c6                	mov    %eax,%esi
f0122549:	89 44 24 14          	mov    %eax,0x14(%esp)
f012254d:	89 f9                	mov    %edi,%ecx
f012254f:	d3 e2                	shl    %cl,%edx
f0122551:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0122555:	89 e8                	mov    %ebp,%eax
f0122557:	89 f1                	mov    %esi,%ecx
f0122559:	d3 e8                	shr    %cl,%eax
f012255b:	09 d0                	or     %edx,%eax
f012255d:	89 04 24             	mov    %eax,(%esp)
f0122560:	89 ea                	mov    %ebp,%edx
f0122562:	89 f9                	mov    %edi,%ecx
f0122564:	d3 e2                	shl    %cl,%edx
f0122566:	89 d7                	mov    %edx,%edi
f0122568:	89 da                	mov    %ebx,%edx
f012256a:	d3 e2                	shl    %cl,%edx
f012256c:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0122570:	d3 e5                	shl    %cl,%ebp
f0122572:	8b 44 24 10          	mov    0x10(%esp),%eax
f0122576:	89 f1                	mov    %esi,%ecx
f0122578:	d3 e8                	shr    %cl,%eax
f012257a:	09 d0                	or     %edx,%eax
f012257c:	d3 eb                	shr    %cl,%ebx
f012257e:	89 da                	mov    %ebx,%edx
f0122580:	f7 34 24             	divl   (%esp)
f0122583:	89 d3                	mov    %edx,%ebx
f0122585:	f7 e7                	mul    %edi
f0122587:	89 c6                	mov    %eax,%esi
f0122589:	89 d1                	mov    %edx,%ecx
f012258b:	39 d3                	cmp    %edx,%ebx
f012258d:	72 29                	jb     f01225b8 <__moddi3+0x184>
f012258f:	74 33                	je     f01225c4 <__moddi3+0x190>
f0122591:	89 e8                	mov    %ebp,%eax
f0122593:	29 f0                	sub    %esi,%eax
f0122595:	19 cb                	sbb    %ecx,%ebx
f0122597:	89 de                	mov    %ebx,%esi
f0122599:	8a 4c 24 14          	mov    0x14(%esp),%cl
f012259d:	d3 e6                	shl    %cl,%esi
f012259f:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01225a3:	89 f9                	mov    %edi,%ecx
f01225a5:	d3 e8                	shr    %cl,%eax
f01225a7:	09 c6                	or     %eax,%esi
f01225a9:	89 f0                	mov    %esi,%eax
f01225ab:	89 f9                	mov    %edi,%ecx
f01225ad:	d3 eb                	shr    %cl,%ebx
f01225af:	89 da                	mov    %ebx,%edx
f01225b1:	e9 f6 fe ff ff       	jmp    f01224ac <__moddi3+0x78>
f01225b6:	66 90                	xchg   %ax,%ax
f01225b8:	29 f8                	sub    %edi,%eax
f01225ba:	1b 14 24             	sbb    (%esp),%edx
f01225bd:	89 d1                	mov    %edx,%ecx
f01225bf:	89 c6                	mov    %eax,%esi
f01225c1:	eb ce                	jmp    f0122591 <__moddi3+0x15d>
f01225c3:	90                   	nop
f01225c4:	39 c5                	cmp    %eax,%ebp
f01225c6:	72 f0                	jb     f01225b8 <__moddi3+0x184>
f01225c8:	89 d9                	mov    %ebx,%ecx
f01225ca:	eb c5                	jmp    f0122591 <__moddi3+0x15d>

f01225cc <__udivdi3>:
f01225cc:	55                   	push   %ebp
f01225cd:	57                   	push   %edi
f01225ce:	56                   	push   %esi
f01225cf:	53                   	push   %ebx
f01225d0:	83 ec 1c             	sub    $0x1c,%esp
f01225d3:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f01225d7:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f01225db:	8b 7c 24 38          	mov    0x38(%esp),%edi
f01225df:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f01225e3:	89 ca                	mov    %ecx,%edx
f01225e5:	89 f8                	mov    %edi,%eax
f01225e7:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f01225eb:	85 f6                	test   %esi,%esi
f01225ed:	75 2d                	jne    f012261c <__udivdi3+0x50>
f01225ef:	39 cf                	cmp    %ecx,%edi
f01225f1:	77 65                	ja     f0122658 <__udivdi3+0x8c>
f01225f3:	89 fd                	mov    %edi,%ebp
f01225f5:	85 ff                	test   %edi,%edi
f01225f7:	75 0b                	jne    f0122604 <__udivdi3+0x38>
f01225f9:	b8 01 00 00 00       	mov    $0x1,%eax
f01225fe:	31 d2                	xor    %edx,%edx
f0122600:	f7 f7                	div    %edi
f0122602:	89 c5                	mov    %eax,%ebp
f0122604:	31 d2                	xor    %edx,%edx
f0122606:	89 c8                	mov    %ecx,%eax
f0122608:	f7 f5                	div    %ebp
f012260a:	89 c1                	mov    %eax,%ecx
f012260c:	89 d8                	mov    %ebx,%eax
f012260e:	f7 f5                	div    %ebp
f0122610:	89 cf                	mov    %ecx,%edi
f0122612:	89 fa                	mov    %edi,%edx
f0122614:	83 c4 1c             	add    $0x1c,%esp
f0122617:	5b                   	pop    %ebx
f0122618:	5e                   	pop    %esi
f0122619:	5f                   	pop    %edi
f012261a:	5d                   	pop    %ebp
f012261b:	c3                   	ret    
f012261c:	39 ce                	cmp    %ecx,%esi
f012261e:	77 28                	ja     f0122648 <__udivdi3+0x7c>
f0122620:	0f bd fe             	bsr    %esi,%edi
f0122623:	83 f7 1f             	xor    $0x1f,%edi
f0122626:	75 40                	jne    f0122668 <__udivdi3+0x9c>
f0122628:	39 ce                	cmp    %ecx,%esi
f012262a:	72 0a                	jb     f0122636 <__udivdi3+0x6a>
f012262c:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0122630:	0f 87 9e 00 00 00    	ja     f01226d4 <__udivdi3+0x108>
f0122636:	b8 01 00 00 00       	mov    $0x1,%eax
f012263b:	89 fa                	mov    %edi,%edx
f012263d:	83 c4 1c             	add    $0x1c,%esp
f0122640:	5b                   	pop    %ebx
f0122641:	5e                   	pop    %esi
f0122642:	5f                   	pop    %edi
f0122643:	5d                   	pop    %ebp
f0122644:	c3                   	ret    
f0122645:	8d 76 00             	lea    0x0(%esi),%esi
f0122648:	31 ff                	xor    %edi,%edi
f012264a:	31 c0                	xor    %eax,%eax
f012264c:	89 fa                	mov    %edi,%edx
f012264e:	83 c4 1c             	add    $0x1c,%esp
f0122651:	5b                   	pop    %ebx
f0122652:	5e                   	pop    %esi
f0122653:	5f                   	pop    %edi
f0122654:	5d                   	pop    %ebp
f0122655:	c3                   	ret    
f0122656:	66 90                	xchg   %ax,%ax
f0122658:	89 d8                	mov    %ebx,%eax
f012265a:	f7 f7                	div    %edi
f012265c:	31 ff                	xor    %edi,%edi
f012265e:	89 fa                	mov    %edi,%edx
f0122660:	83 c4 1c             	add    $0x1c,%esp
f0122663:	5b                   	pop    %ebx
f0122664:	5e                   	pop    %esi
f0122665:	5f                   	pop    %edi
f0122666:	5d                   	pop    %ebp
f0122667:	c3                   	ret    
f0122668:	bd 20 00 00 00       	mov    $0x20,%ebp
f012266d:	89 eb                	mov    %ebp,%ebx
f012266f:	29 fb                	sub    %edi,%ebx
f0122671:	89 f9                	mov    %edi,%ecx
f0122673:	d3 e6                	shl    %cl,%esi
f0122675:	89 c5                	mov    %eax,%ebp
f0122677:	88 d9                	mov    %bl,%cl
f0122679:	d3 ed                	shr    %cl,%ebp
f012267b:	89 e9                	mov    %ebp,%ecx
f012267d:	09 f1                	or     %esi,%ecx
f012267f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f0122683:	89 f9                	mov    %edi,%ecx
f0122685:	d3 e0                	shl    %cl,%eax
f0122687:	89 c5                	mov    %eax,%ebp
f0122689:	89 d6                	mov    %edx,%esi
f012268b:	88 d9                	mov    %bl,%cl
f012268d:	d3 ee                	shr    %cl,%esi
f012268f:	89 f9                	mov    %edi,%ecx
f0122691:	d3 e2                	shl    %cl,%edx
f0122693:	8b 44 24 08          	mov    0x8(%esp),%eax
f0122697:	88 d9                	mov    %bl,%cl
f0122699:	d3 e8                	shr    %cl,%eax
f012269b:	09 c2                	or     %eax,%edx
f012269d:	89 d0                	mov    %edx,%eax
f012269f:	89 f2                	mov    %esi,%edx
f01226a1:	f7 74 24 0c          	divl   0xc(%esp)
f01226a5:	89 d6                	mov    %edx,%esi
f01226a7:	89 c3                	mov    %eax,%ebx
f01226a9:	f7 e5                	mul    %ebp
f01226ab:	39 d6                	cmp    %edx,%esi
f01226ad:	72 19                	jb     f01226c8 <__udivdi3+0xfc>
f01226af:	74 0b                	je     f01226bc <__udivdi3+0xf0>
f01226b1:	89 d8                	mov    %ebx,%eax
f01226b3:	31 ff                	xor    %edi,%edi
f01226b5:	e9 58 ff ff ff       	jmp    f0122612 <__udivdi3+0x46>
f01226ba:	66 90                	xchg   %ax,%ax
f01226bc:	8b 54 24 08          	mov    0x8(%esp),%edx
f01226c0:	89 f9                	mov    %edi,%ecx
f01226c2:	d3 e2                	shl    %cl,%edx
f01226c4:	39 c2                	cmp    %eax,%edx
f01226c6:	73 e9                	jae    f01226b1 <__udivdi3+0xe5>
f01226c8:	8d 43 ff             	lea    -0x1(%ebx),%eax
f01226cb:	31 ff                	xor    %edi,%edi
f01226cd:	e9 40 ff ff ff       	jmp    f0122612 <__udivdi3+0x46>
f01226d2:	66 90                	xchg   %ax,%ax
f01226d4:	31 c0                	xor    %eax,%eax
f01226d6:	e9 37 ff ff ff       	jmp    f0122612 <__udivdi3+0x46>
f01226db:	90                   	nop

f01226dc <__umoddi3>:
f01226dc:	55                   	push   %ebp
f01226dd:	57                   	push   %edi
f01226de:	56                   	push   %esi
f01226df:	53                   	push   %ebx
f01226e0:	83 ec 1c             	sub    $0x1c,%esp
f01226e3:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f01226e7:	8b 74 24 34          	mov    0x34(%esp),%esi
f01226eb:	8b 7c 24 38          	mov    0x38(%esp),%edi
f01226ef:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f01226f3:	89 44 24 0c          	mov    %eax,0xc(%esp)
f01226f7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f01226fb:	89 f3                	mov    %esi,%ebx
f01226fd:	89 fa                	mov    %edi,%edx
f01226ff:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0122703:	89 34 24             	mov    %esi,(%esp)
f0122706:	85 c0                	test   %eax,%eax
f0122708:	75 1a                	jne    f0122724 <__umoddi3+0x48>
f012270a:	39 f7                	cmp    %esi,%edi
f012270c:	0f 86 a2 00 00 00    	jbe    f01227b4 <__umoddi3+0xd8>
f0122712:	89 c8                	mov    %ecx,%eax
f0122714:	89 f2                	mov    %esi,%edx
f0122716:	f7 f7                	div    %edi
f0122718:	89 d0                	mov    %edx,%eax
f012271a:	31 d2                	xor    %edx,%edx
f012271c:	83 c4 1c             	add    $0x1c,%esp
f012271f:	5b                   	pop    %ebx
f0122720:	5e                   	pop    %esi
f0122721:	5f                   	pop    %edi
f0122722:	5d                   	pop    %ebp
f0122723:	c3                   	ret    
f0122724:	39 f0                	cmp    %esi,%eax
f0122726:	0f 87 ac 00 00 00    	ja     f01227d8 <__umoddi3+0xfc>
f012272c:	0f bd e8             	bsr    %eax,%ebp
f012272f:	83 f5 1f             	xor    $0x1f,%ebp
f0122732:	0f 84 ac 00 00 00    	je     f01227e4 <__umoddi3+0x108>
f0122738:	bf 20 00 00 00       	mov    $0x20,%edi
f012273d:	29 ef                	sub    %ebp,%edi
f012273f:	89 fe                	mov    %edi,%esi
f0122741:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0122745:	89 e9                	mov    %ebp,%ecx
f0122747:	d3 e0                	shl    %cl,%eax
f0122749:	89 d7                	mov    %edx,%edi
f012274b:	89 f1                	mov    %esi,%ecx
f012274d:	d3 ef                	shr    %cl,%edi
f012274f:	09 c7                	or     %eax,%edi
f0122751:	89 e9                	mov    %ebp,%ecx
f0122753:	d3 e2                	shl    %cl,%edx
f0122755:	89 14 24             	mov    %edx,(%esp)
f0122758:	89 d8                	mov    %ebx,%eax
f012275a:	d3 e0                	shl    %cl,%eax
f012275c:	89 c2                	mov    %eax,%edx
f012275e:	8b 44 24 08          	mov    0x8(%esp),%eax
f0122762:	d3 e0                	shl    %cl,%eax
f0122764:	89 44 24 04          	mov    %eax,0x4(%esp)
f0122768:	8b 44 24 08          	mov    0x8(%esp),%eax
f012276c:	89 f1                	mov    %esi,%ecx
f012276e:	d3 e8                	shr    %cl,%eax
f0122770:	09 d0                	or     %edx,%eax
f0122772:	d3 eb                	shr    %cl,%ebx
f0122774:	89 da                	mov    %ebx,%edx
f0122776:	f7 f7                	div    %edi
f0122778:	89 d3                	mov    %edx,%ebx
f012277a:	f7 24 24             	mull   (%esp)
f012277d:	89 c6                	mov    %eax,%esi
f012277f:	89 d1                	mov    %edx,%ecx
f0122781:	39 d3                	cmp    %edx,%ebx
f0122783:	0f 82 87 00 00 00    	jb     f0122810 <__umoddi3+0x134>
f0122789:	0f 84 91 00 00 00    	je     f0122820 <__umoddi3+0x144>
f012278f:	8b 54 24 04          	mov    0x4(%esp),%edx
f0122793:	29 f2                	sub    %esi,%edx
f0122795:	19 cb                	sbb    %ecx,%ebx
f0122797:	89 d8                	mov    %ebx,%eax
f0122799:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f012279d:	d3 e0                	shl    %cl,%eax
f012279f:	89 e9                	mov    %ebp,%ecx
f01227a1:	d3 ea                	shr    %cl,%edx
f01227a3:	09 d0                	or     %edx,%eax
f01227a5:	89 e9                	mov    %ebp,%ecx
f01227a7:	d3 eb                	shr    %cl,%ebx
f01227a9:	89 da                	mov    %ebx,%edx
f01227ab:	83 c4 1c             	add    $0x1c,%esp
f01227ae:	5b                   	pop    %ebx
f01227af:	5e                   	pop    %esi
f01227b0:	5f                   	pop    %edi
f01227b1:	5d                   	pop    %ebp
f01227b2:	c3                   	ret    
f01227b3:	90                   	nop
f01227b4:	89 fd                	mov    %edi,%ebp
f01227b6:	85 ff                	test   %edi,%edi
f01227b8:	75 0b                	jne    f01227c5 <__umoddi3+0xe9>
f01227ba:	b8 01 00 00 00       	mov    $0x1,%eax
f01227bf:	31 d2                	xor    %edx,%edx
f01227c1:	f7 f7                	div    %edi
f01227c3:	89 c5                	mov    %eax,%ebp
f01227c5:	89 f0                	mov    %esi,%eax
f01227c7:	31 d2                	xor    %edx,%edx
f01227c9:	f7 f5                	div    %ebp
f01227cb:	89 c8                	mov    %ecx,%eax
f01227cd:	f7 f5                	div    %ebp
f01227cf:	89 d0                	mov    %edx,%eax
f01227d1:	e9 44 ff ff ff       	jmp    f012271a <__umoddi3+0x3e>
f01227d6:	66 90                	xchg   %ax,%ax
f01227d8:	89 c8                	mov    %ecx,%eax
f01227da:	89 f2                	mov    %esi,%edx
f01227dc:	83 c4 1c             	add    $0x1c,%esp
f01227df:	5b                   	pop    %ebx
f01227e0:	5e                   	pop    %esi
f01227e1:	5f                   	pop    %edi
f01227e2:	5d                   	pop    %ebp
f01227e3:	c3                   	ret    
f01227e4:	3b 04 24             	cmp    (%esp),%eax
f01227e7:	72 06                	jb     f01227ef <__umoddi3+0x113>
f01227e9:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f01227ed:	77 0f                	ja     f01227fe <__umoddi3+0x122>
f01227ef:	89 f2                	mov    %esi,%edx
f01227f1:	29 f9                	sub    %edi,%ecx
f01227f3:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f01227f7:	89 14 24             	mov    %edx,(%esp)
f01227fa:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f01227fe:	8b 44 24 04          	mov    0x4(%esp),%eax
f0122802:	8b 14 24             	mov    (%esp),%edx
f0122805:	83 c4 1c             	add    $0x1c,%esp
f0122808:	5b                   	pop    %ebx
f0122809:	5e                   	pop    %esi
f012280a:	5f                   	pop    %edi
f012280b:	5d                   	pop    %ebp
f012280c:	c3                   	ret    
f012280d:	8d 76 00             	lea    0x0(%esi),%esi
f0122810:	2b 04 24             	sub    (%esp),%eax
f0122813:	19 fa                	sbb    %edi,%edx
f0122815:	89 d1                	mov    %edx,%ecx
f0122817:	89 c6                	mov    %eax,%esi
f0122819:	e9 71 ff ff ff       	jmp    f012278f <__umoddi3+0xb3>
f012281e:	66 90                	xchg   %ax,%ax
f0122820:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0122824:	72 ea                	jb     f0122810 <__umoddi3+0x134>
f0122826:	89 d9                	mov    %ebx,%ecx
f0122828:	e9 62 ff ff ff       	jmp    f012278f <__umoddi3+0xb3>
