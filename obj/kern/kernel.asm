
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 e0 17 00 	lgdtl  0x17e018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 e0 17 f0       	mov    $0xf017e000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 58 b8 6b f0 01 	movl   $0x1,0xf06bb858
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 a4 b7 6b f0 01 	movl   $0x1,0xf06bb7a4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 90 64 b0 f0       	mov    $0xf0b06490,%edx
f010006a:	b8 64 25 69 f0       	mov    $0xf0692564,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 64 25 69 f0       	push   $0xf0692564
f010007e:	e8 44 f6 01 00       	call   f011f6c7 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 e0 1d 12 f0       	push   $0xf0121de0
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 27 1e 12 f0       	push   $0xf0121e27
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 3b 1e 12 f0       	push   $0xf0121e3b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 4f 1e 12 f0       	push   $0xf0121e4f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 3c 70 00 00       	call   f0107116 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 5b 1e 12 f0       	push   $0xf0121e5b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 63 1e 12 f0       	push   $0xf0121e63
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 81 79 00 00       	call   f0107a83 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 22 75 00 00       	call   f0107629 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 c2 7c 00 00       	call   f0107dce <initialize_paging>
		sharing_init();
f010010c:	e8 33 89 00 00       	call   f0108a44 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 79 8d 00 00       	call   f0108ea1 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 4d ed 00 00       	call   f010ee7d <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 36 ee 00 00       	call   f010ef7a <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 11 ee 00 00       	call   f010ef62 <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 31 ee 00 00       	call   f010ef92 <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 b5 fa 01 00       	call   f011fc1e <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 71 1e 12 f0       	push   $0xf0121e71
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 b8 a4 00 00       	call   f010a636 <env_init>
		ts_init();
f010017e:	e8 9c c6 00 00       	call   f010c81f <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 5b 1e 12 f0       	push   $0xf0121e5b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 84 1e 12 f0       	push   $0xf0121e84
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 5a 6c 00 00       	call   f0106e02 <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 ad 1e 12 f0       	push   $0xf0121ead
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 32 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 c3 1e 12 f0       	push   $0xf0121ec3
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 15 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 e0 1e 12 f0       	push   $0xf0121ee0
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 f8 6d 00 00       	call   f0106ff4 <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 ff 1e 12 f0       	push   $0xf0121eff
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 1c 1f 12 f0       	push   $0xf0121f1c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 d4 49 00 00       	call   f0104bf8 <kclock_init>
		sched_init() ;
f0100224:	e8 04 65 00 00       	call   f010672d <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 40 1f 12 f0       	push   $0xf0121f40
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 e0 17 f0       	mov    $0xf017e000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 60 1f 12 f0       	push   $0xf0121f60
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 84 1f 12 f0       	push   $0xf0121f84
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 9c ba 6b f0 00 	movl   $0x0,0xf06bba9c
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 cc 1f 12 f0       	push   $0xf0121fcc
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 f8 1f 12 f0       	push   $0xf0121ff8
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 1d 20 12 f0       	push   $0xf012201d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 24 20 12 f0       	push   $0xf0122024
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 6c 20 12 f0       	push   $0xf012206c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 b4 20 12 f0       	push   $0xf01220b4
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 6c 20 12 f0       	push   $0xf012206c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 24 20 12 f0       	push   $0xf0122024
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 f9 20 12 f0       	push   $0xf01220f9
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 46 af 00 00       	call   f010b28a <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 80 25 69 f0       	mov    %eax,0xf0692580

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 00 21 12 f0       	push   $0xf0122100
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 25 21 12 f0       	push   $0xf0122125
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 a2 ae 00 00       	call   f010b248 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 27 21 12 f0       	push   $0xf0122127
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 80 25 69 f0       	mov    %eax,0xf0692580

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 31 21 12 f0       	push   $0xf0122131
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 25 21 12 f0       	push   $0xf0122125
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 b2 6d 00 00       	call   f01071cf <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 ea 6c 00 00       	call   f010710c <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 eb 6d 00 00       	call   f0107221 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 94 60 00 00       	call   f01064d5 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 44 ae 00 00       	call   f010b28a <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 e9 ad 00 00       	call   f010b248 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 80 25 69 f0       	mov    %eax,0xf0692580

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 31 21 12 f0       	push   $0xf0122131
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 25 21 12 f0       	push   $0xf0122125
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 d2 ad 00 00       	call   f010b28a <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 77 ad 00 00       	call   f010b248 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 4a 21 12 f0       	push   $0xf012214a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 25 21 12 f0       	push   $0xf0122125
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 a4 25 69 f0       	mov    0xf06925a4,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 68 21 12 f0       	push   $0xf0122168
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 a4 25 69 f0       	mov    %eax,0xf06925a4
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 ae d4 00 00       	call   f010db23 <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 a8 25 69 f0 b4 	movl   $0x3b4,0xf06925a8
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 a8 25 69 f0 d4 	movl   $0x3d4,0xf06925a8
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 a8 25 69 f0       	mov    0xf06925a8,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 a8 25 69 f0       	mov    0xf06925a8,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 a8 25 69 f0       	mov    0xf06925a8,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 a8 25 69 f0       	mov    0xf06925a8,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 ac 25 69 f0       	mov    %eax,0xf06925ac
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 b0 25 69 f0    	mov    %ax,0xf06925b0
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 b0 25 69 f0    	mov    %ax,0xf06925b0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 ac 25 69 f0    	mov    0xf06925ac,%edx
f010087a:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 b0 25 69 f0    	mov    %ax,0xf06925b0
		text_length = 0;
f01008a6:	c7 05 a0 25 69 f0 00 	movl   $0x0,0xf06925a0
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d b0 25 69 f0 	mov    0xf06925b0,%cx
f01008b7:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 b0 25 69 f0    	mov    %ax,0xf06925b0
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 b0 25 69 f0    	mov    %ax,0xf06925b0
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 b0 25 69 f0    	mov    %ax,0xf06925b0
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d ac 25 69 f0    	mov    0xf06925ac,%ecx
f0100972:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 b0 25 69 f0 	mov    %dx,0xf06925b0
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 a0 25 69 f0    	mov    0xf06925a0,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 a0 25 69 f0       	mov    0xf06925a0,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 a0 25 69 f0       	mov    %eax,0xf06925a0
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 ac 25 69 f0       	mov    0xf06925ac,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 ac 25 69 f0       	mov    0xf06925ac,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 0c ed 01 00       	call   f011f6f7 <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 ac 25 69 f0    	mov    0xf06925ac,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 b0 25 69 f0    	mov    %ax,0xf06925b0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 a8 25 69 f0       	mov    0xf06925a8,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 a8 25 69 f0    	mov    0xf06925a8,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 a8 25 69 f0       	mov    0xf06925a8,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 a8 25 69 f0    	mov    0xf06925a8,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 c8 27 69 f0       	mov    %eax,0xf06927c8
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 e0 17 f0    	mov    -0xfe81fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 c8 27 69 f0       	mov    %eax,0xf06927c8
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 c8 27 69 f0       	mov    %eax,0xf06927c8
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 e0 17 f0    	mov    -0xfe81fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 c8 27 69 f0       	mov    %eax,0xf06927c8
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 e1 17 f0    	mov    -0xfe81ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 c8 27 69 f0       	mov    %eax,0xf06927c8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 e5 17 f0 	mov    -0xfe81ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 a0 25 69 f0       	mov    0xf06925a0,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 a0 25 69 f0    	mov    0xf06925a0,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 a0 25 69 f0       	mov    0xf06925a0,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 a0 25 69 f0       	mov    %eax,0xf06925a0
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 b0 25 69 f0    	mov    0xf06925b0,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 ac 25 69 f0    	mov    0xf06925ac,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 ac 25 69 f0       	mov    0xf06925ac,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 a0 25 69 f0       	mov    0xf06925a0,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 c8 27 69 f0       	mov    0xf06927c8,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 7b 21 12 f0       	push   $0xf012217b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 0e ce 00 00       	call   f010db23 <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 c4 27 69 f0       	mov    0xf06927c4,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 c4 27 69 f0    	mov    %edx,0xf06927c4
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 c0 25 69 f0    	mov    %dl,-0xf96da40(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 c4 27 69 f0       	mov    0xf06927c4,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 c4 27 69 f0 00 	movl   $0x0,0xf06927c4
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 c0 27 69 f0    	mov    0xf06927c0,%edx
f0100d7f:	a1 c4 27 69 f0       	mov    0xf06927c4,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 c0 27 69 f0       	mov    0xf06927c0,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 c0 27 69 f0    	mov    %edx,0xf06927c0
f0100d96:	8a 80 c0 25 69 f0    	mov    -0xf96da40(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 c0 27 69 f0       	mov    0xf06927c0,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 c0 27 69 f0 00 	movl   $0x0,0xf06927c0
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 c0 27 69 f0    	mov    0xf06927c0,%edx
f0100dd0:	a1 c4 27 69 f0       	mov    0xf06927c4,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 c0 27 69 f0       	mov    0xf06927c0,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 c0 27 69 f0    	mov    %edx,0xf06927c0
f0100de7:	8a 80 c0 25 69 f0    	mov    -0xf96da40(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 c0 27 69 f0       	mov    0xf06927c0,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 c0 27 69 f0 00 	movl   $0x0,0xf06927c0
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 a4 25 69 f0       	mov    0xf06925a4,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 87 21 12 f0       	push   $0xf0122187
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ff 3d 00 00       	call   f0104cba <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 c9 a3 00 00       	call   f010b28a <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 a4 21 12 f0       	push   $0xf01221a4
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 cb 21 12 f0       	push   $0xf01221cb
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 b8 3d 00 00       	call   f0104cba <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 82 a3 00 00       	call   f010b28a <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 e0 21 12 f0       	push   $0xf01221e0
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 cb 21 12 f0       	push   $0xf01221cb
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 94 de 01 00       	call   f011ee17 <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 39 62 00 00       	call   f01071cf <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 6b 62 00 00       	call   f0107221 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 60 4b 6d f0       	add    $0xf06d4b60,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 e1 e4 01 00       	call   f011f4d9 <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 80 9b 6d f0       	push   $0xf06d9b80
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 e4 e6 01 00       	call   f011f6f7 <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 60 4b 6d f0       	add    $0xf06d4b60,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 60 4b 6d f0       	add    $0xf06d4b60,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 1f e4 01 00       	call   f011f4d9 <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 80 9b 6d f0       	push   $0xf06d9b80
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 22 e6 01 00       	call   f011f6f7 <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 60 bb 6b f0       	add    $0xf06bbb60,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 5f e5 01 00       	call   f011f6c7 <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 0c 22 12 f0       	push   $0xf012220c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 0f 22 12 f0       	push   $0xf012220f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 60 bb 6b f0       	push   $0xf06bbb60
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 04 e2 01 00       	call   f011f4d9 <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 19 e2 01 00       	call   f011f528 <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 bc e1 01 00       	call   f011f4d9 <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 1f 22 12 f0       	push   $0xf012221f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 97 e7 01 00       	call   f011faee <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 24 22 12 f0       	push   $0xf0122224
f010137e:	50                   	push   %eax
f010137f:	e8 61 e2 01 00       	call   f011f5e5 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 28 22 12 f0       	push   $0xf0122228
f0101399:	50                   	push   %eax
f010139a:	e8 46 e2 01 00       	call   f011f5e5 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 2d 22 12 f0       	push   $0xf012222d
f01013b4:	50                   	push   %eax
f01013b5:	e8 2b e2 01 00       	call   f011f5e5 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 2d 22 12 f0       	push   $0xf012222d
f01013d5:	50                   	push   %eax
f01013d6:	e8 0a e2 01 00       	call   f011f5e5 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 b2 e0 01 00       	call   f011f4d9 <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 b4 e0 01 00       	call   f011f528 <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 93 e0 01 00       	call   f011f528 <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 10 e0 01 00       	call   f011f4d9 <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 2b e1 01 00       	call   f011f61d <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 60 df 01 00       	call   f011f4d9 <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 60 bb 6b f0       	add    $0xf06bbb60,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 2b e1 01 00       	call   f011f6c7 <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 60 bb 6b f0    	add    $0xf06bbb60,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 96 df 01 00       	call   f011f556 <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 d6 de 01 00       	call   f011f4d9 <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 ec 17 f0    	mov    0xf017ece0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 ee df 01 00       	call   f011f61d <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 39 de 01 00       	call   f011f4d9 <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 ec 17 f0    	mov    0xf017ece0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 ec 17 f0    	mov    0xf017ece0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 d9 dd 01 00       	call   f011f4d9 <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 60 bb 6b f0       	add    $0xf06bbb60,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 a4 df 01 00       	call   f011f6c7 <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 60 bb 6b f0    	add    $0xf06bbb60,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 0f de 01 00       	call   f011f556 <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 51 dd 01 00       	call   f011f4d9 <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 6c de 01 00       	call   f011f61d <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 b7 dc 01 00       	call   f011f4d9 <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 5d dc 01 00       	call   f011f4d9 <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 60 bb 6b f0       	add    $0xf06bbb60,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 28 de 01 00       	call   f011f6c7 <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 60 bb 6b f0    	add    $0xf06bbb60,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 93 dc 01 00       	call   f011f556 <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 ed 17 f0       	mov    0xf017edb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 60 bb 6b f0       	add    $0xf06bbb60,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 60 bb 6b f0       	push   $0xf06bbb60
f0101929:	e8 ab db 01 00       	call   f011f4d9 <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 52 db 01 00       	call   f011f4d9 <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 3f db 01 00       	call   f011f4d9 <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 60 bb 6b f0    	lea    -0xf9444a0(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 60 bb 6b f0       	add    $0xf06bbb60,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 e4 da 01 00       	call   f011f4d9 <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 60 4b 6d f0    	lea    -0xf92b4a0(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 60 4b 6d f0       	add    $0xf06d4b60,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 d9 da 01 00       	call   f011f6f7 <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 60 97 6d f0       	push   $0xf06d9760
f0101c3a:	e8 b8 da 01 00       	call   f011f6f7 <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 60 4b 6d f0       	add    $0xf06d4b60,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 88 d9 01 00       	call   f011f5e5 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 e5 17 f0       	mov    %eax,0xf017e530
f0101c6f:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 60 4b 6d f0       	add    $0xf06d4b60,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 6a da 01 00       	call   f011f6f7 <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 9c ba 6b f0       	mov    0xf06bba9c,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 37 22 12 f0       	mov    $0xf0122237,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 37 26 12 f0       	mov    $0xf0122637,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 37 2a 12 f0       	mov    $0xf0122a37,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 9c ba 6b f0 00 	movl   $0x0,0xf06bba9c
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 18 ba 6b f0 00 	movl   $0x0,0xf06bba18
f0101d59:	00 00 00 
f0101d5c:	c7 05 1c ba 6b f0 00 	movl   $0x0,0xf06bba1c
f0101d63:	00 00 00 
f0101d66:	c7 05 24 ba 6b f0 00 	movl   $0x0,0xf06bba24
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 41 d9 01 00       	call   f011f6c7 <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 31 22 12 f0       	push   $0xf0122231
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 38 97 00 00       	call   f010b517 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 28 53 00 00       	call   f010710c <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 40 bb 6b f0       	mov    %eax,0xf06bbb40
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 60 9b 6d f0       	mov    %eax,0xf06d9b60
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 40 bb 6b f0       	mov    0xf06bbb40,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 40 bb 6b f0    	mov    %edx,0xf06bbb40
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 60 9b 6d f0       	mov    0xf06d9b60,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 60 9b 6d f0       	mov    %eax,0xf06d9b60
f0101e98:	a1 60 9b 6d f0       	mov    0xf06d9b60,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 40 bb 6b f0       	mov    %eax,0xf06bbb40
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 60 9b 6d f0       	mov    %eax,0xf06d9b60
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 40 bb 6b f0       	mov    0xf06bbb40,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 40 bb 6b f0    	mov    %edx,0xf06bbb40
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 60 9b 6d f0       	mov    0xf06d9b60,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 60 9b 6d f0       	mov    %eax,0xf06d9b60
f0101ed4:	a1 60 9b 6d f0       	mov    0xf06d9b60,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 1f 22 12 f0       	push   $0xf012221f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 d8 db 01 00       	call   f011faee <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 37 2e 12 f0       	push   $0xf0122e37
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 24 ba 6b f0       	mov    0xf06bba24,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 50 2e 12 f0       	push   $0xf0122e50
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 a1 2e 12 f0       	push   $0xf0122ea1
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 18 ba 6b f0       	mov    0xf06bba18,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 bc 2e 12 f0       	push   $0xf0122ebc
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 24 ba 6b f0       	mov    0xf06bba24,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 ec 2e 12 f0       	push   $0xf0122eec
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 a1 2e 12 f0       	push   $0xf0122ea1
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 18 ba 6b f0       	mov    0xf06bba18,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 16 2f 12 f0       	push   $0xf0122f16
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 20 ba 6b f0       	mov    0xf06bba20,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 20 ba 6b f0       	mov    %eax,0xf06bba20
f010203b:	a1 20 ba 6b f0       	mov    0xf06bba20,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 20 2f 12 f0       	push   $0xf0122f20
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 18 ba 6b f0       	mov    0xf06bba18,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 83 2f 12 f0       	push   $0xf0122f83
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 8c 2f 12 f0       	push   $0xf0122f8c
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 20 ba 6b f0       	mov    0xf06bba20,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 20 ba 6b f0       	mov    %eax,0xf06bba20
f010218b:	a1 20 ba 6b f0       	mov    0xf06bba20,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 e5 17 f0       	add    $0xf017e548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 18 ba 6b f0       	mov    0xf06bba18,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 94 2f 12 f0       	push   $0xf0122f94
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 a1 2e 12 f0       	push   $0xf0122ea1
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 1c ba 6b f0       	mov    %eax,0xf06bba1c
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 18 ba 6b f0       	mov    %eax,0xf06bba18
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 24 ba 6b f0       	mov    0xf06bba24,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 24 ba 6b f0       	mov    %eax,0xf06bba24

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 20 ba 6b f0       	mov    0xf06bba20,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 20 ba 6b f0       	mov    %eax,0xf06bba20
f0102292:	a1 20 ba 6b f0       	mov    0xf06bba20,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 07 d3 01 00       	call   f011f5e5 <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c e5 17 f0       	add    $0xf017e54c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c e5 17 f0       	add    $0xf017e54c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 18 ba 6b f0    	mov    0xf06bba18,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 18 ba 6b f0    	mov    0xf06bba18,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f010238d:	a3 1c ba 6b f0       	mov    %eax,0xf06bba1c
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01023a3:	a3 18 ba 6b f0       	mov    %eax,0xf06bba18
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 e5 17 f0       	add    $0xf017e554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 24 ba 6b f0       	mov    0xf06bba24,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 24 ba 6b f0       	mov    %eax,0xf06bba24
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 18 ba 6b f0    	mov    0xf06bba18,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 18 ba 6b f0    	mov    0xf06bba18,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f010248c:	a3 1c ba 6b f0       	mov    %eax,0xf06bba1c
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01024a2:	a3 18 ba 6b f0       	mov    %eax,0xf06bba18
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 e5 17 f0       	add    $0xf017e554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 24 ba 6b f0       	mov    0xf06bba24,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 24 ba 6b f0       	mov    %eax,0xf06bba24
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 58 b8 6b f0 00 	movl   $0x0,0xf06bb858
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 58 b8 6b f0 01 	movl   $0x1,0xf06bb858
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 58 b8 6b f0 02 	movl   $0x2,0xf06bb858
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 58 b8 6b f0 03 	movl   $0x3,0xf06bb858
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 58 b8 6b f0 04 	movl   $0x4,0xf06bb858
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 a4 b7 6b f0 01 	movl   $0x1,0xf06bb7a4
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 a4 b7 6b f0 02 	movl   $0x2,0xf06bb7a4
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 a4 b7 6b f0 03 	movl   $0x3,0xf06bb7a4
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 a4 b7 6b f0 04 	movl   $0x4,0xf06bb7a4
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 a4 b7 6b f0       	mov    0xf06bb7a4,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 a4 b7 6b f0       	mov    0xf06bb7a4,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 a4 b7 6b f0       	mov    0xf06bb7a4,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 a4 b7 6b f0       	mov    0xf06bb7a4,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 b4 2f 12 f0       	push   $0xf0122fb4
f0102662:	6a 56                	push   $0x56
f0102664:	68 dc 2f 12 f0       	push   $0xf0122fdc
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 c0 b7 6b f0    	mov    0xf06bb7c0,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 e5 17 f0       	add    $0xf017e544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 5f 38 12 f0       	push   $0xf012385f
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 68 38 12 f0       	push   $0xf0123868
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d e0 ec 17 f0    	mov    0xf017ece0,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d e0 ec 17 f0    	mov    0xf017ece0,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 7d 38 12 f0       	push   $0xf012387d
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 99 38 12 f0       	push   $0xf0123899
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 b4 38 12 f0       	push   $0xf01238b4
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 d9 1d 12 00       	mov    $0x121dd9,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 d9 1d 12 f0       	push   $0xf0121dd9
f010278e:	68 f0 38 12 f0       	push   $0xf01238f0
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 64 25 69 00       	mov    $0x692564,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 64 25 69 f0       	push   $0xf0692564
f01027a9:	68 2c 39 12 f0       	push   $0xf012392c
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 90 64 b0 00       	mov    $0xb06490,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 90 64 b0 f0       	push   $0xf0b06490
f01027c4:	68 74 39 12 f0       	push   $0xf0123974
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 90 64 b0 f0       	mov    $0xf0b06490,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 b0 39 12 f0       	push   $0xf01239b0
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 0f d0 01 00       	call   f011f839 <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 ce cf 01 00       	call   f011f839 <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 51 8a 00 00       	call   f010b2da <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 98 cf 01 00       	call   f011f839 <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 dc 39 12 f0       	push   $0xf01239dc
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 12 cf 01 00       	call   f011f839 <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 8f cb 01 00       	call   f011f4d9 <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 94 ce 01 00       	call   f011f839 <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 06 3a 12 f0       	push   $0xf0123a06
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 48 ce 01 00       	call   f011f839 <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 cb 88 00 00       	call   f010b2da <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 12 ce 01 00       	call   f011f839 <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 06 3a 12 f0       	push   $0xf0123a06
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 20 3a 12 f0       	push   $0xf0123a20
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 81 cd 01 00       	call   f011f839 <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 4a 3a 12 f0       	push   $0xf0123a4a
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 4d 3a 12 f0       	push   $0xf0123a4d
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 24 cd 01 00       	call   f011f839 <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 a7 87 00 00       	call   f010b2da <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 ee cc 01 00       	call   f011f839 <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 d3 cc 01 00       	call   f011f839 <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 4f 3a 12 f0       	push   $0xf0123a4f
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 37 cc 01 00       	call   f011f839 <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 ba 86 00 00       	call   f010b2da <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 f0 cb 01 00       	call   f011f839 <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 09 68 00 00       	call   f010948e <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 ba 66 00 00       	call   f010934b <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 4b 56 00 00       	call   f0108306 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 60 3a 12 f0       	push   $0xf0123a60
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 fb ca 01 00       	call   f011f839 <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 7e 85 00 00       	call   f010b2da <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 b4 ca 01 00       	call   f011f839 <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 1b 54 00 00       	call   f01081b2 <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 8a 3a 12 f0       	push   $0xf0123a8a
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 a7 58 00 00       	call   f010867f <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 a4 3a 12 f0       	push   $0xf0123aa4
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 18 58 00 00       	call   f010867f <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 dc 5a 00 00       	call   f0108961 <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 e8 3a 12 f0       	push   $0xf0123ae8
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 70 b9 6b f0       	mov    0xf06bb970,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 40 3b 12 f0       	push   $0xf0123b40
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ef9:	83 f8 04             	cmp    $0x4,%eax
f0102efc:	0f 84 94 00 00 00    	je     f0102f96 <CreateEnv+0xc2>
f0102f02:	83 f8 05             	cmp    $0x5,%eax
f0102f05:	74 0e                	je     f0102f15 <CreateEnv+0x41>
f0102f07:	83 f8 03             	cmp    $0x3,%eax
f0102f0a:	0f 84 ec 00 00 00    	je     f0102ffc <CreateEnv+0x128>
f0102f10:	e9 2f 01 00 00       	jmp    f0103044 <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f15:	83 ec 0c             	sub    $0xc,%esp
f0102f18:	6a 02                	push   $0x2
f0102f1a:	e8 a6 bf 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f0102f1f:	83 c4 10             	add    $0x10,%esp
f0102f22:	85 c0                	test   %eax,%eax
f0102f24:	75 1a                	jne    f0102f40 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f26:	83 ec 0c             	sub    $0xc,%esp
f0102f29:	68 7c 3b 12 f0       	push   $0xf0123b7c
f0102f2e:	e8 58 e0 ff ff       	call   f0100f8b <cprintf>
f0102f33:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f3b:	e9 ff 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f43:	83 c0 10             	add    $0x10,%eax
f0102f46:	8b 00                	mov    (%eax),%eax
f0102f48:	83 ec 04             	sub    $0x4,%esp
f0102f4b:	6a 0a                	push   $0xa
f0102f4d:	6a 00                	push   $0x0
f0102f4f:	50                   	push   %eax
f0102f50:	e8 e4 c8 01 00       	call   f011f839 <strtol>
f0102f55:	83 c4 10             	add    $0x10,%esp
f0102f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5e:	83 c0 0c             	add    $0xc,%eax
f0102f61:	8b 00                	mov    (%eax),%eax
f0102f63:	83 ec 04             	sub    $0x4,%esp
f0102f66:	6a 0a                	push   $0xa
f0102f68:	6a 00                	push   $0x0
f0102f6a:	50                   	push   %eax
f0102f6b:	e8 c9 c8 01 00       	call   f011f839 <strtol>
f0102f70:	83 c4 10             	add    $0x10,%esp
f0102f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 08             	add    $0x8,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 ae c8 01 00       	call   f011f839 <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102f91:	e9 c8 00 00 00       	jmp    f010305e <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f96:	83 ec 0c             	sub    $0xc,%esp
f0102f99:	6a 02                	push   $0x2
f0102f9b:	e8 25 bf 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f0102fa0:	83 c4 10             	add    $0x10,%esp
f0102fa3:	85 c0                	test   %eax,%eax
f0102fa5:	75 1d                	jne    f0102fc4 <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faa:	83 c0 0c             	add    $0xc,%eax
f0102fad:	8b 00                	mov    (%eax),%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	6a 0a                	push   $0xa
f0102fb4:	6a 00                	push   $0x0
f0102fb6:	50                   	push   %eax
f0102fb7:	e8 7d c8 01 00       	call   f011f839 <strtol>
f0102fbc:	83 c4 10             	add    $0x10,%esp
f0102fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102fc2:	eb 1b                	jmp    f0102fdf <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fc7:	83 c0 0c             	add    $0xc,%eax
f0102fca:	8b 00                	mov    (%eax),%eax
f0102fcc:	83 ec 04             	sub    $0x4,%esp
f0102fcf:	6a 0a                	push   $0xa
f0102fd1:	6a 00                	push   $0x0
f0102fd3:	50                   	push   %eax
f0102fd4:	e8 60 c8 01 00       	call   f011f839 <strtol>
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe2:	83 c0 08             	add    $0x8,%eax
f0102fe5:	8b 00                	mov    (%eax),%eax
f0102fe7:	83 ec 04             	sub    $0x4,%esp
f0102fea:	6a 0a                	push   $0xa
f0102fec:	6a 00                	push   $0x0
f0102fee:	50                   	push   %eax
f0102fef:	e8 45 c8 01 00       	call   f011f839 <strtol>
f0102ff4:	83 c4 10             	add    $0x10,%esp
f0102ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102ffa:	eb 62                	jmp    f010305e <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ffc:	83 ec 0c             	sub    $0xc,%esp
f0102fff:	6a 02                	push   $0x2
f0103001:	e8 bf be 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f0103006:	83 c4 10             	add    $0x10,%esp
f0103009:	85 c0                	test   %eax,%eax
f010300b:	74 1a                	je     f0103027 <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f010300d:	83 ec 0c             	sub    $0xc,%esp
f0103010:	68 28 3c 12 f0       	push   $0xf0123c28
f0103015:	e8 71 df ff ff       	call   f0100f8b <cprintf>
f010301a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f010301d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103022:	e9 18 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103027:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302a:	83 c0 08             	add    $0x8,%eax
f010302d:	8b 00                	mov    (%eax),%eax
f010302f:	83 ec 04             	sub    $0x4,%esp
f0103032:	6a 0a                	push   $0xa
f0103034:	6a 00                	push   $0x0
f0103036:	50                   	push   %eax
f0103037:	e8 fd c7 01 00       	call   f011f839 <strtol>
f010303c:	83 c4 10             	add    $0x10,%esp
f010303f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103042:	eb 1a                	jmp    f010305e <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 b8 3c 12 f0       	push   $0xf0123cb8
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 e1 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	6a 02                	push   $0x2
f0103063:	e8 5d be 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f0103068:	83 c4 10             	add    $0x10,%esp
f010306b:	85 c0                	test   %eax,%eax
f010306d:	74 23                	je     f0103092 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f010306f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103072:	48                   	dec    %eax
f0103073:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103076:	73 1a                	jae    f0103092 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103078:	83 ec 0c             	sub    $0xc,%esp
f010307b:	68 50 3d 12 f0       	push   $0xf0123d50
f0103080:	e8 06 df ff ff       	call   f0100f8b <cprintf>
f0103085:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103088:	b8 00 00 00 00       	mov    $0x0,%eax
f010308d:	e9 ad 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103092:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f0103096:	76 19                	jbe    f01030b1 <CreateEnv+0x1dd>
f0103098:	68 a8 3d 12 f0       	push   $0xf0123da8
f010309d:	68 ed 3d 12 f0       	push   $0xf0123ded
f01030a2:	68 a4 01 00 00       	push   $0x1a4
f01030a7:	68 02 3e 12 f0       	push   $0xf0123e02
f01030ac:	e8 88 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030b1:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030b5:	76 19                	jbe    f01030d0 <CreateEnv+0x1fc>
f01030b7:	68 a8 3d 12 f0       	push   $0xf0123da8
f01030bc:	68 ed 3d 12 f0       	push   $0xf0123ded
f01030c1:	68 c0 01 00 00       	push   $0x1c0
f01030c6:	68 02 3e 12 f0       	push   $0xf0123e02
f01030cb:	e8 69 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f01030d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030d3:	83 c0 04             	add    $0x4,%eax
f01030d6:	8b 00                	mov    (%eax),%eax
f01030d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01030db:	ff 75 f0             	pushl  -0x10(%ebp)
f01030de:	ff 75 f4             	pushl  -0xc(%ebp)
f01030e1:	50                   	push   %eax
f01030e2:	e8 25 77 00 00       	call   f010a80c <env_create>
f01030e7:	83 c4 10             	add    $0x10,%esp
f01030ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f01030ed:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f01030f1:	74 49                	je     f010313c <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f01030f3:	83 ec 08             	sub    $0x8,%esp
f01030f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01030f9:	68 16 3e 12 f0       	push   $0xf0123e16
f01030fe:	e8 88 de ff ff       	call   f0100f8b <cprintf>
f0103103:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103106:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010310a:	7c 06                	jl     f0103112 <CreateEnv+0x23e>
f010310c:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103110:	7e 19                	jle    f010312b <CreateEnv+0x257>
f0103112:	68 28 3e 12 f0       	push   $0xf0123e28
f0103117:	68 ed 3d 12 f0       	push   $0xf0123ded
f010311c:	68 c5 01 00 00       	push   $0x1c5
f0103121:	68 02 3e 12 f0       	push   $0xf0123e02
f0103126:	e8 0e d2 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010312b:	83 ec 08             	sub    $0x8,%esp
f010312e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103131:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103134:	e8 4d 35 00 00       	call   f0106686 <env_set_nice>
f0103139:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f010313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010313f:	c9                   	leave  
f0103140:	c3                   	ret    

f0103141 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103141:	55                   	push   %ebp
f0103142:	89 e5                	mov    %esp,%ebp
f0103144:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103147:	83 ec 08             	sub    $0x8,%esp
f010314a:	ff 75 0c             	pushl  0xc(%ebp)
f010314d:	ff 75 08             	pushl  0x8(%ebp)
f0103150:	e8 7f fd ff ff       	call   f0102ed4 <CreateEnv>
f0103155:	83 c4 10             	add    $0x10,%esp
f0103158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f010315b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010315f:	75 07                	jne    f0103168 <command_run_program+0x27>
f0103161:	b8 00 00 00 00       	mov    $0x0,%eax
f0103166:	eb 46                	jmp    f01031ae <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010316b:	8b 40 10             	mov    0x10(%eax),%eax
f010316e:	83 ec 08             	sub    $0x8,%esp
f0103171:	50                   	push   %eax
f0103172:	68 58 3e 12 f0       	push   $0xf0123e58
f0103177:	e8 0f de ff ff       	call   f0100f8b <cprintf>
f010317c:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f010317f:	83 ec 0c             	sub    $0xc,%esp
f0103182:	ff 75 f4             	pushl  -0xc(%ebp)
f0103185:	e8 92 25 00 00       	call   f010571c <sched_new_env>
f010318a:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010318d:	c7 05 70 b9 6b f0 00 	movl   $0x0,0xf06bb970
f0103194:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010319a:	8b 40 10             	mov    0x10(%eax),%eax
f010319d:	83 ec 0c             	sub    $0xc,%esp
f01031a0:	50                   	push   %eax
f01031a1:	e8 cc 25 00 00       	call   f0105772 <sched_run_env>
f01031a6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ae:	c9                   	leave  
f01031af:	c3                   	ret    

f01031b0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b9:	83 c0 04             	add    $0x4,%eax
f01031bc:	8b 00                	mov    (%eax),%eax
f01031be:	83 ec 04             	sub    $0x4,%esp
f01031c1:	6a 0a                	push   $0xa
f01031c3:	6a 00                	push   $0x0
f01031c5:	50                   	push   %eax
f01031c6:	e8 6e c6 01 00       	call   f011f839 <strtol>
f01031cb:	83 c4 10             	add    $0x10,%esp
f01031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f01031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 db 28 00 00       	call   f0105ab8 <sched_kill_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ed:	83 ec 08             	sub    $0x8,%esp
f01031f0:	ff 75 0c             	pushl  0xc(%ebp)
f01031f3:	ff 75 08             	pushl  0x8(%ebp)
f01031f6:	e8 d9 fc ff ff       	call   f0102ed4 <CreateEnv>
f01031fb:	83 c4 10             	add    $0x10,%esp
f01031fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103205:	75 07                	jne    f010320e <commnad_load_env+0x27>
		return 0 ;
f0103207:	b8 00 00 00 00       	mov    $0x0,%eax
f010320c:	eb 2a                	jmp    f0103238 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010320e:	83 ec 0c             	sub    $0xc,%esp
f0103211:	ff 75 f4             	pushl  -0xc(%ebp)
f0103214:	e8 03 25 00 00       	call   f010571c <sched_new_env>
f0103219:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010321c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321f:	8b 40 10             	mov    0x10(%eax),%eax
f0103222:	83 ec 08             	sub    $0x8,%esp
f0103225:	50                   	push   %eax
f0103226:	68 58 3e 12 f0       	push   $0xf0123e58
f010322b:	e8 5b dd ff ff       	call   f0100f8b <cprintf>
f0103230:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103233:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103238:	c9                   	leave  
f0103239:	c3                   	ret    

f010323a <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f010323a:	55                   	push   %ebp
f010323b:	89 e5                	mov    %esp,%ebp
f010323d:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103240:	c7 05 70 b9 6b f0 00 	movl   $0x0,0xf06bb970
f0103247:	00 00 00 
	sched_run_all();
f010324a:	e8 26 2e 00 00       	call   f0106075 <sched_run_all>

	return 0 ;
f010324f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103254:	c9                   	leave  
f0103255:	c3                   	ret    

f0103256 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103256:	55                   	push   %ebp
f0103257:	89 e5                	mov    %esp,%ebp
f0103259:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f010325c:	e8 f3 2b 00 00       	call   f0105e54 <sched_print_all>

	return 0 ;
f0103261:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103266:	c9                   	leave  
f0103267:	c3                   	ret    

f0103268 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103268:	55                   	push   %ebp
f0103269:	89 e5                	mov    %esp,%ebp
f010326b:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f010326e:	e8 97 2e 00 00       	call   f010610a <sched_kill_all>

	return 0 ;
f0103273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103278:	c9                   	leave  
f0103279:	c3                   	ret    

f010327a <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f010327a:	55                   	push   %ebp
f010327b:	89 e5                	mov    %esp,%ebp
f010327d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103280:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103284:	7f 1a                	jg     f01032a0 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103286:	83 ec 0c             	sub    $0xc,%esp
f0103289:	68 70 3e 12 f0       	push   $0xf0123e70
f010328e:	e8 f8 dc ff ff       	call   f0100f8b <cprintf>
f0103293:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103296:	b8 00 00 00 00       	mov    $0x0,%eax
f010329b:	e9 83 00 00 00       	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032a3:	83 c0 04             	add    $0x4,%eax
f01032a6:	8b 00                	mov    (%eax),%eax
f01032a8:	83 ec 04             	sub    $0x4,%esp
f01032ab:	6a 0a                	push   $0xa
f01032ad:	6a 00                	push   $0x0
f01032af:	50                   	push   %eax
f01032b0:	e8 84 c5 01 00       	call   f011f839 <strtol>
f01032b5:	83 c4 10             	add    $0x10,%esp
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032bb:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032bf:	75 20                	jne    f01032e1 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032c1:	83 ec 0c             	sub    $0xc,%esp
f01032c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01032c7:	e8 6e bb 00 00       	call   f010ee3a <setPageReplacmentAlgorithmLRU>
f01032cc:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f01032cf:	83 ec 0c             	sub    $0xc,%esp
f01032d2:	68 d0 3e 12 f0       	push   $0xf0123ed0
f01032d7:	e8 af dc ff ff       	call   f0100f8b <cprintf>
f01032dc:	83 c4 10             	add    $0x10,%esp
f01032df:	eb 3d                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f01032e1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01032e5:	75 20                	jne    f0103307 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032e7:	83 ec 0c             	sub    $0xc,%esp
f01032ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01032ed:	e8 48 bb 00 00       	call   f010ee3a <setPageReplacmentAlgorithmLRU>
f01032f2:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01032f5:	83 ec 0c             	sub    $0xc,%esp
f01032f8:	68 14 3f 12 f0       	push   $0xf0123f14
f01032fd:	e8 89 dc ff ff       	call   f0100f8b <cprintf>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	eb 17                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103307:	83 ec 0c             	sub    $0xc,%esp
f010330a:	68 54 3f 12 f0       	push   $0xf0123f54
f010330f:	e8 77 dc ff ff       	call   f0100f8b <cprintf>
f0103314:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103317:	b8 00 00 00 00       	mov    $0x0,%eax
f010331c:	eb 05                	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f010332b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010332e:	83 c0 04             	add    $0x4,%eax
f0103331:	8b 00                	mov    (%eax),%eax
f0103333:	83 ec 04             	sub    $0x4,%esp
f0103336:	6a 0a                	push   $0xa
f0103338:	6a 00                	push   $0x0
f010333a:	50                   	push   %eax
f010333b:	e8 f9 c4 01 00       	call   f011f839 <strtol>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103346:	83 ec 0c             	sub    $0xc,%esp
f0103349:	ff 75 f4             	pushl  -0xc(%ebp)
f010334c:	e8 5c bb 00 00       	call   f010eead <setPageReplacmentAlgorithmNchanceCLOCK>
f0103351:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103354:	83 ec 0c             	sub    $0xc,%esp
f0103357:	68 a8 3f 12 f0       	push   $0xf0123fa8
f010335c:	e8 2a dc ff ff       	call   f0100f8b <cprintf>
f0103361:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103364:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103369:	c9                   	leave  
f010336a:	c3                   	ret    

f010336b <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010336b:	55                   	push   %ebp
f010336c:	89 e5                	mov    %esp,%ebp
f010336e:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103371:	e8 f7 ba 00 00       	call   f010ee6d <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103376:	83 ec 0c             	sub    $0xc,%esp
f0103379:	68 dc 3f 12 f0       	push   $0xf0123fdc
f010337e:	e8 08 dc ff ff       	call   f0100f8b <cprintf>
f0103383:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010338b:	c9                   	leave  
f010338c:	c3                   	ret    

f010338d <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010338d:	55                   	push   %ebp
f010338e:	89 e5                	mov    %esp,%ebp
f0103390:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103393:	e8 e5 ba 00 00       	call   f010ee7d <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103398:	83 ec 0c             	sub    $0xc,%esp
f010339b:	68 08 40 12 f0       	push   $0xf0124008
f01033a0:	e8 e6 db ff ff       	call   f0100f8b <cprintf>
f01033a5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033ad:	c9                   	leave  
f01033ae:	c3                   	ret    

f01033af <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033af:	55                   	push   %ebp
f01033b0:	89 e5                	mov    %esp,%ebp
f01033b2:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033b5:	e8 d3 ba 00 00       	call   f010ee8d <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033ba:	83 ec 0c             	sub    $0xc,%esp
f01033bd:	68 30 40 12 f0       	push   $0xf0124030
f01033c2:	e8 c4 db ff ff       	call   f0100f8b <cprintf>
f01033c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033cf:	c9                   	leave  
f01033d0:	c3                   	ret    

f01033d1 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01033d1:	55                   	push   %ebp
f01033d2:	89 e5                	mov    %esp,%ebp
f01033d4:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01033d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033da:	83 c0 04             	add    $0x4,%eax
f01033dd:	8b 00                	mov    (%eax),%eax
f01033df:	83 ec 04             	sub    $0x4,%esp
f01033e2:	6a 0a                	push   $0xa
f01033e4:	6a 00                	push   $0x0
f01033e6:	50                   	push   %eax
f01033e7:	e8 4d c4 01 00       	call   f011f839 <strtol>
f01033ec:	83 c4 10             	add    $0x10,%esp
f01033ef:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01033f2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033f6:	83 ec 0c             	sub    $0xc,%esp
f01033f9:	50                   	push   %eax
f01033fa:	e8 a8 35 00 00       	call   f01069a7 <sched_init_RR>
f01033ff:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103402:	a1 84 b6 6b f0       	mov    0xf06bb684,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 64 40 12 f0       	push   $0xf0124064
f0103415:	e8 71 db ff ff       	call   f0100f8b <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103422:	c9                   	leave  
f0103423:	c3                   	ret    

f0103424 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103424:	55                   	push   %ebp
f0103425:	89 e5                	mov    %esp,%ebp
f0103427:	53                   	push   %ebx
f0103428:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010342e:	83 c0 04             	add    $0x4,%eax
f0103431:	8b 00                	mov    (%eax),%eax
f0103433:	83 ec 04             	sub    $0x4,%esp
f0103436:	6a 0a                	push   $0xa
f0103438:	6a 00                	push   $0x0
f010343a:	50                   	push   %eax
f010343b:	e8 f9 c3 01 00       	call   f011f839 <strtol>
f0103440:	83 c4 10             	add    $0x10,%esp
f0103443:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103446:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010344d:	eb 2e                	jmp    f010347d <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f010344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103452:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103458:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010345f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103462:	01 d0                	add    %edx,%eax
f0103464:	8b 00                	mov    (%eax),%eax
f0103466:	83 ec 04             	sub    $0x4,%esp
f0103469:	6a 0a                	push   $0xa
f010346b:	6a 00                	push   $0x0
f010346d:	50                   	push   %eax
f010346e:	e8 c6 c3 01 00       	call   f011f839 <strtol>
f0103473:	83 c4 10             	add    $0x10,%esp
f0103476:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347a:	ff 45 f4             	incl   -0xc(%ebp)
f010347d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103480:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103483:	7c ca                	jl     f010344f <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103485:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103489:	83 ec 08             	sub    $0x8,%esp
f010348c:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f010348f:	52                   	push   %edx
f0103490:	50                   	push   %eax
f0103491:	e8 bf 35 00 00       	call   f0106a55 <sched_init_MLFQ>
f0103496:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103499:	83 ec 0c             	sub    $0xc,%esp
f010349c:	68 9c 40 12 f0       	push   $0xf012409c
f01034a1:	e8 e5 da ff ff       	call   f0100f8b <cprintf>
f01034a6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034b0:	eb 24                	jmp    f01034d6 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034b2:	8b 15 84 b6 6b f0    	mov    0xf06bb684,%edx
f01034b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034bb:	01 d0                	add    %edx,%eax
f01034bd:	8a 00                	mov    (%eax),%al
f01034bf:	0f b6 c0             	movzbl %al,%eax
f01034c2:	83 ec 08             	sub    $0x8,%esp
f01034c5:	50                   	push   %eax
f01034c6:	68 c9 40 12 f0       	push   $0xf01240c9
f01034cb:	e8 bb da ff ff       	call   f0100f8b <cprintf>
f01034d0:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034d3:	ff 45 f0             	incl   -0x10(%ebp)
f01034d6:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f01034db:	0f b6 c0             	movzbl %al,%eax
f01034de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034e1:	7f cf                	jg     f01034b2 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01034e3:	83 ec 0c             	sub    $0xc,%esp
f01034e6:	68 4d 3a 12 f0       	push   $0xf0123a4d
f01034eb:	e8 9b da ff ff       	call   f0100f8b <cprintf>
f01034f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01034fb:	c9                   	leave  
f01034fc:	c3                   	ret    

f01034fd <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 0a                	push   $0xa
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 21 c3 01 00       	call   f011f839 <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f010351e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103521:	83 c0 08             	add    $0x8,%eax
f0103524:	8b 00                	mov    (%eax),%eax
f0103526:	83 ec 04             	sub    $0x4,%esp
f0103529:	6a 0a                	push   $0xa
f010352b:	6a 00                	push   $0x0
f010352d:	50                   	push   %eax
f010352e:	e8 06 c3 01 00       	call   f011f839 <strtol>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103539:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010353d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103541:	83 ec 08             	sub    $0x8,%esp
f0103544:	52                   	push   %edx
f0103545:	50                   	push   %eax
f0103546:	e8 32 35 00 00       	call   f0106a7d <sched_init_BSD>
f010354b:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f010354e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103552:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103556:	83 ec 04             	sub    $0x4,%esp
f0103559:	52                   	push   %edx
f010355a:	50                   	push   %eax
f010355b:	68 d0 40 12 f0       	push   $0xf01240d0
f0103560:	e8 26 da ff ff       	call   f0100f8b <cprintf>
f0103565:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103568:	83 ec 0c             	sub    $0xc,%esp
f010356b:	68 4d 3a 12 f0       	push   $0xf0123a4d
f0103570:	e8 16 da ff ff       	call   f0100f8b <cprintf>
f0103575:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103578:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010357d:	c9                   	leave  
f010357e:	c3                   	ret    

f010357f <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f010357f:	55                   	push   %ebp
f0103580:	89 e5                	mov    %esp,%ebp
f0103582:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103585:	e8 6d 31 00 00       	call   f01066f7 <isSchedMethodMLFQ>
f010358a:	85 c0                	test   %eax,%eax
f010358c:	74 5c                	je     f01035ea <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010358e:	83 ec 0c             	sub    $0xc,%esp
f0103591:	68 0c 41 12 f0       	push   $0xf012410c
f0103596:	e8 f0 d9 ff ff       	call   f0100f8b <cprintf>
f010359b:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010359e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035a5:	eb 24                	jmp    f01035cb <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035a7:	8b 15 84 b6 6b f0    	mov    0xf06bb684,%edx
f01035ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035b0:	01 d0                	add    %edx,%eax
f01035b2:	8a 00                	mov    (%eax),%al
f01035b4:	0f b6 c0             	movzbl %al,%eax
f01035b7:	83 ec 08             	sub    $0x8,%esp
f01035ba:	50                   	push   %eax
f01035bb:	68 c9 40 12 f0       	push   $0xf01240c9
f01035c0:	e8 c6 d9 ff ff       	call   f0100f8b <cprintf>
f01035c5:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035c8:	ff 45 f4             	incl   -0xc(%ebp)
f01035cb:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f01035d0:	0f b6 c0             	movzbl %al,%eax
f01035d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01035d6:	7f cf                	jg     f01035a7 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f01035d8:	83 ec 0c             	sub    $0xc,%esp
f01035db:	68 4d 3a 12 f0       	push   $0xf0123a4d
f01035e0:	e8 a6 d9 ff ff       	call   f0100f8b <cprintf>
f01035e5:	83 c4 10             	add    $0x10,%esp
f01035e8:	eb 65                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f01035ea:	e8 ee 30 00 00       	call   f01066dd <isSchedMethodRR>
f01035ef:	85 c0                	test   %eax,%eax
f01035f1:	74 1d                	je     f0103610 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f01035f3:	a1 84 b6 6b f0       	mov    0xf06bb684,%eax
f01035f8:	8a 00                	mov    (%eax),%al
f01035fa:	0f b6 c0             	movzbl %al,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	50                   	push   %eax
f0103601:	68 40 41 12 f0       	push   $0xf0124140
f0103606:	e8 80 d9 ff ff       	call   f0100f8b <cprintf>
f010360b:	83 c4 10             	add    $0x10,%esp
f010360e:	eb 3f                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103610:	e8 fd 30 00 00       	call   f0106712 <isSchedMethodBSD>
f0103615:	85 c0                	test   %eax,%eax
f0103617:	74 26                	je     f010363f <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103619:	a1 84 b6 6b f0       	mov    0xf06bb684,%eax
f010361e:	8a 00                	mov    (%eax),%al
f0103620:	0f b6 d0             	movzbl %al,%edx
f0103623:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f0103628:	0f b6 c0             	movzbl %al,%eax
f010362b:	83 ec 04             	sub    $0x4,%esp
f010362e:	52                   	push   %edx
f010362f:	50                   	push   %eax
f0103630:	68 d0 40 12 f0       	push   $0xf01240d0
f0103635:	e8 51 d9 ff ff       	call   f0100f8b <cprintf>
f010363a:	83 c4 10             	add    $0x10,%esp
f010363d:	eb 10                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f010363f:	83 ec 0c             	sub    $0xc,%esp
f0103642:	68 7c 41 12 f0       	push   $0xf012417c
f0103647:	e8 3f d9 ff ff       	call   f0100f8b <cprintf>
f010364c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010364f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103654:	c9                   	leave  
f0103655:	c3                   	ret    

f0103656 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f0103656:	55                   	push   %ebp
f0103657:	89 e5                	mov    %esp,%ebp
f0103659:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f010365c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010365f:	83 c0 04             	add    $0x4,%eax
f0103662:	8b 00                	mov    (%eax),%eax
f0103664:	83 ec 04             	sub    $0x4,%esp
f0103667:	6a 0a                	push   $0xa
f0103669:	6a 00                	push   $0x0
f010366b:	50                   	push   %eax
f010366c:	e8 c8 c1 01 00       	call   f011f839 <strtol>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010367a:	0f b6 c0             	movzbl %al,%eax
f010367d:	83 ec 0c             	sub    $0xc,%esp
f0103680:	50                   	push   %eax
f0103681:	e8 a7 af 01 00       	call   f011e62d <chksch>
f0103686:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010368d:	75 12                	jne    f01036a1 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	68 a4 41 12 f0       	push   $0xf01241a4
f0103697:	e8 ef d8 ff ff       	call   f0100f8b <cprintf>
f010369c:	83 c4 10             	add    $0x10,%esp
f010369f:	eb 16                	jmp    f01036b7 <command_sch_test+0x61>
	else if (status == 1)
f01036a1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036a5:	75 10                	jne    f01036b7 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036a7:	83 ec 0c             	sub    $0xc,%esp
f01036aa:	68 cc 41 12 f0       	push   $0xf01241cc
f01036af:	e8 d7 d8 ff ff       	call   f0100f8b <cprintf>
f01036b4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036bc:	c9                   	leave  
f01036bd:	c3                   	ret    

f01036be <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036be:	55                   	push   %ebp
f01036bf:	89 e5                	mov    %esp,%ebp
f01036c1:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036c4:	e8 12 b8 00 00       	call   f010eedb <isPageReplacmentAlgorithmCLOCK>
f01036c9:	85 c0                	test   %eax,%eax
f01036cb:	74 15                	je     f01036e2 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f01036cd:	83 ec 0c             	sub    $0xc,%esp
f01036d0:	68 f0 41 12 f0       	push   $0xf01241f0
f01036d5:	e8 b1 d8 ff ff       	call   f0100f8b <cprintf>
f01036da:	83 c4 10             	add    $0x10,%esp
f01036dd:	e9 8c 00 00 00       	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	6a 01                	push   $0x1
f01036e7:	e8 d9 b7 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f01036ec:	83 c4 10             	add    $0x10,%esp
f01036ef:	85 c0                	test   %eax,%eax
f01036f1:	74 12                	je     f0103705 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f01036f3:	83 ec 0c             	sub    $0xc,%esp
f01036f6:	68 18 42 12 f0       	push   $0xf0124218
f01036fb:	e8 8b d8 ff ff       	call   f0100f8b <cprintf>
f0103700:	83 c4 10             	add    $0x10,%esp
f0103703:	eb 69                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103705:	83 ec 0c             	sub    $0xc,%esp
f0103708:	6a 02                	push   $0x2
f010370a:	e8 b6 b7 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f010370f:	83 c4 10             	add    $0x10,%esp
f0103712:	85 c0                	test   %eax,%eax
f0103714:	74 12                	je     f0103728 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103716:	83 ec 0c             	sub    $0xc,%esp
f0103719:	68 58 42 12 f0       	push   $0xf0124258
f010371e:	e8 68 d8 ff ff       	call   f0100f8b <cprintf>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	eb 46                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103728:	e8 c9 b7 00 00       	call   f010eef6 <isPageReplacmentAlgorithmFIFO>
f010372d:	85 c0                	test   %eax,%eax
f010372f:	74 12                	je     f0103743 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103731:	83 ec 0c             	sub    $0xc,%esp
f0103734:	68 94 42 12 f0       	push   $0xf0124294
f0103739:	e8 4d d8 ff ff       	call   f0100f8b <cprintf>
f010373e:	83 c4 10             	add    $0x10,%esp
f0103741:	eb 2b                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103743:	e8 c9 b7 00 00       	call   f010ef11 <isPageReplacmentAlgorithmModifiedCLOCK>
f0103748:	85 c0                	test   %eax,%eax
f010374a:	74 12                	je     f010375e <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010374c:	83 ec 0c             	sub    $0xc,%esp
f010374f:	68 b8 42 12 f0       	push   $0xf01242b8
f0103754:	e8 32 d8 ff ff       	call   f0100f8b <cprintf>
f0103759:	83 c4 10             	add    $0x10,%esp
f010375c:	eb 10                	jmp    f010376e <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f010375e:	83 ec 0c             	sub    $0xc,%esp
f0103761:	68 e8 42 12 f0       	push   $0xf01242e8
f0103766:	e8 20 d8 ff ff       	call   f0100f8b <cprintf>
f010376b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010376e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103773:	c9                   	leave  
f0103774:	c3                   	ret    

f0103775 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103775:	55                   	push   %ebp
f0103776:	89 e5                	mov    %esp,%ebp
f0103778:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010377b:	e8 2f ee ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103780:	83 ec 0c             	sub    $0xc,%esp
f0103783:	68 14 43 12 f0       	push   $0xf0124314
f0103788:	e8 fe d7 ff ff       	call   f0100f8b <cprintf>
f010378d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103795:	c9                   	leave  
f0103796:	c3                   	ret    

f0103797 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103797:	55                   	push   %ebp
f0103798:	89 e5                	mov    %esp,%ebp
f010379a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010379d:	e8 1d ee ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037a2:	83 ec 0c             	sub    $0xc,%esp
f01037a5:	68 44 43 12 f0       	push   $0xf0124344
f01037aa:	e8 dc d7 ff ff       	call   f0100f8b <cprintf>
f01037af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037b7:	c9                   	leave  
f01037b8:	c3                   	ret    

f01037b9 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037b9:	55                   	push   %ebp
f01037ba:	89 e5                	mov    %esp,%ebp
f01037bc:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037bf:	e8 0b ee ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037c4:	83 ec 0c             	sub    $0xc,%esp
f01037c7:	68 74 43 12 f0       	push   $0xf0124374
f01037cc:	e8 ba d7 ff ff       	call   f0100f8b <cprintf>
f01037d1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037d9:	c9                   	leave  
f01037da:	c3                   	ret    

f01037db <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01037db:	55                   	push   %ebp
f01037dc:	89 e5                	mov    %esp,%ebp
f01037de:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01037e1:	e8 f9 ed ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01037e6:	83 ec 0c             	sub    $0xc,%esp
f01037e9:	68 a4 43 12 f0       	push   $0xf01243a4
f01037ee:	e8 98 d7 ff ff       	call   f0100f8b <cprintf>
f01037f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037fb:	c9                   	leave  
f01037fc:	c3                   	ret    

f01037fd <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01037fd:	55                   	push   %ebp
f01037fe:	89 e5                	mov    %esp,%ebp
f0103800:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103803:	e8 e7 ed ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 d4 43 12 f0       	push   $0xf01243d4
f0103814:	e8 72 d7 ff ff       	call   f0100f8b <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 61                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010381e:	e8 e1 ed ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 00 44 12 f0       	push   $0xf0124400
f010382f:	e8 57 d7 ff ff       	call   f0100f8b <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 46                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103839:	e8 db ed ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f010383e:	84 c0                	test   %al,%al
f0103840:	74 12                	je     f0103854 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103842:	83 ec 0c             	sub    $0xc,%esp
f0103845:	68 2c 44 12 f0       	push   $0xf012442c
f010384a:	e8 3c d7 ff ff       	call   f0100f8b <cprintf>
f010384f:	83 c4 10             	add    $0x10,%esp
f0103852:	eb 2b                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103854:	e8 d5 ed ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103859:	84 c0                	test   %al,%al
f010385b:	74 12                	je     f010386f <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f010385d:	83 ec 0c             	sub    $0xc,%esp
f0103860:	68 58 44 12 f0       	push   $0xf0124458
f0103865:	e8 21 d7 ff ff       	call   f0100f8b <cprintf>
f010386a:	83 c4 10             	add    $0x10,%esp
f010386d:	eb 10                	jmp    f010387f <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f010386f:	83 ec 0c             	sub    $0xc,%esp
f0103872:	68 84 44 12 f0       	push   $0xf0124484
f0103877:	e8 0f d7 ff ff       	call   f0100f8b <cprintf>
f010387c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010387f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103884:	c9                   	leave  
f0103885:	c3                   	ret    

f0103886 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103886:	55                   	push   %ebp
f0103887:	89 e5                	mov    %esp,%ebp
f0103889:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f010388c:	e8 66 ec ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 b0 44 12 f0       	push   $0xf01244b0
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038a6:	c9                   	leave  
f01038a7:	c3                   	ret    

f01038a8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038a8:	55                   	push   %ebp
f01038a9:	89 e5                	mov    %esp,%ebp
f01038ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038ae:	e8 54 ec ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038b3:	83 ec 0c             	sub    $0xc,%esp
f01038b6:	68 b0 44 12 f0       	push   $0xf01244b0
f01038bb:	e8 cb d6 ff ff       	call   f0100f8b <cprintf>
f01038c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038c8:	c9                   	leave  
f01038c9:	c3                   	ret    

f01038ca <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01038ca:	55                   	push   %ebp
f01038cb:	89 e5                	mov    %esp,%ebp
f01038cd:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f01038d0:	e8 42 ec ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 e4 44 12 f0       	push   $0xf01244e4
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ea:	c9                   	leave  
f01038eb:	c3                   	ret    

f01038ec <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01038ec:	55                   	push   %ebp
f01038ed:	89 e5                	mov    %esp,%ebp
f01038ef:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f01038f2:	e8 30 ec ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f01038f7:	83 ec 0c             	sub    $0xc,%esp
f01038fa:	68 14 45 12 f0       	push   $0xf0124514
f01038ff:	e8 87 d6 ff ff       	call   f0100f8b <cprintf>
f0103904:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103907:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390c:	c9                   	leave  
f010390d:	c3                   	ret    

f010390e <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010390e:	55                   	push   %ebp
f010390f:	89 e5                	mov    %esp,%ebp
f0103911:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103914:	e8 1e ec ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103919:	83 ec 0c             	sub    $0xc,%esp
f010391c:	68 44 45 12 f0       	push   $0xf0124544
f0103921:	e8 65 d6 ff ff       	call   f0100f8b <cprintf>
f0103926:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103929:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392e:	c9                   	leave  
f010392f:	c3                   	ret    

f0103930 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103930:	55                   	push   %ebp
f0103931:	89 e5                	mov    %esp,%ebp
f0103933:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103936:	e8 0c ec ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f010393b:	84 c0                	test   %al,%al
f010393d:	74 12                	je     f0103951 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 78 45 12 f0       	push   $0xf0124578
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 7c                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103951:	e8 05 ec ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103956:	84 c0                	test   %al,%al
f0103958:	74 12                	je     f010396c <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010395a:	83 ec 0c             	sub    $0xc,%esp
f010395d:	68 b4 45 12 f0       	push   $0xf01245b4
f0103962:	e8 24 d6 ff ff       	call   f0100f8b <cprintf>
f0103967:	83 c4 10             	add    $0x10,%esp
f010396a:	eb 61                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f010396c:	e8 ff eb ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103971:	84 c0                	test   %al,%al
f0103973:	74 12                	je     f0103987 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103975:	83 ec 0c             	sub    $0xc,%esp
f0103978:	68 e4 45 12 f0       	push   $0xf01245e4
f010397d:	e8 09 d6 ff ff       	call   f0100f8b <cprintf>
f0103982:	83 c4 10             	add    $0x10,%esp
f0103985:	eb 46                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103987:	e8 f9 eb ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f010398c:	84 c0                	test   %al,%al
f010398e:	74 12                	je     f01039a2 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103990:	83 ec 0c             	sub    $0xc,%esp
f0103993:	68 10 46 12 f0       	push   $0xf0124610
f0103998:	e8 ee d5 ff ff       	call   f0100f8b <cprintf>
f010399d:	83 c4 10             	add    $0x10,%esp
f01039a0:	eb 2b                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039a2:	e8 f3 eb ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f01039a7:	84 c0                	test   %al,%al
f01039a9:	74 12                	je     f01039bd <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039ab:	83 ec 0c             	sub    $0xc,%esp
f01039ae:	68 3c 46 12 f0       	push   $0xf012463c
f01039b3:	e8 d3 d5 ff ff       	call   f0100f8b <cprintf>
f01039b8:	83 c4 10             	add    $0x10,%esp
f01039bb:	eb 10                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	68 6c 46 12 f0       	push   $0xf012466c
f01039c5:	e8 c1 d5 ff ff       	call   f0100f8b <cprintf>
f01039ca:	83 c4 10             	add    $0x10,%esp

	return 0;
f01039cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039d2:	c9                   	leave  
f01039d3:	c3                   	ret    

f01039d4 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f01039d4:	55                   	push   %ebp
f01039d5:	89 e5                	mov    %esp,%ebp
f01039d7:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039da:	e8 a9 b5 00 00       	call   f010ef88 <isBufferingEnabled>
f01039df:	84 c0                	test   %al,%al
f01039e1:	75 12                	jne    f01039f5 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01039e3:	83 ec 0c             	sub    $0xc,%esp
f01039e6:	68 9c 46 12 f0       	push   $0xf012469c
f01039eb:	e8 9b d5 ff ff       	call   f0100f8b <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
f01039f3:	eb 1d                	jmp    f0103a12 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f01039f5:	83 ec 0c             	sub    $0xc,%esp
f01039f8:	6a 00                	push   $0x0
f01039fa:	e8 63 b5 00 00       	call   f010ef62 <enableModifiedBuffer>
f01039ff:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a02:	83 ec 0c             	sub    $0xc,%esp
f0103a05:	68 d8 46 12 f0       	push   $0xf01246d8
f0103a0a:	e8 7c d5 ff ff       	call   f0100f8b <cprintf>
f0103a0f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a17:	c9                   	leave  
f0103a18:	c3                   	ret    

f0103a19 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a19:	55                   	push   %ebp
f0103a1a:	89 e5                	mov    %esp,%ebp
f0103a1c:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a1f:	e8 64 b5 00 00       	call   f010ef88 <isBufferingEnabled>
f0103a24:	84 c0                	test   %al,%al
f0103a26:	75 12                	jne    f0103a3a <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a28:	83 ec 0c             	sub    $0xc,%esp
f0103a2b:	68 9c 46 12 f0       	push   $0xf012469c
f0103a30:	e8 56 d5 ff ff       	call   f0100f8b <cprintf>
f0103a35:	83 c4 10             	add    $0x10,%esp
f0103a38:	eb 1d                	jmp    f0103a57 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a3a:	83 ec 0c             	sub    $0xc,%esp
f0103a3d:	6a 01                	push   $0x1
f0103a3f:	e8 1e b5 00 00       	call   f010ef62 <enableModifiedBuffer>
f0103a44:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a47:	83 ec 0c             	sub    $0xc,%esp
f0103a4a:	68 fc 46 12 f0       	push   $0xf01246fc
f0103a4f:	e8 37 d5 ff ff       	call   f0100f8b <cprintf>
f0103a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a57:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a5c:	c9                   	leave  
f0103a5d:	c3                   	ret    

f0103a5e <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a5e:	55                   	push   %ebp
f0103a5f:	89 e5                	mov    %esp,%ebp
f0103a61:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	6a 00                	push   $0x0
f0103a69:	e8 0c b5 00 00       	call   f010ef7a <enableBuffering>
f0103a6e:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 00                	push   $0x0
f0103a76:	e8 e7 b4 00 00       	call   f010ef62 <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 1c 47 12 f0       	push   $0xf012471c
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 01                	push   $0x1
f0103aa0:	e8 d5 b4 00 00       	call   f010ef7a <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 01                	push   $0x1
f0103aad:	e8 b0 b4 00 00       	call   f010ef62 <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ab5:	e8 e6 b4 00 00       	call   f010efa0 <getModifiedBufferLength>
f0103aba:	85 c0                	test   %eax,%eax
f0103abc:	75 59                	jne    f0103b17 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103abe:	83 ec 0c             	sub    $0xc,%esp
f0103ac1:	68 38 47 12 f0       	push   $0xf0124738
f0103ac6:	e8 c0 d4 ff ff       	call   f0100f8b <cprintf>
f0103acb:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103ace:	83 ec 08             	sub    $0x8,%esp
f0103ad1:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ad4:	50                   	push   %eax
f0103ad5:	68 68 47 12 f0       	push   $0xf0124768
f0103ada:	e8 f2 b7 01 00       	call   f011f2d1 <readline>
f0103adf:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103ae2:	83 ec 04             	sub    $0x4,%esp
f0103ae5:	6a 0a                	push   $0xa
f0103ae7:	6a 00                	push   $0x0
f0103ae9:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103aec:	50                   	push   %eax
f0103aed:	e8 47 bd 01 00       	call   f011f839 <strtol>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	50                   	push   %eax
f0103af9:	e8 94 b4 00 00       	call   f010ef92 <setModifiedBufferLength>
f0103afe:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b01:	e8 9a b4 00 00       	call   f010efa0 <getModifiedBufferLength>
f0103b06:	83 ec 08             	sub    $0x8,%esp
f0103b09:	50                   	push   %eax
f0103b0a:	68 94 47 12 f0       	push   $0xf0124794
f0103b0f:	e8 77 d4 ff ff       	call   f0100f8b <cprintf>
f0103b14:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b17:	83 ec 0c             	sub    $0xc,%esp
f0103b1a:	68 b9 47 12 f0       	push   $0xf01247b9
f0103b1f:	e8 67 d4 ff ff       	call   f0100f8b <cprintf>
f0103b24:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b2c:	c9                   	leave  
f0103b2d:	c3                   	ret    

f0103b2e <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b2e:	55                   	push   %ebp
f0103b2f:	89 e5                	mov    %esp,%ebp
f0103b31:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b34:	e8 4f b4 00 00       	call   f010ef88 <isBufferingEnabled>
f0103b39:	84 c0                	test   %al,%al
f0103b3b:	75 12                	jne    f0103b4f <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b3d:	83 ec 0c             	sub    $0xc,%esp
f0103b40:	68 d4 47 12 f0       	push   $0xf01247d4
f0103b45:	e8 41 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	eb 19                	jmp    f0103b68 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b4f:	e8 1c b4 00 00       	call   f010ef70 <isModifiedBufferEnabled>
f0103b54:	84 c0                	test   %al,%al
f0103b56:	75 10                	jne    f0103b68 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b58:	83 ec 0c             	sub    $0xc,%esp
f0103b5b:	68 24 48 12 f0       	push   $0xf0124824
f0103b60:	e8 26 d4 ff ff       	call   f0100f8b <cprintf>
f0103b65:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b6b:	83 c0 04             	add    $0x4,%eax
f0103b6e:	8b 00                	mov    (%eax),%eax
f0103b70:	83 ec 04             	sub    $0x4,%esp
f0103b73:	6a 0a                	push   $0xa
f0103b75:	6a 00                	push   $0x0
f0103b77:	50                   	push   %eax
f0103b78:	e8 bc bc 01 00       	call   f011f839 <strtol>
f0103b7d:	83 c4 10             	add    $0x10,%esp
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	50                   	push   %eax
f0103b84:	e8 09 b4 00 00       	call   f010ef92 <setModifiedBufferLength>
f0103b89:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b8c:	e8 0f b4 00 00       	call   f010efa0 <getModifiedBufferLength>
f0103b91:	83 ec 08             	sub    $0x8,%esp
f0103b94:	50                   	push   %eax
f0103b95:	68 94 47 12 f0       	push   $0xf0124794
f0103b9a:	e8 ec d3 ff ff       	call   f0100f8b <cprintf>
f0103b9f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ba2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba7:	c9                   	leave  
f0103ba8:	c3                   	ret    

f0103ba9 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103ba9:	55                   	push   %ebp
f0103baa:	89 e5                	mov    %esp,%ebp
f0103bac:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103baf:	e8 d4 b3 00 00       	call   f010ef88 <isBufferingEnabled>
f0103bb4:	84 c0                	test   %al,%al
f0103bb6:	75 12                	jne    f0103bca <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	68 d4 47 12 f0       	push   $0xf01247d4
f0103bc0:	e8 c6 d3 ff ff       	call   f0100f8b <cprintf>
f0103bc5:	83 c4 10             	add    $0x10,%esp
f0103bc8:	eb 19                	jmp    f0103be3 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103bca:	e8 a1 b3 00 00       	call   f010ef70 <isModifiedBufferEnabled>
f0103bcf:	84 c0                	test   %al,%al
f0103bd1:	75 10                	jne    f0103be3 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	68 24 48 12 f0       	push   $0xf0124824
f0103bdb:	e8 ab d3 ff ff       	call   f0100f8b <cprintf>
f0103be0:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103be3:	e8 b8 b3 00 00       	call   f010efa0 <getModifiedBufferLength>
f0103be8:	83 ec 08             	sub    $0x8,%esp
f0103beb:	50                   	push   %eax
f0103bec:	68 6a 48 12 f0       	push   $0xf012486a
f0103bf1:	e8 95 d3 ff ff       	call   f0100f8b <cprintf>
f0103bf6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bfe:	c9                   	leave  
f0103bff:	c3                   	ret    

f0103c00 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c00:	55                   	push   %ebp
f0103c01:	89 e5                	mov    %esp,%ebp
f0103c03:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c06:	83 ec 08             	sub    $0x8,%esp
f0103c09:	ff 75 0c             	pushl  0xc(%ebp)
f0103c0c:	ff 75 08             	pushl  0x8(%ebp)
f0103c0f:	e8 eb be 00 00       	call   f010faff <tst_handler>
f0103c14:	83 c4 10             	add    $0x10,%esp
}
f0103c17:	c9                   	leave  
f0103c18:	c3                   	ret    

f0103c19 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c19:	55                   	push   %ebp
f0103c1a:	89 e5                	mov    %esp,%ebp
f0103c1c:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c22:	05 00 14 00 00       	add    $0x1400,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c2d:	83 ec 04             	sub    $0x4,%esp
f0103c30:	6a 08                	push   $0x8
f0103c32:	ff 75 0c             	pushl  0xc(%ebp)
f0103c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c38:	e8 84 c0 01 00       	call   f011fcc1 <ide_read>
f0103c3d:	83 c4 10             	add    $0x10,%esp
f0103c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c46:	c9                   	leave  
f0103c47:	c3                   	ret    

f0103c48 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c48:	55                   	push   %ebp
f0103c49:	89 e5                	mov    %esp,%ebp
f0103c4b:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c51:	05 00 14 00 00       	add    $0x1400,%eax
f0103c56:	c1 e0 03             	shl    $0x3,%eax
f0103c59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c5c:	83 ec 04             	sub    $0x4,%esp
f0103c5f:	6a 08                	push   $0x8
f0103c61:	ff 75 0c             	pushl  0xc(%ebp)
f0103c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c67:	e8 95 c1 01 00       	call   f011fe01 <ide_write>
f0103c6c:	83 c4 10             	add    $0x10,%esp
f0103c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103c72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103c76:	74 14                	je     f0103c8c <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103c78:	83 ec 04             	sub    $0x4,%esp
f0103c7b:	68 88 48 12 f0       	push   $0xf0124888
f0103c80:	6a 2f                	push   $0x2f
f0103c82:	68 9f 48 12 f0       	push   $0xf012489f
f0103c87:	e8 ad c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c8f:	c9                   	leave  
f0103c90:	c3                   	ret    

f0103c91 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103c91:	55                   	push   %ebp
f0103c92:	89 e5                	mov    %esp,%ebp
f0103c94:	53                   	push   %ebx
f0103c95:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103c98:	c7 05 80 b9 6b f0 00 	movl   $0x0,0xf06bb980
f0103c9f:	00 00 00 
f0103ca2:	c7 05 84 b9 6b f0 00 	movl   $0x0,0xf06bb984
f0103ca9:	00 00 00 
f0103cac:	c7 05 8c b9 6b f0 00 	movl   $0x0,0xf06bb98c
f0103cb3:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cbd:	e9 e8 00 00 00       	jmp    f0103daa <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cc2:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ccb:	89 d0                	mov    %edx,%eax
f0103ccd:	01 c0                	add    %eax,%eax
f0103ccf:	01 d0                	add    %edx,%eax
f0103cd1:	c1 e0 03             	shl    $0x3,%eax
f0103cd4:	01 c8                	add    %ecx,%eax
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	50                   	push   %eax
f0103cda:	e8 b8 44 00 00       	call   f0108197 <initialize_frame_info>
f0103cdf:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ce2:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ceb:	89 d0                	mov    %edx,%eax
f0103ced:	01 c0                	add    %eax,%eax
f0103cef:	01 d0                	add    %edx,%eax
f0103cf1:	c1 e0 03             	shl    $0x3,%eax
f0103cf4:	01 c8                	add    %ecx,%eax
f0103cf6:	85 c0                	test   %eax,%eax
f0103cf8:	75 14                	jne    f0103d0e <initialize_disk_page_file+0x7d>
f0103cfa:	83 ec 04             	sub    $0x4,%esp
f0103cfd:	68 bc 48 12 f0       	push   $0xf01248bc
f0103d02:	6a 56                	push   $0x56
f0103d04:	68 9f 48 12 f0       	push   $0xf012489f
f0103d09:	e8 2b c6 ff ff       	call   f0100339 <_panic>
f0103d0e:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103d14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d17:	89 d0                	mov    %edx,%eax
f0103d19:	01 c0                	add    %eax,%eax
f0103d1b:	01 d0                	add    %edx,%eax
f0103d1d:	c1 e0 03             	shl    $0x3,%eax
f0103d20:	01 c8                	add    %ecx,%eax
f0103d22:	8b 15 80 b9 6b f0    	mov    0xf06bb980,%edx
f0103d28:	89 10                	mov    %edx,(%eax)
f0103d2a:	8b 00                	mov    (%eax),%eax
f0103d2c:	85 c0                	test   %eax,%eax
f0103d2e:	74 1f                	je     f0103d4f <initialize_disk_page_file+0xbe>
f0103d30:	8b 15 80 b9 6b f0    	mov    0xf06bb980,%edx
f0103d36:	8b 1d 80 b0 6b f0    	mov    0xf06bb080,%ebx
f0103d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103d3f:	89 c8                	mov    %ecx,%eax
f0103d41:	01 c0                	add    %eax,%eax
f0103d43:	01 c8                	add    %ecx,%eax
f0103d45:	c1 e0 03             	shl    $0x3,%eax
f0103d48:	01 d8                	add    %ebx,%eax
f0103d4a:	89 42 04             	mov    %eax,0x4(%edx)
f0103d4d:	eb 19                	jmp    f0103d68 <initialize_disk_page_file+0xd7>
f0103d4f:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d58:	89 d0                	mov    %edx,%eax
f0103d5a:	01 c0                	add    %eax,%eax
f0103d5c:	01 d0                	add    %edx,%eax
f0103d5e:	c1 e0 03             	shl    $0x3,%eax
f0103d61:	01 c8                	add    %ecx,%eax
f0103d63:	a3 84 b9 6b f0       	mov    %eax,0xf06bb984
f0103d68:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d71:	89 d0                	mov    %edx,%eax
f0103d73:	01 c0                	add    %eax,%eax
f0103d75:	01 d0                	add    %edx,%eax
f0103d77:	c1 e0 03             	shl    $0x3,%eax
f0103d7a:	01 c8                	add    %ecx,%eax
f0103d7c:	a3 80 b9 6b f0       	mov    %eax,0xf06bb980
f0103d81:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103d87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8a:	89 d0                	mov    %edx,%eax
f0103d8c:	01 c0                	add    %eax,%eax
f0103d8e:	01 d0                	add    %edx,%eax
f0103d90:	c1 e0 03             	shl    $0x3,%eax
f0103d93:	01 c8                	add    %ecx,%eax
f0103d95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d9c:	a1 8c b9 6b f0       	mov    0xf06bb98c,%eax
f0103da1:	40                   	inc    %eax
f0103da2:	a3 8c b9 6b f0       	mov    %eax,0xf06bb98c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103da7:	ff 45 f4             	incl   -0xc(%ebp)
f0103daa:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103db1:	0f 8e 0b ff ff ff    	jle    f0103cc2 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103db7:	90                   	nop
f0103db8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103dbb:	c9                   	leave  
f0103dbc:	c3                   	ret    

f0103dbd <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103dbd:	55                   	push   %ebp
f0103dbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103dc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc3:	8b 15 80 b0 6b f0    	mov    0xf06bb080,%edx
f0103dc9:	29 d0                	sub    %edx,%eax
f0103dcb:	c1 f8 03             	sar    $0x3,%eax
f0103dce:	89 c2                	mov    %eax,%edx
f0103dd0:	89 d0                	mov    %edx,%eax
f0103dd2:	c1 e0 02             	shl    $0x2,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 d0                	add    %edx,%eax
f0103ddc:	c1 e0 02             	shl    $0x2,%eax
f0103ddf:	01 d0                	add    %edx,%eax
f0103de1:	89 c1                	mov    %eax,%ecx
f0103de3:	c1 e1 08             	shl    $0x8,%ecx
f0103de6:	01 c8                	add    %ecx,%eax
f0103de8:	89 c1                	mov    %eax,%ecx
f0103dea:	c1 e1 10             	shl    $0x10,%ecx
f0103ded:	01 c8                	add    %ecx,%eax
f0103def:	01 c0                	add    %eax,%eax
f0103df1:	01 d0                	add    %edx,%eax
}
f0103df3:	5d                   	pop    %ebp
f0103df4:	c3                   	ret    

f0103df5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e02:	83 ec 0c             	sub    $0xc,%esp
f0103e05:	68 90 b9 6b f0       	push   $0xf06bb990
f0103e0a:	e8 09 b7 00 00       	call   f010f518 <acquire_spinlock>
f0103e0f:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e12:	a1 80 b9 6b f0       	mov    0xf06bb980,%eax
f0103e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e1e:	75 0c                	jne    f0103e2c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e20:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e27:	e9 a2 00 00 00       	jmp    f0103ece <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e30:	75 14                	jne    f0103e46 <allocate_disk_frame+0x51>
f0103e32:	83 ec 04             	sub    $0x4,%esp
f0103e35:	68 df 48 12 f0       	push   $0xf01248df
f0103e3a:	6a 7b                	push   $0x7b
f0103e3c:	68 9f 48 12 f0       	push   $0xf012489f
f0103e41:	e8 f3 c4 ff ff       	call   f0100339 <_panic>
f0103e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e49:	8b 00                	mov    (%eax),%eax
f0103e4b:	85 c0                	test   %eax,%eax
f0103e4d:	74 10                	je     f0103e5f <allocate_disk_frame+0x6a>
f0103e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e52:	8b 00                	mov    (%eax),%eax
f0103e54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e57:	8b 52 04             	mov    0x4(%edx),%edx
f0103e5a:	89 50 04             	mov    %edx,0x4(%eax)
f0103e5d:	eb 0b                	jmp    f0103e6a <allocate_disk_frame+0x75>
f0103e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e62:	8b 40 04             	mov    0x4(%eax),%eax
f0103e65:	a3 84 b9 6b f0       	mov    %eax,0xf06bb984
f0103e6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e6d:	8b 40 04             	mov    0x4(%eax),%eax
f0103e70:	85 c0                	test   %eax,%eax
f0103e72:	74 0f                	je     f0103e83 <allocate_disk_frame+0x8e>
f0103e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e77:	8b 40 04             	mov    0x4(%eax),%eax
f0103e7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e7d:	8b 12                	mov    (%edx),%edx
f0103e7f:	89 10                	mov    %edx,(%eax)
f0103e81:	eb 0a                	jmp    f0103e8d <allocate_disk_frame+0x98>
f0103e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e86:	8b 00                	mov    (%eax),%eax
f0103e88:	a3 80 b9 6b f0       	mov    %eax,0xf06bb980
f0103e8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea0:	a1 8c b9 6b f0       	mov    0xf06bb98c,%eax
f0103ea5:	48                   	dec    %eax
f0103ea6:	a3 8c b9 6b f0       	mov    %eax,0xf06bb98c
			initialize_frame_info(ptr_frame_info);
f0103eab:	83 ec 0c             	sub    $0xc,%esp
f0103eae:	ff 75 f0             	pushl  -0x10(%ebp)
f0103eb1:	e8 e1 42 00 00       	call   f0108197 <initialize_frame_info>
f0103eb6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103eb9:	83 ec 0c             	sub    $0xc,%esp
f0103ebc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103ebf:	e8 f9 fe ff ff       	call   f0103dbd <to_disk_frame_number>
f0103ec4:	83 c4 10             	add    $0x10,%esp
f0103ec7:	89 c2                	mov    %eax,%edx
f0103ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ecc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ece:	83 ec 0c             	sub    $0xc,%esp
f0103ed1:	68 90 b9 6b f0       	push   $0xf06bb990
f0103ed6:	e8 c4 b6 00 00       	call   f010f59f <release_spinlock>
f0103edb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103ee1:	c9                   	leave  
f0103ee2:	c3                   	ret    

f0103ee3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103ee3:	55                   	push   %ebp
f0103ee4:	89 e5                	mov    %esp,%ebp
f0103ee6:	53                   	push   %ebx
f0103ee7:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103eee:	0f 84 ea 00 00 00    	je     f0103fde <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ef4:	83 ec 0c             	sub    $0xc,%esp
f0103ef7:	68 90 b9 6b f0       	push   $0xf06bb990
f0103efc:	e8 17 b6 00 00       	call   f010f518 <acquire_spinlock>
f0103f01:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f04:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103f0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f0d:	89 d0                	mov    %edx,%eax
f0103f0f:	01 c0                	add    %eax,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	85 c0                	test   %eax,%eax
f0103f1a:	75 17                	jne    f0103f33 <free_disk_frame+0x50>
f0103f1c:	83 ec 04             	sub    $0x4,%esp
f0103f1f:	68 bc 48 12 f0       	push   $0xf01248bc
f0103f24:	68 8e 00 00 00       	push   $0x8e
f0103f29:	68 9f 48 12 f0       	push   $0xf012489f
f0103f2e:	e8 06 c4 ff ff       	call   f0100339 <_panic>
f0103f33:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103f39:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f3c:	89 d0                	mov    %edx,%eax
f0103f3e:	01 c0                	add    %eax,%eax
f0103f40:	01 d0                	add    %edx,%eax
f0103f42:	c1 e0 03             	shl    $0x3,%eax
f0103f45:	01 c8                	add    %ecx,%eax
f0103f47:	8b 15 80 b9 6b f0    	mov    0xf06bb980,%edx
f0103f4d:	89 10                	mov    %edx,(%eax)
f0103f4f:	8b 00                	mov    (%eax),%eax
f0103f51:	85 c0                	test   %eax,%eax
f0103f53:	74 1f                	je     f0103f74 <free_disk_frame+0x91>
f0103f55:	8b 15 80 b9 6b f0    	mov    0xf06bb980,%edx
f0103f5b:	8b 1d 80 b0 6b f0    	mov    0xf06bb080,%ebx
f0103f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f64:	89 c8                	mov    %ecx,%eax
f0103f66:	01 c0                	add    %eax,%eax
f0103f68:	01 c8                	add    %ecx,%eax
f0103f6a:	c1 e0 03             	shl    $0x3,%eax
f0103f6d:	01 d8                	add    %ebx,%eax
f0103f6f:	89 42 04             	mov    %eax,0x4(%edx)
f0103f72:	eb 19                	jmp    f0103f8d <free_disk_frame+0xaa>
f0103f74:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7d:	89 d0                	mov    %edx,%eax
f0103f7f:	01 c0                	add    %eax,%eax
f0103f81:	01 d0                	add    %edx,%eax
f0103f83:	c1 e0 03             	shl    $0x3,%eax
f0103f86:	01 c8                	add    %ecx,%eax
f0103f88:	a3 84 b9 6b f0       	mov    %eax,0xf06bb984
f0103f8d:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103f93:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f96:	89 d0                	mov    %edx,%eax
f0103f98:	01 c0                	add    %eax,%eax
f0103f9a:	01 d0                	add    %edx,%eax
f0103f9c:	c1 e0 03             	shl    $0x3,%eax
f0103f9f:	01 c8                	add    %ecx,%eax
f0103fa1:	a3 80 b9 6b f0       	mov    %eax,0xf06bb980
f0103fa6:	8b 0d 80 b0 6b f0    	mov    0xf06bb080,%ecx
f0103fac:	8b 55 08             	mov    0x8(%ebp),%edx
f0103faf:	89 d0                	mov    %edx,%eax
f0103fb1:	01 c0                	add    %eax,%eax
f0103fb3:	01 d0                	add    %edx,%eax
f0103fb5:	c1 e0 03             	shl    $0x3,%eax
f0103fb8:	01 c8                	add    %ecx,%eax
f0103fba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103fc1:	a1 8c b9 6b f0       	mov    0xf06bb98c,%eax
f0103fc6:	40                   	inc    %eax
f0103fc7:	a3 8c b9 6b f0       	mov    %eax,0xf06bb98c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103fcc:	83 ec 0c             	sub    $0xc,%esp
f0103fcf:	68 90 b9 6b f0       	push   $0xf06bb990
f0103fd4:	e8 c6 b5 00 00       	call   f010f59f <release_spinlock>
f0103fd9:	83 c4 10             	add    $0x10,%esp
f0103fdc:	eb 01                	jmp    f0103fdf <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103fde:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103fdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fe2:	c9                   	leave  
f0103fe3:	c3                   	ret    

f0103fe4 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103fe4:	55                   	push   %ebp
f0103fe5:	89 e5                	mov    %esp,%ebp
f0103fe7:	53                   	push   %ebx
f0103fe8:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fee:	c1 e8 16             	shr    $0x16,%eax
f0103ff1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ffb:	01 d0                	add    %edx,%eax
f0103ffd:	8b 00                	mov    (%eax),%eax
f0103fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104002:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104009:	77 1d                	ja     f0104028 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010400b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104013:	83 ec 0c             	sub    $0xc,%esp
f0104016:	50                   	push   %eax
f0104017:	e8 72 54 00 00       	call   f010948e <kheap_virtual_address>
f010401c:	83 c4 10             	add    $0x10,%esp
f010401f:	89 c2                	mov    %eax,%edx
f0104021:	8b 45 14             	mov    0x14(%ebp),%eax
f0104024:	89 10                	mov    %edx,(%eax)
f0104026:	eb 44                	jmp    f010406c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010402b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104030:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104036:	c1 e8 0c             	shr    $0xc,%eax
f0104039:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010403c:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f0104041:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104044:	72 17                	jb     f010405d <get_disk_page_table+0x79>
f0104046:	ff 75 f0             	pushl  -0x10(%ebp)
f0104049:	68 00 49 12 f0       	push   $0xf0124900
f010404e:	68 9d 00 00 00       	push   $0x9d
f0104053:	68 9f 48 12 f0       	push   $0xf012489f
f0104058:	e8 dc c2 ff ff       	call   f0100339 <_panic>
f010405d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104060:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104065:	89 c2                	mov    %eax,%edx
f0104067:	8b 45 14             	mov    0x14(%ebp),%eax
f010406a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104070:	0f 85 80 00 00 00    	jne    f01040f6 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104076:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010407a:	74 6a                	je     f01040e6 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010407c:	83 ec 0c             	sub    $0xc,%esp
f010407f:	68 00 10 00 00       	push   $0x1000
f0104084:	e8 62 50 00 00       	call   f01090eb <kmalloc>
f0104089:	83 c4 10             	add    $0x10,%esp
f010408c:	89 c2                	mov    %eax,%edx
f010408e:	8b 45 14             	mov    0x14(%ebp),%eax
f0104091:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104093:	8b 45 14             	mov    0x14(%ebp),%eax
f0104096:	8b 00                	mov    (%eax),%eax
f0104098:	85 c0                	test   %eax,%eax
f010409a:	75 07                	jne    f01040a3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010409c:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01040a1:	eb 58                	jmp    f01040fb <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01040a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040a6:	c1 e8 16             	shr    $0x16,%eax
f01040a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01040b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01040b6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040b9:	8b 00                	mov    (%eax),%eax
f01040bb:	83 ec 0c             	sub    $0xc,%esp
f01040be:	50                   	push   %eax
f01040bf:	e8 6d 53 00 00       	call   f0109431 <kheap_physical_address>
f01040c4:	83 c4 10             	add    $0x10,%esp
f01040c7:	83 c8 01             	or     $0x1,%eax
f01040ca:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01040cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01040cf:	8b 00                	mov    (%eax),%eax
f01040d1:	83 ec 04             	sub    $0x4,%esp
f01040d4:	68 00 10 00 00       	push   $0x1000
f01040d9:	6a 00                	push   $0x0
f01040db:	50                   	push   %eax
f01040dc:	e8 e6 b5 01 00       	call   f011f6c7 <memset>
f01040e1:	83 c4 10             	add    $0x10,%esp
f01040e4:	eb 10                	jmp    f01040f6 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01040e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01040ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01040f4:	eb 05                	jmp    f01040fb <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01040f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01040fe:	c9                   	leave  
f01040ff:	c3                   	ret    

f0104100 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104100:	55                   	push   %ebp
f0104101:	89 e5                	mov    %esp,%ebp
f0104103:	83 ec 28             	sub    $0x28,%esp
f0104106:	8b 45 10             	mov    0x10(%ebp),%eax
f0104109:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010410c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104110:	74 72                	je     f0104184 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104112:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411c:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104121:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104124:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104127:	ba 00 00 00 00       	mov    $0x0,%edx
f010412c:	f7 75 f4             	divl   -0xc(%ebp)
f010412f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104132:	29 d0                	sub    %edx,%eax
f0104134:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104137:	73 2f                	jae    f0104168 <pf_add_empty_env_page+0x68>
f0104139:	8b 45 08             	mov    0x8(%ebp),%eax
f010413c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010413f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104144:	29 d0                	sub    %edx,%eax
f0104146:	c1 e0 0c             	shl    $0xc,%eax
f0104149:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010414e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104151:	76 15                	jbe    f0104168 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f010415c:	8d 50 01             	lea    0x1(%eax),%edx
f010415f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104162:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104168:	a1 5c b8 6b f0       	mov    0xf06bb85c,%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	50                   	push   %eax
f0104171:	ff 75 0c             	pushl  0xc(%ebp)
f0104174:	ff 75 08             	pushl  0x8(%ebp)
f0104177:	e8 b5 00 00 00       	call   f0104231 <pf_add_env_page>
f010417c:	83 c4 10             	add    $0x10,%esp
f010417f:	e9 ab 00 00 00       	jmp    f010422f <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104184:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010418b:	76 19                	jbe    f01041a6 <pf_add_empty_env_page+0xa6>
f010418d:	68 30 49 12 f0       	push   $0xf0124930
f0104192:	68 56 49 12 f0       	push   $0xf0124956
f0104197:	68 dc 00 00 00       	push   $0xdc
f010419c:	68 9f 48 12 f0       	push   $0xf012489f
f01041a1:	e8 93 c1 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01041a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a9:	83 e8 80             	sub    $0xffffff80,%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	ff 75 08             	pushl  0x8(%ebp)
f01041b3:	e8 c8 05 00 00       	call   f0104780 <get_disk_page_directory>
f01041b8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01041bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01041be:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01041c4:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01041c7:	52                   	push   %edx
f01041c8:	6a 01                	push   $0x1
f01041ca:	ff 75 0c             	pushl  0xc(%ebp)
f01041cd:	50                   	push   %eax
f01041ce:	e8 11 fe ff ff       	call   f0103fe4 <get_disk_page_table>
f01041d3:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041d9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041dc:	c1 ea 0c             	shr    $0xc,%edx
f01041df:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e5:	c1 e2 02             	shl    $0x2,%edx
f01041e8:	01 d0                	add    %edx,%eax
f01041ea:	8b 00                	mov    (%eax),%eax
f01041ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01041ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01041f2:	85 c0                	test   %eax,%eax
f01041f4:	75 34                	jne    f010422a <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041f6:	83 ec 0c             	sub    $0xc,%esp
f01041f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01041fc:	50                   	push   %eax
f01041fd:	e8 f3 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f0104202:	83 c4 10             	add    $0x10,%esp
f0104205:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104208:	75 07                	jne    f0104211 <pf_add_empty_env_page+0x111>
f010420a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010420f:	eb 1e                	jmp    f010422f <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104214:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104217:	c1 ea 0c             	shr    $0xc,%edx
f010421a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104220:	c1 e2 02             	shl    $0x2,%edx
f0104223:	01 c2                	add    %eax,%edx
f0104225:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104228:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010422a:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010422f:	c9                   	leave  
f0104230:	c3                   	ret    

f0104231 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104231:	55                   	push   %ebp
f0104232:	89 e5                	mov    %esp,%ebp
f0104234:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104237:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010423e:	76 19                	jbe    f0104259 <pf_add_env_page+0x28>
f0104240:	68 30 49 12 f0       	push   $0xf0124930
f0104245:	68 56 49 12 f0       	push   $0xf0124956
f010424a:	68 f1 00 00 00       	push   $0xf1
f010424f:	68 9f 48 12 f0       	push   $0xf012489f
f0104254:	e8 e0 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104259:	8b 45 08             	mov    0x8(%ebp),%eax
f010425c:	83 e8 80             	sub    $0xffffff80,%eax
f010425f:	83 ec 08             	sub    $0x8,%esp
f0104262:	50                   	push   %eax
f0104263:	ff 75 08             	pushl  0x8(%ebp)
f0104266:	e8 15 05 00 00       	call   f0104780 <get_disk_page_directory>
f010426b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010426e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104271:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104277:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010427a:	52                   	push   %edx
f010427b:	6a 01                	push   $0x1
f010427d:	ff 75 0c             	pushl  0xc(%ebp)
f0104280:	50                   	push   %eax
f0104281:	e8 5e fd ff ff       	call   f0103fe4 <get_disk_page_table>
f0104286:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010428c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010428f:	c1 ea 0c             	shr    $0xc,%edx
f0104292:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104298:	c1 e2 02             	shl    $0x2,%edx
f010429b:	01 d0                	add    %edx,%eax
f010429d:	8b 00                	mov    (%eax),%eax
f010429f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01042a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042a5:	85 c0                	test   %eax,%eax
f01042a7:	75 34                	jne    f01042dd <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01042a9:	83 ec 0c             	sub    $0xc,%esp
f01042ac:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01042af:	50                   	push   %eax
f01042b0:	e8 40 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01042b5:	83 c4 10             	add    $0x10,%esp
f01042b8:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042bb:	75 07                	jne    f01042c4 <pf_add_env_page+0x93>
f01042bd:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042c2:	eb 31                	jmp    f01042f5 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042c7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042ca:	c1 ea 0c             	shr    $0xc,%edx
f01042cd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042d3:	c1 e2 02             	shl    $0x2,%edx
f01042d6:	01 c2                	add    %eax,%edx
f01042d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042db:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01042dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042e0:	83 ec 08             	sub    $0x8,%esp
f01042e3:	ff 75 10             	pushl  0x10(%ebp)
f01042e6:	50                   	push   %eax
f01042e7:	e8 5c f9 ff ff       	call   f0103c48 <write_disk_page>
f01042ec:	83 c4 10             	add    $0x10,%esp
f01042ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01042f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01042f5:	c9                   	leave  
f01042f6:	c3                   	ret    

f01042f7 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01042f7:	55                   	push   %ebp
f01042f8:	89 e5                	mov    %esp,%ebp
f01042fa:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01042fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104304:	76 19                	jbe    f010431f <pf_update_env_page+0x28>
f0104306:	68 30 49 12 f0       	push   $0xf0124930
f010430b:	68 56 49 12 f0       	push   $0xf0124956
f0104310:	68 13 01 00 00       	push   $0x113
f0104315:	68 9f 48 12 f0       	push   $0xf012489f
f010431a:	e8 1a c0 ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010431f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104322:	83 e8 80             	sub    $0xffffff80,%eax
f0104325:	83 ec 08             	sub    $0x8,%esp
f0104328:	50                   	push   %eax
f0104329:	ff 75 08             	pushl  0x8(%ebp)
f010432c:	e8 4f 04 00 00       	call   f0104780 <get_disk_page_directory>
f0104331:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104334:	8b 45 08             	mov    0x8(%ebp),%eax
f0104337:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010433d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104340:	52                   	push   %edx
f0104341:	6a 00                	push   $0x0
f0104343:	ff 75 0c             	pushl  0xc(%ebp)
f0104346:	50                   	push   %eax
f0104347:	e8 98 fc ff ff       	call   f0103fe4 <get_disk_page_table>
f010434c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010434f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104352:	85 c0                	test   %eax,%eax
f0104354:	74 29                	je     f010437f <pf_update_env_page+0x88>
f0104356:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104359:	85 c0                	test   %eax,%eax
f010435b:	0f 84 c5 00 00 00    	je     f0104426 <pf_update_env_page+0x12f>
f0104361:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104364:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104367:	c1 ea 0c             	shr    $0xc,%edx
f010436a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104370:	c1 e2 02             	shl    $0x2,%edx
f0104373:	01 d0                	add    %edx,%eax
f0104375:	8b 00                	mov    (%eax),%eax
f0104377:	85 c0                	test   %eax,%eax
f0104379:	0f 85 a7 00 00 00    	jne    f0104426 <pf_update_env_page+0x12f>
	{

		uint32 VA = (uint32)virtual_address ;
f010437f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104382:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0104385:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104388:	85 c0                	test   %eax,%eax
f010438a:	79 09                	jns    f0104395 <pf_update_env_page+0x9e>
f010438c:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0104393:	76 30                	jbe    f01043c5 <pf_update_env_page+0xce>
f0104395:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010439c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010439f:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01043a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01043a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01043af:	f7 75 f0             	divl   -0x10(%ebp)
f01043b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043b5:	29 d0                	sub    %edx,%eax
f01043b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01043ba:	77 53                	ja     f010440f <pf_update_env_page+0x118>
f01043bc:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01043c3:	77 4a                	ja     f010440f <pf_update_env_page+0x118>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01043c5:	83 ec 04             	sub    $0x4,%esp
f01043c8:	6a 00                	push   $0x0
f01043ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01043cd:	ff 75 08             	pushl  0x8(%ebp)
f01043d0:	e8 2b fd ff ff       	call   f0104100 <pf_add_empty_env_page>
f01043d5:	83 c4 10             	add    $0x10,%esp
f01043d8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01043db:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01043df:	75 17                	jne    f01043f8 <pf_update_env_page+0x101>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01043e1:	83 ec 04             	sub    $0x4,%esp
f01043e4:	68 6c 49 12 f0       	push   $0xf012496c
f01043e9:	68 43 01 00 00       	push   $0x143
f01043ee:	68 9f 48 12 f0       	push   $0xf012489f
f01043f3:	e8 41 bf ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01043f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01043fb:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104401:	8d 50 01             	lea    0x1(%eax),%edx
f0104404:	8b 45 08             	mov    0x8(%ebp),%eax
f0104407:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f010440d:	eb 17                	jmp    f0104426 <pf_update_env_page+0x12f>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f010440f:	83 ec 04             	sub    $0x4,%esp
f0104412:	68 b8 49 12 f0       	push   $0xf01249b8
f0104417:	68 4c 01 00 00       	push   $0x14c
f010441c:	68 9f 48 12 f0       	push   $0xf012489f
f0104421:	e8 13 bf ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104426:	8b 45 08             	mov    0x8(%ebp),%eax
f0104429:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010442f:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104432:	52                   	push   %edx
f0104433:	6a 00                	push   $0x0
f0104435:	ff 75 0c             	pushl  0xc(%ebp)
f0104438:	50                   	push   %eax
f0104439:	e8 a6 fb ff ff       	call   f0103fe4 <get_disk_page_table>
f010443e:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104441:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104444:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104447:	c1 ea 0c             	shr    $0xc,%edx
f010444a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104450:	c1 e2 02             	shl    $0x2,%edx
f0104453:	01 d0                	add    %edx,%eax
f0104455:	8b 00                	mov    (%eax),%eax
f0104457:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f010445a:	8b 45 08             	mov    0x8(%ebp),%eax
f010445d:	8b 40 64             	mov    0x64(%eax),%eax
f0104460:	6a 00                	push   $0x0
f0104462:	68 00 00 80 ef       	push   $0xef800000
f0104467:	ff 75 10             	pushl  0x10(%ebp)
f010446a:	50                   	push   %eax
f010446b:	e8 0f 42 00 00       	call   f010867f <map_frame>
f0104470:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f0104473:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f010447a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010447d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104482:	83 ec 08             	sub    $0x8,%esp
f0104485:	50                   	push   %eax
f0104486:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104489:	e8 ba f7 ff ff       	call   f0103c48 <write_disk_page>
f010448e:	83 c4 10             	add    $0x10,%esp
f0104491:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104494:	8b 45 10             	mov    0x10(%ebp),%eax
f0104497:	8b 40 08             	mov    0x8(%eax),%eax
f010449a:	40                   	inc    %eax
f010449b:	8b 55 10             	mov    0x10(%ebp),%edx
f010449e:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f01044a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a5:	8b 40 64             	mov    0x64(%eax),%eax
f01044a8:	83 ec 08             	sub    $0x8,%esp
f01044ab:	68 00 00 80 ef       	push   $0xef800000
f01044b0:	50                   	push   %eax
f01044b1:	e8 29 43 00 00       	call   f01087df <unmap_frame>
f01044b6:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01044b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01044bc:	8b 40 08             	mov    0x8(%eax),%eax
f01044bf:	48                   	dec    %eax
f01044c0:	8b 55 10             	mov    0x10(%ebp),%edx
f01044c3:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01044c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ca:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01044d0:	8d 50 01             	lea    0x1(%eax),%edx
f01044d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01044d6:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01044dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01044df:	c9                   	leave  
f01044e0:	c3                   	ret    

f01044e1 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01044e1:	55                   	push   %ebp
f01044e2:	89 e5                	mov    %esp,%ebp
f01044e4:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01044e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01044ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044f5:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01044f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01044fb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104501:	85 c0                	test   %eax,%eax
f0104503:	75 0a                	jne    f010450f <pf_read_env_page+0x2e>
f0104505:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010450a:	e9 93 00 00 00       	jmp    f01045a2 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f010450f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104512:	8b 45 08             	mov    0x8(%ebp),%eax
f0104515:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010451b:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010451e:	51                   	push   %ecx
f010451f:	6a 00                	push   $0x0
f0104521:	52                   	push   %edx
f0104522:	50                   	push   %eax
f0104523:	e8 bc fa ff ff       	call   f0103fe4 <get_disk_page_table>
f0104528:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010452b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452e:	85 c0                	test   %eax,%eax
f0104530:	75 07                	jne    f0104539 <pf_read_env_page+0x58>
f0104532:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104537:	eb 69                	jmp    f01045a2 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104539:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010453c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010453f:	c1 ea 0c             	shr    $0xc,%edx
f0104542:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104548:	c1 e2 02             	shl    $0x2,%edx
f010454b:	01 d0                	add    %edx,%eax
f010454d:	8b 00                	mov    (%eax),%eax
f010454f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104552:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104556:	75 07                	jne    f010455f <pf_read_env_page+0x7e>
f0104558:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010455d:	eb 43                	jmp    f01045a2 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010455f:	83 ec 08             	sub    $0x8,%esp
f0104562:	ff 75 0c             	pushl  0xc(%ebp)
f0104565:	ff 75 f0             	pushl  -0x10(%ebp)
f0104568:	e8 ac f6 ff ff       	call   f0103c19 <read_disk_page>
f010456d:	83 c4 10             	add    $0x10,%esp
f0104570:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104573:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104576:	8b 45 08             	mov    0x8(%ebp),%eax
f0104579:	8b 40 64             	mov    0x64(%eax),%eax
f010457c:	6a 40                	push   $0x40
f010457e:	6a 00                	push   $0x0
f0104580:	52                   	push   %edx
f0104581:	50                   	push   %eax
f0104582:	e8 43 4f 00 00       	call   f01094ca <pt_set_page_permissions>
f0104587:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010458a:	8b 45 08             	mov    0x8(%ebp),%eax
f010458d:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104593:	8d 50 01             	lea    0x1(%eax),%edx
f0104596:	8b 45 08             	mov    0x8(%ebp),%eax
f0104599:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010459f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01045a2:	c9                   	leave  
f01045a3:	c3                   	ret    

f01045a4 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f01045a4:	55                   	push   %ebp
f01045a5:	89 e5                	mov    %esp,%ebp
f01045a7:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01045aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ad:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045b3:	85 c0                	test   %eax,%eax
f01045b5:	74 65                	je     f010461c <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01045b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ba:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045c0:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01045c3:	52                   	push   %edx
f01045c4:	6a 00                	push   $0x0
f01045c6:	ff 75 0c             	pushl  0xc(%ebp)
f01045c9:	50                   	push   %eax
f01045ca:	e8 15 fa ff ff       	call   f0103fe4 <get_disk_page_table>
f01045cf:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01045d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045d5:	85 c0                	test   %eax,%eax
f01045d7:	74 46                	je     f010461f <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045df:	c1 ea 0c             	shr    $0xc,%edx
f01045e2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045e8:	c1 e2 02             	shl    $0x2,%edx
f01045eb:	01 d0                	add    %edx,%eax
f01045ed:	8b 00                	mov    (%eax),%eax
f01045ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01045f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045f5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045f8:	c1 ea 0c             	shr    $0xc,%edx
f01045fb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104601:	c1 e2 02             	shl    $0x2,%edx
f0104604:	01 d0                	add    %edx,%eax
f0104606:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010460c:	83 ec 0c             	sub    $0xc,%esp
f010460f:	ff 75 f4             	pushl  -0xc(%ebp)
f0104612:	e8 cc f8 ff ff       	call   f0103ee3 <free_disk_frame>
f0104617:	83 c4 10             	add    $0x10,%esp
f010461a:	eb 04                	jmp    f0104620 <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010461c:	90                   	nop
f010461d:	eb 01                	jmp    f0104620 <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010461f:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104620:	c9                   	leave  
f0104621:	c3                   	ret    

f0104622 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104622:	55                   	push   %ebp
f0104623:	89 e5                	mov    %esp,%ebp
f0104625:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104628:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010462f:	e9 c1 00 00 00       	jmp    f01046f5 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104634:	8b 45 08             	mov    0x8(%ebp),%eax
f0104637:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104640:	c1 e2 02             	shl    $0x2,%edx
f0104643:	01 d0                	add    %edx,%eax
f0104645:	8b 00                	mov    (%eax),%eax
f0104647:	83 e0 01             	and    $0x1,%eax
f010464a:	85 c0                	test   %eax,%eax
f010464c:	0f 84 9f 00 00 00    	je     f01046f1 <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104652:	8b 45 08             	mov    0x8(%ebp),%eax
f0104655:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010465b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010465e:	c1 e2 02             	shl    $0x2,%edx
f0104661:	01 d0                	add    %edx,%eax
f0104663:	8b 00                	mov    (%eax),%eax
f0104665:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010466a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010466d:	83 ec 0c             	sub    $0xc,%esp
f0104670:	ff 75 ec             	pushl  -0x14(%ebp)
f0104673:	e8 16 4e 00 00       	call   f010948e <kheap_virtual_address>
f0104678:	83 c4 10             	add    $0x10,%esp
f010467b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010467e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104685:	eb 3a                	jmp    f01046c1 <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104687:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010468a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104691:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104694:	01 d0                	add    %edx,%eax
f0104696:	8b 00                	mov    (%eax),%eax
f0104698:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010469b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010469e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01046a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046a8:	01 d0                	add    %edx,%eax
f01046aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01046b0:	83 ec 0c             	sub    $0xc,%esp
f01046b3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01046b6:	e8 28 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f01046bb:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01046be:	ff 45 f0             	incl   -0x10(%ebp)
f01046c1:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01046c8:	76 bd                	jbe    f0104687 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01046ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01046cd:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046d6:	c1 e2 02             	shl    $0x2,%edx
f01046d9:	01 d0                	add    %edx,%eax
f01046db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01046e1:	83 ec 0c             	sub    $0xc,%esp
f01046e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01046e7:	e8 5f 4c 00 00       	call   f010934b <kfree>
f01046ec:	83 c4 10             	add    $0x10,%esp
f01046ef:	eb 01                	jmp    f01046f2 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01046f1:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046f2:	ff 45 f4             	incl   -0xc(%ebp)
f01046f5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01046fc:	0f 86 32 ff ff ff    	jbe    f0104634 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f0104702:	8b 45 08             	mov    0x8(%ebp),%eax
f0104705:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010470b:	83 ec 0c             	sub    $0xc,%esp
f010470e:	50                   	push   %eax
f010470f:	e8 37 4c 00 00       	call   f010934b <kfree>
f0104714:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104717:	8b 45 08             	mov    0x8(%ebp),%eax
f010471a:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104721:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104724:	8b 45 08             	mov    0x8(%ebp),%eax
f0104727:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010472e:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104731:	8b 45 08             	mov    0x8(%ebp),%eax
f0104734:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010473a:	85 c0                	test   %eax,%eax
f010473c:	74 3f                	je     f010477d <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010473e:	83 ec 0c             	sub    $0xc,%esp
f0104741:	ff 75 08             	pushl  0x8(%ebp)
f0104744:	e8 14 03 00 00       	call   f0104a5d <__pf_remove_env_all_tables>
f0104749:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010474c:	8b 45 08             	mov    0x8(%ebp),%eax
f010474f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104755:	83 ec 0c             	sub    $0xc,%esp
f0104758:	50                   	push   %eax
f0104759:	e8 ed 4b 00 00       	call   f010934b <kfree>
f010475e:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104761:	8b 45 08             	mov    0x8(%ebp),%eax
f0104764:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010476b:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010476e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104771:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104778:	00 00 00 
f010477b:	eb 01                	jmp    f010477e <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010477d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010477e:	c9                   	leave  
f010477f:	c3                   	ret    

f0104780 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0104780:	55                   	push   %ebp
f0104781:	89 e5                	mov    %esp,%ebp
f0104783:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104786:	8b 45 08             	mov    0x8(%ebp),%eax
f0104789:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010478f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104792:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104794:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104797:	8b 00                	mov    (%eax),%eax
f0104799:	85 c0                	test   %eax,%eax
f010479b:	75 5b                	jne    f01047f8 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010479d:	83 ec 0c             	sub    $0xc,%esp
f01047a0:	68 00 10 00 00       	push   $0x1000
f01047a5:	e8 41 49 00 00       	call   f01090eb <kmalloc>
f01047aa:	83 c4 10             	add    $0x10,%esp
f01047ad:	89 c2                	mov    %eax,%edx
f01047af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b2:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01047b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b7:	8b 00                	mov    (%eax),%eax
f01047b9:	85 c0                	test   %eax,%eax
f01047bb:	75 07                	jne    f01047c4 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01047bd:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01047c2:	eb 39                	jmp    f01047fd <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01047c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047c7:	8b 00                	mov    (%eax),%eax
f01047c9:	83 ec 0c             	sub    $0xc,%esp
f01047cc:	50                   	push   %eax
f01047cd:	e8 5f 4c 00 00       	call   f0109431 <kheap_physical_address>
f01047d2:	83 c4 10             	add    $0x10,%esp
f01047d5:	89 c2                	mov    %eax,%edx
f01047d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01047da:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01047e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047e3:	8b 00                	mov    (%eax),%eax
f01047e5:	83 ec 04             	sub    $0x4,%esp
f01047e8:	68 00 10 00 00       	push   $0x1000
f01047ed:	6a 00                	push   $0x0
f01047ef:	50                   	push   %eax
f01047f0:	e8 d2 ae 01 00       	call   f011f6c7 <memset>
f01047f5:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01047f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047fd:	c9                   	leave  
f01047fe:	c3                   	ret    

f01047ff <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01047ff:	55                   	push   %ebp
f0104800:	89 e5                	mov    %esp,%ebp
f0104802:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104805:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010480c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104813:	eb 7e                	jmp    f0104893 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104815:	8b 45 08             	mov    0x8(%ebp),%eax
f0104818:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010481e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104821:	c1 e2 02             	shl    $0x2,%edx
f0104824:	01 d0                	add    %edx,%eax
f0104826:	8b 00                	mov    (%eax),%eax
f0104828:	83 e0 01             	and    $0x1,%eax
f010482b:	85 c0                	test   %eax,%eax
f010482d:	74 60                	je     f010488f <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f010482f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104832:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104838:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010483b:	c1 e2 02             	shl    $0x2,%edx
f010483e:	01 d0                	add    %edx,%eax
f0104840:	8b 00                	mov    (%eax),%eax
f0104842:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104847:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010484a:	83 ec 0c             	sub    $0xc,%esp
f010484d:	ff 75 e8             	pushl  -0x18(%ebp)
f0104850:	e8 39 4c 00 00       	call   f010948e <kheap_virtual_address>
f0104855:	83 c4 10             	add    $0x10,%esp
f0104858:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010485b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104862:	eb 20                	jmp    f0104884 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104864:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010486e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104871:	01 d0                	add    %edx,%eax
f0104873:	8b 00                	mov    (%eax),%eax
f0104875:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104878:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010487c:	74 03                	je     f0104881 <pf_calculate_allocated_pages+0x82>
				counter ++;
f010487e:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104881:	ff 45 ec             	incl   -0x14(%ebp)
f0104884:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010488b:	76 d7                	jbe    f0104864 <pf_calculate_allocated_pages+0x65>
f010488d:	eb 01                	jmp    f0104890 <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010488f:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104890:	ff 45 f4             	incl   -0xc(%ebp)
f0104893:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010489a:	0f 86 75 ff ff ff    	jbe    f0104815 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f01048a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01048a3:	c9                   	leave  
f01048a4:	c3                   	ret    

f01048a5 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f01048a5:	55                   	push   %ebp
f01048a6:	89 e5                	mov    %esp,%ebp
f01048a8:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f01048ab:	83 ec 0c             	sub    $0xc,%esp
f01048ae:	68 90 b9 6b f0       	push   $0xf06bb990
f01048b3:	e8 60 ac 00 00       	call   f010f518 <acquire_spinlock>
f01048b8:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f01048bb:	a1 8c b9 6b f0       	mov    0xf06bb98c,%eax
f01048c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01048c3:	83 ec 0c             	sub    $0xc,%esp
f01048c6:	68 90 b9 6b f0       	push   $0xf06bb990
f01048cb:	e8 cf ac 00 00       	call   f010f59f <release_spinlock>
f01048d0:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f01048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f01048d6:	c9                   	leave  
f01048d7:	c3                   	ret    

f01048d8 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f01048d8:	55                   	push   %ebp
f01048d9:	89 e5                	mov    %esp,%ebp
f01048db:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f01048de:	8b 45 08             	mov    0x8(%ebp),%eax
f01048e1:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f01048e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ea:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01048ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ef:	8b 00                	mov    (%eax),%eax
f01048f1:	85 c0                	test   %eax,%eax
f01048f3:	75 5b                	jne    f0104950 <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f01048f5:	83 ec 0c             	sub    $0xc,%esp
f01048f8:	68 00 10 00 00       	push   $0x1000
f01048fd:	e8 e9 47 00 00       	call   f01090eb <kmalloc>
f0104902:	83 c4 10             	add    $0x10,%esp
f0104905:	89 c2                	mov    %eax,%edx
f0104907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490a:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010490c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490f:	8b 00                	mov    (%eax),%eax
f0104911:	85 c0                	test   %eax,%eax
f0104913:	75 07                	jne    f010491c <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104915:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010491a:	eb 39                	jmp    f0104955 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010491c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010491f:	8b 00                	mov    (%eax),%eax
f0104921:	83 ec 0c             	sub    $0xc,%esp
f0104924:	50                   	push   %eax
f0104925:	e8 07 4b 00 00       	call   f0109431 <kheap_physical_address>
f010492a:	83 c4 10             	add    $0x10,%esp
f010492d:	89 c2                	mov    %eax,%edx
f010492f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104932:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104938:	8b 45 0c             	mov    0xc(%ebp),%eax
f010493b:	8b 00                	mov    (%eax),%eax
f010493d:	83 ec 04             	sub    $0x4,%esp
f0104940:	68 00 10 00 00       	push   $0x1000
f0104945:	6a 00                	push   $0x0
f0104947:	50                   	push   %eax
f0104948:	e8 7a ad 01 00       	call   f011f6c7 <memset>
f010494d:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104950:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104955:	c9                   	leave  
f0104956:	c3                   	ret    

f0104957 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104957:	55                   	push   %ebp
f0104958:	89 e5                	mov    %esp,%ebp
f010495a:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010495d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104964:	76 19                	jbe    f010497f <__pf_write_env_table+0x28>
f0104966:	68 30 49 12 f0       	push   $0xf0124930
f010496b:	68 56 49 12 f0       	push   $0xf0124956
f0104970:	68 91 02 00 00       	push   $0x291
f0104975:	68 9f 48 12 f0       	push   $0xf012489f
f010497a:	e8 ba b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010497f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104982:	05 88 00 00 00       	add    $0x88,%eax
f0104987:	83 ec 08             	sub    $0x8,%esp
f010498a:	50                   	push   %eax
f010498b:	ff 75 08             	pushl  0x8(%ebp)
f010498e:	e8 45 ff ff ff       	call   f01048d8 <get_disk_table_directory>
f0104993:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104996:	8b 45 08             	mov    0x8(%ebp),%eax
f0104999:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010499f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049a2:	c1 ea 16             	shr    $0x16,%edx
f01049a5:	c1 e2 02             	shl    $0x2,%edx
f01049a8:	01 d0                	add    %edx,%eax
f01049aa:	8b 00                	mov    (%eax),%eax
f01049ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f01049af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049b2:	85 c0                	test   %eax,%eax
f01049b4:	75 34                	jne    f01049ea <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01049b6:	83 ec 0c             	sub    $0xc,%esp
f01049b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01049bc:	50                   	push   %eax
f01049bd:	e8 33 f4 ff ff       	call   f0103df5 <allocate_disk_frame>
f01049c2:	83 c4 10             	add    $0x10,%esp
f01049c5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01049c8:	75 07                	jne    f01049d1 <__pf_write_env_table+0x7a>
f01049ca:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01049cf:	eb 31                	jmp    f0104a02 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01049d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01049da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049dd:	c1 ea 16             	shr    $0x16,%edx
f01049e0:	c1 e2 02             	shl    $0x2,%edx
f01049e3:	01 c2                	add    %eax,%edx
f01049e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049e8:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049ed:	83 ec 08             	sub    $0x8,%esp
f01049f0:	ff 75 10             	pushl  0x10(%ebp)
f01049f3:	50                   	push   %eax
f01049f4:	e8 4f f2 ff ff       	call   f0103c48 <write_disk_page>
f01049f9:	83 c4 10             	add    $0x10,%esp
f01049fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104a02:	c9                   	leave  
f0104a03:	c3                   	ret    

f0104a04 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104a04:	55                   	push   %ebp
f0104a05:	89 e5                	mov    %esp,%ebp
f0104a07:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a0d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a13:	85 c0                	test   %eax,%eax
f0104a15:	75 07                	jne    f0104a1e <__pf_read_env_table+0x1a>
f0104a17:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a1c:	eb 3d                	jmp    f0104a5b <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a21:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a27:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a2a:	c1 ea 16             	shr    $0x16,%edx
f0104a2d:	c1 e2 02             	shl    $0x2,%edx
f0104a30:	01 d0                	add    %edx,%eax
f0104a32:	8b 00                	mov    (%eax),%eax
f0104a34:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104a3b:	75 07                	jne    f0104a44 <__pf_read_env_table+0x40>
f0104a3d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a42:	eb 17                	jmp    f0104a5b <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104a44:	83 ec 08             	sub    $0x8,%esp
f0104a47:	ff 75 10             	pushl  0x10(%ebp)
f0104a4a:	ff 75 f4             	pushl  -0xc(%ebp)
f0104a4d:	e8 c7 f1 ff ff       	call   f0103c19 <read_disk_page>
f0104a52:	83 c4 10             	add    $0x10,%esp
f0104a55:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a5b:	c9                   	leave  
f0104a5c:	c3                   	ret    

f0104a5d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a5d:	55                   	push   %ebp
f0104a5e:	89 e5                	mov    %esp,%ebp
f0104a60:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a63:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a66:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a6c:	85 c0                	test   %eax,%eax
f0104a6e:	74 52                	je     f0104ac2 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a77:	eb 3e                	jmp    f0104ab7 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a7c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a85:	c1 e2 02             	shl    $0x2,%edx
f0104a88:	01 d0                	add    %edx,%eax
f0104a8a:	8b 00                	mov    (%eax),%eax
f0104a8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a92:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a9b:	c1 e2 02             	shl    $0x2,%edx
f0104a9e:	01 d0                	add    %edx,%eax
f0104aa0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104aa6:	83 ec 0c             	sub    $0xc,%esp
f0104aa9:	ff 75 f0             	pushl  -0x10(%ebp)
f0104aac:	e8 32 f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104ab1:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ab4:	ff 45 f4             	incl   -0xc(%ebp)
f0104ab7:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104abe:	76 b9                	jbe    f0104a79 <__pf_remove_env_all_tables+0x1c>
f0104ac0:	eb 01                	jmp    f0104ac3 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ac2:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104ac3:	c9                   	leave  
f0104ac4:	c3                   	ret    

f0104ac5 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104ac5:	55                   	push   %ebp
f0104ac6:	89 e5                	mov    %esp,%ebp
f0104ac8:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104acb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104acf:	75 10                	jne    f0104ae1 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104ad1:	83 ec 0c             	sub    $0xc,%esp
f0104ad4:	68 34 4a 12 f0       	push   $0xf0124a34
f0104ad9:	e8 ad c4 ff ff       	call   f0100f8b <cprintf>
f0104ade:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ae4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104aea:	85 c0                	test   %eax,%eax
f0104aec:	74 43                	je     f0104b31 <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104aee:	8b 45 08             	mov    0x8(%ebp),%eax
f0104af1:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104af7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104afa:	c1 ea 16             	shr    $0x16,%edx
f0104afd:	c1 e2 02             	shl    $0x2,%edx
f0104b00:	01 d0                	add    %edx,%eax
f0104b02:	8b 00                	mov    (%eax),%eax
f0104b04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b0a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b10:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b13:	c1 ea 16             	shr    $0x16,%edx
f0104b16:	c1 e2 02             	shl    $0x2,%edx
f0104b19:	01 d0                	add    %edx,%eax
f0104b1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104b21:	83 ec 0c             	sub    $0xc,%esp
f0104b24:	ff 75 f4             	pushl  -0xc(%ebp)
f0104b27:	e8 b7 f3 ff ff       	call   f0103ee3 <free_disk_frame>
f0104b2c:	83 c4 10             	add    $0x10,%esp
f0104b2f:	eb 01                	jmp    f0104b32 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b31:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104b32:	c9                   	leave  
f0104b33:	c3                   	ret    

f0104b34 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104b34:	55                   	push   %ebp
f0104b35:	89 e5                	mov    %esp,%ebp
f0104b37:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104b3a:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104b41:	eb 1f                	jmp    f0104b62 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b46:	83 ec 04             	sub    $0x4,%esp
f0104b49:	6a 08                	push   $0x8
f0104b4b:	ff 75 08             	pushl  0x8(%ebp)
f0104b4e:	50                   	push   %eax
f0104b4f:	e8 ad b2 01 00       	call   f011fe01 <ide_write>
f0104b54:	83 c4 10             	add    $0x10,%esp
f0104b57:	85 c0                	test   %eax,%eax
f0104b59:	75 12                	jne    f0104b6d <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104b5b:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b62:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b69:	7e d8                	jle    f0104b43 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6b:	eb 01                	jmp    f0104b6e <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b6d:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6e:	90                   	nop
f0104b6f:	c9                   	leave  
f0104b70:	c3                   	ret    

f0104b71 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b71:	55                   	push   %ebp
  pushl %eax
f0104b72:	50                   	push   %eax
  pushl %ebx
f0104b73:	53                   	push   %ebx
  pushl %ecx
f0104b74:	51                   	push   %ecx
  pushl %edx
f0104b75:	52                   	push   %edx
  pushl %esi
f0104b76:	56                   	push   %esi
  pushl %edi
f0104b77:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b78:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b7c:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b80:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b82:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b84:	5f                   	pop    %edi
  popl %esi
f0104b85:	5e                   	pop    %esi
  popl %edx
f0104b86:	5a                   	pop    %edx
  popl %ecx
f0104b87:	59                   	pop    %ecx
  popl %ebx
f0104b88:	5b                   	pop    %ebx
  popl %eax
f0104b89:	58                   	pop    %eax
  popl %ebp
f0104b8a:	5d                   	pop    %ebp
  ret
f0104b8b:	c3                   	ret    

f0104b8c <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b8c:	55                   	push   %ebp
f0104b8d:	89 e5                	mov    %esp,%ebp
f0104b8f:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b95:	0f b6 c0             	movzbl %al,%eax
f0104b98:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b9f:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ba2:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104ba5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104ba8:	ee                   	out    %al,(%dx)
f0104ba9:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bb3:	89 c2                	mov    %eax,%edx
f0104bb5:	ec                   	in     (%dx),%al
f0104bb6:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104bb9:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104bbc:	0f b6 c0             	movzbl %al,%eax
}
f0104bbf:	c9                   	leave  
f0104bc0:	c3                   	ret    

f0104bc1 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104bc1:	55                   	push   %ebp
f0104bc2:	89 e5                	mov    %esp,%ebp
f0104bc4:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104bc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bca:	0f b6 c0             	movzbl %al,%eax
f0104bcd:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104bd4:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104bd7:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104bda:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104bdd:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104bde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104be1:	0f b6 c0             	movzbl %al,%eax
f0104be4:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104beb:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104bee:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104bf1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104bf4:	ee                   	out    %al,(%dx)
}
f0104bf5:	90                   	nop
f0104bf6:	c9                   	leave  
f0104bf7:	c3                   	ret    

f0104bf8 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104bf8:	55                   	push   %ebp
f0104bf9:	89 e5                	mov    %esp,%ebp
f0104bfb:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104bfe:	c7 05 68 b9 6b f0 00 	movl   $0x0,0xf06bb968
f0104c05:	00 00 00 
f0104c08:	c7 05 6c b9 6b f0 00 	movl   $0x0,0xf06bb96c
f0104c0f:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104c12:	83 ec 08             	sub    $0x8,%esp
f0104c15:	68 bf 6b 10 f0       	push   $0xf0106bbf
f0104c1a:	6a 00                	push   $0x0
f0104c1c:	e8 02 8f 00 00       	call   f010db23 <irq_install_handler>
f0104c21:	83 c4 10             	add    $0x10,%esp
}
f0104c24:	90                   	nop
f0104c25:	c9                   	leave  
f0104c26:	c3                   	ret    

f0104c27 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104c27:	55                   	push   %ebp
f0104c28:	89 e5                	mov    %esp,%ebp
f0104c2a:	53                   	push   %ebx
f0104c2b:	83 ec 24             	sub    $0x24,%esp
f0104c2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c31:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104c34:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104c3b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104c3f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104c42:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104c45:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104c46:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104c4a:	77 48                	ja     f0104c94 <kclock_start+0x6d>
f0104c4c:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c53:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104c57:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104c5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c5d:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c62:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c67:	99                   	cltd   
f0104c68:	f7 fb                	idiv   %ebx
f0104c6a:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c70:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c74:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c79:	99                   	cltd   
f0104c7a:	f7 fb                	idiv   %ebx
f0104c7c:	89 c3                	mov    %eax,%ebx
f0104c7e:	89 c8                	mov    %ecx,%eax
f0104c80:	99                   	cltd   
f0104c81:	f7 fb                	idiv   %ebx
f0104c83:	0f b7 c0             	movzwl %ax,%eax
f0104c86:	83 ec 0c             	sub    $0xc,%esp
f0104c89:	50                   	push   %eax
f0104c8a:	e8 b3 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104c8f:	83 c4 10             	add    $0x10,%esp
f0104c92:	eb 13                	jmp    f0104ca7 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c94:	6a 35                	push   $0x35
f0104c96:	68 58 4a 12 f0       	push   $0xf0124a58
f0104c9b:	6a 41                	push   $0x41
f0104c9d:	68 b4 4a 12 f0       	push   $0xf0124ab4
f0104ca2:	e8 92 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104ca7:	83 ec 0c             	sub    $0xc,%esp
f0104caa:	6a 00                	push   $0x0
f0104cac:	e8 43 23 00 00       	call   f0106ff4 <irq_clear_mask>
f0104cb1:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104cb4:	90                   	nop
f0104cb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104cb8:	c9                   	leave  
f0104cb9:	c3                   	ret    

f0104cba <kclock_stop>:

void
kclock_stop(void)
{
f0104cba:	55                   	push   %ebp
f0104cbb:	89 e5                	mov    %esp,%ebp
f0104cbd:	83 ec 18             	sub    $0x18,%esp
f0104cc0:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cc7:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104ccb:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104cce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cd1:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104cd2:	83 ec 0c             	sub    $0xc,%esp
f0104cd5:	6a 00                	push   $0x0
f0104cd7:	e8 a3 22 00 00       	call   f0106f7f <irq_set_mask>
f0104cdc:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104cdf:	90                   	nop
f0104ce0:	c9                   	leave  
f0104ce1:	c3                   	ret    

f0104ce2 <kclock_resume>:

void
kclock_resume(void)
{
f0104ce2:	55                   	push   %ebp
f0104ce3:	89 e5                	mov    %esp,%ebp
f0104ce5:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ce8:	e8 f5 01 00 00       	call   f0104ee2 <kclock_read_cnt0_latch>
f0104ced:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104cf1:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104cf6:	77 06                	ja     f0104cfe <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104cf8:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104cfe:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d02:	83 e0 01             	and    $0x1,%eax
f0104d05:	66 85 c0             	test   %ax,%ax
f0104d08:	74 09                	je     f0104d13 <kclock_resume+0x31>
		cnt0++;
f0104d0a:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d0e:	40                   	inc    %eax
f0104d0f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104d13:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d1a:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104d1e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104d21:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104d24:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d25:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104d29:	83 ec 0c             	sub    $0xc,%esp
f0104d2c:	50                   	push   %eax
f0104d2d:	e8 10 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d32:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d35:	83 ec 0c             	sub    $0xc,%esp
f0104d38:	6a 00                	push   $0x0
f0104d3a:	e8 b5 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d3f:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104d42:	90                   	nop
f0104d43:	c9                   	leave  
f0104d44:	c3                   	ret    

f0104d45 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104d45:	55                   	push   %ebp
f0104d46:	89 e5                	mov    %esp,%ebp
f0104d48:	83 ec 28             	sub    $0x28,%esp
f0104d4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d4e:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104d51:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d58:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d5c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d62:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d63:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d67:	83 ec 0c             	sub    $0xc,%esp
f0104d6a:	50                   	push   %eax
f0104d6b:	e8 d2 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d70:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d73:	83 ec 0c             	sub    $0xc,%esp
f0104d76:	6a 00                	push   $0x0
f0104d78:	e8 77 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d7d:	83 c4 10             	add    $0x10,%esp
}
f0104d80:	90                   	nop
f0104d81:	c9                   	leave  
f0104d82:	c3                   	ret    

f0104d83 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d83:	55                   	push   %ebp
f0104d84:	89 e5                	mov    %esp,%ebp
f0104d86:	56                   	push   %esi
f0104d87:	53                   	push   %ebx
f0104d88:	83 ec 20             	sub    $0x20,%esp
f0104d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d8e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d91:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d95:	0f 87 8a 00 00 00    	ja     f0104e25 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d9b:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d9f:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104da4:	99                   	cltd   
f0104da5:	f7 fe                	idiv   %esi
f0104da7:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dad:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104db1:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104db6:	99                   	cltd   
f0104db7:	f7 fb                	idiv   %ebx
f0104db9:	89 c6                	mov    %eax,%esi
f0104dbb:	89 c8                	mov    %ecx,%eax
f0104dbd:	99                   	cltd   
f0104dbe:	f7 fe                	idiv   %esi
f0104dc0:	89 c3                	mov    %eax,%ebx
f0104dc2:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104dc6:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104dcb:	99                   	cltd   
f0104dcc:	f7 f9                	idiv   %ecx
f0104dce:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dd4:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104dd8:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104ddd:	99                   	cltd   
f0104dde:	f7 fe                	idiv   %esi
f0104de0:	89 c6                	mov    %eax,%esi
f0104de2:	89 c8                	mov    %ecx,%eax
f0104de4:	99                   	cltd   
f0104de5:	f7 fe                	idiv   %esi
f0104de7:	25 01 00 00 80       	and    $0x80000001,%eax
f0104dec:	85 c0                	test   %eax,%eax
f0104dee:	79 05                	jns    f0104df5 <kclock_set_quantum+0x72>
f0104df0:	48                   	dec    %eax
f0104df1:	83 c8 fe             	or     $0xfffffffe,%eax
f0104df4:	40                   	inc    %eax
f0104df5:	01 d8                	add    %ebx,%eax
f0104df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104dfa:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e01:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e05:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e0b:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104e0f:	0f b7 c0             	movzwl %ax,%eax
f0104e12:	83 ec 0c             	sub    $0xc,%esp
f0104e15:	50                   	push   %eax
f0104e16:	e8 27 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104e1b:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104e1e:	e8 97 fe ff ff       	call   f0104cba <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104e23:	eb 16                	jmp    f0104e3b <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e25:	6a 35                	push   $0x35
f0104e27:	68 58 4a 12 f0       	push   $0xf0124a58
f0104e2c:	68 ea 00 00 00       	push   $0xea
f0104e31:	68 b4 4a 12 f0       	push   $0xf0124ab4
f0104e36:	e8 fe b4 ff ff       	call   f0100339 <_panic>
	}
}
f0104e3b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e3e:	5b                   	pop    %ebx
f0104e3f:	5e                   	pop    %esi
f0104e40:	5d                   	pop    %ebp
f0104e41:	c3                   	ret    

f0104e42 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104e42:	55                   	push   %ebp
f0104e43:	89 e5                	mov    %esp,%ebp
f0104e45:	83 ec 28             	sub    $0x28,%esp
f0104e48:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e4b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104e4f:	e8 7b 23 00 00       	call   f01071cf <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104e54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e57:	0f b6 c0             	movzbl %al,%eax
f0104e5a:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104e61:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e64:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e6a:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e6e:	66 c1 e8 08          	shr    $0x8,%ax
f0104e72:	0f b6 c0             	movzbl %al,%eax
f0104e75:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e7c:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e85:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e86:	e8 96 23 00 00       	call   f0107221 <popcli>

}
f0104e8b:	90                   	nop
f0104e8c:	c9                   	leave  
f0104e8d:	c3                   	ret    

f0104e8e <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e8e:	55                   	push   %ebp
f0104e8f:	89 e5                	mov    %esp,%ebp
f0104e91:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e94:	e8 36 23 00 00       	call   f01071cf <pushcli>
f0104e99:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ea3:	89 c2                	mov    %eax,%edx
f0104ea5:	ec                   	in     (%dx),%al
f0104ea6:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104ea9:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104eac:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104eaf:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104eb9:	89 c2                	mov    %eax,%edx
f0104ebb:	ec                   	in     (%dx),%al
f0104ebc:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104ebf:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104ec2:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104ec5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104ec9:	c1 e0 08             	shl    $0x8,%eax
f0104ecc:	89 c2                	mov    %eax,%edx
f0104ece:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104ed2:	09 d0                	or     %edx,%eax
f0104ed4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104ed8:	e8 44 23 00 00       	call   f0107221 <popcli>
	return cnt0 ;
f0104edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104ee0:	c9                   	leave  
f0104ee1:	c3                   	ret    

f0104ee2 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104ee2:	55                   	push   %ebp
f0104ee3:	89 e5                	mov    %esp,%ebp
f0104ee5:	83 ec 30             	sub    $0x30,%esp
f0104ee8:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eef:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104ef2:	89 c2                	mov    %eax,%edx
f0104ef4:	ec                   	in     (%dx),%al
f0104ef5:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104ef8:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104efb:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104efe:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f05:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f09:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104f0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f0f:	ee                   	out    %al,(%dx)
f0104f10:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104f1a:	89 c2                	mov    %eax,%edx
f0104f1c:	ec                   	in     (%dx),%al
f0104f1d:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104f20:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104f23:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104f26:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104f30:	89 c2                	mov    %eax,%edx
f0104f32:	ec                   	in     (%dx),%al
f0104f33:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104f36:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f39:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f3c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104f40:	c1 e0 08             	shl    $0x8,%eax
f0104f43:	89 c2                	mov    %eax,%edx
f0104f45:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104f49:	09 d0                	or     %edx,%eax
f0104f4b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104f4f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104f53:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104f5a:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f5d:	8a 45 df             	mov    -0x21(%ebp),%al
f0104f60:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f63:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f64:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f67:	c9                   	leave  
f0104f68:	c3                   	ret    

f0104f69 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f69:	55                   	push   %ebp
f0104f6a:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f70:	74 1d                	je     f0104f8f <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f72:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f85:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f88:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f8f:	90                   	nop
f0104f90:	5d                   	pop    %ebp
f0104f91:	c3                   	ret    

f0104f92 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f92:	55                   	push   %ebp
f0104f93:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f99:	74 08                	je     f0104fa3 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f9e:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fa1:	eb 05                	jmp    f0104fa8 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104fa3:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104fa8:	5d                   	pop    %ebp
f0104fa9:	c3                   	ret    

f0104faa <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104faa:	55                   	push   %ebp
f0104fab:	89 e5                	mov    %esp,%ebp
f0104fad:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104fb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb4:	75 16                	jne    f0104fcc <enqueue+0x22>
f0104fb6:	68 c8 4a 12 f0       	push   $0xf0124ac8
f0104fbb:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0104fc0:	6a 34                	push   $0x34
f0104fc2:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0104fc7:	e8 6d b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f0104fcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd0:	74 66                	je     f0105038 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104fd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd6:	75 14                	jne    f0104fec <enqueue+0x42>
f0104fd8:	83 ec 04             	sub    $0x4,%esp
f0104fdb:	68 04 4b 12 f0       	push   $0xf0124b04
f0104fe0:	6a 37                	push   $0x37
f0104fe2:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0104fe7:	e8 4d b3 ff ff       	call   f0100339 <_panic>
f0104fec:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fef:	8b 10                	mov    (%eax),%edx
f0104ff1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ff4:	89 50 08             	mov    %edx,0x8(%eax)
f0104ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ffa:	8b 40 08             	mov    0x8(%eax),%eax
f0104ffd:	85 c0                	test   %eax,%eax
f0104fff:	74 0d                	je     f010500e <enqueue+0x64>
f0105001:	8b 45 08             	mov    0x8(%ebp),%eax
f0105004:	8b 00                	mov    (%eax),%eax
f0105006:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105009:	89 50 0c             	mov    %edx,0xc(%eax)
f010500c:	eb 09                	jmp    f0105017 <enqueue+0x6d>
f010500e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105011:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105014:	89 50 04             	mov    %edx,0x4(%eax)
f0105017:	8b 45 08             	mov    0x8(%ebp),%eax
f010501a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010501d:	89 10                	mov    %edx,(%eax)
f010501f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105022:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105029:	8b 45 08             	mov    0x8(%ebp),%eax
f010502c:	8b 40 0c             	mov    0xc(%eax),%eax
f010502f:	8d 50 01             	lea    0x1(%eax),%edx
f0105032:	8b 45 08             	mov    0x8(%ebp),%eax
f0105035:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105038:	90                   	nop
f0105039:	c9                   	leave  
f010503a:	c3                   	ret    

f010503b <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010503b:	55                   	push   %ebp
f010503c:	89 e5                	mov    %esp,%ebp
f010503e:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105041:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105045:	75 0a                	jne    f0105051 <dequeue+0x16>
f0105047:	b8 00 00 00 00       	mov    $0x0,%eax
f010504c:	e9 a0 00 00 00       	jmp    f01050f1 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105051:	8b 45 08             	mov    0x8(%ebp),%eax
f0105054:	8b 40 04             	mov    0x4(%eax),%eax
f0105057:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f010505a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010505e:	0f 84 8a 00 00 00    	je     f01050ee <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105064:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105068:	75 14                	jne    f010507e <dequeue+0x43>
f010506a:	83 ec 04             	sub    $0x4,%esp
f010506d:	68 27 4b 12 f0       	push   $0xf0124b27
f0105072:	6a 44                	push   $0x44
f0105074:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105079:	e8 bb b2 ff ff       	call   f0100339 <_panic>
f010507e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105081:	8b 40 08             	mov    0x8(%eax),%eax
f0105084:	85 c0                	test   %eax,%eax
f0105086:	74 11                	je     f0105099 <dequeue+0x5e>
f0105088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010508b:	8b 40 08             	mov    0x8(%eax),%eax
f010508e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105091:	8b 52 0c             	mov    0xc(%edx),%edx
f0105094:	89 50 0c             	mov    %edx,0xc(%eax)
f0105097:	eb 0c                	jmp    f01050a5 <dequeue+0x6a>
f0105099:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010509c:	8b 50 0c             	mov    0xc(%eax),%edx
f010509f:	8b 45 08             	mov    0x8(%ebp),%eax
f01050a2:	89 50 04             	mov    %edx,0x4(%eax)
f01050a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01050ab:	85 c0                	test   %eax,%eax
f01050ad:	74 11                	je     f01050c0 <dequeue+0x85>
f01050af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050b2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050b8:	8b 52 08             	mov    0x8(%edx),%edx
f01050bb:	89 50 08             	mov    %edx,0x8(%eax)
f01050be:	eb 0b                	jmp    f01050cb <dequeue+0x90>
f01050c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050c3:	8b 50 08             	mov    0x8(%eax),%edx
f01050c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01050c9:	89 10                	mov    %edx,(%eax)
f01050cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01050d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050df:	8b 45 08             	mov    0x8(%ebp),%eax
f01050e2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050e5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01050e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01050eb:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01050ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01050f1:	c9                   	leave  
f01050f2:	c3                   	ret    

f01050f3 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01050f3:	55                   	push   %ebp
f01050f4:	89 e5                	mov    %esp,%ebp
f01050f6:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01050f9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01050fd:	75 16                	jne    f0105115 <remove_from_queue+0x22>
f01050ff:	68 c8 4a 12 f0       	push   $0xf0124ac8
f0105104:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0105109:	6a 4e                	push   $0x4e
f010510b:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105110:	e8 24 b2 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105115:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105119:	0f 84 8a 00 00 00    	je     f01051a9 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010511f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105123:	75 14                	jne    f0105139 <remove_from_queue+0x46>
f0105125:	83 ec 04             	sub    $0x4,%esp
f0105128:	68 27 4b 12 f0       	push   $0xf0124b27
f010512d:	6a 52                	push   $0x52
f010512f:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105134:	e8 00 b2 ff ff       	call   f0100339 <_panic>
f0105139:	8b 45 0c             	mov    0xc(%ebp),%eax
f010513c:	8b 40 08             	mov    0x8(%eax),%eax
f010513f:	85 c0                	test   %eax,%eax
f0105141:	74 11                	je     f0105154 <remove_from_queue+0x61>
f0105143:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105146:	8b 40 08             	mov    0x8(%eax),%eax
f0105149:	8b 55 0c             	mov    0xc(%ebp),%edx
f010514c:	8b 52 0c             	mov    0xc(%edx),%edx
f010514f:	89 50 0c             	mov    %edx,0xc(%eax)
f0105152:	eb 0c                	jmp    f0105160 <remove_from_queue+0x6d>
f0105154:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105157:	8b 50 0c             	mov    0xc(%eax),%edx
f010515a:	8b 45 08             	mov    0x8(%ebp),%eax
f010515d:	89 50 04             	mov    %edx,0x4(%eax)
f0105160:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105163:	8b 40 0c             	mov    0xc(%eax),%eax
f0105166:	85 c0                	test   %eax,%eax
f0105168:	74 11                	je     f010517b <remove_from_queue+0x88>
f010516a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010516d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105170:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105173:	8b 52 08             	mov    0x8(%edx),%edx
f0105176:	89 50 08             	mov    %edx,0x8(%eax)
f0105179:	eb 0b                	jmp    f0105186 <remove_from_queue+0x93>
f010517b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010517e:	8b 50 08             	mov    0x8(%eax),%edx
f0105181:	8b 45 08             	mov    0x8(%ebp),%eax
f0105184:	89 10                	mov    %edx,(%eax)
f0105186:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105189:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105190:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105193:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010519a:	8b 45 08             	mov    0x8(%ebp),%eax
f010519d:	8b 40 0c             	mov    0xc(%eax),%eax
f01051a0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01051a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a6:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01051a9:	90                   	nop
f01051aa:	c9                   	leave  
f01051ab:	c3                   	ret    

f01051ac <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f01051ac:	55                   	push   %ebp
f01051ad:	89 e5                	mov    %esp,%ebp
f01051af:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01051b2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051b6:	75 07                	jne    f01051bf <find_env_in_queue+0x13>
f01051b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01051bd:	eb 58                	jmp    f0105217 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01051bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01051c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c9:	8b 00                	mov    (%eax),%eax
f01051cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051ce:	eb 19                	jmp    f01051e9 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01051d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051d3:	8b 40 10             	mov    0x10(%eax),%eax
f01051d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01051d9:	75 05                	jne    f01051e0 <find_env_in_queue+0x34>
		{
			return ptr_env;
f01051db:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051de:	eb 37                	jmp    f0105217 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01051e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e3:	8b 40 08             	mov    0x8(%eax),%eax
f01051e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051ed:	74 08                	je     f01051f7 <find_env_in_queue+0x4b>
f01051ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051f2:	8b 40 08             	mov    0x8(%eax),%eax
f01051f5:	eb 05                	jmp    f01051fc <find_env_in_queue+0x50>
f01051f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01051fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01051ff:	89 42 08             	mov    %eax,0x8(%edx)
f0105202:	8b 45 08             	mov    0x8(%ebp),%eax
f0105205:	8b 40 08             	mov    0x8(%eax),%eax
f0105208:	85 c0                	test   %eax,%eax
f010520a:	75 c4                	jne    f01051d0 <find_env_in_queue+0x24>
f010520c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105210:	75 be                	jne    f01051d0 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105212:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105217:	c9                   	leave  
f0105218:	c3                   	ret    

f0105219 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105219:	55                   	push   %ebp
f010521a:	89 e5                	mov    %esp,%ebp
f010521c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010521f:	83 ec 0c             	sub    $0xc,%esp
f0105222:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105227:	e8 ec a2 00 00       	call   f010f518 <acquire_spinlock>
f010522c:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010522f:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105234:	85 c0                	test   %eax,%eax
f0105236:	74 11                	je     f0105249 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105238:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f010523d:	83 ec 0c             	sub    $0xc,%esp
f0105240:	50                   	push   %eax
f0105241:	e8 05 41 00 00       	call   f010934b <kfree>
f0105246:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105249:	a1 84 b6 6b f0       	mov    0xf06bb684,%eax
f010524e:	85 c0                	test   %eax,%eax
f0105250:	74 11                	je     f0105263 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105252:	a1 84 b6 6b f0       	mov    0xf06bb684,%eax
f0105257:	83 ec 0c             	sub    $0xc,%esp
f010525a:	50                   	push   %eax
f010525b:	e8 eb 40 00 00       	call   f010934b <kfree>
f0105260:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105263:	83 ec 0c             	sub    $0xc,%esp
f0105266:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010526b:	e8 2f a3 00 00       	call   f010f59f <release_spinlock>
f0105270:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105273:	90                   	nop
f0105274:	c9                   	leave  
f0105275:	c3                   	ret    

f0105276 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105276:	55                   	push   %ebp
f0105277:	89 e5                	mov    %esp,%ebp
f0105279:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010527c:	83 ec 0c             	sub    $0xc,%esp
f010527f:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105284:	e8 a8 a4 00 00       	call   f010f731 <holding_spinlock>
f0105289:	83 c4 10             	add    $0x10,%esp
f010528c:	85 c0                	test   %eax,%eax
f010528e:	75 17                	jne    f01052a7 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105290:	83 ec 04             	sub    $0x4,%esp
f0105293:	68 48 4b 12 f0       	push   $0xf0124b48
f0105298:	68 85 00 00 00       	push   $0x85
f010529d:	68 eb 4a 12 f0       	push   $0xf0124aeb
f01052a2:	e8 92 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01052a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ab:	75 19                	jne    f01052c6 <sched_insert_ready0+0x50>
f01052ad:	68 89 4b 12 f0       	push   $0xf0124b89
f01052b2:	68 d6 4a 12 f0       	push   $0xf0124ad6
f01052b7:	68 88 00 00 00       	push   $0x88
f01052bc:	68 eb 4a 12 f0       	push   $0xf0124aeb
f01052c1:	e8 73 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01052c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052c9:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01052d0:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01052d5:	83 ec 08             	sub    $0x8,%esp
f01052d8:	ff 75 08             	pushl  0x8(%ebp)
f01052db:	50                   	push   %eax
f01052dc:	e8 c9 fc ff ff       	call   f0104faa <enqueue>
f01052e1:	83 c4 10             	add    $0x10,%esp
	}
}
f01052e4:	90                   	nop
f01052e5:	c9                   	leave  
f01052e6:	c3                   	ret    

f01052e7 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f01052e7:	55                   	push   %ebp
f01052e8:	89 e5                	mov    %esp,%ebp
f01052ea:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052ed:	83 ec 0c             	sub    $0xc,%esp
f01052f0:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f01052f5:	e8 37 a4 00 00       	call   f010f731 <holding_spinlock>
f01052fa:	83 c4 10             	add    $0x10,%esp
f01052fd:	85 c0                	test   %eax,%eax
f01052ff:	75 17                	jne    f0105318 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105301:	83 ec 04             	sub    $0x4,%esp
f0105304:	68 48 4b 12 f0       	push   $0xf0124b48
f0105309:	68 97 00 00 00       	push   $0x97
f010530e:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105313:	e8 21 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105318:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010531c:	74 0b                	je     f0105329 <sched_remove_ready+0x42>
f010531e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105321:	8b 40 18             	mov    0x18(%eax),%eax
f0105324:	83 f8 01             	cmp    $0x1,%eax
f0105327:	74 19                	je     f0105342 <sched_remove_ready+0x5b>
f0105329:	68 98 4b 12 f0       	push   $0xf0124b98
f010532e:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0105333:	68 9a 00 00 00       	push   $0x9a
f0105338:	68 eb 4a 12 f0       	push   $0xf0124aeb
f010533d:	e8 f7 af ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105349:	e9 e4 00 00 00       	jmp    f0105432 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f010534e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105351:	8b 40 10             	mov    0x10(%eax),%eax
f0105354:	89 c2                	mov    %eax,%edx
f0105356:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f010535b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010535e:	c1 e1 04             	shl    $0x4,%ecx
f0105361:	01 c8                	add    %ecx,%eax
f0105363:	83 ec 08             	sub    $0x8,%esp
f0105366:	52                   	push   %edx
f0105367:	50                   	push   %eax
f0105368:	e8 3f fe ff ff       	call   f01051ac <find_env_in_queue>
f010536d:	83 c4 10             	add    $0x10,%esp
f0105370:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105373:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105377:	0f 84 b2 00 00 00    	je     f010542f <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010537d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105381:	75 17                	jne    f010539a <sched_remove_ready+0xb3>
f0105383:	83 ec 04             	sub    $0x4,%esp
f0105386:	68 27 4b 12 f0       	push   $0xf0124b27
f010538b:	68 a1 00 00 00       	push   $0xa1
f0105390:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105395:	e8 9f af ff ff       	call   f0100339 <_panic>
f010539a:	8b 45 08             	mov    0x8(%ebp),%eax
f010539d:	8b 40 08             	mov    0x8(%eax),%eax
f01053a0:	85 c0                	test   %eax,%eax
f01053a2:	74 11                	je     f01053b5 <sched_remove_ready+0xce>
f01053a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a7:	8b 40 08             	mov    0x8(%eax),%eax
f01053aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01053b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01053b3:	eb 16                	jmp    f01053cb <sched_remove_ready+0xe4>
f01053b5:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01053ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053bd:	c1 e2 04             	shl    $0x4,%edx
f01053c0:	01 c2                	add    %eax,%edx
f01053c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01053c8:	89 42 04             	mov    %eax,0x4(%edx)
f01053cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01053d1:	85 c0                	test   %eax,%eax
f01053d3:	74 11                	je     f01053e6 <sched_remove_ready+0xff>
f01053d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d8:	8b 40 0c             	mov    0xc(%eax),%eax
f01053db:	8b 55 08             	mov    0x8(%ebp),%edx
f01053de:	8b 52 08             	mov    0x8(%edx),%edx
f01053e1:	89 50 08             	mov    %edx,0x8(%eax)
f01053e4:	eb 15                	jmp    f01053fb <sched_remove_ready+0x114>
f01053e6:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01053eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053ee:	c1 e2 04             	shl    $0x4,%edx
f01053f1:	01 c2                	add    %eax,%edx
f01053f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f6:	8b 40 08             	mov    0x8(%eax),%eax
f01053f9:	89 02                	mov    %eax,(%edx)
f01053fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053fe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105405:	8b 45 08             	mov    0x8(%ebp),%eax
f0105408:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010540f:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105417:	c1 e2 04             	shl    $0x4,%edx
f010541a:	01 d0                	add    %edx,%eax
f010541c:	8b 50 0c             	mov    0xc(%eax),%edx
f010541f:	4a                   	dec    %edx
f0105420:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0105423:	8b 45 08             	mov    0x8(%ebp),%eax
f0105426:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f010542d:	eb 14                	jmp    f0105443 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010542f:	ff 45 f4             	incl   -0xc(%ebp)
f0105432:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f0105437:	0f b6 c0             	movzbl %al,%eax
f010543a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010543d:	0f 8f 0b ff ff ff    	jg     f010534e <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f0105443:	c9                   	leave  
f0105444:	c3                   	ret    

f0105445 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f0105445:	55                   	push   %ebp
f0105446:	89 e5                	mov    %esp,%ebp
f0105448:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010544b:	83 ec 0c             	sub    $0xc,%esp
f010544e:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105453:	e8 d9 a2 00 00       	call   f010f731 <holding_spinlock>
f0105458:	83 c4 10             	add    $0x10,%esp
f010545b:	85 c0                	test   %eax,%eax
f010545d:	75 17                	jne    f0105476 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010545f:	83 ec 04             	sub    $0x4,%esp
f0105462:	68 48 4b 12 f0       	push   $0xf0124b48
f0105467:	68 b0 00 00 00       	push   $0xb0
f010546c:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105471:	e8 c3 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105476:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010547a:	75 19                	jne    f0105495 <sched_insert_new+0x50>
f010547c:	68 89 4b 12 f0       	push   $0xf0124b89
f0105481:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0105486:	68 b3 00 00 00       	push   $0xb3
f010548b:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105495:	8b 45 08             	mov    0x8(%ebp),%eax
f0105498:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010549f:	83 ec 08             	sub    $0x8,%esp
f01054a2:	ff 75 08             	pushl  0x8(%ebp)
f01054a5:	68 30 b3 6b f0       	push   $0xf06bb330
f01054aa:	e8 fb fa ff ff       	call   f0104faa <enqueue>
f01054af:	83 c4 10             	add    $0x10,%esp
	}
}
f01054b2:	90                   	nop
f01054b3:	c9                   	leave  
f01054b4:	c3                   	ret    

f01054b5 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f01054b5:	55                   	push   %ebp
f01054b6:	89 e5                	mov    %esp,%ebp
f01054b8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054bb:	83 ec 0c             	sub    $0xc,%esp
f01054be:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f01054c3:	e8 69 a2 00 00       	call   f010f731 <holding_spinlock>
f01054c8:	83 c4 10             	add    $0x10,%esp
f01054cb:	85 c0                	test   %eax,%eax
f01054cd:	75 17                	jne    f01054e6 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054cf:	83 ec 04             	sub    $0x4,%esp
f01054d2:	68 48 4b 12 f0       	push   $0xf0124b48
f01054d7:	68 c1 00 00 00       	push   $0xc1
f01054dc:	68 eb 4a 12 f0       	push   $0xf0124aeb
f01054e1:	e8 53 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f01054e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054ea:	74 0b                	je     f01054f7 <sched_remove_new+0x42>
f01054ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01054ef:	8b 40 18             	mov    0x18(%eax),%eax
f01054f2:	83 f8 04             	cmp    $0x4,%eax
f01054f5:	74 19                	je     f0105510 <sched_remove_new+0x5b>
f01054f7:	68 c4 4b 12 f0       	push   $0xf0124bc4
f01054fc:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0105501:	68 c4 00 00 00       	push   $0xc4
f0105506:	68 eb 4a 12 f0       	push   $0xf0124aeb
f010550b:	e8 29 ae ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0105510:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105514:	75 17                	jne    f010552d <sched_remove_new+0x78>
f0105516:	83 ec 04             	sub    $0x4,%esp
f0105519:	68 27 4b 12 f0       	push   $0xf0124b27
f010551e:	68 c6 00 00 00       	push   $0xc6
f0105523:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105528:	e8 0c ae ff ff       	call   f0100339 <_panic>
f010552d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105530:	8b 40 08             	mov    0x8(%eax),%eax
f0105533:	85 c0                	test   %eax,%eax
f0105535:	74 11                	je     f0105548 <sched_remove_new+0x93>
f0105537:	8b 45 08             	mov    0x8(%ebp),%eax
f010553a:	8b 40 08             	mov    0x8(%eax),%eax
f010553d:	8b 55 08             	mov    0x8(%ebp),%edx
f0105540:	8b 52 0c             	mov    0xc(%edx),%edx
f0105543:	89 50 0c             	mov    %edx,0xc(%eax)
f0105546:	eb 0b                	jmp    f0105553 <sched_remove_new+0x9e>
f0105548:	8b 45 08             	mov    0x8(%ebp),%eax
f010554b:	8b 40 0c             	mov    0xc(%eax),%eax
f010554e:	a3 34 b3 6b f0       	mov    %eax,0xf06bb334
f0105553:	8b 45 08             	mov    0x8(%ebp),%eax
f0105556:	8b 40 0c             	mov    0xc(%eax),%eax
f0105559:	85 c0                	test   %eax,%eax
f010555b:	74 11                	je     f010556e <sched_remove_new+0xb9>
f010555d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105560:	8b 40 0c             	mov    0xc(%eax),%eax
f0105563:	8b 55 08             	mov    0x8(%ebp),%edx
f0105566:	8b 52 08             	mov    0x8(%edx),%edx
f0105569:	89 50 08             	mov    %edx,0x8(%eax)
f010556c:	eb 0b                	jmp    f0105579 <sched_remove_new+0xc4>
f010556e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105571:	8b 40 08             	mov    0x8(%eax),%eax
f0105574:	a3 30 b3 6b f0       	mov    %eax,0xf06bb330
f0105579:	8b 45 08             	mov    0x8(%ebp),%eax
f010557c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105583:	8b 45 08             	mov    0x8(%ebp),%eax
f0105586:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010558d:	a1 3c b3 6b f0       	mov    0xf06bb33c,%eax
f0105592:	48                   	dec    %eax
f0105593:	a3 3c b3 6b f0       	mov    %eax,0xf06bb33c
		env->env_status = ENV_UNKNOWN;
f0105598:	8b 45 08             	mov    0x8(%ebp),%eax
f010559b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01055a2:	90                   	nop
f01055a3:	c9                   	leave  
f01055a4:	c3                   	ret    

f01055a5 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f01055a5:	55                   	push   %ebp
f01055a6:	89 e5                	mov    %esp,%ebp
f01055a8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055ab:	83 ec 0c             	sub    $0xc,%esp
f01055ae:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f01055b3:	e8 79 a1 00 00       	call   f010f731 <holding_spinlock>
f01055b8:	83 c4 10             	add    $0x10,%esp
f01055bb:	85 c0                	test   %eax,%eax
f01055bd:	75 17                	jne    f01055d6 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055bf:	83 ec 04             	sub    $0x4,%esp
f01055c2:	68 48 4b 12 f0       	push   $0xf0124b48
f01055c7:	68 d2 00 00 00       	push   $0xd2
f01055cc:	68 eb 4a 12 f0       	push   $0xf0124aeb
f01055d1:	e8 63 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01055d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055da:	75 19                	jne    f01055f5 <sched_insert_exit+0x50>
f01055dc:	68 89 4b 12 f0       	push   $0xf0124b89
f01055e1:	68 d6 4a 12 f0       	push   $0xf0124ad6
f01055e6:	68 d5 00 00 00       	push   $0xd5
f01055eb:	68 eb 4a 12 f0       	push   $0xf0124aeb
f01055f0:	e8 44 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f01055f5:	e8 8e 99 00 00       	call   f010ef88 <isBufferingEnabled>
f01055fa:	84 c0                	test   %al,%al
f01055fc:	74 0e                	je     f010560c <sched_insert_exit+0x67>
f01055fe:	83 ec 0c             	sub    $0xc,%esp
f0105601:	ff 75 08             	pushl  0x8(%ebp)
f0105604:	e8 03 6f 00 00       	call   f010c50c <cleanup_buffers>
f0105609:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010560c:	8b 45 08             	mov    0x8(%ebp),%eax
f010560f:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105616:	83 ec 08             	sub    $0x8,%esp
f0105619:	ff 75 08             	pushl  0x8(%ebp)
f010561c:	68 40 b3 6b f0       	push   $0xf06bb340
f0105621:	e8 84 f9 ff ff       	call   f0104faa <enqueue>
f0105626:	83 c4 10             	add    $0x10,%esp
	}
}
f0105629:	90                   	nop
f010562a:	c9                   	leave  
f010562b:	c3                   	ret    

f010562c <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f010562c:	55                   	push   %ebp
f010562d:	89 e5                	mov    %esp,%ebp
f010562f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105632:	83 ec 0c             	sub    $0xc,%esp
f0105635:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010563a:	e8 f2 a0 00 00       	call   f010f731 <holding_spinlock>
f010563f:	83 c4 10             	add    $0x10,%esp
f0105642:	85 c0                	test   %eax,%eax
f0105644:	75 17                	jne    f010565d <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105646:	83 ec 04             	sub    $0x4,%esp
f0105649:	68 48 4b 12 f0       	push   $0xf0124b48
f010564e:	68 e3 00 00 00       	push   $0xe3
f0105653:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105658:	e8 dc ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f010565d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105661:	74 0b                	je     f010566e <sched_remove_exit+0x42>
f0105663:	8b 45 08             	mov    0x8(%ebp),%eax
f0105666:	8b 40 18             	mov    0x18(%eax),%eax
f0105669:	83 f8 05             	cmp    $0x5,%eax
f010566c:	74 19                	je     f0105687 <sched_remove_exit+0x5b>
f010566e:	68 f0 4b 12 f0       	push   $0xf0124bf0
f0105673:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0105678:	68 e6 00 00 00       	push   $0xe6
f010567d:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105682:	e8 b2 ac ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105687:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010568b:	75 17                	jne    f01056a4 <sched_remove_exit+0x78>
f010568d:	83 ec 04             	sub    $0x4,%esp
f0105690:	68 27 4b 12 f0       	push   $0xf0124b27
f0105695:	68 e8 00 00 00       	push   $0xe8
f010569a:	68 eb 4a 12 f0       	push   $0xf0124aeb
f010569f:	e8 95 ac ff ff       	call   f0100339 <_panic>
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 08             	mov    0x8(%eax),%eax
f01056aa:	85 c0                	test   %eax,%eax
f01056ac:	74 11                	je     f01056bf <sched_remove_exit+0x93>
f01056ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b1:	8b 40 08             	mov    0x8(%eax),%eax
f01056b4:	8b 55 08             	mov    0x8(%ebp),%edx
f01056b7:	8b 52 0c             	mov    0xc(%edx),%edx
f01056ba:	89 50 0c             	mov    %edx,0xc(%eax)
f01056bd:	eb 0b                	jmp    f01056ca <sched_remove_exit+0x9e>
f01056bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01056c2:	8b 40 0c             	mov    0xc(%eax),%eax
f01056c5:	a3 44 b3 6b f0       	mov    %eax,0xf06bb344
f01056ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01056cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	74 11                	je     f01056e5 <sched_remove_exit+0xb9>
f01056d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056d7:	8b 40 0c             	mov    0xc(%eax),%eax
f01056da:	8b 55 08             	mov    0x8(%ebp),%edx
f01056dd:	8b 52 08             	mov    0x8(%edx),%edx
f01056e0:	89 50 08             	mov    %edx,0x8(%eax)
f01056e3:	eb 0b                	jmp    f01056f0 <sched_remove_exit+0xc4>
f01056e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e8:	8b 40 08             	mov    0x8(%eax),%eax
f01056eb:	a3 40 b3 6b f0       	mov    %eax,0xf06bb340
f01056f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01056fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01056fd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105704:	a1 4c b3 6b f0       	mov    0xf06bb34c,%eax
f0105709:	48                   	dec    %eax
f010570a:	a3 4c b3 6b f0       	mov    %eax,0xf06bb34c
		env->env_status = ENV_UNKNOWN;
f010570f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105712:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105719:	90                   	nop
f010571a:	c9                   	leave  
f010571b:	c3                   	ret    

f010571c <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f010571c:	55                   	push   %ebp
f010571d:	89 e5                	mov    %esp,%ebp
f010571f:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105722:	83 ec 0c             	sub    $0xc,%esp
f0105725:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010572a:	e8 e9 9d 00 00       	call   f010f518 <acquire_spinlock>
f010572f:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f0105732:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105736:	75 19                	jne    f0105751 <sched_new_env+0x35>
f0105738:	68 1b 4c 12 f0       	push   $0xf0124c1b
f010573d:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0105742:	68 f6 00 00 00       	push   $0xf6
f0105747:	68 eb 4a 12 f0       	push   $0xf0124aeb
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f0105751:	83 ec 0c             	sub    $0xc,%esp
f0105754:	ff 75 08             	pushl  0x8(%ebp)
f0105757:	e8 e9 fc ff ff       	call   f0105445 <sched_insert_new>
f010575c:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010575f:	83 ec 0c             	sub    $0xc,%esp
f0105762:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105767:	e8 33 9e 00 00       	call   f010f59f <release_spinlock>
f010576c:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f010576f:	90                   	nop
f0105770:	c9                   	leave  
f0105771:	c3                   	ret    

f0105772 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105772:	55                   	push   %ebp
f0105773:	89 e5                	mov    %esp,%ebp
f0105775:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105778:	83 ec 0c             	sub    $0xc,%esp
f010577b:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105780:	e8 93 9d 00 00       	call   f010f518 <acquire_spinlock>
f0105785:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010578f:	a1 30 b3 6b f0       	mov    0xf06bb330,%eax
f0105794:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105797:	eb 53                	jmp    f01057ec <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105799:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010579c:	8b 40 10             	mov    0x10(%eax),%eax
f010579f:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057a2:	75 40                	jne    f01057e4 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f01057a4:	83 ec 0c             	sub    $0xc,%esp
f01057a7:	ff 75 f4             	pushl  -0xc(%ebp)
f01057aa:	e8 06 fd ff ff       	call   f01054b5 <sched_remove_new>
f01057af:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f01057b2:	83 ec 0c             	sub    $0xc,%esp
f01057b5:	ff 75 f4             	pushl  -0xc(%ebp)
f01057b8:	e8 b9 fa ff ff       	call   f0105276 <sched_insert_ready0>
f01057bd:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f01057c0:	e8 47 19 00 00       	call   f010710c <mycpu>
f01057c5:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01057cb:	85 c0                	test   %eax,%eax
f01057cd:	75 46                	jne    f0105815 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057cf:	83 ec 0c             	sub    $0xc,%esp
f01057d2:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f01057d7:	e8 c3 9d 00 00       	call   f010f59f <release_spinlock>
f01057dc:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f01057df:	e8 ad 0f 00 00       	call   f0106791 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057e4:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f01057e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057f0:	74 08                	je     f01057fa <sched_run_env+0x88>
f01057f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057f5:	8b 40 08             	mov    0x8(%eax),%eax
f01057f8:	eb 05                	jmp    f01057ff <sched_run_env+0x8d>
f01057fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01057ff:	a3 38 b3 6b f0       	mov    %eax,0xf06bb338
f0105804:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f0105809:	85 c0                	test   %eax,%eax
f010580b:	75 8c                	jne    f0105799 <sched_run_env+0x27>
f010580d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105811:	75 86                	jne    f0105799 <sched_run_env+0x27>
f0105813:	eb 01                	jmp    f0105816 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105815:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010581e:	e8 7c 9d 00 00       	call   f010f59f <release_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105826:	90                   	nop
f0105827:	c9                   	leave  
f0105828:	c3                   	ret    

f0105829 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105829:	55                   	push   %ebp
f010582a:	89 e5                	mov    %esp,%ebp
f010582c:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f010582f:	83 ec 0c             	sub    $0xc,%esp
f0105832:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105837:	e8 f5 9e 00 00       	call   f010f731 <holding_spinlock>
f010583c:	83 c4 10             	add    $0x10,%esp
f010583f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105842:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105846:	75 10                	jne    f0105858 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105848:	83 ec 0c             	sub    $0xc,%esp
f010584b:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105850:	e8 c3 9c 00 00       	call   f010f518 <acquire_spinlock>
f0105855:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105858:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f010585f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105866:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010586a:	75 59                	jne    f01058c5 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010586c:	a1 30 b3 6b f0       	mov    0xf06bb330,%eax
f0105871:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105874:	eb 28                	jmp    f010589e <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105876:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105879:	8b 40 10             	mov    0x10(%eax),%eax
f010587c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010587f:	75 15                	jne    f0105896 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105881:	83 ec 0c             	sub    $0xc,%esp
f0105884:	ff 75 f4             	pushl  -0xc(%ebp)
f0105887:	e8 29 fc ff ff       	call   f01054b5 <sched_remove_new>
f010588c:	83 c4 10             	add    $0x10,%esp
				found = 1;
f010588f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105896:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f010589b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010589e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058a2:	74 08                	je     f01058ac <sched_exit_env+0x83>
f01058a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058a7:	8b 40 08             	mov    0x8(%eax),%eax
f01058aa:	eb 05                	jmp    f01058b1 <sched_exit_env+0x88>
f01058ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01058b1:	a3 38 b3 6b f0       	mov    %eax,0xf06bb338
f01058b6:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f01058bb:	85 c0                	test   %eax,%eax
f01058bd:	75 b7                	jne    f0105876 <sched_exit_env+0x4d>
f01058bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058c3:	75 b1                	jne    f0105876 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f01058c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01058c9:	0f 85 67 01 00 00    	jne    f0105a36 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01058cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01058d6:	e9 47 01 00 00       	jmp    f0105a22 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01058db:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01058e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058e3:	c1 e2 04             	shl    $0x4,%edx
f01058e6:	01 d0                	add    %edx,%eax
f01058e8:	8b 00                	mov    (%eax),%eax
f01058ea:	85 c0                	test   %eax,%eax
f01058ec:	0f 84 27 01 00 00    	je     f0105a19 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f01058f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01058f9:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01058fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105901:	c1 e2 04             	shl    $0x4,%edx
f0105904:	01 d0                	add    %edx,%eax
f0105906:	8b 00                	mov    (%eax),%eax
f0105908:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010590b:	e9 d1 00 00 00       	jmp    f01059e1 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105910:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105913:	8b 40 10             	mov    0x10(%eax),%eax
f0105916:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105919:	0f 85 af 00 00 00    	jne    f01059ce <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010591f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105923:	75 17                	jne    f010593c <sched_exit_env+0x113>
f0105925:	83 ec 04             	sub    $0x4,%esp
f0105928:	68 27 4b 12 f0       	push   $0xf0124b27
f010592d:	68 44 01 00 00       	push   $0x144
f0105932:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105937:	e8 fd a9 ff ff       	call   f0100339 <_panic>
f010593c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010593f:	8b 40 08             	mov    0x8(%eax),%eax
f0105942:	85 c0                	test   %eax,%eax
f0105944:	74 11                	je     f0105957 <sched_exit_env+0x12e>
f0105946:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105949:	8b 40 08             	mov    0x8(%eax),%eax
f010594c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010594f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105952:	89 50 0c             	mov    %edx,0xc(%eax)
f0105955:	eb 16                	jmp    f010596d <sched_exit_env+0x144>
f0105957:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f010595c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010595f:	c1 e2 04             	shl    $0x4,%edx
f0105962:	01 c2                	add    %eax,%edx
f0105964:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105967:	8b 40 0c             	mov    0xc(%eax),%eax
f010596a:	89 42 04             	mov    %eax,0x4(%edx)
f010596d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105970:	8b 40 0c             	mov    0xc(%eax),%eax
f0105973:	85 c0                	test   %eax,%eax
f0105975:	74 11                	je     f0105988 <sched_exit_env+0x15f>
f0105977:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010597a:	8b 40 0c             	mov    0xc(%eax),%eax
f010597d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105980:	8b 52 08             	mov    0x8(%edx),%edx
f0105983:	89 50 08             	mov    %edx,0x8(%eax)
f0105986:	eb 15                	jmp    f010599d <sched_exit_env+0x174>
f0105988:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f010598d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105990:	c1 e2 04             	shl    $0x4,%edx
f0105993:	01 c2                	add    %eax,%edx
f0105995:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105998:	8b 40 08             	mov    0x8(%eax),%eax
f010599b:	89 02                	mov    %eax,(%edx)
f010599d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01059a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059aa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01059b1:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01059b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059b9:	c1 e2 04             	shl    $0x4,%edx
f01059bc:	01 d0                	add    %edx,%eax
f01059be:	8b 50 0c             	mov    0xc(%eax),%edx
f01059c1:	4a                   	dec    %edx
f01059c2:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f01059c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f01059cc:	eb 4b                	jmp    f0105a19 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01059ce:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01059d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059d6:	c1 e2 04             	shl    $0x4,%edx
f01059d9:	01 d0                	add    %edx,%eax
f01059db:	8b 40 08             	mov    0x8(%eax),%eax
f01059de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01059e1:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01059e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059e9:	c1 e2 04             	shl    $0x4,%edx
f01059ec:	01 d0                	add    %edx,%eax
f01059ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059f2:	74 08                	je     f01059fc <sched_exit_env+0x1d3>
f01059f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059f7:	8b 52 08             	mov    0x8(%edx),%edx
f01059fa:	eb 05                	jmp    f0105a01 <sched_exit_env+0x1d8>
f01059fc:	ba 00 00 00 00       	mov    $0x0,%edx
f0105a01:	89 50 08             	mov    %edx,0x8(%eax)
f0105a04:	8b 40 08             	mov    0x8(%eax),%eax
f0105a07:	85 c0                	test   %eax,%eax
f0105a09:	0f 85 01 ff ff ff    	jne    f0105910 <sched_exit_env+0xe7>
f0105a0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a13:	0f 85 f7 fe ff ff    	jne    f0105910 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a1d:	75 16                	jne    f0105a35 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105a1f:	ff 45 ec             	incl   -0x14(%ebp)
f0105a22:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f0105a27:	0f b6 c0             	movzbl %al,%eax
f0105a2a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105a2d:	0f 8f a8 fe ff ff    	jg     f01058db <sched_exit_env+0xb2>
f0105a33:	eb 01                	jmp    f0105a36 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a35:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105a36:	e8 4f 58 00 00       	call   f010b28a <get_cpu_proc>
f0105a3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105a3e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105a42:	75 19                	jne    f0105a5d <sched_exit_env+0x234>
f0105a44:	68 23 4c 12 f0       	push   $0xf0124c23
f0105a49:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0105a4e:	68 4e 01 00 00       	push   $0x14e
f0105a53:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105a58:	e8 dc a8 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105a5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a61:	75 18                	jne    f0105a7b <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a66:	8b 40 10             	mov    0x10(%eax),%eax
f0105a69:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a6c:	75 0d                	jne    f0105a7b <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a74:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a7f:	74 1e                	je     f0105a9f <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a87:	e8 19 fb ff ff       	call   f01055a5 <sched_insert_exit>
f0105a8c:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a92:	8b 40 10             	mov    0x10(%eax),%eax
f0105a95:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a98:	75 05                	jne    f0105a9f <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a9a:	e8 6c 59 00 00       	call   f010b40b <sched>
		}
	}
	if (!lock_already_held)
f0105a9f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105aa3:	75 10                	jne    f0105ab5 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105aa5:	83 ec 0c             	sub    $0xc,%esp
f0105aa8:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105aad:	e8 ed 9a 00 00       	call   f010f59f <release_spinlock>
f0105ab2:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105ab5:	90                   	nop
f0105ab6:	c9                   	leave  
f0105ab7:	c3                   	ret    

f0105ab8 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105ab8:	55                   	push   %ebp
f0105ab9:	89 e5                	mov    %esp,%ebp
f0105abb:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105abe:	83 ec 0c             	sub    $0xc,%esp
f0105ac1:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105ac6:	e8 4d 9a 00 00       	call   f010f518 <acquire_spinlock>
f0105acb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105ace:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105ad5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105adc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ae0:	75 79                	jne    f0105b5b <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ae2:	a1 30 b3 6b f0       	mov    0xf06bb330,%eax
f0105ae7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105aea:	eb 48                	jmp    f0105b34 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aef:	8b 40 10             	mov    0x10(%eax),%eax
f0105af2:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105af5:	75 35                	jne    f0105b2c <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105afa:	8d 50 20             	lea    0x20(%eax),%edx
f0105afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b00:	8b 40 10             	mov    0x10(%eax),%eax
f0105b03:	83 ec 04             	sub    $0x4,%esp
f0105b06:	52                   	push   %edx
f0105b07:	50                   	push   %eax
f0105b08:	68 34 4c 12 f0       	push   $0xf0124c34
f0105b0d:	e8 79 b4 ff ff       	call   f0100f8b <cprintf>
f0105b12:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105b15:	83 ec 0c             	sub    $0xc,%esp
f0105b18:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b1b:	e8 95 f9 ff ff       	call   f01054b5 <sched_remove_new>
f0105b20:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105b23:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105b2a:	eb 2f                	jmp    f0105b5b <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b2c:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f0105b31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b38:	74 08                	je     f0105b42 <sched_kill_env+0x8a>
f0105b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b3d:	8b 40 08             	mov    0x8(%eax),%eax
f0105b40:	eb 05                	jmp    f0105b47 <sched_kill_env+0x8f>
f0105b42:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b47:	a3 38 b3 6b f0       	mov    %eax,0xf06bb338
f0105b4c:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f0105b51:	85 c0                	test   %eax,%eax
f0105b53:	75 97                	jne    f0105aec <sched_kill_env+0x34>
f0105b55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b59:	75 91                	jne    f0105aec <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105b5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b5f:	0f 85 85 01 00 00    	jne    f0105cea <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b6c:	e9 65 01 00 00       	jmp    f0105cd6 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b71:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105b76:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b79:	c1 e2 04             	shl    $0x4,%edx
f0105b7c:	01 d0                	add    %edx,%eax
f0105b7e:	8b 00                	mov    (%eax),%eax
f0105b80:	85 c0                	test   %eax,%eax
f0105b82:	0f 84 45 01 00 00    	je     f0105ccd <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105b88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b8f:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b97:	c1 e2 04             	shl    $0x4,%edx
f0105b9a:	01 d0                	add    %edx,%eax
f0105b9c:	8b 00                	mov    (%eax),%eax
f0105b9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ba1:	e9 ef 00 00 00       	jmp    f0105c95 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba9:	8b 40 10             	mov    0x10(%eax),%eax
f0105bac:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105baf:	0f 85 cd 00 00 00    	jne    f0105c82 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb8:	8d 50 20             	lea    0x20(%eax),%edx
f0105bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bbe:	8b 40 10             	mov    0x10(%eax),%eax
f0105bc1:	ff 75 ec             	pushl  -0x14(%ebp)
f0105bc4:	52                   	push   %edx
f0105bc5:	50                   	push   %eax
f0105bc6:	68 5c 4c 12 f0       	push   $0xf0124c5c
f0105bcb:	e8 bb b3 ff ff       	call   f0100f8b <cprintf>
f0105bd0:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105bd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bd7:	75 17                	jne    f0105bf0 <sched_kill_env+0x138>
f0105bd9:	83 ec 04             	sub    $0x4,%esp
f0105bdc:	68 27 4b 12 f0       	push   $0xf0124b27
f0105be1:	68 91 01 00 00       	push   $0x191
f0105be6:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105beb:	e8 49 a7 ff ff       	call   f0100339 <_panic>
f0105bf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf3:	8b 40 08             	mov    0x8(%eax),%eax
f0105bf6:	85 c0                	test   %eax,%eax
f0105bf8:	74 11                	je     f0105c0b <sched_kill_env+0x153>
f0105bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bfd:	8b 40 08             	mov    0x8(%eax),%eax
f0105c00:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c03:	8b 52 0c             	mov    0xc(%edx),%edx
f0105c06:	89 50 0c             	mov    %edx,0xc(%eax)
f0105c09:	eb 16                	jmp    f0105c21 <sched_kill_env+0x169>
f0105c0b:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105c10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c13:	c1 e2 04             	shl    $0x4,%edx
f0105c16:	01 c2                	add    %eax,%edx
f0105c18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c1b:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c1e:	89 42 04             	mov    %eax,0x4(%edx)
f0105c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c24:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c27:	85 c0                	test   %eax,%eax
f0105c29:	74 11                	je     f0105c3c <sched_kill_env+0x184>
f0105c2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c2e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c34:	8b 52 08             	mov    0x8(%edx),%edx
f0105c37:	89 50 08             	mov    %edx,0x8(%eax)
f0105c3a:	eb 15                	jmp    f0105c51 <sched_kill_env+0x199>
f0105c3c:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105c41:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c44:	c1 e2 04             	shl    $0x4,%edx
f0105c47:	01 c2                	add    %eax,%edx
f0105c49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c4c:	8b 40 08             	mov    0x8(%eax),%eax
f0105c4f:	89 02                	mov    %eax,(%edx)
f0105c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c54:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c5e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c65:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105c6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c6d:	c1 e2 04             	shl    $0x4,%edx
f0105c70:	01 d0                	add    %edx,%eax
f0105c72:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c75:	4a                   	dec    %edx
f0105c76:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c79:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c80:	eb 4b                	jmp    f0105ccd <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c82:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105c87:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c8a:	c1 e2 04             	shl    $0x4,%edx
f0105c8d:	01 d0                	add    %edx,%eax
f0105c8f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c95:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105c9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c9d:	c1 e2 04             	shl    $0x4,%edx
f0105ca0:	01 d0                	add    %edx,%eax
f0105ca2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ca6:	74 08                	je     f0105cb0 <sched_kill_env+0x1f8>
f0105ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cab:	8b 52 08             	mov    0x8(%edx),%edx
f0105cae:	eb 05                	jmp    f0105cb5 <sched_kill_env+0x1fd>
f0105cb0:	ba 00 00 00 00       	mov    $0x0,%edx
f0105cb5:	89 50 08             	mov    %edx,0x8(%eax)
f0105cb8:	8b 40 08             	mov    0x8(%eax),%eax
f0105cbb:	85 c0                	test   %eax,%eax
f0105cbd:	0f 85 e3 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
f0105cc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cc7:	0f 85 d9 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105ccd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cd1:	75 16                	jne    f0105ce9 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105cd3:	ff 45 ec             	incl   -0x14(%ebp)
f0105cd6:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f0105cdb:	0f b6 c0             	movzbl %al,%eax
f0105cde:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105ce1:	0f 8f 8a fe ff ff    	jg     f0105b71 <sched_kill_env+0xb9>
f0105ce7:	eb 01                	jmp    f0105cea <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105ce9:	90                   	nop
		}
	}
	if (!found)
f0105cea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cee:	0f 85 80 00 00 00    	jne    f0105d74 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105cf4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cfb:	a1 40 b3 6b f0       	mov    0xf06bb340,%eax
f0105d00:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d03:	eb 48                	jmp    f0105d4d <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105d05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d08:	8b 40 10             	mov    0x10(%eax),%eax
f0105d0b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d0e:	75 35                	jne    f0105d45 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d13:	8d 50 20             	lea    0x20(%eax),%edx
f0105d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d19:	8b 40 10             	mov    0x10(%eax),%eax
f0105d1c:	83 ec 04             	sub    $0x4,%esp
f0105d1f:	52                   	push   %edx
f0105d20:	50                   	push   %eax
f0105d21:	68 88 4c 12 f0       	push   $0xf0124c88
f0105d26:	e8 60 b2 ff ff       	call   f0100f8b <cprintf>
f0105d2b:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105d2e:	83 ec 0c             	sub    $0xc,%esp
f0105d31:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d34:	e8 f3 f8 ff ff       	call   f010562c <sched_remove_exit>
f0105d39:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d43:	eb 2f                	jmp    f0105d74 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d45:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f0105d4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d51:	74 08                	je     f0105d5b <sched_kill_env+0x2a3>
f0105d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d56:	8b 40 08             	mov    0x8(%eax),%eax
f0105d59:	eb 05                	jmp    f0105d60 <sched_kill_env+0x2a8>
f0105d5b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d60:	a3 48 b3 6b f0       	mov    %eax,0xf06bb348
f0105d65:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f0105d6a:	85 c0                	test   %eax,%eax
f0105d6c:	75 97                	jne    f0105d05 <sched_kill_env+0x24d>
f0105d6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d72:	75 91                	jne    f0105d05 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d74:	83 ec 0c             	sub    $0xc,%esp
f0105d77:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105d7c:	e8 1e 98 00 00       	call   f010f59f <release_spinlock>
f0105d81:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d88:	74 23                	je     f0105dad <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105d8a:	83 ec 0c             	sub    $0xc,%esp
f0105d8d:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d90:	e8 ad 54 00 00       	call   f010b242 <env_free>
f0105d95:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d98:	83 ec 0c             	sub    $0xc,%esp
f0105d9b:	68 ae 4c 12 f0       	push   $0xf0124cae
f0105da0:	e8 e6 b1 ff ff       	call   f0100f8b <cprintf>
f0105da5:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105da8:	e9 a4 00 00 00       	jmp    f0105e51 <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105dad:	e8 d8 54 00 00       	call   f010b28a <get_cpu_proc>
f0105db2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105db5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105db9:	75 19                	jne    f0105dd4 <sched_kill_env+0x31c>
f0105dbb:	68 23 4c 12 f0       	push   $0xf0124c23
f0105dc0:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0105dc5:	68 b3 01 00 00       	push   $0x1b3
f0105dca:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105dcf:	e8 65 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105dd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105dd7:	8b 40 10             	mov    0x10(%eax),%eax
f0105dda:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ddd:	75 72                	jne    f0105e51 <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105ddf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105de2:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105de8:	8b 40 18             	mov    0x18(%eax),%eax
f0105deb:	83 f8 02             	cmp    $0x2,%eax
f0105dee:	74 19                	je     f0105e09 <sched_kill_env+0x351>
f0105df0:	68 b4 4c 12 f0       	push   $0xf0124cb4
f0105df5:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0105dfa:	68 b8 01 00 00       	push   $0x1b8
f0105dff:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0105e04:	e8 30 a5 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e0c:	8d 50 20             	lea    0x20(%eax),%edx
f0105e0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e12:	8b 40 10             	mov    0x10(%eax),%eax
f0105e15:	83 ec 04             	sub    $0x4,%esp
f0105e18:	52                   	push   %edx
f0105e19:	50                   	push   %eax
f0105e1a:	68 d8 4c 12 f0       	push   $0xf0124cd8
f0105e1f:	e8 67 b1 ff ff       	call   f0100f8b <cprintf>
f0105e24:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e27:	83 ec 0c             	sub    $0xc,%esp
f0105e2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e2d:	e8 10 54 00 00       	call   f010b242 <env_free>
f0105e32:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e35:	83 ec 0c             	sub    $0xc,%esp
f0105e38:	68 ae 4c 12 f0       	push   $0xf0124cae
f0105e3d:	e8 49 b1 ff ff       	call   f0100f8b <cprintf>
f0105e42:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105e45:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105e4c:	e8 ba 55 00 00       	call   f010b40b <sched>
		}
	}

}
f0105e51:	90                   	nop
f0105e52:	c9                   	leave  
f0105e53:	c3                   	ret    

f0105e54 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105e54:	55                   	push   %ebp
f0105e55:	89 e5                	mov    %esp,%ebp
f0105e57:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e5a:	83 ec 0c             	sub    $0xc,%esp
f0105e5d:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0105e62:	e8 b1 96 00 00       	call   f010f518 <acquire_spinlock>
f0105e67:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e6a:	a1 30 b3 6b f0       	mov    0xf06bb330,%eax
f0105e6f:	85 c0                	test   %eax,%eax
f0105e71:	74 69                	je     f0105edc <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e73:	83 ec 0c             	sub    $0xc,%esp
f0105e76:	68 04 4d 12 f0       	push   $0xf0124d04
f0105e7b:	e8 0b b1 ff ff       	call   f0100f8b <cprintf>
f0105e80:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e83:	a1 30 b3 6b f0       	mov    0xf06bb330,%eax
f0105e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e8b:	eb 26                	jmp    f0105eb3 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e90:	8d 50 20             	lea    0x20(%eax),%edx
f0105e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e96:	8b 40 10             	mov    0x10(%eax),%eax
f0105e99:	83 ec 04             	sub    $0x4,%esp
f0105e9c:	52                   	push   %edx
f0105e9d:	50                   	push   %eax
f0105e9e:	68 26 4d 12 f0       	push   $0xf0124d26
f0105ea3:	e8 e3 b0 ff ff       	call   f0100f8b <cprintf>
f0105ea8:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105eab:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f0105eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105eb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105eb7:	74 08                	je     f0105ec1 <sched_print_all+0x6d>
f0105eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebc:	8b 40 08             	mov    0x8(%eax),%eax
f0105ebf:	eb 05                	jmp    f0105ec6 <sched_print_all+0x72>
f0105ec1:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ec6:	a3 38 b3 6b f0       	mov    %eax,0xf06bb338
f0105ecb:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f0105ed0:	85 c0                	test   %eax,%eax
f0105ed2:	75 b9                	jne    f0105e8d <sched_print_all+0x39>
f0105ed4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ed8:	75 b3                	jne    f0105e8d <sched_print_all+0x39>
f0105eda:	eb 10                	jmp    f0105eec <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105edc:	83 ec 0c             	sub    $0xc,%esp
f0105edf:	68 30 4d 12 f0       	push   $0xf0124d30
f0105ee4:	e8 a2 b0 ff ff       	call   f0100f8b <cprintf>
f0105ee9:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105eec:	83 ec 0c             	sub    $0xc,%esp
f0105eef:	68 4c 4d 12 f0       	push   $0xf0124d4c
f0105ef4:	e8 92 b0 ff ff       	call   f0100f8b <cprintf>
f0105ef9:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105efc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105f03:	e9 c7 00 00 00       	jmp    f0105fcf <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105f08:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105f0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f10:	c1 e2 04             	shl    $0x4,%edx
f0105f13:	01 d0                	add    %edx,%eax
f0105f15:	8b 00                	mov    (%eax),%eax
f0105f17:	85 c0                	test   %eax,%eax
f0105f19:	0f 84 8a 00 00 00    	je     f0105fa9 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105f1f:	83 ec 08             	sub    $0x8,%esp
f0105f22:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f25:	68 80 4d 12 f0       	push   $0xf0124d80
f0105f2a:	e8 5c b0 ff ff       	call   f0100f8b <cprintf>
f0105f2f:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f32:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105f37:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f3a:	c1 e2 04             	shl    $0x4,%edx
f0105f3d:	01 d0                	add    %edx,%eax
f0105f3f:	8b 00                	mov    (%eax),%eax
f0105f41:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f44:	eb 31                	jmp    f0105f77 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f49:	8d 50 20             	lea    0x20(%eax),%edx
f0105f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f4f:	8b 40 10             	mov    0x10(%eax),%eax
f0105f52:	83 ec 04             	sub    $0x4,%esp
f0105f55:	52                   	push   %edx
f0105f56:	50                   	push   %eax
f0105f57:	68 26 4d 12 f0       	push   $0xf0124d26
f0105f5c:	e8 2a b0 ff ff       	call   f0100f8b <cprintf>
f0105f61:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f64:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105f69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f6c:	c1 e2 04             	shl    $0x4,%edx
f0105f6f:	01 d0                	add    %edx,%eax
f0105f71:	8b 40 08             	mov    0x8(%eax),%eax
f0105f74:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f77:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0105f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f7f:	c1 e2 04             	shl    $0x4,%edx
f0105f82:	01 d0                	add    %edx,%eax
f0105f84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f88:	74 08                	je     f0105f92 <sched_print_all+0x13e>
f0105f8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f8d:	8b 52 08             	mov    0x8(%edx),%edx
f0105f90:	eb 05                	jmp    f0105f97 <sched_print_all+0x143>
f0105f92:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f97:	89 50 08             	mov    %edx,0x8(%eax)
f0105f9a:	8b 40 08             	mov    0x8(%eax),%eax
f0105f9d:	85 c0                	test   %eax,%eax
f0105f9f:	75 a5                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fa5:	75 9f                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa7:	eb 13                	jmp    f0105fbc <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105fa9:	83 ec 08             	sub    $0x8,%esp
f0105fac:	ff 75 f0             	pushl  -0x10(%ebp)
f0105faf:	68 a8 4d 12 f0       	push   $0xf0124da8
f0105fb4:	e8 d2 af ff ff       	call   f0100f8b <cprintf>
f0105fb9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105fbc:	83 ec 0c             	sub    $0xc,%esp
f0105fbf:	68 4c 4d 12 f0       	push   $0xf0124d4c
f0105fc4:	e8 c2 af ff ff       	call   f0100f8b <cprintf>
f0105fc9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105fcc:	ff 45 f0             	incl   -0x10(%ebp)
f0105fcf:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f0105fd4:	0f b6 c0             	movzbl %al,%eax
f0105fd7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105fda:	0f 8f 28 ff ff ff    	jg     f0105f08 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105fe0:	a1 40 b3 6b f0       	mov    0xf06bb340,%eax
f0105fe5:	85 c0                	test   %eax,%eax
f0105fe7:	74 69                	je     f0106052 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105fe9:	83 ec 0c             	sub    $0xc,%esp
f0105fec:	68 cc 4d 12 f0       	push   $0xf0124dcc
f0105ff1:	e8 95 af ff ff       	call   f0100f8b <cprintf>
f0105ff6:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ff9:	a1 40 b3 6b f0       	mov    0xf06bb340,%eax
f0105ffe:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106001:	eb 26                	jmp    f0106029 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106006:	8d 50 20             	lea    0x20(%eax),%edx
f0106009:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010600c:	8b 40 10             	mov    0x10(%eax),%eax
f010600f:	83 ec 04             	sub    $0x4,%esp
f0106012:	52                   	push   %edx
f0106013:	50                   	push   %eax
f0106014:	68 26 4d 12 f0       	push   $0xf0124d26
f0106019:	e8 6d af ff ff       	call   f0100f8b <cprintf>
f010601e:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106021:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f0106026:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106029:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010602d:	74 08                	je     f0106037 <sched_print_all+0x1e3>
f010602f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106032:	8b 40 08             	mov    0x8(%eax),%eax
f0106035:	eb 05                	jmp    f010603c <sched_print_all+0x1e8>
f0106037:	b8 00 00 00 00       	mov    $0x0,%eax
f010603c:	a3 48 b3 6b f0       	mov    %eax,0xf06bb348
f0106041:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f0106046:	85 c0                	test   %eax,%eax
f0106048:	75 b9                	jne    f0106003 <sched_print_all+0x1af>
f010604a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010604e:	75 b3                	jne    f0106003 <sched_print_all+0x1af>
f0106050:	eb 10                	jmp    f0106062 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106052:	83 ec 0c             	sub    $0xc,%esp
f0106055:	68 ee 4d 12 f0       	push   $0xf0124dee
f010605a:	e8 2c af ff ff       	call   f0100f8b <cprintf>
f010605f:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106062:	83 ec 0c             	sub    $0xc,%esp
f0106065:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010606a:	e8 30 95 00 00       	call   f010f59f <release_spinlock>
f010606f:	83 c4 10             	add    $0x10,%esp
}
f0106072:	90                   	nop
f0106073:	c9                   	leave  
f0106074:	c3                   	ret    

f0106075 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106075:	55                   	push   %ebp
f0106076:	89 e5                	mov    %esp,%ebp
f0106078:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010607b:	83 ec 0c             	sub    $0xc,%esp
f010607e:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0106083:	e8 90 94 00 00       	call   f010f518 <acquire_spinlock>
f0106088:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010608b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106092:	a1 3c b3 6b f0       	mov    0xf06bb33c,%eax
f0106097:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010609a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01060a1:	eb 24                	jmp    f01060c7 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f01060a3:	83 ec 0c             	sub    $0xc,%esp
f01060a6:	68 30 b3 6b f0       	push   $0xf06bb330
f01060ab:	e8 8b ef ff ff       	call   f010503b <dequeue>
f01060b0:	83 c4 10             	add    $0x10,%esp
f01060b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f01060b6:	83 ec 0c             	sub    $0xc,%esp
f01060b9:	ff 75 f0             	pushl  -0x10(%ebp)
f01060bc:	e8 b5 f1 ff ff       	call   f0105276 <sched_insert_ready0>
f01060c1:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f01060c4:	ff 45 f4             	incl   -0xc(%ebp)
f01060c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ca:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01060cd:	7c d4                	jl     f01060a3 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060cf:	83 ec 0c             	sub    $0xc,%esp
f01060d2:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f01060d7:	e8 c3 94 00 00       	call   f010f59f <release_spinlock>
f01060dc:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f01060df:	e8 28 10 00 00       	call   f010710c <mycpu>
f01060e4:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01060ea:	85 c0                	test   %eax,%eax
f01060ec:	75 05                	jne    f01060f3 <sched_run_all+0x7e>
		fos_scheduler();
f01060ee:	e8 9e 06 00 00       	call   f0106791 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f01060f3:	83 ec 04             	sub    $0x4,%esp
f01060f6:	68 0c 4e 12 f0       	push   $0xf0124e0c
f01060fb:	68 15 02 00 00       	push   $0x215
f0106100:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0106105:	e8 2f a2 ff ff       	call   f0100339 <_panic>

f010610a <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010610a:	55                   	push   %ebp
f010610b:	89 e5                	mov    %esp,%ebp
f010610d:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106110:	83 ec 0c             	sub    $0xc,%esp
f0106113:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0106118:	e8 fb 93 00 00       	call   f010f518 <acquire_spinlock>
f010611d:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106120:	a1 30 b3 6b f0       	mov    0xf06bb330,%eax
f0106125:	85 c0                	test   %eax,%eax
f0106127:	0f 84 95 00 00 00    	je     f01061c2 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f010612d:	83 ec 0c             	sub    $0xc,%esp
f0106130:	68 48 4e 12 f0       	push   $0xf0124e48
f0106135:	e8 51 ae ff ff       	call   f0100f8b <cprintf>
f010613a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010613d:	a1 30 b3 6b f0       	mov    0xf06bb330,%eax
f0106142:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106145:	eb 52                	jmp    f0106199 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106147:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010614a:	8d 50 20             	lea    0x20(%eax),%edx
f010614d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106150:	8b 40 10             	mov    0x10(%eax),%eax
f0106153:	83 ec 04             	sub    $0x4,%esp
f0106156:	52                   	push   %edx
f0106157:	50                   	push   %eax
f0106158:	68 74 4e 12 f0       	push   $0xf0124e74
f010615d:	e8 29 ae ff ff       	call   f0100f8b <cprintf>
f0106162:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106165:	83 ec 0c             	sub    $0xc,%esp
f0106168:	ff 75 f4             	pushl  -0xc(%ebp)
f010616b:	e8 45 f3 ff ff       	call   f01054b5 <sched_remove_new>
f0106170:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106173:	83 ec 0c             	sub    $0xc,%esp
f0106176:	ff 75 f4             	pushl  -0xc(%ebp)
f0106179:	e8 c4 50 00 00       	call   f010b242 <env_free>
f010617e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106181:	83 ec 0c             	sub    $0xc,%esp
f0106184:	68 ae 4c 12 f0       	push   $0xf0124cae
f0106189:	e8 fd ad ff ff       	call   f0100f8b <cprintf>
f010618e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106191:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f0106196:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106199:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010619d:	74 08                	je     f01061a7 <sched_kill_all+0x9d>
f010619f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061a2:	8b 40 08             	mov    0x8(%eax),%eax
f01061a5:	eb 05                	jmp    f01061ac <sched_kill_all+0xa2>
f01061a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01061ac:	a3 38 b3 6b f0       	mov    %eax,0xf06bb338
f01061b1:	a1 38 b3 6b f0       	mov    0xf06bb338,%eax
f01061b6:	85 c0                	test   %eax,%eax
f01061b8:	75 8d                	jne    f0106147 <sched_kill_all+0x3d>
f01061ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061be:	75 87                	jne    f0106147 <sched_kill_all+0x3d>
f01061c0:	eb 10                	jmp    f01061d2 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f01061c2:	83 ec 0c             	sub    $0xc,%esp
f01061c5:	68 87 4e 12 f0       	push   $0xf0124e87
f01061ca:	e8 bc ad ff ff       	call   f0100f8b <cprintf>
f01061cf:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f01061d2:	83 ec 0c             	sub    $0xc,%esp
f01061d5:	68 4c 4d 12 f0       	push   $0xf0124d4c
f01061da:	e8 ac ad ff ff       	call   f0100f8b <cprintf>
f01061df:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01061e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01061e9:	e9 96 01 00 00       	jmp    f0106384 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061ee:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01061f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061f6:	c1 e2 04             	shl    $0x4,%edx
f01061f9:	01 d0                	add    %edx,%eax
f01061fb:	8b 00                	mov    (%eax),%eax
f01061fd:	85 c0                	test   %eax,%eax
f01061ff:	0f 84 59 01 00 00    	je     f010635e <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106205:	83 ec 08             	sub    $0x8,%esp
f0106208:	ff 75 f0             	pushl  -0x10(%ebp)
f010620b:	68 a4 4e 12 f0       	push   $0xf0124ea4
f0106210:	e8 76 ad ff ff       	call   f0100f8b <cprintf>
f0106215:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106218:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f010621d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106220:	c1 e2 04             	shl    $0x4,%edx
f0106223:	01 d0                	add    %edx,%eax
f0106225:	8b 00                	mov    (%eax),%eax
f0106227:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010622a:	e9 f5 00 00 00       	jmp    f0106324 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010622f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106232:	8d 50 20             	lea    0x20(%eax),%edx
f0106235:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106238:	8b 40 10             	mov    0x10(%eax),%eax
f010623b:	83 ec 04             	sub    $0x4,%esp
f010623e:	52                   	push   %edx
f010623f:	50                   	push   %eax
f0106240:	68 74 4e 12 f0       	push   $0xf0124e74
f0106245:	e8 41 ad ff ff       	call   f0100f8b <cprintf>
f010624a:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010624d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106251:	75 17                	jne    f010626a <sched_kill_all+0x160>
f0106253:	83 ec 04             	sub    $0x4,%esp
f0106256:	68 27 4b 12 f0       	push   $0xf0124b27
f010625b:	68 37 02 00 00       	push   $0x237
f0106260:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0106265:	e8 cf a0 ff ff       	call   f0100339 <_panic>
f010626a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626d:	8b 40 08             	mov    0x8(%eax),%eax
f0106270:	85 c0                	test   %eax,%eax
f0106272:	74 11                	je     f0106285 <sched_kill_all+0x17b>
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 08             	mov    0x8(%eax),%eax
f010627a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010627d:	8b 52 0c             	mov    0xc(%edx),%edx
f0106280:	89 50 0c             	mov    %edx,0xc(%eax)
f0106283:	eb 16                	jmp    f010629b <sched_kill_all+0x191>
f0106285:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f010628a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010628d:	c1 e2 04             	shl    $0x4,%edx
f0106290:	01 c2                	add    %eax,%edx
f0106292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106295:	8b 40 0c             	mov    0xc(%eax),%eax
f0106298:	89 42 04             	mov    %eax,0x4(%edx)
f010629b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629e:	8b 40 0c             	mov    0xc(%eax),%eax
f01062a1:	85 c0                	test   %eax,%eax
f01062a3:	74 11                	je     f01062b6 <sched_kill_all+0x1ac>
f01062a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01062ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062ae:	8b 52 08             	mov    0x8(%edx),%edx
f01062b1:	89 50 08             	mov    %edx,0x8(%eax)
f01062b4:	eb 15                	jmp    f01062cb <sched_kill_all+0x1c1>
f01062b6:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01062bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062be:	c1 e2 04             	shl    $0x4,%edx
f01062c1:	01 c2                	add    %eax,%edx
f01062c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062c6:	8b 40 08             	mov    0x8(%eax),%eax
f01062c9:	89 02                	mov    %eax,(%edx)
f01062cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062df:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01062e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062e7:	c1 e2 04             	shl    $0x4,%edx
f01062ea:	01 d0                	add    %edx,%eax
f01062ec:	8b 50 0c             	mov    0xc(%eax),%edx
f01062ef:	4a                   	dec    %edx
f01062f0:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f01062f3:	83 ec 0c             	sub    $0xc,%esp
f01062f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01062f9:	e8 44 4f 00 00       	call   f010b242 <env_free>
f01062fe:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106301:	83 ec 0c             	sub    $0xc,%esp
f0106304:	68 ae 4c 12 f0       	push   $0xf0124cae
f0106309:	e8 7d ac ff ff       	call   f0100f8b <cprintf>
f010630e:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106311:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0106316:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106319:	c1 e2 04             	shl    $0x4,%edx
f010631c:	01 d0                	add    %edx,%eax
f010631e:	8b 40 08             	mov    0x8(%eax),%eax
f0106321:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106324:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0106329:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010632c:	c1 e2 04             	shl    $0x4,%edx
f010632f:	01 d0                	add    %edx,%eax
f0106331:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106335:	74 08                	je     f010633f <sched_kill_all+0x235>
f0106337:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010633a:	8b 52 08             	mov    0x8(%edx),%edx
f010633d:	eb 05                	jmp    f0106344 <sched_kill_all+0x23a>
f010633f:	ba 00 00 00 00       	mov    $0x0,%edx
f0106344:	89 50 08             	mov    %edx,0x8(%eax)
f0106347:	8b 40 08             	mov    0x8(%eax),%eax
f010634a:	85 c0                	test   %eax,%eax
f010634c:	0f 85 dd fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f0106352:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106356:	0f 85 d3 fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f010635c:	eb 13                	jmp    f0106371 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010635e:	83 ec 08             	sub    $0x8,%esp
f0106361:	ff 75 f0             	pushl  -0x10(%ebp)
f0106364:	68 a8 4d 12 f0       	push   $0xf0124da8
f0106369:	e8 1d ac ff ff       	call   f0100f8b <cprintf>
f010636e:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106371:	83 ec 0c             	sub    $0xc,%esp
f0106374:	68 4c 4d 12 f0       	push   $0xf0124d4c
f0106379:	e8 0d ac ff ff       	call   f0100f8b <cprintf>
f010637e:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106381:	ff 45 f0             	incl   -0x10(%ebp)
f0106384:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f0106389:	0f b6 c0             	movzbl %al,%eax
f010638c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010638f:	0f 8f 59 fe ff ff    	jg     f01061ee <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106395:	a1 40 b3 6b f0       	mov    0xf06bb340,%eax
f010639a:	85 c0                	test   %eax,%eax
f010639c:	0f 84 95 00 00 00    	je     f0106437 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01063a2:	83 ec 0c             	sub    $0xc,%esp
f01063a5:	68 d8 4e 12 f0       	push   $0xf0124ed8
f01063aa:	e8 dc ab ff ff       	call   f0100f8b <cprintf>
f01063af:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063b2:	a1 40 b3 6b f0       	mov    0xf06bb340,%eax
f01063b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063ba:	eb 52                	jmp    f010640e <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bf:	8d 50 20             	lea    0x20(%eax),%edx
f01063c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063c5:	8b 40 10             	mov    0x10(%eax),%eax
f01063c8:	83 ec 04             	sub    $0x4,%esp
f01063cb:	52                   	push   %edx
f01063cc:	50                   	push   %eax
f01063cd:	68 74 4e 12 f0       	push   $0xf0124e74
f01063d2:	e8 b4 ab ff ff       	call   f0100f8b <cprintf>
f01063d7:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01063da:	83 ec 0c             	sub    $0xc,%esp
f01063dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e0:	e8 47 f2 ff ff       	call   f010562c <sched_remove_exit>
f01063e5:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063e8:	83 ec 0c             	sub    $0xc,%esp
f01063eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01063ee:	e8 4f 4e 00 00       	call   f010b242 <env_free>
f01063f3:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063f6:	83 ec 0c             	sub    $0xc,%esp
f01063f9:	68 ae 4c 12 f0       	push   $0xf0124cae
f01063fe:	e8 88 ab ff ff       	call   f0100f8b <cprintf>
f0106403:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106406:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f010640b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010640e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106412:	74 08                	je     f010641c <sched_kill_all+0x312>
f0106414:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106417:	8b 40 08             	mov    0x8(%eax),%eax
f010641a:	eb 05                	jmp    f0106421 <sched_kill_all+0x317>
f010641c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106421:	a3 48 b3 6b f0       	mov    %eax,0xf06bb348
f0106426:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f010642b:	85 c0                	test   %eax,%eax
f010642d:	75 8d                	jne    f01063bc <sched_kill_all+0x2b2>
f010642f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106433:	75 87                	jne    f01063bc <sched_kill_all+0x2b2>
f0106435:	eb 10                	jmp    f0106447 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106437:	83 ec 0c             	sub    $0xc,%esp
f010643a:	68 ee 4d 12 f0       	push   $0xf0124dee
f010643f:	e8 47 ab ff ff       	call   f0100f8b <cprintf>
f0106444:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106447:	e8 3e 4e 00 00       	call   f010b28a <get_cpu_proc>
f010644c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010644f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106453:	74 6b                	je     f01064c0 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f0106455:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106458:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010645b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010645e:	8b 40 18             	mov    0x18(%eax),%eax
f0106461:	83 f8 02             	cmp    $0x2,%eax
f0106464:	74 19                	je     f010647f <sched_kill_all+0x375>
f0106466:	68 b4 4c 12 f0       	push   $0xf0124cb4
f010646b:	68 d6 4a 12 f0       	push   $0xf0124ad6
f0106470:	68 57 02 00 00       	push   $0x257
f0106475:	68 eb 4a 12 f0       	push   $0xf0124aeb
f010647a:	e8 ba 9e ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010647f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106482:	8d 50 20             	lea    0x20(%eax),%edx
f0106485:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106488:	8b 40 10             	mov    0x10(%eax),%eax
f010648b:	83 ec 04             	sub    $0x4,%esp
f010648e:	52                   	push   %edx
f010648f:	50                   	push   %eax
f0106490:	68 d8 4c 12 f0       	push   $0xf0124cd8
f0106495:	e8 f1 aa ff ff       	call   f0100f8b <cprintf>
f010649a:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010649d:	83 ec 0c             	sub    $0xc,%esp
f01064a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01064a3:	e8 9a 4d 00 00       	call   f010b242 <env_free>
f01064a8:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01064ab:	83 ec 0c             	sub    $0xc,%esp
f01064ae:	68 ae 4c 12 f0       	push   $0xf0124cae
f01064b3:	e8 d3 aa ff ff       	call   f0100f8b <cprintf>
f01064b8:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01064bb:	e8 4b 4f 00 00       	call   f010b40b <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064c0:	83 ec 0c             	sub    $0xc,%esp
f01064c3:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f01064c8:	e8 d2 90 00 00       	call   f010f59f <release_spinlock>
f01064cd:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01064d0:	e8 ed b8 ff ff       	call   f0101dc2 <get_into_prompt>

f01064d5 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01064d5:	55                   	push   %ebp
f01064d6:	89 e5                	mov    %esp,%ebp
f01064d8:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064db:	83 ec 0c             	sub    $0xc,%esp
f01064de:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f01064e3:	e8 30 90 00 00       	call   f010f518 <acquire_spinlock>
f01064e8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01064eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01064f9:	e9 37 01 00 00       	jmp    f0106635 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01064fe:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0106503:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106506:	c1 e2 04             	shl    $0x4,%edx
f0106509:	01 d0                	add    %edx,%eax
f010650b:	8b 00                	mov    (%eax),%eax
f010650d:	85 c0                	test   %eax,%eax
f010650f:	0f 84 1d 01 00 00    	je     f0106632 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010651c:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0106521:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106524:	c1 e2 04             	shl    $0x4,%edx
f0106527:	01 d0                	add    %edx,%eax
f0106529:	8b 00                	mov    (%eax),%eax
f010652b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010652e:	e9 c7 00 00 00       	jmp    f01065fa <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106537:	75 17                	jne    f0106550 <sched_exit_all_ready_envs+0x7b>
f0106539:	83 ec 04             	sub    $0x4,%esp
f010653c:	68 27 4b 12 f0       	push   $0xf0124b27
f0106541:	68 79 02 00 00       	push   $0x279
f0106546:	68 eb 4a 12 f0       	push   $0xf0124aeb
f010654b:	e8 e9 9d ff ff       	call   f0100339 <_panic>
f0106550:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106553:	8b 40 08             	mov    0x8(%eax),%eax
f0106556:	85 c0                	test   %eax,%eax
f0106558:	74 11                	je     f010656b <sched_exit_all_ready_envs+0x96>
f010655a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655d:	8b 40 08             	mov    0x8(%eax),%eax
f0106560:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106563:	8b 52 0c             	mov    0xc(%edx),%edx
f0106566:	89 50 0c             	mov    %edx,0xc(%eax)
f0106569:	eb 16                	jmp    f0106581 <sched_exit_all_ready_envs+0xac>
f010656b:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0106570:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106573:	c1 e2 04             	shl    $0x4,%edx
f0106576:	01 c2                	add    %eax,%edx
f0106578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010657b:	8b 40 0c             	mov    0xc(%eax),%eax
f010657e:	89 42 04             	mov    %eax,0x4(%edx)
f0106581:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106584:	8b 40 0c             	mov    0xc(%eax),%eax
f0106587:	85 c0                	test   %eax,%eax
f0106589:	74 11                	je     f010659c <sched_exit_all_ready_envs+0xc7>
f010658b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010658e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106591:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106594:	8b 52 08             	mov    0x8(%edx),%edx
f0106597:	89 50 08             	mov    %edx,0x8(%eax)
f010659a:	eb 15                	jmp    f01065b1 <sched_exit_all_ready_envs+0xdc>
f010659c:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01065a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a4:	c1 e2 04             	shl    $0x4,%edx
f01065a7:	01 c2                	add    %eax,%edx
f01065a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065ac:	8b 40 08             	mov    0x8(%eax),%eax
f01065af:	89 02                	mov    %eax,(%edx)
f01065b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065b4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065be:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01065c5:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01065ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065cd:	c1 e2 04             	shl    $0x4,%edx
f01065d0:	01 d0                	add    %edx,%eax
f01065d2:	8b 50 0c             	mov    0xc(%eax),%edx
f01065d5:	4a                   	dec    %edx
f01065d6:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f01065d9:	83 ec 0c             	sub    $0xc,%esp
f01065dc:	ff 75 f4             	pushl  -0xc(%ebp)
f01065df:	e8 c1 ef ff ff       	call   f01055a5 <sched_insert_exit>
f01065e4:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065e7:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01065ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065ef:	c1 e2 04             	shl    $0x4,%edx
f01065f2:	01 d0                	add    %edx,%eax
f01065f4:	8b 40 08             	mov    0x8(%eax),%eax
f01065f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01065fa:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f01065ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106602:	c1 e2 04             	shl    $0x4,%edx
f0106605:	01 d0                	add    %edx,%eax
f0106607:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010660b:	74 08                	je     f0106615 <sched_exit_all_ready_envs+0x140>
f010660d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106610:	8b 52 08             	mov    0x8(%edx),%edx
f0106613:	eb 05                	jmp    f010661a <sched_exit_all_ready_envs+0x145>
f0106615:	ba 00 00 00 00       	mov    $0x0,%edx
f010661a:	89 50 08             	mov    %edx,0x8(%eax)
f010661d:	8b 40 08             	mov    0x8(%eax),%eax
f0106620:	85 c0                	test   %eax,%eax
f0106622:	0f 85 0b ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
f0106628:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010662c:	0f 85 01 ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106632:	ff 45 f0             	incl   -0x10(%ebp)
f0106635:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f010663a:	0f b6 c0             	movzbl %al,%eax
f010663d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106640:	0f 8f b8 fe ff ff    	jg     f01064fe <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106646:	83 ec 0c             	sub    $0xc,%esp
f0106649:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010664e:	e8 4c 8f 00 00       	call   f010f59f <release_spinlock>
f0106653:	83 c4 10             	add    $0x10,%esp
}
f0106656:	90                   	nop
f0106657:	c9                   	leave  
f0106658:	c3                   	ret    

f0106659 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f0106659:	55                   	push   %ebp
f010665a:	89 e5                	mov    %esp,%ebp
	return ticks;
f010665c:	a1 68 b9 6b f0       	mov    0xf06bb968,%eax
f0106661:	8b 15 6c b9 6b f0    	mov    0xf06bb96c,%edx
}
f0106667:	5d                   	pop    %ebp
f0106668:	c3                   	ret    

f0106669 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f0106669:	55                   	push   %ebp
f010666a:	89 e5                	mov    %esp,%ebp
f010666c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010666f:	83 ec 04             	sub    $0x4,%esp
f0106672:	68 04 4f 12 f0       	push   $0xf0124f04
f0106677:	68 8c 02 00 00       	push   $0x28c
f010667c:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0106681:	e8 b3 9c ff ff       	call   f0100339 <_panic>

f0106686 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106686:	55                   	push   %ebp
f0106687:	89 e5                	mov    %esp,%ebp
f0106689:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010668c:	83 ec 04             	sub    $0x4,%esp
f010668f:	68 04 4f 12 f0       	push   $0xf0124f04
f0106694:	68 94 02 00 00       	push   $0x294
f0106699:	68 eb 4a 12 f0       	push   $0xf0124aeb
f010669e:	e8 96 9c ff ff       	call   f0100339 <_panic>

f01066a3 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01066a3:	55                   	push   %ebp
f01066a4:	89 e5                	mov    %esp,%ebp
f01066a6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066a9:	83 ec 04             	sub    $0x4,%esp
f01066ac:	68 04 4f 12 f0       	push   $0xf0124f04
f01066b1:	68 9c 02 00 00       	push   $0x29c
f01066b6:	68 eb 4a 12 f0       	push   $0xf0124aeb
f01066bb:	e8 79 9c ff ff       	call   f0100339 <_panic>

f01066c0 <get_load_average>:
}
int get_load_average()
{
f01066c0:	55                   	push   %ebp
f01066c1:	89 e5                	mov    %esp,%ebp
f01066c3:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066c6:	83 ec 04             	sub    $0x4,%esp
f01066c9:	68 04 4f 12 f0       	push   $0xf0124f04
f01066ce:	68 a4 02 00 00       	push   $0x2a4
f01066d3:	68 eb 4a 12 f0       	push   $0xf0124aeb
f01066d8:	e8 5c 9c ff ff       	call   f0100339 <_panic>

f01066dd <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01066dd:	55                   	push   %ebp
f01066de:	89 e5                	mov    %esp,%ebp
f01066e0:	a1 b4 b7 6b f0       	mov    0xf06bb7b4,%eax
f01066e5:	85 c0                	test   %eax,%eax
f01066e7:	75 07                	jne    f01066f0 <isSchedMethodRR+0x13>
f01066e9:	b8 01 00 00 00       	mov    $0x1,%eax
f01066ee:	eb 05                	jmp    f01066f5 <isSchedMethodRR+0x18>
f01066f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01066f5:	5d                   	pop    %ebp
f01066f6:	c3                   	ret    

f01066f7 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f01066f7:	55                   	push   %ebp
f01066f8:	89 e5                	mov    %esp,%ebp
f01066fa:	a1 b4 b7 6b f0       	mov    0xf06bb7b4,%eax
f01066ff:	83 f8 01             	cmp    $0x1,%eax
f0106702:	75 07                	jne    f010670b <isSchedMethodMLFQ+0x14>
f0106704:	b8 01 00 00 00       	mov    $0x1,%eax
f0106709:	eb 05                	jmp    f0106710 <isSchedMethodMLFQ+0x19>
f010670b:	b8 00 00 00 00       	mov    $0x0,%eax
f0106710:	5d                   	pop    %ebp
f0106711:	c3                   	ret    

f0106712 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106712:	55                   	push   %ebp
f0106713:	89 e5                	mov    %esp,%ebp
f0106715:	a1 b4 b7 6b f0       	mov    0xf06bb7b4,%eax
f010671a:	83 f8 02             	cmp    $0x2,%eax
f010671d:	75 07                	jne    f0106726 <isSchedMethodBSD+0x14>
f010671f:	b8 01 00 00 00       	mov    $0x1,%eax
f0106724:	eb 05                	jmp    f010672b <isSchedMethodBSD+0x19>
f0106726:	b8 00 00 00 00       	mov    $0x0,%eax
f010672b:	5d                   	pop    %ebp
f010672c:	c3                   	ret    

f010672d <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010672d:	55                   	push   %ebp
f010672e:	89 e5                	mov    %esp,%ebp
f0106730:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106733:	c7 05 98 b4 6b f0 00 	movl   $0x0,0xf06bb498
f010673a:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010673d:	83 ec 0c             	sub    $0xc,%esp
f0106740:	6a 0a                	push   $0xa
f0106742:	e8 60 02 00 00       	call   f01069a7 <sched_init_RR>
f0106747:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010674a:	83 ec 0c             	sub    $0xc,%esp
f010674d:	68 30 b3 6b f0       	push   $0xf06bb330
f0106752:	e8 12 e8 ff ff       	call   f0104f69 <init_queue>
f0106757:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010675a:	83 ec 0c             	sub    $0xc,%esp
f010675d:	68 40 b3 6b f0       	push   $0xf06bb340
f0106762:	e8 02 e8 ff ff       	call   f0104f69 <init_queue>
f0106767:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f010676a:	e8 9d 09 00 00       	call   f010710c <mycpu>
f010676f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106776:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106779:	83 ec 08             	sub    $0x8,%esp
f010677c:	68 18 4f 12 f0       	push   $0xf0124f18
f0106781:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0106786:	e8 5c 8d 00 00       	call   f010f4e7 <init_spinlock>
f010678b:	83 c4 10             	add    $0x10,%esp
}
f010678e:	90                   	nop
f010678f:	c9                   	leave  
f0106790:	c3                   	ret    

f0106791 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106791:	55                   	push   %ebp
f0106792:	89 e5                	mov    %esp,%ebp
f0106794:	53                   	push   %ebx
f0106795:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106798:	9c                   	pushf  
f0106799:	58                   	pop    %eax
f010679a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f010679d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01067a0:	25 00 02 00 00       	and    $0x200,%eax
f01067a5:	85 c0                	test   %eax,%eax
f01067a7:	74 14                	je     f01067bd <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01067a9:	83 ec 04             	sub    $0x4,%esp
f01067ac:	68 2c 4f 12 f0       	push   $0xf0124f2c
f01067b1:	6a 37                	push   $0x37
f01067b3:	68 62 4f 12 f0       	push   $0xf0124f62
f01067b8:	e8 7c 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067bd:	e8 4a 09 00 00       	call   f010710c <mycpu>
f01067c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01067c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067c8:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01067cf:	00 00 00 

	chk1();
f01067d2:	e8 be 7e 01 00       	call   f011e695 <chk1>
	c->scheduler_status = SCH_STARTED;
f01067d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067da:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f01067e1:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f01067e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01067eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01067f2:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01067f3:	83 ec 0c             	sub    $0xc,%esp
f01067f6:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f01067fb:	e8 18 8d 00 00       	call   f010f518 <acquire_spinlock>
f0106800:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106803:	a1 b4 b7 6b f0       	mov    0xf06bb7b4,%eax
f0106808:	8b 04 85 4c e9 17 f0 	mov    -0xfe816b4(,%eax,4),%eax
f010680f:	ff d0                	call   *%eax
f0106811:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106814:	e8 71 4a 00 00       	call   f010b28a <get_cpu_proc>
f0106819:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010681c:	83 ec 0c             	sub    $0xc,%esp
f010681f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106822:	e8 8c 4a 00 00       	call   f010b2b3 <set_cpu_proc>
f0106827:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010682a:	83 ec 0c             	sub    $0xc,%esp
f010682d:	ff 75 e8             	pushl  -0x18(%ebp)
f0106830:	e8 66 7e 01 00       	call   f011e69b <chk2>
f0106835:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106838:	83 ec 0c             	sub    $0xc,%esp
f010683b:	ff 75 e0             	pushl  -0x20(%ebp)
f010683e:	e8 70 4a 00 00       	call   f010b2b3 <set_cpu_proc>
f0106843:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106846:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010684a:	0f 84 d6 00 00 00    	je     f0106926 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106850:	83 ec 0c             	sub    $0xc,%esp
f0106853:	ff 75 e8             	pushl  -0x18(%ebp)
f0106856:	e8 58 4a 00 00       	call   f010b2b3 <set_cpu_proc>
f010685b:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010685e:	83 ec 0c             	sub    $0xc,%esp
f0106861:	ff 75 e8             	pushl  -0x18(%ebp)
f0106864:	e8 c5 4c 00 00       	call   f010b52e <switchuvm>
f0106869:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f010686c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010686f:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106876:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106879:	8b 40 04             	mov    0x4(%eax),%eax
f010687c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010687f:	83 c2 04             	add    $0x4,%edx
f0106882:	83 ec 08             	sub    $0x8,%esp
f0106885:	50                   	push   %eax
f0106886:	52                   	push   %edx
f0106887:	e8 e5 e2 ff ff       	call   f0104b71 <context_switch>
f010688c:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010688f:	9c                   	pushf  
f0106890:	58                   	pop    %eax
f0106891:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106894:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106897:	25 00 02 00 00       	and    $0x200,%eax
f010689c:	85 c0                	test   %eax,%eax
f010689e:	74 14                	je     f01068b4 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01068a0:	83 ec 04             	sub    $0x4,%esp
f01068a3:	68 74 4f 12 f0       	push   $0xf0124f74
f01068a8:	6a 74                	push   $0x74
f01068aa:	68 62 4f 12 f0       	push   $0xf0124f62
f01068af:	e8 85 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068b4:	e8 01 e4 ff ff       	call   f0104cba <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068b9:	e8 cc 49 00 00       	call   f010b28a <get_cpu_proc>
f01068be:	89 c2                	mov    %eax,%edx
f01068c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068c3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068c9:	39 c2                	cmp    %eax,%edx
f01068cb:	74 16                	je     f01068e3 <fos_scheduler+0x152>
f01068cd:	68 ab 4f 12 f0       	push   $0xf0124fab
f01068d2:	68 c5 4f 12 f0       	push   $0xf0124fc5
f01068d7:	6a 7d                	push   $0x7d
f01068d9:	68 62 4f 12 f0       	push   $0xf0124f62
f01068de:	e8 56 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f01068e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068e6:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068ec:	8b 40 18             	mov    0x18(%eax),%eax
f01068ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f01068f2:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f01068f6:	75 16                	jne    f010690e <fos_scheduler+0x17d>
f01068f8:	68 da 4f 12 f0       	push   $0xf0124fda
f01068fd:	68 c5 4f 12 f0       	push   $0xf0124fc5
f0106902:	6a 7f                	push   $0x7f
f0106904:	68 62 4f 12 f0       	push   $0xf0124f62
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f010690e:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106912:	74 12                	je     f0106926 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106914:	e8 fe 4b 00 00       	call   f010b517 <switchkvm>
					set_cpu_proc(NULL);
f0106919:	83 ec 0c             	sub    $0xc,%esp
f010691c:	6a 00                	push   $0x0
f010691e:	e8 90 49 00 00       	call   f010b2b3 <set_cpu_proc>
f0106923:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106926:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010692a:	0f 85 d3 fe ff ff    	jne    f0106803 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106930:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106937:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010693e:	eb 3e                	jmp    f010697e <fos_scheduler+0x1ed>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106940:	8b 0d d0 27 69 f0    	mov    0xf06927d0,%ecx
f0106946:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106949:	89 d0                	mov    %edx,%eax
f010694b:	c1 e0 03             	shl    $0x3,%eax
f010694e:	01 d0                	add    %edx,%eax
f0106950:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106957:	01 d8                	add    %ebx,%eax
f0106959:	01 c0                	add    %eax,%eax
f010695b:	01 d0                	add    %edx,%eax
f010695d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106964:	01 d8                	add    %ebx,%eax
f0106966:	01 d0                	add    %edx,%eax
f0106968:	01 c8                	add    %ecx,%eax
f010696a:	8b 40 18             	mov    0x18(%eax),%eax
f010696d:	83 f8 03             	cmp    $0x3,%eax
f0106970:	75 09                	jne    f010697b <fos_scheduler+0x1ea>
			{
				is_any_blocked = 1;
f0106972:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106979:	eb 0d                	jmp    f0106988 <fos_scheduler+0x1f7>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f010697b:	ff 45 f0             	incl   -0x10(%ebp)
f010697e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106981:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106986:	76 b8                	jbe    f0106940 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106988:	83 ec 0c             	sub    $0xc,%esp
f010698b:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0106990:	e8 0a 8c 00 00       	call   f010f59f <release_spinlock>
f0106995:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106998:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010699c:	0f 8f 50 fe ff ff    	jg     f01067f2 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069a2:	e8 1b b4 ff ff       	call   f0101dc2 <get_into_prompt>

f01069a7 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069a7:	55                   	push   %ebp
f01069a8:	89 e5                	mov    %esp,%ebp
f01069aa:	83 ec 28             	sub    $0x28,%esp
f01069ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01069b0:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069b3:	c6 05 04 ba 6b f0 01 	movb   $0x1,0xf06bba04
#if USE_KHEAP
	sched_delete_ready_queues();
f01069ba:	e8 5a e8 ff ff       	call   f0105219 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f01069bf:	83 ec 0c             	sub    $0xc,%esp
f01069c2:	6a 10                	push   $0x10
f01069c4:	e8 22 27 00 00       	call   f01090eb <kmalloc>
f01069c9:	83 c4 10             	add    $0x10,%esp
f01069cc:	a3 50 b3 6b f0       	mov    %eax,0xf06bb350
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f01069d1:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f01069d6:	0f b6 c0             	movzbl %al,%eax
f01069d9:	83 ec 0c             	sub    $0xc,%esp
f01069dc:	50                   	push   %eax
f01069dd:	e8 09 27 00 00       	call   f01090eb <kmalloc>
f01069e2:	83 c4 10             	add    $0x10,%esp
f01069e5:	a3 84 b6 6b f0       	mov    %eax,0xf06bb684
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01069ea:	a1 84 b6 6b f0       	mov    0xf06bb684,%eax
f01069ef:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f01069f2:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f01069f4:	a1 84 b6 6b f0       	mov    0xf06bb684,%eax
f01069f9:	8a 00                	mov    (%eax),%al
f01069fb:	0f b6 c0             	movzbl %al,%eax
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	50                   	push   %eax
f0106a02:	e8 7c e3 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106a07:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106a0a:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0106a0f:	83 ec 0c             	sub    $0xc,%esp
f0106a12:	50                   	push   %eax
f0106a13:	e8 51 e5 ff ff       	call   f0104f69 <init_queue>
f0106a18:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106a1b:	e8 c2 e4 ff ff       	call   f0104ee2 <kclock_read_cnt0_latch>
f0106a20:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106a24:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106a28:	83 ec 08             	sub    $0x8,%esp
f0106a2b:	50                   	push   %eax
f0106a2c:	68 f0 4f 12 f0       	push   $0xf0124ff0
f0106a31:	e8 55 a5 ff ff       	call   f0100f8b <cprintf>
f0106a36:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a39:	e8 ce 06 00 00       	call   f010710c <mycpu>
f0106a3e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a45:	00 00 00 
	scheduler_method = SCH_RR;
f0106a48:	c7 05 b4 b7 6b f0 00 	movl   $0x0,0xf06bb7b4
f0106a4f:	00 00 00 
	//=========================================
	//=========================================
}
f0106a52:	90                   	nop
f0106a53:	c9                   	leave  
f0106a54:	c3                   	ret    

f0106a55 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a55:	55                   	push   %ebp
f0106a56:	89 e5                	mov    %esp,%ebp
f0106a58:	83 ec 18             	sub    $0x18,%esp
f0106a5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a5e:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a61:	e8 b3 e7 ff ff       	call   f0105219 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a66:	83 ec 04             	sub    $0x4,%esp
f0106a69:	68 18 50 12 f0       	push   $0xf0125018
f0106a6e:	68 ce 00 00 00       	push   $0xce
f0106a73:	68 62 4f 12 f0       	push   $0xf0124f62
f0106a78:	e8 bc 98 ff ff       	call   f0100339 <_panic>

f0106a7d <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a7d:	55                   	push   %ebp
f0106a7e:	89 e5                	mov    %esp,%ebp
f0106a80:	83 ec 18             	sub    $0x18,%esp
f0106a83:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a89:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a8c:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a8f:	83 ec 04             	sub    $0x4,%esp
f0106a92:	68 18 50 12 f0       	push   $0xf0125018
f0106a97:	68 e4 00 00 00       	push   $0xe4
f0106a9c:	68 62 4f 12 f0       	push   $0xf0124f62
f0106aa1:	e8 93 98 ff ff       	call   f0100339 <_panic>

f0106aa6 <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106aa6:	55                   	push   %ebp
f0106aa7:	89 e5                	mov    %esp,%ebp
f0106aa9:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aac:	83 ec 0c             	sub    $0xc,%esp
f0106aaf:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0106ab4:	e8 78 8c 00 00       	call   f010f731 <holding_spinlock>
f0106ab9:	83 c4 10             	add    $0x10,%esp
f0106abc:	85 c0                	test   %eax,%eax
f0106abe:	75 17                	jne    f0106ad7 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106ac0:	83 ec 04             	sub    $0x4,%esp
f0106ac3:	68 2c 50 12 f0       	push   $0xf012502c
f0106ac8:	68 fe 00 00 00       	push   $0xfe
f0106acd:	68 62 4f 12 f0       	push   $0xf0124f62
f0106ad2:	e8 62 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106ad7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106ade:	e8 a7 47 00 00       	call   f010b28a <get_cpu_proc>
f0106ae3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106ae6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106aea:	74 14                	je     f0106b00 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106aec:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0106af1:	83 ec 08             	sub    $0x8,%esp
f0106af4:	ff 75 f0             	pushl  -0x10(%ebp)
f0106af7:	50                   	push   %eax
f0106af8:	e8 ad e4 ff ff       	call   f0104faa <enqueue>
f0106afd:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106b00:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f0106b05:	83 ec 0c             	sub    $0xc,%esp
f0106b08:	50                   	push   %eax
f0106b09:	e8 2d e5 ff ff       	call   f010503b <dequeue>
f0106b0e:	83 c4 10             	add    $0x10,%esp
f0106b11:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106b14:	a1 84 b6 6b f0       	mov    0xf06bb684,%eax
f0106b19:	8a 00                	mov    (%eax),%al
f0106b1b:	0f b6 c0             	movzbl %al,%eax
f0106b1e:	83 ec 0c             	sub    $0xc,%esp
f0106b21:	50                   	push   %eax
f0106b22:	e8 5c e2 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106b27:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106b2d:	c9                   	leave  
f0106b2e:	c3                   	ret    

f0106b2f <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106b2f:	55                   	push   %ebp
f0106b30:	89 e5                	mov    %esp,%ebp
f0106b32:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b35:	83 ec 0c             	sub    $0xc,%esp
f0106b38:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0106b3d:	e8 ef 8b 00 00       	call   f010f731 <holding_spinlock>
f0106b42:	83 c4 10             	add    $0x10,%esp
f0106b45:	85 c0                	test   %eax,%eax
f0106b47:	75 17                	jne    f0106b60 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b49:	83 ec 04             	sub    $0x4,%esp
f0106b4c:	68 78 50 12 f0       	push   $0xf0125078
f0106b51:	68 1d 01 00 00       	push   $0x11d
f0106b56:	68 62 4f 12 f0       	push   $0xf0124f62
f0106b5b:	e8 d9 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b60:	83 ec 04             	sub    $0x4,%esp
f0106b63:	68 18 50 12 f0       	push   $0xf0125018
f0106b68:	68 23 01 00 00       	push   $0x123
f0106b6d:	68 62 4f 12 f0       	push   $0xf0124f62
f0106b72:	e8 c2 97 ff ff       	call   f0100339 <_panic>

f0106b77 <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b77:	55                   	push   %ebp
f0106b78:	89 e5                	mov    %esp,%ebp
f0106b7a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b7d:	83 ec 0c             	sub    $0xc,%esp
f0106b80:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f0106b85:	e8 a7 8b 00 00       	call   f010f731 <holding_spinlock>
f0106b8a:	83 c4 10             	add    $0x10,%esp
f0106b8d:	85 c0                	test   %eax,%eax
f0106b8f:	75 17                	jne    f0106ba8 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b91:	83 ec 04             	sub    $0x4,%esp
f0106b94:	68 c8 50 12 f0       	push   $0xf01250c8
f0106b99:	68 2e 01 00 00       	push   $0x12e
f0106b9e:	68 62 4f 12 f0       	push   $0xf0124f62
f0106ba3:	e8 91 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ba8:	83 ec 04             	sub    $0x4,%esp
f0106bab:	68 18 50 12 f0       	push   $0xf0125018
f0106bb0:	68 34 01 00 00       	push   $0x134
f0106bb5:	68 62 4f 12 f0       	push   $0xf0124f62
f0106bba:	e8 7a 97 ff ff       	call   f0100339 <_panic>

f0106bbf <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106bbf:	55                   	push   %ebp
f0106bc0:	89 e5                	mov    %esp,%ebp
f0106bc2:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106bc5:	e8 48 fb ff ff       	call   f0106712 <isSchedMethodBSD>
f0106bca:	85 c0                	test   %eax,%eax
f0106bcc:	74 17                	je     f0106be5 <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106bce:	83 ec 04             	sub    $0x4,%esp
f0106bd1:	68 18 50 12 f0       	push   $0xf0125018
f0106bd6:	68 43 01 00 00       	push   $0x143
f0106bdb:	68 62 4f 12 f0       	push   $0xf0124f62
f0106be0:	e8 54 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106be5:	a1 68 b9 6b f0       	mov    0xf06bb968,%eax
f0106bea:	8b 15 6c b9 6b f0    	mov    0xf06bb96c,%edx
f0106bf0:	83 c0 01             	add    $0x1,%eax
f0106bf3:	83 d2 00             	adc    $0x0,%edx
f0106bf6:	a3 68 b9 6b f0       	mov    %eax,0xf06bb968
f0106bfb:	89 15 6c b9 6b f0    	mov    %edx,0xf06bb96c
	struct Env* p = get_cpu_proc();
f0106c01:	e8 84 46 00 00       	call   f010b28a <get_cpu_proc>
f0106c06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106c09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c0d:	74 30                	je     f0106c3f <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c12:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106c18:	8d 50 01             	lea    0x1(%eax),%edx
f0106c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c1e:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106c24:	83 ec 0c             	sub    $0xc,%esp
f0106c27:	6a 01                	push   $0x1
f0106c29:	e8 97 82 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f0106c2e:	83 c4 10             	add    $0x10,%esp
f0106c31:	85 c0                	test   %eax,%eax
f0106c33:	74 05                	je     f0106c3a <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106c35:	e8 08 00 00 00       	call   f0106c42 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c3a:	e8 6d 47 00 00       	call   f010b3ac <yield>
	}
	/*****************************************/
}
f0106c3f:	90                   	nop
f0106c40:	c9                   	leave  
f0106c41:	c3                   	ret    

f0106c42 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c42:	55                   	push   %ebp
f0106c43:	89 e5                	mov    %esp,%ebp
f0106c45:	53                   	push   %ebx
f0106c46:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c49:	e8 3c 46 00 00       	call   f010b28a <get_cpu_proc>
f0106c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c55:	0f 84 a1 01 00 00    	je     f0106dfc <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c5e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106c64:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c67:	eb 78                	jmp    f0106ce1 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c6c:	8b 00                	mov    (%eax),%eax
f0106c6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c74:	8b 40 64             	mov    0x64(%eax),%eax
f0106c77:	83 ec 08             	sub    $0x8,%esp
f0106c7a:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c7d:	50                   	push   %eax
f0106c7e:	e8 0b 29 00 00       	call   f010958e <pt_get_page_permissions>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c8c:	8b 40 08             	mov    0x8(%eax),%eax
f0106c8f:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106c92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c95:	83 e0 20             	and    $0x20,%eax
f0106c98:	85 c0                	test   %eax,%eax
f0106c9a:	74 2b                	je     f0106cc7 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c9f:	c1 e8 02             	shr    $0x2,%eax
f0106ca2:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106ca7:	89 c2                	mov    %eax,%edx
f0106ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cac:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106caf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cb2:	8b 40 64             	mov    0x64(%eax),%eax
f0106cb5:	6a 20                	push   $0x20
f0106cb7:	6a 00                	push   $0x0
f0106cb9:	ff 75 e8             	pushl  -0x18(%ebp)
f0106cbc:	50                   	push   %eax
f0106cbd:	e8 08 28 00 00       	call   f01094ca <pt_set_page_permissions>
f0106cc2:	83 c4 10             	add    $0x10,%esp
f0106cc5:	eb 0e                	jmp    f0106cd5 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106cc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106cca:	c1 e8 02             	shr    $0x2,%eax
f0106ccd:	89 c2                	mov    %eax,%edx
f0106ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cd2:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106cd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cd8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106cde:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ce1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ce5:	74 08                	je     f0106cef <update_WS_time_stamps+0xad>
f0106ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cea:	8b 40 10             	mov    0x10(%eax),%eax
f0106ced:	eb 05                	jmp    f0106cf4 <update_WS_time_stamps+0xb2>
f0106cef:	b8 00 00 00 00       	mov    $0x0,%eax
f0106cf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cf7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0106cfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d00:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106d06:	85 c0                	test   %eax,%eax
f0106d08:	0f 85 5b ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
f0106d0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d12:	0f 85 51 ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106d1f:	e9 ce 00 00 00       	jmp    f0106df2 <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106d24:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d27:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d2a:	89 d0                	mov    %edx,%eax
f0106d2c:	01 c0                	add    %eax,%eax
f0106d2e:	01 d0                	add    %edx,%eax
f0106d30:	c1 e0 03             	shl    $0x3,%eax
f0106d33:	01 c8                	add    %ecx,%eax
f0106d35:	05 b0 00 00 00       	add    $0xb0,%eax
f0106d3a:	8a 00                	mov    (%eax),%al
f0106d3c:	3c 01                	cmp    $0x1,%al
f0106d3e:	0f 84 ab 00 00 00    	je     f0106def <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d47:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d4a:	89 d0                	mov    %edx,%eax
f0106d4c:	01 c0                	add    %eax,%eax
f0106d4e:	01 d0                	add    %edx,%eax
f0106d50:	c1 e0 03             	shl    $0x3,%eax
f0106d53:	01 c8                	add    %ecx,%eax
f0106d55:	05 ac 00 00 00       	add    $0xac,%eax
f0106d5a:	8b 00                	mov    (%eax),%eax
f0106d5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d5f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d65:	89 d0                	mov    %edx,%eax
f0106d67:	01 c0                	add    %eax,%eax
f0106d69:	01 d0                	add    %edx,%eax
f0106d6b:	c1 e0 03             	shl    $0x3,%eax
f0106d6e:	01 c8                	add    %ecx,%eax
f0106d70:	05 b4 00 00 00       	add    $0xb4,%eax
f0106d75:	8b 00                	mov    (%eax),%eax
f0106d77:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d7d:	8b 40 64             	mov    0x64(%eax),%eax
f0106d80:	83 ec 08             	sub    $0x8,%esp
f0106d83:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d86:	50                   	push   %eax
f0106d87:	e8 de 28 00 00       	call   f010966a <pd_is_table_used>
f0106d8c:	83 c4 10             	add    $0x10,%esp
f0106d8f:	85 c0                	test   %eax,%eax
f0106d91:	74 3c                	je     f0106dcf <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d93:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d96:	c1 e8 02             	shr    $0x2,%eax
f0106d99:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d9e:	89 c1                	mov    %eax,%ecx
f0106da0:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106da3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106da6:	89 d0                	mov    %edx,%eax
f0106da8:	01 c0                	add    %eax,%eax
f0106daa:	01 d0                	add    %edx,%eax
f0106dac:	c1 e0 03             	shl    $0x3,%eax
f0106daf:	01 d8                	add    %ebx,%eax
f0106db1:	05 b4 00 00 00       	add    $0xb4,%eax
f0106db6:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106dbb:	8b 40 64             	mov    0x64(%eax),%eax
f0106dbe:	83 ec 08             	sub    $0x8,%esp
f0106dc1:	ff 75 dc             	pushl  -0x24(%ebp)
f0106dc4:	50                   	push   %eax
f0106dc5:	e8 c4 28 00 00       	call   f010968e <pd_set_table_unused>
f0106dca:	83 c4 10             	add    $0x10,%esp
f0106dcd:	eb 20                	jmp    f0106def <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106dcf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106dd2:	c1 e8 02             	shr    $0x2,%eax
f0106dd5:	89 c1                	mov    %eax,%ecx
f0106dd7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106dda:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ddd:	89 d0                	mov    %edx,%eax
f0106ddf:	01 c0                	add    %eax,%eax
f0106de1:	01 d0                	add    %edx,%eax
f0106de3:	c1 e0 03             	shl    $0x3,%eax
f0106de6:	01 d8                	add    %ebx,%eax
f0106de8:	05 b4 00 00 00       	add    $0xb4,%eax
f0106ded:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106def:	ff 45 f0             	incl   -0x10(%ebp)
f0106df2:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106df6:	0f 8e 28 ff ff ff    	jle    f0106d24 <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106dfc:	90                   	nop
f0106dfd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106e00:	c9                   	leave  
f0106e01:	c3                   	ret    

f0106e02 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106e02:	55                   	push   %ebp
f0106e03:	89 e5                	mov    %esp,%ebp
f0106e05:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106e08:	c7 05 cc 27 69 f0 01 	movl   $0x1,0xf06927cc
f0106e0f:	00 00 00 
f0106e12:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106e19:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106e1d:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106e20:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106e23:	ee                   	out    %al,(%dx)
f0106e24:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106e2b:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106e2f:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106e32:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e35:	ee                   	out    %al,(%dx)
f0106e36:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e3d:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e41:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e44:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e47:	ee                   	out    %al,(%dx)
f0106e48:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e4f:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e53:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e56:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e59:	ee                   	out    %al,(%dx)
f0106e5a:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e61:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e65:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106e68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e6b:	ee                   	out    %al,(%dx)
f0106e6c:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e73:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e77:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e7a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e7d:	ee                   	out    %al,(%dx)
f0106e7e:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e85:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e89:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e8f:	ee                   	out    %al,(%dx)
f0106e90:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e97:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e9b:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106ea1:	ee                   	out    %al,(%dx)
f0106ea2:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106ea9:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106ead:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106eb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106eb3:	ee                   	out    %al,(%dx)
f0106eb4:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106ebb:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106ebf:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106ec2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106ec5:	ee                   	out    %al,(%dx)
f0106ec6:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106ecd:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106ed1:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106ed4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106ed7:	ee                   	out    %al,(%dx)
f0106ed8:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106edf:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106ee3:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106ee6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106ee9:	ee                   	out    %al,(%dx)
f0106eea:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106ef1:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106ef5:	8a 45 be             	mov    -0x42(%ebp),%al
f0106ef8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106efb:	ee                   	out    %al,(%dx)
f0106efc:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106f03:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106f07:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106f0a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106f0d:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106f0e:	66 a1 58 e9 17 f0    	mov    0xf017e958,%ax
f0106f14:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106f18:	74 15                	je     f0106f2f <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106f1a:	66 a1 58 e9 17 f0    	mov    0xf017e958,%ax
f0106f20:	0f b7 c0             	movzwl %ax,%eax
f0106f23:	83 ec 0c             	sub    $0xc,%esp
f0106f26:	50                   	push   %eax
f0106f27:	e8 06 00 00 00       	call   f0106f32 <irq_setmask_8259A>
f0106f2c:	83 c4 10             	add    $0x10,%esp
}
f0106f2f:	90                   	nop
f0106f30:	c9                   	leave  
f0106f31:	c3                   	ret    

f0106f32 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106f32:	55                   	push   %ebp
f0106f33:	89 e5                	mov    %esp,%ebp
f0106f35:	83 ec 14             	sub    $0x14,%esp
f0106f38:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f3b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f3f:	a1 cc 27 69 f0       	mov    0xf06927cc,%eax
f0106f44:	85 c0                	test   %eax,%eax
f0106f46:	74 34                	je     f0106f7c <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f4b:	0f b6 c0             	movzbl %al,%eax
f0106f4e:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f55:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f58:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f5e:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f62:	66 c1 e8 08          	shr    $0x8,%ax
f0106f66:	0f b6 c0             	movzbl %al,%eax
f0106f69:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f70:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f73:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f76:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f79:	ee                   	out    %al,(%dx)
f0106f7a:	eb 01                	jmp    f0106f7d <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f7c:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f7d:	c9                   	leave  
f0106f7e:	c3                   	ret    

f0106f7f <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f7f:	55                   	push   %ebp
f0106f80:	89 e5                	mov    %esp,%ebp
f0106f82:	53                   	push   %ebx
f0106f83:	83 ec 14             	sub    $0x14,%esp
f0106f86:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f89:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f8c:	a1 cc 27 69 f0       	mov    0xf06927cc,%eax
f0106f91:	85 c0                	test   %eax,%eax
f0106f93:	74 58                	je     f0106fed <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f95:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f99:	77 08                	ja     f0106fa3 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f9b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fa1:	eb 0a                	jmp    f0106fad <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fa3:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fa9:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106fad:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fb1:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	89 c2                	mov    %eax,%edx
f0106fb9:	ec                   	in     (%dx),%al
f0106fba:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fbd:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fc0:	88 c2                	mov    %al,%dl
f0106fc2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fc6:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fcb:	88 c1                	mov    %al,%cl
f0106fcd:	d3 e3                	shl    %cl,%ebx
f0106fcf:	89 d8                	mov    %ebx,%eax
f0106fd1:	09 d0                	or     %edx,%eax
f0106fd3:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fd6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fda:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fde:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fe1:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106fe4:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106fe7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fea:	ee                   	out    %al,(%dx)
f0106feb:	eb 01                	jmp    f0106fee <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106fed:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106fee:	83 c4 14             	add    $0x14,%esp
f0106ff1:	5b                   	pop    %ebx
f0106ff2:	5d                   	pop    %ebp
f0106ff3:	c3                   	ret    

f0106ff4 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106ff4:	55                   	push   %ebp
f0106ff5:	89 e5                	mov    %esp,%ebp
f0106ff7:	53                   	push   %ebx
f0106ff8:	83 ec 14             	sub    $0x14,%esp
f0106ffb:	8b 45 08             	mov    0x8(%ebp),%eax
f0106ffe:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107001:	a1 cc 27 69 f0       	mov    0xf06927cc,%eax
f0107006:	85 c0                	test   %eax,%eax
f0107008:	74 5a                	je     f0107064 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010700a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010700e:	77 08                	ja     f0107018 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107010:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107016:	eb 0a                	jmp    f0107022 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107018:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010701e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107022:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107026:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107029:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010702c:	89 c2                	mov    %eax,%edx
f010702e:	ec                   	in     (%dx),%al
f010702f:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107032:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107035:	88 c2                	mov    %al,%dl
f0107037:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010703b:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107040:	88 c1                	mov    %al,%cl
f0107042:	d3 e3                	shl    %cl,%ebx
f0107044:	89 d8                	mov    %ebx,%eax
f0107046:	f7 d0                	not    %eax
f0107048:	21 d0                	and    %edx,%eax
f010704a:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f010704d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107051:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107055:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107058:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010705b:	8a 45 ef             	mov    -0x11(%ebp),%al
f010705e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107061:	ee                   	out    %al,(%dx)
f0107062:	eb 01                	jmp    f0107065 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107064:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107065:	83 c4 14             	add    $0x14,%esp
f0107068:	5b                   	pop    %ebx
f0107069:	5d                   	pop    %ebp
f010706a:	c3                   	ret    

f010706b <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f010706b:	55                   	push   %ebp
f010706c:	89 e5                	mov    %esp,%ebp
f010706e:	53                   	push   %ebx
f010706f:	83 ec 14             	sub    $0x14,%esp
f0107072:	8b 45 08             	mov    0x8(%ebp),%eax
f0107075:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107078:	a1 cc 27 69 f0       	mov    0xf06927cc,%eax
f010707d:	85 c0                	test   %eax,%eax
f010707f:	75 07                	jne    f0107088 <irq_get_mask+0x1d>
		return -1;
f0107081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107086:	eb 45                	jmp    f01070cd <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107088:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010708c:	77 08                	ja     f0107096 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f010708e:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107094:	eb 0a                	jmp    f01070a0 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107096:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010709c:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01070a0:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01070a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01070a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070aa:	89 c2                	mov    %eax,%edx
f01070ac:	ec                   	in     (%dx),%al
f01070ad:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01070b0:	8a 45 f3             	mov    -0xd(%ebp),%al
f01070b3:	88 c2                	mov    %al,%dl
f01070b5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01070b9:	bb 01 00 00 00       	mov    $0x1,%ebx
f01070be:	88 c1                	mov    %al,%cl
f01070c0:	d3 e3                	shl    %cl,%ebx
f01070c2:	89 d8                	mov    %ebx,%eax
f01070c4:	21 d0                	and    %edx,%eax
f01070c6:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01070c9:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01070cd:	83 c4 14             	add    $0x14,%esp
f01070d0:	5b                   	pop    %ebx
f01070d1:	5d                   	pop    %ebp
f01070d2:	c3                   	ret    

f01070d3 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01070d3:	55                   	push   %ebp
f01070d4:	89 e5                	mov    %esp,%ebp
f01070d6:	83 ec 14             	sub    $0x14,%esp
f01070d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01070dc:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01070df:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01070e3:	76 12                	jbe    f01070f7 <pic_sendEOI+0x24>
f01070e5:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01070ec:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01070f0:	8a 45 f7             	mov    -0x9(%ebp),%al
f01070f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01070f6:	ee                   	out    %al,(%dx)
f01070f7:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01070fe:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107102:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107105:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107108:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107109:	90                   	nop
f010710a:	c9                   	leave  
f010710b:	c3                   	ret    

f010710c <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f010710c:	55                   	push   %ebp
f010710d:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010710f:	b8 a0 b4 6b f0       	mov    $0xf06bb4a0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107114:	5d                   	pop    %ebp
f0107115:	c3                   	ret    

f0107116 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107116:	55                   	push   %ebp
f0107117:	89 e5                	mov    %esp,%ebp
f0107119:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f010711c:	e8 eb ff ff ff       	call   f010710c <mycpu>
f0107121:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107127:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010712e:	00 00 00 
  c->ncli = 0;
f0107131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107134:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010713b:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010713e:	9c                   	pushf  
f010713f:	58                   	pop    %eax
f0107140:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107143:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107146:	25 00 02 00 00       	and    $0x200,%eax
f010714b:	85 c0                	test   %eax,%eax
f010714d:	0f 95 c0             	setne  %al
f0107150:	0f b6 d0             	movzbl %al,%edx
f0107153:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107156:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f010715c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107166:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107169:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107170:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107173:	8b 45 08             	mov    0x8(%ebp),%eax
f0107176:	40                   	inc    %eax
f0107177:	c1 e0 0f             	shl    $0xf,%eax
f010717a:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f010717f:	29 c2                	sub    %eax,%edx
f0107181:	89 d0                	mov    %edx,%eax
f0107183:	89 c2                	mov    %eax,%edx
f0107185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107188:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f010718b:	e8 18 01 00 00       	call   f01072a8 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107190:	e8 c5 57 00 00       	call   f010c95a <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107198:	83 c0 0c             	add    $0xc,%eax
f010719b:	83 ec 04             	sub    $0x4,%esp
f010719e:	6a 68                	push   $0x68
f01071a0:	6a 00                	push   $0x0
f01071a2:	50                   	push   %eax
f01071a3:	e8 1f 85 01 00       	call   f011f6c7 <memset>
f01071a8:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01071ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ae:	05 a4 00 00 00       	add    $0xa4,%eax
f01071b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01071b6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01071bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01071c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01071c3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01071c6:	f0 87 02             	lock xchg %eax,(%edx)
f01071c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01071cc:	90                   	nop
f01071cd:	c9                   	leave  
f01071ce:	c3                   	ret    

f01071cf <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01071cf:	55                   	push   %ebp
f01071d0:	89 e5                	mov    %esp,%ebp
f01071d2:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071d5:	9c                   	pushf  
f01071d6:	58                   	pop    %eax
f01071d7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01071da:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01071dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01071e0:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01071e1:	e8 26 ff ff ff       	call   f010710c <mycpu>
f01071e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01071e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ec:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071f2:	85 c0                	test   %eax,%eax
f01071f4:	75 13                	jne    f0107209 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01071f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01071f9:	25 00 02 00 00       	and    $0x200,%eax
f01071fe:	89 c2                	mov    %eax,%edx
f0107200:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107203:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107209:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010720c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107212:	8d 50 01             	lea    0x1(%eax),%edx
f0107215:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107218:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010721e:	90                   	nop
f010721f:	c9                   	leave  
f0107220:	c3                   	ret    

f0107221 <popcli>:

void popcli(void)
{
f0107221:	55                   	push   %ebp
f0107222:	89 e5                	mov    %esp,%ebp
f0107224:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107227:	9c                   	pushf  
f0107228:	58                   	pop    %eax
f0107229:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010722c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010722f:	25 00 02 00 00       	and    $0x200,%eax
f0107234:	85 c0                	test   %eax,%eax
f0107236:	74 14                	je     f010724c <popcli+0x2b>
    panic("popcli - interruptible");
f0107238:	83 ec 04             	sub    $0x4,%esp
f010723b:	68 15 51 12 f0       	push   $0xf0125115
f0107240:	6a 5e                	push   $0x5e
f0107242:	68 2c 51 12 f0       	push   $0xf012512c
f0107247:	e8 ed 90 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f010724c:	e8 bb fe ff ff       	call   f010710c <mycpu>
f0107251:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0107254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107257:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010725d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107260:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107263:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107269:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107272:	85 c0                	test   %eax,%eax
f0107274:	79 14                	jns    f010728a <popcli+0x69>
    panic("popcli");
f0107276:	83 ec 04             	sub    $0x4,%esp
f0107279:	68 3b 51 12 f0       	push   $0xf012513b
f010727e:	6a 61                	push   $0x61
f0107280:	68 2c 51 12 f0       	push   $0xf012512c
f0107285:	e8 af 90 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f010728a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010728d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107293:	85 c0                	test   %eax,%eax
f0107295:	75 0e                	jne    f01072a5 <popcli+0x84>
f0107297:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01072a0:	85 c0                	test   %eax,%eax
f01072a2:	74 01                	je     f01072a5 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01072a4:	fb                   	sti    
    sti();
}
f01072a5:	90                   	nop
f01072a6:	c9                   	leave  
f01072a7:	c3                   	ret    

f01072a8 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01072a8:	55                   	push   %ebp
f01072a9:	89 e5                	mov    %esp,%ebp
f01072ab:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01072ae:	e8 1c ff ff ff       	call   f01071cf <pushcli>

	c = mycpu();
f01072b3:	e8 54 fe ff ff       	call   f010710c <mycpu>
f01072b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01072bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072be:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01072c5:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01072cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072cf:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01072d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d8:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01072de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e1:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01072e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072eb:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072f1:	83 e2 f0             	and    $0xfffffff0,%edx
f01072f4:	83 ca 0a             	or     $0xa,%edx
f01072f7:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107300:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107306:	83 ca 10             	or     $0x10,%edx
f0107309:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010730f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107312:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107318:	83 e2 9f             	and    $0xffffff9f,%edx
f010731b:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107321:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107324:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010732a:	83 ca 80             	or     $0xffffff80,%edx
f010732d:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107333:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107336:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010733c:	83 ca 0f             	or     $0xf,%edx
f010733f:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107345:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107348:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010734e:	83 e2 ef             	and    $0xffffffef,%edx
f0107351:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107357:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010735a:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107360:	83 e2 df             	and    $0xffffffdf,%edx
f0107363:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107369:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736c:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107372:	83 ca 40             	or     $0x40,%edx
f0107375:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010737b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010737e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107384:	83 ca 80             	or     $0xffffff80,%edx
f0107387:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010738d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107390:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107397:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010739a:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01073a1:	ff ff 
f01073a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a6:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01073ad:	00 00 
f01073af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073b2:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01073b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073bc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073c2:	83 e2 f0             	and    $0xfffffff0,%edx
f01073c5:	83 ca 02             	or     $0x2,%edx
f01073c8:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d1:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073d7:	83 ca 10             	or     $0x10,%edx
f01073da:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e3:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073e9:	83 e2 9f             	and    $0xffffff9f,%edx
f01073ec:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f5:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073fb:	83 ca 80             	or     $0xffffff80,%edx
f01073fe:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107404:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107407:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010740d:	83 ca 0f             	or     $0xf,%edx
f0107410:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107416:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107419:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010741f:	83 e2 ef             	and    $0xffffffef,%edx
f0107422:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107428:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010742b:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107431:	83 e2 df             	and    $0xffffffdf,%edx
f0107434:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010743a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010743d:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107443:	83 ca 40             	or     $0x40,%edx
f0107446:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010744c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010744f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107455:	83 ca 80             	or     $0xffffff80,%edx
f0107458:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010745e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107461:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107468:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010746b:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107472:	ff ff 
f0107474:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107477:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f010747e:	00 00 
f0107480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107483:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010748a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748d:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107493:	83 e2 f0             	and    $0xfffffff0,%edx
f0107496:	83 ca 0a             	or     $0xa,%edx
f0107499:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010749f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a2:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074a8:	83 ca 10             	or     $0x10,%edx
f01074ab:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b4:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074ba:	83 ca 60             	or     $0x60,%edx
f01074bd:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c6:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074cc:	83 ca 80             	or     $0xffffff80,%edx
f01074cf:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d8:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074de:	83 ca 0f             	or     $0xf,%edx
f01074e1:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ea:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074f0:	83 e2 ef             	and    $0xffffffef,%edx
f01074f3:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fc:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107502:	83 e2 df             	and    $0xffffffdf,%edx
f0107505:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010750b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750e:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107514:	83 ca 40             	or     $0x40,%edx
f0107517:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010751d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107520:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107526:	83 ca 80             	or     $0xffffff80,%edx
f0107529:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010752f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107532:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107539:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753c:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107543:	ff ff 
f0107545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107548:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010754f:	00 00 
f0107551:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107554:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010755b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010755e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107564:	83 e2 f0             	and    $0xfffffff0,%edx
f0107567:	83 ca 02             	or     $0x2,%edx
f010756a:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107570:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107573:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107579:	83 ca 10             	or     $0x10,%edx
f010757c:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107582:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107585:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010758b:	83 ca 60             	or     $0x60,%edx
f010758e:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010759d:	83 ca 80             	or     $0xffffff80,%edx
f01075a0:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a9:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075af:	83 ca 0f             	or     $0xf,%edx
f01075b2:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075bb:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075c1:	83 e2 ef             	and    $0xffffffef,%edx
f01075c4:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075cd:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075d3:	83 e2 df             	and    $0xffffffdf,%edx
f01075d6:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075df:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075e5:	83 ca 40             	or     $0x40,%edx
f01075e8:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075f1:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075f7:	83 ca 80             	or     $0xffffff80,%edx
f01075fa:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010760a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760d:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107614:	00 00 00 
f0107617:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010761e:	00 00 00 

	popcli();	//enable interrupt
f0107621:	e8 fb fb ff ff       	call   f0107221 <popcli>


}
f0107626:	90                   	nop
f0107627:	c9                   	leave  
f0107628:	c3                   	ret    

f0107629 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107629:	55                   	push   %ebp
f010762a:	89 e5                	mov    %esp,%ebp
f010762c:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010762f:	83 ec 08             	sub    $0x8,%esp
f0107632:	68 00 10 00 00       	push   $0x1000
f0107637:	68 00 10 00 00       	push   $0x1000
f010763c:	e8 42 02 00 00       	call   f0107883 <boot_allocate_space>
f0107641:	83 c4 10             	add    $0x10,%esp
f0107644:	a3 7c b9 6b f0       	mov    %eax,0xf06bb97c
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107649:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f010764e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107651:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107658:	77 14                	ja     f010766e <initialize_kernel_VM+0x45>
f010765a:	ff 75 e0             	pushl  -0x20(%ebp)
f010765d:	68 44 51 12 f0       	push   $0xf0125144
f0107662:	6a 57                	push   $0x57
f0107664:	68 78 51 12 f0       	push   $0xf0125178
f0107669:	e8 cb 8c ff ff       	call   f0100339 <_panic>
f010766e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107671:	05 00 00 00 10       	add    $0x10000000,%eax
f0107676:	a3 a4 ba 6b f0       	mov    %eax,0xf06bbaa4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010767b:	c7 45 dc 00 60 17 f0 	movl   $0xf0176000,-0x24(%ebp)
f0107682:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107689:	77 14                	ja     f010769f <initialize_kernel_VM+0x76>
f010768b:	ff 75 dc             	pushl  -0x24(%ebp)
f010768e:	68 44 51 12 f0       	push   $0xf0125144
f0107693:	6a 63                	push   $0x63
f0107695:	68 78 51 12 f0       	push   $0xf0125178
f010769a:	e8 9a 8c ff ff       	call   f0100339 <_panic>
f010769f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01076a2:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01076a8:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01076ad:	83 ec 0c             	sub    $0xc,%esp
f01076b0:	6a 02                	push   $0x2
f01076b2:	52                   	push   %edx
f01076b3:	68 00 80 00 00       	push   $0x8000
f01076b8:	68 00 80 bf ef       	push   $0xefbf8000
f01076bd:	50                   	push   %eax
f01076be:	e8 34 02 00 00       	call   f01078f7 <boot_map_range>
f01076c3:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01076cd:	eb 24                	jmp    f01076f3 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01076cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d2:	40                   	inc    %eax
f01076d3:	c1 e0 0f             	shl    $0xf,%eax
f01076d6:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01076db:	29 c2                	sub    %eax,%edx
f01076dd:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01076e2:	6a 01                	push   $0x1
f01076e4:	6a 00                	push   $0x0
f01076e6:	52                   	push   %edx
f01076e7:	50                   	push   %eax
f01076e8:	e8 dd 1d 00 00       	call   f01094ca <pt_set_page_permissions>
f01076ed:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076f0:	ff 45 f4             	incl   -0xc(%ebp)
f01076f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076f7:	7e d6                	jle    f01076cf <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01076f9:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107700:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107707:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010770e:	eb 25                	jmp    f0107735 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107710:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107713:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107716:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f010771b:	83 ec 04             	sub    $0x4,%esp
f010771e:	6a 01                	push   $0x1
f0107720:	52                   	push   %edx
f0107721:	50                   	push   %eax
f0107722:	e8 44 02 00 00       	call   f010796b <boot_get_page_table>
f0107727:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010772a:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107731:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107735:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107739:	72 d5                	jb     f0107710 <initialize_kernel_VM+0xe7>
f010773b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010773f:	77 06                	ja     f0107747 <initialize_kernel_VM+0x11e>
f0107741:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107745:	76 c9                	jbe    f0107710 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107747:	8b 15 58 b5 6b f0    	mov    0xf06bb558,%edx
f010774d:	89 d0                	mov    %edx,%eax
f010774f:	01 c0                	add    %eax,%eax
f0107751:	01 d0                	add    %edx,%eax
f0107753:	c1 e0 03             	shl    $0x3,%eax
f0107756:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107759:	83 ec 08             	sub    $0x8,%esp
f010775c:	68 00 10 00 00       	push   $0x1000
f0107761:	ff 75 d8             	pushl  -0x28(%ebp)
f0107764:	e8 1a 01 00 00       	call   f0107883 <boot_allocate_space>
f0107769:	83 c4 10             	add    $0x10,%esp
f010776c:	a3 c0 b7 6b f0       	mov    %eax,0xf06bb7c0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107771:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107778:	83 ec 08             	sub    $0x8,%esp
f010777b:	68 00 10 00 00       	push   $0x1000
f0107780:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107783:	e8 fb 00 00 00       	call   f0107883 <boot_allocate_space>
f0107788:	83 c4 10             	add    $0x10,%esp
f010778b:	a3 80 b0 6b f0       	mov    %eax,0xf06bb080
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107790:	e8 05 05 00 00       	call   f0107c9a <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107795:	83 ec 0c             	sub    $0xc,%esp
f0107798:	68 ca 02 00 00       	push   $0x2ca
f010779d:	e8 95 62 01 00       	call   f011da37 <nearest_pow2_ceil>
f01077a2:	83 c4 10             	add    $0x10,%esp
f01077a5:	83 ec 04             	sub    $0x4,%esp
f01077a8:	50                   	push   %eax
f01077a9:	68 ca 02 00 00       	push   $0x2ca
f01077ae:	68 98 51 12 f0       	push   $0xf0125198
f01077b3:	e8 d3 97 ff ff       	call   f0100f8b <cprintf>
f01077b8:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01077bb:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01077c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01077c5:	83 ec 08             	sub    $0x8,%esp
f01077c8:	68 00 10 00 00       	push   $0x1000
f01077cd:	50                   	push   %eax
f01077ce:	e8 b0 00 00 00       	call   f0107883 <boot_allocate_space>
f01077d3:	83 c4 10             	add    $0x10,%esp
f01077d6:	a3 d0 27 69 f0       	mov    %eax,0xf06927d0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01077db:	a1 d0 27 69 f0       	mov    0xf06927d0,%eax
f01077e0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01077e3:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01077ea:	77 17                	ja     f0107803 <initialize_kernel_VM+0x1da>
f01077ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01077ef:	68 44 51 12 f0       	push   $0xf0125144
f01077f4:	68 b1 00 00 00       	push   $0xb1
f01077f9:	68 78 51 12 f0       	push   $0xf0125178
f01077fe:	e8 36 8b ff ff       	call   f0100339 <_panic>
f0107803:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107806:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010780c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010780f:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0107814:	83 ec 0c             	sub    $0xc,%esp
f0107817:	6a 04                	push   $0x4
f0107819:	51                   	push   %ecx
f010781a:	52                   	push   %edx
f010781b:	68 00 00 c0 ee       	push   $0xeec00000
f0107820:	50                   	push   %eax
f0107821:	e8 d1 00 00 00       	call   f01078f7 <boot_map_range>
f0107826:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107829:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f010782e:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107833:	8b 15 7c b9 6b f0    	mov    0xf06bb97c,%edx
f0107839:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010783f:	8b 12                	mov    (%edx),%edx
f0107841:	83 ca 05             	or     $0x5,%edx
f0107844:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107846:	a1 78 b9 6b f0       	mov    0xf06bb978,%eax
f010784b:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107851:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0107856:	83 ec 0c             	sub    $0xc,%esp
f0107859:	6a 02                	push   $0x2
f010785b:	6a 00                	push   $0x0
f010785d:	52                   	push   %edx
f010785e:	68 00 00 00 f0       	push   $0xf0000000
f0107863:	50                   	push   %eax
f0107864:	e8 8e 00 00 00       	call   f01078f7 <boot_map_range>
f0107869:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f010786c:	e8 99 71 01 00       	call   f011ea0a <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107871:	c7 05 90 b4 6b f0 19 	movl   $0x19,0xf06bb490
f0107878:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010787b:	e8 e6 02 00 00       	call   f0107b66 <turn_on_paging>
}
f0107880:	90                   	nop
f0107881:	c9                   	leave  
f0107882:	c3                   	ret    

f0107883 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107883:	55                   	push   %ebp
f0107884:	89 e5                	mov    %esp,%ebp
f0107886:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107889:	a1 78 b9 6b f0       	mov    0xf06bb978,%eax
f010788e:	85 c0                	test   %eax,%eax
f0107890:	75 0a                	jne    f010789c <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107892:	c7 05 78 b9 6b f0 90 	movl   $0xf0b06490,0xf06bb978
f0107899:	64 b0 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f010789c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010789f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01078a2:	a1 78 b9 6b f0       	mov    0xf06bb978,%eax
f01078a7:	89 c2                	mov    %eax,%edx
f01078a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078ac:	01 d0                	add    %edx,%eax
f01078ae:	48                   	dec    %eax
f01078af:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01078b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078b5:	ba 00 00 00 00       	mov    $0x0,%edx
f01078ba:	f7 75 f4             	divl   -0xc(%ebp)
f01078bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078c0:	29 d0                	sub    %edx,%eax
f01078c2:	a3 78 b9 6b f0       	mov    %eax,0xf06bb978

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01078c7:	a1 78 b9 6b f0       	mov    0xf06bb978,%eax
f01078cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01078cf:	8b 15 78 b9 6b f0    	mov    0xf06bb978,%edx
f01078d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01078d8:	01 d0                	add    %edx,%eax
f01078da:	a3 78 b9 6b f0       	mov    %eax,0xf06bb978

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01078df:	83 ec 04             	sub    $0x4,%esp
f01078e2:	ff 75 08             	pushl  0x8(%ebp)
f01078e5:	6a 00                	push   $0x0
f01078e7:	ff 75 ec             	pushl  -0x14(%ebp)
f01078ea:	e8 d8 7d 01 00       	call   f011f6c7 <memset>
f01078ef:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01078f2:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01078f5:	c9                   	leave  
f01078f6:	c3                   	ret    

f01078f7 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01078f7:	55                   	push   %ebp
f01078f8:	89 e5                	mov    %esp,%ebp
f01078fa:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01078fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107904:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010790b:	eb 53                	jmp    f0107960 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010790d:	83 ec 04             	sub    $0x4,%esp
f0107910:	6a 01                	push   $0x1
f0107912:	ff 75 0c             	pushl  0xc(%ebp)
f0107915:	ff 75 08             	pushl  0x8(%ebp)
f0107918:	e8 4e 00 00 00       	call   f010796b <boot_get_page_table>
f010791d:	83 c4 10             	add    $0x10,%esp
f0107920:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107923:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107926:	c1 e8 0c             	shr    $0xc,%eax
f0107929:	25 ff 03 00 00       	and    $0x3ff,%eax
f010792e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107931:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107934:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010793b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010793e:	01 c2                	add    %eax,%edx
f0107940:	8b 45 18             	mov    0x18(%ebp),%eax
f0107943:	0b 45 14             	or     0x14(%ebp),%eax
f0107946:	83 c8 01             	or     $0x1,%eax
f0107949:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010794b:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107952:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107959:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107960:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107963:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107966:	72 a5                	jb     f010790d <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107968:	90                   	nop
f0107969:	c9                   	leave  
f010796a:	c3                   	ret    

f010796b <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f010796b:	55                   	push   %ebp
f010796c:	89 e5                	mov    %esp,%ebp
f010796e:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107974:	c1 e8 16             	shr    $0x16,%eax
f0107977:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010797a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010797d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107984:	8b 45 08             	mov    0x8(%ebp),%eax
f0107987:	01 d0                	add    %edx,%eax
f0107989:	8b 00                	mov    (%eax),%eax
f010798b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f010798e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107991:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107996:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107999:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010799c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010799f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079a2:	c1 e8 0c             	shr    $0xc,%eax
f01079a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079a8:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f01079ad:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01079b0:	72 17                	jb     f01079c9 <boot_get_page_table+0x5e>
f01079b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01079b5:	68 c0 51 12 f0       	push   $0xf01251c0
f01079ba:	68 33 01 00 00       	push   $0x133
f01079bf:	68 78 51 12 f0       	push   $0xf0125178
f01079c4:	e8 70 89 ff ff       	call   f0100339 <_panic>
f01079c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079cc:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01079d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01079d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01079d8:	75 72                	jne    f0107a4c <boot_get_page_table+0xe1>
	{
		if (create)
f01079da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01079de:	74 65                	je     f0107a45 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01079e0:	83 ec 08             	sub    $0x8,%esp
f01079e3:	68 00 10 00 00       	push   $0x1000
f01079e8:	68 00 10 00 00       	push   $0x1000
f01079ed:	e8 91 fe ff ff       	call   f0107883 <boot_allocate_space>
f01079f2:	83 c4 10             	add    $0x10,%esp
f01079f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01079f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01079fe:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107a05:	77 17                	ja     f0107a1e <boot_get_page_table+0xb3>
f0107a07:	ff 75 dc             	pushl  -0x24(%ebp)
f0107a0a:	68 44 51 12 f0       	push   $0xf0125144
f0107a0f:	68 39 01 00 00       	push   $0x139
f0107a14:	68 78 51 12 f0       	push   $0xf0125178
f0107a19:	e8 1b 89 ff ff       	call   f0100339 <_panic>
f0107a1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a21:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a26:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107a33:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a36:	01 d0                	add    %edx,%eax
f0107a38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107a3b:	83 ca 03             	or     $0x3,%edx
f0107a3e:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a43:	eb 0a                	jmp    f0107a4f <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107a45:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a4a:	eb 03                	jmp    f0107a4f <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a4f:	c9                   	leave  
f0107a50:	c3                   	ret    

f0107a51 <nvram_read>:


int nvram_read(int r)
{
f0107a51:	55                   	push   %ebp
f0107a52:	89 e5                	mov    %esp,%ebp
f0107a54:	53                   	push   %ebx
f0107a55:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a58:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a5b:	83 ec 0c             	sub    $0xc,%esp
f0107a5e:	50                   	push   %eax
f0107a5f:	e8 28 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	89 c3                	mov    %eax,%ebx
f0107a69:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a6c:	40                   	inc    %eax
f0107a6d:	83 ec 0c             	sub    $0xc,%esp
f0107a70:	50                   	push   %eax
f0107a71:	e8 16 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a76:	83 c4 10             	add    $0x10,%esp
f0107a79:	c1 e0 08             	shl    $0x8,%eax
f0107a7c:	09 d8                	or     %ebx,%eax
}
f0107a7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a81:	c9                   	leave  
f0107a82:	c3                   	ret    

f0107a83 <detect_memory>:

void detect_memory()
{
f0107a83:	55                   	push   %ebp
f0107a84:	89 e5                	mov    %esp,%ebp
f0107a86:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a89:	83 ec 0c             	sub    $0xc,%esp
f0107a8c:	6a 15                	push   $0x15
f0107a8e:	e8 be ff ff ff       	call   f0107a51 <nvram_read>
f0107a93:	83 c4 10             	add    $0x10,%esp
f0107a96:	c1 e0 0a             	shl    $0xa,%eax
f0107a99:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107aa4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107aa7:	83 ec 0c             	sub    $0xc,%esp
f0107aaa:	6a 17                	push   $0x17
f0107aac:	e8 a0 ff ff ff       	call   f0107a51 <nvram_read>
f0107ab1:	83 c4 10             	add    $0x10,%esp
f0107ab4:	c1 e0 0a             	shl    $0xa,%eax
f0107ab7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107aba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107abd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ac2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107ac5:	83 ec 0c             	sub    $0xc,%esp
f0107ac8:	6a 34                	push   $0x34
f0107aca:	e8 82 ff ff ff       	call   f0107a51 <nvram_read>
f0107acf:	83 c4 10             	add    $0x10,%esp
f0107ad2:	c1 e0 10             	shl    $0x10,%eax
f0107ad5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107ad8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107adb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ae0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107ae3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107ae7:	74 18                	je     f0107b01 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107ae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107aec:	05 00 00 00 01       	add    $0x1000000,%eax
f0107af1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107af7:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107afc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107aff:	eb 19                	jmp    f0107b1a <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107b01:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107b05:	74 0d                	je     f0107b14 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b0a:	05 00 00 10 00       	add    $0x100000,%eax
f0107b0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107b12:	eb 06                	jmp    f0107b1a <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107b1a:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b24:	c1 e8 0c             	shr    $0xc,%eax
f0107b27:	a3 58 b5 6b f0       	mov    %eax,0xf06bb558

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b2f:	c1 e8 0a             	shr    $0xa,%eax
f0107b32:	83 ec 08             	sub    $0x8,%esp
f0107b35:	50                   	push   %eax
f0107b36:	68 f0 51 12 f0       	push   $0xf01251f0
f0107b3b:	e8 4b 94 ff ff       	call   f0100f8b <cprintf>
f0107b40:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b46:	c1 e8 0a             	shr    $0xa,%eax
f0107b49:	89 c2                	mov    %eax,%edx
f0107b4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b4e:	c1 e8 0a             	shr    $0xa,%eax
f0107b51:	83 ec 04             	sub    $0x4,%esp
f0107b54:	52                   	push   %edx
f0107b55:	50                   	push   %eax
f0107b56:	68 13 52 12 f0       	push   $0xf0125213
f0107b5b:	e8 2b 94 ff ff       	call   f0100f8b <cprintf>
f0107b60:	83 c4 10             	add    $0x10,%esp
}
f0107b63:	90                   	nop
f0107b64:	c9                   	leave  
f0107b65:	c3                   	ret    

f0107b66 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107b66:	55                   	push   %ebp
f0107b67:	89 e5                	mov    %esp,%ebp
f0107b69:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b6c:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b7a:	eb 24                	jmp    f0107ba0 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b7c:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0107b81:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b84:	c1 e2 02             	shl    $0x2,%edx
f0107b87:	01 c2                	add    %eax,%edx
f0107b89:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0107b8e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b91:	c1 e1 02             	shl    $0x2,%ecx
f0107b94:	01 c8                	add    %ecx,%eax
f0107b96:	8b 00                	mov    (%eax),%eax
f0107b98:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b9a:	ff 45 f4             	incl   -0xc(%ebp)
f0107b9d:	ff 45 f0             	incl   -0x10(%ebp)
f0107ba0:	a1 78 b9 6b f0       	mov    0xf06bb978,%eax
f0107ba5:	c1 e8 16             	shr    $0x16,%eax
f0107ba8:	89 c2                	mov    %eax,%edx
f0107baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bad:	39 c2                	cmp    %eax,%edx
f0107baf:	77 cb                	ja     f0107b7c <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107bb1:	a1 a4 ba 6b f0       	mov    0xf06bbaa4,%eax
f0107bb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107bbc:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bbf:	0f 20 c0             	mov    %cr0,%eax
f0107bc2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107bc5:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107bcb:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107bd2:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107bd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107bd9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107bdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107bdf:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107be2:	e8 e8 f5 ff ff       	call   f01071cf <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107be7:	e8 20 f5 ff ff       	call   f010710c <mycpu>
f0107bec:	83 c0 74             	add    $0x74,%eax
f0107bef:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107bf2:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107bf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107bfc:	48                   	dec    %eax
f0107bfd:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107c01:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c04:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107c08:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c0b:	c1 e8 10             	shr    $0x10,%eax
f0107c0e:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c12:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c15:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c18:	e8 04 f6 ff ff       	call   f0107221 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c1d:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c22:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c24:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c29:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c2b:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c30:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c32:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c37:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c39:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c3e:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c40:	ea 47 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c47
	asm volatile("lldt %%ax" :: "a" (0));
f0107c47:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c4c:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c4f:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c56:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c5d:	eb 19                	jmp    f0107c78 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c5f:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0107c64:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107c67:	c1 e2 02             	shl    $0x2,%edx
f0107c6a:	01 d0                	add    %edx,%eax
f0107c6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c72:	ff 45 ec             	incl   -0x14(%ebp)
f0107c75:	ff 45 e8             	incl   -0x18(%ebp)
f0107c78:	a1 78 b9 6b f0       	mov    0xf06bb978,%eax
f0107c7d:	c1 e8 16             	shr    $0x16,%eax
f0107c80:	89 c2                	mov    %eax,%edx
f0107c82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c85:	39 c2                	cmp    %eax,%edx
f0107c87:	77 d6                	ja     f0107c5f <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c89:	a1 a4 ba 6b f0       	mov    0xf06bbaa4,%eax
f0107c8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c94:	0f 22 d8             	mov    %eax,%cr3

}
f0107c97:	90                   	nop
f0107c98:	c9                   	leave  
f0107c99:	c3                   	ret    

f0107c9a <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c9a:	55                   	push   %ebp
f0107c9b:	89 e5                	mov    %esp,%ebp
f0107c9d:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107ca0:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0107ca5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107ca8:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107caf:	77 17                	ja     f0107cc8 <setup_listing_to_all_page_tables_entries+0x2e>
f0107cb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0107cb4:	68 44 51 12 f0       	push   $0xf0125144
f0107cb9:	68 cf 01 00 00       	push   $0x1cf
f0107cbe:	68 78 51 12 f0       	push   $0xf0125178
f0107cc3:	e8 71 86 ff ff       	call   f0100339 <_panic>
f0107cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ccb:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107cd3:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0107cd8:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107cdd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ce0:	83 ca 03             	or     $0x3,%edx
f0107ce3:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107ce5:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0107cea:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107cf0:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0107cf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107cf8:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107cff:	77 17                	ja     f0107d18 <setup_listing_to_all_page_tables_entries+0x7e>
f0107d01:	ff 75 ec             	pushl  -0x14(%ebp)
f0107d04:	68 44 51 12 f0       	push   $0xf0125144
f0107d09:	68 d4 01 00 00       	push   $0x1d4
f0107d0e:	68 78 51 12 f0       	push   $0xf0125178
f0107d13:	e8 21 86 ff ff       	call   f0100339 <_panic>
f0107d18:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d1b:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d20:	83 c8 05             	or     $0x5,%eax
f0107d23:	89 02                	mov    %eax,(%edx)

}
f0107d25:	90                   	nop
f0107d26:	c9                   	leave  
f0107d27:	c3                   	ret    

f0107d28 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d28:	55                   	push   %ebp
f0107d29:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d2e:	8b 15 c0 b7 6b f0    	mov    0xf06bb7c0,%edx
f0107d34:	29 d0                	sub    %edx,%eax
f0107d36:	c1 f8 03             	sar    $0x3,%eax
f0107d39:	89 c2                	mov    %eax,%edx
f0107d3b:	89 d0                	mov    %edx,%eax
f0107d3d:	c1 e0 02             	shl    $0x2,%eax
f0107d40:	01 d0                	add    %edx,%eax
f0107d42:	c1 e0 02             	shl    $0x2,%eax
f0107d45:	01 d0                	add    %edx,%eax
f0107d47:	c1 e0 02             	shl    $0x2,%eax
f0107d4a:	01 d0                	add    %edx,%eax
f0107d4c:	89 c1                	mov    %eax,%ecx
f0107d4e:	c1 e1 08             	shl    $0x8,%ecx
f0107d51:	01 c8                	add    %ecx,%eax
f0107d53:	89 c1                	mov    %eax,%ecx
f0107d55:	c1 e1 10             	shl    $0x10,%ecx
f0107d58:	01 c8                	add    %ecx,%eax
f0107d5a:	01 c0                	add    %eax,%eax
f0107d5c:	01 d0                	add    %edx,%eax
}
f0107d5e:	5d                   	pop    %ebp
f0107d5f:	c3                   	ret    

f0107d60 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107d60:	55                   	push   %ebp
f0107d61:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107d63:	ff 75 08             	pushl  0x8(%ebp)
f0107d66:	e8 bd ff ff ff       	call   f0107d28 <to_frame_number>
f0107d6b:	83 c4 04             	add    $0x4,%esp
f0107d6e:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d71:	c9                   	leave  
f0107d72:	c3                   	ret    

f0107d73 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d73:	55                   	push   %ebp
f0107d74:	89 e5                	mov    %esp,%ebp
f0107d76:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d7c:	c1 e8 0c             	shr    $0xc,%eax
f0107d7f:	89 c2                	mov    %eax,%edx
f0107d81:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f0107d86:	39 c2                	cmp    %eax,%edx
f0107d88:	72 14                	jb     f0107d9e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d8a:	83 ec 04             	sub    $0x4,%esp
f0107d8d:	68 30 52 12 f0       	push   $0xf0125230
f0107d92:	6a 56                	push   $0x56
f0107d94:	68 55 52 12 f0       	push   $0xf0125255
f0107d99:	e8 9b 85 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107d9e:	8b 15 c0 b7 6b f0    	mov    0xf06bb7c0,%edx
f0107da4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107da7:	c1 e8 0c             	shr    $0xc,%eax
f0107daa:	89 c1                	mov    %eax,%ecx
f0107dac:	89 c8                	mov    %ecx,%eax
f0107dae:	01 c0                	add    %eax,%eax
f0107db0:	01 c8                	add    %ecx,%eax
f0107db2:	c1 e0 03             	shl    $0x3,%eax
f0107db5:	01 d0                	add    %edx,%eax
}
f0107db7:	c9                   	leave  
f0107db8:	c3                   	ret    

f0107db9 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107db9:	55                   	push   %ebp
f0107dba:	89 e5                	mov    %esp,%ebp
f0107dbc:	83 ec 10             	sub    $0x10,%esp
f0107dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107dc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107dc8:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107dcb:	90                   	nop
f0107dcc:	c9                   	leave  
f0107dcd:	c3                   	ret    

f0107dce <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107dce:	55                   	push   %ebp
f0107dcf:	89 e5                	mov    %esp,%ebp
f0107dd1:	53                   	push   %ebx
f0107dd2:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107dd5:	c7 05 60 b3 6b f0 00 	movl   $0x0,0xf06bb360
f0107ddc:	00 00 00 
f0107ddf:	c7 05 64 b3 6b f0 00 	movl   $0x0,0xf06bb364
f0107de6:	00 00 00 
f0107de9:	c7 05 6c b3 6b f0 00 	movl   $0x0,0xf06bb36c
f0107df0:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107df3:	c7 05 70 b3 6b f0 00 	movl   $0x0,0xf06bb370
f0107dfa:	00 00 00 
f0107dfd:	c7 05 74 b3 6b f0 00 	movl   $0x0,0xf06bb374
f0107e04:	00 00 00 
f0107e07:	c7 05 7c b3 6b f0 00 	movl   $0x0,0xf06bb37c
f0107e0e:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e11:	83 ec 08             	sub    $0x8,%esp
f0107e14:	68 6f 52 12 f0       	push   $0xf012526f
f0107e19:	68 80 b3 6b f0       	push   $0xf06bb380
f0107e1e:	e8 c4 76 00 00       	call   f010f4e7 <init_spinlock>
f0107e23:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e26:	a1 c0 b7 6b f0       	mov    0xf06bb7c0,%eax
f0107e2b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e31:	a1 c0 b7 6b f0       	mov    0xf06bb7c0,%eax
f0107e36:	83 c0 18             	add    $0x18,%eax
f0107e39:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e3f:	a1 c0 b7 6b f0       	mov    0xf06bb7c0,%eax
f0107e44:	83 c0 30             	add    $0x30,%eax
f0107e47:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e4d:	c7 05 5c b8 6b f0 00 	movl   $0xf0001000,0xf06bb85c
f0107e54:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107e57:	c7 05 0c ba 6b f0 00 	movl   $0xf0002000,0xf06bba0c
f0107e5e:	20 00 f0 
	i =0;
f0107e61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107e68:	eb 1f                	jmp    f0107e89 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107e6a:	8b 15 5c b8 6b f0    	mov    0xf06bb85c,%edx
f0107e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e73:	01 d0                	add    %edx,%eax
f0107e75:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e78:	8b 15 0c ba 6b f0    	mov    0xf06bba0c,%edx
f0107e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e81:	01 d0                	add    %edx,%eax
f0107e83:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e86:	ff 45 f4             	incl   -0xc(%ebp)
f0107e89:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e90:	7e d8                	jle    f0107e6a <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e92:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e9c:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107ea1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ea7:	ba 00 00 00 00       	mov    $0x0,%edx
f0107eac:	f7 75 f0             	divl   -0x10(%ebp)
f0107eaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107eb2:	29 d0                	sub    %edx,%eax
f0107eb4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107eb7:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107ebe:	e9 e8 00 00 00       	jmp    f0107fab <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107ec3:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0107ec9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ecc:	89 d0                	mov    %edx,%eax
f0107ece:	01 c0                	add    %eax,%eax
f0107ed0:	01 d0                	add    %edx,%eax
f0107ed2:	c1 e0 03             	shl    $0x3,%eax
f0107ed5:	01 c8                	add    %ecx,%eax
f0107ed7:	83 ec 0c             	sub    $0xc,%esp
f0107eda:	50                   	push   %eax
f0107edb:	e8 b7 02 00 00       	call   f0108197 <initialize_frame_info>
f0107ee0:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107ee3:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0107ee9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eec:	89 d0                	mov    %edx,%eax
f0107eee:	01 c0                	add    %eax,%eax
f0107ef0:	01 d0                	add    %edx,%eax
f0107ef2:	c1 e0 03             	shl    $0x3,%eax
f0107ef5:	01 c8                	add    %ecx,%eax
f0107ef7:	85 c0                	test   %eax,%eax
f0107ef9:	75 14                	jne    f0107f0f <initialize_paging+0x141>
f0107efb:	83 ec 04             	sub    $0x4,%esp
f0107efe:	68 80 52 12 f0       	push   $0xf0125280
f0107f03:	6a 60                	push   $0x60
f0107f05:	68 a3 52 12 f0       	push   $0xf01252a3
f0107f0a:	e8 2a 84 ff ff       	call   f0100339 <_panic>
f0107f0f:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0107f15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f18:	89 d0                	mov    %edx,%eax
f0107f1a:	01 c0                	add    %eax,%eax
f0107f1c:	01 d0                	add    %edx,%eax
f0107f1e:	c1 e0 03             	shl    $0x3,%eax
f0107f21:	01 c8                	add    %ecx,%eax
f0107f23:	8b 15 60 b3 6b f0    	mov    0xf06bb360,%edx
f0107f29:	89 10                	mov    %edx,(%eax)
f0107f2b:	8b 00                	mov    (%eax),%eax
f0107f2d:	85 c0                	test   %eax,%eax
f0107f2f:	74 1f                	je     f0107f50 <initialize_paging+0x182>
f0107f31:	8b 15 60 b3 6b f0    	mov    0xf06bb360,%edx
f0107f37:	8b 1d c0 b7 6b f0    	mov    0xf06bb7c0,%ebx
f0107f3d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107f40:	89 c8                	mov    %ecx,%eax
f0107f42:	01 c0                	add    %eax,%eax
f0107f44:	01 c8                	add    %ecx,%eax
f0107f46:	c1 e0 03             	shl    $0x3,%eax
f0107f49:	01 d8                	add    %ebx,%eax
f0107f4b:	89 42 04             	mov    %eax,0x4(%edx)
f0107f4e:	eb 19                	jmp    f0107f69 <initialize_paging+0x19b>
f0107f50:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0107f56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f59:	89 d0                	mov    %edx,%eax
f0107f5b:	01 c0                	add    %eax,%eax
f0107f5d:	01 d0                	add    %edx,%eax
f0107f5f:	c1 e0 03             	shl    $0x3,%eax
f0107f62:	01 c8                	add    %ecx,%eax
f0107f64:	a3 64 b3 6b f0       	mov    %eax,0xf06bb364
f0107f69:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0107f6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f72:	89 d0                	mov    %edx,%eax
f0107f74:	01 c0                	add    %eax,%eax
f0107f76:	01 d0                	add    %edx,%eax
f0107f78:	c1 e0 03             	shl    $0x3,%eax
f0107f7b:	01 c8                	add    %ecx,%eax
f0107f7d:	a3 60 b3 6b f0       	mov    %eax,0xf06bb360
f0107f82:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0107f88:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f8b:	89 d0                	mov    %edx,%eax
f0107f8d:	01 c0                	add    %eax,%eax
f0107f8f:	01 d0                	add    %edx,%eax
f0107f91:	c1 e0 03             	shl    $0x3,%eax
f0107f94:	01 c8                	add    %ecx,%eax
f0107f96:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f9d:	a1 6c b3 6b f0       	mov    0xf06bb36c,%eax
f0107fa2:	40                   	inc    %eax
f0107fa3:	a3 6c b3 6b f0       	mov    %eax,0xf06bb36c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107fa8:	ff 45 f4             	incl   -0xc(%ebp)
f0107fab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107fae:	85 c0                	test   %eax,%eax
f0107fb0:	79 05                	jns    f0107fb7 <initialize_paging+0x1e9>
f0107fb2:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107fb7:	c1 f8 0c             	sar    $0xc,%eax
f0107fba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107fbd:	0f 8f 00 ff ff ff    	jg     f0107ec3 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fc3:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107fca:	eb 1d                	jmp    f0107fe9 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107fcc:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0107fd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fd5:	89 d0                	mov    %edx,%eax
f0107fd7:	01 c0                	add    %eax,%eax
f0107fd9:	01 d0                	add    %edx,%eax
f0107fdb:	c1 e0 03             	shl    $0x3,%eax
f0107fde:	01 c8                	add    %ecx,%eax
f0107fe0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fe6:	ff 45 f4             	incl   -0xc(%ebp)
f0107fe9:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107ff0:	7e da                	jle    f0107fcc <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107ff2:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107ff9:	a1 78 b9 6b f0       	mov    0xf06bb978,%eax
f0107ffe:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108001:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108008:	77 14                	ja     f010801e <initialize_paging+0x250>
f010800a:	ff 75 e0             	pushl  -0x20(%ebp)
f010800d:	68 c0 52 12 f0       	push   $0xf01252c0
f0108012:	6a 68                	push   $0x68
f0108014:	68 a3 52 12 f0       	push   $0xf01252a3
f0108019:	e8 1b 83 ff ff       	call   f0100339 <_panic>
f010801e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108021:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108027:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010802a:	01 d0                	add    %edx,%eax
f010802c:	48                   	dec    %eax
f010802d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108030:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108033:	ba 00 00 00 00       	mov    $0x0,%edx
f0108038:	f7 75 e4             	divl   -0x1c(%ebp)
f010803b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010803e:	29 d0                	sub    %edx,%eax
f0108040:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108043:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f010804a:	eb 1d                	jmp    f0108069 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f010804c:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0108052:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108055:	89 d0                	mov    %edx,%eax
f0108057:	01 c0                	add    %eax,%eax
f0108059:	01 d0                	add    %edx,%eax
f010805b:	c1 e0 03             	shl    $0x3,%eax
f010805e:	01 c8                	add    %ecx,%eax
f0108060:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108066:	ff 45 f4             	incl   -0xc(%ebp)
f0108069:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010806c:	85 c0                	test   %eax,%eax
f010806e:	79 05                	jns    f0108075 <initialize_paging+0x2a7>
f0108070:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108075:	c1 f8 0c             	sar    $0xc,%eax
f0108078:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010807b:	7f cf                	jg     f010804c <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010807d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108080:	85 c0                	test   %eax,%eax
f0108082:	79 05                	jns    f0108089 <initialize_paging+0x2bb>
f0108084:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108089:	c1 f8 0c             	sar    $0xc,%eax
f010808c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010808f:	e9 e8 00 00 00       	jmp    f010817c <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108094:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f010809a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010809d:	89 d0                	mov    %edx,%eax
f010809f:	01 c0                	add    %eax,%eax
f01080a1:	01 d0                	add    %edx,%eax
f01080a3:	c1 e0 03             	shl    $0x3,%eax
f01080a6:	01 c8                	add    %ecx,%eax
f01080a8:	83 ec 0c             	sub    $0xc,%esp
f01080ab:	50                   	push   %eax
f01080ac:	e8 e6 00 00 00       	call   f0108197 <initialize_frame_info>
f01080b1:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01080b4:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f01080ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bd:	89 d0                	mov    %edx,%eax
f01080bf:	01 c0                	add    %eax,%eax
f01080c1:	01 d0                	add    %edx,%eax
f01080c3:	c1 e0 03             	shl    $0x3,%eax
f01080c6:	01 c8                	add    %ecx,%eax
f01080c8:	85 c0                	test   %eax,%eax
f01080ca:	75 14                	jne    f01080e0 <initialize_paging+0x312>
f01080cc:	83 ec 04             	sub    $0x4,%esp
f01080cf:	68 80 52 12 f0       	push   $0xf0125280
f01080d4:	6a 74                	push   $0x74
f01080d6:	68 a3 52 12 f0       	push   $0xf01252a3
f01080db:	e8 59 82 ff ff       	call   f0100339 <_panic>
f01080e0:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f01080e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080e9:	89 d0                	mov    %edx,%eax
f01080eb:	01 c0                	add    %eax,%eax
f01080ed:	01 d0                	add    %edx,%eax
f01080ef:	c1 e0 03             	shl    $0x3,%eax
f01080f2:	01 c8                	add    %ecx,%eax
f01080f4:	8b 15 60 b3 6b f0    	mov    0xf06bb360,%edx
f01080fa:	89 10                	mov    %edx,(%eax)
f01080fc:	8b 00                	mov    (%eax),%eax
f01080fe:	85 c0                	test   %eax,%eax
f0108100:	74 1f                	je     f0108121 <initialize_paging+0x353>
f0108102:	8b 15 60 b3 6b f0    	mov    0xf06bb360,%edx
f0108108:	8b 1d c0 b7 6b f0    	mov    0xf06bb7c0,%ebx
f010810e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108111:	89 c8                	mov    %ecx,%eax
f0108113:	01 c0                	add    %eax,%eax
f0108115:	01 c8                	add    %ecx,%eax
f0108117:	c1 e0 03             	shl    $0x3,%eax
f010811a:	01 d8                	add    %ebx,%eax
f010811c:	89 42 04             	mov    %eax,0x4(%edx)
f010811f:	eb 19                	jmp    f010813a <initialize_paging+0x36c>
f0108121:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0108127:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010812a:	89 d0                	mov    %edx,%eax
f010812c:	01 c0                	add    %eax,%eax
f010812e:	01 d0                	add    %edx,%eax
f0108130:	c1 e0 03             	shl    $0x3,%eax
f0108133:	01 c8                	add    %ecx,%eax
f0108135:	a3 64 b3 6b f0       	mov    %eax,0xf06bb364
f010813a:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0108140:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108143:	89 d0                	mov    %edx,%eax
f0108145:	01 c0                	add    %eax,%eax
f0108147:	01 d0                	add    %edx,%eax
f0108149:	c1 e0 03             	shl    $0x3,%eax
f010814c:	01 c8                	add    %ecx,%eax
f010814e:	a3 60 b3 6b f0       	mov    %eax,0xf06bb360
f0108153:	8b 0d c0 b7 6b f0    	mov    0xf06bb7c0,%ecx
f0108159:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010815c:	89 d0                	mov    %edx,%eax
f010815e:	01 c0                	add    %eax,%eax
f0108160:	01 d0                	add    %edx,%eax
f0108162:	c1 e0 03             	shl    $0x3,%eax
f0108165:	01 c8                	add    %ecx,%eax
f0108167:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010816e:	a1 6c b3 6b f0       	mov    0xf06bb36c,%eax
f0108173:	40                   	inc    %eax
f0108174:	a3 6c b3 6b f0       	mov    %eax,0xf06bb36c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108179:	ff 45 f4             	incl   -0xc(%ebp)
f010817c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010817f:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f0108184:	39 c2                	cmp    %eax,%edx
f0108186:	0f 82 08 ff ff ff    	jb     f0108094 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010818c:	e8 00 bb ff ff       	call   f0103c91 <initialize_disk_page_file>
}
f0108191:	90                   	nop
f0108192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108195:	c9                   	leave  
f0108196:	c3                   	ret    

f0108197 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0108197:	55                   	push   %ebp
f0108198:	89 e5                	mov    %esp,%ebp
f010819a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010819d:	83 ec 04             	sub    $0x4,%esp
f01081a0:	6a 18                	push   $0x18
f01081a2:	6a 00                	push   $0x0
f01081a4:	ff 75 08             	pushl  0x8(%ebp)
f01081a7:	e8 1b 75 01 00       	call   f011f6c7 <memset>
f01081ac:	83 c4 10             	add    $0x10,%esp
}
f01081af:	90                   	nop
f01081b0:	c9                   	leave  
f01081b1:	c3                   	ret    

f01081b2 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01081b2:	55                   	push   %ebp
f01081b3:	89 e5                	mov    %esp,%ebp
f01081b5:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01081b8:	83 ec 0c             	sub    $0xc,%esp
f01081bb:	68 80 b3 6b f0       	push   $0xf06bb380
f01081c0:	e8 6c 75 00 00       	call   f010f731 <holding_spinlock>
f01081c5:	83 c4 10             	add    $0x10,%esp
f01081c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01081cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081cf:	75 10                	jne    f01081e1 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01081d1:	83 ec 0c             	sub    $0xc,%esp
f01081d4:	68 80 b3 6b f0       	push   $0xf06bb380
f01081d9:	e8 3a 73 00 00       	call   f010f518 <acquire_spinlock>
f01081de:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01081e1:	8b 15 60 b3 6b f0    	mov    0xf06bb360,%edx
f01081e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ea:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01081ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01081f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f6:	8b 00                	mov    (%eax),%eax
f01081f8:	85 c0                	test   %eax,%eax
f01081fa:	75 17                	jne    f0108213 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01081fc:	83 ec 04             	sub    $0x4,%esp
f01081ff:	68 f4 52 12 f0       	push   $0xf01252f4
f0108204:	68 a2 00 00 00       	push   $0xa2
f0108209:	68 a3 52 12 f0       	push   $0xf01252a3
f010820e:	e8 26 81 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108213:	8b 45 08             	mov    0x8(%ebp),%eax
f0108216:	8b 00                	mov    (%eax),%eax
f0108218:	85 c0                	test   %eax,%eax
f010821a:	75 17                	jne    f0108233 <allocate_frame+0x81>
f010821c:	83 ec 04             	sub    $0x4,%esp
f010821f:	68 41 53 12 f0       	push   $0xf0125341
f0108224:	68 a8 00 00 00       	push   $0xa8
f0108229:	68 a3 52 12 f0       	push   $0xf01252a3
f010822e:	e8 06 81 ff ff       	call   f0100339 <_panic>
f0108233:	8b 45 08             	mov    0x8(%ebp),%eax
f0108236:	8b 00                	mov    (%eax),%eax
f0108238:	8b 00                	mov    (%eax),%eax
f010823a:	85 c0                	test   %eax,%eax
f010823c:	74 14                	je     f0108252 <allocate_frame+0xa0>
f010823e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108241:	8b 00                	mov    (%eax),%eax
f0108243:	8b 00                	mov    (%eax),%eax
f0108245:	8b 55 08             	mov    0x8(%ebp),%edx
f0108248:	8b 12                	mov    (%edx),%edx
f010824a:	8b 52 04             	mov    0x4(%edx),%edx
f010824d:	89 50 04             	mov    %edx,0x4(%eax)
f0108250:	eb 0d                	jmp    f010825f <allocate_frame+0xad>
f0108252:	8b 45 08             	mov    0x8(%ebp),%eax
f0108255:	8b 00                	mov    (%eax),%eax
f0108257:	8b 40 04             	mov    0x4(%eax),%eax
f010825a:	a3 64 b3 6b f0       	mov    %eax,0xf06bb364
f010825f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108262:	8b 00                	mov    (%eax),%eax
f0108264:	8b 40 04             	mov    0x4(%eax),%eax
f0108267:	85 c0                	test   %eax,%eax
f0108269:	74 13                	je     f010827e <allocate_frame+0xcc>
f010826b:	8b 45 08             	mov    0x8(%ebp),%eax
f010826e:	8b 00                	mov    (%eax),%eax
f0108270:	8b 40 04             	mov    0x4(%eax),%eax
f0108273:	8b 55 08             	mov    0x8(%ebp),%edx
f0108276:	8b 12                	mov    (%edx),%edx
f0108278:	8b 12                	mov    (%edx),%edx
f010827a:	89 10                	mov    %edx,(%eax)
f010827c:	eb 0c                	jmp    f010828a <allocate_frame+0xd8>
f010827e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108281:	8b 00                	mov    (%eax),%eax
f0108283:	8b 00                	mov    (%eax),%eax
f0108285:	a3 60 b3 6b f0       	mov    %eax,0xf06bb360
f010828a:	8b 45 08             	mov    0x8(%ebp),%eax
f010828d:	8b 00                	mov    (%eax),%eax
f010828f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108295:	8b 45 08             	mov    0x8(%ebp),%eax
f0108298:	8b 00                	mov    (%eax),%eax
f010829a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082a1:	a1 6c b3 6b f0       	mov    0xf06bb36c,%eax
f01082a6:	48                   	dec    %eax
f01082a7:	a3 6c b3 6b f0       	mov    %eax,0xf06bb36c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01082ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01082af:	8b 00                	mov    (%eax),%eax
f01082b1:	8a 40 14             	mov    0x14(%eax),%al
f01082b4:	84 c0                	test   %al,%al
f01082b6:	74 20                	je     f01082d8 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01082b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082bb:	8b 00                	mov    (%eax),%eax
f01082bd:	8b 50 10             	mov    0x10(%eax),%edx
f01082c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01082c3:	8b 00                	mov    (%eax),%eax
f01082c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01082c8:	8b 40 64             	mov    0x64(%eax),%eax
f01082cb:	83 ec 08             	sub    $0x8,%esp
f01082ce:	52                   	push   %edx
f01082cf:	50                   	push   %eax
f01082d0:	e8 02 13 00 00       	call   f01095d7 <pt_clear_page_table_entry>
f01082d5:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01082d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082db:	8b 00                	mov    (%eax),%eax
f01082dd:	83 ec 0c             	sub    $0xc,%esp
f01082e0:	50                   	push   %eax
f01082e1:	e8 b1 fe ff ff       	call   f0108197 <initialize_frame_info>
f01082e6:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01082e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082ed:	75 10                	jne    f01082ff <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01082ef:	83 ec 0c             	sub    $0xc,%esp
f01082f2:	68 80 b3 6b f0       	push   $0xf06bb380
f01082f7:	e8 a3 72 00 00       	call   f010f59f <release_spinlock>
f01082fc:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01082ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108304:	c9                   	leave  
f0108305:	c3                   	ret    

f0108306 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108306:	55                   	push   %ebp
f0108307:	89 e5                	mov    %esp,%ebp
f0108309:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010830c:	83 ec 0c             	sub    $0xc,%esp
f010830f:	68 80 b3 6b f0       	push   $0xf06bb380
f0108314:	e8 18 74 00 00       	call   f010f731 <holding_spinlock>
f0108319:	83 c4 10             	add    $0x10,%esp
f010831c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010831f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108323:	75 10                	jne    f0108335 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108325:	83 ec 0c             	sub    $0xc,%esp
f0108328:	68 80 b3 6b f0       	push   $0xf06bb380
f010832d:	e8 e6 71 00 00       	call   f010f518 <acquire_spinlock>
f0108332:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108335:	83 ec 0c             	sub    $0xc,%esp
f0108338:	ff 75 08             	pushl  0x8(%ebp)
f010833b:	e8 57 fe ff ff       	call   f0108197 <initialize_frame_info>
f0108340:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108343:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108347:	75 17                	jne    f0108360 <free_frame+0x5a>
f0108349:	83 ec 04             	sub    $0x4,%esp
f010834c:	68 80 52 12 f0       	push   $0xf0125280
f0108351:	68 cf 00 00 00       	push   $0xcf
f0108356:	68 a3 52 12 f0       	push   $0xf01252a3
f010835b:	e8 d9 7f ff ff       	call   f0100339 <_panic>
f0108360:	8b 15 60 b3 6b f0    	mov    0xf06bb360,%edx
f0108366:	8b 45 08             	mov    0x8(%ebp),%eax
f0108369:	89 10                	mov    %edx,(%eax)
f010836b:	8b 45 08             	mov    0x8(%ebp),%eax
f010836e:	8b 00                	mov    (%eax),%eax
f0108370:	85 c0                	test   %eax,%eax
f0108372:	74 0d                	je     f0108381 <free_frame+0x7b>
f0108374:	a1 60 b3 6b f0       	mov    0xf06bb360,%eax
f0108379:	8b 55 08             	mov    0x8(%ebp),%edx
f010837c:	89 50 04             	mov    %edx,0x4(%eax)
f010837f:	eb 08                	jmp    f0108389 <free_frame+0x83>
f0108381:	8b 45 08             	mov    0x8(%ebp),%eax
f0108384:	a3 64 b3 6b f0       	mov    %eax,0xf06bb364
f0108389:	8b 45 08             	mov    0x8(%ebp),%eax
f010838c:	a3 60 b3 6b f0       	mov    %eax,0xf06bb360
f0108391:	8b 45 08             	mov    0x8(%ebp),%eax
f0108394:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010839b:	a1 6c b3 6b f0       	mov    0xf06bb36c,%eax
f01083a0:	40                   	inc    %eax
f01083a1:	a3 6c b3 6b f0       	mov    %eax,0xf06bb36c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01083a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083aa:	75 10                	jne    f01083bc <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01083ac:	83 ec 0c             	sub    $0xc,%esp
f01083af:	68 80 b3 6b f0       	push   $0xf06bb380
f01083b4:	e8 e6 71 00 00       	call   f010f59f <release_spinlock>
f01083b9:	83 c4 10             	add    $0x10,%esp
	}
}
f01083bc:	90                   	nop
f01083bd:	c9                   	leave  
f01083be:	c3                   	ret    

f01083bf <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01083bf:	55                   	push   %ebp
f01083c0:	89 e5                	mov    %esp,%ebp
f01083c2:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01083c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01083c8:	8b 40 08             	mov    0x8(%eax),%eax
f01083cb:	48                   	dec    %eax
f01083cc:	8b 55 08             	mov    0x8(%ebp),%edx
f01083cf:	66 89 42 08          	mov    %ax,0x8(%edx)
f01083d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01083d6:	8b 40 08             	mov    0x8(%eax),%eax
f01083d9:	66 85 c0             	test   %ax,%ax
f01083dc:	75 0e                	jne    f01083ec <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01083de:	83 ec 0c             	sub    $0xc,%esp
f01083e1:	ff 75 08             	pushl  0x8(%ebp)
f01083e4:	e8 1d ff ff ff       	call   f0108306 <free_frame>
f01083e9:	83 c4 10             	add    $0x10,%esp
}
f01083ec:	90                   	nop
f01083ed:	c9                   	leave  
f01083ee:	c3                   	ret    

f01083ef <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01083ef:	55                   	push   %ebp
f01083f0:	89 e5                	mov    %esp,%ebp
f01083f2:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01083f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083f8:	c1 e8 16             	shr    $0x16,%eax
f01083fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108402:	8b 45 08             	mov    0x8(%ebp),%eax
f0108405:	01 d0                	add    %edx,%eax
f0108407:	8b 00                	mov    (%eax),%eax
f0108409:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f010840c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840f:	83 e0 01             	and    $0x1,%eax
f0108412:	85 c0                	test   %eax,%eax
f0108414:	74 74                	je     f010848a <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108416:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010841d:	77 1d                	ja     f010843c <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010841f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108422:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108427:	83 ec 0c             	sub    $0xc,%esp
f010842a:	50                   	push   %eax
f010842b:	e8 5e 10 00 00       	call   f010948e <kheap_virtual_address>
f0108430:	83 c4 10             	add    $0x10,%esp
f0108433:	89 c2                	mov    %eax,%edx
f0108435:	8b 45 10             	mov    0x10(%ebp),%eax
f0108438:	89 10                	mov    %edx,(%eax)
f010843a:	eb 44                	jmp    f0108480 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010843c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010843f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108444:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108447:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010844a:	c1 e8 0c             	shr    $0xc,%eax
f010844d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108450:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f0108455:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108458:	72 17                	jb     f0108471 <get_page_table+0x82>
f010845a:	ff 75 f0             	pushl  -0x10(%ebp)
f010845d:	68 60 53 12 f0       	push   $0xf0125360
f0108462:	68 fb 00 00 00       	push   $0xfb
f0108467:	68 a3 52 12 f0       	push   $0xf01252a3
f010846c:	e8 c8 7e ff ff       	call   f0100339 <_panic>
f0108471:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108474:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108479:	89 c2                	mov    %eax,%edx
f010847b:	8b 45 10             	mov    0x10(%ebp),%eax
f010847e:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108480:	b8 00 00 00 00       	mov    $0x0,%eax
f0108485:	e9 b9 00 00 00       	jmp    f0108543 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010848a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010848e:	0f 84 a1 00 00 00    	je     f0108535 <get_page_table+0x146>
f0108494:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108497:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010849a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010849d:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01084a0:	83 ec 0c             	sub    $0xc,%esp
f01084a3:	6a 00                	push   $0x0
f01084a5:	e8 00 6b 00 00       	call   f010efaa <fault_handler>
f01084aa:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084b0:	c1 e8 16             	shr    $0x16,%eax
f01084b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01084ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01084bd:	01 d0                	add    %edx,%eax
f01084bf:	8b 00                	mov    (%eax),%eax
f01084c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01084c4:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01084cb:	77 1d                	ja     f01084ea <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084d5:	83 ec 0c             	sub    $0xc,%esp
f01084d8:	50                   	push   %eax
f01084d9:	e8 b0 0f 00 00       	call   f010948e <kheap_virtual_address>
f01084de:	83 c4 10             	add    $0x10,%esp
f01084e1:	89 c2                	mov    %eax,%edx
f01084e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01084e6:	89 10                	mov    %edx,(%eax)
f01084e8:	eb 44                	jmp    f010852e <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084ed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01084f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084f8:	c1 e8 0c             	shr    $0xc,%eax
f01084fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01084fe:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f0108503:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108506:	72 17                	jb     f010851f <get_page_table+0x130>
f0108508:	ff 75 e8             	pushl  -0x18(%ebp)
f010850b:	68 60 53 12 f0       	push   $0xf0125360
f0108510:	68 13 01 00 00       	push   $0x113
f0108515:	68 a3 52 12 f0       	push   $0xf01252a3
f010851a:	e8 1a 7e ff ff       	call   f0100339 <_panic>
f010851f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108522:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108527:	89 c2                	mov    %eax,%edx
f0108529:	8b 45 10             	mov    0x10(%ebp),%eax
f010852c:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f010852e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108533:	eb 0e                	jmp    f0108543 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108535:	8b 45 10             	mov    0x10(%ebp),%eax
f0108538:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010853e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108543:	c9                   	leave  
f0108544:	c3                   	ret    

f0108545 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108545:	55                   	push   %ebp
f0108546:	89 e5                	mov    %esp,%ebp
f0108548:	53                   	push   %ebx
f0108549:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f010854c:	83 ec 0c             	sub    $0xc,%esp
f010854f:	68 00 10 00 00       	push   $0x1000
f0108554:	e8 92 0b 00 00       	call   f01090eb <kmalloc>
f0108559:	83 c4 10             	add    $0x10,%esp
f010855c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010855f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108563:	75 17                	jne    f010857c <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108565:	83 ec 04             	sub    $0x4,%esp
f0108568:	68 8f 53 12 f0       	push   $0xf012538f
f010856d:	68 33 01 00 00       	push   $0x133
f0108572:	68 a3 52 12 f0       	push   $0xf01252a3
f0108577:	e8 bd 7d ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010857c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010857f:	c1 e8 16             	shr    $0x16,%eax
f0108582:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108589:	8b 45 08             	mov    0x8(%ebp),%eax
f010858c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010858f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108592:	83 ec 0c             	sub    $0xc,%esp
f0108595:	50                   	push   %eax
f0108596:	e8 96 0e 00 00       	call   f0109431 <kheap_physical_address>
f010859b:	83 c4 10             	add    $0x10,%esp
f010859e:	83 c8 07             	or     $0x7,%eax
f01085a1:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01085a3:	83 ec 04             	sub    $0x4,%esp
f01085a6:	68 00 10 00 00       	push   $0x1000
f01085ab:	6a 00                	push   $0x0
f01085ad:	ff 75 f4             	pushl  -0xc(%ebp)
f01085b0:	e8 12 71 01 00       	call   f011f6c7 <memset>
f01085b5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01085b8:	0f 20 d8             	mov    %cr3,%eax
f01085bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01085be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085c1:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01085c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01085c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01085ca:	c9                   	leave  
f01085cb:	c3                   	ret    

f01085cc <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01085cc:	55                   	push   %ebp
f01085cd:	89 e5                	mov    %esp,%ebp
f01085cf:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01085d2:	83 ec 0c             	sub    $0xc,%esp
f01085d5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01085d8:	50                   	push   %eax
f01085d9:	e8 d4 fb ff ff       	call   f01081b2 <allocate_frame>
f01085de:	83 c4 10             	add    $0x10,%esp
f01085e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f01085e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085e7:	83 ec 0c             	sub    $0xc,%esp
f01085ea:	50                   	push   %eax
f01085eb:	e8 70 f7 ff ff       	call   f0107d60 <to_physical_address>
f01085f0:	83 c4 10             	add    $0x10,%esp
f01085f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f01085f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01085fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01085ff:	c1 e8 0c             	shr    $0xc,%eax
f0108602:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108605:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f010860a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f010860d:	72 17                	jb     f0108626 <__static_cpt+0x5a>
f010860f:	ff 75 ec             	pushl  -0x14(%ebp)
f0108612:	68 60 53 12 f0       	push   $0xf0125360
f0108617:	68 4e 01 00 00       	push   $0x14e
f010861c:	68 a3 52 12 f0       	push   $0xf01252a3
f0108621:	e8 13 7d ff ff       	call   f0100339 <_panic>
f0108626:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108629:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010862e:	89 c2                	mov    %eax,%edx
f0108630:	8b 45 10             	mov    0x10(%ebp),%eax
f0108633:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108635:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108638:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f010863e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108641:	c1 e8 16             	shr    $0x16,%eax
f0108644:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010864b:	8b 45 08             	mov    0x8(%ebp),%eax
f010864e:	01 d0                	add    %edx,%eax
f0108650:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108653:	83 ca 07             	or     $0x7,%edx
f0108656:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108658:	8b 45 10             	mov    0x10(%ebp),%eax
f010865b:	8b 00                	mov    (%eax),%eax
f010865d:	83 ec 04             	sub    $0x4,%esp
f0108660:	68 00 10 00 00       	push   $0x1000
f0108665:	6a 00                	push   $0x0
f0108667:	50                   	push   %eax
f0108668:	e8 5a 70 01 00       	call   f011f6c7 <memset>
f010866d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108670:	0f 20 d8             	mov    %cr3,%eax
f0108673:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108679:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010867c:	90                   	nop
f010867d:	c9                   	leave  
f010867e:	c3                   	ret    

f010867f <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f010867f:	55                   	push   %ebp
f0108680:	89 e5                	mov    %esp,%ebp
f0108682:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108685:	ff 75 0c             	pushl  0xc(%ebp)
f0108688:	e8 d3 f6 ff ff       	call   f0107d60 <to_physical_address>
f010868d:	83 c4 04             	add    $0x4,%esp
f0108690:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108693:	83 ec 04             	sub    $0x4,%esp
f0108696:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108699:	50                   	push   %eax
f010869a:	ff 75 10             	pushl  0x10(%ebp)
f010869d:	ff 75 08             	pushl  0x8(%ebp)
f01086a0:	e8 4a fd ff ff       	call   f01083ef <get_page_table>
f01086a5:	83 c4 10             	add    $0x10,%esp
f01086a8:	83 f8 01             	cmp    $0x1,%eax
f01086ab:	75 1b                	jne    f01086c8 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01086ad:	83 ec 08             	sub    $0x8,%esp
f01086b0:	ff 75 10             	pushl  0x10(%ebp)
f01086b3:	ff 75 08             	pushl  0x8(%ebp)
f01086b6:	e8 8a fe ff ff       	call   f0108545 <create_page_table>
f01086bb:	83 c4 10             	add    $0x10,%esp
f01086be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01086c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01086c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086cb:	8b 55 10             	mov    0x10(%ebp),%edx
f01086ce:	c1 ea 0c             	shr    $0xc,%edx
f01086d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086d7:	c1 e2 02             	shl    $0x2,%edx
f01086da:	01 d0                	add    %edx,%eax
f01086dc:	8b 00                	mov    (%eax),%eax
f01086de:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f01086e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086e4:	83 e0 01             	and    $0x1,%eax
f01086e7:	85 c0                	test   %eax,%eax
f01086e9:	74 25                	je     f0108710 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f01086eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01086f3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01086f6:	75 07                	jne    f01086ff <map_frame+0x80>
			return 0;
f01086f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01086fd:	eb 68                	jmp    f0108767 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f01086ff:	83 ec 08             	sub    $0x8,%esp
f0108702:	ff 75 10             	pushl  0x10(%ebp)
f0108705:	ff 75 08             	pushl  0x8(%ebp)
f0108708:	e8 d2 00 00 00       	call   f01087df <unmap_frame>
f010870d:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108710:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108713:	8b 40 08             	mov    0x8(%eax),%eax
f0108716:	40                   	inc    %eax
f0108717:	8b 55 0c             	mov    0xc(%ebp),%edx
f010871a:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010871e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108721:	8b 55 10             	mov    0x10(%ebp),%edx
f0108724:	c1 ea 0c             	shr    $0xc,%edx
f0108727:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010872d:	c1 e2 02             	shl    $0x2,%edx
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	25 00 0e 00 00       	and    $0xe00,%eax
f0108739:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010873c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010873f:	8b 55 10             	mov    0x10(%ebp),%edx
f0108742:	c1 ea 0c             	shr    $0xc,%edx
f0108745:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010874b:	c1 e2 02             	shl    $0x2,%edx
f010874e:	01 c2                	add    %eax,%edx
f0108750:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108753:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108756:	89 c1                	mov    %eax,%ecx
f0108758:	8b 45 14             	mov    0x14(%ebp),%eax
f010875b:	09 c8                	or     %ecx,%eax
f010875d:	83 c8 01             	or     $0x1,%eax
f0108760:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108762:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108767:	c9                   	leave  
f0108768:	c3                   	ret    

f0108769 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108769:	55                   	push   %ebp
f010876a:	89 e5                	mov    %esp,%ebp
f010876c:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f010876f:	83 ec 04             	sub    $0x4,%esp
f0108772:	ff 75 10             	pushl  0x10(%ebp)
f0108775:	ff 75 0c             	pushl  0xc(%ebp)
f0108778:	ff 75 08             	pushl  0x8(%ebp)
f010877b:	e8 6f fc ff ff       	call   f01083ef <get_page_table>
f0108780:	83 c4 10             	add    $0x10,%esp
f0108783:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108786:	8b 45 10             	mov    0x10(%ebp),%eax
f0108789:	8b 00                	mov    (%eax),%eax
f010878b:	85 c0                	test   %eax,%eax
f010878d:	74 49                	je     f01087d8 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f010878f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108792:	c1 e8 0c             	shr    $0xc,%eax
f0108795:	25 ff 03 00 00       	and    $0x3ff,%eax
f010879a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010879d:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a0:	8b 00                	mov    (%eax),%eax
f01087a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01087a5:	c1 e2 02             	shl    $0x2,%edx
f01087a8:	01 d0                	add    %edx,%eax
f01087aa:	8b 00                	mov    (%eax),%eax
f01087ac:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f01087af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087b7:	85 c0                	test   %eax,%eax
f01087b9:	74 16                	je     f01087d1 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f01087bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087c3:	83 ec 0c             	sub    $0xc,%esp
f01087c6:	50                   	push   %eax
f01087c7:	e8 a7 f5 ff ff       	call   f0107d73 <to_frame_info>
f01087cc:	83 c4 10             	add    $0x10,%esp
f01087cf:	eb 0c                	jmp    f01087dd <get_frame_info+0x74>
		}
		return 0;
f01087d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01087d6:	eb 05                	jmp    f01087dd <get_frame_info+0x74>
	}
	return 0;
f01087d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01087dd:	c9                   	leave  
f01087de:	c3                   	ret    

f01087df <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f01087df:	55                   	push   %ebp
f01087e0:	89 e5                	mov    %esp,%ebp
f01087e2:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f01087e5:	83 ec 04             	sub    $0x4,%esp
f01087e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01087eb:	50                   	push   %eax
f01087ec:	ff 75 0c             	pushl  0xc(%ebp)
f01087ef:	ff 75 08             	pushl  0x8(%ebp)
f01087f2:	e8 72 ff ff ff       	call   f0108769 <get_frame_info>
f01087f7:	83 c4 10             	add    $0x10,%esp
f01087fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f01087fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108801:	74 7d                	je     f0108880 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108803:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108806:	8a 40 14             	mov    0x14(%eax),%al
f0108809:	84 c0                	test   %al,%al
f010880b:	74 1c                	je     f0108829 <unmap_frame+0x4a>
f010880d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108814:	77 13                	ja     f0108829 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108816:	83 ec 08             	sub    $0x8,%esp
f0108819:	ff 75 0c             	pushl  0xc(%ebp)
f010881c:	68 ac 53 12 f0       	push   $0xf01253ac
f0108821:	e8 65 87 ff ff       	call   f0100f8b <cprintf>
f0108826:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108829:	83 ec 0c             	sub    $0xc,%esp
f010882c:	ff 75 f4             	pushl  -0xc(%ebp)
f010882f:	e8 8b fb ff ff       	call   f01083bf <decrement_references>
f0108834:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108837:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010883a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010883d:	c1 ea 0c             	shr    $0xc,%edx
f0108840:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108846:	c1 e2 02             	shl    $0x2,%edx
f0108849:	01 d0                	add    %edx,%eax
f010884b:	8b 00                	mov    (%eax),%eax
f010884d:	25 00 0e 00 00       	and    $0xe00,%eax
f0108852:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108855:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108858:	8b 55 0c             	mov    0xc(%ebp),%edx
f010885b:	c1 ea 0c             	shr    $0xc,%edx
f010885e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108864:	c1 e2 02             	shl    $0x2,%edx
f0108867:	01 c2                	add    %eax,%edx
f0108869:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010886c:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f010886e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108871:	83 ec 08             	sub    $0x8,%esp
f0108874:	50                   	push   %eax
f0108875:	ff 75 08             	pushl  0x8(%ebp)
f0108878:	e8 3c f5 ff ff       	call   f0107db9 <tlb_invalidate>
f010887d:	83 c4 10             	add    $0x10,%esp
	}
}
f0108880:	90                   	nop
f0108881:	c9                   	leave  
f0108882:	c3                   	ret    

f0108883 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108883:	55                   	push   %ebp
f0108884:	89 e5                	mov    %esp,%ebp
f0108886:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108889:	ff 75 0c             	pushl  0xc(%ebp)
f010888c:	e8 cf f4 ff ff       	call   f0107d60 <to_physical_address>
f0108891:	83 c4 04             	add    $0x4,%esp
f0108894:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108897:	8b 45 10             	mov    0x10(%ebp),%eax
f010889a:	c1 e8 16             	shr    $0x16,%eax
f010889d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088a7:	01 d0                	add    %edx,%eax
f01088a9:	8b 00                	mov    (%eax),%eax
f01088ab:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01088ae:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01088b5:	77 19                	ja     f01088d0 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088bf:	83 ec 0c             	sub    $0xc,%esp
f01088c2:	50                   	push   %eax
f01088c3:	e8 c6 0b 00 00       	call   f010948e <kheap_virtual_address>
f01088c8:	83 c4 10             	add    $0x10,%esp
f01088cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01088ce:	eb 40                	jmp    f0108910 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01088db:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01088de:	c1 e8 0c             	shr    $0xc,%eax
f01088e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088e4:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f01088e9:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01088ec:	72 17                	jb     f0108905 <loadtime_map_frame+0x82>
f01088ee:	ff 75 e8             	pushl  -0x18(%ebp)
f01088f1:	68 60 53 12 f0       	push   $0xf0125360
f01088f6:	68 fa 01 00 00       	push   $0x1fa
f01088fb:	68 a3 52 12 f0       	push   $0xf01252a3
f0108900:	e8 34 7a ff ff       	call   f0100339 <_panic>
f0108905:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108908:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010890d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108910:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108914:	75 14                	jne    f010892a <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108916:	83 ec 08             	sub    $0x8,%esp
f0108919:	ff 75 10             	pushl  0x10(%ebp)
f010891c:	ff 75 08             	pushl  0x8(%ebp)
f010891f:	e8 21 fc ff ff       	call   f0108545 <create_page_table>
f0108924:	83 c4 10             	add    $0x10,%esp
f0108927:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010892a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010892d:	8b 40 08             	mov    0x8(%eax),%eax
f0108930:	40                   	inc    %eax
f0108931:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108934:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108938:	8b 45 10             	mov    0x10(%ebp),%eax
f010893b:	c1 e8 0c             	shr    $0xc,%eax
f010893e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108943:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010894a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010894d:	01 c2                	add    %eax,%edx
f010894f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108952:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108955:	83 c8 01             	or     $0x1,%eax
f0108958:	89 02                	mov    %eax,(%edx)

	return 0;
f010895a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010895f:	c9                   	leave  
f0108960:	c3                   	ret    

f0108961 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108961:	55                   	push   %ebp
f0108962:	89 e5                	mov    %esp,%ebp
f0108964:	57                   	push   %edi
f0108965:	56                   	push   %esi
f0108966:	53                   	push   %ebx
f0108967:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f010896a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108971:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108978:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f010897f:	83 ec 0c             	sub    $0xc,%esp
f0108982:	68 80 b3 6b f0       	push   $0xf06bb380
f0108987:	e8 a5 6d 00 00       	call   f010f731 <holding_spinlock>
f010898c:	83 c4 10             	add    $0x10,%esp
f010898f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108992:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108996:	75 10                	jne    f01089a8 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108998:	83 ec 0c             	sub    $0xc,%esp
f010899b:	68 80 b3 6b f0       	push   $0xf06bb380
f01089a0:	e8 73 6b 00 00       	call   f010f518 <acquire_spinlock>
f01089a5:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089a8:	a1 60 b3 6b f0       	mov    0xf06bb360,%eax
f01089ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089b0:	eb 1a                	jmp    f01089cc <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01089b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089b5:	8a 40 14             	mov    0x14(%eax),%al
f01089b8:	84 c0                	test   %al,%al
f01089ba:	74 05                	je     f01089c1 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01089bc:	ff 45 dc             	incl   -0x24(%ebp)
f01089bf:	eb 03                	jmp    f01089c4 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01089c1:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089c4:	a1 68 b3 6b f0       	mov    0xf06bb368,%eax
f01089c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089d0:	74 07                	je     f01089d9 <calculate_available_frames+0x78>
f01089d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089d5:	8b 00                	mov    (%eax),%eax
f01089d7:	eb 05                	jmp    f01089de <calculate_available_frames+0x7d>
f01089d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01089de:	a3 68 b3 6b f0       	mov    %eax,0xf06bb368
f01089e3:	a1 68 b3 6b f0       	mov    0xf06bb368,%eax
f01089e8:	85 c0                	test   %eax,%eax
f01089ea:	75 c6                	jne    f01089b2 <calculate_available_frames+0x51>
f01089ec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089f0:	75 c0                	jne    f01089b2 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f01089f2:	a1 7c b3 6b f0       	mov    0xf06bb37c,%eax
f01089f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f01089fa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01089fe:	75 10                	jne    f0108a10 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108a00:	83 ec 0c             	sub    $0xc,%esp
f0108a03:	68 80 b3 6b f0       	push   $0xf06bb380
f0108a08:	e8 92 6b 00 00       	call   f010f59f <release_spinlock>
f0108a0d:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a13:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108a16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a19:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108a1c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108a1f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a25:	89 c3                	mov    %eax,%ebx
f0108a27:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108a2a:	ba 03 00 00 00       	mov    $0x3,%edx
f0108a2f:	89 df                	mov    %ebx,%edi
f0108a31:	89 c6                	mov    %eax,%esi
f0108a33:	89 d1                	mov    %edx,%ecx
f0108a35:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108a37:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108a3d:	5b                   	pop    %ebx
f0108a3e:	5e                   	pop    %esi
f0108a3f:	5f                   	pop    %edi
f0108a40:	5d                   	pop    %ebp
f0108a41:	c2 04 00             	ret    $0x4

f0108a44 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108a44:	55                   	push   %ebp
f0108a45:	89 e5                	mov    %esp,%ebp
f0108a47:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108a4a:	c7 05 20 b2 6b f0 00 	movl   $0x0,0xf06bb220
f0108a51:	00 00 00 
f0108a54:	c7 05 24 b2 6b f0 00 	movl   $0x0,0xf06bb224
f0108a5b:	00 00 00 
f0108a5e:	c7 05 2c b2 6b f0 00 	movl   $0x0,0xf06bb22c
f0108a65:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108a68:	83 ec 08             	sub    $0x8,%esp
f0108a6b:	68 dc 53 12 f0       	push   $0xf01253dc
f0108a70:	68 30 b2 6b f0       	push   $0xf06bb230
f0108a75:	e8 6d 6a 00 00       	call   f010f4e7 <init_spinlock>
f0108a7a:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108a7d:	90                   	nop
f0108a7e:	c9                   	leave  
f0108a7f:	c3                   	ret    

f0108a80 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a80:	55                   	push   %ebp
f0108a81:	89 e5                	mov    %esp,%ebp
f0108a83:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a86:	83 ec 08             	sub    $0x8,%esp
f0108a89:	ff 75 0c             	pushl  0xc(%ebp)
f0108a8c:	ff 75 08             	pushl  0x8(%ebp)
f0108a8f:	e8 2d 01 00 00       	call   f0108bc1 <get_share>
f0108a94:	83 c4 10             	add    $0x10,%esp
f0108a97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a9e:	75 07                	jne    f0108aa7 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108aa0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108aa5:	eb 06                	jmp    f0108aad <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108aaa:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108aad:	c9                   	leave  
f0108aae:	c3                   	ret    

f0108aaf <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108aaf:	55                   	push   %ebp
f0108ab0:	89 e5                	mov    %esp,%ebp
f0108ab2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108ab5:	8b 15 6c b3 6b f0    	mov    0xf06bb36c,%edx
f0108abb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108abe:	39 c2                	cmp    %eax,%edx
f0108ac0:	73 07                	jae    f0108ac9 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ac2:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ac7:	eb 25                	jmp    f0108aee <create_frames_storage+0x3f>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo*));
f0108ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108acc:	c1 e0 02             	shl    $0x2,%eax
f0108acf:	83 ec 0c             	sub    $0xc,%esp
f0108ad2:	50                   	push   %eax
f0108ad3:	e8 13 06 00 00       	call   f01090eb <kmalloc>
f0108ad8:	83 c4 10             	add    $0x10,%esp
f0108adb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108ade:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ae2:	75 07                	jne    f0108aeb <create_frames_storage+0x3c>
f0108ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ae9:	eb 03                	jmp    f0108aee <create_frames_storage+0x3f>
	return frames_storage;
f0108aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108aee:	c9                   	leave  
f0108aef:	c3                   	ret    

f0108af0 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108af0:	55                   	push   %ebp
f0108af1:	89 e5                	mov    %esp,%ebp
f0108af3:	83 ec 28             	sub    $0x28,%esp
f0108af6:	8b 45 14             	mov    0x14(%ebp),%eax
f0108af9:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108afc:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108b03:	8b 55 10             	mov    0x10(%ebp),%edx
f0108b06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b09:	01 d0                	add    %edx,%eax
f0108b0b:	48                   	dec    %eax
f0108b0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108b0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b12:	ba 00 00 00 00       	mov    $0x0,%edx
f0108b17:	f7 75 f4             	divl   -0xc(%ebp)
f0108b1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b1d:	29 d0                	sub    %edx,%eax
f0108b1f:	c1 e8 0c             	shr    $0xc,%eax
f0108b22:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share*));
f0108b25:	83 ec 0c             	sub    $0xc,%esp
f0108b28:	6a 04                	push   $0x4
f0108b2a:	e8 bc 05 00 00       	call   f01090eb <kmalloc>
f0108b2f:	83 c4 10             	add    $0x10,%esp
f0108b32:	89 45 e8             	mov    %eax,-0x18(%ebp)

	created_share->references=1;
f0108b35:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b38:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)((int)created_share & 0x7FFFFFFF); //mask
f0108b3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b42:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
f0108b47:	89 c2                	mov    %eax,%edx
f0108b49:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b4c:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108b4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b51:	83 ec 0c             	sub    $0xc,%esp
f0108b54:	50                   	push   %eax
f0108b55:	e8 55 ff ff ff       	call   f0108aaf <create_frames_storage>
f0108b5a:	83 c4 10             	add    $0x10,%esp
f0108b5d:	89 c2                	mov    %eax,%edx
f0108b5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b62:	89 50 54             	mov    %edx,0x54(%eax)
	created_share->ownerID=ownerID;
f0108b65:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b68:	8b 55 08             	mov    0x8(%ebp),%edx
f0108b6b:	89 50 04             	mov    %edx,0x4(%eax)

	strncpy(created_share->name, shareName,sizeof(created_share->name) - 1);
f0108b6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b71:	83 c0 08             	add    $0x8,%eax
f0108b74:	83 ec 04             	sub    $0x4,%esp
f0108b77:	6a 3f                	push   $0x3f
f0108b79:	ff 75 0c             	pushl  0xc(%ebp)
f0108b7c:	50                   	push   %eax
f0108b7d:	e8 d4 69 01 00       	call   f011f556 <strncpy>
f0108b82:	83 c4 10             	add    $0x10,%esp

	created_share->size=size;
f0108b85:	8b 55 10             	mov    0x10(%ebp),%edx
f0108b88:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b8b:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108b8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b91:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108b94:	88 50 50             	mov    %dl,0x50(%eax)



	if(created_share==NULL || created_share->framesStorage==NULL)
f0108b97:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108b9b:	74 0a                	je     f0108ba7 <create_share+0xb7>
f0108b9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ba0:	8b 40 54             	mov    0x54(%eax),%eax
f0108ba3:	85 c0                	test   %eax,%eax
f0108ba5:	75 15                	jne    f0108bbc <create_share+0xcc>
	{
		kfree((void*)created_share);
f0108ba7:	83 ec 0c             	sub    $0xc,%esp
f0108baa:	ff 75 e8             	pushl  -0x18(%ebp)
f0108bad:	e8 99 07 00 00       	call   f010934b <kfree>
f0108bb2:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0108bb5:	b8 00 00 00 00       	mov    $0x0,%eax
f0108bba:	eb 03                	jmp    f0108bbf <create_share+0xcf>
	}
	return created_share;
f0108bbc:	8b 45 e8             	mov    -0x18(%ebp),%eax

}
f0108bbf:	c9                   	leave  
f0108bc0:	c3                   	ret    

f0108bc1 <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108bc1:	55                   	push   %ebp
f0108bc2:	89 e5                	mov    %esp,%ebp
f0108bc4:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108bc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108bce:	a1 20 b2 6b f0       	mov    0xf06bb220,%eax
f0108bd3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108bd6:	eb 31                	jmp    f0108c09 <get_share+0x48>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108bd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108bdb:	8b 40 04             	mov    0x4(%eax),%eax
f0108bde:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108be1:	75 1e                	jne    f0108c01 <get_share+0x40>
f0108be3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108be6:	83 c0 08             	add    $0x8,%eax
f0108be9:	83 ec 08             	sub    $0x8,%esp
f0108bec:	ff 75 0c             	pushl  0xc(%ebp)
f0108bef:	50                   	push   %eax
f0108bf0:	e8 f0 69 01 00       	call   f011f5e5 <strcmp>
f0108bf5:	83 c4 10             	add    $0x10,%esp
f0108bf8:	85 c0                	test   %eax,%eax
f0108bfa:	75 05                	jne    f0108c01 <get_share+0x40>
		{
			return founded;
f0108bfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108bff:	eb 34                	jmp    f0108c35 <get_share+0x74>
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108c01:	a1 28 b2 6b f0       	mov    0xf06bb228,%eax
f0108c06:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c0d:	74 08                	je     f0108c17 <get_share+0x56>
f0108c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c12:	8b 40 58             	mov    0x58(%eax),%eax
f0108c15:	eb 05                	jmp    f0108c1c <get_share+0x5b>
f0108c17:	b8 00 00 00 00       	mov    $0x0,%eax
f0108c1c:	a3 28 b2 6b f0       	mov    %eax,0xf06bb228
f0108c21:	a1 28 b2 6b f0       	mov    0xf06bb228,%eax
f0108c26:	85 c0                	test   %eax,%eax
f0108c28:	75 ae                	jne    f0108bd8 <get_share+0x17>
f0108c2a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c2e:	75 a8                	jne    f0108bd8 <get_share+0x17>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
		{
			return founded;
		}
	}
	return NULL;
f0108c30:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c35:	c9                   	leave  
f0108c36:	c3                   	ret    

f0108c37 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108c37:	55                   	push   %ebp
f0108c38:	89 e5                	mov    %esp,%ebp
f0108c3a:	53                   	push   %ebx
f0108c3b:	83 ec 44             	sub    $0x44,%esp
f0108c3e:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c41:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108c44:	e8 41 26 00 00       	call   f010b28a <get_cpu_proc>
f0108c49:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108c4c:	83 ec 08             	sub    $0x8,%esp
f0108c4f:	ff 75 0c             	pushl  0xc(%ebp)
f0108c52:	ff 75 08             	pushl  0x8(%ebp)
f0108c55:	e8 67 ff ff ff       	call   f0108bc1 <get_share>
f0108c5a:	83 c4 10             	add    $0x10,%esp
f0108c5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108c60:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108c64:	74 0a                	je     f0108c70 <createSharedObject+0x39>
f0108c66:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108c6b:	e9 60 01 00 00       	jmp    f0108dd0 <createSharedObject+0x199>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108c70:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108c74:	50                   	push   %eax
f0108c75:	ff 75 10             	pushl  0x10(%ebp)
f0108c78:	ff 75 0c             	pushl  0xc(%ebp)
f0108c7b:	ff 75 08             	pushl  0x8(%ebp)
f0108c7e:	e8 6d fe ff ff       	call   f0108af0 <create_share>
f0108c83:	83 c4 10             	add    $0x10,%esp
f0108c86:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0108c89:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108c8d:	75 0a                	jne    f0108c99 <createSharedObject+0x62>
f0108c8f:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f0108c94:	e9 37 01 00 00       	jmp    f0108dd0 <createSharedObject+0x199>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108c99:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108ca0:	8b 55 10             	mov    0x10(%ebp),%edx
f0108ca3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108ca6:	01 d0                	add    %edx,%eax
f0108ca8:	48                   	dec    %eax
f0108ca9:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108cac:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108caf:	ba 00 00 00 00       	mov    $0x0,%edx
f0108cb4:	f7 75 e4             	divl   -0x1c(%ebp)
f0108cb7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cba:	29 d0                	sub    %edx,%eax
f0108cbc:	c1 e8 0c             	shr    $0xc,%eax
f0108cbf:	89 45 dc             	mov    %eax,-0x24(%ebp)

	for (int k = 0; k < num_pages; k++)
f0108cc2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108cc9:	eb 73                	jmp    f0108d3e <createSharedObject+0x107>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0108ccb:	83 ec 0c             	sub    $0xc,%esp
f0108cce:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0108cd1:	50                   	push   %eax
f0108cd2:	e8 db f4 ff ff       	call   f01081b2 <allocate_frame>
f0108cd7:	83 c4 10             	add    $0x10,%esp
f0108cda:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret != E_NO_MEM)
f0108cdd:	83 7d d8 fc          	cmpl   $0xfffffffc,-0x28(%ebp)
f0108ce1:	74 44                	je     f0108d27 <createSharedObject+0xf0>
		{
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),isWritable*PERM_WRITEABLE);
f0108ce3:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108ce7:	01 c0                	add    %eax,%eax
f0108ce9:	89 c3                	mov    %eax,%ebx
f0108ceb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108cee:	c1 e0 0c             	shl    $0xc,%eax
f0108cf1:	89 c2                	mov    %eax,%edx
f0108cf3:	8b 45 18             	mov    0x18(%ebp),%eax
f0108cf6:	01 d0                	add    %edx,%eax
f0108cf8:	89 c1                	mov    %eax,%ecx
f0108cfa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0108cfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d00:	8b 40 64             	mov    0x64(%eax),%eax
f0108d03:	53                   	push   %ebx
f0108d04:	51                   	push   %ecx
f0108d05:	52                   	push   %edx
f0108d06:	50                   	push   %eax
f0108d07:	e8 73 f9 ff ff       	call   f010867f <map_frame>
f0108d0c:	83 c4 10             	add    $0x10,%esp
			created_share->framesStorage[k] = ptr_frame_info;
f0108d0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d12:	8b 40 54             	mov    0x54(%eax),%eax
f0108d15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d18:	c1 e2 02             	shl    $0x2,%edx
f0108d1b:	01 c2                	add    %eax,%edx
f0108d1d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108d20:	89 02                	mov    %eax,(%edx)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108d22:	ff 45 f4             	incl   -0xc(%ebp)
f0108d25:	eb 17                	jmp    f0108d3e <createSharedObject+0x107>
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),isWritable*PERM_WRITEABLE);
			created_share->framesStorage[k] = ptr_frame_info;
		}
		else
		{
			panic("No Memory");
f0108d27:	83 ec 04             	sub    $0x4,%esp
f0108d2a:	68 e8 53 12 f0       	push   $0xf01253e8
f0108d2f:	68 a7 00 00 00       	push   $0xa7
f0108d34:	68 f4 53 12 f0       	push   $0xf01253f4
f0108d39:	e8 fb 75 ff ff       	call   f0100339 <_panic>
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108d3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d41:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108d44:	72 85                	jb     f0108ccb <createSharedObject+0x94>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f0108d46:	83 ec 0c             	sub    $0xc,%esp
f0108d49:	68 30 b2 6b f0       	push   $0xf06bb230
f0108d4e:	e8 c5 67 00 00       	call   f010f518 <acquire_spinlock>
f0108d53:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f0108d56:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108d5a:	75 17                	jne    f0108d73 <createSharedObject+0x13c>
f0108d5c:	83 ec 04             	sub    $0x4,%esp
f0108d5f:	68 18 54 12 f0       	push   $0xf0125418
f0108d64:	68 ac 00 00 00       	push   $0xac
f0108d69:	68 f4 53 12 f0       	push   $0xf01253f4
f0108d6e:	e8 c6 75 ff ff       	call   f0100339 <_panic>
f0108d73:	8b 15 24 b2 6b f0    	mov    0xf06bb224,%edx
f0108d79:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d7c:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108d7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d82:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108d85:	85 c0                	test   %eax,%eax
f0108d87:	74 0d                	je     f0108d96 <createSharedObject+0x15f>
f0108d89:	a1 24 b2 6b f0       	mov    0xf06bb224,%eax
f0108d8e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108d91:	89 50 58             	mov    %edx,0x58(%eax)
f0108d94:	eb 08                	jmp    f0108d9e <createSharedObject+0x167>
f0108d96:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d99:	a3 20 b2 6b f0       	mov    %eax,0xf06bb220
f0108d9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108da1:	a3 24 b2 6b f0       	mov    %eax,0xf06bb224
f0108da6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108da9:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108db0:	a1 2c b2 6b f0       	mov    0xf06bb22c,%eax
f0108db5:	40                   	inc    %eax
f0108db6:	a3 2c b2 6b f0       	mov    %eax,0xf06bb22c
	release_spinlock(&AllShares.shareslock);
f0108dbb:	83 ec 0c             	sub    $0xc,%esp
f0108dbe:	68 30 b2 6b f0       	push   $0xf06bb230
f0108dc3:	e8 d7 67 00 00       	call   f010f59f <release_spinlock>
f0108dc8:	83 c4 10             	add    $0x10,%esp

	return created_share->ID;
f0108dcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dce:	8b 00                	mov    (%eax),%eax
}
f0108dd0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108dd3:	c9                   	leave  
f0108dd4:	c3                   	ret    

f0108dd5 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108dd5:	55                   	push   %ebp
f0108dd6:	89 e5                	mov    %esp,%ebp
f0108dd8:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("getSharedObject is not implemented yet");
f0108ddb:	83 ec 04             	sub    $0x4,%esp
f0108dde:	68 3c 54 12 f0       	push   $0xf012543c
f0108de3:	68 ba 00 00 00       	push   $0xba
f0108de8:	68 f4 53 12 f0       	push   $0xf01253f4
f0108ded:	e8 47 75 ff ff       	call   f0100339 <_panic>

f0108df2 <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108df2:	55                   	push   %ebp
f0108df3:	89 e5                	mov    %esp,%ebp
f0108df5:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f0108df8:	83 ec 04             	sub    $0x4,%esp
f0108dfb:	68 64 54 12 f0       	push   $0xf0125464
f0108e00:	68 cd 00 00 00       	push   $0xcd
f0108e05:	68 f4 53 12 f0       	push   $0xf01253f4
f0108e0a:	e8 2a 75 ff ff       	call   f0100339 <_panic>

f0108e0f <freeSharedObject>:
}
//========================
// [B2] Free Share Object:
//========================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108e0f:	55                   	push   %ebp
f0108e10:	89 e5                	mov    %esp,%ebp
f0108e12:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f0108e15:	83 ec 04             	sub    $0x4,%esp
f0108e18:	68 88 54 12 f0       	push   $0xf0125488
f0108e1d:	68 d8 00 00 00       	push   $0xd8
f0108e22:	68 f4 53 12 f0       	push   $0xf01253f4
f0108e27:	e8 0d 75 ff ff       	call   f0100339 <_panic>

f0108e2c <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0108e2c:	55                   	push   %ebp
f0108e2d:	89 e5                	mov    %esp,%ebp
f0108e2f:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f0108e34:	83 f8 01             	cmp    $0x1,%eax
f0108e37:	75 04                	jne    f0108e3d <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0108e39:	b0 01                	mov    $0x1,%al
f0108e3b:	eb 02                	jmp    f0108e3f <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0108e3d:	b0 00                	mov    $0x0,%al
f0108e3f:	5d                   	pop    %ebp
f0108e40:	c3                   	ret    

f0108e41 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0108e41:	55                   	push   %ebp
f0108e42:	89 e5                	mov    %esp,%ebp
f0108e44:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f0108e49:	83 f8 02             	cmp    $0x2,%eax
f0108e4c:	75 04                	jne    f0108e52 <isKHeapPlacementStrategyBESTFIT+0x11>
f0108e4e:	b0 01                	mov    $0x1,%al
f0108e50:	eb 02                	jmp    f0108e54 <isKHeapPlacementStrategyBESTFIT+0x13>
f0108e52:	b0 00                	mov    $0x0,%al
f0108e54:	5d                   	pop    %ebp
f0108e55:	c3                   	ret    

f0108e56 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108e56:	55                   	push   %ebp
f0108e57:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108e59:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e5c:	8b 15 c0 b7 6b f0    	mov    0xf06bb7c0,%edx
f0108e62:	29 d0                	sub    %edx,%eax
f0108e64:	c1 f8 03             	sar    $0x3,%eax
f0108e67:	89 c2                	mov    %eax,%edx
f0108e69:	89 d0                	mov    %edx,%eax
f0108e6b:	c1 e0 02             	shl    $0x2,%eax
f0108e6e:	01 d0                	add    %edx,%eax
f0108e70:	c1 e0 02             	shl    $0x2,%eax
f0108e73:	01 d0                	add    %edx,%eax
f0108e75:	c1 e0 02             	shl    $0x2,%eax
f0108e78:	01 d0                	add    %edx,%eax
f0108e7a:	89 c1                	mov    %eax,%ecx
f0108e7c:	c1 e1 08             	shl    $0x8,%ecx
f0108e7f:	01 c8                	add    %ecx,%eax
f0108e81:	89 c1                	mov    %eax,%ecx
f0108e83:	c1 e1 10             	shl    $0x10,%ecx
f0108e86:	01 c8                	add    %ecx,%eax
f0108e88:	01 c0                	add    %eax,%eax
f0108e8a:	01 d0                	add    %edx,%eax
}
f0108e8c:	5d                   	pop    %ebp
f0108e8d:	c3                   	ret    

f0108e8e <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0108e8e:	55                   	push   %ebp
f0108e8f:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0108e91:	ff 75 08             	pushl  0x8(%ebp)
f0108e94:	e8 bd ff ff ff       	call   f0108e56 <to_frame_number>
f0108e99:	83 c4 04             	add    $0x4,%esp
f0108e9c:	c1 e0 0c             	shl    $0xc,%eax
}
f0108e9f:	c9                   	leave  
f0108ea0:	c3                   	ret    

f0108ea1 <initialize_kheap_dynamic_allocator>:
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC

uint32 no_pages_alloc[NUM_OF_KHEAP_PAGES];
uint32 to_virtual[1048576];
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0108ea1:	55                   	push   %ebp
f0108ea2:	89 e5                	mov    %esp,%ebp
f0108ea4:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f0108ea7:	8b 45 08             	mov    0x8(%ebp),%eax
f0108eaa:	a3 08 ba 6b f0       	mov    %eax,0xf06bba08
	hard_limit = daLimit;
f0108eaf:	8b 45 10             	mov    0x10(%ebp),%eax
f0108eb2:	a3 54 b8 6b f0       	mov    %eax,0xf06bb854
	brk = daStart + initSizeToAllocate;
f0108eb7:	8b 55 08             	mov    0x8(%ebp),%edx
f0108eba:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108ebd:	01 d0                	add    %edx,%eax
f0108ebf:	a3 00 ba 6b f0       	mov    %eax,0xf06bba00

	if(brk > daLimit) panic("exceeds Limit");
f0108ec4:	a1 00 ba 6b f0       	mov    0xf06bba00,%eax
f0108ec9:	3b 45 10             	cmp    0x10(%ebp),%eax
f0108ecc:	76 14                	jbe    f0108ee2 <initialize_kheap_dynamic_allocator+0x41>
f0108ece:	83 ec 04             	sub    $0x4,%esp
f0108ed1:	68 b0 54 12 f0       	push   $0xf01254b0
f0108ed6:	6a 1a                	push   $0x1a
f0108ed8:	68 be 54 12 f0       	push   $0xf01254be
f0108edd:	e8 57 74 ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f0108ee2:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f0108ee9:	8b 45 10             	mov    0x10(%ebp),%eax
f0108eec:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f0108eef:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108ef2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f0108ef5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ef8:	c1 e8 0c             	shr    $0xc,%eax
f0108efb:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f0108efe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108f05:	e9 8a 00 00 00       	jmp    f0108f94 <initialize_kheap_dynamic_allocator+0xf3>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f0108f0a:	83 ec 0c             	sub    $0xc,%esp
f0108f0d:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0108f10:	50                   	push   %eax
f0108f11:	e8 9c f2 ff ff       	call   f01081b2 <allocate_frame>
f0108f16:	83 c4 10             	add    $0x10,%esp
f0108f19:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f0108f1c:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f0108f20:	74 5e                	je     f0108f80 <initialize_kheap_dynamic_allocator+0xdf>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f0108f22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f25:	c1 e0 0c             	shl    $0xc,%eax
f0108f28:	89 c2                	mov    %eax,%edx
f0108f2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f2d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0108f30:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0108f33:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0108f38:	6a 02                	push   $0x2
f0108f3a:	51                   	push   %ecx
f0108f3b:	52                   	push   %edx
f0108f3c:	50                   	push   %eax
f0108f3d:	e8 3d f7 ff ff       	call   f010867f <map_frame>
f0108f42:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f0108f45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f48:	c1 e0 0c             	shl    $0xc,%eax
f0108f4b:	89 c2                	mov    %eax,%edx
f0108f4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f50:	01 d0                	add    %edx,%eax
f0108f52:	83 ec 0c             	sub    $0xc,%esp
f0108f55:	50                   	push   %eax
f0108f56:	e8 d6 04 00 00       	call   f0109431 <kheap_physical_address>
f0108f5b:	83 c4 10             	add    $0x10,%esp
f0108f5e:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f0108f61:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108f64:	c1 e8 0c             	shr    $0xc,%eax
f0108f67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108f6a:	c1 e2 0c             	shl    $0xc,%edx
f0108f6d:	89 d1                	mov    %edx,%ecx
f0108f6f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108f72:	01 ca                	add    %ecx,%edx
f0108f74:	89 14 85 a0 1f 70 f0 	mov    %edx,-0xf8fe060(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0108f7b:	ff 45 f4             	incl   -0xc(%ebp)
f0108f7e:	eb 14                	jmp    f0108f94 <initialize_kheap_dynamic_allocator+0xf3>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f0108f80:	83 ec 04             	sub    $0x4,%esp
f0108f83:	68 cf 54 12 f0       	push   $0xf01254cf
f0108f88:	6a 2f                	push   $0x2f
f0108f8a:	68 be 54 12 f0       	push   $0xf01254be
f0108f8f:	e8 a5 73 ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0108f94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f97:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0108f9a:	0f 82 6a ff ff ff    	jb     f0108f0a <initialize_kheap_dynamic_allocator+0x69>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f0108fa0:	83 ec 08             	sub    $0x8,%esp
f0108fa3:	ff 75 0c             	pushl  0xc(%ebp)
f0108fa6:	ff 75 08             	pushl  0x8(%ebp)
f0108fa9:	e8 fa 70 01 00       	call   f01200a8 <initialize_dynamic_allocator>
f0108fae:	83 c4 10             	add    $0x10,%esp

	return 0;
f0108fb1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108fb6:	c9                   	leave  
f0108fb7:	c3                   	ret    

f0108fb8 <sbrk>:

void* sbrk(int numOfPages)
{
f0108fb8:	55                   	push   %ebp
f0108fb9:	89 e5                	mov    %esp,%ebp
f0108fbb:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f0108fbe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108fc2:	0f 8e d6 00 00 00    	jle    f010909e <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f0108fc8:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fcb:	c1 e0 0c             	shl    $0xc,%eax
f0108fce:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f0108fd1:	a1 00 ba 6b f0       	mov    0xf06bba00,%eax
f0108fd6:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f0108fd9:	8b 15 00 ba 6b f0    	mov    0xf06bba00,%edx
f0108fdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108fe2:	01 c2                	add    %eax,%edx
f0108fe4:	a1 54 b8 6b f0       	mov    0xf06bb854,%eax
f0108fe9:	39 c2                	cmp    %eax,%edx
f0108feb:	76 0a                	jbe    f0108ff7 <sbrk+0x3f>
f0108fed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108ff2:	e9 b9 00 00 00       	jmp    f01090b0 <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f0108ff7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108ffe:	eb 7d                	jmp    f010907d <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f0109000:	83 ec 0c             	sub    $0xc,%esp
f0109003:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0109006:	50                   	push   %eax
f0109007:	e8 a6 f1 ff ff       	call   f01081b2 <allocate_frame>
f010900c:	83 c4 10             	add    $0x10,%esp
f010900f:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f0109012:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0109016:	74 5e                	je     f0109076 <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f0109018:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010901b:	c1 e0 0c             	shl    $0xc,%eax
f010901e:	89 c2                	mov    %eax,%edx
f0109020:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109023:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109026:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109029:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f010902e:	6a 02                	push   $0x2
f0109030:	51                   	push   %ecx
f0109031:	52                   	push   %edx
f0109032:	50                   	push   %eax
f0109033:	e8 47 f6 ff ff       	call   f010867f <map_frame>
f0109038:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f010903b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010903e:	c1 e0 0c             	shl    $0xc,%eax
f0109041:	89 c2                	mov    %eax,%edx
f0109043:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109046:	01 d0                	add    %edx,%eax
f0109048:	83 ec 0c             	sub    $0xc,%esp
f010904b:	50                   	push   %eax
f010904c:	e8 e0 03 00 00       	call   f0109431 <kheap_physical_address>
f0109051:	83 c4 10             	add    $0x10,%esp
f0109054:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f0109057:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010905a:	c1 e8 0c             	shr    $0xc,%eax
f010905d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109060:	c1 e2 0c             	shl    $0xc,%edx
f0109063:	89 d1                	mov    %edx,%ecx
f0109065:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109068:	01 ca                	add    %ecx,%edx
f010906a:	89 14 85 a0 1f 70 f0 	mov    %edx,-0xf8fe060(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109071:	ff 45 f4             	incl   -0xc(%ebp)
f0109074:	eb 07                	jmp    f010907d <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f0109076:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010907b:	eb 33                	jmp    f01090b0 <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f010907d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109080:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109083:	0f 8c 77 ff ff ff    	jl     f0109000 <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f0109089:	8b 15 00 ba 6b f0    	mov    0xf06bba00,%edx
f010908f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109092:	01 d0                	add    %edx,%eax
f0109094:	a3 00 ba 6b f0       	mov    %eax,0xf06bba00
		return (void *)prev_brk;
f0109099:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010909c:	eb 12                	jmp    f01090b0 <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f010909e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01090a2:	75 07                	jne    f01090ab <sbrk+0xf3>
	{
		return (void *) brk;
f01090a4:	a1 00 ba 6b f0       	mov    0xf06bba00,%eax
f01090a9:	eb 05                	jmp    f01090b0 <sbrk+0xf8>
	}

	return (void *)-1;
f01090ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f01090b0:	c9                   	leave  
f01090b1:	c3                   	ret    

f01090b2 <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f01090b2:	55                   	push   %ebp
f01090b3:	89 e5                	mov    %esp,%ebp
f01090b5:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f01090b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f01090bf:	83 ec 04             	sub    $0x4,%esp
f01090c2:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01090c5:	50                   	push   %eax
f01090c6:	ff 75 0c             	pushl  0xc(%ebp)
f01090c9:	ff 75 08             	pushl  0x8(%ebp)
f01090cc:	e8 98 f6 ff ff       	call   f0108769 <get_frame_info>
f01090d1:	83 c4 10             	add    $0x10,%esp
f01090d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f01090d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01090db:	75 07                	jne    f01090e4 <isPageAllocated+0x32>
f01090dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01090e2:	eb 05                	jmp    f01090e9 <isPageAllocated+0x37>
	return 1;
f01090e4:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01090e9:	c9                   	leave  
f01090ea:	c3                   	ret    

f01090eb <kmalloc>:

void *kmalloc(unsigned int size)
{
f01090eb:	55                   	push   %ebp
f01090ec:	89 e5                	mov    %esp,%ebp
f01090ee:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f01090f1:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01090f8:	8b 55 08             	mov    0x8(%ebp),%edx
f01090fb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01090fe:	01 d0                	add    %edx,%eax
f0109100:	48                   	dec    %eax
f0109101:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109104:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109107:	ba 00 00 00 00       	mov    $0x0,%edx
f010910c:	f7 75 d8             	divl   -0x28(%ebp)
f010910f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109112:	29 d0                	sub    %edx,%eax
f0109114:	c1 e8 0c             	shr    $0xc,%eax
f0109117:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f010911a:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0109121:	a1 54 b8 6b f0       	mov    0xf06bb854,%eax
f0109126:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0109129:	29 c2                	sub    %eax,%edx
f010912b:	89 d0                	mov    %edx,%eax
f010912d:	48                   	dec    %eax
f010912e:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0109131:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109134:	ba 00 00 00 00       	mov    $0x0,%edx
f0109139:	f7 75 cc             	divl   -0x34(%ebp)
f010913c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010913f:	29 d0                	sub    %edx,%eax
f0109141:	c1 e8 0c             	shr    $0xc,%eax
f0109144:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f0109147:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f010914e:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0109155:	77 42                	ja     f0109199 <kmalloc+0xae>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f0109157:	e8 d0 fc ff ff       	call   f0108e2c <isKHeapPlacementStrategyFIRSTFIT>
f010915c:	84 c0                	test   %al,%al
f010915e:	74 16                	je     f0109176 <kmalloc+0x8b>
			ptr = alloc_block_FF(size);
f0109160:	83 ec 0c             	sub    $0xc,%esp
f0109163:	ff 75 08             	pushl  0x8(%ebp)
f0109166:	e8 59 71 01 00       	call   f01202c4 <alloc_block_FF>
f010916b:	83 c4 10             	add    $0x10,%esp
f010916e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109171:	e9 d0 01 00 00       	jmp    f0109346 <kmalloc+0x25b>
		else if (isKHeapPlacementStrategyBESTFIT())
f0109176:	e8 c6 fc ff ff       	call   f0108e41 <isKHeapPlacementStrategyBESTFIT>
f010917b:	84 c0                	test   %al,%al
f010917d:	0f 84 c3 01 00 00    	je     f0109346 <kmalloc+0x25b>
			ptr = alloc_block_BF(size);
f0109183:	83 ec 0c             	sub    $0xc,%esp
f0109186:	ff 75 08             	pushl  0x8(%ebp)
f0109189:	e8 f2 75 01 00       	call   f0120780 <alloc_block_BF>
f010918e:	83 c4 10             	add    $0x10,%esp
f0109191:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109194:	e9 ad 01 00 00       	jmp    f0109346 <kmalloc+0x25b>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f0109199:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010919c:	48                   	dec    %eax
f010919d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01091a0:	0f 86 99 01 00 00    	jbe    f010933f <kmalloc+0x254>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f01091a6:	a1 54 b8 6b f0       	mov    0xf06bb854,%eax
f01091ab:	05 00 10 00 00       	add    $0x1000,%eax
f01091b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f01091b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f01091ba:	e9 86 00 00 00       	jmp    f0109245 <kmalloc+0x15a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f01091bf:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01091c4:	83 ec 08             	sub    $0x8,%esp
f01091c7:	ff 75 f0             	pushl  -0x10(%ebp)
f01091ca:	50                   	push   %eax
f01091cb:	e8 e2 fe ff ff       	call   f01090b2 <isPageAllocated>
f01091d0:	83 c4 10             	add    $0x10,%esp
f01091d3:	85 c0                	test   %eax,%eax
f01091d5:	75 61                	jne    f0109238 <kmalloc+0x14d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f01091d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091da:	05 00 10 00 00       	add    $0x1000,%eax
f01091df:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f01091e2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f01091e9:	eb 3d                	jmp    f0109228 <kmalloc+0x13d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) return NULL;
f01091eb:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f01091f2:	76 0a                	jbe    f01091fe <kmalloc+0x113>
f01091f4:	b8 00 00 00 00       	mov    $0x0,%eax
f01091f9:	e9 4b 01 00 00       	jmp    f0109349 <kmalloc+0x25e>
					if (isPageAllocated(ptr_page_directory, j))
f01091fe:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0109203:	83 ec 08             	sub    $0x8,%esp
f0109206:	ff 75 e8             	pushl  -0x18(%ebp)
f0109209:	50                   	push   %eax
f010920a:	e8 a3 fe ff ff       	call   f01090b2 <isPageAllocated>
f010920f:	83 c4 10             	add    $0x10,%esp
f0109212:	85 c0                	test   %eax,%eax
f0109214:	74 08                	je     f010921e <kmalloc+0x133>
					{

						i = j;
f0109216:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109219:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f010921c:	eb 1a                	jmp    f0109238 <kmalloc+0x14d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f010921e:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f0109225:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f0109228:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010922b:	48                   	dec    %eax
f010922c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010922f:	77 ba                	ja     f01091eb <kmalloc+0x100>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f0109231:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f0109238:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010923c:	75 16                	jne    f0109254 <kmalloc+0x169>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f010923e:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f0109245:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f010924c:	0f 86 6d ff ff ff    	jbe    f01091bf <kmalloc+0xd4>
f0109252:	eb 01                	jmp    f0109255 <kmalloc+0x16a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f0109254:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
f0109255:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109259:	75 0a                	jne    f0109265 <kmalloc+0x17a>
f010925b:	b8 00 00 00 00       	mov    $0x0,%eax
f0109260:	e9 e4 00 00 00       	jmp    f0109349 <kmalloc+0x25e>
		for (int k = 0; k < num_pages; k++)
f0109265:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f010926c:	eb 57                	jmp    f01092c5 <kmalloc+0x1da>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f010926e:	83 ec 0c             	sub    $0xc,%esp
f0109271:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0109274:	50                   	push   %eax
f0109275:	e8 38 ef ff ff       	call   f01081b2 <allocate_frame>
f010927a:	83 c4 10             	add    $0x10,%esp
f010927d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			//map_frame(ptr_page_directory, ptr_frame_info, i + k * 1024, PERM_USER|PERM_WRITEABLE); REPLACED BY
			if (ret != E_NO_MEM)
f0109280:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f0109284:	74 28                	je     f01092ae <kmalloc+0x1c3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE); // a3raf el page mnen
f0109286:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109289:	c1 e0 0c             	shl    $0xc,%eax
f010928c:	89 c2                	mov    %eax,%edx
f010928e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109291:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109294:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0109297:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f010929c:	6a 02                	push   $0x2
f010929e:	51                   	push   %ecx
f010929f:	52                   	push   %edx
f01092a0:	50                   	push   %eax
f01092a1:	e8 d9 f3 ff ff       	call   f010867f <map_frame>
f01092a6:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f01092a9:	ff 45 e0             	incl   -0x20(%ebp)
f01092ac:	eb 17                	jmp    f01092c5 <kmalloc+0x1da>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE); // a3raf el page mnen
			}
			else
			{
				panic("No Memory");
f01092ae:	83 ec 04             	sub    $0x4,%esp
f01092b1:	68 cf 54 12 f0       	push   $0xf01254cf
f01092b6:	68 b6 00 00 00       	push   $0xb6
f01092bb:	68 be 54 12 f0       	push   $0xf01254be
f01092c0:	e8 74 70 ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f01092c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01092c8:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01092cb:	72 a1                	jb     f010926e <kmalloc+0x183>
			else
			{
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f01092cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092d0:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f01092d3:	a1 54 b8 6b f0       	mov    0xf06bb854,%eax
f01092d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01092db:	29 c2                	sub    %eax,%edx
f01092dd:	89 d0                	mov    %edx,%eax
f01092df:	2d 00 10 00 00       	sub    $0x1000,%eax
f01092e4:	c1 e8 0c             	shr    $0xc,%eax
f01092e7:	89 c2                	mov    %eax,%edx
f01092e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01092ec:	89 04 95 a0 9f 6d f0 	mov    %eax,-0xf926060(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f01092f3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01092fa:	eb 39                	jmp    f0109335 <kmalloc+0x24a>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f01092fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01092ff:	c1 e0 0c             	shl    $0xc,%eax
f0109302:	89 c2                	mov    %eax,%edx
f0109304:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109307:	01 d0                	add    %edx,%eax
f0109309:	83 ec 0c             	sub    $0xc,%esp
f010930c:	50                   	push   %eax
f010930d:	e8 1f 01 00 00       	call   f0109431 <kheap_physical_address>
f0109312:	83 c4 10             	add    $0x10,%esp
f0109315:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f0109318:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010931b:	c1 e8 0c             	shr    $0xc,%eax
f010931e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109321:	c1 e2 0c             	shl    $0xc,%edx
f0109324:	89 d1                	mov    %edx,%ecx
f0109326:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109329:	01 ca                	add    %ecx,%edx
f010932b:	89 14 85 a0 1f 70 f0 	mov    %edx,-0xf8fe060(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f0109332:	ff 45 dc             	incl   -0x24(%ebp)
f0109335:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109338:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010933b:	72 bf                	jb     f01092fc <kmalloc+0x211>
f010933d:	eb 07                	jmp    f0109346 <kmalloc+0x25b>
		}
	}
	else
	{

		return NULL;
f010933f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109344:	eb 03                	jmp    f0109349 <kmalloc+0x25e>
	}
	return ptr;
f0109346:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109349:	c9                   	leave  
f010934a:	c3                   	ret    

f010934b <kfree>:

void kfree(void *va)
{
f010934b:	55                   	push   %ebp
f010934c:	89 e5                	mov    %esp,%ebp
f010934e:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109351:	a1 54 b8 6b f0       	mov    0xf06bb854,%eax
f0109356:	05 00 10 00 00       	add    $0x1000,%eax
f010935b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f010935e:	8b 55 08             	mov    0x8(%ebp),%edx
f0109361:	a1 54 b8 6b f0       	mov    0xf06bb854,%eax
f0109366:	39 c2                	cmp    %eax,%edx
f0109368:	73 13                	jae    f010937d <kfree+0x32>
        free_block(va);
f010936a:	83 ec 0c             	sub    $0xc,%esp
f010936d:	ff 75 08             	pushl  0x8(%ebp)
f0109370:	e8 13 7e 01 00       	call   f0121188 <free_block>
f0109375:	83 c4 10             	add    $0x10,%esp
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
		}
    } else{
        panic("kfree: The virtual Address is invalid");
    }
}
f0109378:	e9 b1 00 00 00       	jmp    f010942e <kfree+0xe3>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f010937d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109380:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0109383:	0f 82 8e 00 00 00    	jb     f0109417 <kfree+0xcc>
f0109389:	8b 45 08             	mov    0x8(%ebp),%eax
f010938c:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109391:	0f 87 80 00 00 00    	ja     f0109417 <kfree+0xcc>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f0109397:	8b 55 08             	mov    0x8(%ebp),%edx
f010939a:	a1 54 b8 6b f0       	mov    0xf06bb854,%eax
f010939f:	29 c2                	sub    %eax,%edx
f01093a1:	89 d0                	mov    %edx,%eax
f01093a3:	2d 00 10 00 00       	sub    $0x1000,%eax
f01093a8:	c1 e8 0c             	shr    $0xc,%eax
f01093ab:	8b 04 85 a0 9f 6d f0 	mov    -0xf926060(,%eax,4),%eax
f01093b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f01093b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01093bc:	eb 4f                	jmp    f010940d <kfree+0xc2>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f01093be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093c1:	c1 e0 0c             	shl    $0xc,%eax
f01093c4:	89 c2                	mov    %eax,%edx
f01093c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01093c9:	01 d0                	add    %edx,%eax
f01093cb:	83 ec 0c             	sub    $0xc,%esp
f01093ce:	50                   	push   %eax
f01093cf:	e8 5d 00 00 00       	call   f0109431 <kheap_physical_address>
f01093d4:	83 c4 10             	add    $0x10,%esp
f01093d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f01093da:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01093dd:	c1 e8 0c             	shr    $0xc,%eax
f01093e0:	c7 04 85 a0 1f 70 f0 	movl   $0x0,-0xf8fe060(,%eax,4)
f01093e7:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f01093eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093ee:	c1 e0 0c             	shl    $0xc,%eax
f01093f1:	89 c2                	mov    %eax,%edx
f01093f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01093f6:	01 c2                	add    %eax,%edx
f01093f8:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01093fd:	83 ec 08             	sub    $0x8,%esp
f0109400:	52                   	push   %edx
f0109401:	50                   	push   %eax
f0109402:	e8 d8 f3 ff ff       	call   f01087df <unmap_frame>
f0109407:	83 c4 10             	add    $0x10,%esp
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f010940a:	ff 45 f4             	incl   -0xc(%ebp)
f010940d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109410:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109413:	72 a9                	jb     f01093be <kfree+0x73>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109415:	eb 17                	jmp    f010942e <kfree+0xe3>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = 0;
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
		}
    } else{
        panic("kfree: The virtual Address is invalid");
f0109417:	83 ec 04             	sub    $0x4,%esp
f010941a:	68 dc 54 12 f0       	push   $0xf01254dc
f010941f:	68 dd 00 00 00       	push   $0xdd
f0109424:	68 be 54 12 f0       	push   $0xf01254be
f0109429:	e8 0b 6f ff ff       	call   f0100339 <_panic>
    }
}
f010942e:	90                   	nop
f010942f:	c9                   	leave  
f0109430:	c3                   	ret    

f0109431 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f0109431:	55                   	push   %ebp
f0109432:	89 e5                	mov    %esp,%ebp
f0109434:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f0109437:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f010943e:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0109443:	83 ec 04             	sub    $0x4,%esp
f0109446:	8d 55 e8             	lea    -0x18(%ebp),%edx
f0109449:	52                   	push   %edx
f010944a:	ff 75 08             	pushl  0x8(%ebp)
f010944d:	50                   	push   %eax
f010944e:	e8 16 f3 ff ff       	call   f0108769 <get_frame_info>
f0109453:	83 c4 10             	add    $0x10,%esp
f0109456:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f0109459:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010945d:	75 07                	jne    f0109466 <kheap_physical_address+0x35>
		return 0;
f010945f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109464:	eb 26                	jmp    f010948c <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f0109466:	8b 45 08             	mov    0x8(%ebp),%eax
f0109469:	25 ff 0f 00 00       	and    $0xfff,%eax
f010946e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f0109471:	83 ec 0c             	sub    $0xc,%esp
f0109474:	ff 75 f4             	pushl  -0xc(%ebp)
f0109477:	e8 12 fa ff ff       	call   f0108e8e <to_physical_address>
f010947c:	83 c4 10             	add    $0x10,%esp
f010947f:	89 c2                	mov    %eax,%edx
f0109481:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109484:	01 d0                	add    %edx,%eax
f0109486:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f0109489:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010948c:	c9                   	leave  
f010948d:	c3                   	ret    

f010948e <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f010948e:	55                   	push   %ebp
f010948f:	89 e5                	mov    %esp,%ebp
f0109491:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f0109494:	8b 45 08             	mov    0x8(%ebp),%eax
f0109497:	25 ff 0f 00 00       	and    $0xfff,%eax
f010949c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f010949f:	8b 45 08             	mov    0x8(%ebp),%eax
f01094a2:	c1 e8 0c             	shr    $0xc,%eax
f01094a5:	8b 04 85 a0 1f 70 f0 	mov    -0xf8fe060(,%eax,4),%eax
f01094ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f01094af:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01094b3:	74 06                	je     f01094bb <kheap_virtual_address+0x2d>
f01094b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01094b8:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f01094bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01094be:	c9                   	leave  
f01094bf:	c3                   	ret    

f01094c0 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f01094c0:	55                   	push   %ebp
f01094c1:	89 e5                	mov    %esp,%ebp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	return NULL;
f01094c3:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f01094c8:	5d                   	pop    %ebp
f01094c9:	c3                   	ret    

f01094ca <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f01094ca:	55                   	push   %ebp
f01094cb:	89 e5                	mov    %esp,%ebp
f01094cd:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01094d0:	83 ec 04             	sub    $0x4,%esp
f01094d3:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01094d6:	50                   	push   %eax
f01094d7:	ff 75 0c             	pushl  0xc(%ebp)
f01094da:	ff 75 08             	pushl  0x8(%ebp)
f01094dd:	e8 0d ef ff ff       	call   f01083ef <get_page_table>
f01094e2:	83 c4 10             	add    $0x10,%esp
f01094e5:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f01094e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01094eb:	85 c0                	test   %eax,%eax
f01094ed:	74 64                	je     f0109553 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f01094ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01094f2:	8b 55 0c             	mov    0xc(%ebp),%edx
f01094f5:	c1 ea 0c             	shr    $0xc,%edx
f01094f8:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01094fe:	c1 e2 02             	shl    $0x2,%edx
f0109501:	01 c2                	add    %eax,%edx
f0109503:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109506:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109509:	c1 e9 0c             	shr    $0xc,%ecx
f010950c:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109512:	c1 e1 02             	shl    $0x2,%ecx
f0109515:	01 c8                	add    %ecx,%eax
f0109517:	8b 00                	mov    (%eax),%eax
f0109519:	0b 45 10             	or     0x10(%ebp),%eax
f010951c:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f010951e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109521:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109524:	c1 ea 0c             	shr    $0xc,%edx
f0109527:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010952d:	c1 e2 02             	shl    $0x2,%edx
f0109530:	01 d0                	add    %edx,%eax
f0109532:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109535:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109538:	c1 e9 0c             	shr    $0xc,%ecx
f010953b:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109541:	c1 e1 02             	shl    $0x2,%ecx
f0109544:	01 ca                	add    %ecx,%edx
f0109546:	8b 12                	mov    (%edx),%edx
f0109548:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010954b:	f7 d1                	not    %ecx
f010954d:	21 ca                	and    %ecx,%edx
f010954f:	89 10                	mov    %edx,(%eax)
f0109551:	eb 27                	jmp    f010957a <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109553:	83 ec 08             	sub    $0x8,%esp
f0109556:	ff 75 0c             	pushl  0xc(%ebp)
f0109559:	68 04 55 12 f0       	push   $0xf0125504
f010955e:	e8 28 7a ff ff       	call   f0100f8b <cprintf>
f0109563:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109566:	83 ec 04             	sub    $0x4,%esp
f0109569:	68 2c 55 12 f0       	push   $0xf012552c
f010956e:	6a 1c                	push   $0x1c
f0109570:	68 a0 55 12 f0       	push   $0xf01255a0
f0109575:	e8 bf 6d ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010957a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010957d:	83 ec 08             	sub    $0x8,%esp
f0109580:	50                   	push   %eax
f0109581:	6a 00                	push   $0x0
f0109583:	e8 31 e8 ff ff       	call   f0107db9 <tlb_invalidate>
f0109588:	83 c4 10             	add    $0x10,%esp
}
f010958b:	90                   	nop
f010958c:	c9                   	leave  
f010958d:	c3                   	ret    

f010958e <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f010958e:	55                   	push   %ebp
f010958f:	89 e5                	mov    %esp,%ebp
f0109591:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109594:	83 ec 04             	sub    $0x4,%esp
f0109597:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010959a:	50                   	push   %eax
f010959b:	ff 75 0c             	pushl  0xc(%ebp)
f010959e:	ff 75 08             	pushl  0x8(%ebp)
f01095a1:	e8 49 ee ff ff       	call   f01083ef <get_page_table>
f01095a6:	83 c4 10             	add    $0x10,%esp
f01095a9:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f01095ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095af:	85 c0                	test   %eax,%eax
f01095b1:	74 1d                	je     f01095d0 <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f01095b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095b6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01095b9:	c1 ea 0c             	shr    $0xc,%edx
f01095bc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01095c2:	c1 e2 02             	shl    $0x2,%edx
f01095c5:	01 d0                	add    %edx,%eax
f01095c7:	8b 00                	mov    (%eax),%eax
f01095c9:	25 ff 0f 00 00       	and    $0xfff,%eax
f01095ce:	eb 05                	jmp    f01095d5 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f01095d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f01095d5:	c9                   	leave  
f01095d6:	c3                   	ret    

f01095d7 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f01095d7:	55                   	push   %ebp
f01095d8:	89 e5                	mov    %esp,%ebp
f01095da:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01095dd:	83 ec 04             	sub    $0x4,%esp
f01095e0:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01095e3:	50                   	push   %eax
f01095e4:	ff 75 0c             	pushl  0xc(%ebp)
f01095e7:	ff 75 08             	pushl  0x8(%ebp)
f01095ea:	e8 00 ee ff ff       	call   f01083ef <get_page_table>
f01095ef:	83 c4 10             	add    $0x10,%esp
f01095f2:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f01095f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095f8:	85 c0                	test   %eax,%eax
f01095fa:	74 46                	je     f0109642 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f01095fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095ff:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109602:	c1 ea 0c             	shr    $0xc,%edx
f0109605:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010960b:	c1 e2 02             	shl    $0x2,%edx
f010960e:	01 d0                	add    %edx,%eax
f0109610:	8b 00                	mov    (%eax),%eax
f0109612:	83 ec 04             	sub    $0x4,%esp
f0109615:	50                   	push   %eax
f0109616:	ff 75 0c             	pushl  0xc(%ebp)
f0109619:	68 bc 55 12 f0       	push   $0xf01255bc
f010961e:	e8 68 79 ff ff       	call   f0100f8b <cprintf>
f0109623:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0109626:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109629:	8b 55 0c             	mov    0xc(%ebp),%edx
f010962c:	c1 ea 0c             	shr    $0xc,%edx
f010962f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109635:	c1 e2 02             	shl    $0x2,%edx
f0109638:	01 d0                	add    %edx,%eax
f010963a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109640:	eb 14                	jmp    f0109656 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109642:	83 ec 04             	sub    $0x4,%esp
f0109645:	68 e4 55 12 f0       	push   $0xf01255e4
f010964a:	6a 47                	push   $0x47
f010964c:	68 a0 55 12 f0       	push   $0xf01255a0
f0109651:	e8 e3 6c ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109656:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109659:	83 ec 08             	sub    $0x8,%esp
f010965c:	50                   	push   %eax
f010965d:	6a 00                	push   $0x0
f010965f:	e8 55 e7 ff ff       	call   f0107db9 <tlb_invalidate>
f0109664:	83 c4 10             	add    $0x10,%esp
}
f0109667:	90                   	nop
f0109668:	c9                   	leave  
f0109669:	c3                   	ret    

f010966a <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f010966a:	55                   	push   %ebp
f010966b:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f010966d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109670:	c1 e8 16             	shr    $0x16,%eax
f0109673:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010967a:	8b 45 08             	mov    0x8(%ebp),%eax
f010967d:	01 d0                	add    %edx,%eax
f010967f:	8b 00                	mov    (%eax),%eax
f0109681:	83 e0 20             	and    $0x20,%eax
f0109684:	85 c0                	test   %eax,%eax
f0109686:	0f 95 c0             	setne  %al
f0109689:	0f b6 c0             	movzbl %al,%eax
}
f010968c:	5d                   	pop    %ebp
f010968d:	c3                   	ret    

f010968e <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f010968e:	55                   	push   %ebp
f010968f:	89 e5                	mov    %esp,%ebp
f0109691:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0109694:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109697:	c1 e8 16             	shr    $0x16,%eax
f010969a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01096a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01096a4:	01 d0                	add    %edx,%eax
f01096a6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01096a9:	c1 ea 16             	shr    $0x16,%edx
f01096ac:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f01096b3:	8b 55 08             	mov    0x8(%ebp),%edx
f01096b6:	01 ca                	add    %ecx,%edx
f01096b8:	8b 12                	mov    (%edx),%edx
f01096ba:	83 e2 df             	and    $0xffffffdf,%edx
f01096bd:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01096bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01096c2:	83 ec 08             	sub    $0x8,%esp
f01096c5:	50                   	push   %eax
f01096c6:	6a 00                	push   $0x0
f01096c8:	e8 ec e6 ff ff       	call   f0107db9 <tlb_invalidate>
f01096cd:	83 c4 10             	add    $0x10,%esp
}
f01096d0:	90                   	nop
f01096d1:	c9                   	leave  
f01096d2:	c3                   	ret    

f01096d3 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f01096d3:	55                   	push   %ebp
f01096d4:	89 e5                	mov    %esp,%ebp
f01096d6:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f01096d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01096dc:	c1 e8 16             	shr    $0x16,%eax
f01096df:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01096e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01096e9:	01 d0                	add    %edx,%eax
f01096eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01096f1:	0f 20 d8             	mov    %cr3,%eax
f01096f4:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01096f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01096fa:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01096fd:	90                   	nop
f01096fe:	c9                   	leave  
f01096ff:	c3                   	ret    

f0109700 <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0109700:	55                   	push   %ebp
f0109701:	89 e5                	mov    %esp,%ebp
f0109703:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f0109706:	83 ec 0c             	sub    $0xc,%esp
f0109709:	6a 18                	push   $0x18
f010970b:	e8 db f9 ff ff       	call   f01090eb <kmalloc>
f0109710:	83 c4 10             	add    $0x10,%esp
f0109713:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f0109716:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010971a:	75 14                	jne    f0109730 <env_page_ws_list_create_element+0x30>
f010971c:	83 ec 04             	sub    $0x4,%esp
f010971f:	68 5c 56 12 f0       	push   $0xf012565c
f0109724:	6a 19                	push   $0x19
f0109726:	68 8c 56 12 f0       	push   $0xf012568c
f010972b:	e8 09 6c ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f0109730:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109733:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f0109736:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109739:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010973c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010973f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109744:	89 c2                	mov    %eax,%edx
f0109746:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109749:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f010974b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010974e:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f0109752:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109755:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f010975c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010975f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f0109766:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f0109769:	c9                   	leave  
f010976a:	c3                   	ret    

f010976b <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010976b:	55                   	push   %ebp
f010976c:	89 e5                	mov    %esp,%ebp
f010976e:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109771:	83 ec 0c             	sub    $0xc,%esp
f0109774:	6a 02                	push   $0x2
f0109776:	e8 4a 57 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f010977b:	83 c4 10             	add    $0x10,%esp
f010977e:	85 c0                	test   %eax,%eax
f0109780:	0f 84 e5 03 00 00    	je     f0109b6b <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0109786:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f010978d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109794:	8b 45 08             	mov    0x8(%ebp),%eax
f0109797:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010979d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01097a0:	e9 3b 02 00 00       	jmp    f01099e0 <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f01097a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01097a8:	8b 00                	mov    (%eax),%eax
f01097aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01097ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01097b0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01097b5:	89 c2                	mov    %eax,%edx
f01097b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01097bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01097c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01097c5:	39 c2                	cmp    %eax,%edx
f01097c7:	0f 85 07 02 00 00    	jne    f01099d4 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f01097cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01097d0:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01097d6:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f01097d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01097dc:	8b 10                	mov    (%eax),%edx
f01097de:	8b 45 08             	mov    0x8(%ebp),%eax
f01097e1:	8b 40 64             	mov    0x64(%eax),%eax
f01097e4:	83 ec 08             	sub    $0x8,%esp
f01097e7:	52                   	push   %edx
f01097e8:	50                   	push   %eax
f01097e9:	e8 f1 ef ff ff       	call   f01087df <unmap_frame>
f01097ee:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f01097f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01097f5:	75 14                	jne    f010980b <env_page_ws_invalidate+0xa0>
f01097f7:	83 ec 04             	sub    $0x4,%esp
f01097fa:	68 ab 56 12 f0       	push   $0xf01256ab
f01097ff:	6a 2f                	push   $0x2f
f0109801:	68 8c 56 12 f0       	push   $0xf012568c
f0109806:	e8 2e 6b ff ff       	call   f0100339 <_panic>
f010980b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010980e:	8b 40 10             	mov    0x10(%eax),%eax
f0109811:	85 c0                	test   %eax,%eax
f0109813:	74 11                	je     f0109826 <env_page_ws_invalidate+0xbb>
f0109815:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109818:	8b 40 10             	mov    0x10(%eax),%eax
f010981b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010981e:	8b 52 14             	mov    0x14(%edx),%edx
f0109821:	89 50 14             	mov    %edx,0x14(%eax)
f0109824:	eb 0f                	jmp    f0109835 <env_page_ws_invalidate+0xca>
f0109826:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109829:	8b 50 14             	mov    0x14(%eax),%edx
f010982c:	8b 45 08             	mov    0x8(%ebp),%eax
f010982f:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f0109835:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109838:	8b 40 14             	mov    0x14(%eax),%eax
f010983b:	85 c0                	test   %eax,%eax
f010983d:	74 11                	je     f0109850 <env_page_ws_invalidate+0xe5>
f010983f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109842:	8b 40 14             	mov    0x14(%eax),%eax
f0109845:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109848:	8b 52 10             	mov    0x10(%edx),%edx
f010984b:	89 50 10             	mov    %edx,0x10(%eax)
f010984e:	eb 0f                	jmp    f010985f <env_page_ws_invalidate+0xf4>
f0109850:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109853:	8b 50 10             	mov    0x10(%eax),%edx
f0109856:	8b 45 08             	mov    0x8(%ebp),%eax
f0109859:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010985f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109862:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109869:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010986c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109873:	8b 45 08             	mov    0x8(%ebp),%eax
f0109876:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010987c:	8d 50 ff             	lea    -0x1(%eax),%edx
f010987f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109882:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f0109888:	83 ec 0c             	sub    $0xc,%esp
f010988b:	ff 75 f0             	pushl  -0x10(%ebp)
f010988e:	e8 b8 fa ff ff       	call   f010934b <kfree>
f0109893:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f0109896:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010989a:	0f 84 2b 01 00 00    	je     f01099cb <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f01098a0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01098a4:	75 14                	jne    f01098ba <env_page_ws_invalidate+0x14f>
f01098a6:	83 ec 04             	sub    $0x4,%esp
f01098a9:	68 ab 56 12 f0       	push   $0xf01256ab
f01098ae:	6a 35                	push   $0x35
f01098b0:	68 8c 56 12 f0       	push   $0xf012568c
f01098b5:	e8 7f 6a ff ff       	call   f0100339 <_panic>
f01098ba:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01098bd:	8b 40 10             	mov    0x10(%eax),%eax
f01098c0:	85 c0                	test   %eax,%eax
f01098c2:	74 11                	je     f01098d5 <env_page_ws_invalidate+0x16a>
f01098c4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01098c7:	8b 40 10             	mov    0x10(%eax),%eax
f01098ca:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01098cd:	8b 52 14             	mov    0x14(%edx),%edx
f01098d0:	89 50 14             	mov    %edx,0x14(%eax)
f01098d3:	eb 0f                	jmp    f01098e4 <env_page_ws_invalidate+0x179>
f01098d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01098d8:	8b 50 14             	mov    0x14(%eax),%edx
f01098db:	8b 45 08             	mov    0x8(%ebp),%eax
f01098de:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f01098e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01098e7:	8b 40 14             	mov    0x14(%eax),%eax
f01098ea:	85 c0                	test   %eax,%eax
f01098ec:	74 11                	je     f01098ff <env_page_ws_invalidate+0x194>
f01098ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01098f1:	8b 40 14             	mov    0x14(%eax),%eax
f01098f4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01098f7:	8b 52 10             	mov    0x10(%edx),%edx
f01098fa:	89 50 10             	mov    %edx,0x10(%eax)
f01098fd:	eb 0f                	jmp    f010990e <env_page_ws_invalidate+0x1a3>
f01098ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109902:	8b 50 10             	mov    0x10(%eax),%edx
f0109905:	8b 45 08             	mov    0x8(%ebp),%eax
f0109908:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010990e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109911:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109918:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010991b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109922:	8b 45 08             	mov    0x8(%ebp),%eax
f0109925:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010992b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010992e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109931:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f0109937:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010993b:	75 14                	jne    f0109951 <env_page_ws_invalidate+0x1e6>
f010993d:	83 ec 04             	sub    $0x4,%esp
f0109940:	68 cc 56 12 f0       	push   $0xf01256cc
f0109945:	6a 36                	push   $0x36
f0109947:	68 8c 56 12 f0       	push   $0xf012568c
f010994c:	e8 e8 69 ff ff       	call   f0100339 <_panic>
f0109951:	8b 45 08             	mov    0x8(%ebp),%eax
f0109954:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010995a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010995d:	89 50 14             	mov    %edx,0x14(%eax)
f0109960:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109963:	8b 40 14             	mov    0x14(%eax),%eax
f0109966:	85 c0                	test   %eax,%eax
f0109968:	74 11                	je     f010997b <env_page_ws_invalidate+0x210>
f010996a:	8b 45 08             	mov    0x8(%ebp),%eax
f010996d:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f0109973:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109976:	89 50 10             	mov    %edx,0x10(%eax)
f0109979:	eb 0c                	jmp    f0109987 <env_page_ws_invalidate+0x21c>
f010997b:	8b 45 08             	mov    0x8(%ebp),%eax
f010997e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109981:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f0109987:	8b 45 08             	mov    0x8(%ebp),%eax
f010998a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010998d:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f0109993:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109996:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010999d:	8b 45 08             	mov    0x8(%ebp),%eax
f01099a0:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f01099a6:	8d 50 01             	lea    0x1(%eax),%edx
f01099a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01099ac:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f01099b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099b5:	8b 10                	mov    (%eax),%edx
f01099b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01099ba:	8b 40 64             	mov    0x64(%eax),%eax
f01099bd:	6a 00                	push   $0x0
f01099bf:	6a 01                	push   $0x1
f01099c1:	52                   	push   %edx
f01099c2:	50                   	push   %eax
f01099c3:	e8 02 fb ff ff       	call   f01094ca <pt_set_page_permissions>
f01099c8:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f01099cb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f01099d2:	eb 43                	jmp    f0109a17 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f01099d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01099d7:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01099dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01099e0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01099e4:	74 08                	je     f01099ee <env_page_ws_invalidate+0x283>
f01099e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099e9:	8b 40 10             	mov    0x10(%eax),%eax
f01099ec:	eb 05                	jmp    f01099f3 <env_page_ws_invalidate+0x288>
f01099ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01099f3:	8b 55 08             	mov    0x8(%ebp),%edx
f01099f6:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f01099fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01099ff:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109a05:	85 c0                	test   %eax,%eax
f0109a07:	0f 85 98 fd ff ff    	jne    f01097a5 <env_page_ws_invalidate+0x3a>
f0109a0d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109a11:	0f 85 8e fd ff ff    	jne    f01097a5 <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f0109a17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109a1b:	0f 85 a4 02 00 00    	jne    f0109cc5 <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f0109a21:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109a28:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a2b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109a31:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109a34:	e9 f6 00 00 00       	jmp    f0109b2f <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109a39:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a3c:	8b 00                	mov    (%eax),%eax
f0109a3e:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0109a41:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109a44:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109a49:	89 c2                	mov    %eax,%edx
f0109a4b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0109a51:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109a54:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109a59:	39 c2                	cmp    %eax,%edx
f0109a5b:	0f 85 c2 00 00 00    	jne    f0109b23 <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109a61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a64:	8b 10                	mov    (%eax),%edx
f0109a66:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a69:	8b 40 64             	mov    0x64(%eax),%eax
f0109a6c:	83 ec 08             	sub    $0x8,%esp
f0109a6f:	52                   	push   %edx
f0109a70:	50                   	push   %eax
f0109a71:	e8 69 ed ff ff       	call   f01087df <unmap_frame>
f0109a76:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f0109a79:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109a7d:	75 14                	jne    f0109a93 <env_page_ws_invalidate+0x328>
f0109a7f:	83 ec 04             	sub    $0x4,%esp
f0109a82:	68 ab 56 12 f0       	push   $0xf01256ab
f0109a87:	6a 46                	push   $0x46
f0109a89:	68 8c 56 12 f0       	push   $0xf012568c
f0109a8e:	e8 a6 68 ff ff       	call   f0100339 <_panic>
f0109a93:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a96:	8b 40 10             	mov    0x10(%eax),%eax
f0109a99:	85 c0                	test   %eax,%eax
f0109a9b:	74 11                	je     f0109aae <env_page_ws_invalidate+0x343>
f0109a9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109aa0:	8b 40 10             	mov    0x10(%eax),%eax
f0109aa3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109aa6:	8b 52 14             	mov    0x14(%edx),%edx
f0109aa9:	89 50 14             	mov    %edx,0x14(%eax)
f0109aac:	eb 0f                	jmp    f0109abd <env_page_ws_invalidate+0x352>
f0109aae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ab1:	8b 50 14             	mov    0x14(%eax),%edx
f0109ab4:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ab7:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f0109abd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ac0:	8b 40 14             	mov    0x14(%eax),%eax
f0109ac3:	85 c0                	test   %eax,%eax
f0109ac5:	74 11                	je     f0109ad8 <env_page_ws_invalidate+0x36d>
f0109ac7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109aca:	8b 40 14             	mov    0x14(%eax),%eax
f0109acd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109ad0:	8b 52 10             	mov    0x10(%edx),%edx
f0109ad3:	89 50 10             	mov    %edx,0x10(%eax)
f0109ad6:	eb 0f                	jmp    f0109ae7 <env_page_ws_invalidate+0x37c>
f0109ad8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109adb:	8b 50 10             	mov    0x10(%eax),%edx
f0109ade:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ae1:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f0109ae7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109aea:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109af1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109af4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109afb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109afe:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f0109b04:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b0a:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f0109b10:	83 ec 0c             	sub    $0xc,%esp
f0109b13:	ff 75 f0             	pushl  -0x10(%ebp)
f0109b16:	e8 30 f8 ff ff       	call   f010934b <kfree>
f0109b1b:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f0109b1e:	e9 a2 01 00 00       	jmp    f0109cc5 <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109b23:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b26:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109b2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109b2f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109b33:	74 08                	je     f0109b3d <env_page_ws_invalidate+0x3d2>
f0109b35:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b38:	8b 40 10             	mov    0x10(%eax),%eax
f0109b3b:	eb 05                	jmp    f0109b42 <env_page_ws_invalidate+0x3d7>
f0109b3d:	b8 00 00 00 00       	mov    $0x0,%eax
f0109b42:	8b 55 08             	mov    0x8(%ebp),%edx
f0109b45:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0109b4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b4e:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109b54:	85 c0                	test   %eax,%eax
f0109b56:	0f 85 dd fe ff ff    	jne    f0109a39 <env_page_ws_invalidate+0x2ce>
f0109b5c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109b60:	0f 85 d3 fe ff ff    	jne    f0109a39 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f0109b66:	e9 5a 01 00 00       	jmp    f0109cc5 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109b6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b6e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0109b74:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109b77:	e9 10 01 00 00       	jmp    f0109c8c <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109b7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109b7f:	8b 00                	mov    (%eax),%eax
f0109b81:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109b84:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109b87:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b8c:	89 c2                	mov    %eax,%edx
f0109b8e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109b91:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109b94:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109b97:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b9c:	39 c2                	cmp    %eax,%edx
f0109b9e:	0f 85 dc 00 00 00    	jne    f0109c80 <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f0109ba4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109ba7:	8b 10                	mov    (%eax),%edx
f0109ba9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bac:	8b 40 64             	mov    0x64(%eax),%eax
f0109baf:	83 ec 08             	sub    $0x8,%esp
f0109bb2:	52                   	push   %edx
f0109bb3:	50                   	push   %eax
f0109bb4:	e8 26 ec ff ff       	call   f01087df <unmap_frame>
f0109bb9:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f0109bbc:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bbf:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0109bc5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109bc8:	75 0f                	jne    f0109bd9 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f0109bca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109bcd:	8b 50 10             	mov    0x10(%eax),%edx
f0109bd0:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bd3:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f0109bd9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109bdd:	75 14                	jne    f0109bf3 <env_page_ws_invalidate+0x488>
f0109bdf:	83 ec 04             	sub    $0x4,%esp
f0109be2:	68 ab 56 12 f0       	push   $0xf01256ab
f0109be7:	6a 5c                	push   $0x5c
f0109be9:	68 8c 56 12 f0       	push   $0xf012568c
f0109bee:	e8 46 67 ff ff       	call   f0100339 <_panic>
f0109bf3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109bf6:	8b 40 10             	mov    0x10(%eax),%eax
f0109bf9:	85 c0                	test   %eax,%eax
f0109bfb:	74 11                	je     f0109c0e <env_page_ws_invalidate+0x4a3>
f0109bfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c00:	8b 40 10             	mov    0x10(%eax),%eax
f0109c03:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109c06:	8b 52 14             	mov    0x14(%edx),%edx
f0109c09:	89 50 14             	mov    %edx,0x14(%eax)
f0109c0c:	eb 0f                	jmp    f0109c1d <env_page_ws_invalidate+0x4b2>
f0109c0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c11:	8b 50 14             	mov    0x14(%eax),%edx
f0109c14:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c17:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f0109c1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c20:	8b 40 14             	mov    0x14(%eax),%eax
f0109c23:	85 c0                	test   %eax,%eax
f0109c25:	74 11                	je     f0109c38 <env_page_ws_invalidate+0x4cd>
f0109c27:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c2a:	8b 40 14             	mov    0x14(%eax),%eax
f0109c2d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109c30:	8b 52 10             	mov    0x10(%edx),%edx
f0109c33:	89 50 10             	mov    %edx,0x10(%eax)
f0109c36:	eb 0f                	jmp    f0109c47 <env_page_ws_invalidate+0x4dc>
f0109c38:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c3b:	8b 50 10             	mov    0x10(%eax),%edx
f0109c3e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c41:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f0109c47:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c4a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109c51:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c54:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109c5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c5e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f0109c64:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109c67:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c6a:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f0109c70:	83 ec 0c             	sub    $0xc,%esp
f0109c73:	ff 75 ec             	pushl  -0x14(%ebp)
f0109c76:	e8 d0 f6 ff ff       	call   f010934b <kfree>
f0109c7b:	83 c4 10             	add    $0x10,%esp

				break;
f0109c7e:	eb 45                	jmp    f0109cc5 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109c80:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c83:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109c89:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109c8c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109c90:	74 08                	je     f0109c9a <env_page_ws_invalidate+0x52f>
f0109c92:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c95:	8b 40 10             	mov    0x10(%eax),%eax
f0109c98:	eb 05                	jmp    f0109c9f <env_page_ws_invalidate+0x534>
f0109c9a:	b8 00 00 00 00       	mov    $0x0,%eax
f0109c9f:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ca2:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0109ca8:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cab:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109cb1:	85 c0                	test   %eax,%eax
f0109cb3:	0f 85 c3 fe ff ff    	jne    f0109b7c <env_page_ws_invalidate+0x411>
f0109cb9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109cbd:	0f 85 b9 fe ff ff    	jne    f0109b7c <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f0109cc3:	eb 00                	jmp    f0109cc5 <env_page_ws_invalidate+0x55a>
f0109cc5:	90                   	nop
f0109cc6:	c9                   	leave  
f0109cc7:	c3                   	ret    

f0109cc8 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f0109cc8:	55                   	push   %ebp
f0109cc9:	89 e5                	mov    %esp,%ebp
f0109ccb:	53                   	push   %ebx
f0109ccc:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109ccf:	83 ec 0c             	sub    $0xc,%esp
f0109cd2:	6a 02                	push   $0x2
f0109cd4:	e8 ec 51 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f0109cd9:	83 c4 10             	add    $0x10,%esp
f0109cdc:	85 c0                	test   %eax,%eax
f0109cde:	0f 84 fe 00 00 00    	je     f0109de2 <env_page_ws_print+0x11a>
	{
		int i = 0;
f0109ce4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f0109ceb:	83 ec 0c             	sub    $0xc,%esp
f0109cee:	68 ef 56 12 f0       	push   $0xf01256ef
f0109cf3:	e8 93 72 ff ff       	call   f0100f8b <cprintf>
f0109cf8:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109cfb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cfe:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109d04:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109d07:	eb 2c                	jmp    f0109d35 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109d09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d0c:	8b 10                	mov    (%eax),%edx
f0109d0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109d11:	8d 48 01             	lea    0x1(%eax),%ecx
f0109d14:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109d17:	83 ec 04             	sub    $0x4,%esp
f0109d1a:	52                   	push   %edx
f0109d1b:	50                   	push   %eax
f0109d1c:	68 09 57 12 f0       	push   $0xf0125709
f0109d21:	e8 65 72 ff ff       	call   f0100f8b <cprintf>
f0109d26:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109d29:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d2c:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109d32:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109d35:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109d39:	74 08                	je     f0109d43 <env_page_ws_print+0x7b>
f0109d3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d3e:	8b 40 10             	mov    0x10(%eax),%eax
f0109d41:	eb 05                	jmp    f0109d48 <env_page_ws_print+0x80>
f0109d43:	b8 00 00 00 00       	mov    $0x0,%eax
f0109d48:	8b 55 08             	mov    0x8(%ebp),%edx
f0109d4b:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0109d51:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d54:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109d5a:	85 c0                	test   %eax,%eax
f0109d5c:	75 ab                	jne    f0109d09 <env_page_ws_print+0x41>
f0109d5e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109d62:	75 a5                	jne    f0109d09 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f0109d64:	83 ec 0c             	sub    $0xc,%esp
f0109d67:	68 11 57 12 f0       	push   $0xf0125711
f0109d6c:	e8 1a 72 ff ff       	call   f0100f8b <cprintf>
f0109d71:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109d74:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d77:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109d7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109d80:	eb 2c                	jmp    f0109dae <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109d82:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d85:	8b 10                	mov    (%eax),%edx
f0109d87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109d8a:	8d 48 01             	lea    0x1(%eax),%ecx
f0109d8d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109d90:	83 ec 04             	sub    $0x4,%esp
f0109d93:	52                   	push   %edx
f0109d94:	50                   	push   %eax
f0109d95:	68 09 57 12 f0       	push   $0xf0125709
f0109d9a:	e8 ec 71 ff ff       	call   f0100f8b <cprintf>
f0109d9f:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109da2:	8b 45 08             	mov    0x8(%ebp),%eax
f0109da5:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109dab:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109dae:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109db2:	74 08                	je     f0109dbc <env_page_ws_print+0xf4>
f0109db4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109db7:	8b 40 10             	mov    0x10(%eax),%eax
f0109dba:	eb 05                	jmp    f0109dc1 <env_page_ws_print+0xf9>
f0109dbc:	b8 00 00 00 00       	mov    $0x0,%eax
f0109dc1:	8b 55 08             	mov    0x8(%ebp),%edx
f0109dc4:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0109dca:	8b 45 08             	mov    0x8(%ebp),%eax
f0109dcd:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109dd3:	85 c0                	test   %eax,%eax
f0109dd5:	75 ab                	jne    f0109d82 <env_page_ws_print+0xba>
f0109dd7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109ddb:	75 a5                	jne    f0109d82 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f0109ddd:	e9 5a 01 00 00       	jmp    f0109f3c <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f0109de2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f0109de9:	83 ec 0c             	sub    $0xc,%esp
f0109dec:	68 2c 57 12 f0       	push   $0xf012572c
f0109df1:	e8 95 71 ff ff       	call   f0100f8b <cprintf>
f0109df6:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f0109df9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109e00:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e03:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0109e09:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109e0c:	e9 d1 00 00 00       	jmp    f0109ee2 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f0109e11:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109e14:	8b 00                	mov    (%eax),%eax
f0109e16:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f0109e19:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109e1c:	8b 40 08             	mov    0x8(%eax),%eax
f0109e1f:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f0109e22:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e25:	8b 40 64             	mov    0x64(%eax),%eax
f0109e28:	83 ec 08             	sub    $0x8,%esp
f0109e2b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109e2e:	50                   	push   %eax
f0109e2f:	e8 5a f7 ff ff       	call   f010958e <pt_get_page_permissions>
f0109e34:	83 c4 10             	add    $0x10,%esp
f0109e37:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f0109e3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109e3d:	83 e0 40             	and    $0x40,%eax
f0109e40:	85 c0                	test   %eax,%eax
f0109e42:	0f 95 c0             	setne  %al
f0109e45:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f0109e48:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109e4b:	83 e0 20             	and    $0x20,%eax
f0109e4e:	85 c0                	test   %eax,%eax
f0109e50:	0f 95 c0             	setne  %al
f0109e53:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f0109e56:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109e59:	25 00 02 00 00       	and    $0x200,%eax
f0109e5e:	85 c0                	test   %eax,%eax
f0109e60:	0f 95 c0             	setne  %al
f0109e63:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f0109e66:	83 ec 04             	sub    $0x4,%esp
f0109e69:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109e6c:	ff 75 ec             	pushl  -0x14(%ebp)
f0109e6f:	68 36 57 12 f0       	push   $0xf0125736
f0109e74:	e8 12 71 ff ff       	call   f0100f8b <cprintf>
f0109e79:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f0109e7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109e7f:	8b 58 0c             	mov    0xc(%eax),%ebx
f0109e82:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f0109e86:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f0109e8a:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f0109e8e:	83 ec 08             	sub    $0x8,%esp
f0109e91:	53                   	push   %ebx
f0109e92:	ff 75 e0             	pushl  -0x20(%ebp)
f0109e95:	51                   	push   %ecx
f0109e96:	52                   	push   %edx
f0109e97:	50                   	push   %eax
f0109e98:	68 40 57 12 f0       	push   $0xf0125740
f0109e9d:	e8 e9 70 ff ff       	call   f0100f8b <cprintf>
f0109ea2:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f0109ea5:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ea8:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0109eae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109eb1:	75 10                	jne    f0109ec3 <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f0109eb3:	83 ec 0c             	sub    $0xc,%esp
f0109eb6:	68 87 57 12 f0       	push   $0xf0125787
f0109ebb:	e8 cb 70 ff ff       	call   f0100f8b <cprintf>
f0109ec0:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109ec3:	83 ec 0c             	sub    $0xc,%esp
f0109ec6:	68 8c 57 12 f0       	push   $0xf012578c
f0109ecb:	e8 bb 70 ff ff       	call   f0100f8b <cprintf>
f0109ed0:	83 c4 10             	add    $0x10,%esp
			i++;
f0109ed3:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109ed6:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ed9:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109edf:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109ee2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109ee6:	74 08                	je     f0109ef0 <env_page_ws_print+0x228>
f0109ee8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109eeb:	8b 40 10             	mov    0x10(%eax),%eax
f0109eee:	eb 05                	jmp    f0109ef5 <env_page_ws_print+0x22d>
f0109ef0:	b8 00 00 00 00       	mov    $0x0,%eax
f0109ef5:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ef8:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0109efe:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f01:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109f07:	85 c0                	test   %eax,%eax
f0109f09:	0f 85 02 ff ff ff    	jne    f0109e11 <env_page_ws_print+0x149>
f0109f0f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109f13:	0f 85 f8 fe ff ff    	jne    f0109e11 <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f0109f19:	eb 13                	jmp    f0109f2e <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f0109f1b:	83 ec 0c             	sub    $0xc,%esp
f0109f1e:	68 8e 57 12 f0       	push   $0xf012578e
f0109f23:	e8 63 70 ff ff       	call   f0100f8b <cprintf>
f0109f28:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f0109f2b:	ff 45 ec             	incl   -0x14(%ebp)
f0109f2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f31:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0109f37:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109f3a:	77 df                	ja     f0109f1b <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f0109f3c:	90                   	nop
f0109f3d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109f40:	c9                   	leave  
f0109f41:	c3                   	ret    

f0109f42 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f0109f42:	55                   	push   %ebp
f0109f43:	89 e5                	mov    %esp,%ebp
f0109f45:	53                   	push   %ebx
f0109f46:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f0109f49:	83 ec 0c             	sub    $0xc,%esp
f0109f4c:	68 a0 57 12 f0       	push   $0xf01257a0
f0109f51:	e8 35 70 ff ff       	call   f0100f8b <cprintf>
f0109f56:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f0109f59:	83 ec 0c             	sub    $0xc,%esp
f0109f5c:	68 d5 57 12 f0       	push   $0xf01257d5
f0109f61:	e8 25 70 ff ff       	call   f0100f8b <cprintf>
f0109f66:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f0109f69:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109f70:	e9 16 01 00 00       	jmp    f010a08b <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f0109f75:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109f78:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109f7b:	89 d0                	mov    %edx,%eax
f0109f7d:	01 c0                	add    %eax,%eax
f0109f7f:	01 d0                	add    %edx,%eax
f0109f81:	c1 e0 03             	shl    $0x3,%eax
f0109f84:	01 c8                	add    %ecx,%eax
f0109f86:	05 b0 00 00 00       	add    $0xb0,%eax
f0109f8b:	8a 00                	mov    (%eax),%al
f0109f8d:	84 c0                	test   %al,%al
f0109f8f:	74 43                	je     f0109fd4 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f0109f91:	83 ec 0c             	sub    $0xc,%esp
f0109f94:	68 e0 57 12 f0       	push   $0xf01257e0
f0109f99:	e8 ed 6f ff ff       	call   f0100f8b <cprintf>
f0109f9e:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f0109fa1:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fa4:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f0109faa:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109fad:	75 10                	jne    f0109fbf <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f0109faf:	83 ec 0c             	sub    $0xc,%esp
f0109fb2:	68 ef 57 12 f0       	push   $0xf01257ef
f0109fb7:	e8 cf 6f ff ff       	call   f0100f8b <cprintf>
f0109fbc:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109fbf:	83 ec 0c             	sub    $0xc,%esp
f0109fc2:	68 8c 57 12 f0       	push   $0xf012578c
f0109fc7:	e8 bf 6f ff ff       	call   f0100f8b <cprintf>
f0109fcc:	83 c4 10             	add    $0x10,%esp
			continue;
f0109fcf:	e9 b4 00 00 00       	jmp    f010a088 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f0109fd4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109fd7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109fda:	89 d0                	mov    %edx,%eax
f0109fdc:	01 c0                	add    %eax,%eax
f0109fde:	01 d0                	add    %edx,%eax
f0109fe0:	c1 e0 03             	shl    $0x3,%eax
f0109fe3:	01 c8                	add    %ecx,%eax
f0109fe5:	05 ac 00 00 00       	add    $0xac,%eax
f0109fea:	8b 00                	mov    (%eax),%eax
f0109fec:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f0109fef:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109ff2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109ff5:	89 d0                	mov    %edx,%eax
f0109ff7:	01 c0                	add    %eax,%eax
f0109ff9:	01 d0                	add    %edx,%eax
f0109ffb:	c1 e0 03             	shl    $0x3,%eax
f0109ffe:	01 c8                	add    %ecx,%eax
f010a000:	05 ac 00 00 00       	add    $0xac,%eax
f010a005:	8b 00                	mov    (%eax),%eax
f010a007:	83 ec 04             	sub    $0x4,%esp
f010a00a:	50                   	push   %eax
f010a00b:	ff 75 f4             	pushl  -0xc(%ebp)
f010a00e:	68 f5 57 12 f0       	push   $0xf01257f5
f010a013:	e8 73 6f ff ff       	call   f0100f8b <cprintf>
f010a018:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a01b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a01e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a021:	89 d0                	mov    %edx,%eax
f010a023:	01 c0                	add    %eax,%eax
f010a025:	01 d0                	add    %edx,%eax
f010a027:	c1 e0 03             	shl    $0x3,%eax
f010a02a:	01 c8                	add    %ecx,%eax
f010a02c:	05 b4 00 00 00       	add    $0xb4,%eax
f010a031:	8b 18                	mov    (%eax),%ebx
f010a033:	8b 45 08             	mov    0x8(%ebp),%eax
f010a036:	8b 40 64             	mov    0x64(%eax),%eax
f010a039:	83 ec 08             	sub    $0x8,%esp
f010a03c:	ff 75 f0             	pushl  -0x10(%ebp)
f010a03f:	50                   	push   %eax
f010a040:	e8 25 f6 ff ff       	call   f010966a <pd_is_table_used>
f010a045:	83 c4 10             	add    $0x10,%esp
f010a048:	83 ec 04             	sub    $0x4,%esp
f010a04b:	53                   	push   %ebx
f010a04c:	50                   	push   %eax
f010a04d:	68 0c 58 12 f0       	push   $0xf012580c
f010a052:	e8 34 6f ff ff       	call   f0100f8b <cprintf>
f010a057:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a05a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a05d:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a063:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a066:	75 10                	jne    f010a078 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a068:	83 ec 0c             	sub    $0xc,%esp
f010a06b:	68 87 57 12 f0       	push   $0xf0125787
f010a070:	e8 16 6f ff ff       	call   f0100f8b <cprintf>
f010a075:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a078:	83 ec 0c             	sub    $0xc,%esp
f010a07b:	68 8c 57 12 f0       	push   $0xf012578c
f010a080:	e8 06 6f ff ff       	call   f0100f8b <cprintf>
f010a085:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a088:	ff 45 f4             	incl   -0xc(%ebp)
f010a08b:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a08f:	0f 86 e0 fe ff ff    	jbe    f0109f75 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a095:	90                   	nop
f010a096:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a099:	c9                   	leave  
f010a09a:	c3                   	ret    

f010a09b <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a09b:	55                   	push   %ebp
f010a09c:	89 e5                	mov    %esp,%ebp
f010a09e:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a0a1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a0a8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a0af:	eb 22                	jmp    f010a0d3 <env_table_ws_get_size+0x38>
f010a0b1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a0b4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a0b7:	89 d0                	mov    %edx,%eax
f010a0b9:	01 c0                	add    %eax,%eax
f010a0bb:	01 d0                	add    %edx,%eax
f010a0bd:	c1 e0 03             	shl    $0x3,%eax
f010a0c0:	01 c8                	add    %ecx,%eax
f010a0c2:	05 b0 00 00 00       	add    $0xb0,%eax
f010a0c7:	8a 00                	mov    (%eax),%al
f010a0c9:	84 c0                	test   %al,%al
f010a0cb:	75 03                	jne    f010a0d0 <env_table_ws_get_size+0x35>
f010a0cd:	ff 45 f8             	incl   -0x8(%ebp)
f010a0d0:	ff 45 fc             	incl   -0x4(%ebp)
f010a0d3:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a0d7:	7e d8                	jle    f010a0b1 <env_table_ws_get_size+0x16>
	return counter;
f010a0d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a0dc:	c9                   	leave  
f010a0dd:	c3                   	ret    

f010a0de <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a0de:	55                   	push   %ebp
f010a0df:	89 e5                	mov    %esp,%ebp
f010a0e1:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a0e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010a0eb:	eb 4e                	jmp    f010a13b <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010a0ed:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a0f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a0f3:	89 d0                	mov    %edx,%eax
f010a0f5:	01 c0                	add    %eax,%eax
f010a0f7:	01 d0                	add    %edx,%eax
f010a0f9:	c1 e0 03             	shl    $0x3,%eax
f010a0fc:	01 c8                	add    %ecx,%eax
f010a0fe:	05 ac 00 00 00       	add    $0xac,%eax
f010a103:	8b 00                	mov    (%eax),%eax
f010a105:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a108:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a10b:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a110:	89 c2                	mov    %eax,%edx
f010a112:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a115:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a118:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a11b:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a120:	39 c2                	cmp    %eax,%edx
f010a122:	75 14                	jne    f010a138 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010a124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a127:	83 ec 08             	sub    $0x8,%esp
f010a12a:	50                   	push   %eax
f010a12b:	ff 75 08             	pushl  0x8(%ebp)
f010a12e:	e8 bc 00 00 00       	call   f010a1ef <env_table_ws_clear_entry>
f010a133:	83 c4 10             	add    $0x10,%esp
			break;
f010a136:	eb 09                	jmp    f010a141 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010a138:	ff 45 f4             	incl   -0xc(%ebp)
f010a13b:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a13f:	7e ac                	jle    f010a0ed <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010a141:	90                   	nop
f010a142:	c9                   	leave  
f010a143:	c3                   	ret    

f010a144 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010a144:	55                   	push   %ebp
f010a145:	89 e5                	mov    %esp,%ebp
f010a147:	53                   	push   %ebx
f010a148:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a14b:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a14f:	76 19                	jbe    f010a16a <env_table_ws_set_entry+0x26>
f010a151:	68 30 58 12 f0       	push   $0xf0125830
f010a156:	68 61 58 12 f0       	push   $0xf0125861
f010a15b:	68 3f 01 00 00       	push   $0x13f
f010a160:	68 8c 56 12 f0       	push   $0xf012568c
f010a165:	e8 cf 61 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a16a:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010a171:	76 19                	jbe    f010a18c <env_table_ws_set_entry+0x48>
f010a173:	68 78 58 12 f0       	push   $0xf0125878
f010a178:	68 61 58 12 f0       	push   $0xf0125861
f010a17d:	68 40 01 00 00       	push   $0x140
f010a182:	68 8c 56 12 f0       	push   $0xf012568c
f010a187:	e8 ad 61 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010a18c:	8b 45 10             	mov    0x10(%ebp),%eax
f010a18f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a192:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a195:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a19a:	89 c1                	mov    %eax,%ecx
f010a19c:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010a19f:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a1a2:	89 d0                	mov    %edx,%eax
f010a1a4:	01 c0                	add    %eax,%eax
f010a1a6:	01 d0                	add    %edx,%eax
f010a1a8:	c1 e0 03             	shl    $0x3,%eax
f010a1ab:	01 d8                	add    %ebx,%eax
f010a1ad:	05 ac 00 00 00       	add    $0xac,%eax
f010a1b2:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010a1b4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a1b7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a1ba:	89 d0                	mov    %edx,%eax
f010a1bc:	01 c0                	add    %eax,%eax
f010a1be:	01 d0                	add    %edx,%eax
f010a1c0:	c1 e0 03             	shl    $0x3,%eax
f010a1c3:	01 c8                	add    %ecx,%eax
f010a1c5:	05 b0 00 00 00       	add    $0xb0,%eax
f010a1ca:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010a1cd:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a1d0:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a1d3:	89 d0                	mov    %edx,%eax
f010a1d5:	01 c0                	add    %eax,%eax
f010a1d7:	01 d0                	add    %edx,%eax
f010a1d9:	c1 e0 03             	shl    $0x3,%eax
f010a1dc:	01 c8                	add    %ecx,%eax
f010a1de:	05 b4 00 00 00       	add    $0xb4,%eax
f010a1e3:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010a1e9:	90                   	nop
}
f010a1ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a1ed:	c9                   	leave  
f010a1ee:	c3                   	ret    

f010a1ef <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010a1ef:	55                   	push   %ebp
f010a1f0:	89 e5                	mov    %esp,%ebp
f010a1f2:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a1f5:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a1f9:	76 19                	jbe    f010a214 <env_table_ws_clear_entry+0x25>
f010a1fb:	68 30 58 12 f0       	push   $0xf0125830
f010a200:	68 61 58 12 f0       	push   $0xf0125861
f010a205:	68 4b 01 00 00       	push   $0x14b
f010a20a:	68 8c 56 12 f0       	push   $0xf012568c
f010a20f:	e8 25 61 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010a214:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a217:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a21a:	89 d0                	mov    %edx,%eax
f010a21c:	01 c0                	add    %eax,%eax
f010a21e:	01 d0                	add    %edx,%eax
f010a220:	c1 e0 03             	shl    $0x3,%eax
f010a223:	01 c8                	add    %ecx,%eax
f010a225:	05 ac 00 00 00       	add    $0xac,%eax
f010a22a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010a230:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a233:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a236:	89 d0                	mov    %edx,%eax
f010a238:	01 c0                	add    %eax,%eax
f010a23a:	01 d0                	add    %edx,%eax
f010a23c:	c1 e0 03             	shl    $0x3,%eax
f010a23f:	01 c8                	add    %ecx,%eax
f010a241:	05 b0 00 00 00       	add    $0xb0,%eax
f010a246:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010a249:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a24c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a24f:	89 d0                	mov    %edx,%eax
f010a251:	01 c0                	add    %eax,%eax
f010a253:	01 d0                	add    %edx,%eax
f010a255:	c1 e0 03             	shl    $0x3,%eax
f010a258:	01 c8                	add    %ecx,%eax
f010a25a:	05 b4 00 00 00       	add    $0xb4,%eax
f010a25f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010a265:	90                   	nop
f010a266:	c9                   	leave  
f010a267:	c3                   	ret    

f010a268 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010a268:	55                   	push   %ebp
f010a269:	89 e5                	mov    %esp,%ebp
f010a26b:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a26e:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a272:	76 19                	jbe    f010a28d <env_table_ws_get_virtual_address+0x25>
f010a274:	68 30 58 12 f0       	push   $0xf0125830
f010a279:	68 61 58 12 f0       	push   $0xf0125861
f010a27e:	68 53 01 00 00       	push   $0x153
f010a283:	68 8c 56 12 f0       	push   $0xf012568c
f010a288:	e8 ac 60 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010a28d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a290:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a293:	89 d0                	mov    %edx,%eax
f010a295:	01 c0                	add    %eax,%eax
f010a297:	01 d0                	add    %edx,%eax
f010a299:	c1 e0 03             	shl    $0x3,%eax
f010a29c:	01 c8                	add    %ecx,%eax
f010a29e:	05 ac 00 00 00       	add    $0xac,%eax
f010a2a3:	8b 00                	mov    (%eax),%eax
f010a2a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a2a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a2ab:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010a2b0:	c9                   	leave  
f010a2b1:	c3                   	ret    

f010a2b2 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010a2b2:	55                   	push   %ebp
f010a2b3:	89 e5                	mov    %esp,%ebp
f010a2b5:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a2b8:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a2bc:	76 19                	jbe    f010a2d7 <env_table_ws_get_time_stamp+0x25>
f010a2be:	68 30 58 12 f0       	push   $0xf0125830
f010a2c3:	68 61 58 12 f0       	push   $0xf0125861
f010a2c8:	68 5a 01 00 00       	push   $0x15a
f010a2cd:	68 8c 56 12 f0       	push   $0xf012568c
f010a2d2:	e8 62 60 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010a2d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a2da:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2dd:	89 d0                	mov    %edx,%eax
f010a2df:	01 c0                	add    %eax,%eax
f010a2e1:	01 d0                	add    %edx,%eax
f010a2e3:	c1 e0 03             	shl    $0x3,%eax
f010a2e6:	01 c8                	add    %ecx,%eax
f010a2e8:	05 b4 00 00 00       	add    $0xb4,%eax
f010a2ed:	8b 00                	mov    (%eax),%eax
}
f010a2ef:	c9                   	leave  
f010a2f0:	c3                   	ret    

f010a2f1 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010a2f1:	55                   	push   %ebp
f010a2f2:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010a2f4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a2f7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2fa:	89 d0                	mov    %edx,%eax
f010a2fc:	01 c0                	add    %eax,%eax
f010a2fe:	01 d0                	add    %edx,%eax
f010a300:	c1 e0 03             	shl    $0x3,%eax
f010a303:	01 c8                	add    %ecx,%eax
f010a305:	05 b0 00 00 00       	add    $0xb0,%eax
f010a30a:	8a 00                	mov    (%eax),%al
f010a30c:	0f b6 c0             	movzbl %al,%eax
}
f010a30f:	5d                   	pop    %ebp
f010a310:	c3                   	ret    

f010a311 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010a311:	55                   	push   %ebp
f010a312:	89 e5                	mov    %esp,%ebp
f010a314:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010a317:	83 ec 04             	sub    $0x4,%esp
f010a31a:	68 ab 58 12 f0       	push   $0xf01258ab
f010a31f:	68 6a 01 00 00       	push   $0x16a
f010a324:	68 8c 56 12 f0       	push   $0xf012568c
f010a329:	e8 0b 60 ff ff       	call   f0100339 <_panic>

f010a32e <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010a32e:	55                   	push   %ebp
f010a32f:	89 e5                	mov    %esp,%ebp
f010a331:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010a334:	83 ec 04             	sub    $0x4,%esp
f010a337:	68 ab 58 12 f0       	push   $0xf01258ab
f010a33c:	68 6f 01 00 00       	push   $0x16f
f010a341:	68 8c 56 12 f0       	push   $0xf012568c
f010a346:	e8 ee 5f ff ff       	call   f0100339 <_panic>

f010a34b <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010a34b:	55                   	push   %ebp
f010a34c:	89 e5                	mov    %esp,%ebp
f010a34e:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010a351:	83 ec 04             	sub    $0x4,%esp
f010a354:	68 bc 58 12 f0       	push   $0xf01258bc
f010a359:	6a 22                	push   $0x22
f010a35b:	68 ea 58 12 f0       	push   $0xf01258ea
f010a360:	e8 d4 5f ff ff       	call   f0100339 <_panic>

f010a365 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010a365:	55                   	push   %ebp
f010a366:	89 e5                	mov    %esp,%ebp
f010a368:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010a36b:	83 ec 04             	sub    $0x4,%esp
f010a36e:	68 08 59 12 f0       	push   $0xf0125908
f010a373:	6a 35                	push   $0x35
f010a375:	68 ea 58 12 f0       	push   $0xf01258ea
f010a37a:	e8 ba 5f ff ff       	call   f0100339 <_panic>

f010a37f <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010a37f:	55                   	push   %ebp
f010a380:	89 e5                	mov    %esp,%ebp
f010a382:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010a385:	83 ec 04             	sub    $0x4,%esp
f010a388:	68 38 59 12 f0       	push   $0xf0125938
f010a38d:	6a 45                	push   $0x45
f010a38f:	68 ea 58 12 f0       	push   $0xf01258ea
f010a394:	e8 a0 5f ff ff       	call   f0100339 <_panic>

f010a399 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010a399:	55                   	push   %ebp
f010a39a:	89 e5                	mov    %esp,%ebp
f010a39c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010a39f:	83 ec 04             	sub    $0x4,%esp
f010a3a2:	68 64 59 12 f0       	push   $0xf0125964
f010a3a7:	6a 53                	push   $0x53
f010a3a9:	68 ea 58 12 f0       	push   $0xf01258ea
f010a3ae:	e8 86 5f ff ff       	call   f0100339 <_panic>

f010a3b3 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010a3b3:	55                   	push   %ebp
f010a3b4:	89 e5                	mov    %esp,%ebp
f010a3b6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010a3b9:	83 ec 04             	sub    $0x4,%esp
f010a3bc:	68 94 59 12 f0       	push   $0xf0125994
f010a3c1:	6a 5d                	push   $0x5d
f010a3c3:	68 ea 58 12 f0       	push   $0xf01258ea
f010a3c8:	e8 6c 5f ff ff       	call   f0100339 <_panic>

f010a3cd <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010a3cd:	55                   	push   %ebp
f010a3ce:	89 e5                	mov    %esp,%ebp
f010a3d0:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010a3d3:	83 ec 04             	sub    $0x4,%esp
f010a3d6:	68 cc 59 12 f0       	push   $0xf01259cc
f010a3db:	6a 6a                	push   $0x6a
f010a3dd:	68 ea 58 12 f0       	push   $0xf01258ea
f010a3e2:	e8 52 5f ff ff       	call   f0100339 <_panic>

f010a3e7 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010a3e7:	55                   	push   %ebp
f010a3e8:	89 e5                	mov    %esp,%ebp
f010a3ea:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010a3ed:	e8 98 0e 00 00       	call   f010b28a <get_cpu_proc>
f010a3f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010a3f5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a3f9:	7e 61                	jle    f010a45c <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010a3fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3fe:	c1 e0 0c             	shl    $0xc,%eax
f010a401:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010a404:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a407:	8b 40 7c             	mov    0x7c(%eax),%eax
f010a40a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010a40d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a410:	8b 50 7c             	mov    0x7c(%eax),%edx
f010a413:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a416:	01 c2                	add    %eax,%edx
f010a418:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a41b:	8b 40 78             	mov    0x78(%eax),%eax
f010a41e:	39 c2                	cmp    %eax,%edx
f010a420:	77 09                	ja     f010a42b <sys_sbrk+0x44>
f010a422:	a1 6c b3 6b f0       	mov    0xf06bb36c,%eax
f010a427:	85 c0                	test   %eax,%eax
f010a429:	75 07                	jne    f010a432 <sys_sbrk+0x4b>
f010a42b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a430:	eb 3d                	jmp    f010a46f <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010a432:	83 ec 04             	sub    $0x4,%esp
f010a435:	ff 75 f0             	pushl  -0x10(%ebp)
f010a438:	ff 75 ec             	pushl  -0x14(%ebp)
f010a43b:	ff 75 f4             	pushl  -0xc(%ebp)
f010a43e:	e8 2e 00 00 00       	call   f010a471 <allocate_user_mem>
f010a443:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010a446:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a449:	8b 50 7c             	mov    0x7c(%eax),%edx
f010a44c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a44f:	01 c2                	add    %eax,%edx
f010a451:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a454:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010a457:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a45a:	eb 13                	jmp    f010a46f <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010a45c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a460:	75 08                	jne    f010a46a <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010a462:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a465:	8b 40 7c             	mov    0x7c(%eax),%eax
f010a468:	eb 05                	jmp    f010a46f <sys_sbrk+0x88>
	}

	return (void *)-1;
f010a46a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010a46f:	c9                   	leave  
f010a470:	c3                   	ret    

f010a471 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a471:	55                   	push   %ebp
f010a472:	89 e5                	mov    %esp,%ebp
f010a474:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010a477:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010a47e:	8b 55 10             	mov    0x10(%ebp),%edx
f010a481:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a484:	01 d0                	add    %edx,%eax
f010a486:	48                   	dec    %eax
f010a487:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a48a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a48d:	ba 00 00 00 00       	mov    $0x0,%edx
f010a492:	f7 75 f0             	divl   -0x10(%ebp)
f010a495:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a498:	29 d0                	sub    %edx,%eax
f010a49a:	c1 e8 0c             	shr    $0xc,%eax
f010a49d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010a4a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a4a7:	eb 78                	jmp    f010a521 <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010a4a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4ac:	c1 e0 0c             	shl    $0xc,%eax
f010a4af:	89 c2                	mov    %eax,%edx
f010a4b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a4b4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010a4b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4ba:	8b 40 64             	mov    0x64(%eax),%eax
f010a4bd:	83 ec 04             	sub    $0x4,%esp
f010a4c0:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010a4c3:	52                   	push   %edx
f010a4c4:	51                   	push   %ecx
f010a4c5:	50                   	push   %eax
f010a4c6:	e8 24 df ff ff       	call   f01083ef <get_page_table>
f010a4cb:	83 c4 10             	add    $0x10,%esp
f010a4ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010a4d1:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010a4d5:	75 23                	jne    f010a4fa <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010a4d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4da:	c1 e0 0c             	shl    $0xc,%eax
f010a4dd:	89 c2                	mov    %eax,%edx
f010a4df:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a4e2:	01 c2                	add    %eax,%edx
f010a4e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4e7:	8b 40 64             	mov    0x64(%eax),%eax
f010a4ea:	83 ec 08             	sub    $0x8,%esp
f010a4ed:	52                   	push   %edx
f010a4ee:	50                   	push   %eax
f010a4ef:	e8 51 e0 ff ff       	call   f0108545 <create_page_table>
f010a4f4:	83 c4 10             	add    $0x10,%esp
f010a4f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010a4fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4fd:	c1 e0 0c             	shl    $0xc,%eax
f010a500:	89 c2                	mov    %eax,%edx
f010a502:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a505:	01 c2                	add    %eax,%edx
f010a507:	8b 45 08             	mov    0x8(%ebp),%eax
f010a50a:	8b 40 64             	mov    0x64(%eax),%eax
f010a50d:	6a 00                	push   $0x0
f010a50f:	68 00 02 00 00       	push   $0x200
f010a514:	52                   	push   %edx
f010a515:	50                   	push   %eax
f010a516:	e8 af ef ff ff       	call   f01094ca <pt_set_page_permissions>
f010a51b:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010a51e:	ff 45 f4             	incl   -0xc(%ebp)
f010a521:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a524:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a527:	72 80                	jb     f010a4a9 <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010a529:	90                   	nop
f010a52a:	c9                   	leave  
f010a52b:	c3                   	ret    

f010a52c <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a52c:	55                   	push   %ebp
f010a52d:	89 e5                	mov    %esp,%ebp
f010a52f:	83 ec 28             	sub    $0x28,%esp

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010a532:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010a539:	8b 55 10             	mov    0x10(%ebp),%edx
f010a53c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a53f:	01 d0                	add    %edx,%eax
f010a541:	48                   	dec    %eax
f010a542:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a545:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a548:	ba 00 00 00 00       	mov    $0x0,%edx
f010a54d:	f7 75 f0             	divl   -0x10(%ebp)
f010a550:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a553:	29 d0                	sub    %edx,%eax
f010a555:	c1 e8 0c             	shr    $0xc,%eax
f010a558:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f010a55b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a562:	e9 86 00 00 00       	jmp    f010a5ed <free_user_mem+0xc1>
			pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010a567:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a56a:	c1 e0 0c             	shl    $0xc,%eax
f010a56d:	89 c2                	mov    %eax,%edx
f010a56f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a572:	01 c2                	add    %eax,%edx
f010a574:	8b 45 08             	mov    0x8(%ebp),%eax
f010a577:	8b 40 64             	mov    0x64(%eax),%eax
f010a57a:	68 00 02 00 00       	push   $0x200
f010a57f:	6a 00                	push   $0x0
f010a581:	52                   	push   %edx
f010a582:	50                   	push   %eax
f010a583:	e8 42 ef ff ff       	call   f01094ca <pt_set_page_permissions>
f010a588:	83 c4 10             	add    $0x10,%esp
			int ret = pf_read_env_page(e,(void*)((i*PAGE_SIZE)+virtual_address));
f010a58b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a58e:	c1 e0 0c             	shl    $0xc,%eax
f010a591:	89 c2                	mov    %eax,%edx
f010a593:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a596:	01 d0                	add    %edx,%eax
f010a598:	83 ec 08             	sub    $0x8,%esp
f010a59b:	50                   	push   %eax
f010a59c:	ff 75 08             	pushl  0x8(%ebp)
f010a59f:	e8 3d 9f ff ff       	call   f01044e1 <pf_read_env_page>
f010a5a4:	83 c4 10             	add    $0x10,%esp
f010a5a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
f010a5aa:	83 7d e4 f7          	cmpl   $0xfffffff7,-0x1c(%ebp)
f010a5ae:	75 1e                	jne    f010a5ce <free_user_mem+0xa2>
f010a5b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5b3:	c1 e0 0c             	shl    $0xc,%eax
f010a5b6:	89 c2                	mov    %eax,%edx
f010a5b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a5bb:	01 d0                	add    %edx,%eax
f010a5bd:	83 ec 08             	sub    $0x8,%esp
f010a5c0:	50                   	push   %eax
f010a5c1:	ff 75 08             	pushl  0x8(%ebp)
f010a5c4:	e8 a2 f1 ff ff       	call   f010976b <env_page_ws_invalidate>
f010a5c9:	83 c4 10             	add    $0x10,%esp
f010a5cc:	eb 1c                	jmp    f010a5ea <free_user_mem+0xbe>
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);
f010a5ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5d1:	c1 e0 0c             	shl    $0xc,%eax
f010a5d4:	89 c2                	mov    %eax,%edx
f010a5d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a5d9:	01 d0                	add    %edx,%eax
f010a5db:	83 ec 08             	sub    $0x8,%esp
f010a5de:	50                   	push   %eax
f010a5df:	ff 75 08             	pushl  0x8(%ebp)
f010a5e2:	e8 bd 9f ff ff       	call   f01045a4 <pf_remove_env_page>
f010a5e7:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
		for(int i = 0; i < no_of_pages; i++){
f010a5ea:	ff 45 f4             	incl   -0xc(%ebp)
f010a5ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5f0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a5f3:	0f 82 6e ff ff ff    	jb     f010a567 <free_user_mem+0x3b>
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);


		}
}
f010a5f9:	90                   	nop
f010a5fa:	c9                   	leave  
f010a5fb:	c3                   	ret    

f010a5fc <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a5fc:	55                   	push   %ebp
f010a5fd:	89 e5                	mov    %esp,%ebp
f010a5ff:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010a602:	83 ec 04             	sub    $0x4,%esp
f010a605:	68 04 5a 12 f0       	push   $0xf0125a04
f010a60a:	68 e0 00 00 00       	push   $0xe0
f010a60f:	68 ea 58 12 f0       	push   $0xf01258ea
f010a614:	e8 20 5d ff ff       	call   f0100339 <_panic>

f010a619 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010a619:	55                   	push   %ebp
f010a61a:	89 e5                	mov    %esp,%ebp
f010a61c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010a61f:	83 ec 04             	sub    $0x4,%esp
f010a622:	68 44 5a 12 f0       	push   $0xf0125a44
f010a627:	68 ea 00 00 00       	push   $0xea
f010a62c:	68 ea 58 12 f0       	push   $0xf01258ea
f010a631:	e8 03 5d ff ff       	call   f0100339 <_panic>

f010a636 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010a636:	55                   	push   %ebp
f010a637:	89 e5                	mov    %esp,%ebp
f010a639:	56                   	push   %esi
f010a63a:	53                   	push   %ebx
f010a63b:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010a63e:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010a645:	e9 b0 01 00 00       	jmp    f010a7fa <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010a64a:	8b 0d d0 27 69 f0    	mov    0xf06927d0,%ecx
f010a650:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a653:	89 d0                	mov    %edx,%eax
f010a655:	c1 e0 03             	shl    $0x3,%eax
f010a658:	01 d0                	add    %edx,%eax
f010a65a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a661:	01 d8                	add    %ebx,%eax
f010a663:	01 c0                	add    %eax,%eax
f010a665:	01 d0                	add    %edx,%eax
f010a667:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a66e:	01 d8                	add    %ebx,%eax
f010a670:	01 d0                	add    %edx,%eax
f010a672:	01 c8                	add    %ecx,%eax
f010a674:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010a67b:	8b 0d d0 27 69 f0    	mov    0xf06927d0,%ecx
f010a681:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a684:	89 d0                	mov    %edx,%eax
f010a686:	c1 e0 03             	shl    $0x3,%eax
f010a689:	01 d0                	add    %edx,%eax
f010a68b:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a692:	01 d8                	add    %ebx,%eax
f010a694:	01 c0                	add    %eax,%eax
f010a696:	01 d0                	add    %edx,%eax
f010a698:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a69f:	01 d8                	add    %ebx,%eax
f010a6a1:	01 d0                	add    %edx,%eax
f010a6a3:	01 c8                	add    %ecx,%eax
f010a6a5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010a6ac:	8b 0d d0 27 69 f0    	mov    0xf06927d0,%ecx
f010a6b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a6b5:	89 d0                	mov    %edx,%eax
f010a6b7:	c1 e0 03             	shl    $0x3,%eax
f010a6ba:	01 d0                	add    %edx,%eax
f010a6bc:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a6c3:	01 d8                	add    %ebx,%eax
f010a6c5:	01 c0                	add    %eax,%eax
f010a6c7:	01 d0                	add    %edx,%eax
f010a6c9:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a6d0:	01 d8                	add    %ebx,%eax
f010a6d2:	01 d0                	add    %edx,%eax
f010a6d4:	01 c8                	add    %ecx,%eax
f010a6d6:	85 c0                	test   %eax,%eax
f010a6d8:	75 14                	jne    f010a6ee <env_init+0xb8>
f010a6da:	83 ec 04             	sub    $0x4,%esp
f010a6dd:	68 70 5a 12 f0       	push   $0xf0125a70
f010a6e2:	6a 65                	push   $0x65
f010a6e4:	68 93 5a 12 f0       	push   $0xf0125a93
f010a6e9:	e8 4b 5c ff ff       	call   f0100339 <_panic>
f010a6ee:	8b 0d d0 27 69 f0    	mov    0xf06927d0,%ecx
f010a6f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a6f7:	89 d0                	mov    %edx,%eax
f010a6f9:	c1 e0 03             	shl    $0x3,%eax
f010a6fc:	01 d0                	add    %edx,%eax
f010a6fe:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a705:	01 d8                	add    %ebx,%eax
f010a707:	01 c0                	add    %eax,%eax
f010a709:	01 d0                	add    %edx,%eax
f010a70b:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a712:	01 d8                	add    %ebx,%eax
f010a714:	01 d0                	add    %edx,%eax
f010a716:	01 c8                	add    %ecx,%eax
f010a718:	8b 15 d4 27 69 f0    	mov    0xf06927d4,%edx
f010a71e:	89 50 08             	mov    %edx,0x8(%eax)
f010a721:	8b 40 08             	mov    0x8(%eax),%eax
f010a724:	85 c0                	test   %eax,%eax
f010a726:	74 35                	je     f010a75d <env_init+0x127>
f010a728:	8b 0d d4 27 69 f0    	mov    0xf06927d4,%ecx
f010a72e:	8b 1d d0 27 69 f0    	mov    0xf06927d0,%ebx
f010a734:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a737:	89 d0                	mov    %edx,%eax
f010a739:	c1 e0 03             	shl    $0x3,%eax
f010a73c:	01 d0                	add    %edx,%eax
f010a73e:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010a745:	01 f0                	add    %esi,%eax
f010a747:	01 c0                	add    %eax,%eax
f010a749:	01 d0                	add    %edx,%eax
f010a74b:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010a752:	01 f0                	add    %esi,%eax
f010a754:	01 d0                	add    %edx,%eax
f010a756:	01 d8                	add    %ebx,%eax
f010a758:	89 41 0c             	mov    %eax,0xc(%ecx)
f010a75b:	eb 2f                	jmp    f010a78c <env_init+0x156>
f010a75d:	8b 0d d0 27 69 f0    	mov    0xf06927d0,%ecx
f010a763:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a766:	89 d0                	mov    %edx,%eax
f010a768:	c1 e0 03             	shl    $0x3,%eax
f010a76b:	01 d0                	add    %edx,%eax
f010a76d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a774:	01 d8                	add    %ebx,%eax
f010a776:	01 c0                	add    %eax,%eax
f010a778:	01 d0                	add    %edx,%eax
f010a77a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a781:	01 d8                	add    %ebx,%eax
f010a783:	01 d0                	add    %edx,%eax
f010a785:	01 c8                	add    %ecx,%eax
f010a787:	a3 d8 27 69 f0       	mov    %eax,0xf06927d8
f010a78c:	8b 0d d0 27 69 f0    	mov    0xf06927d0,%ecx
f010a792:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a795:	89 d0                	mov    %edx,%eax
f010a797:	c1 e0 03             	shl    $0x3,%eax
f010a79a:	01 d0                	add    %edx,%eax
f010a79c:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7a3:	01 d8                	add    %ebx,%eax
f010a7a5:	01 c0                	add    %eax,%eax
f010a7a7:	01 d0                	add    %edx,%eax
f010a7a9:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7b0:	01 d8                	add    %ebx,%eax
f010a7b2:	01 d0                	add    %edx,%eax
f010a7b4:	01 c8                	add    %ecx,%eax
f010a7b6:	a3 d4 27 69 f0       	mov    %eax,0xf06927d4
f010a7bb:	8b 0d d0 27 69 f0    	mov    0xf06927d0,%ecx
f010a7c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7c4:	89 d0                	mov    %edx,%eax
f010a7c6:	c1 e0 03             	shl    $0x3,%eax
f010a7c9:	01 d0                	add    %edx,%eax
f010a7cb:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7d2:	01 d8                	add    %ebx,%eax
f010a7d4:	01 c0                	add    %eax,%eax
f010a7d6:	01 d0                	add    %edx,%eax
f010a7d8:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7df:	01 d8                	add    %ebx,%eax
f010a7e1:	01 d0                	add    %edx,%eax
f010a7e3:	01 c8                	add    %ecx,%eax
f010a7e5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010a7ec:	a1 e0 27 69 f0       	mov    0xf06927e0,%eax
f010a7f1:	40                   	inc    %eax
f010a7f2:	a3 e0 27 69 f0       	mov    %eax,0xf06927e0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010a7f7:	ff 4d f4             	decl   -0xc(%ebp)
f010a7fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a7fe:	0f 89 46 fe ff ff    	jns    f010a64a <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010a804:	90                   	nop
f010a805:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a808:	5b                   	pop    %ebx
f010a809:	5e                   	pop    %esi
f010a80a:	5d                   	pop    %ebp
f010a80b:	c3                   	ret    

f010a80c <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010a80c:	55                   	push   %ebp
f010a80d:	89 e5                	mov    %esp,%ebp
f010a80f:	57                   	push   %edi
f010a810:	56                   	push   %esi
f010a811:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010a817:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010a81e:	83 ec 0c             	sub    $0xc,%esp
f010a821:	ff 75 08             	pushl  0x8(%ebp)
f010a824:	e8 b8 1e 00 00       	call   f010c6e1 <get_user_program_info>
f010a829:	83 c4 10             	add    $0x10,%esp
f010a82c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010a82f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010a833:	75 0a                	jne    f010a83f <env_create+0x33>
	{
		return NULL;
f010a835:	b8 00 00 00 00       	mov    $0x0,%eax
f010a83a:	e9 aa 09 00 00       	jmp    f010b1e9 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010a83f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a842:	8b 40 08             	mov    0x8(%eax),%eax
f010a845:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010a848:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010a84f:	00 00 00 
	if(allocate_environment(&e) < 0)
f010a852:	83 ec 0c             	sub    $0xc,%esp
f010a855:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010a85b:	50                   	push   %eax
f010a85c:	e8 96 0e 00 00       	call   f010b6f7 <allocate_environment>
f010a861:	83 c4 10             	add    $0x10,%esp
f010a864:	85 c0                	test   %eax,%eax
f010a866:	79 0a                	jns    f010a872 <env_create+0x66>
	{
		return NULL;
f010a868:	b8 00 00 00 00       	mov    $0x0,%eax
f010a86d:	e9 77 09 00 00       	jmp    f010b1e9 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010a872:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a875:	8b 00                	mov    (%eax),%eax
f010a877:	83 ec 0c             	sub    $0xc,%esp
f010a87a:	50                   	push   %eax
f010a87b:	e8 59 4c 01 00       	call   f011f4d9 <strlen>
f010a880:	83 c4 10             	add    $0x10,%esp
f010a883:	83 f8 3f             	cmp    $0x3f,%eax
f010a886:	7f 1d                	jg     f010a8a5 <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010a888:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a88b:	8b 00                	mov    (%eax),%eax
f010a88d:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a893:	83 c2 20             	add    $0x20,%edx
f010a896:	83 ec 08             	sub    $0x8,%esp
f010a899:	50                   	push   %eax
f010a89a:	52                   	push   %edx
f010a89b:	e8 88 4c 01 00       	call   f011f528 <strcpy>
f010a8a0:	83 c4 10             	add    $0x10,%esp
f010a8a3:	eb 1d                	jmp    f010a8c2 <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010a8a5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a8a8:	8b 00                	mov    (%eax),%eax
f010a8aa:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a8b0:	83 c2 20             	add    $0x20,%edx
f010a8b3:	83 ec 04             	sub    $0x4,%esp
f010a8b6:	6a 3f                	push   $0x3f
f010a8b8:	50                   	push   %eax
f010a8b9:	52                   	push   %edx
f010a8ba:	e8 97 4c 01 00       	call   f011f556 <strncpy>
f010a8bf:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010a8c2:	e8 fc 13 00 00       	call   f010bcc3 <create_user_directory>
f010a8c7:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010a8ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a8cd:	83 ec 0c             	sub    $0xc,%esp
f010a8d0:	50                   	push   %eax
f010a8d1:	e8 5b eb ff ff       	call   f0109431 <kheap_physical_address>
f010a8d6:	83 c4 10             	add    $0x10,%esp
f010a8d9:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010a8dc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a8e2:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a8e5:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a8eb:	83 ec 0c             	sub    $0xc,%esp
f010a8ee:	6a 02                	push   $0x2
f010a8f0:	e8 d0 45 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f010a8f5:	83 c4 10             	add    $0x10,%esp
f010a8f8:	85 c0                	test   %eax,%eax
f010a8fa:	74 21                	je     f010a91d <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010a8fc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a902:	8b 55 10             	mov    0x10(%ebp),%edx
f010a905:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010a90b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a911:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a914:	2b 55 10             	sub    0x10(%ebp),%edx
f010a917:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010a91d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010a921:	75 12                	jne    f010a935 <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010a923:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a929:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010a930:	00 00 00 
f010a933:	eb 0f                	jmp    f010a944 <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010a935:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a93b:	8b 55 14             	mov    0x14(%ebp),%edx
f010a93e:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010a944:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a94a:	83 ec 04             	sub    $0x4,%esp
f010a94d:	ff 75 bc             	pushl  -0x44(%ebp)
f010a950:	ff 75 c0             	pushl  -0x40(%ebp)
f010a953:	50                   	push   %eax
f010a954:	e8 c8 14 00 00       	call   f010be21 <initialize_environment>
f010a959:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010a95c:	e8 6e c8 ff ff       	call   f01071cf <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010a961:	0f 20 d8             	mov    %cr3,%eax
f010a964:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010a967:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010a96a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010a96d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a973:	8b 40 68             	mov    0x68(%eax),%eax
f010a976:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010a97c:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010a982:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010a985:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010a98c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010a993:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a999:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a99f:	48                   	dec    %eax
f010a9a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010a9a3:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010a9aa:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010a9ad:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010a9b3:	83 ec 08             	sub    $0x8,%esp
f010a9b6:	ff 75 c8             	pushl  -0x38(%ebp)
f010a9b9:	50                   	push   %eax
f010a9ba:	e8 34 1a 00 00       	call   f010c3f3 <PROGRAM_SEGMENT_FIRST>
f010a9bf:	83 c4 0c             	add    $0xc,%esp
f010a9c2:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010a9c8:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010a9ce:	b9 05 00 00 00       	mov    $0x5,%ecx
f010a9d3:	89 c7                	mov    %eax,%edi
f010a9d5:	89 d6                	mov    %edx,%esi
f010a9d7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010a9d9:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010a9df:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a9e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a9e5:	8b 40 10             	mov    0x10(%eax),%eax
f010a9e8:	83 f8 ff             	cmp    $0xffffffff,%eax
f010a9eb:	75 07                	jne    f010a9f4 <env_create+0x1e8>
f010a9ed:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010a9f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a9f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a9fa:	e9 fa 02 00 00       	jmp    f010acf9 <env_create+0x4ed>
		{
			segment_counter++;
f010a9ff:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010aa02:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010aa09:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010aa0c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa12:	83 ec 0c             	sub    $0xc,%esp
f010aa15:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010aa1b:	52                   	push   %edx
f010aa1c:	ff 75 ec             	pushl  -0x14(%ebp)
f010aa1f:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010aa25:	52                   	push   %edx
f010aa26:	ff 75 f4             	pushl  -0xc(%ebp)
f010aa29:	50                   	push   %eax
f010aa2a:	e8 86 0d 00 00       	call   f010b7b5 <program_segment_alloc_map_copy_workingset>
f010aa2f:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010aa32:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010aa38:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010aa3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa3e:	8b 00                	mov    (%eax),%eax
f010aa40:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010aa43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa46:	8b 40 0c             	mov    0xc(%eax),%eax
f010aa49:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010aa4c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010aa4f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010aa52:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010aa55:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010aa5a:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010aa5d:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010aa64:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010aa67:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010aa6a:	01 d0                	add    %edx,%eax
f010aa6c:	48                   	dec    %eax
f010aa6d:	89 45 98             	mov    %eax,-0x68(%ebp)
f010aa70:	8b 45 98             	mov    -0x68(%ebp),%eax
f010aa73:	ba 00 00 00 00       	mov    $0x0,%edx
f010aa78:	f7 75 9c             	divl   -0x64(%ebp)
f010aa7b:	8b 45 98             	mov    -0x68(%ebp),%eax
f010aa7e:	29 d0                	sub    %edx,%eax
f010aa80:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010aa83:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010aa86:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010aa89:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010aa8c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010aa8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010aa92:	8b 15 0c ba 6b f0    	mov    0xf06bba0c,%edx
f010aa98:	8b 45 90             	mov    -0x70(%ebp),%eax
f010aa9b:	01 d0                	add    %edx,%eax
f010aa9d:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010aaa0:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010aaa4:	74 73                	je     f010ab19 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010aaa6:	a1 0c ba 6b f0       	mov    0xf06bba0c,%eax
f010aaab:	83 ec 04             	sub    $0x4,%esp
f010aaae:	68 00 10 00 00       	push   $0x1000
f010aab3:	6a 00                	push   $0x0
f010aab5:	50                   	push   %eax
f010aab6:	e8 0c 4c 01 00       	call   f011f6c7 <memset>
f010aabb:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010aabe:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010aac1:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010aac4:	eb 13                	jmp    f010aad9 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010aac6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010aac9:	8a 10                	mov    (%eax),%dl
f010aacb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010aace:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010aad0:	ff 45 dc             	incl   -0x24(%ebp)
f010aad3:	ff 45 e4             	incl   -0x1c(%ebp)
f010aad6:	ff 45 e0             	incl   -0x20(%ebp)
f010aad9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010aadc:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010aadf:	72 e5                	jb     f010aac6 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010aae1:	8b 15 0c ba 6b f0    	mov    0xf06bba0c,%edx
f010aae7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aaed:	83 ec 04             	sub    $0x4,%esp
f010aaf0:	52                   	push   %edx
f010aaf1:	ff 75 a0             	pushl  -0x60(%ebp)
f010aaf4:	50                   	push   %eax
f010aaf5:	e8 37 97 ff ff       	call   f0104231 <pf_add_env_page>
f010aafa:	83 c4 10             	add    $0x10,%esp
f010aafd:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ab00:	75 17                	jne    f010ab19 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ab02:	83 ec 04             	sub    $0x4,%esp
f010ab05:	68 b0 5a 12 f0       	push   $0xf0125ab0
f010ab0a:	68 f5 00 00 00       	push   $0xf5
f010ab0f:	68 93 5a 12 f0       	push   $0xf0125a93
f010ab14:	e8 20 58 ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010ab19:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab1c:	8b 50 04             	mov    0x4(%eax),%edx
f010ab1f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ab22:	01 d0                	add    %edx,%eax
f010ab24:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010ab27:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010ab2a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ab2f:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010ab32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab35:	8b 50 04             	mov    0x4(%eax),%edx
f010ab38:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ab3b:	01 d0                	add    %edx,%eax
f010ab3d:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010ab40:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010ab43:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010ab46:	eb 43                	jmp    f010ab8b <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010ab48:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010ab4b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab51:	83 ec 04             	sub    $0x4,%esp
f010ab54:	ff 75 e4             	pushl  -0x1c(%ebp)
f010ab57:	52                   	push   %edx
f010ab58:	50                   	push   %eax
f010ab59:	e8 d3 96 ff ff       	call   f0104231 <pf_add_env_page>
f010ab5e:	83 c4 10             	add    $0x10,%esp
f010ab61:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ab64:	75 17                	jne    f010ab7d <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ab66:	83 ec 04             	sub    $0x4,%esp
f010ab69:	68 b0 5a 12 f0       	push   $0xf0125ab0
f010ab6e:	68 02 01 00 00       	push   $0x102
f010ab73:	68 93 5a 12 f0       	push   $0xf0125a93
f010ab78:	e8 bc 57 ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010ab7d:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010ab84:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010ab8b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ab8e:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010ab91:	72 b5                	jb     f010ab48 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010ab93:	a1 0c ba 6b f0       	mov    0xf06bba0c,%eax
f010ab98:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010ab9b:	83 ec 04             	sub    $0x4,%esp
f010ab9e:	68 00 10 00 00       	push   $0x1000
f010aba3:	6a 00                	push   $0x0
f010aba5:	ff 75 e0             	pushl  -0x20(%ebp)
f010aba8:	e8 1a 4b 01 00       	call   f011f6c7 <memset>
f010abad:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010abb0:	8b 45 88             	mov    -0x78(%ebp),%eax
f010abb3:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010abb6:	eb 13                	jmp    f010abcb <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010abb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010abbb:	8a 10                	mov    (%eax),%dl
f010abbd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010abc0:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010abc2:	ff 45 dc             	incl   -0x24(%ebp)
f010abc5:	ff 45 e4             	incl   -0x1c(%ebp)
f010abc8:	ff 45 e0             	incl   -0x20(%ebp)
f010abcb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010abce:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010abd1:	72 e5                	jb     f010abb8 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010abd3:	8b 15 0c ba 6b f0    	mov    0xf06bba0c,%edx
f010abd9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010abdf:	83 ec 04             	sub    $0x4,%esp
f010abe2:	52                   	push   %edx
f010abe3:	ff 75 88             	pushl  -0x78(%ebp)
f010abe6:	50                   	push   %eax
f010abe7:	e8 45 96 ff ff       	call   f0104231 <pf_add_env_page>
f010abec:	83 c4 10             	add    $0x10,%esp
f010abef:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010abf2:	75 17                	jne    f010ac0b <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010abf4:	83 ec 04             	sub    $0x4,%esp
f010abf7:	68 b0 5a 12 f0       	push   $0xf0125ab0
f010abfc:	68 11 01 00 00       	push   $0x111
f010ac01:	68 93 5a 12 f0       	push   $0xf0125a93
f010ac06:	e8 2e 57 ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010ac0b:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010ac12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac15:	8b 50 04             	mov    0x4(%eax),%edx
f010ac18:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ac1b:	01 c2                	add    %eax,%edx
f010ac1d:	8b 45 80             	mov    -0x80(%ebp),%eax
f010ac20:	01 d0                	add    %edx,%eax
f010ac22:	48                   	dec    %eax
f010ac23:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010ac29:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010ac2f:	ba 00 00 00 00       	mov    $0x0,%edx
f010ac34:	f7 75 80             	divl   -0x80(%ebp)
f010ac37:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010ac3d:	29 d0                	sub    %edx,%eax
f010ac3f:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010ac42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac45:	8b 50 08             	mov    0x8(%eax),%edx
f010ac48:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ac4b:	01 d0                	add    %edx,%eax
f010ac4d:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010ac50:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010ac56:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010ac5d:	eb 41                	jmp    f010aca0 <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010ac5f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ac65:	83 ec 04             	sub    $0x4,%esp
f010ac68:	6a 01                	push   $0x1
f010ac6a:	ff 75 d8             	pushl  -0x28(%ebp)
f010ac6d:	50                   	push   %eax
f010ac6e:	e8 8d 94 ff ff       	call   f0104100 <pf_add_empty_env_page>
f010ac73:	83 c4 10             	add    $0x10,%esp
f010ac76:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ac79:	75 17                	jne    f010ac92 <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ac7b:	83 ec 04             	sub    $0x4,%esp
f010ac7e:	68 b0 5a 12 f0       	push   $0xf0125ab0
f010ac83:	68 1e 01 00 00       	push   $0x11e
f010ac88:	68 93 5a 12 f0       	push   $0xf0125a93
f010ac8d:	e8 a7 56 ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010ac92:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010ac99:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010aca0:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010aca7:	10 00 00 
f010acaa:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010acb0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010acb6:	01 d0                	add    %edx,%eax
f010acb8:	48                   	dec    %eax
f010acb9:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010acbf:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010acc5:	ba 00 00 00 00       	mov    $0x0,%edx
f010acca:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010acd0:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010acd6:	29 d0                	sub    %edx,%eax
f010acd8:	89 c2                	mov    %eax,%edx
f010acda:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010acdd:	39 c2                	cmp    %eax,%edx
f010acdf:	0f 87 7a ff ff ff    	ja     f010ac5f <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010ace5:	83 ec 08             	sub    $0x8,%esp
f010ace8:	ff 75 c8             	pushl  -0x38(%ebp)
f010aceb:	ff 75 f4             	pushl  -0xc(%ebp)
f010acee:	e8 f5 15 00 00       	call   f010c2e8 <PROGRAM_SEGMENT_NEXT>
f010acf3:	83 c4 10             	add    $0x10,%esp
f010acf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010acf9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010acfd:	0f 85 fc fc ff ff    	jne    f010a9ff <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010ad03:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ad09:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010ad0f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010ad12:	eb 77                	jmp    f010ad8b <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010ad14:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ad17:	8b 00                	mov    (%eax),%eax
f010ad19:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010ad1f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ad25:	8b 40 64             	mov    0x64(%eax),%eax
f010ad28:	83 ec 04             	sub    $0x4,%esp
f010ad2b:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010ad31:	52                   	push   %edx
f010ad32:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010ad38:	50                   	push   %eax
f010ad39:	e8 b1 d6 ff ff       	call   f01083ef <get_page_table>
f010ad3e:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010ad41:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010ad47:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010ad4d:	c1 ea 0c             	shr    $0xc,%edx
f010ad50:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010ad56:	c1 e2 02             	shl    $0x2,%edx
f010ad59:	01 d0                	add    %edx,%eax
f010ad5b:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010ad61:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010ad67:	c1 e9 0c             	shr    $0xc,%ecx
f010ad6a:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010ad70:	c1 e1 02             	shl    $0x2,%ecx
f010ad73:	01 ca                	add    %ecx,%edx
f010ad75:	8b 12                	mov    (%edx),%edx
f010ad77:	83 e2 bf             	and    $0xffffffbf,%edx
f010ad7a:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010ad7c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ad82:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010ad88:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010ad8b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ad91:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010ad95:	74 08                	je     f010ad9f <env_create+0x593>
f010ad97:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ad9a:	8b 52 10             	mov    0x10(%edx),%edx
f010ad9d:	eb 05                	jmp    f010ada4 <env_create+0x598>
f010ad9f:	ba 00 00 00 00       	mov    $0x0,%edx
f010ada4:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010adaa:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010adb0:	85 c0                	test   %eax,%eax
f010adb2:	0f 85 5c ff ff ff    	jne    f010ad14 <env_create+0x508>
f010adb8:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010adbc:	0f 85 52 ff ff ff    	jne    f010ad14 <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010adc2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010adc5:	8b 50 08             	mov    0x8(%eax),%edx
f010adc8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010adce:	83 ec 08             	sub    $0x8,%esp
f010add1:	52                   	push   %edx
f010add2:	50                   	push   %eax
f010add3:	e8 d0 14 00 00       	call   f010c2a8 <set_environment_entry_point>
f010add8:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010addb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ade1:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010ade8:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010adef:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010adf2:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010adf9:	e9 42 03 00 00       	jmp    f010b140 <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010adfe:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010ae05:	00 00 00 
			allocate_frame(&pp);
f010ae08:	83 ec 0c             	sub    $0xc,%esp
f010ae0b:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010ae11:	50                   	push   %eax
f010ae12:	e8 9b d3 ff ff       	call   f01081b2 <allocate_frame>
f010ae17:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010ae1a:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010ae20:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae26:	8b 40 64             	mov    0x64(%eax),%eax
f010ae29:	6a 06                	push   $0x6
f010ae2b:	ff 75 d0             	pushl  -0x30(%ebp)
f010ae2e:	52                   	push   %edx
f010ae2f:	50                   	push   %eax
f010ae30:	e8 4e da ff ff       	call   f0108883 <loadtime_map_frame>
f010ae35:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010ae38:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ae3b:	83 ec 04             	sub    $0x4,%esp
f010ae3e:	68 00 10 00 00       	push   $0x1000
f010ae43:	6a 00                	push   $0x0
f010ae45:	50                   	push   %eax
f010ae46:	e8 7c 48 01 00       	call   f011f6c7 <memset>
f010ae4b:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010ae4e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae54:	83 ec 08             	sub    $0x8,%esp
f010ae57:	ff 75 d0             	pushl  -0x30(%ebp)
f010ae5a:	50                   	push   %eax
f010ae5b:	e8 a0 e8 ff ff       	call   f0109700 <env_page_ws_list_create_element>
f010ae60:	83 c4 10             	add    $0x10,%esp
f010ae63:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010ae66:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010ae6a:	75 17                	jne    f010ae83 <env_create+0x677>
f010ae6c:	83 ec 04             	sub    $0x4,%esp
f010ae6f:	68 f8 5a 12 f0       	push   $0xf0125af8
f010ae74:	68 5d 01 00 00       	push   $0x15d
f010ae79:	68 93 5a 12 f0       	push   $0xf0125a93
f010ae7e:	e8 b6 54 ff ff       	call   f0100339 <_panic>
f010ae83:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae89:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010ae8f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ae92:	89 50 14             	mov    %edx,0x14(%eax)
f010ae95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ae98:	8b 40 14             	mov    0x14(%eax),%eax
f010ae9b:	85 c0                	test   %eax,%eax
f010ae9d:	74 14                	je     f010aeb3 <env_create+0x6a7>
f010ae9f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aea5:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010aeab:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aeae:	89 50 10             	mov    %edx,0x10(%eax)
f010aeb1:	eb 0f                	jmp    f010aec2 <env_create+0x6b6>
f010aeb3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aeb9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aebc:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010aec2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aec8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aecb:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010aed1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aed4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010aedb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aee1:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010aee7:	42                   	inc    %edx
f010aee8:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010aeee:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aef4:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010aefa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010af00:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010af06:	39 c2                	cmp    %eax,%edx
f010af08:	75 1a                	jne    f010af24 <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010af0a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010af10:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010af16:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010af1c:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010af22:	eb 10                	jmp    f010af34 <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010af24:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010af2a:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010af31:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010af34:	83 ec 0c             	sub    $0xc,%esp
f010af37:	6a 02                	push   $0x2
f010af39:	e8 87 3f 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f010af3e:	83 c4 10             	add    $0x10,%esp
f010af41:	85 c0                	test   %eax,%eax
f010af43:	0f 84 d3 01 00 00    	je     f010b11c <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010af49:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010af4d:	75 17                	jne    f010af66 <env_create+0x75a>
f010af4f:	83 ec 04             	sub    $0x4,%esp
f010af52:	68 1b 5b 12 f0       	push   $0xf0125b1b
f010af57:	68 6a 01 00 00       	push   $0x16a
f010af5c:	68 93 5a 12 f0       	push   $0xf0125a93
f010af61:	e8 d3 53 ff ff       	call   f0100339 <_panic>
f010af66:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010af69:	8b 40 10             	mov    0x10(%eax),%eax
f010af6c:	85 c0                	test   %eax,%eax
f010af6e:	74 11                	je     f010af81 <env_create+0x775>
f010af70:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010af73:	8b 40 10             	mov    0x10(%eax),%eax
f010af76:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010af79:	8b 52 14             	mov    0x14(%edx),%edx
f010af7c:	89 50 14             	mov    %edx,0x14(%eax)
f010af7f:	eb 12                	jmp    f010af93 <env_create+0x787>
f010af81:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010af87:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010af8a:	8b 52 14             	mov    0x14(%edx),%edx
f010af8d:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010af93:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010af96:	8b 40 14             	mov    0x14(%eax),%eax
f010af99:	85 c0                	test   %eax,%eax
f010af9b:	74 11                	je     f010afae <env_create+0x7a2>
f010af9d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010afa0:	8b 40 14             	mov    0x14(%eax),%eax
f010afa3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010afa6:	8b 52 10             	mov    0x10(%edx),%edx
f010afa9:	89 50 10             	mov    %edx,0x10(%eax)
f010afac:	eb 12                	jmp    f010afc0 <env_create+0x7b4>
f010afae:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afb4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010afb7:	8b 52 10             	mov    0x10(%edx),%edx
f010afba:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010afc0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010afc3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010afca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010afcd:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010afd4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afda:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010afe0:	4a                   	dec    %edx
f010afe1:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010afe7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afed:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010aff3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aff9:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010afff:	39 c2                	cmp    %eax,%edx
f010b001:	0f 83 8d 00 00 00    	jae    f010b094 <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b007:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b00b:	75 17                	jne    f010b024 <env_create+0x818>
f010b00d:	83 ec 04             	sub    $0x4,%esp
f010b010:	68 70 5a 12 f0       	push   $0xf0125a70
f010b015:	68 6f 01 00 00       	push   $0x16f
f010b01a:	68 93 5a 12 f0       	push   $0xf0125a93
f010b01f:	e8 15 53 ff ff       	call   f0100339 <_panic>
f010b024:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b02a:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b030:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b033:	89 50 10             	mov    %edx,0x10(%eax)
f010b036:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b039:	8b 40 10             	mov    0x10(%eax),%eax
f010b03c:	85 c0                	test   %eax,%eax
f010b03e:	74 14                	je     f010b054 <env_create+0x848>
f010b040:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b046:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b04c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b04f:	89 50 14             	mov    %edx,0x14(%eax)
f010b052:	eb 0f                	jmp    f010b063 <env_create+0x857>
f010b054:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b05a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b05d:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b063:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b069:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b06c:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b072:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b075:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b07c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b082:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b088:	42                   	inc    %edx
f010b089:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b08f:	e9 88 00 00 00       	jmp    f010b11c <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b094:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b098:	75 17                	jne    f010b0b1 <env_create+0x8a5>
f010b09a:	83 ec 04             	sub    $0x4,%esp
f010b09d:	68 70 5a 12 f0       	push   $0xf0125a70
f010b0a2:	68 73 01 00 00       	push   $0x173
f010b0a7:	68 93 5a 12 f0       	push   $0xf0125a93
f010b0ac:	e8 88 52 ff ff       	call   f0100339 <_panic>
f010b0b1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0b7:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010b0bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b0c0:	89 50 10             	mov    %edx,0x10(%eax)
f010b0c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b0c6:	8b 40 10             	mov    0x10(%eax),%eax
f010b0c9:	85 c0                	test   %eax,%eax
f010b0cb:	74 14                	je     f010b0e1 <env_create+0x8d5>
f010b0cd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0d3:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b0d9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b0dc:	89 50 14             	mov    %edx,0x14(%eax)
f010b0df:	eb 0f                	jmp    f010b0f0 <env_create+0x8e4>
f010b0e1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b0ea:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b0f0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0f6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b0f9:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010b0ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b102:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b109:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b10f:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010b115:	42                   	inc    %edx
f010b116:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b11c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b122:	83 ec 04             	sub    $0x4,%esp
f010b125:	6a 01                	push   $0x1
f010b127:	ff 75 d0             	pushl  -0x30(%ebp)
f010b12a:	50                   	push   %eax
f010b12b:	e8 d0 8f ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b130:	83 c4 10             	add    $0x10,%esp
f010b133:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b139:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010b140:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b143:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010b149:	0f 83 af fc ff ff    	jae    f010adfe <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b14f:	83 ec 0c             	sub    $0xc,%esp
f010b152:	6a 02                	push   $0x2
f010b154:	e8 6c 3d 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f010b159:	83 c4 10             	add    $0x10,%esp
f010b15c:	85 c0                	test   %eax,%eax
f010b15e:	74 72                	je     f010b1d2 <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010b160:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b167:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b16d:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b173:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b176:	eb 2b                	jmp    f010b1a3 <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b178:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b17b:	8b 10                	mov    (%eax),%edx
f010b17d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b183:	8b 40 64             	mov    0x64(%eax),%eax
f010b186:	6a 01                	push   $0x1
f010b188:	6a 00                	push   $0x0
f010b18a:	52                   	push   %edx
f010b18b:	50                   	push   %eax
f010b18c:	e8 39 e3 ff ff       	call   f01094ca <pt_set_page_permissions>
f010b191:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b194:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b19a:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b1a0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b1a3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1a9:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b1ad:	74 08                	je     f010b1b7 <env_create+0x9ab>
f010b1af:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b1b2:	8b 52 10             	mov    0x10(%edx),%edx
f010b1b5:	eb 05                	jmp    f010b1bc <env_create+0x9b0>
f010b1b7:	ba 00 00 00 00       	mov    $0x0,%edx
f010b1bc:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b1c2:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b1c8:	85 c0                	test   %eax,%eax
f010b1ca:	75 ac                	jne    f010b178 <env_create+0x96c>
f010b1cc:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b1d0:	75 a6                	jne    f010b178 <env_create+0x96c>
f010b1d2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b1d5:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b1d8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b1db:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b1de:	e8 3e c0 ff ff       	call   f0107221 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010b1e3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010b1e9:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b1ec:	5e                   	pop    %esi
f010b1ed:	5f                   	pop    %edi
f010b1ee:	5d                   	pop    %ebp
f010b1ef:	c3                   	ret    

f010b1f0 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010b1f0:	55                   	push   %ebp
f010b1f1:	89 e5                	mov    %esp,%ebp
f010b1f3:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010b1f6:	83 ec 0c             	sub    $0xc,%esp
f010b1f9:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010b1fe:	e8 9c 43 00 00       	call   f010f59f <release_spinlock>
f010b203:	83 c4 10             	add    $0x10,%esp

	if (first)
f010b206:	a1 60 e9 17 f0       	mov    0xf017e960,%eax
f010b20b:	85 c0                	test   %eax,%eax
f010b20d:	74 30                	je     f010b23f <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010b20f:	e8 76 00 00 00       	call   f010b28a <get_cpu_proc>
f010b214:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010b217:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b21a:	8b 40 10             	mov    0x10(%eax),%eax
f010b21d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b220:	83 c2 20             	add    $0x20,%edx
f010b223:	83 ec 04             	sub    $0x4,%esp
f010b226:	50                   	push   %eax
f010b227:	52                   	push   %edx
f010b228:	68 39 5b 12 f0       	push   $0xf0125b39
f010b22d:	e8 59 5d ff ff       	call   f0100f8b <cprintf>
f010b232:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010b235:	c7 05 60 e9 17 f0 00 	movl   $0x0,0xf017e960
f010b23c:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010b23f:	90                   	nop
f010b240:	c9                   	leave  
f010b241:	c3                   	ret    

f010b242 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010b242:	55                   	push   %ebp
f010b243:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010b245:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010b246:	5d                   	pop    %ebp
f010b247:	c3                   	ret    

f010b248 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010b248:	55                   	push   %ebp
f010b249:	89 e5                	mov    %esp,%ebp
f010b24b:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010b24e:	e8 37 00 00 00       	call   f010b28a <get_cpu_proc>
f010b253:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010b256:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b25a:	75 19                	jne    f010b275 <env_exit+0x2d>
f010b25c:	68 4f 5b 12 f0       	push   $0xf0125b4f
f010b261:	68 5f 5b 12 f0       	push   $0xf0125b5f
f010b266:	68 ed 01 00 00       	push   $0x1ed
f010b26b:	68 93 5a 12 f0       	push   $0xf0125a93
f010b270:	e8 c4 50 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010b275:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b278:	8b 40 10             	mov    0x10(%eax),%eax
f010b27b:	83 ec 0c             	sub    $0xc,%esp
f010b27e:	50                   	push   %eax
f010b27f:	e8 a5 a5 ff ff       	call   f0105829 <sched_exit_env>
f010b284:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010b287:	90                   	nop
f010b288:	c9                   	leave  
f010b289:	c3                   	ret    

f010b28a <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010b28a:	55                   	push   %ebp
f010b28b:	89 e5                	mov    %esp,%ebp
f010b28d:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010b290:	e8 3a bf ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010b295:	e8 72 be ff ff       	call   f010710c <mycpu>
f010b29a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010b29d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b2a0:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b2a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010b2a9:	e8 73 bf ff ff       	call   f0107221 <popcli>
	return p;
f010b2ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010b2b1:	c9                   	leave  
f010b2b2:	c3                   	ret    

f010b2b3 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010b2b3:	55                   	push   %ebp
f010b2b4:	89 e5                	mov    %esp,%ebp
f010b2b6:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010b2b9:	e8 11 bf ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010b2be:	e8 49 be ff ff       	call   f010710c <mycpu>
f010b2c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010b2c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b2c9:	8b 55 08             	mov    0x8(%ebp),%edx
f010b2cc:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010b2d2:	e8 4a bf ff ff       	call   f0107221 <popcli>
}
f010b2d7:	90                   	nop
f010b2d8:	c9                   	leave  
f010b2d9:	c3                   	ret    

f010b2da <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010b2da:	55                   	push   %ebp
f010b2db:	89 e5                	mov    %esp,%ebp
f010b2dd:	53                   	push   %ebx
f010b2de:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010b2e1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b2e5:	75 16                	jne    f010b2fd <envid2env+0x23>
		*env_store = get_cpu_proc();
f010b2e7:	e8 9e ff ff ff       	call   f010b28a <get_cpu_proc>
f010b2ec:	89 c2                	mov    %eax,%edx
f010b2ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b2f1:	89 10                	mov    %edx,(%eax)
		return 0;
f010b2f3:	b8 00 00 00 00       	mov    $0x0,%eax
f010b2f8:	e9 aa 00 00 00       	jmp    f010b3a7 <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010b2fd:	8b 1d d0 27 69 f0    	mov    0xf06927d0,%ebx
f010b303:	83 ec 0c             	sub    $0xc,%esp
f010b306:	68 ca 02 00 00       	push   $0x2ca
f010b30b:	e8 27 27 01 00       	call   f011da37 <nearest_pow2_ceil>
f010b310:	83 c4 10             	add    $0x10,%esp
f010b313:	8d 50 ff             	lea    -0x1(%eax),%edx
f010b316:	8b 45 08             	mov    0x8(%ebp),%eax
f010b319:	21 c2                	and    %eax,%edx
f010b31b:	89 d0                	mov    %edx,%eax
f010b31d:	c1 e0 03             	shl    $0x3,%eax
f010b320:	01 d0                	add    %edx,%eax
f010b322:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010b329:	01 c8                	add    %ecx,%eax
f010b32b:	01 c0                	add    %eax,%eax
f010b32d:	01 d0                	add    %edx,%eax
f010b32f:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010b336:	01 c8                	add    %ecx,%eax
f010b338:	01 d0                	add    %edx,%eax
f010b33a:	01 d8                	add    %ebx,%eax
f010b33c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010b33f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b342:	8b 40 18             	mov    0x18(%eax),%eax
f010b345:	85 c0                	test   %eax,%eax
f010b347:	74 0b                	je     f010b354 <envid2env+0x7a>
f010b349:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b34c:	8b 40 10             	mov    0x10(%eax),%eax
f010b34f:	3b 45 08             	cmp    0x8(%ebp),%eax
f010b352:	74 10                	je     f010b364 <envid2env+0x8a>
		*env_store = 0;
f010b354:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b357:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010b35d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010b362:	eb 43                	jmp    f010b3a7 <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010b364:	e8 21 ff ff ff       	call   f010b28a <get_cpu_proc>
f010b369:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010b36c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010b370:	74 28                	je     f010b39a <envid2env+0xc0>
f010b372:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b375:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010b378:	74 20                	je     f010b39a <envid2env+0xc0>
f010b37a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b37d:	8b 50 14             	mov    0x14(%eax),%edx
f010b380:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b383:	8b 40 10             	mov    0x10(%eax),%eax
f010b386:	39 c2                	cmp    %eax,%edx
f010b388:	74 10                	je     f010b39a <envid2env+0xc0>
		*env_store = 0;
f010b38a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b38d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010b393:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010b398:	eb 0d                	jmp    f010b3a7 <envid2env+0xcd>
	}

	*env_store = e;
f010b39a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b39d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b3a0:	89 10                	mov    %edx,(%eax)
	return 0;
f010b3a2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b3a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b3aa:	c9                   	leave  
f010b3ab:	c3                   	ret    

f010b3ac <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010b3ac:	55                   	push   %ebp
f010b3ad:	89 e5                	mov    %esp,%ebp
f010b3af:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010b3b2:	83 ec 0c             	sub    $0xc,%esp
f010b3b5:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010b3ba:	e8 59 41 00 00       	call   f010f518 <acquire_spinlock>
f010b3bf:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010b3c2:	e8 c3 fe ff ff       	call   f010b28a <get_cpu_proc>
f010b3c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010b3ca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b3ce:	75 19                	jne    f010b3e9 <yield+0x3d>
f010b3d0:	68 74 5b 12 f0       	push   $0xf0125b74
f010b3d5:	68 5f 5b 12 f0       	push   $0xf0125b5f
f010b3da:	68 4c 02 00 00       	push   $0x24c
f010b3df:	68 93 5a 12 f0       	push   $0xf0125a93
f010b3e4:	e8 50 4f ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010b3e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b3ec:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010b3f3:	e8 13 00 00 00       	call   f010b40b <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010b3f8:	83 ec 0c             	sub    $0xc,%esp
f010b3fb:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010b400:	e8 9a 41 00 00       	call   f010f59f <release_spinlock>
f010b405:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010b408:	90                   	nop
f010b409:	c9                   	leave  
f010b40a:	c3                   	ret    

f010b40b <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010b40b:	55                   	push   %ebp
f010b40c:	89 e5                	mov    %esp,%ebp
f010b40e:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010b411:	e8 74 fe ff ff       	call   f010b28a <get_cpu_proc>
f010b416:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010b419:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b41d:	75 19                	jne    f010b438 <sched+0x2d>
f010b41f:	68 74 5b 12 f0       	push   $0xf0125b74
f010b424:	68 5f 5b 12 f0       	push   $0xf0125b5f
f010b429:	68 60 02 00 00       	push   $0x260
f010b42e:	68 93 5a 12 f0       	push   $0xf0125a93
f010b433:	e8 01 4f ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010b438:	83 ec 0c             	sub    $0xc,%esp
f010b43b:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010b440:	e8 ec 42 00 00       	call   f010f731 <holding_spinlock>
f010b445:	83 c4 10             	add    $0x10,%esp
f010b448:	85 c0                	test   %eax,%eax
f010b44a:	75 17                	jne    f010b463 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010b44c:	83 ec 04             	sub    $0x4,%esp
f010b44f:	68 80 5b 12 f0       	push   $0xf0125b80
f010b454:	68 64 02 00 00       	push   $0x264
f010b459:	68 93 5a 12 f0       	push   $0xf0125a93
f010b45e:	e8 d6 4e ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010b463:	e8 a4 bc ff ff       	call   f010710c <mycpu>
f010b468:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010b46e:	83 f8 01             	cmp    $0x1,%eax
f010b471:	74 20                	je     f010b493 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010b473:	e8 94 bc ff ff       	call   f010710c <mycpu>
f010b478:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010b47e:	50                   	push   %eax
f010b47f:	68 c2 5b 12 f0       	push   $0xf0125bc2
f010b484:	68 67 02 00 00       	push   $0x267
f010b489:	68 93 5a 12 f0       	push   $0xf0125a93
f010b48e:	e8 a6 4e ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010b493:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b496:	8b 40 18             	mov    0x18(%eax),%eax
f010b499:	83 f8 02             	cmp    $0x2,%eax
f010b49c:	75 17                	jne    f010b4b5 <sched+0xaa>
		panic("sched a running process");
f010b49e:	83 ec 04             	sub    $0x4,%esp
f010b4a1:	68 d9 5b 12 f0       	push   $0xf0125bd9
f010b4a6:	68 6a 02 00 00       	push   $0x26a
f010b4ab:	68 93 5a 12 f0       	push   $0xf0125a93
f010b4b0:	e8 84 4e ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010b4b5:	9c                   	pushf  
f010b4b6:	58                   	pop    %eax
f010b4b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010b4ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010b4bd:	25 00 02 00 00       	and    $0x200,%eax
f010b4c2:	85 c0                	test   %eax,%eax
f010b4c4:	74 17                	je     f010b4dd <sched+0xd2>
		panic("sched is interruptible!");
f010b4c6:	83 ec 04             	sub    $0x4,%esp
f010b4c9:	68 f1 5b 12 f0       	push   $0xf0125bf1
f010b4ce:	68 6c 02 00 00       	push   $0x26c
f010b4d3:	68 93 5a 12 f0       	push   $0xf0125a93
f010b4d8:	e8 5c 4e ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010b4dd:	e8 2a bc ff ff       	call   f010710c <mycpu>
f010b4e2:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010b4e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010b4eb:	e8 1c bc ff ff       	call   f010710c <mycpu>
f010b4f0:	8b 40 04             	mov    0x4(%eax),%eax
f010b4f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4f6:	83 c2 04             	add    $0x4,%edx
f010b4f9:	83 ec 08             	sub    $0x8,%esp
f010b4fc:	50                   	push   %eax
f010b4fd:	52                   	push   %edx
f010b4fe:	e8 6e 96 ff ff       	call   f0104b71 <context_switch>
f010b503:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010b506:	e8 01 bc ff ff       	call   f010710c <mycpu>
f010b50b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b50e:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010b514:	90                   	nop
f010b515:	c9                   	leave  
f010b516:	c3                   	ret    

f010b517 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010b517:	55                   	push   %ebp
f010b518:	89 e5                	mov    %esp,%ebp
f010b51a:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010b51d:	a1 a4 ba 6b f0       	mov    0xf06bbaa4,%eax
f010b522:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b525:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010b528:	0f 22 d8             	mov    %eax,%cr3
}
f010b52b:	90                   	nop
f010b52c:	c9                   	leave  
f010b52d:	c3                   	ret    

f010b52e <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010b52e:	55                   	push   %ebp
f010b52f:	89 e5                	mov    %esp,%ebp
f010b531:	53                   	push   %ebx
f010b532:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010b535:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b539:	75 17                	jne    f010b552 <switchuvm+0x24>
		panic("switchuvm: no process");
f010b53b:	83 ec 04             	sub    $0x4,%esp
f010b53e:	68 09 5c 12 f0       	push   $0xf0125c09
f010b543:	68 81 02 00 00       	push   $0x281
f010b548:	68 93 5a 12 f0       	push   $0xf0125a93
f010b54d:	e8 e7 4d ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010b552:	8b 45 08             	mov    0x8(%ebp),%eax
f010b555:	8b 40 70             	mov    0x70(%eax),%eax
f010b558:	85 c0                	test   %eax,%eax
f010b55a:	75 17                	jne    f010b573 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010b55c:	83 ec 04             	sub    $0x4,%esp
f010b55f:	68 1f 5c 12 f0       	push   $0xf0125c1f
f010b564:	68 83 02 00 00       	push   $0x283
f010b569:	68 93 5a 12 f0       	push   $0xf0125a93
f010b56e:	e8 c6 4d ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010b573:	8b 45 08             	mov    0x8(%ebp),%eax
f010b576:	8b 40 64             	mov    0x64(%eax),%eax
f010b579:	85 c0                	test   %eax,%eax
f010b57b:	75 17                	jne    f010b594 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010b57d:	83 ec 04             	sub    $0x4,%esp
f010b580:	68 34 5c 12 f0       	push   $0xf0125c34
f010b585:	68 85 02 00 00       	push   $0x285
f010b58a:	68 93 5a 12 f0       	push   $0xf0125a93
f010b58f:	e8 a5 4d ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010b594:	e8 36 bc ff ff       	call   f01071cf <pushcli>
	struct cpu* c = mycpu();
f010b599:	e8 6e bb ff ff       	call   f010710c <mycpu>
f010b59e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010b5a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5a4:	8b 55 08             	mov    0x8(%ebp),%edx
f010b5a7:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010b5ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5b0:	83 c0 0c             	add    $0xc,%eax
f010b5b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b5b6:	83 c2 0c             	add    $0xc,%edx
f010b5b9:	c1 ea 10             	shr    $0x10,%edx
f010b5bc:	88 d3                	mov    %dl,%bl
f010b5be:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b5c1:	83 c2 0c             	add    $0xc,%edx
f010b5c4:	c1 ea 18             	shr    $0x18,%edx
f010b5c7:	88 d1                	mov    %dl,%cl
f010b5c9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b5cc:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010b5d3:	68 00 
f010b5d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b5d8:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010b5df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5e2:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010b5e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5eb:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b5f1:	83 e2 f0             	and    $0xfffffff0,%edx
f010b5f4:	83 ca 09             	or     $0x9,%edx
f010b5f7:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b5fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b600:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b606:	83 ca 10             	or     $0x10,%edx
f010b609:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b60f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b612:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b618:	83 e2 9f             	and    $0xffffff9f,%edx
f010b61b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b621:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b624:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b62a:	83 ca 80             	or     $0xffffff80,%edx
f010b62d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b633:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b636:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b63c:	83 e2 f0             	and    $0xfffffff0,%edx
f010b63f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b645:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b648:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b64e:	83 e2 ef             	and    $0xffffffef,%edx
f010b651:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b657:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b65a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b660:	83 e2 df             	and    $0xffffffdf,%edx
f010b663:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b669:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b66c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b672:	83 ca 40             	or     $0x40,%edx
f010b675:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b67b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b67e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b684:	83 e2 7f             	and    $0x7f,%edx
f010b687:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b68d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b690:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010b696:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b699:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b69f:	83 e2 ef             	and    $0xffffffef,%edx
f010b6a2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010b6a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6ab:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b6b1:	8b 40 70             	mov    0x70(%eax),%eax
f010b6b4:	05 00 80 00 00       	add    $0x8000,%eax
f010b6b9:	89 c2                	mov    %eax,%edx
f010b6bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6be:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010b6c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6c4:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010b6ca:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010b6d0:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010b6d4:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010b6d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6da:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b6e0:	8b 40 68             	mov    0x68(%eax),%eax
f010b6e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b6e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b6e9:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010b6ec:	e8 30 bb ff ff       	call   f0107221 <popcli>
}
f010b6f1:	90                   	nop
f010b6f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b6f5:	c9                   	leave  
f010b6f6:	c3                   	ret    

f010b6f7 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010b6f7:	55                   	push   %ebp
f010b6f8:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010b6fa:	8b 15 d4 27 69 f0    	mov    0xf06927d4,%edx
f010b700:	8b 45 08             	mov    0x8(%ebp),%eax
f010b703:	89 10                	mov    %edx,(%eax)
f010b705:	8b 45 08             	mov    0x8(%ebp),%eax
f010b708:	8b 00                	mov    (%eax),%eax
f010b70a:	85 c0                	test   %eax,%eax
f010b70c:	75 07                	jne    f010b715 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010b70e:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010b713:	eb 11                	jmp    f010b726 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010b715:	8b 45 08             	mov    0x8(%ebp),%eax
f010b718:	8b 00                	mov    (%eax),%eax
f010b71a:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010b721:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b726:	5d                   	pop    %ebp
f010b727:	c3                   	ret    

f010b728 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010b728:	55                   	push   %ebp
f010b729:	89 e5                	mov    %esp,%ebp
f010b72b:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010b72e:	83 ec 04             	sub    $0x4,%esp
f010b731:	68 bc 05 00 00       	push   $0x5bc
f010b736:	6a 00                	push   $0x0
f010b738:	ff 75 08             	pushl  0x8(%ebp)
f010b73b:	e8 87 3f 01 00       	call   f011f6c7 <memset>
f010b740:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010b743:	8b 45 08             	mov    0x8(%ebp),%eax
f010b746:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010b74d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b751:	75 17                	jne    f010b76a <free_environment+0x42>
f010b753:	83 ec 04             	sub    $0x4,%esp
f010b756:	68 70 5a 12 f0       	push   $0xf0125a70
f010b75b:	68 c0 02 00 00       	push   $0x2c0
f010b760:	68 93 5a 12 f0       	push   $0xf0125a93
f010b765:	e8 cf 4b ff ff       	call   f0100339 <_panic>
f010b76a:	8b 15 d4 27 69 f0    	mov    0xf06927d4,%edx
f010b770:	8b 45 08             	mov    0x8(%ebp),%eax
f010b773:	89 50 08             	mov    %edx,0x8(%eax)
f010b776:	8b 45 08             	mov    0x8(%ebp),%eax
f010b779:	8b 40 08             	mov    0x8(%eax),%eax
f010b77c:	85 c0                	test   %eax,%eax
f010b77e:	74 0d                	je     f010b78d <free_environment+0x65>
f010b780:	a1 d4 27 69 f0       	mov    0xf06927d4,%eax
f010b785:	8b 55 08             	mov    0x8(%ebp),%edx
f010b788:	89 50 0c             	mov    %edx,0xc(%eax)
f010b78b:	eb 08                	jmp    f010b795 <free_environment+0x6d>
f010b78d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b790:	a3 d8 27 69 f0       	mov    %eax,0xf06927d8
f010b795:	8b 45 08             	mov    0x8(%ebp),%eax
f010b798:	a3 d4 27 69 f0       	mov    %eax,0xf06927d4
f010b79d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7a0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b7a7:	a1 e0 27 69 f0       	mov    0xf06927e0,%eax
f010b7ac:	40                   	inc    %eax
f010b7ad:	a3 e0 27 69 f0       	mov    %eax,0xf06927e0
}
f010b7b2:	90                   	nop
f010b7b3:	c9                   	leave  
f010b7b4:	c3                   	ret    

f010b7b5 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010b7b5:	55                   	push   %ebp
f010b7b6:	89 e5                	mov    %esp,%ebp
f010b7b8:	53                   	push   %ebx
f010b7b9:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010b7bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b7bf:	8b 40 0c             	mov    0xc(%eax),%eax
f010b7c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010b7c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b7c8:	8b 40 08             	mov    0x8(%eax),%eax
f010b7cb:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010b7ce:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010b7d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010b7d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b7db:	01 c2                	add    %eax,%edx
f010b7dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b7e0:	01 d0                	add    %edx,%eax
f010b7e2:	48                   	dec    %eax
f010b7e3:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b7e6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b7e9:	ba 00 00 00 00       	mov    $0x0,%edx
f010b7ee:	f7 75 dc             	divl   -0x24(%ebp)
f010b7f1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b7f4:	29 d0                	sub    %edx,%eax
f010b7f6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010b7f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b7fc:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010b7ff:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b802:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b807:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010b80a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010b811:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010b818:	8b 45 10             	mov    0x10(%ebp),%eax
f010b81b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010b821:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010b828:	0f 85 f5 03 00 00    	jne    f010bc23 <program_segment_alloc_map_copy_workingset+0x46e>
f010b82e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b831:	83 c0 20             	add    $0x20,%eax
f010b834:	83 ec 08             	sub    $0x8,%esp
f010b837:	68 48 5c 12 f0       	push   $0xf0125c48
f010b83c:	50                   	push   %eax
f010b83d:	e8 a3 3d 01 00       	call   f011f5e5 <strcmp>
f010b842:	83 c4 10             	add    $0x10,%esp
f010b845:	85 c0                	test   %eax,%eax
f010b847:	0f 84 d6 03 00 00    	je     f010bc23 <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010b84d:	8b 45 14             	mov    0x14(%ebp),%eax
f010b850:	83 f8 06             	cmp    $0x6,%eax
f010b853:	76 05                	jbe    f010b85a <program_segment_alloc_map_copy_workingset+0xa5>
f010b855:	b8 06 00 00 00       	mov    $0x6,%eax
f010b85a:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b85d:	e9 c1 03 00 00       	jmp    f010bc23 <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010b862:	83 ec 0c             	sub    $0xc,%esp
f010b865:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010b868:	50                   	push   %eax
f010b869:	e8 44 c9 ff ff       	call   f01081b2 <allocate_frame>
f010b86e:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010b871:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010b874:	8b 45 08             	mov    0x8(%ebp),%eax
f010b877:	8b 40 64             	mov    0x64(%eax),%eax
f010b87a:	6a 06                	push   $0x6
f010b87c:	ff 75 f4             	pushl  -0xc(%ebp)
f010b87f:	52                   	push   %edx
f010b880:	50                   	push   %eax
f010b881:	e8 fd cf ff ff       	call   f0108883 <loadtime_map_frame>
f010b886:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010b889:	83 ec 08             	sub    $0x8,%esp
f010b88c:	ff 75 f4             	pushl  -0xc(%ebp)
f010b88f:	ff 75 08             	pushl  0x8(%ebp)
f010b892:	e8 69 de ff ff       	call   f0109700 <env_page_ws_list_create_element>
f010b897:	83 c4 10             	add    $0x10,%esp
f010b89a:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010b89d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b8a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b8a7:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b8ab:	75 17                	jne    f010b8c4 <program_segment_alloc_map_copy_workingset+0x10f>
f010b8ad:	83 ec 04             	sub    $0x4,%esp
f010b8b0:	68 f8 5a 12 f0       	push   $0xf0125af8
f010b8b5:	68 ea 02 00 00       	push   $0x2ea
f010b8ba:	68 93 5a 12 f0       	push   $0xf0125a93
f010b8bf:	e8 75 4a ff ff       	call   f0100339 <_panic>
f010b8c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8c7:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b8cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b8d0:	89 50 14             	mov    %edx,0x14(%eax)
f010b8d3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b8d6:	8b 40 14             	mov    0x14(%eax),%eax
f010b8d9:	85 c0                	test   %eax,%eax
f010b8db:	74 11                	je     f010b8ee <program_segment_alloc_map_copy_workingset+0x139>
f010b8dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8e0:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b8e6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b8e9:	89 50 10             	mov    %edx,0x10(%eax)
f010b8ec:	eb 0c                	jmp    f010b8fa <program_segment_alloc_map_copy_workingset+0x145>
f010b8ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8f1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b8f4:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b8fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8fd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b900:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b906:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b909:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b910:	8b 45 08             	mov    0x8(%ebp),%eax
f010b913:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010b919:	8d 50 01             	lea    0x1(%eax),%edx
f010b91c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b91f:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b925:	83 ec 0c             	sub    $0xc,%esp
f010b928:	6a 02                	push   $0x2
f010b92a:	e8 96 35 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f010b92f:	83 c4 10             	add    $0x10,%esp
f010b932:	85 c0                	test   %eax,%eax
f010b934:	0f 84 b3 01 00 00    	je     f010baed <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010b93a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b93e:	75 17                	jne    f010b957 <program_segment_alloc_map_copy_workingset+0x1a2>
f010b940:	83 ec 04             	sub    $0x4,%esp
f010b943:	68 1b 5b 12 f0       	push   $0xf0125b1b
f010b948:	68 f6 02 00 00       	push   $0x2f6
f010b94d:	68 93 5a 12 f0       	push   $0xf0125a93
f010b952:	e8 e2 49 ff ff       	call   f0100339 <_panic>
f010b957:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b95a:	8b 40 10             	mov    0x10(%eax),%eax
f010b95d:	85 c0                	test   %eax,%eax
f010b95f:	74 11                	je     f010b972 <program_segment_alloc_map_copy_workingset+0x1bd>
f010b961:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b964:	8b 40 10             	mov    0x10(%eax),%eax
f010b967:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b96a:	8b 52 14             	mov    0x14(%edx),%edx
f010b96d:	89 50 14             	mov    %edx,0x14(%eax)
f010b970:	eb 0f                	jmp    f010b981 <program_segment_alloc_map_copy_workingset+0x1cc>
f010b972:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b975:	8b 50 14             	mov    0x14(%eax),%edx
f010b978:	8b 45 08             	mov    0x8(%ebp),%eax
f010b97b:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b981:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b984:	8b 40 14             	mov    0x14(%eax),%eax
f010b987:	85 c0                	test   %eax,%eax
f010b989:	74 11                	je     f010b99c <program_segment_alloc_map_copy_workingset+0x1e7>
f010b98b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b98e:	8b 40 14             	mov    0x14(%eax),%eax
f010b991:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b994:	8b 52 10             	mov    0x10(%edx),%edx
f010b997:	89 50 10             	mov    %edx,0x10(%eax)
f010b99a:	eb 0f                	jmp    f010b9ab <program_segment_alloc_map_copy_workingset+0x1f6>
f010b99c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b99f:	8b 50 10             	mov    0x10(%eax),%edx
f010b9a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9a5:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b9ab:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b9ae:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b9b5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b9b8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b9bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9c2:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010b9c8:	8d 50 ff             	lea    -0x1(%eax),%edx
f010b9cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9ce:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010b9d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9d7:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b9dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9e0:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b9e6:	48                   	dec    %eax
f010b9e7:	39 c2                	cmp    %eax,%edx
f010b9e9:	0f 83 80 00 00 00    	jae    f010ba6f <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b9ef:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b9f3:	75 17                	jne    f010ba0c <program_segment_alloc_map_copy_workingset+0x257>
f010b9f5:	83 ec 04             	sub    $0x4,%esp
f010b9f8:	68 70 5a 12 f0       	push   $0xf0125a70
f010b9fd:	68 fa 02 00 00       	push   $0x2fa
f010ba02:	68 93 5a 12 f0       	push   $0xf0125a93
f010ba07:	e8 2d 49 ff ff       	call   f0100339 <_panic>
f010ba0c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba0f:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010ba15:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba18:	89 50 10             	mov    %edx,0x10(%eax)
f010ba1b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba1e:	8b 40 10             	mov    0x10(%eax),%eax
f010ba21:	85 c0                	test   %eax,%eax
f010ba23:	74 11                	je     f010ba36 <program_segment_alloc_map_copy_workingset+0x281>
f010ba25:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba28:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010ba2e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ba31:	89 50 14             	mov    %edx,0x14(%eax)
f010ba34:	eb 0c                	jmp    f010ba42 <program_segment_alloc_map_copy_workingset+0x28d>
f010ba36:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba39:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ba3c:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010ba42:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba45:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ba48:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010ba4e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba51:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010ba58:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba5b:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010ba61:	8d 50 01             	lea    0x1(%eax),%edx
f010ba64:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba67:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010ba6d:	eb 7e                	jmp    f010baed <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010ba6f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010ba73:	75 17                	jne    f010ba8c <program_segment_alloc_map_copy_workingset+0x2d7>
f010ba75:	83 ec 04             	sub    $0x4,%esp
f010ba78:	68 70 5a 12 f0       	push   $0xf0125a70
f010ba7d:	68 ff 02 00 00       	push   $0x2ff
f010ba82:	68 93 5a 12 f0       	push   $0xf0125a93
f010ba87:	e8 ad 48 ff ff       	call   f0100339 <_panic>
f010ba8c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba8f:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010ba95:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba98:	89 50 10             	mov    %edx,0x10(%eax)
f010ba9b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba9e:	8b 40 10             	mov    0x10(%eax),%eax
f010baa1:	85 c0                	test   %eax,%eax
f010baa3:	74 11                	je     f010bab6 <program_segment_alloc_map_copy_workingset+0x301>
f010baa5:	8b 45 08             	mov    0x8(%ebp),%eax
f010baa8:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010baae:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bab1:	89 50 14             	mov    %edx,0x14(%eax)
f010bab4:	eb 0c                	jmp    f010bac2 <program_segment_alloc_map_copy_workingset+0x30d>
f010bab6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bab9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010babc:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010bac2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bac5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bac8:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010bace:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bad1:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bad8:	8b 45 08             	mov    0x8(%ebp),%eax
f010badb:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010bae1:	8d 50 01             	lea    0x1(%eax),%edx
f010bae4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bae7:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010baed:	8b 45 08             	mov    0x8(%ebp),%eax
f010baf0:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010baf6:	8b 45 08             	mov    0x8(%ebp),%eax
f010baf9:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010baff:	39 c2                	cmp    %eax,%edx
f010bb01:	75 14                	jne    f010bb17 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010bb03:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb06:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010bb0c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb0f:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010bb15:	eb 0d                	jmp    f010bb24 <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010bb17:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb1a:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010bb21:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010bb24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb27:	c1 e8 16             	shr    $0x16,%eax
f010bb2a:	89 c2                	mov    %eax,%edx
f010bb2c:	8b 45 18             	mov    0x18(%ebp),%eax
f010bb2f:	8b 00                	mov    (%eax),%eax
f010bb31:	39 c2                	cmp    %eax,%edx
f010bb33:	0f 84 d3 00 00 00    	je     f010bc0c <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010bb39:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb3c:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010bb42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb45:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010bb48:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010bb4b:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010bb50:	89 c1                	mov    %eax,%ecx
f010bb52:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010bb55:	89 d0                	mov    %edx,%eax
f010bb57:	01 c0                	add    %eax,%eax
f010bb59:	01 d0                	add    %edx,%eax
f010bb5b:	c1 e0 03             	shl    $0x3,%eax
f010bb5e:	01 d8                	add    %ebx,%eax
f010bb60:	05 ac 00 00 00       	add    $0xac,%eax
f010bb65:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010bb67:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb6a:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010bb70:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010bb73:	89 d0                	mov    %edx,%eax
f010bb75:	01 c0                	add    %eax,%eax
f010bb77:	01 d0                	add    %edx,%eax
f010bb79:	c1 e0 03             	shl    $0x3,%eax
f010bb7c:	01 c8                	add    %ecx,%eax
f010bb7e:	05 b0 00 00 00       	add    $0xb0,%eax
f010bb83:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010bb86:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb89:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010bb8f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010bb92:	89 d0                	mov    %edx,%eax
f010bb94:	01 c0                	add    %eax,%eax
f010bb96:	01 d0                	add    %edx,%eax
f010bb98:	c1 e0 03             	shl    $0x3,%eax
f010bb9b:	01 c8                	add    %ecx,%eax
f010bb9d:	05 b4 00 00 00       	add    $0xb4,%eax
f010bba2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010bba8:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbab:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010bbb1:	8d 50 01             	lea    0x1(%eax),%edx
f010bbb4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbb7:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010bbbd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbc0:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010bbc6:	b9 32 00 00 00       	mov    $0x32,%ecx
f010bbcb:	ba 00 00 00 00       	mov    $0x0,%edx
f010bbd0:	f7 f1                	div    %ecx
f010bbd2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbd5:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010bbdb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbde:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010bbe4:	85 c0                	test   %eax,%eax
f010bbe6:	75 17                	jne    f010bbff <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010bbe8:	83 ec 04             	sub    $0x4,%esp
f010bbeb:	68 4c 5c 12 f0       	push   $0xf0125c4c
f010bbf0:	68 27 03 00 00       	push   $0x327
f010bbf5:	68 93 5a 12 f0       	push   $0xf0125a93
f010bbfa:	e8 3a 47 ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010bbff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc02:	c1 e8 16             	shr    $0x16,%eax
f010bc05:	89 c2                	mov    %eax,%edx
f010bc07:	8b 45 18             	mov    0x18(%ebp),%eax
f010bc0a:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010bc0c:	8b 45 10             	mov    0x10(%ebp),%eax
f010bc0f:	8b 00                	mov    (%eax),%eax
f010bc11:	8d 50 01             	lea    0x1(%eax),%edx
f010bc14:	8b 45 10             	mov    0x10(%ebp),%eax
f010bc17:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010bc19:	ff 45 f0             	incl   -0x10(%ebp)
f010bc1c:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010bc23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc26:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010bc29:	73 0c                	jae    f010bc37 <program_segment_alloc_map_copy_workingset+0x482>
f010bc2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc2e:	3b 45 14             	cmp    0x14(%ebp),%eax
f010bc31:	0f 82 2b fc ff ff    	jb     f010b862 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010bc37:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc3a:	8b 00                	mov    (%eax),%eax
f010bc3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010bc3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc42:	8b 40 0c             	mov    0xc(%eax),%eax
f010bc45:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010bc48:	eb 10                	jmp    f010bc5a <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010bc4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc4d:	8a 10                	mov    (%eax),%dl
f010bc4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bc52:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010bc54:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010bc57:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010bc5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bc5d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010bc60:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010bc63:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bc68:	89 c2                	mov    %eax,%edx
f010bc6a:	8b 45 10             	mov    0x10(%ebp),%eax
f010bc6d:	8b 00                	mov    (%eax),%eax
f010bc6f:	c1 e0 0c             	shl    $0xc,%eax
f010bc72:	01 c2                	add    %eax,%edx
f010bc74:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bc77:	39 c2                	cmp    %eax,%edx
f010bc79:	76 1d                	jbe    f010bc98 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010bc7b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc7e:	8b 50 04             	mov    0x4(%eax),%edx
f010bc81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bc84:	01 c2                	add    %eax,%edx
f010bc86:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010bc89:	39 c2                	cmp    %eax,%edx
f010bc8b:	77 bd                	ja     f010bc4a <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010bc8d:	eb 09                	jmp    f010bc98 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010bc8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bc92:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010bc95:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010bc98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bc9b:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010bc9e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010bca1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bca6:	89 c2                	mov    %eax,%edx
f010bca8:	8b 45 10             	mov    0x10(%ebp),%eax
f010bcab:	8b 00                	mov    (%eax),%eax
f010bcad:	c1 e0 0c             	shl    $0xc,%eax
f010bcb0:	01 c2                	add    %eax,%edx
f010bcb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bcb5:	39 c2                	cmp    %eax,%edx
f010bcb7:	77 d6                	ja     f010bc8f <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010bcb9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bcbe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bcc1:	c9                   	leave  
f010bcc2:	c3                   	ret    

f010bcc3 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010bcc3:	55                   	push   %ebp
f010bcc4:	89 e5                	mov    %esp,%ebp
f010bcc6:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010bcc9:	83 ec 0c             	sub    $0xc,%esp
f010bccc:	68 00 10 00 00       	push   $0x1000
f010bcd1:	e8 15 d4 ff ff       	call   f01090eb <kmalloc>
f010bcd6:	83 c4 10             	add    $0x10,%esp
f010bcd9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010bcdc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bce0:	75 17                	jne    f010bcf9 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010bce2:	83 ec 04             	sub    $0x4,%esp
f010bce5:	68 ef 5c 12 f0       	push   $0xf0125cef
f010bcea:	68 57 03 00 00       	push   $0x357
f010bcef:	68 93 5a 12 f0       	push   $0xf0125a93
f010bcf4:	e8 40 46 ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010bcf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010bcfc:	c9                   	leave  
f010bcfd:	c3                   	ret    

f010bcfe <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010bcfe:	55                   	push   %ebp
f010bcff:	89 e5                	mov    %esp,%ebp
f010bd01:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010bd04:	83 ec 0c             	sub    $0xc,%esp
f010bd07:	68 00 80 00 00       	push   $0x8000
f010bd0c:	e8 da d3 ff ff       	call   f01090eb <kmalloc>
f010bd11:	83 c4 10             	add    $0x10,%esp
f010bd14:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010bd17:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010bd1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bd21:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010bd26:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010bd29:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bd2c:	ba 00 00 00 00       	mov    $0x0,%edx
f010bd31:	f7 75 ec             	divl   -0x14(%ebp)
f010bd34:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bd37:	29 d0                	sub    %edx,%eax
f010bd39:	85 c0                	test   %eax,%eax
f010bd3b:	79 05                	jns    f010bd42 <create_user_kern_stack+0x44>
f010bd3d:	05 ff 0f 00 00       	add    $0xfff,%eax
f010bd42:	c1 f8 0c             	sar    $0xc,%eax
f010bd45:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010bd48:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010bd4f:	eb 72                	jmp    f010bdc3 <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010bd51:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010bd58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd5b:	c1 e0 0c             	shl    $0xc,%eax
f010bd5e:	89 c2                	mov    %eax,%edx
f010bd60:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bd63:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010bd66:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f010bd6b:	83 ec 04             	sub    $0x4,%esp
f010bd6e:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010bd71:	52                   	push   %edx
f010bd72:	51                   	push   %ecx
f010bd73:	50                   	push   %eax
f010bd74:	e8 f0 c9 ff ff       	call   f0108769 <get_frame_info>
f010bd79:	83 c4 10             	add    $0x10,%esp
f010bd7c:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010bd7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd82:	c1 e0 0c             	shl    $0xc,%eax
f010bd85:	89 c2                	mov    %eax,%edx
f010bd87:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bd8a:	01 d0                	add    %edx,%eax
f010bd8c:	6a 01                	push   $0x1
f010bd8e:	50                   	push   %eax
f010bd8f:	ff 75 e0             	pushl  -0x20(%ebp)
f010bd92:	ff 75 08             	pushl  0x8(%ebp)
f010bd95:	e8 e5 c8 ff ff       	call   f010867f <map_frame>
f010bd9a:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010bd9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bda1:	75 1d                	jne    f010bdc0 <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010bda3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bda6:	c1 e0 0c             	shl    $0xc,%eax
f010bda9:	89 c2                	mov    %eax,%edx
f010bdab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bdae:	01 d0                	add    %edx,%eax
f010bdb0:	6a 01                	push   $0x1
f010bdb2:	6a 00                	push   $0x0
f010bdb4:	50                   	push   %eax
f010bdb5:	ff 75 08             	pushl  0x8(%ebp)
f010bdb8:	e8 0d d7 ff ff       	call   f01094ca <pt_set_page_permissions>
f010bdbd:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010bdc0:	ff 45 f4             	incl   -0xc(%ebp)
f010bdc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdc6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010bdc9:	72 86                	jb     f010bd51 <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010bdcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010bdce:	c9                   	leave  
f010bdcf:	c3                   	ret    

f010bdd0 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010bdd0:	55                   	push   %ebp
f010bdd1:	89 e5                	mov    %esp,%ebp
f010bdd3:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010bdd6:	83 ec 04             	sub    $0x4,%esp
f010bdd9:	68 0c 5d 12 f0       	push   $0xf0125d0c
f010bdde:	68 8e 03 00 00       	push   $0x38e
f010bde3:	68 93 5a 12 f0       	push   $0xf0125a93
f010bde8:	e8 4c 45 ff ff       	call   f0100339 <_panic>

f010bded <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010bded:	55                   	push   %ebp
f010bdee:	89 e5                	mov    %esp,%ebp
f010bdf0:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010bdf3:	8b 45 08             	mov    0x8(%ebp),%eax
f010bdf6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010bdf9:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010bdfc:	8b 45 08             	mov    0x8(%ebp),%eax
f010bdff:	8b 55 10             	mov    0x10(%ebp),%edx
f010be02:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010be05:	8b 45 08             	mov    0x8(%ebp),%eax
f010be08:	8b 55 0c             	mov    0xc(%ebp),%edx
f010be0b:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010be0e:	83 ec 08             	sub    $0x8,%esp
f010be11:	6a 00                	push   $0x0
f010be13:	ff 75 0c             	pushl  0xc(%ebp)
f010be16:	e8 8d 42 01 00       	call   f01200a8 <initialize_dynamic_allocator>
f010be1b:	83 c4 10             	add    $0x10,%esp
}
f010be1e:	90                   	nop
f010be1f:	c9                   	leave  
f010be20:	c3                   	ret    

f010be21 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010be21:	55                   	push   %ebp
f010be22:	89 e5                	mov    %esp,%ebp
f010be24:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010be27:	8b 45 08             	mov    0x8(%ebp),%eax
f010be2a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010be2d:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010be30:	8b 45 08             	mov    0x8(%ebp),%eax
f010be33:	8b 55 10             	mov    0x10(%ebp),%edx
f010be36:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010be39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010be40:	eb 17                	jmp    f010be59 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010be42:	8b 45 08             	mov    0x8(%ebp),%eax
f010be45:	8b 40 64             	mov    0x64(%eax),%eax
f010be48:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be4b:	c1 e2 02             	shl    $0x2,%edx
f010be4e:	01 d0                	add    %edx,%eax
f010be50:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010be56:	ff 45 f4             	incl   -0xc(%ebp)
f010be59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be5c:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010be61:	76 df                	jbe    f010be42 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010be63:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010be6a:	eb 22                	jmp    f010be8e <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010be6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010be6f:	8b 40 64             	mov    0x64(%eax),%eax
f010be72:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be75:	c1 e2 02             	shl    $0x2,%edx
f010be78:	01 c2                	add    %eax,%edx
f010be7a:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f010be7f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010be82:	c1 e1 02             	shl    $0x2,%ecx
f010be85:	01 c8                	add    %ecx,%eax
f010be87:	8b 00                	mov    (%eax),%eax
f010be89:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010be8b:	ff 45 f4             	incl   -0xc(%ebp)
f010be8e:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010be95:	7e d5                	jle    f010be6c <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010be97:	8b 45 08             	mov    0x8(%ebp),%eax
f010be9a:	8b 40 64             	mov    0x64(%eax),%eax
f010be9d:	83 ec 0c             	sub    $0xc,%esp
f010bea0:	50                   	push   %eax
f010bea1:	e8 58 fe ff ff       	call   f010bcfe <create_user_kern_stack>
f010bea6:	83 c4 10             	add    $0x10,%esp
f010bea9:	89 c2                	mov    %eax,%edx
f010beab:	8b 45 08             	mov    0x8(%ebp),%eax
f010beae:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010beb1:	8b 45 08             	mov    0x8(%ebp),%eax
f010beb4:	8b 40 70             	mov    0x70(%eax),%eax
f010beb7:	05 00 80 00 00       	add    $0x8000,%eax
f010bebc:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010bebf:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010bec3:	8b 45 08             	mov    0x8(%ebp),%eax
f010bec6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bec9:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010becb:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010becf:	ba 0e df 10 f0       	mov    $0xf010df0e,%edx
f010bed4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bed7:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010bed9:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010bedd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bee0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bee3:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010bee6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bee9:	8b 40 04             	mov    0x4(%eax),%eax
f010beec:	83 ec 04             	sub    $0x4,%esp
f010beef:	6a 20                	push   $0x20
f010bef1:	6a 00                	push   $0x0
f010bef3:	50                   	push   %eax
f010bef4:	e8 ce 37 01 00       	call   f011f6c7 <memset>
f010bef9:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010befc:	8b 45 08             	mov    0x8(%ebp),%eax
f010beff:	8b 40 04             	mov    0x4(%eax),%eax
f010bf02:	ba f0 b1 10 f0       	mov    $0xf010b1f0,%edx
f010bf07:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010bf0a:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf0d:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010bf14:	00 00 00 
f010bf17:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf1a:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010bf21:	00 00 00 
f010bf24:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf27:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010bf2e:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010bf31:	83 ec 0c             	sub    $0xc,%esp
f010bf34:	6a 02                	push   $0x2
f010bf36:	e8 8a 2f 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f010bf3b:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010bf3e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bf45:	eb 54                	jmp    f010bf9b <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010bf47:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010bf4a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf4d:	89 d0                	mov    %edx,%eax
f010bf4f:	01 c0                	add    %eax,%eax
f010bf51:	01 d0                	add    %edx,%eax
f010bf53:	c1 e0 03             	shl    $0x3,%eax
f010bf56:	01 c8                	add    %ecx,%eax
f010bf58:	05 ac 00 00 00       	add    $0xac,%eax
f010bf5d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010bf63:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010bf66:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf69:	89 d0                	mov    %edx,%eax
f010bf6b:	01 c0                	add    %eax,%eax
f010bf6d:	01 d0                	add    %edx,%eax
f010bf6f:	c1 e0 03             	shl    $0x3,%eax
f010bf72:	01 c8                	add    %ecx,%eax
f010bf74:	05 b0 00 00 00       	add    $0xb0,%eax
f010bf79:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010bf7c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010bf7f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf82:	89 d0                	mov    %edx,%eax
f010bf84:	01 c0                	add    %eax,%eax
f010bf86:	01 d0                	add    %edx,%eax
f010bf88:	c1 e0 03             	shl    $0x3,%eax
f010bf8b:	01 c8                	add    %ecx,%eax
f010bf8d:	05 b4 00 00 00       	add    $0xb4,%eax
f010bf92:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010bf98:	ff 45 f4             	incl   -0xc(%ebp)
f010bf9b:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010bf9f:	7e a6                	jle    f010bf47 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010bfa1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfa4:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010bfab:	00 00 00 

	e->pageFaultsCounter=0;
f010bfae:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfb1:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010bfb8:	00 00 00 
	e->tableFaultsCounter=0;
f010bfbb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfbe:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010bfc5:	00 00 00 

	e->freeingFullWSCounter = 0;
f010bfc8:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfcb:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010bfd2:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010bfd5:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfd8:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010bfdf:	00 00 00 

	e->nModifiedPages=0;
f010bfe2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfe5:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010bfec:	00 00 00 
	e->nNotModifiedPages=0;
f010bfef:	8b 45 08             	mov    0x8(%ebp),%eax
f010bff2:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010bff9:	00 00 00 
	e->nClocks = 0;
f010bffc:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfff:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c006:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c009:	8b 45 08             	mov    0x8(%ebp),%eax
f010c00c:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c013:	00 00 00 
	e->nPageOut = 0;
f010c016:	8b 45 08             	mov    0x8(%ebp),%eax
f010c019:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c020:	00 00 00 
	e->nNewPageAdded = 0;
f010c023:	8b 45 08             	mov    0x8(%ebp),%eax
f010c026:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c02d:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010c030:	83 ec 04             	sub    $0x4,%esp
f010c033:	68 00 00 00 82       	push   $0x82000000
f010c038:	68 00 00 00 80       	push   $0x80000000
f010c03d:	ff 75 08             	pushl  0x8(%ebp)
f010c040:	e8 a8 fd ff ff       	call   f010bded <initialize_uheap_dynamic_allocator>
f010c045:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c048:	83 ec 0c             	sub    $0xc,%esp
f010c04b:	ff 75 08             	pushl  0x8(%ebp)
f010c04e:	e8 06 00 00 00       	call   f010c059 <complete_environment_initialization>
f010c053:	83 c4 10             	add    $0x10,%esp
}
f010c056:	90                   	nop
f010c057:	c9                   	leave  
f010c058:	c3                   	ret    

f010c059 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c059:	55                   	push   %ebp
f010c05a:	89 e5                	mov    %esp,%ebp
f010c05c:	53                   	push   %ebx
f010c05d:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c060:	8b 45 08             	mov    0x8(%ebp),%eax
f010c063:	8b 40 64             	mov    0x64(%eax),%eax
f010c066:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c06c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c06f:	8b 40 68             	mov    0x68(%eax),%eax
f010c072:	83 c8 03             	or     $0x3,%eax
f010c075:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c077:	8b 45 08             	mov    0x8(%ebp),%eax
f010c07a:	8b 40 64             	mov    0x64(%eax),%eax
f010c07d:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c083:	8b 45 08             	mov    0x8(%ebp),%eax
f010c086:	8b 40 68             	mov    0x68(%eax),%eax
f010c089:	83 c8 05             	or     $0x5,%eax
f010c08c:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c08e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c091:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c098:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010c09b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c09e:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010c0a5:	00 00 00 
	e->disk_env_tabledir = 0;
f010c0a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0ab:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c0b2:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010c0b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0b8:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c0bf:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c0c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0c5:	8b 58 10             	mov    0x10(%eax),%ebx
f010c0c8:	83 ec 0c             	sub    $0xc,%esp
f010c0cb:	68 ca 02 00 00       	push   $0x2ca
f010c0d0:	e8 97 19 01 00       	call   f011da6c <log2_ceil>
f010c0d5:	83 c4 10             	add    $0x10,%esp
f010c0d8:	ba 01 00 00 00       	mov    $0x1,%edx
f010c0dd:	88 c1                	mov    %al,%cl
f010c0df:	d3 e2                	shl    %cl,%edx
f010c0e1:	89 d0                	mov    %edx,%eax
f010c0e3:	01 d8                	add    %ebx,%eax
f010c0e5:	89 c3                	mov    %eax,%ebx
f010c0e7:	83 ec 0c             	sub    $0xc,%esp
f010c0ea:	68 ca 02 00 00       	push   $0x2ca
f010c0ef:	e8 43 19 01 00       	call   f011da37 <nearest_pow2_ceil>
f010c0f4:	83 c4 10             	add    $0x10,%esp
f010c0f7:	f7 d8                	neg    %eax
f010c0f9:	21 d8                	and    %ebx,%eax
f010c0fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c0fe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c102:	7f 1e                	jg     f010c122 <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010c104:	83 ec 0c             	sub    $0xc,%esp
f010c107:	68 ca 02 00 00       	push   $0x2ca
f010c10c:	e8 5b 19 01 00       	call   f011da6c <log2_ceil>
f010c111:	83 c4 10             	add    $0x10,%esp
f010c114:	ba 01 00 00 00       	mov    $0x1,%edx
f010c119:	88 c1                	mov    %al,%cl
f010c11b:	d3 e2                	shl    %cl,%edx
f010c11d:	89 d0                	mov    %edx,%eax
f010c11f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c122:	8b 45 08             	mov    0x8(%ebp),%eax
f010c125:	8b 15 d0 27 69 f0    	mov    0xf06927d0,%edx
f010c12b:	29 d0                	sub    %edx,%eax
f010c12d:	c1 f8 02             	sar    $0x2,%eax
f010c130:	89 c2                	mov    %eax,%edx
f010c132:	89 d0                	mov    %edx,%eax
f010c134:	c1 e0 03             	shl    $0x3,%eax
f010c137:	01 d0                	add    %edx,%eax
f010c139:	c1 e0 03             	shl    $0x3,%eax
f010c13c:	01 d0                	add    %edx,%eax
f010c13e:	c1 e0 02             	shl    $0x2,%eax
f010c141:	01 d0                	add    %edx,%eax
f010c143:	01 c0                	add    %eax,%eax
f010c145:	01 d0                	add    %edx,%eax
f010c147:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010c14e:	01 c8                	add    %ecx,%eax
f010c150:	c1 e0 02             	shl    $0x2,%eax
f010c153:	01 d0                	add    %edx,%eax
f010c155:	c1 e0 03             	shl    $0x3,%eax
f010c158:	01 d0                	add    %edx,%eax
f010c15a:	c1 e0 05             	shl    $0x5,%eax
f010c15d:	29 d0                	sub    %edx,%eax
f010c15f:	c1 e0 02             	shl    $0x2,%eax
f010c162:	01 d0                	add    %edx,%eax
f010c164:	01 c0                	add    %eax,%eax
f010c166:	01 d0                	add    %edx,%eax
f010c168:	c1 e0 03             	shl    $0x3,%eax
f010c16b:	01 d0                	add    %edx,%eax
f010c16d:	c1 e0 04             	shl    $0x4,%eax
f010c170:	29 d0                	sub    %edx,%eax
f010c172:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c175:	89 c2                	mov    %eax,%edx
f010c177:	8b 45 08             	mov    0x8(%ebp),%eax
f010c17a:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c17d:	e8 08 f1 ff ff       	call   f010b28a <get_cpu_proc>
f010c182:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c185:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c189:	75 0c                	jne    f010c197 <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010c18b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c18e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c195:	eb 0c                	jmp    f010c1a3 <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c197:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c19a:	8b 50 10             	mov    0x10(%eax),%edx
f010c19d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1a0:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c1a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1a6:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c1ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1b0:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c1b7:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c1ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1bd:	8b 00                	mov    (%eax),%eax
f010c1bf:	83 ec 04             	sub    $0x4,%esp
f010c1c2:	6a 44                	push   $0x44
f010c1c4:	6a 00                	push   $0x0
f010c1c6:	50                   	push   %eax
f010c1c7:	e8 fb 34 01 00       	call   f011f6c7 <memset>
f010c1cc:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c1cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1d2:	8b 00                	mov    (%eax),%eax
f010c1d4:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c1da:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1dd:	8b 00                	mov    (%eax),%eax
f010c1df:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c1e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1e8:	8b 00                	mov    (%eax),%eax
f010c1ea:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c1f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1f3:	8b 00                	mov    (%eax),%eax
f010c1f5:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010c1fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1ff:	8b 00                	mov    (%eax),%eax
f010c201:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010c207:	8b 45 08             	mov    0x8(%ebp),%eax
f010c20a:	8b 00                	mov    (%eax),%eax
f010c20c:	8b 55 08             	mov    0x8(%ebp),%edx
f010c20f:	8b 12                	mov    (%edx),%edx
f010c211:	8b 52 38             	mov    0x38(%edx),%edx
f010c214:	80 ce 02             	or     $0x2,%dh
f010c217:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010c21a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c21e:	75 17                	jne    f010c237 <complete_environment_initialization+0x1de>
f010c220:	83 ec 04             	sub    $0x4,%esp
f010c223:	68 1b 5b 12 f0       	push   $0xf0125b1b
f010c228:	68 67 04 00 00       	push   $0x467
f010c22d:	68 93 5a 12 f0       	push   $0xf0125a93
f010c232:	e8 02 41 ff ff       	call   f0100339 <_panic>
f010c237:	8b 45 08             	mov    0x8(%ebp),%eax
f010c23a:	8b 40 08             	mov    0x8(%eax),%eax
f010c23d:	85 c0                	test   %eax,%eax
f010c23f:	74 11                	je     f010c252 <complete_environment_initialization+0x1f9>
f010c241:	8b 45 08             	mov    0x8(%ebp),%eax
f010c244:	8b 40 08             	mov    0x8(%eax),%eax
f010c247:	8b 55 08             	mov    0x8(%ebp),%edx
f010c24a:	8b 52 0c             	mov    0xc(%edx),%edx
f010c24d:	89 50 0c             	mov    %edx,0xc(%eax)
f010c250:	eb 0b                	jmp    f010c25d <complete_environment_initialization+0x204>
f010c252:	8b 45 08             	mov    0x8(%ebp),%eax
f010c255:	8b 40 0c             	mov    0xc(%eax),%eax
f010c258:	a3 d8 27 69 f0       	mov    %eax,0xf06927d8
f010c25d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c260:	8b 40 0c             	mov    0xc(%eax),%eax
f010c263:	85 c0                	test   %eax,%eax
f010c265:	74 11                	je     f010c278 <complete_environment_initialization+0x21f>
f010c267:	8b 45 08             	mov    0x8(%ebp),%eax
f010c26a:	8b 40 0c             	mov    0xc(%eax),%eax
f010c26d:	8b 55 08             	mov    0x8(%ebp),%edx
f010c270:	8b 52 08             	mov    0x8(%edx),%edx
f010c273:	89 50 08             	mov    %edx,0x8(%eax)
f010c276:	eb 0b                	jmp    f010c283 <complete_environment_initialization+0x22a>
f010c278:	8b 45 08             	mov    0x8(%ebp),%eax
f010c27b:	8b 40 08             	mov    0x8(%eax),%eax
f010c27e:	a3 d4 27 69 f0       	mov    %eax,0xf06927d4
f010c283:	8b 45 08             	mov    0x8(%ebp),%eax
f010c286:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010c28d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c290:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c297:	a1 e0 27 69 f0       	mov    0xf06927e0,%eax
f010c29c:	48                   	dec    %eax
f010c29d:	a3 e0 27 69 f0       	mov    %eax,0xf06927e0
	return ;
f010c2a2:	90                   	nop
}
f010c2a3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c2a6:	c9                   	leave  
f010c2a7:	c3                   	ret    

f010c2a8 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010c2a8:	55                   	push   %ebp
f010c2a9:	89 e5                	mov    %esp,%ebp
f010c2ab:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c2ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c2b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c2b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2b7:	8b 00                	mov    (%eax),%eax
f010c2b9:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c2be:	74 17                	je     f010c2d7 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010c2c0:	83 ec 04             	sub    $0x4,%esp
f010c2c3:	68 41 5d 12 f0       	push   $0xf0125d41
f010c2c8:	68 73 04 00 00       	push   $0x473
f010c2cd:	68 93 5a 12 f0       	push   $0xf0125a93
f010c2d2:	e8 62 40 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010c2d7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2da:	8b 00                	mov    (%eax),%eax
f010c2dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c2df:	8b 52 18             	mov    0x18(%edx),%edx
f010c2e2:	89 50 30             	mov    %edx,0x30(%eax)
}
f010c2e5:	90                   	nop
f010c2e6:	c9                   	leave  
f010c2e7:	c3                   	ret    

f010c2e8 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010c2e8:	55                   	push   %ebp
f010c2e9:	89 e5                	mov    %esp,%ebp
f010c2eb:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010c2ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2f1:	8b 40 10             	mov    0x10(%eax),%eax
f010c2f4:	8d 48 01             	lea    0x1(%eax),%ecx
f010c2f7:	8b 55 08             	mov    0x8(%ebp),%edx
f010c2fa:	89 4a 10             	mov    %ecx,0x10(%edx)
f010c2fd:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c300:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c303:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c306:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c309:	8b 00                	mov    (%eax),%eax
f010c30b:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c310:	74 17                	je     f010c329 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010c312:	83 ec 04             	sub    $0x4,%esp
f010c315:	68 41 5d 12 f0       	push   $0xf0125d41
f010c31a:	68 81 04 00 00       	push   $0x481
f010c31f:	68 93 5a 12 f0       	push   $0xf0125a93
f010c324:	e8 10 40 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010c329:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c32c:	8b 50 1c             	mov    0x1c(%eax),%edx
f010c32f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c332:	01 d0                	add    %edx,%eax
f010c334:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010c337:	eb 0f                	jmp    f010c348 <PROGRAM_SEGMENT_NEXT+0x60>
f010c339:	8b 45 08             	mov    0x8(%ebp),%eax
f010c33c:	8b 40 10             	mov    0x10(%eax),%eax
f010c33f:	8d 50 01             	lea    0x1(%eax),%edx
f010c342:	8b 45 08             	mov    0x8(%ebp),%eax
f010c345:	89 50 10             	mov    %edx,0x10(%eax)
f010c348:	8b 45 08             	mov    0x8(%ebp),%eax
f010c34b:	8b 40 10             	mov    0x10(%eax),%eax
f010c34e:	c1 e0 05             	shl    $0x5,%eax
f010c351:	89 c2                	mov    %eax,%edx
f010c353:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c356:	01 d0                	add    %edx,%eax
f010c358:	8b 00                	mov    (%eax),%eax
f010c35a:	83 f8 01             	cmp    $0x1,%eax
f010c35d:	74 13                	je     f010c372 <PROGRAM_SEGMENT_NEXT+0x8a>
f010c35f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c362:	8b 50 10             	mov    0x10(%eax),%edx
f010c365:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c368:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c36b:	0f b7 c0             	movzwl %ax,%eax
f010c36e:	39 c2                	cmp    %eax,%edx
f010c370:	72 c7                	jb     f010c339 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010c372:	8b 45 08             	mov    0x8(%ebp),%eax
f010c375:	8b 40 10             	mov    0x10(%eax),%eax
f010c378:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010c37b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c37e:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c381:	0f b7 c0             	movzwl %ax,%eax
f010c384:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c387:	7e 63                	jle    f010c3ec <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010c389:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c38c:	c1 e0 05             	shl    $0x5,%eax
f010c38f:	89 c2                	mov    %eax,%edx
f010c391:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c394:	01 d0                	add    %edx,%eax
f010c396:	8b 50 04             	mov    0x4(%eax),%edx
f010c399:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c39c:	01 c2                	add    %eax,%edx
f010c39e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3a1:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010c3a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3a6:	c1 e0 05             	shl    $0x5,%eax
f010c3a9:	89 c2                	mov    %eax,%edx
f010c3ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c3ae:	01 d0                	add    %edx,%eax
f010c3b0:	8b 50 14             	mov    0x14(%eax),%edx
f010c3b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3b6:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010c3b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3bc:	c1 e0 05             	shl    $0x5,%eax
f010c3bf:	89 c2                	mov    %eax,%edx
f010c3c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c3c4:	01 d0                	add    %edx,%eax
f010c3c6:	8b 50 10             	mov    0x10(%eax),%edx
f010c3c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3cc:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010c3cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3d2:	c1 e0 05             	shl    $0x5,%eax
f010c3d5:	89 c2                	mov    %eax,%edx
f010c3d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c3da:	01 d0                	add    %edx,%eax
f010c3dc:	8b 40 08             	mov    0x8(%eax),%eax
f010c3df:	89 c2                	mov    %eax,%edx
f010c3e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3e4:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010c3e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3ea:	eb 05                	jmp    f010c3f1 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010c3ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c3f1:	c9                   	leave  
f010c3f2:	c3                   	ret    

f010c3f3 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010c3f3:	55                   	push   %ebp
f010c3f4:	89 e5                	mov    %esp,%ebp
f010c3f6:	57                   	push   %edi
f010c3f7:	56                   	push   %esi
f010c3f8:	53                   	push   %ebx
f010c3f9:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010c3fc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c403:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c406:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c409:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c40c:	8b 00                	mov    (%eax),%eax
f010c40e:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c413:	74 17                	je     f010c42c <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010c415:	83 ec 04             	sub    $0x4,%esp
f010c418:	68 41 5d 12 f0       	push   $0xf0125d41
f010c41d:	68 9d 04 00 00       	push   $0x49d
f010c422:	68 93 5a 12 f0       	push   $0xf0125a93
f010c427:	e8 0d 3f ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010c42c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c42f:	8b 50 1c             	mov    0x1c(%eax),%edx
f010c432:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c435:	01 d0                	add    %edx,%eax
f010c437:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010c43a:	eb 07                	jmp    f010c443 <PROGRAM_SEGMENT_FIRST+0x50>
f010c43c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c43f:	40                   	inc    %eax
f010c440:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010c443:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c446:	c1 e0 05             	shl    $0x5,%eax
f010c449:	89 c2                	mov    %eax,%edx
f010c44b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c44e:	01 d0                	add    %edx,%eax
f010c450:	8b 00                	mov    (%eax),%eax
f010c452:	83 f8 01             	cmp    $0x1,%eax
f010c455:	74 10                	je     f010c467 <PROGRAM_SEGMENT_FIRST+0x74>
f010c457:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010c45a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c45d:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c460:	0f b7 c0             	movzwl %ax,%eax
f010c463:	39 c2                	cmp    %eax,%edx
f010c465:	72 d5                	jb     f010c43c <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010c467:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c46a:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010c46d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c470:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c473:	0f b7 c0             	movzwl %ax,%eax
f010c476:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010c479:	7e 68                	jle    f010c4e3 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010c47b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c47e:	c1 e0 05             	shl    $0x5,%eax
f010c481:	89 c2                	mov    %eax,%edx
f010c483:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c486:	01 d0                	add    %edx,%eax
f010c488:	8b 50 04             	mov    0x4(%eax),%edx
f010c48b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c48e:	01 d0                	add    %edx,%eax
f010c490:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010c493:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c496:	c1 e0 05             	shl    $0x5,%eax
f010c499:	89 c2                	mov    %eax,%edx
f010c49b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c49e:	01 d0                	add    %edx,%eax
f010c4a0:	8b 40 14             	mov    0x14(%eax),%eax
f010c4a3:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010c4a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c4a9:	c1 e0 05             	shl    $0x5,%eax
f010c4ac:	89 c2                	mov    %eax,%edx
f010c4ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c4b1:	01 d0                	add    %edx,%eax
f010c4b3:	8b 40 10             	mov    0x10(%eax),%eax
f010c4b6:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010c4b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c4bc:	c1 e0 05             	shl    $0x5,%eax
f010c4bf:	89 c2                	mov    %eax,%edx
f010c4c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c4c4:	01 d0                	add    %edx,%eax
f010c4c6:	8b 40 08             	mov    0x8(%eax),%eax
f010c4c9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010c4cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4cf:	89 c3                	mov    %eax,%ebx
f010c4d1:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010c4d4:	ba 05 00 00 00       	mov    $0x5,%edx
f010c4d9:	89 df                	mov    %ebx,%edi
f010c4db:	89 c6                	mov    %eax,%esi
f010c4dd:	89 d1                	mov    %edx,%ecx
f010c4df:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010c4e1:	eb 1c                	jmp    f010c4ff <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010c4e3:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010c4ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4ed:	89 c3                	mov    %eax,%ebx
f010c4ef:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010c4f2:	ba 05 00 00 00       	mov    $0x5,%edx
f010c4f7:	89 df                	mov    %ebx,%edi
f010c4f9:	89 c6                	mov    %eax,%esi
f010c4fb:	89 d1                	mov    %edx,%ecx
f010c4fd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010c4ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010c502:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010c505:	5b                   	pop    %ebx
f010c506:	5e                   	pop    %esi
f010c507:	5f                   	pop    %edi
f010c508:	5d                   	pop    %ebp
f010c509:	c2 04 00             	ret    $0x4

f010c50c <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010c50c:	55                   	push   %ebp
f010c50d:	89 e5                	mov    %esp,%ebp
f010c50f:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010c512:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010c519:	83 ec 0c             	sub    $0xc,%esp
f010c51c:	68 80 b3 6b f0       	push   $0xf06bb380
f010c521:	e8 f2 2f 00 00       	call   f010f518 <acquire_spinlock>
f010c526:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010c529:	a1 70 b3 6b f0       	mov    0xf06bb370,%eax
f010c52e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c531:	e9 c3 00 00 00       	jmp    f010c5f9 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010c536:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c539:	8b 40 0c             	mov    0xc(%eax),%eax
f010c53c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010c53f:	0f 85 ac 00 00 00    	jne    f010c5f1 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010c545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c548:	8b 50 10             	mov    0x10(%eax),%edx
f010c54b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c54e:	8b 40 0c             	mov    0xc(%eax),%eax
f010c551:	8b 40 64             	mov    0x64(%eax),%eax
f010c554:	83 ec 08             	sub    $0x8,%esp
f010c557:	52                   	push   %edx
f010c558:	50                   	push   %eax
f010c559:	e8 79 d0 ff ff       	call   f01095d7 <pt_clear_page_table_entry>
f010c55e:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010c561:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c565:	75 17                	jne    f010c57e <cleanup_buffers+0x72>
f010c567:	83 ec 04             	sub    $0x4,%esp
f010c56a:	68 1b 5b 12 f0       	push   $0xf0125b1b
f010c56f:	68 c6 04 00 00       	push   $0x4c6
f010c574:	68 93 5a 12 f0       	push   $0xf0125a93
f010c579:	e8 bb 3d ff ff       	call   f0100339 <_panic>
f010c57e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c581:	8b 00                	mov    (%eax),%eax
f010c583:	85 c0                	test   %eax,%eax
f010c585:	74 10                	je     f010c597 <cleanup_buffers+0x8b>
f010c587:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c58a:	8b 00                	mov    (%eax),%eax
f010c58c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c58f:	8b 52 04             	mov    0x4(%edx),%edx
f010c592:	89 50 04             	mov    %edx,0x4(%eax)
f010c595:	eb 0b                	jmp    f010c5a2 <cleanup_buffers+0x96>
f010c597:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c59a:	8b 40 04             	mov    0x4(%eax),%eax
f010c59d:	a3 74 b3 6b f0       	mov    %eax,0xf06bb374
f010c5a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5a5:	8b 40 04             	mov    0x4(%eax),%eax
f010c5a8:	85 c0                	test   %eax,%eax
f010c5aa:	74 0f                	je     f010c5bb <cleanup_buffers+0xaf>
f010c5ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5af:	8b 40 04             	mov    0x4(%eax),%eax
f010c5b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c5b5:	8b 12                	mov    (%edx),%edx
f010c5b7:	89 10                	mov    %edx,(%eax)
f010c5b9:	eb 0a                	jmp    f010c5c5 <cleanup_buffers+0xb9>
f010c5bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5be:	8b 00                	mov    (%eax),%eax
f010c5c0:	a3 70 b3 6b f0       	mov    %eax,0xf06bb370
f010c5c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5c8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010c5ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5d1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010c5d8:	a1 7c b3 6b f0       	mov    0xf06bb37c,%eax
f010c5dd:	48                   	dec    %eax
f010c5de:	a3 7c b3 6b f0       	mov    %eax,0xf06bb37c

				free_frame(ptr_fi);
f010c5e3:	83 ec 0c             	sub    $0xc,%esp
f010c5e6:	ff 75 f4             	pushl  -0xc(%ebp)
f010c5e9:	e8 18 bd ff ff       	call   f0108306 <free_frame>
f010c5ee:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010c5f1:	a1 78 b3 6b f0       	mov    0xf06bb378,%eax
f010c5f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c5f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c5fd:	74 07                	je     f010c606 <cleanup_buffers+0xfa>
f010c5ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c602:	8b 00                	mov    (%eax),%eax
f010c604:	eb 05                	jmp    f010c60b <cleanup_buffers+0xff>
f010c606:	b8 00 00 00 00       	mov    $0x0,%eax
f010c60b:	a3 78 b3 6b f0       	mov    %eax,0xf06bb378
f010c610:	a1 78 b3 6b f0       	mov    0xf06bb378,%eax
f010c615:	85 c0                	test   %eax,%eax
f010c617:	0f 85 19 ff ff ff    	jne    f010c536 <cleanup_buffers+0x2a>
f010c61d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c621:	0f 85 0f ff ff ff    	jne    f010c536 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010c627:	83 ec 0c             	sub    $0xc,%esp
f010c62a:	68 80 b3 6b f0       	push   $0xf06bb380
f010c62f:	e8 6b 2f 00 00       	call   f010f59f <release_spinlock>
f010c634:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010c637:	90                   	nop
f010c638:	c9                   	leave  
f010c639:	c3                   	ret    

f010c63a <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010c63a:	55                   	push   %ebp
f010c63b:	89 e5                	mov    %esp,%ebp
f010c63d:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010c640:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010c644:	7e 06                	jle    f010c64c <set_program_priority+0x12>
f010c646:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010c64a:	7e 14                	jle    f010c660 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010c64c:	83 ec 04             	sub    $0x4,%esp
f010c64f:	68 58 5d 12 f0       	push   $0xf0125d58
f010c654:	6a 10                	push   $0x10
f010c656:	68 7c 5d 12 f0       	push   $0xf0125d7c
f010c65b:	e8 d9 3c ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010c660:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c664:	74 78                	je     f010c6de <set_program_priority+0xa4>
		return;
	switch(priority)
f010c666:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010c66a:	77 56                	ja     f010c6c2 <set_program_priority+0x88>
f010c66c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c66f:	c1 e0 02             	shl    $0x2,%eax
f010c672:	05 b8 5d 12 f0       	add    $0xf0125db8,%eax
f010c677:	8b 00                	mov    (%eax),%eax
f010c679:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010c67b:	83 ec 08             	sub    $0x8,%esp
f010c67e:	6a 01                	push   $0x1
f010c680:	ff 75 08             	pushl  0x8(%ebp)
f010c683:	e8 a6 dc ff ff       	call   f010a32e <half_WS_Size>
f010c688:	83 c4 10             	add    $0x10,%esp
			break;
f010c68b:	eb 35                	jmp    f010c6c2 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010c68d:	83 ec 08             	sub    $0x8,%esp
f010c690:	6a 00                	push   $0x0
f010c692:	ff 75 08             	pushl  0x8(%ebp)
f010c695:	e8 94 dc ff ff       	call   f010a32e <half_WS_Size>
f010c69a:	83 c4 10             	add    $0x10,%esp
			break;
f010c69d:	eb 23                	jmp    f010c6c2 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010c69f:	83 ec 08             	sub    $0x8,%esp
f010c6a2:	6a 01                	push   $0x1
f010c6a4:	ff 75 08             	pushl  0x8(%ebp)
f010c6a7:	e8 65 dc ff ff       	call   f010a311 <double_WS_Size>
f010c6ac:	83 c4 10             	add    $0x10,%esp
			break;
f010c6af:	eb 11                	jmp    f010c6c2 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010c6b1:	83 ec 08             	sub    $0x8,%esp
f010c6b4:	6a 00                	push   $0x0
f010c6b6:	ff 75 08             	pushl  0x8(%ebp)
f010c6b9:	e8 53 dc ff ff       	call   f010a311 <double_WS_Size>
f010c6be:	83 c4 10             	add    $0x10,%esp
			break;
f010c6c1:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010c6c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6c5:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c6cb:	83 ec 08             	sub    $0x8,%esp
f010c6ce:	50                   	push   %eax
f010c6cf:	68 99 5d 12 f0       	push   $0xf0125d99
f010c6d4:	e8 b2 48 ff ff       	call   f0100f8b <cprintf>
f010c6d9:	83 c4 10             	add    $0x10,%esp
f010c6dc:	eb 01                	jmp    f010c6df <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010c6de:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010c6df:	c9                   	leave  
f010c6e0:	c3                   	ret    

f010c6e1 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010c6e1:	55                   	push   %ebp
f010c6e2:	89 e5                	mov    %esp,%ebp
f010c6e4:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c6e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c6ee:	eb 29                	jmp    f010c719 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010c6f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c6f3:	89 d0                	mov    %edx,%eax
f010c6f5:	01 c0                	add    %eax,%eax
f010c6f7:	01 d0                	add    %edx,%eax
f010c6f9:	c1 e0 02             	shl    $0x2,%eax
f010c6fc:	05 80 e9 17 f0       	add    $0xf017e980,%eax
f010c701:	8b 00                	mov    (%eax),%eax
f010c703:	83 ec 08             	sub    $0x8,%esp
f010c706:	50                   	push   %eax
f010c707:	ff 75 08             	pushl  0x8(%ebp)
f010c70a:	e8 d6 2e 01 00       	call   f011f5e5 <strcmp>
f010c70f:	83 c4 10             	add    $0x10,%esp
f010c712:	85 c0                	test   %eax,%eax
f010c714:	74 0f                	je     f010c725 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c716:	ff 45 f4             	incl   -0xc(%ebp)
f010c719:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c71e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c721:	7c cd                	jl     f010c6f0 <get_user_program_info+0xf>
f010c723:	eb 01                	jmp    f010c726 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010c725:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010c726:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c72b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c72e:	75 1a                	jne    f010c74a <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010c730:	83 ec 08             	sub    $0x8,%esp
f010c733:	ff 75 08             	pushl  0x8(%ebp)
f010c736:	68 1d 6b 12 f0       	push   $0xf0126b1d
f010c73b:	e8 4b 48 ff ff       	call   f0100f8b <cprintf>
f010c740:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c743:	b8 00 00 00 00       	mov    $0x0,%eax
f010c748:	eb 11                	jmp    f010c75b <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010c74a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c74d:	89 d0                	mov    %edx,%eax
f010c74f:	01 c0                	add    %eax,%eax
f010c751:	01 d0                	add    %edx,%eax
f010c753:	c1 e0 02             	shl    $0x2,%eax
f010c756:	05 80 e9 17 f0       	add    $0xf017e980,%eax
}
f010c75b:	c9                   	leave  
f010c75c:	c3                   	ret    

f010c75d <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010c75d:	55                   	push   %ebp
f010c75e:	89 e5                	mov    %esp,%ebp
f010c760:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c763:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c76a:	eb 2d                	jmp    f010c799 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010c76c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c76f:	89 d0                	mov    %edx,%eax
f010c771:	01 c0                	add    %eax,%eax
f010c773:	01 d0                	add    %edx,%eax
f010c775:	c1 e0 02             	shl    $0x2,%eax
f010c778:	05 80 e9 17 f0       	add    $0xf017e980,%eax
f010c77d:	8b 00                	mov    (%eax),%eax
f010c77f:	8b 55 08             	mov    0x8(%ebp),%edx
f010c782:	83 c2 20             	add    $0x20,%edx
f010c785:	83 ec 08             	sub    $0x8,%esp
f010c788:	50                   	push   %eax
f010c789:	52                   	push   %edx
f010c78a:	e8 56 2e 01 00       	call   f011f5e5 <strcmp>
f010c78f:	83 c4 10             	add    $0x10,%esp
f010c792:	85 c0                	test   %eax,%eax
f010c794:	74 0f                	je     f010c7a5 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c796:	ff 45 f4             	incl   -0xc(%ebp)
f010c799:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c79e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c7a1:	7c c9                	jl     f010c76c <get_user_program_info_by_env+0xf>
f010c7a3:	eb 01                	jmp    f010c7a6 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010c7a5:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010c7a6:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c7ab:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c7ae:	75 17                	jne    f010c7c7 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010c7b0:	83 ec 0c             	sub    $0xc,%esp
f010c7b3:	68 38 6b 12 f0       	push   $0xf0126b38
f010c7b8:	e8 ce 47 ff ff       	call   f0100f8b <cprintf>
f010c7bd:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c7c0:	b8 00 00 00 00       	mov    $0x0,%eax
f010c7c5:	eb 11                	jmp    f010c7d8 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010c7c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c7ca:	89 d0                	mov    %edx,%eax
f010c7cc:	01 c0                	add    %eax,%eax
f010c7ce:	01 d0                	add    %edx,%eax
f010c7d0:	c1 e0 02             	shl    $0x2,%eax
f010c7d3:	05 80 e9 17 f0       	add    $0xf017e980,%eax
}
f010c7d8:	c9                   	leave  
f010c7d9:	c3                   	ret    

f010c7da <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010c7da:	55                   	push   %ebp
f010c7db:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010c7dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7e0:	83 f8 13             	cmp    $0x13,%eax
f010c7e3:	77 0c                	ja     f010c7f1 <trapname+0x17>
		return excnames[trapno];
f010c7e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7e8:	8b 04 85 20 6f 12 f0 	mov    -0xfed90e0(,%eax,4),%eax
f010c7ef:	eb 2c                	jmp    f010c81d <trapname+0x43>
	if (trapno == T_SYSCALL)
f010c7f1:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010c7f5:	75 07                	jne    f010c7fe <trapname+0x24>
		return "System call";
f010c7f7:	b8 60 6b 12 f0       	mov    $0xf0126b60,%eax
f010c7fc:	eb 1f                	jmp    f010c81d <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010c7fe:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010c802:	75 07                	jne    f010c80b <trapname+0x31>
		return "Clock Interrupt";
f010c804:	b8 6c 6b 12 f0       	mov    $0xf0126b6c,%eax
f010c809:	eb 12                	jmp    f010c81d <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010c80b:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010c80f:	75 07                	jne    f010c818 <trapname+0x3e>
		return "Keyboard Interrupt";
f010c811:	b8 7c 6b 12 f0       	mov    $0xf0126b7c,%eax
f010c816:	eb 05                	jmp    f010c81d <trapname+0x43>
	return "(unknown trap)";
f010c818:	b8 8f 6b 12 f0       	mov    $0xf0126b8f,%eax
}
f010c81d:	5d                   	pop    %ebp
f010c81e:	c3                   	ret    

f010c81f <ts_init>:


void ts_init(void)
{
f010c81f:	55                   	push   %ebp
f010c820:	89 e5                	mov    %esp,%ebp
f010c822:	53                   	push   %ebx
f010c823:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010c826:	e8 a4 a9 ff ff       	call   f01071cf <pushcli>

	struct cpu* c = mycpu();
f010c82b:	e8 dc a8 ff ff       	call   f010710c <mycpu>
f010c830:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010c833:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c836:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c83d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c840:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c846:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c849:	83 c0 0c             	add    $0xc,%eax
f010c84c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c84f:	83 c2 0c             	add    $0xc,%edx
f010c852:	c1 ea 10             	shr    $0x10,%edx
f010c855:	88 d3                	mov    %dl,%bl
f010c857:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c85a:	83 c2 0c             	add    $0xc,%edx
f010c85d:	c1 ea 18             	shr    $0x18,%edx
f010c860:	88 d1                	mov    %dl,%cl
f010c862:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c865:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c86c:	68 00 
f010c86e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c871:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c878:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c87b:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c881:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c884:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c88a:	83 e2 f0             	and    $0xfffffff0,%edx
f010c88d:	83 ca 09             	or     $0x9,%edx
f010c890:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c896:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c899:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c89f:	83 ca 10             	or     $0x10,%edx
f010c8a2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c8a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8ab:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c8b1:	83 e2 9f             	and    $0xffffff9f,%edx
f010c8b4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c8ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8bd:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c8c3:	83 ca 80             	or     $0xffffff80,%edx
f010c8c6:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c8cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8cf:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c8d5:	83 e2 f0             	and    $0xfffffff0,%edx
f010c8d8:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c8de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8e1:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c8e7:	83 e2 ef             	and    $0xffffffef,%edx
f010c8ea:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c8f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8f3:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c8f9:	83 e2 df             	and    $0xffffffdf,%edx
f010c8fc:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c902:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c905:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c90b:	83 ca 40             	or     $0x40,%edx
f010c90e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c914:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c917:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c91d:	83 e2 7f             	and    $0x7f,%edx
f010c920:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c926:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c929:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010c92f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c932:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c938:	83 e2 ef             	and    $0xffffffef,%edx
f010c93b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010c941:	e8 db a8 ff ff       	call   f0107221 <popcli>
f010c946:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010c94c:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010c950:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010c953:	90                   	nop
f010c954:	83 c4 14             	add    $0x14,%esp
f010c957:	5b                   	pop    %ebx
f010c958:	5d                   	pop    %ebp
f010c959:	c3                   	ret    

f010c95a <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010c95a:	55                   	push   %ebp
f010c95b:	89 e5                	mov    %esp,%ebp
f010c95d:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010c960:	b8 08 de 10 f0       	mov    $0xf010de08,%eax
f010c965:	66 a3 40 28 69 f0    	mov    %ax,0xf0692840
f010c96b:	66 c7 05 42 28 69 f0 	movw   $0x8,0xf0692842
f010c972:	08 00 
f010c974:	a0 44 28 69 f0       	mov    0xf0692844,%al
f010c979:	83 e0 e0             	and    $0xffffffe0,%eax
f010c97c:	a2 44 28 69 f0       	mov    %al,0xf0692844
f010c981:	a0 44 28 69 f0       	mov    0xf0692844,%al
f010c986:	83 e0 1f             	and    $0x1f,%eax
f010c989:	a2 44 28 69 f0       	mov    %al,0xf0692844
f010c98e:	a0 45 28 69 f0       	mov    0xf0692845,%al
f010c993:	83 e0 f0             	and    $0xfffffff0,%eax
f010c996:	83 c8 0e             	or     $0xe,%eax
f010c999:	a2 45 28 69 f0       	mov    %al,0xf0692845
f010c99e:	a0 45 28 69 f0       	mov    0xf0692845,%al
f010c9a3:	83 e0 ef             	and    $0xffffffef,%eax
f010c9a6:	a2 45 28 69 f0       	mov    %al,0xf0692845
f010c9ab:	a0 45 28 69 f0       	mov    0xf0692845,%al
f010c9b0:	83 e0 9f             	and    $0xffffff9f,%eax
f010c9b3:	a2 45 28 69 f0       	mov    %al,0xf0692845
f010c9b8:	a0 45 28 69 f0       	mov    0xf0692845,%al
f010c9bd:	83 c8 80             	or     $0xffffff80,%eax
f010c9c0:	a2 45 28 69 f0       	mov    %al,0xf0692845
f010c9c5:	b8 08 de 10 f0       	mov    $0xf010de08,%eax
f010c9ca:	c1 e8 10             	shr    $0x10,%eax
f010c9cd:	66 a3 46 28 69 f0    	mov    %ax,0xf0692846
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010c9d3:	b8 10 de 10 f0       	mov    $0xf010de10,%eax
f010c9d8:	66 a3 70 28 69 f0    	mov    %ax,0xf0692870
f010c9de:	66 c7 05 72 28 69 f0 	movw   $0x8,0xf0692872
f010c9e5:	08 00 
f010c9e7:	a0 74 28 69 f0       	mov    0xf0692874,%al
f010c9ec:	83 e0 e0             	and    $0xffffffe0,%eax
f010c9ef:	a2 74 28 69 f0       	mov    %al,0xf0692874
f010c9f4:	a0 74 28 69 f0       	mov    0xf0692874,%al
f010c9f9:	83 e0 1f             	and    $0x1f,%eax
f010c9fc:	a2 74 28 69 f0       	mov    %al,0xf0692874
f010ca01:	a0 75 28 69 f0       	mov    0xf0692875,%al
f010ca06:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca09:	83 c8 0e             	or     $0xe,%eax
f010ca0c:	a2 75 28 69 f0       	mov    %al,0xf0692875
f010ca11:	a0 75 28 69 f0       	mov    0xf0692875,%al
f010ca16:	83 e0 ef             	and    $0xffffffef,%eax
f010ca19:	a2 75 28 69 f0       	mov    %al,0xf0692875
f010ca1e:	a0 75 28 69 f0       	mov    0xf0692875,%al
f010ca23:	83 e0 9f             	and    $0xffffff9f,%eax
f010ca26:	a2 75 28 69 f0       	mov    %al,0xf0692875
f010ca2b:	a0 75 28 69 f0       	mov    0xf0692875,%al
f010ca30:	83 c8 80             	or     $0xffffff80,%eax
f010ca33:	a2 75 28 69 f0       	mov    %al,0xf0692875
f010ca38:	b8 10 de 10 f0       	mov    $0xf010de10,%eax
f010ca3d:	c1 e8 10             	shr    $0x10,%eax
f010ca40:	66 a3 76 28 69 f0    	mov    %ax,0xf0692876
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010ca46:	b8 18 de 10 f0       	mov    $0xf010de18,%eax
f010ca4b:	66 a3 00 29 69 f0    	mov    %ax,0xf0692900
f010ca51:	66 c7 05 02 29 69 f0 	movw   $0x8,0xf0692902
f010ca58:	08 00 
f010ca5a:	a0 04 29 69 f0       	mov    0xf0692904,%al
f010ca5f:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca62:	a2 04 29 69 f0       	mov    %al,0xf0692904
f010ca67:	a0 04 29 69 f0       	mov    0xf0692904,%al
f010ca6c:	83 e0 1f             	and    $0x1f,%eax
f010ca6f:	a2 04 29 69 f0       	mov    %al,0xf0692904
f010ca74:	a0 05 29 69 f0       	mov    0xf0692905,%al
f010ca79:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca7c:	83 c8 0e             	or     $0xe,%eax
f010ca7f:	a2 05 29 69 f0       	mov    %al,0xf0692905
f010ca84:	a0 05 29 69 f0       	mov    0xf0692905,%al
f010ca89:	83 e0 ef             	and    $0xffffffef,%eax
f010ca8c:	a2 05 29 69 f0       	mov    %al,0xf0692905
f010ca91:	a0 05 29 69 f0       	mov    0xf0692905,%al
f010ca96:	83 c8 60             	or     $0x60,%eax
f010ca99:	a2 05 29 69 f0       	mov    %al,0xf0692905
f010ca9e:	a0 05 29 69 f0       	mov    0xf0692905,%al
f010caa3:	83 c8 80             	or     $0xffffff80,%eax
f010caa6:	a2 05 29 69 f0       	mov    %al,0xf0692905
f010caab:	b8 18 de 10 f0       	mov    $0xf010de18,%eax
f010cab0:	c1 e8 10             	shr    $0x10,%eax
f010cab3:	66 a3 06 29 69 f0    	mov    %ax,0xf0692906
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010cab9:	b8 22 de 10 f0       	mov    $0xf010de22,%eax
f010cabe:	66 a3 08 29 69 f0    	mov    %ax,0xf0692908
f010cac4:	66 c7 05 0a 29 69 f0 	movw   $0x8,0xf069290a
f010cacb:	08 00 
f010cacd:	a0 0c 29 69 f0       	mov    0xf069290c,%al
f010cad2:	83 e0 e0             	and    $0xffffffe0,%eax
f010cad5:	a2 0c 29 69 f0       	mov    %al,0xf069290c
f010cada:	a0 0c 29 69 f0       	mov    0xf069290c,%al
f010cadf:	83 e0 1f             	and    $0x1f,%eax
f010cae2:	a2 0c 29 69 f0       	mov    %al,0xf069290c
f010cae7:	a0 0d 29 69 f0       	mov    0xf069290d,%al
f010caec:	83 e0 f0             	and    $0xfffffff0,%eax
f010caef:	83 c8 0e             	or     $0xe,%eax
f010caf2:	a2 0d 29 69 f0       	mov    %al,0xf069290d
f010caf7:	a0 0d 29 69 f0       	mov    0xf069290d,%al
f010cafc:	83 e0 ef             	and    $0xffffffef,%eax
f010caff:	a2 0d 29 69 f0       	mov    %al,0xf069290d
f010cb04:	a0 0d 29 69 f0       	mov    0xf069290d,%al
f010cb09:	83 c8 60             	or     $0x60,%eax
f010cb0c:	a2 0d 29 69 f0       	mov    %al,0xf069290d
f010cb11:	a0 0d 29 69 f0       	mov    0xf069290d,%al
f010cb16:	83 c8 80             	or     $0xffffff80,%eax
f010cb19:	a2 0d 29 69 f0       	mov    %al,0xf069290d
f010cb1e:	b8 22 de 10 f0       	mov    $0xf010de22,%eax
f010cb23:	c1 e8 10             	shr    $0x10,%eax
f010cb26:	66 a3 0e 29 69 f0    	mov    %ax,0xf069290e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010cb2c:	b8 2c de 10 f0       	mov    $0xf010de2c,%eax
f010cb31:	66 a3 80 29 69 f0    	mov    %ax,0xf0692980
f010cb37:	66 c7 05 82 29 69 f0 	movw   $0x8,0xf0692982
f010cb3e:	08 00 
f010cb40:	a0 84 29 69 f0       	mov    0xf0692984,%al
f010cb45:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb48:	a2 84 29 69 f0       	mov    %al,0xf0692984
f010cb4d:	a0 84 29 69 f0       	mov    0xf0692984,%al
f010cb52:	83 e0 1f             	and    $0x1f,%eax
f010cb55:	a2 84 29 69 f0       	mov    %al,0xf0692984
f010cb5a:	a0 85 29 69 f0       	mov    0xf0692985,%al
f010cb5f:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb62:	83 c8 0e             	or     $0xe,%eax
f010cb65:	a2 85 29 69 f0       	mov    %al,0xf0692985
f010cb6a:	a0 85 29 69 f0       	mov    0xf0692985,%al
f010cb6f:	83 e0 ef             	and    $0xffffffef,%eax
f010cb72:	a2 85 29 69 f0       	mov    %al,0xf0692985
f010cb77:	a0 85 29 69 f0       	mov    0xf0692985,%al
f010cb7c:	83 c8 60             	or     $0x60,%eax
f010cb7f:	a2 85 29 69 f0       	mov    %al,0xf0692985
f010cb84:	a0 85 29 69 f0       	mov    0xf0692985,%al
f010cb89:	83 c8 80             	or     $0xffffff80,%eax
f010cb8c:	a2 85 29 69 f0       	mov    %al,0xf0692985
f010cb91:	b8 2c de 10 f0       	mov    $0xf010de2c,%eax
f010cb96:	c1 e8 10             	shr    $0x10,%eax
f010cb99:	66 a3 86 29 69 f0    	mov    %ax,0xf0692986

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010cb9f:	b8 36 de 10 f0       	mov    $0xf010de36,%eax
f010cba4:	66 a3 00 28 69 f0    	mov    %ax,0xf0692800
f010cbaa:	66 c7 05 02 28 69 f0 	movw   $0x8,0xf0692802
f010cbb1:	08 00 
f010cbb3:	a0 04 28 69 f0       	mov    0xf0692804,%al
f010cbb8:	83 e0 e0             	and    $0xffffffe0,%eax
f010cbbb:	a2 04 28 69 f0       	mov    %al,0xf0692804
f010cbc0:	a0 04 28 69 f0       	mov    0xf0692804,%al
f010cbc5:	83 e0 1f             	and    $0x1f,%eax
f010cbc8:	a2 04 28 69 f0       	mov    %al,0xf0692804
f010cbcd:	a0 05 28 69 f0       	mov    0xf0692805,%al
f010cbd2:	83 e0 f0             	and    $0xfffffff0,%eax
f010cbd5:	83 c8 0e             	or     $0xe,%eax
f010cbd8:	a2 05 28 69 f0       	mov    %al,0xf0692805
f010cbdd:	a0 05 28 69 f0       	mov    0xf0692805,%al
f010cbe2:	83 e0 ef             	and    $0xffffffef,%eax
f010cbe5:	a2 05 28 69 f0       	mov    %al,0xf0692805
f010cbea:	a0 05 28 69 f0       	mov    0xf0692805,%al
f010cbef:	83 c8 60             	or     $0x60,%eax
f010cbf2:	a2 05 28 69 f0       	mov    %al,0xf0692805
f010cbf7:	a0 05 28 69 f0       	mov    0xf0692805,%al
f010cbfc:	83 c8 80             	or     $0xffffff80,%eax
f010cbff:	a2 05 28 69 f0       	mov    %al,0xf0692805
f010cc04:	b8 36 de 10 f0       	mov    $0xf010de36,%eax
f010cc09:	c1 e8 10             	shr    $0x10,%eax
f010cc0c:	66 a3 06 28 69 f0    	mov    %ax,0xf0692806
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010cc12:	b8 40 de 10 f0       	mov    $0xf010de40,%eax
f010cc17:	66 a3 08 28 69 f0    	mov    %ax,0xf0692808
f010cc1d:	66 c7 05 0a 28 69 f0 	movw   $0x8,0xf069280a
f010cc24:	08 00 
f010cc26:	a0 0c 28 69 f0       	mov    0xf069280c,%al
f010cc2b:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc2e:	a2 0c 28 69 f0       	mov    %al,0xf069280c
f010cc33:	a0 0c 28 69 f0       	mov    0xf069280c,%al
f010cc38:	83 e0 1f             	and    $0x1f,%eax
f010cc3b:	a2 0c 28 69 f0       	mov    %al,0xf069280c
f010cc40:	a0 0d 28 69 f0       	mov    0xf069280d,%al
f010cc45:	83 c8 0f             	or     $0xf,%eax
f010cc48:	a2 0d 28 69 f0       	mov    %al,0xf069280d
f010cc4d:	a0 0d 28 69 f0       	mov    0xf069280d,%al
f010cc52:	83 e0 ef             	and    $0xffffffef,%eax
f010cc55:	a2 0d 28 69 f0       	mov    %al,0xf069280d
f010cc5a:	a0 0d 28 69 f0       	mov    0xf069280d,%al
f010cc5f:	83 c8 60             	or     $0x60,%eax
f010cc62:	a2 0d 28 69 f0       	mov    %al,0xf069280d
f010cc67:	a0 0d 28 69 f0       	mov    0xf069280d,%al
f010cc6c:	83 c8 80             	or     $0xffffff80,%eax
f010cc6f:	a2 0d 28 69 f0       	mov    %al,0xf069280d
f010cc74:	b8 40 de 10 f0       	mov    $0xf010de40,%eax
f010cc79:	c1 e8 10             	shr    $0x10,%eax
f010cc7c:	66 a3 0e 28 69 f0    	mov    %ax,0xf069280e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010cc82:	b8 4a de 10 f0       	mov    $0xf010de4a,%eax
f010cc87:	66 a3 10 28 69 f0    	mov    %ax,0xf0692810
f010cc8d:	66 c7 05 12 28 69 f0 	movw   $0x8,0xf0692812
f010cc94:	08 00 
f010cc96:	a0 14 28 69 f0       	mov    0xf0692814,%al
f010cc9b:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc9e:	a2 14 28 69 f0       	mov    %al,0xf0692814
f010cca3:	a0 14 28 69 f0       	mov    0xf0692814,%al
f010cca8:	83 e0 1f             	and    $0x1f,%eax
f010ccab:	a2 14 28 69 f0       	mov    %al,0xf0692814
f010ccb0:	a0 15 28 69 f0       	mov    0xf0692815,%al
f010ccb5:	83 e0 f0             	and    $0xfffffff0,%eax
f010ccb8:	83 c8 0e             	or     $0xe,%eax
f010ccbb:	a2 15 28 69 f0       	mov    %al,0xf0692815
f010ccc0:	a0 15 28 69 f0       	mov    0xf0692815,%al
f010ccc5:	83 e0 ef             	and    $0xffffffef,%eax
f010ccc8:	a2 15 28 69 f0       	mov    %al,0xf0692815
f010cccd:	a0 15 28 69 f0       	mov    0xf0692815,%al
f010ccd2:	83 c8 60             	or     $0x60,%eax
f010ccd5:	a2 15 28 69 f0       	mov    %al,0xf0692815
f010ccda:	a0 15 28 69 f0       	mov    0xf0692815,%al
f010ccdf:	83 c8 80             	or     $0xffffff80,%eax
f010cce2:	a2 15 28 69 f0       	mov    %al,0xf0692815
f010cce7:	b8 4a de 10 f0       	mov    $0xf010de4a,%eax
f010ccec:	c1 e8 10             	shr    $0x10,%eax
f010ccef:	66 a3 16 28 69 f0    	mov    %ax,0xf0692816
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010ccf5:	b8 54 de 10 f0       	mov    $0xf010de54,%eax
f010ccfa:	66 a3 18 28 69 f0    	mov    %ax,0xf0692818
f010cd00:	66 c7 05 1a 28 69 f0 	movw   $0x8,0xf069281a
f010cd07:	08 00 
f010cd09:	a0 1c 28 69 f0       	mov    0xf069281c,%al
f010cd0e:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd11:	a2 1c 28 69 f0       	mov    %al,0xf069281c
f010cd16:	a0 1c 28 69 f0       	mov    0xf069281c,%al
f010cd1b:	83 e0 1f             	and    $0x1f,%eax
f010cd1e:	a2 1c 28 69 f0       	mov    %al,0xf069281c
f010cd23:	a0 1d 28 69 f0       	mov    0xf069281d,%al
f010cd28:	83 c8 0f             	or     $0xf,%eax
f010cd2b:	a2 1d 28 69 f0       	mov    %al,0xf069281d
f010cd30:	a0 1d 28 69 f0       	mov    0xf069281d,%al
f010cd35:	83 e0 ef             	and    $0xffffffef,%eax
f010cd38:	a2 1d 28 69 f0       	mov    %al,0xf069281d
f010cd3d:	a0 1d 28 69 f0       	mov    0xf069281d,%al
f010cd42:	83 c8 60             	or     $0x60,%eax
f010cd45:	a2 1d 28 69 f0       	mov    %al,0xf069281d
f010cd4a:	a0 1d 28 69 f0       	mov    0xf069281d,%al
f010cd4f:	83 c8 80             	or     $0xffffff80,%eax
f010cd52:	a2 1d 28 69 f0       	mov    %al,0xf069281d
f010cd57:	b8 54 de 10 f0       	mov    $0xf010de54,%eax
f010cd5c:	c1 e8 10             	shr    $0x10,%eax
f010cd5f:	66 a3 1e 28 69 f0    	mov    %ax,0xf069281e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010cd65:	b8 5e de 10 f0       	mov    $0xf010de5e,%eax
f010cd6a:	66 a3 20 28 69 f0    	mov    %ax,0xf0692820
f010cd70:	66 c7 05 22 28 69 f0 	movw   $0x8,0xf0692822
f010cd77:	08 00 
f010cd79:	a0 24 28 69 f0       	mov    0xf0692824,%al
f010cd7e:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd81:	a2 24 28 69 f0       	mov    %al,0xf0692824
f010cd86:	a0 24 28 69 f0       	mov    0xf0692824,%al
f010cd8b:	83 e0 1f             	and    $0x1f,%eax
f010cd8e:	a2 24 28 69 f0       	mov    %al,0xf0692824
f010cd93:	a0 25 28 69 f0       	mov    0xf0692825,%al
f010cd98:	83 c8 0f             	or     $0xf,%eax
f010cd9b:	a2 25 28 69 f0       	mov    %al,0xf0692825
f010cda0:	a0 25 28 69 f0       	mov    0xf0692825,%al
f010cda5:	83 e0 ef             	and    $0xffffffef,%eax
f010cda8:	a2 25 28 69 f0       	mov    %al,0xf0692825
f010cdad:	a0 25 28 69 f0       	mov    0xf0692825,%al
f010cdb2:	83 c8 60             	or     $0x60,%eax
f010cdb5:	a2 25 28 69 f0       	mov    %al,0xf0692825
f010cdba:	a0 25 28 69 f0       	mov    0xf0692825,%al
f010cdbf:	83 c8 80             	or     $0xffffff80,%eax
f010cdc2:	a2 25 28 69 f0       	mov    %al,0xf0692825
f010cdc7:	b8 5e de 10 f0       	mov    $0xf010de5e,%eax
f010cdcc:	c1 e8 10             	shr    $0x10,%eax
f010cdcf:	66 a3 26 28 69 f0    	mov    %ax,0xf0692826
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010cdd5:	b8 68 de 10 f0       	mov    $0xf010de68,%eax
f010cdda:	66 a3 28 28 69 f0    	mov    %ax,0xf0692828
f010cde0:	66 c7 05 2a 28 69 f0 	movw   $0x8,0xf069282a
f010cde7:	08 00 
f010cde9:	a0 2c 28 69 f0       	mov    0xf069282c,%al
f010cdee:	83 e0 e0             	and    $0xffffffe0,%eax
f010cdf1:	a2 2c 28 69 f0       	mov    %al,0xf069282c
f010cdf6:	a0 2c 28 69 f0       	mov    0xf069282c,%al
f010cdfb:	83 e0 1f             	and    $0x1f,%eax
f010cdfe:	a2 2c 28 69 f0       	mov    %al,0xf069282c
f010ce03:	a0 2d 28 69 f0       	mov    0xf069282d,%al
f010ce08:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce0b:	83 c8 0e             	or     $0xe,%eax
f010ce0e:	a2 2d 28 69 f0       	mov    %al,0xf069282d
f010ce13:	a0 2d 28 69 f0       	mov    0xf069282d,%al
f010ce18:	83 e0 ef             	and    $0xffffffef,%eax
f010ce1b:	a2 2d 28 69 f0       	mov    %al,0xf069282d
f010ce20:	a0 2d 28 69 f0       	mov    0xf069282d,%al
f010ce25:	83 c8 60             	or     $0x60,%eax
f010ce28:	a2 2d 28 69 f0       	mov    %al,0xf069282d
f010ce2d:	a0 2d 28 69 f0       	mov    0xf069282d,%al
f010ce32:	83 c8 80             	or     $0xffffff80,%eax
f010ce35:	a2 2d 28 69 f0       	mov    %al,0xf069282d
f010ce3a:	b8 68 de 10 f0       	mov    $0xf010de68,%eax
f010ce3f:	c1 e8 10             	shr    $0x10,%eax
f010ce42:	66 a3 2e 28 69 f0    	mov    %ax,0xf069282e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010ce48:	b8 72 de 10 f0       	mov    $0xf010de72,%eax
f010ce4d:	66 a3 30 28 69 f0    	mov    %ax,0xf0692830
f010ce53:	66 c7 05 32 28 69 f0 	movw   $0x8,0xf0692832
f010ce5a:	08 00 
f010ce5c:	a0 34 28 69 f0       	mov    0xf0692834,%al
f010ce61:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce64:	a2 34 28 69 f0       	mov    %al,0xf0692834
f010ce69:	a0 34 28 69 f0       	mov    0xf0692834,%al
f010ce6e:	83 e0 1f             	and    $0x1f,%eax
f010ce71:	a2 34 28 69 f0       	mov    %al,0xf0692834
f010ce76:	a0 35 28 69 f0       	mov    0xf0692835,%al
f010ce7b:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce7e:	83 c8 0e             	or     $0xe,%eax
f010ce81:	a2 35 28 69 f0       	mov    %al,0xf0692835
f010ce86:	a0 35 28 69 f0       	mov    0xf0692835,%al
f010ce8b:	83 e0 ef             	and    $0xffffffef,%eax
f010ce8e:	a2 35 28 69 f0       	mov    %al,0xf0692835
f010ce93:	a0 35 28 69 f0       	mov    0xf0692835,%al
f010ce98:	83 c8 60             	or     $0x60,%eax
f010ce9b:	a2 35 28 69 f0       	mov    %al,0xf0692835
f010cea0:	a0 35 28 69 f0       	mov    0xf0692835,%al
f010cea5:	83 c8 80             	or     $0xffffff80,%eax
f010cea8:	a2 35 28 69 f0       	mov    %al,0xf0692835
f010cead:	b8 72 de 10 f0       	mov    $0xf010de72,%eax
f010ceb2:	c1 e8 10             	shr    $0x10,%eax
f010ceb5:	66 a3 36 28 69 f0    	mov    %ax,0xf0692836
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010cebb:	b8 7c de 10 f0       	mov    $0xf010de7c,%eax
f010cec0:	66 a3 38 28 69 f0    	mov    %ax,0xf0692838
f010cec6:	66 c7 05 3a 28 69 f0 	movw   $0x8,0xf069283a
f010cecd:	08 00 
f010cecf:	a0 3c 28 69 f0       	mov    0xf069283c,%al
f010ced4:	83 e0 e0             	and    $0xffffffe0,%eax
f010ced7:	a2 3c 28 69 f0       	mov    %al,0xf069283c
f010cedc:	a0 3c 28 69 f0       	mov    0xf069283c,%al
f010cee1:	83 e0 1f             	and    $0x1f,%eax
f010cee4:	a2 3c 28 69 f0       	mov    %al,0xf069283c
f010cee9:	a0 3d 28 69 f0       	mov    0xf069283d,%al
f010ceee:	83 e0 f0             	and    $0xfffffff0,%eax
f010cef1:	83 c8 0e             	or     $0xe,%eax
f010cef4:	a2 3d 28 69 f0       	mov    %al,0xf069283d
f010cef9:	a0 3d 28 69 f0       	mov    0xf069283d,%al
f010cefe:	83 e0 ef             	and    $0xffffffef,%eax
f010cf01:	a2 3d 28 69 f0       	mov    %al,0xf069283d
f010cf06:	a0 3d 28 69 f0       	mov    0xf069283d,%al
f010cf0b:	83 c8 60             	or     $0x60,%eax
f010cf0e:	a2 3d 28 69 f0       	mov    %al,0xf069283d
f010cf13:	a0 3d 28 69 f0       	mov    0xf069283d,%al
f010cf18:	83 c8 80             	or     $0xffffff80,%eax
f010cf1b:	a2 3d 28 69 f0       	mov    %al,0xf069283d
f010cf20:	b8 7c de 10 f0       	mov    $0xf010de7c,%eax
f010cf25:	c1 e8 10             	shr    $0x10,%eax
f010cf28:	66 a3 3e 28 69 f0    	mov    %ax,0xf069283e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010cf2e:	b8 82 de 10 f0       	mov    $0xf010de82,%eax
f010cf33:	66 a3 50 28 69 f0    	mov    %ax,0xf0692850
f010cf39:	66 c7 05 52 28 69 f0 	movw   $0x8,0xf0692852
f010cf40:	08 00 
f010cf42:	a0 54 28 69 f0       	mov    0xf0692854,%al
f010cf47:	83 e0 e0             	and    $0xffffffe0,%eax
f010cf4a:	a2 54 28 69 f0       	mov    %al,0xf0692854
f010cf4f:	a0 54 28 69 f0       	mov    0xf0692854,%al
f010cf54:	83 e0 1f             	and    $0x1f,%eax
f010cf57:	a2 54 28 69 f0       	mov    %al,0xf0692854
f010cf5c:	a0 55 28 69 f0       	mov    0xf0692855,%al
f010cf61:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf64:	83 c8 0e             	or     $0xe,%eax
f010cf67:	a2 55 28 69 f0       	mov    %al,0xf0692855
f010cf6c:	a0 55 28 69 f0       	mov    0xf0692855,%al
f010cf71:	83 e0 ef             	and    $0xffffffef,%eax
f010cf74:	a2 55 28 69 f0       	mov    %al,0xf0692855
f010cf79:	a0 55 28 69 f0       	mov    0xf0692855,%al
f010cf7e:	83 c8 60             	or     $0x60,%eax
f010cf81:	a2 55 28 69 f0       	mov    %al,0xf0692855
f010cf86:	a0 55 28 69 f0       	mov    0xf0692855,%al
f010cf8b:	83 c8 80             	or     $0xffffff80,%eax
f010cf8e:	a2 55 28 69 f0       	mov    %al,0xf0692855
f010cf93:	b8 82 de 10 f0       	mov    $0xf010de82,%eax
f010cf98:	c1 e8 10             	shr    $0x10,%eax
f010cf9b:	66 a3 56 28 69 f0    	mov    %ax,0xf0692856
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010cfa1:	b8 86 de 10 f0       	mov    $0xf010de86,%eax
f010cfa6:	66 a3 58 28 69 f0    	mov    %ax,0xf0692858
f010cfac:	66 c7 05 5a 28 69 f0 	movw   $0x8,0xf069285a
f010cfb3:	08 00 
f010cfb5:	a0 5c 28 69 f0       	mov    0xf069285c,%al
f010cfba:	83 e0 e0             	and    $0xffffffe0,%eax
f010cfbd:	a2 5c 28 69 f0       	mov    %al,0xf069285c
f010cfc2:	a0 5c 28 69 f0       	mov    0xf069285c,%al
f010cfc7:	83 e0 1f             	and    $0x1f,%eax
f010cfca:	a2 5c 28 69 f0       	mov    %al,0xf069285c
f010cfcf:	a0 5d 28 69 f0       	mov    0xf069285d,%al
f010cfd4:	83 e0 f0             	and    $0xfffffff0,%eax
f010cfd7:	83 c8 0e             	or     $0xe,%eax
f010cfda:	a2 5d 28 69 f0       	mov    %al,0xf069285d
f010cfdf:	a0 5d 28 69 f0       	mov    0xf069285d,%al
f010cfe4:	83 e0 ef             	and    $0xffffffef,%eax
f010cfe7:	a2 5d 28 69 f0       	mov    %al,0xf069285d
f010cfec:	a0 5d 28 69 f0       	mov    0xf069285d,%al
f010cff1:	83 c8 60             	or     $0x60,%eax
f010cff4:	a2 5d 28 69 f0       	mov    %al,0xf069285d
f010cff9:	a0 5d 28 69 f0       	mov    0xf069285d,%al
f010cffe:	83 c8 80             	or     $0xffffff80,%eax
f010d001:	a2 5d 28 69 f0       	mov    %al,0xf069285d
f010d006:	b8 86 de 10 f0       	mov    $0xf010de86,%eax
f010d00b:	c1 e8 10             	shr    $0x10,%eax
f010d00e:	66 a3 5e 28 69 f0    	mov    %ax,0xf069285e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d014:	b8 8a de 10 f0       	mov    $0xf010de8a,%eax
f010d019:	66 a3 60 28 69 f0    	mov    %ax,0xf0692860
f010d01f:	66 c7 05 62 28 69 f0 	movw   $0x8,0xf0692862
f010d026:	08 00 
f010d028:	a0 64 28 69 f0       	mov    0xf0692864,%al
f010d02d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d030:	a2 64 28 69 f0       	mov    %al,0xf0692864
f010d035:	a0 64 28 69 f0       	mov    0xf0692864,%al
f010d03a:	83 e0 1f             	and    $0x1f,%eax
f010d03d:	a2 64 28 69 f0       	mov    %al,0xf0692864
f010d042:	a0 65 28 69 f0       	mov    0xf0692865,%al
f010d047:	83 e0 f0             	and    $0xfffffff0,%eax
f010d04a:	83 c8 0e             	or     $0xe,%eax
f010d04d:	a2 65 28 69 f0       	mov    %al,0xf0692865
f010d052:	a0 65 28 69 f0       	mov    0xf0692865,%al
f010d057:	83 e0 ef             	and    $0xffffffef,%eax
f010d05a:	a2 65 28 69 f0       	mov    %al,0xf0692865
f010d05f:	a0 65 28 69 f0       	mov    0xf0692865,%al
f010d064:	83 c8 60             	or     $0x60,%eax
f010d067:	a2 65 28 69 f0       	mov    %al,0xf0692865
f010d06c:	a0 65 28 69 f0       	mov    0xf0692865,%al
f010d071:	83 c8 80             	or     $0xffffff80,%eax
f010d074:	a2 65 28 69 f0       	mov    %al,0xf0692865
f010d079:	b8 8a de 10 f0       	mov    $0xf010de8a,%eax
f010d07e:	c1 e8 10             	shr    $0x10,%eax
f010d081:	66 a3 66 28 69 f0    	mov    %ax,0xf0692866
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d087:	b8 8e de 10 f0       	mov    $0xf010de8e,%eax
f010d08c:	66 a3 68 28 69 f0    	mov    %ax,0xf0692868
f010d092:	66 c7 05 6a 28 69 f0 	movw   $0x8,0xf069286a
f010d099:	08 00 
f010d09b:	a0 6c 28 69 f0       	mov    0xf069286c,%al
f010d0a0:	83 e0 e0             	and    $0xffffffe0,%eax
f010d0a3:	a2 6c 28 69 f0       	mov    %al,0xf069286c
f010d0a8:	a0 6c 28 69 f0       	mov    0xf069286c,%al
f010d0ad:	83 e0 1f             	and    $0x1f,%eax
f010d0b0:	a2 6c 28 69 f0       	mov    %al,0xf069286c
f010d0b5:	a0 6d 28 69 f0       	mov    0xf069286d,%al
f010d0ba:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0bd:	83 c8 0e             	or     $0xe,%eax
f010d0c0:	a2 6d 28 69 f0       	mov    %al,0xf069286d
f010d0c5:	a0 6d 28 69 f0       	mov    0xf069286d,%al
f010d0ca:	83 e0 ef             	and    $0xffffffef,%eax
f010d0cd:	a2 6d 28 69 f0       	mov    %al,0xf069286d
f010d0d2:	a0 6d 28 69 f0       	mov    0xf069286d,%al
f010d0d7:	83 c8 60             	or     $0x60,%eax
f010d0da:	a2 6d 28 69 f0       	mov    %al,0xf069286d
f010d0df:	a0 6d 28 69 f0       	mov    0xf069286d,%al
f010d0e4:	83 c8 80             	or     $0xffffff80,%eax
f010d0e7:	a2 6d 28 69 f0       	mov    %al,0xf069286d
f010d0ec:	b8 8e de 10 f0       	mov    $0xf010de8e,%eax
f010d0f1:	c1 e8 10             	shr    $0x10,%eax
f010d0f4:	66 a3 6e 28 69 f0    	mov    %ax,0xf069286e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d0fa:	b8 92 de 10 f0       	mov    $0xf010de92,%eax
f010d0ff:	66 a3 80 28 69 f0    	mov    %ax,0xf0692880
f010d105:	66 c7 05 82 28 69 f0 	movw   $0x8,0xf0692882
f010d10c:	08 00 
f010d10e:	a0 84 28 69 f0       	mov    0xf0692884,%al
f010d113:	83 e0 e0             	and    $0xffffffe0,%eax
f010d116:	a2 84 28 69 f0       	mov    %al,0xf0692884
f010d11b:	a0 84 28 69 f0       	mov    0xf0692884,%al
f010d120:	83 e0 1f             	and    $0x1f,%eax
f010d123:	a2 84 28 69 f0       	mov    %al,0xf0692884
f010d128:	a0 85 28 69 f0       	mov    0xf0692885,%al
f010d12d:	83 e0 f0             	and    $0xfffffff0,%eax
f010d130:	83 c8 0e             	or     $0xe,%eax
f010d133:	a2 85 28 69 f0       	mov    %al,0xf0692885
f010d138:	a0 85 28 69 f0       	mov    0xf0692885,%al
f010d13d:	83 e0 ef             	and    $0xffffffef,%eax
f010d140:	a2 85 28 69 f0       	mov    %al,0xf0692885
f010d145:	a0 85 28 69 f0       	mov    0xf0692885,%al
f010d14a:	83 c8 60             	or     $0x60,%eax
f010d14d:	a2 85 28 69 f0       	mov    %al,0xf0692885
f010d152:	a0 85 28 69 f0       	mov    0xf0692885,%al
f010d157:	83 c8 80             	or     $0xffffff80,%eax
f010d15a:	a2 85 28 69 f0       	mov    %al,0xf0692885
f010d15f:	b8 92 de 10 f0       	mov    $0xf010de92,%eax
f010d164:	c1 e8 10             	shr    $0x10,%eax
f010d167:	66 a3 86 28 69 f0    	mov    %ax,0xf0692886
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d16d:	b8 98 de 10 f0       	mov    $0xf010de98,%eax
f010d172:	66 a3 88 28 69 f0    	mov    %ax,0xf0692888
f010d178:	66 c7 05 8a 28 69 f0 	movw   $0x8,0xf069288a
f010d17f:	08 00 
f010d181:	a0 8c 28 69 f0       	mov    0xf069288c,%al
f010d186:	83 e0 e0             	and    $0xffffffe0,%eax
f010d189:	a2 8c 28 69 f0       	mov    %al,0xf069288c
f010d18e:	a0 8c 28 69 f0       	mov    0xf069288c,%al
f010d193:	83 e0 1f             	and    $0x1f,%eax
f010d196:	a2 8c 28 69 f0       	mov    %al,0xf069288c
f010d19b:	a0 8d 28 69 f0       	mov    0xf069288d,%al
f010d1a0:	83 e0 f0             	and    $0xfffffff0,%eax
f010d1a3:	83 c8 0e             	or     $0xe,%eax
f010d1a6:	a2 8d 28 69 f0       	mov    %al,0xf069288d
f010d1ab:	a0 8d 28 69 f0       	mov    0xf069288d,%al
f010d1b0:	83 e0 ef             	and    $0xffffffef,%eax
f010d1b3:	a2 8d 28 69 f0       	mov    %al,0xf069288d
f010d1b8:	a0 8d 28 69 f0       	mov    0xf069288d,%al
f010d1bd:	83 c8 60             	or     $0x60,%eax
f010d1c0:	a2 8d 28 69 f0       	mov    %al,0xf069288d
f010d1c5:	a0 8d 28 69 f0       	mov    0xf069288d,%al
f010d1ca:	83 c8 80             	or     $0xffffff80,%eax
f010d1cd:	a2 8d 28 69 f0       	mov    %al,0xf069288d
f010d1d2:	b8 98 de 10 f0       	mov    $0xf010de98,%eax
f010d1d7:	c1 e8 10             	shr    $0x10,%eax
f010d1da:	66 a3 8e 28 69 f0    	mov    %ax,0xf069288e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d1e0:	b8 9c de 10 f0       	mov    $0xf010de9c,%eax
f010d1e5:	66 a3 90 28 69 f0    	mov    %ax,0xf0692890
f010d1eb:	66 c7 05 92 28 69 f0 	movw   $0x8,0xf0692892
f010d1f2:	08 00 
f010d1f4:	a0 94 28 69 f0       	mov    0xf0692894,%al
f010d1f9:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1fc:	a2 94 28 69 f0       	mov    %al,0xf0692894
f010d201:	a0 94 28 69 f0       	mov    0xf0692894,%al
f010d206:	83 e0 1f             	and    $0x1f,%eax
f010d209:	a2 94 28 69 f0       	mov    %al,0xf0692894
f010d20e:	a0 95 28 69 f0       	mov    0xf0692895,%al
f010d213:	83 e0 f0             	and    $0xfffffff0,%eax
f010d216:	83 c8 0e             	or     $0xe,%eax
f010d219:	a2 95 28 69 f0       	mov    %al,0xf0692895
f010d21e:	a0 95 28 69 f0       	mov    0xf0692895,%al
f010d223:	83 e0 ef             	and    $0xffffffef,%eax
f010d226:	a2 95 28 69 f0       	mov    %al,0xf0692895
f010d22b:	a0 95 28 69 f0       	mov    0xf0692895,%al
f010d230:	83 c8 60             	or     $0x60,%eax
f010d233:	a2 95 28 69 f0       	mov    %al,0xf0692895
f010d238:	a0 95 28 69 f0       	mov    0xf0692895,%al
f010d23d:	83 c8 80             	or     $0xffffff80,%eax
f010d240:	a2 95 28 69 f0       	mov    %al,0xf0692895
f010d245:	b8 9c de 10 f0       	mov    $0xf010de9c,%eax
f010d24a:	c1 e8 10             	shr    $0x10,%eax
f010d24d:	66 a3 96 28 69 f0    	mov    %ax,0xf0692896
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010d253:	b8 a2 de 10 f0       	mov    $0xf010dea2,%eax
f010d258:	66 a3 98 28 69 f0    	mov    %ax,0xf0692898
f010d25e:	66 c7 05 9a 28 69 f0 	movw   $0x8,0xf069289a
f010d265:	08 00 
f010d267:	a0 9c 28 69 f0       	mov    0xf069289c,%al
f010d26c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d26f:	a2 9c 28 69 f0       	mov    %al,0xf069289c
f010d274:	a0 9c 28 69 f0       	mov    0xf069289c,%al
f010d279:	83 e0 1f             	and    $0x1f,%eax
f010d27c:	a2 9c 28 69 f0       	mov    %al,0xf069289c
f010d281:	a0 9d 28 69 f0       	mov    0xf069289d,%al
f010d286:	83 e0 f0             	and    $0xfffffff0,%eax
f010d289:	83 c8 0e             	or     $0xe,%eax
f010d28c:	a2 9d 28 69 f0       	mov    %al,0xf069289d
f010d291:	a0 9d 28 69 f0       	mov    0xf069289d,%al
f010d296:	83 e0 ef             	and    $0xffffffef,%eax
f010d299:	a2 9d 28 69 f0       	mov    %al,0xf069289d
f010d29e:	a0 9d 28 69 f0       	mov    0xf069289d,%al
f010d2a3:	83 c8 60             	or     $0x60,%eax
f010d2a6:	a2 9d 28 69 f0       	mov    %al,0xf069289d
f010d2ab:	a0 9d 28 69 f0       	mov    0xf069289d,%al
f010d2b0:	83 c8 80             	or     $0xffffff80,%eax
f010d2b3:	a2 9d 28 69 f0       	mov    %al,0xf069289d
f010d2b8:	b8 a2 de 10 f0       	mov    $0xf010dea2,%eax
f010d2bd:	c1 e8 10             	shr    $0x10,%eax
f010d2c0:	66 a3 9e 28 69 f0    	mov    %ax,0xf069289e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010d2c6:	b8 a8 de 10 f0       	mov    $0xf010dea8,%eax
f010d2cb:	66 a3 10 29 69 f0    	mov    %ax,0xf0692910
f010d2d1:	66 c7 05 12 29 69 f0 	movw   $0x8,0xf0692912
f010d2d8:	08 00 
f010d2da:	a0 14 29 69 f0       	mov    0xf0692914,%al
f010d2df:	83 e0 e0             	and    $0xffffffe0,%eax
f010d2e2:	a2 14 29 69 f0       	mov    %al,0xf0692914
f010d2e7:	a0 14 29 69 f0       	mov    0xf0692914,%al
f010d2ec:	83 e0 1f             	and    $0x1f,%eax
f010d2ef:	a2 14 29 69 f0       	mov    %al,0xf0692914
f010d2f4:	a0 15 29 69 f0       	mov    0xf0692915,%al
f010d2f9:	83 e0 f0             	and    $0xfffffff0,%eax
f010d2fc:	83 c8 0e             	or     $0xe,%eax
f010d2ff:	a2 15 29 69 f0       	mov    %al,0xf0692915
f010d304:	a0 15 29 69 f0       	mov    0xf0692915,%al
f010d309:	83 e0 ef             	and    $0xffffffef,%eax
f010d30c:	a2 15 29 69 f0       	mov    %al,0xf0692915
f010d311:	a0 15 29 69 f0       	mov    0xf0692915,%al
f010d316:	83 c8 60             	or     $0x60,%eax
f010d319:	a2 15 29 69 f0       	mov    %al,0xf0692915
f010d31e:	a0 15 29 69 f0       	mov    0xf0692915,%al
f010d323:	83 c8 80             	or     $0xffffff80,%eax
f010d326:	a2 15 29 69 f0       	mov    %al,0xf0692915
f010d32b:	b8 a8 de 10 f0       	mov    $0xf010dea8,%eax
f010d330:	c1 e8 10             	shr    $0x10,%eax
f010d333:	66 a3 16 29 69 f0    	mov    %ax,0xf0692916
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010d339:	b8 ae de 10 f0       	mov    $0xf010deae,%eax
f010d33e:	66 a3 18 29 69 f0    	mov    %ax,0xf0692918
f010d344:	66 c7 05 1a 29 69 f0 	movw   $0x8,0xf069291a
f010d34b:	08 00 
f010d34d:	a0 1c 29 69 f0       	mov    0xf069291c,%al
f010d352:	83 e0 e0             	and    $0xffffffe0,%eax
f010d355:	a2 1c 29 69 f0       	mov    %al,0xf069291c
f010d35a:	a0 1c 29 69 f0       	mov    0xf069291c,%al
f010d35f:	83 e0 1f             	and    $0x1f,%eax
f010d362:	a2 1c 29 69 f0       	mov    %al,0xf069291c
f010d367:	a0 1d 29 69 f0       	mov    0xf069291d,%al
f010d36c:	83 e0 f0             	and    $0xfffffff0,%eax
f010d36f:	83 c8 0e             	or     $0xe,%eax
f010d372:	a2 1d 29 69 f0       	mov    %al,0xf069291d
f010d377:	a0 1d 29 69 f0       	mov    0xf069291d,%al
f010d37c:	83 e0 ef             	and    $0xffffffef,%eax
f010d37f:	a2 1d 29 69 f0       	mov    %al,0xf069291d
f010d384:	a0 1d 29 69 f0       	mov    0xf069291d,%al
f010d389:	83 c8 60             	or     $0x60,%eax
f010d38c:	a2 1d 29 69 f0       	mov    %al,0xf069291d
f010d391:	a0 1d 29 69 f0       	mov    0xf069291d,%al
f010d396:	83 c8 80             	or     $0xffffff80,%eax
f010d399:	a2 1d 29 69 f0       	mov    %al,0xf069291d
f010d39e:	b8 ae de 10 f0       	mov    $0xf010deae,%eax
f010d3a3:	c1 e8 10             	shr    $0x10,%eax
f010d3a6:	66 a3 1e 29 69 f0    	mov    %ax,0xf069291e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010d3ac:	b8 b4 de 10 f0       	mov    $0xf010deb4,%eax
f010d3b1:	66 a3 20 29 69 f0    	mov    %ax,0xf0692920
f010d3b7:	66 c7 05 22 29 69 f0 	movw   $0x8,0xf0692922
f010d3be:	08 00 
f010d3c0:	a0 24 29 69 f0       	mov    0xf0692924,%al
f010d3c5:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3c8:	a2 24 29 69 f0       	mov    %al,0xf0692924
f010d3cd:	a0 24 29 69 f0       	mov    0xf0692924,%al
f010d3d2:	83 e0 1f             	and    $0x1f,%eax
f010d3d5:	a2 24 29 69 f0       	mov    %al,0xf0692924
f010d3da:	a0 25 29 69 f0       	mov    0xf0692925,%al
f010d3df:	83 e0 f0             	and    $0xfffffff0,%eax
f010d3e2:	83 c8 0e             	or     $0xe,%eax
f010d3e5:	a2 25 29 69 f0       	mov    %al,0xf0692925
f010d3ea:	a0 25 29 69 f0       	mov    0xf0692925,%al
f010d3ef:	83 e0 ef             	and    $0xffffffef,%eax
f010d3f2:	a2 25 29 69 f0       	mov    %al,0xf0692925
f010d3f7:	a0 25 29 69 f0       	mov    0xf0692925,%al
f010d3fc:	83 c8 60             	or     $0x60,%eax
f010d3ff:	a2 25 29 69 f0       	mov    %al,0xf0692925
f010d404:	a0 25 29 69 f0       	mov    0xf0692925,%al
f010d409:	83 c8 80             	or     $0xffffff80,%eax
f010d40c:	a2 25 29 69 f0       	mov    %al,0xf0692925
f010d411:	b8 b4 de 10 f0       	mov    $0xf010deb4,%eax
f010d416:	c1 e8 10             	shr    $0x10,%eax
f010d419:	66 a3 26 29 69 f0    	mov    %ax,0xf0692926
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010d41f:	b8 ba de 10 f0       	mov    $0xf010deba,%eax
f010d424:	66 a3 28 29 69 f0    	mov    %ax,0xf0692928
f010d42a:	66 c7 05 2a 29 69 f0 	movw   $0x8,0xf069292a
f010d431:	08 00 
f010d433:	a0 2c 29 69 f0       	mov    0xf069292c,%al
f010d438:	83 e0 e0             	and    $0xffffffe0,%eax
f010d43b:	a2 2c 29 69 f0       	mov    %al,0xf069292c
f010d440:	a0 2c 29 69 f0       	mov    0xf069292c,%al
f010d445:	83 e0 1f             	and    $0x1f,%eax
f010d448:	a2 2c 29 69 f0       	mov    %al,0xf069292c
f010d44d:	a0 2d 29 69 f0       	mov    0xf069292d,%al
f010d452:	83 e0 f0             	and    $0xfffffff0,%eax
f010d455:	83 c8 0e             	or     $0xe,%eax
f010d458:	a2 2d 29 69 f0       	mov    %al,0xf069292d
f010d45d:	a0 2d 29 69 f0       	mov    0xf069292d,%al
f010d462:	83 e0 ef             	and    $0xffffffef,%eax
f010d465:	a2 2d 29 69 f0       	mov    %al,0xf069292d
f010d46a:	a0 2d 29 69 f0       	mov    0xf069292d,%al
f010d46f:	83 c8 60             	or     $0x60,%eax
f010d472:	a2 2d 29 69 f0       	mov    %al,0xf069292d
f010d477:	a0 2d 29 69 f0       	mov    0xf069292d,%al
f010d47c:	83 c8 80             	or     $0xffffff80,%eax
f010d47f:	a2 2d 29 69 f0       	mov    %al,0xf069292d
f010d484:	b8 ba de 10 f0       	mov    $0xf010deba,%eax
f010d489:	c1 e8 10             	shr    $0x10,%eax
f010d48c:	66 a3 2e 29 69 f0    	mov    %ax,0xf069292e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010d492:	b8 c0 de 10 f0       	mov    $0xf010dec0,%eax
f010d497:	66 a3 30 29 69 f0    	mov    %ax,0xf0692930
f010d49d:	66 c7 05 32 29 69 f0 	movw   $0x8,0xf0692932
f010d4a4:	08 00 
f010d4a6:	a0 34 29 69 f0       	mov    0xf0692934,%al
f010d4ab:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4ae:	a2 34 29 69 f0       	mov    %al,0xf0692934
f010d4b3:	a0 34 29 69 f0       	mov    0xf0692934,%al
f010d4b8:	83 e0 1f             	and    $0x1f,%eax
f010d4bb:	a2 34 29 69 f0       	mov    %al,0xf0692934
f010d4c0:	a0 35 29 69 f0       	mov    0xf0692935,%al
f010d4c5:	83 e0 f0             	and    $0xfffffff0,%eax
f010d4c8:	83 c8 0e             	or     $0xe,%eax
f010d4cb:	a2 35 29 69 f0       	mov    %al,0xf0692935
f010d4d0:	a0 35 29 69 f0       	mov    0xf0692935,%al
f010d4d5:	83 e0 ef             	and    $0xffffffef,%eax
f010d4d8:	a2 35 29 69 f0       	mov    %al,0xf0692935
f010d4dd:	a0 35 29 69 f0       	mov    0xf0692935,%al
f010d4e2:	83 c8 60             	or     $0x60,%eax
f010d4e5:	a2 35 29 69 f0       	mov    %al,0xf0692935
f010d4ea:	a0 35 29 69 f0       	mov    0xf0692935,%al
f010d4ef:	83 c8 80             	or     $0xffffff80,%eax
f010d4f2:	a2 35 29 69 f0       	mov    %al,0xf0692935
f010d4f7:	b8 c0 de 10 f0       	mov    $0xf010dec0,%eax
f010d4fc:	c1 e8 10             	shr    $0x10,%eax
f010d4ff:	66 a3 36 29 69 f0    	mov    %ax,0xf0692936
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010d505:	b8 c6 de 10 f0       	mov    $0xf010dec6,%eax
f010d50a:	66 a3 38 29 69 f0    	mov    %ax,0xf0692938
f010d510:	66 c7 05 3a 29 69 f0 	movw   $0x8,0xf069293a
f010d517:	08 00 
f010d519:	a0 3c 29 69 f0       	mov    0xf069293c,%al
f010d51e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d521:	a2 3c 29 69 f0       	mov    %al,0xf069293c
f010d526:	a0 3c 29 69 f0       	mov    0xf069293c,%al
f010d52b:	83 e0 1f             	and    $0x1f,%eax
f010d52e:	a2 3c 29 69 f0       	mov    %al,0xf069293c
f010d533:	a0 3d 29 69 f0       	mov    0xf069293d,%al
f010d538:	83 e0 f0             	and    $0xfffffff0,%eax
f010d53b:	83 c8 0e             	or     $0xe,%eax
f010d53e:	a2 3d 29 69 f0       	mov    %al,0xf069293d
f010d543:	a0 3d 29 69 f0       	mov    0xf069293d,%al
f010d548:	83 e0 ef             	and    $0xffffffef,%eax
f010d54b:	a2 3d 29 69 f0       	mov    %al,0xf069293d
f010d550:	a0 3d 29 69 f0       	mov    0xf069293d,%al
f010d555:	83 c8 60             	or     $0x60,%eax
f010d558:	a2 3d 29 69 f0       	mov    %al,0xf069293d
f010d55d:	a0 3d 29 69 f0       	mov    0xf069293d,%al
f010d562:	83 c8 80             	or     $0xffffff80,%eax
f010d565:	a2 3d 29 69 f0       	mov    %al,0xf069293d
f010d56a:	b8 c6 de 10 f0       	mov    $0xf010dec6,%eax
f010d56f:	c1 e8 10             	shr    $0x10,%eax
f010d572:	66 a3 3e 29 69 f0    	mov    %ax,0xf069293e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010d578:	b8 cc de 10 f0       	mov    $0xf010decc,%eax
f010d57d:	66 a3 40 29 69 f0    	mov    %ax,0xf0692940
f010d583:	66 c7 05 42 29 69 f0 	movw   $0x8,0xf0692942
f010d58a:	08 00 
f010d58c:	a0 44 29 69 f0       	mov    0xf0692944,%al
f010d591:	83 e0 e0             	and    $0xffffffe0,%eax
f010d594:	a2 44 29 69 f0       	mov    %al,0xf0692944
f010d599:	a0 44 29 69 f0       	mov    0xf0692944,%al
f010d59e:	83 e0 1f             	and    $0x1f,%eax
f010d5a1:	a2 44 29 69 f0       	mov    %al,0xf0692944
f010d5a6:	a0 45 29 69 f0       	mov    0xf0692945,%al
f010d5ab:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5ae:	83 c8 0e             	or     $0xe,%eax
f010d5b1:	a2 45 29 69 f0       	mov    %al,0xf0692945
f010d5b6:	a0 45 29 69 f0       	mov    0xf0692945,%al
f010d5bb:	83 e0 ef             	and    $0xffffffef,%eax
f010d5be:	a2 45 29 69 f0       	mov    %al,0xf0692945
f010d5c3:	a0 45 29 69 f0       	mov    0xf0692945,%al
f010d5c8:	83 c8 60             	or     $0x60,%eax
f010d5cb:	a2 45 29 69 f0       	mov    %al,0xf0692945
f010d5d0:	a0 45 29 69 f0       	mov    0xf0692945,%al
f010d5d5:	83 c8 80             	or     $0xffffff80,%eax
f010d5d8:	a2 45 29 69 f0       	mov    %al,0xf0692945
f010d5dd:	b8 cc de 10 f0       	mov    $0xf010decc,%eax
f010d5e2:	c1 e8 10             	shr    $0x10,%eax
f010d5e5:	66 a3 46 29 69 f0    	mov    %ax,0xf0692946
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010d5eb:	b8 d2 de 10 f0       	mov    $0xf010ded2,%eax
f010d5f0:	66 a3 48 29 69 f0    	mov    %ax,0xf0692948
f010d5f6:	66 c7 05 4a 29 69 f0 	movw   $0x8,0xf069294a
f010d5fd:	08 00 
f010d5ff:	a0 4c 29 69 f0       	mov    0xf069294c,%al
f010d604:	83 e0 e0             	and    $0xffffffe0,%eax
f010d607:	a2 4c 29 69 f0       	mov    %al,0xf069294c
f010d60c:	a0 4c 29 69 f0       	mov    0xf069294c,%al
f010d611:	83 e0 1f             	and    $0x1f,%eax
f010d614:	a2 4c 29 69 f0       	mov    %al,0xf069294c
f010d619:	a0 4d 29 69 f0       	mov    0xf069294d,%al
f010d61e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d621:	83 c8 0e             	or     $0xe,%eax
f010d624:	a2 4d 29 69 f0       	mov    %al,0xf069294d
f010d629:	a0 4d 29 69 f0       	mov    0xf069294d,%al
f010d62e:	83 e0 ef             	and    $0xffffffef,%eax
f010d631:	a2 4d 29 69 f0       	mov    %al,0xf069294d
f010d636:	a0 4d 29 69 f0       	mov    0xf069294d,%al
f010d63b:	83 c8 60             	or     $0x60,%eax
f010d63e:	a2 4d 29 69 f0       	mov    %al,0xf069294d
f010d643:	a0 4d 29 69 f0       	mov    0xf069294d,%al
f010d648:	83 c8 80             	or     $0xffffff80,%eax
f010d64b:	a2 4d 29 69 f0       	mov    %al,0xf069294d
f010d650:	b8 d2 de 10 f0       	mov    $0xf010ded2,%eax
f010d655:	c1 e8 10             	shr    $0x10,%eax
f010d658:	66 a3 4e 29 69 f0    	mov    %ax,0xf069294e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010d65e:	b8 d8 de 10 f0       	mov    $0xf010ded8,%eax
f010d663:	66 a3 50 29 69 f0    	mov    %ax,0xf0692950
f010d669:	66 c7 05 52 29 69 f0 	movw   $0x8,0xf0692952
f010d670:	08 00 
f010d672:	a0 54 29 69 f0       	mov    0xf0692954,%al
f010d677:	83 e0 e0             	and    $0xffffffe0,%eax
f010d67a:	a2 54 29 69 f0       	mov    %al,0xf0692954
f010d67f:	a0 54 29 69 f0       	mov    0xf0692954,%al
f010d684:	83 e0 1f             	and    $0x1f,%eax
f010d687:	a2 54 29 69 f0       	mov    %al,0xf0692954
f010d68c:	a0 55 29 69 f0       	mov    0xf0692955,%al
f010d691:	83 e0 f0             	and    $0xfffffff0,%eax
f010d694:	83 c8 0e             	or     $0xe,%eax
f010d697:	a2 55 29 69 f0       	mov    %al,0xf0692955
f010d69c:	a0 55 29 69 f0       	mov    0xf0692955,%al
f010d6a1:	83 e0 ef             	and    $0xffffffef,%eax
f010d6a4:	a2 55 29 69 f0       	mov    %al,0xf0692955
f010d6a9:	a0 55 29 69 f0       	mov    0xf0692955,%al
f010d6ae:	83 c8 60             	or     $0x60,%eax
f010d6b1:	a2 55 29 69 f0       	mov    %al,0xf0692955
f010d6b6:	a0 55 29 69 f0       	mov    0xf0692955,%al
f010d6bb:	83 c8 80             	or     $0xffffff80,%eax
f010d6be:	a2 55 29 69 f0       	mov    %al,0xf0692955
f010d6c3:	b8 d8 de 10 f0       	mov    $0xf010ded8,%eax
f010d6c8:	c1 e8 10             	shr    $0x10,%eax
f010d6cb:	66 a3 56 29 69 f0    	mov    %ax,0xf0692956
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010d6d1:	b8 de de 10 f0       	mov    $0xf010dede,%eax
f010d6d6:	66 a3 58 29 69 f0    	mov    %ax,0xf0692958
f010d6dc:	66 c7 05 5a 29 69 f0 	movw   $0x8,0xf069295a
f010d6e3:	08 00 
f010d6e5:	a0 5c 29 69 f0       	mov    0xf069295c,%al
f010d6ea:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6ed:	a2 5c 29 69 f0       	mov    %al,0xf069295c
f010d6f2:	a0 5c 29 69 f0       	mov    0xf069295c,%al
f010d6f7:	83 e0 1f             	and    $0x1f,%eax
f010d6fa:	a2 5c 29 69 f0       	mov    %al,0xf069295c
f010d6ff:	a0 5d 29 69 f0       	mov    0xf069295d,%al
f010d704:	83 e0 f0             	and    $0xfffffff0,%eax
f010d707:	83 c8 0e             	or     $0xe,%eax
f010d70a:	a2 5d 29 69 f0       	mov    %al,0xf069295d
f010d70f:	a0 5d 29 69 f0       	mov    0xf069295d,%al
f010d714:	83 e0 ef             	and    $0xffffffef,%eax
f010d717:	a2 5d 29 69 f0       	mov    %al,0xf069295d
f010d71c:	a0 5d 29 69 f0       	mov    0xf069295d,%al
f010d721:	83 c8 60             	or     $0x60,%eax
f010d724:	a2 5d 29 69 f0       	mov    %al,0xf069295d
f010d729:	a0 5d 29 69 f0       	mov    0xf069295d,%al
f010d72e:	83 c8 80             	or     $0xffffff80,%eax
f010d731:	a2 5d 29 69 f0       	mov    %al,0xf069295d
f010d736:	b8 de de 10 f0       	mov    $0xf010dede,%eax
f010d73b:	c1 e8 10             	shr    $0x10,%eax
f010d73e:	66 a3 5e 29 69 f0    	mov    %ax,0xf069295e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010d744:	b8 e4 de 10 f0       	mov    $0xf010dee4,%eax
f010d749:	66 a3 60 29 69 f0    	mov    %ax,0xf0692960
f010d74f:	66 c7 05 62 29 69 f0 	movw   $0x8,0xf0692962
f010d756:	08 00 
f010d758:	a0 64 29 69 f0       	mov    0xf0692964,%al
f010d75d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d760:	a2 64 29 69 f0       	mov    %al,0xf0692964
f010d765:	a0 64 29 69 f0       	mov    0xf0692964,%al
f010d76a:	83 e0 1f             	and    $0x1f,%eax
f010d76d:	a2 64 29 69 f0       	mov    %al,0xf0692964
f010d772:	a0 65 29 69 f0       	mov    0xf0692965,%al
f010d777:	83 e0 f0             	and    $0xfffffff0,%eax
f010d77a:	83 c8 0e             	or     $0xe,%eax
f010d77d:	a2 65 29 69 f0       	mov    %al,0xf0692965
f010d782:	a0 65 29 69 f0       	mov    0xf0692965,%al
f010d787:	83 e0 ef             	and    $0xffffffef,%eax
f010d78a:	a2 65 29 69 f0       	mov    %al,0xf0692965
f010d78f:	a0 65 29 69 f0       	mov    0xf0692965,%al
f010d794:	83 c8 60             	or     $0x60,%eax
f010d797:	a2 65 29 69 f0       	mov    %al,0xf0692965
f010d79c:	a0 65 29 69 f0       	mov    0xf0692965,%al
f010d7a1:	83 c8 80             	or     $0xffffff80,%eax
f010d7a4:	a2 65 29 69 f0       	mov    %al,0xf0692965
f010d7a9:	b8 e4 de 10 f0       	mov    $0xf010dee4,%eax
f010d7ae:	c1 e8 10             	shr    $0x10,%eax
f010d7b1:	66 a3 66 29 69 f0    	mov    %ax,0xf0692966
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010d7b7:	b8 ea de 10 f0       	mov    $0xf010deea,%eax
f010d7bc:	66 a3 68 29 69 f0    	mov    %ax,0xf0692968
f010d7c2:	66 c7 05 6a 29 69 f0 	movw   $0x8,0xf069296a
f010d7c9:	08 00 
f010d7cb:	a0 6c 29 69 f0       	mov    0xf069296c,%al
f010d7d0:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7d3:	a2 6c 29 69 f0       	mov    %al,0xf069296c
f010d7d8:	a0 6c 29 69 f0       	mov    0xf069296c,%al
f010d7dd:	83 e0 1f             	and    $0x1f,%eax
f010d7e0:	a2 6c 29 69 f0       	mov    %al,0xf069296c
f010d7e5:	a0 6d 29 69 f0       	mov    0xf069296d,%al
f010d7ea:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7ed:	83 c8 0e             	or     $0xe,%eax
f010d7f0:	a2 6d 29 69 f0       	mov    %al,0xf069296d
f010d7f5:	a0 6d 29 69 f0       	mov    0xf069296d,%al
f010d7fa:	83 e0 ef             	and    $0xffffffef,%eax
f010d7fd:	a2 6d 29 69 f0       	mov    %al,0xf069296d
f010d802:	a0 6d 29 69 f0       	mov    0xf069296d,%al
f010d807:	83 c8 60             	or     $0x60,%eax
f010d80a:	a2 6d 29 69 f0       	mov    %al,0xf069296d
f010d80f:	a0 6d 29 69 f0       	mov    0xf069296d,%al
f010d814:	83 c8 80             	or     $0xffffff80,%eax
f010d817:	a2 6d 29 69 f0       	mov    %al,0xf069296d
f010d81c:	b8 ea de 10 f0       	mov    $0xf010deea,%eax
f010d821:	c1 e8 10             	shr    $0x10,%eax
f010d824:	66 a3 6e 29 69 f0    	mov    %ax,0xf069296e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010d82a:	b8 f0 de 10 f0       	mov    $0xf010def0,%eax
f010d82f:	66 a3 70 29 69 f0    	mov    %ax,0xf0692970
f010d835:	66 c7 05 72 29 69 f0 	movw   $0x8,0xf0692972
f010d83c:	08 00 
f010d83e:	a0 74 29 69 f0       	mov    0xf0692974,%al
f010d843:	83 e0 e0             	and    $0xffffffe0,%eax
f010d846:	a2 74 29 69 f0       	mov    %al,0xf0692974
f010d84b:	a0 74 29 69 f0       	mov    0xf0692974,%al
f010d850:	83 e0 1f             	and    $0x1f,%eax
f010d853:	a2 74 29 69 f0       	mov    %al,0xf0692974
f010d858:	a0 75 29 69 f0       	mov    0xf0692975,%al
f010d85d:	83 e0 f0             	and    $0xfffffff0,%eax
f010d860:	83 c8 0e             	or     $0xe,%eax
f010d863:	a2 75 29 69 f0       	mov    %al,0xf0692975
f010d868:	a0 75 29 69 f0       	mov    0xf0692975,%al
f010d86d:	83 e0 ef             	and    $0xffffffef,%eax
f010d870:	a2 75 29 69 f0       	mov    %al,0xf0692975
f010d875:	a0 75 29 69 f0       	mov    0xf0692975,%al
f010d87a:	83 c8 60             	or     $0x60,%eax
f010d87d:	a2 75 29 69 f0       	mov    %al,0xf0692975
f010d882:	a0 75 29 69 f0       	mov    0xf0692975,%al
f010d887:	83 c8 80             	or     $0xffffff80,%eax
f010d88a:	a2 75 29 69 f0       	mov    %al,0xf0692975
f010d88f:	b8 f0 de 10 f0       	mov    $0xf010def0,%eax
f010d894:	c1 e8 10             	shr    $0x10,%eax
f010d897:	66 a3 76 29 69 f0    	mov    %ax,0xf0692976
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010d89d:	b8 f6 de 10 f0       	mov    $0xf010def6,%eax
f010d8a2:	66 a3 78 29 69 f0    	mov    %ax,0xf0692978
f010d8a8:	66 c7 05 7a 29 69 f0 	movw   $0x8,0xf069297a
f010d8af:	08 00 
f010d8b1:	a0 7c 29 69 f0       	mov    0xf069297c,%al
f010d8b6:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8b9:	a2 7c 29 69 f0       	mov    %al,0xf069297c
f010d8be:	a0 7c 29 69 f0       	mov    0xf069297c,%al
f010d8c3:	83 e0 1f             	and    $0x1f,%eax
f010d8c6:	a2 7c 29 69 f0       	mov    %al,0xf069297c
f010d8cb:	a0 7d 29 69 f0       	mov    0xf069297d,%al
f010d8d0:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8d3:	83 c8 0e             	or     $0xe,%eax
f010d8d6:	a2 7d 29 69 f0       	mov    %al,0xf069297d
f010d8db:	a0 7d 29 69 f0       	mov    0xf069297d,%al
f010d8e0:	83 e0 ef             	and    $0xffffffef,%eax
f010d8e3:	a2 7d 29 69 f0       	mov    %al,0xf069297d
f010d8e8:	a0 7d 29 69 f0       	mov    0xf069297d,%al
f010d8ed:	83 c8 60             	or     $0x60,%eax
f010d8f0:	a2 7d 29 69 f0       	mov    %al,0xf069297d
f010d8f5:	a0 7d 29 69 f0       	mov    0xf069297d,%al
f010d8fa:	83 c8 80             	or     $0xffffff80,%eax
f010d8fd:	a2 7d 29 69 f0       	mov    %al,0xf069297d
f010d902:	b8 f6 de 10 f0       	mov    $0xf010def6,%eax
f010d907:	c1 e8 10             	shr    $0x10,%eax
f010d90a:	66 a3 7e 29 69 f0    	mov    %ax,0xf069297e
f010d910:	c7 45 fc 00 28 69 f0 	movl   $0xf0692800,-0x4(%ebp)
f010d917:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010d91e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010d921:	48                   	dec    %eax
f010d922:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010d926:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d929:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010d92d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d930:	c1 e8 10             	shr    $0x10,%eax
f010d933:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010d937:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010d93a:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010d93d:	90                   	nop
f010d93e:	c9                   	leave  
f010d93f:	c3                   	ret    

f010d940 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010d940:	55                   	push   %ebp
f010d941:	89 e5                	mov    %esp,%ebp
f010d943:	53                   	push   %ebx
f010d944:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010d947:	83 ec 08             	sub    $0x8,%esp
f010d94a:	ff 75 08             	pushl  0x8(%ebp)
f010d94d:	68 9e 6b 12 f0       	push   $0xf0126b9e
f010d952:	e8 34 36 ff ff       	call   f0100f8b <cprintf>
f010d957:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010d95a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d95d:	83 ec 0c             	sub    $0xc,%esp
f010d960:	50                   	push   %eax
f010d961:	e8 fd 00 00 00       	call   f010da63 <print_regs>
f010d966:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010d969:	8b 45 08             	mov    0x8(%ebp),%eax
f010d96c:	8b 40 20             	mov    0x20(%eax),%eax
f010d96f:	0f b7 c0             	movzwl %ax,%eax
f010d972:	83 ec 08             	sub    $0x8,%esp
f010d975:	50                   	push   %eax
f010d976:	68 b0 6b 12 f0       	push   $0xf0126bb0
f010d97b:	e8 0b 36 ff ff       	call   f0100f8b <cprintf>
f010d980:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010d983:	8b 45 08             	mov    0x8(%ebp),%eax
f010d986:	8b 40 24             	mov    0x24(%eax),%eax
f010d989:	0f b7 c0             	movzwl %ax,%eax
f010d98c:	83 ec 08             	sub    $0x8,%esp
f010d98f:	50                   	push   %eax
f010d990:	68 c3 6b 12 f0       	push   $0xf0126bc3
f010d995:	e8 f1 35 ff ff       	call   f0100f8b <cprintf>
f010d99a:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010d99d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d9a0:	8b 58 28             	mov    0x28(%eax),%ebx
f010d9a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010d9a6:	8b 40 28             	mov    0x28(%eax),%eax
f010d9a9:	83 ec 0c             	sub    $0xc,%esp
f010d9ac:	50                   	push   %eax
f010d9ad:	e8 28 ee ff ff       	call   f010c7da <trapname>
f010d9b2:	83 c4 10             	add    $0x10,%esp
f010d9b5:	89 c2                	mov    %eax,%edx
f010d9b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010d9ba:	8b 40 28             	mov    0x28(%eax),%eax
f010d9bd:	53                   	push   %ebx
f010d9be:	52                   	push   %edx
f010d9bf:	50                   	push   %eax
f010d9c0:	68 d6 6b 12 f0       	push   $0xf0126bd6
f010d9c5:	e8 c1 35 ff ff       	call   f0100f8b <cprintf>
f010d9ca:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010d9cd:	8b 45 08             	mov    0x8(%ebp),%eax
f010d9d0:	8b 40 2c             	mov    0x2c(%eax),%eax
f010d9d3:	83 ec 08             	sub    $0x8,%esp
f010d9d6:	50                   	push   %eax
f010d9d7:	68 ed 6b 12 f0       	push   $0xf0126bed
f010d9dc:	e8 aa 35 ff ff       	call   f0100f8b <cprintf>
f010d9e1:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010d9e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010d9e7:	8b 40 30             	mov    0x30(%eax),%eax
f010d9ea:	83 ec 08             	sub    $0x8,%esp
f010d9ed:	50                   	push   %eax
f010d9ee:	68 fc 6b 12 f0       	push   $0xf0126bfc
f010d9f3:	e8 93 35 ff ff       	call   f0100f8b <cprintf>
f010d9f8:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010d9fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010d9fe:	8b 40 34             	mov    0x34(%eax),%eax
f010da01:	0f b7 c0             	movzwl %ax,%eax
f010da04:	83 ec 08             	sub    $0x8,%esp
f010da07:	50                   	push   %eax
f010da08:	68 0b 6c 12 f0       	push   $0xf0126c0b
f010da0d:	e8 79 35 ff ff       	call   f0100f8b <cprintf>
f010da12:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010da15:	8b 45 08             	mov    0x8(%ebp),%eax
f010da18:	8b 40 38             	mov    0x38(%eax),%eax
f010da1b:	83 ec 08             	sub    $0x8,%esp
f010da1e:	50                   	push   %eax
f010da1f:	68 1e 6c 12 f0       	push   $0xf0126c1e
f010da24:	e8 62 35 ff ff       	call   f0100f8b <cprintf>
f010da29:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010da2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010da2f:	8b 40 3c             	mov    0x3c(%eax),%eax
f010da32:	83 ec 08             	sub    $0x8,%esp
f010da35:	50                   	push   %eax
f010da36:	68 2d 6c 12 f0       	push   $0xf0126c2d
f010da3b:	e8 4b 35 ff ff       	call   f0100f8b <cprintf>
f010da40:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010da43:	8b 45 08             	mov    0x8(%ebp),%eax
f010da46:	8b 40 40             	mov    0x40(%eax),%eax
f010da49:	0f b7 c0             	movzwl %ax,%eax
f010da4c:	83 ec 08             	sub    $0x8,%esp
f010da4f:	50                   	push   %eax
f010da50:	68 3c 6c 12 f0       	push   $0xf0126c3c
f010da55:	e8 31 35 ff ff       	call   f0100f8b <cprintf>
f010da5a:	83 c4 10             	add    $0x10,%esp
}
f010da5d:	90                   	nop
f010da5e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010da61:	c9                   	leave  
f010da62:	c3                   	ret    

f010da63 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010da63:	55                   	push   %ebp
f010da64:	89 e5                	mov    %esp,%ebp
f010da66:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010da69:	8b 45 08             	mov    0x8(%ebp),%eax
f010da6c:	8b 00                	mov    (%eax),%eax
f010da6e:	83 ec 08             	sub    $0x8,%esp
f010da71:	50                   	push   %eax
f010da72:	68 4f 6c 12 f0       	push   $0xf0126c4f
f010da77:	e8 0f 35 ff ff       	call   f0100f8b <cprintf>
f010da7c:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010da7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010da82:	8b 40 04             	mov    0x4(%eax),%eax
f010da85:	83 ec 08             	sub    $0x8,%esp
f010da88:	50                   	push   %eax
f010da89:	68 5e 6c 12 f0       	push   $0xf0126c5e
f010da8e:	e8 f8 34 ff ff       	call   f0100f8b <cprintf>
f010da93:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010da96:	8b 45 08             	mov    0x8(%ebp),%eax
f010da99:	8b 40 08             	mov    0x8(%eax),%eax
f010da9c:	83 ec 08             	sub    $0x8,%esp
f010da9f:	50                   	push   %eax
f010daa0:	68 6d 6c 12 f0       	push   $0xf0126c6d
f010daa5:	e8 e1 34 ff ff       	call   f0100f8b <cprintf>
f010daaa:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010daad:	8b 45 08             	mov    0x8(%ebp),%eax
f010dab0:	8b 40 0c             	mov    0xc(%eax),%eax
f010dab3:	83 ec 08             	sub    $0x8,%esp
f010dab6:	50                   	push   %eax
f010dab7:	68 7c 6c 12 f0       	push   $0xf0126c7c
f010dabc:	e8 ca 34 ff ff       	call   f0100f8b <cprintf>
f010dac1:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010dac4:	8b 45 08             	mov    0x8(%ebp),%eax
f010dac7:	8b 40 10             	mov    0x10(%eax),%eax
f010daca:	83 ec 08             	sub    $0x8,%esp
f010dacd:	50                   	push   %eax
f010dace:	68 8b 6c 12 f0       	push   $0xf0126c8b
f010dad3:	e8 b3 34 ff ff       	call   f0100f8b <cprintf>
f010dad8:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010dadb:	8b 45 08             	mov    0x8(%ebp),%eax
f010dade:	8b 40 14             	mov    0x14(%eax),%eax
f010dae1:	83 ec 08             	sub    $0x8,%esp
f010dae4:	50                   	push   %eax
f010dae5:	68 9a 6c 12 f0       	push   $0xf0126c9a
f010daea:	e8 9c 34 ff ff       	call   f0100f8b <cprintf>
f010daef:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010daf2:	8b 45 08             	mov    0x8(%ebp),%eax
f010daf5:	8b 40 18             	mov    0x18(%eax),%eax
f010daf8:	83 ec 08             	sub    $0x8,%esp
f010dafb:	50                   	push   %eax
f010dafc:	68 a9 6c 12 f0       	push   $0xf0126ca9
f010db01:	e8 85 34 ff ff       	call   f0100f8b <cprintf>
f010db06:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010db09:	8b 45 08             	mov    0x8(%ebp),%eax
f010db0c:	8b 40 1c             	mov    0x1c(%eax),%eax
f010db0f:	83 ec 08             	sub    $0x8,%esp
f010db12:	50                   	push   %eax
f010db13:	68 b8 6c 12 f0       	push   $0xf0126cb8
f010db18:	e8 6e 34 ff ff       	call   f0100f8b <cprintf>
f010db1d:	83 c4 10             	add    $0x10,%esp
}
f010db20:	90                   	nop
f010db21:	c9                   	leave  
f010db22:	c3                   	ret    

f010db23 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010db23:	55                   	push   %ebp
f010db24:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010db26:	8b 45 08             	mov    0x8(%ebp),%eax
f010db29:	8b 55 0c             	mov    0xc(%ebp),%edx
f010db2c:	89 14 85 00 30 69 f0 	mov    %edx,-0xf96d000(,%eax,4)
}
f010db33:	90                   	nop
f010db34:	5d                   	pop    %ebp
f010db35:	c3                   	ret    

f010db36 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010db36:	55                   	push   %ebp
f010db37:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010db39:	8b 45 08             	mov    0x8(%ebp),%eax
f010db3c:	c7 04 85 00 30 69 f0 	movl   $0x0,-0xf96d000(,%eax,4)
f010db43:	00 00 00 00 
}
f010db47:	90                   	nop
f010db48:	5d                   	pop    %ebp
f010db49:	c3                   	ret    

f010db4a <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010db4a:	55                   	push   %ebp
f010db4b:	89 e5                	mov    %esp,%ebp
f010db4d:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010db50:	8b 45 08             	mov    0x8(%ebp),%eax
f010db53:	8b 40 28             	mov    0x28(%eax),%eax
f010db56:	83 e8 20             	sub    $0x20,%eax
f010db59:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010db5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010db5f:	8b 04 85 00 30 69 f0 	mov    -0xf96d000(,%eax,4),%eax
f010db66:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010db69:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010db6d:	74 0e                	je     f010db7d <irq_dispatch+0x33>
	{
		handler(tf);
f010db6f:	83 ec 0c             	sub    $0xc,%esp
f010db72:	ff 75 08             	pushl  0x8(%ebp)
f010db75:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010db78:	ff d0                	call   *%eax
f010db7a:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010db7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010db80:	0f b6 c0             	movzbl %al,%eax
f010db83:	83 ec 0c             	sub    $0xc,%esp
f010db86:	50                   	push   %eax
f010db87:	e8 47 95 ff ff       	call   f01070d3 <pic_sendEOI>
f010db8c:	83 c4 10             	add    $0x10,%esp
}
f010db8f:	90                   	nop
f010db90:	c9                   	leave  
f010db91:	c3                   	ret    

f010db92 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010db92:	55                   	push   %ebp
f010db93:	89 e5                	mov    %esp,%ebp
f010db95:	57                   	push   %edi
f010db96:	56                   	push   %esi
f010db97:	53                   	push   %ebx
f010db98:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010db9b:	8b 45 08             	mov    0x8(%ebp),%eax
f010db9e:	8b 40 28             	mov    0x28(%eax),%eax
f010dba1:	83 f8 0e             	cmp    $0xe,%eax
f010dba4:	75 51                	jne    f010dbf7 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010dba6:	a0 40 30 69 f0       	mov    0xf0693040,%al
f010dbab:	84 c0                	test   %al,%al
f010dbad:	74 1f                	je     f010dbce <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010dbaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbb2:	8b 40 30             	mov    0x30(%eax),%eax
f010dbb5:	89 c2                	mov    %eax,%edx
f010dbb7:	a0 40 30 69 f0       	mov    0xf0693040,%al
f010dbbc:	0f b6 c0             	movzbl %al,%eax
f010dbbf:	01 d0                	add    %edx,%eax
f010dbc1:	89 c2                	mov    %eax,%edx
f010dbc3:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbc6:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010dbc9:	e9 0c 01 00 00       	jmp    f010dcda <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010dbce:	83 ec 0c             	sub    $0xc,%esp
f010dbd1:	6a 01                	push   $0x1
f010dbd3:	e8 ed 12 00 00       	call   f010eec5 <isPageReplacmentAlgorithmLRU>
f010dbd8:	83 c4 10             	add    $0x10,%esp
f010dbdb:	85 c0                	test   %eax,%eax
f010dbdd:	74 05                	je     f010dbe4 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010dbdf:	e8 5e 90 ff ff       	call   f0106c42 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010dbe4:	83 ec 0c             	sub    $0xc,%esp
f010dbe7:	ff 75 08             	pushl  0x8(%ebp)
f010dbea:	e8 bb 13 00 00       	call   f010efaa <fault_handler>
f010dbef:	83 c4 10             	add    $0x10,%esp
f010dbf2:	e9 e3 00 00 00       	jmp    f010dcda <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010dbf7:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbfa:	8b 40 28             	mov    0x28(%eax),%eax
f010dbfd:	83 f8 30             	cmp    $0x30,%eax
f010dc00:	75 6e                	jne    f010dc70 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010dc02:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc05:	8b 40 38             	mov    0x38(%eax),%eax
f010dc08:	25 00 02 00 00       	and    $0x200,%eax
f010dc0d:	85 c0                	test   %eax,%eax
f010dc0f:	74 06                	je     f010dc17 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010dc11:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010dc12:	e8 cb 70 ff ff       	call   f0104ce2 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010dc17:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc1a:	8b 78 04             	mov    0x4(%eax),%edi
f010dc1d:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc20:	8b 30                	mov    (%eax),%esi
f010dc22:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc25:	8b 58 10             	mov    0x10(%eax),%ebx
f010dc28:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc2b:	8b 48 18             	mov    0x18(%eax),%ecx
f010dc2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc31:	8b 50 14             	mov    0x14(%eax),%edx
f010dc34:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc37:	8b 40 1c             	mov    0x1c(%eax),%eax
f010dc3a:	83 ec 08             	sub    $0x8,%esp
f010dc3d:	57                   	push   %edi
f010dc3e:	56                   	push   %esi
f010dc3f:	53                   	push   %ebx
f010dc40:	51                   	push   %ecx
f010dc41:	52                   	push   %edx
f010dc42:	50                   	push   %eax
f010dc43:	e8 a4 09 00 00       	call   f010e5ec <syscall>
f010dc48:	83 c4 20             	add    $0x20,%esp
f010dc4b:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010dc4e:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc51:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010dc54:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010dc57:	9c                   	pushf  
f010dc58:	58                   	pop    %eax
f010dc59:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010dc5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010dc5f:	25 00 02 00 00       	and    $0x200,%eax
f010dc64:	85 c0                	test   %eax,%eax
f010dc66:	74 72                	je     f010dcda <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010dc68:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010dc69:	e8 4c 70 ff ff       	call   f0104cba <kclock_stop>
f010dc6e:	eb 6a                	jmp    f010dcda <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010dc70:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc73:	8b 40 28             	mov    0x28(%eax),%eax
f010dc76:	83 f8 08             	cmp    $0x8,%eax
f010dc79:	75 17                	jne    f010dc92 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010dc7b:	83 ec 04             	sub    $0x4,%esp
f010dc7e:	68 c7 6c 12 f0       	push   $0xf0126cc7
f010dc83:	68 22 01 00 00       	push   $0x122
f010dc88:	68 d6 6c 12 f0       	push   $0xf0126cd6
f010dc8d:	e8 a7 26 ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010dc92:	83 ec 0c             	sub    $0xc,%esp
f010dc95:	ff 75 08             	pushl  0x8(%ebp)
f010dc98:	e8 a3 fc ff ff       	call   f010d940 <print_trapframe>
f010dc9d:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010dca0:	8b 45 08             	mov    0x8(%ebp),%eax
f010dca3:	8b 40 34             	mov    0x34(%eax),%eax
f010dca6:	66 83 f8 08          	cmp    $0x8,%ax
f010dcaa:	75 17                	jne    f010dcc3 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010dcac:	83 ec 04             	sub    $0x4,%esp
f010dcaf:	68 e7 6c 12 f0       	push   $0xf0126ce7
f010dcb4:	68 2a 01 00 00       	push   $0x12a
f010dcb9:	68 d6 6c 12 f0       	push   $0xf0126cd6
f010dcbe:	e8 76 26 ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010dcc3:	83 ec 04             	sub    $0x4,%esp
f010dcc6:	68 00 6d 12 f0       	push   $0xf0126d00
f010dccb:	68 2f 01 00 00       	push   $0x12f
f010dcd0:	68 d6 6c 12 f0       	push   $0xf0126cd6
f010dcd5:	e8 5f 26 ff ff       	call   f0100339 <_panic>
		}
	}
}
f010dcda:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010dcdd:	5b                   	pop    %ebx
f010dcde:	5e                   	pop    %esi
f010dcdf:	5f                   	pop    %edi
f010dce0:	5d                   	pop    %ebp
f010dce1:	c3                   	ret    

f010dce2 <trap>:

void trap(struct Trapframe *tf)
{
f010dce2:	55                   	push   %ebp
f010dce3:	89 e5                	mov    %esp,%ebp
f010dce5:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010dce8:	e8 cd 6f ff ff       	call   f0104cba <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010dced:	9c                   	pushf  
f010dcee:	58                   	pop    %eax
f010dcef:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010dcf2:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010dcf5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010dcf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dcfb:	25 00 02 00 00       	and    $0x200,%eax
f010dd00:	85 c0                	test   %eax,%eax
f010dd02:	74 25                	je     f010dd29 <trap+0x47>
	{
		print_trapframe(tf);
f010dd04:	83 ec 0c             	sub    $0xc,%esp
f010dd07:	ff 75 08             	pushl  0x8(%ebp)
f010dd0a:	e8 31 fc ff ff       	call   f010d940 <print_trapframe>
f010dd0f:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010dd12:	83 ec 04             	sub    $0x4,%esp
f010dd15:	68 20 6d 12 f0       	push   $0xf0126d20
f010dd1a:	68 45 01 00 00       	push   $0x145
f010dd1f:	68 d6 6c 12 f0       	push   $0xf0126cd6
f010dd24:	e8 10 26 ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010dd29:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010dd30:	e8 55 d5 ff ff       	call   f010b28a <get_cpu_proc>
f010dd35:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010dd38:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd3b:	8b 40 34             	mov    0x34(%eax),%eax
f010dd3e:	0f b7 c0             	movzwl %ax,%eax
f010dd41:	83 e0 03             	and    $0x3,%eax
f010dd44:	83 f8 03             	cmp    $0x3,%eax
f010dd47:	75 54                	jne    f010dd9d <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010dd49:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010dd4d:	74 0b                	je     f010dd5a <trap+0x78>
f010dd4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010dd52:	8b 40 18             	mov    0x18(%eax),%eax
f010dd55:	83 f8 02             	cmp    $0x2,%eax
f010dd58:	74 19                	je     f010dd73 <trap+0x91>
f010dd5a:	68 64 6d 12 f0       	push   $0xf0126d64
f010dd5f:	68 92 6d 12 f0       	push   $0xf0126d92
f010dd64:	68 4d 01 00 00       	push   $0x14d
f010dd69:	68 d6 6c 12 f0       	push   $0xf0126cd6
f010dd6e:	e8 c6 25 ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010dd73:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010dd76:	8b 00                	mov    (%eax),%eax
f010dd78:	3b 45 08             	cmp    0x8(%ebp),%eax
f010dd7b:	74 19                	je     f010dd96 <trap+0xb4>
f010dd7d:	68 a7 6d 12 f0       	push   $0xf0126da7
f010dd82:	68 92 6d 12 f0       	push   $0xf0126d92
f010dd87:	68 4f 01 00 00       	push   $0x14f
f010dd8c:	68 d6 6c 12 f0       	push   $0xf0126cd6
f010dd91:	e8 a3 25 ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010dd96:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010dd9d:	8b 45 08             	mov    0x8(%ebp),%eax
f010dda0:	8b 40 28             	mov    0x28(%eax),%eax
f010dda3:	83 f8 1f             	cmp    $0x1f,%eax
f010dda6:	76 1b                	jbe    f010ddc3 <trap+0xe1>
f010dda8:	8b 45 08             	mov    0x8(%ebp),%eax
f010ddab:	8b 40 28             	mov    0x28(%eax),%eax
f010ddae:	83 f8 2f             	cmp    $0x2f,%eax
f010ddb1:	77 10                	ja     f010ddc3 <trap+0xe1>
	{
		irq_dispatch(tf);
f010ddb3:	83 ec 0c             	sub    $0xc,%esp
f010ddb6:	ff 75 08             	pushl  0x8(%ebp)
f010ddb9:	e8 8c fd ff ff       	call   f010db4a <irq_dispatch>
f010ddbe:	83 c4 10             	add    $0x10,%esp
f010ddc1:	eb 0e                	jmp    f010ddd1 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010ddc3:	83 ec 0c             	sub    $0xc,%esp
f010ddc6:	ff 75 08             	pushl  0x8(%ebp)
f010ddc9:	e8 c4 fd ff ff       	call   f010db92 <trap_dispatch>
f010ddce:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010ddd1:	9c                   	pushf  
f010ddd2:	58                   	pop    %eax
f010ddd3:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010ddd6:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010ddd9:	25 00 02 00 00       	and    $0x200,%eax
f010ddde:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010dde1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010dde5:	74 19                	je     f010de00 <trap+0x11e>
f010dde7:	68 bd 6d 12 f0       	push   $0xf0126dbd
f010ddec:	68 92 6d 12 f0       	push   $0xf0126d92
f010ddf1:	68 66 01 00 00       	push   $0x166
f010ddf6:	68 d6 6c 12 f0       	push   $0xf0126cd6
f010ddfb:	e8 39 25 ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010de00:	e8 dd 6e ff ff       	call   f0104ce2 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010de05:	90                   	nop
f010de06:	c9                   	leave  
f010de07:	c3                   	ret    

f010de08 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010de08:	6a 08                	push   $0x8
f010de0a:	e9 ed 00 00 00       	jmp    f010defc <_alltraps>
f010de0f:	90                   	nop

f010de10 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010de10:	6a 0e                	push   $0xe
f010de12:	e9 e5 00 00 00       	jmp    f010defc <_alltraps>
f010de17:	90                   	nop

f010de18 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010de18:	6a 00                	push   $0x0
f010de1a:	6a 20                	push   $0x20
f010de1c:	e9 db 00 00 00       	jmp    f010defc <_alltraps>
f010de21:	90                   	nop

f010de22 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010de22:	6a 00                	push   $0x0
f010de24:	6a 21                	push   $0x21
f010de26:	e9 d1 00 00 00       	jmp    f010defc <_alltraps>
f010de2b:	90                   	nop

f010de2c <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010de2c:	6a 00                	push   $0x0
f010de2e:	6a 30                	push   $0x30
f010de30:	e9 c7 00 00 00       	jmp    f010defc <_alltraps>
f010de35:	90                   	nop

f010de36 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010de36:	6a 00                	push   $0x0
f010de38:	6a 00                	push   $0x0
f010de3a:	e9 bd 00 00 00       	jmp    f010defc <_alltraps>
f010de3f:	90                   	nop

f010de40 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010de40:	6a 00                	push   $0x0
f010de42:	6a 01                	push   $0x1
f010de44:	e9 b3 00 00 00       	jmp    f010defc <_alltraps>
f010de49:	90                   	nop

f010de4a <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010de4a:	6a 00                	push   $0x0
f010de4c:	6a 02                	push   $0x2
f010de4e:	e9 a9 00 00 00       	jmp    f010defc <_alltraps>
f010de53:	90                   	nop

f010de54 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010de54:	6a 00                	push   $0x0
f010de56:	6a 03                	push   $0x3
f010de58:	e9 9f 00 00 00       	jmp    f010defc <_alltraps>
f010de5d:	90                   	nop

f010de5e <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010de5e:	6a 00                	push   $0x0
f010de60:	6a 04                	push   $0x4
f010de62:	e9 95 00 00 00       	jmp    f010defc <_alltraps>
f010de67:	90                   	nop

f010de68 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010de68:	6a 00                	push   $0x0
f010de6a:	6a 05                	push   $0x5
f010de6c:	e9 8b 00 00 00       	jmp    f010defc <_alltraps>
f010de71:	90                   	nop

f010de72 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010de72:	6a 00                	push   $0x0
f010de74:	6a 06                	push   $0x6
f010de76:	e9 81 00 00 00       	jmp    f010defc <_alltraps>
f010de7b:	90                   	nop

f010de7c <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010de7c:	6a 00                	push   $0x0
f010de7e:	6a 07                	push   $0x7
f010de80:	eb 7a                	jmp    f010defc <_alltraps>

f010de82 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010de82:	6a 0a                	push   $0xa
f010de84:	eb 76                	jmp    f010defc <_alltraps>

f010de86 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010de86:	6a 0b                	push   $0xb
f010de88:	eb 72                	jmp    f010defc <_alltraps>

f010de8a <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010de8a:	6a 0c                	push   $0xc
f010de8c:	eb 6e                	jmp    f010defc <_alltraps>

f010de8e <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010de8e:	6a 0d                	push   $0xd
f010de90:	eb 6a                	jmp    f010defc <_alltraps>

f010de92 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010de92:	6a 00                	push   $0x0
f010de94:	6a 10                	push   $0x10
f010de96:	eb 64                	jmp    f010defc <_alltraps>

f010de98 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010de98:	6a 11                	push   $0x11
f010de9a:	eb 60                	jmp    f010defc <_alltraps>

f010de9c <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010de9c:	6a 00                	push   $0x0
f010de9e:	6a 12                	push   $0x12
f010dea0:	eb 5a                	jmp    f010defc <_alltraps>

f010dea2 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010dea2:	6a 00                	push   $0x0
f010dea4:	6a 13                	push   $0x13
f010dea6:	eb 54                	jmp    f010defc <_alltraps>

f010dea8 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010dea8:	6a 00                	push   $0x0
f010deaa:	6a 22                	push   $0x22
f010deac:	eb 4e                	jmp    f010defc <_alltraps>

f010deae <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010deae:	6a 00                	push   $0x0
f010deb0:	6a 23                	push   $0x23
f010deb2:	eb 48                	jmp    f010defc <_alltraps>

f010deb4 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010deb4:	6a 00                	push   $0x0
f010deb6:	6a 24                	push   $0x24
f010deb8:	eb 42                	jmp    f010defc <_alltraps>

f010deba <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010deba:	6a 00                	push   $0x0
f010debc:	6a 25                	push   $0x25
f010debe:	eb 3c                	jmp    f010defc <_alltraps>

f010dec0 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010dec0:	6a 00                	push   $0x0
f010dec2:	6a 26                	push   $0x26
f010dec4:	eb 36                	jmp    f010defc <_alltraps>

f010dec6 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010dec6:	6a 00                	push   $0x0
f010dec8:	6a 27                	push   $0x27
f010deca:	eb 30                	jmp    f010defc <_alltraps>

f010decc <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010decc:	6a 00                	push   $0x0
f010dece:	6a 28                	push   $0x28
f010ded0:	eb 2a                	jmp    f010defc <_alltraps>

f010ded2 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010ded2:	6a 00                	push   $0x0
f010ded4:	6a 29                	push   $0x29
f010ded6:	eb 24                	jmp    f010defc <_alltraps>

f010ded8 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010ded8:	6a 00                	push   $0x0
f010deda:	6a 2a                	push   $0x2a
f010dedc:	eb 1e                	jmp    f010defc <_alltraps>

f010dede <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010dede:	6a 00                	push   $0x0
f010dee0:	6a 2b                	push   $0x2b
f010dee2:	eb 18                	jmp    f010defc <_alltraps>

f010dee4 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010dee4:	6a 00                	push   $0x0
f010dee6:	6a 2c                	push   $0x2c
f010dee8:	eb 12                	jmp    f010defc <_alltraps>

f010deea <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010deea:	6a 00                	push   $0x0
f010deec:	6a 2d                	push   $0x2d
f010deee:	eb 0c                	jmp    f010defc <_alltraps>

f010def0 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010def0:	6a 00                	push   $0x0
f010def2:	6a 2e                	push   $0x2e
f010def4:	eb 06                	jmp    f010defc <_alltraps>

f010def6 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010def6:	6a 00                	push   $0x0
f010def8:	6a 2f                	push   $0x2f
f010defa:	eb 00                	jmp    f010defc <_alltraps>

f010defc <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010defc:	1e                   	push   %ds
push 	%es
f010defd:	06                   	push   %es
pushal
f010defe:	60                   	pusha  

mov 	$(GD_KD), %ax
f010deff:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010df03:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010df05:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010df07:	54                   	push   %esp
call 	trap
f010df08:	e8 d5 fd ff ff       	call   f010dce2 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010df0d:	59                   	pop    %ecx

f010df0e <trapret>:
.globl trapret
trapret:
popal
f010df0e:	61                   	popa   
pop 	%es
f010df0f:	07                   	pop    %es
pop 	%ds
f010df10:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010df11:	83 c4 08             	add    $0x8,%esp
iret
f010df14:	cf                   	iret   

f010df15 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010df15:	55                   	push   %ebp
f010df16:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010df18:	8b 45 08             	mov    0x8(%ebp),%eax
f010df1b:	8b 15 c0 b7 6b f0    	mov    0xf06bb7c0,%edx
f010df21:	29 d0                	sub    %edx,%eax
f010df23:	c1 f8 03             	sar    $0x3,%eax
f010df26:	89 c2                	mov    %eax,%edx
f010df28:	89 d0                	mov    %edx,%eax
f010df2a:	c1 e0 02             	shl    $0x2,%eax
f010df2d:	01 d0                	add    %edx,%eax
f010df2f:	c1 e0 02             	shl    $0x2,%eax
f010df32:	01 d0                	add    %edx,%eax
f010df34:	c1 e0 02             	shl    $0x2,%eax
f010df37:	01 d0                	add    %edx,%eax
f010df39:	89 c1                	mov    %eax,%ecx
f010df3b:	c1 e1 08             	shl    $0x8,%ecx
f010df3e:	01 c8                	add    %ecx,%eax
f010df40:	89 c1                	mov    %eax,%ecx
f010df42:	c1 e1 10             	shl    $0x10,%ecx
f010df45:	01 c8                	add    %ecx,%eax
f010df47:	01 c0                	add    %eax,%eax
f010df49:	01 d0                	add    %edx,%eax
}
f010df4b:	5d                   	pop    %ebp
f010df4c:	c3                   	ret    

f010df4d <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010df4d:	55                   	push   %ebp
f010df4e:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010df50:	ff 75 08             	pushl  0x8(%ebp)
f010df53:	e8 bd ff ff ff       	call   f010df15 <to_frame_number>
f010df58:	83 c4 04             	add    $0x4,%esp
f010df5b:	c1 e0 0c             	shl    $0xc,%eax
}
f010df5e:	c9                   	leave  
f010df5f:	c3                   	ret    

f010df60 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010df60:	55                   	push   %ebp
f010df61:	89 e5                	mov    %esp,%ebp
f010df63:	83 ec 18             	sub    $0x18,%esp
f010df66:	8b 45 10             	mov    0x10(%ebp),%eax
f010df69:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010df6c:	e8 5e 92 ff ff       	call   f01071cf <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010df71:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010df75:	74 23                	je     f010df9a <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010df77:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010df7c:	8b 40 10             	mov    0x10(%eax),%eax
f010df7f:	8b 15 a0 1f b0 f0    	mov    0xf0b01fa0,%edx
f010df85:	83 c2 20             	add    $0x20,%edx
f010df88:	83 ec 04             	sub    $0x4,%esp
f010df8b:	50                   	push   %eax
f010df8c:	52                   	push   %edx
f010df8d:	68 70 6f 12 f0       	push   $0xf0126f70
f010df92:	e8 f4 2f ff ff       	call   f0100f8b <cprintf>
f010df97:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010df9a:	83 ec 04             	sub    $0x4,%esp
f010df9d:	ff 75 08             	pushl  0x8(%ebp)
f010dfa0:	ff 75 0c             	pushl  0xc(%ebp)
f010dfa3:	68 79 6f 12 f0       	push   $0xf0126f79
f010dfa8:	e8 de 2f ff ff       	call   f0100f8b <cprintf>
f010dfad:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010dfb0:	e8 6c 92 ff ff       	call   f0107221 <popcli>
}
f010dfb5:	90                   	nop
f010dfb6:	c9                   	leave  
f010dfb7:	c3                   	ret    

f010dfb8 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010dfb8:	55                   	push   %ebp
f010dfb9:	89 e5                	mov    %esp,%ebp
f010dfbb:	83 ec 18             	sub    $0x18,%esp
f010dfbe:	8b 45 08             	mov    0x8(%ebp),%eax
f010dfc1:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010dfc4:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010dfc8:	83 ec 08             	sub    $0x8,%esp
f010dfcb:	50                   	push   %eax
f010dfcc:	68 7e 6f 12 f0       	push   $0xf0126f7e
f010dfd1:	e8 b5 2f ff ff       	call   f0100f8b <cprintf>
f010dfd6:	83 c4 10             	add    $0x10,%esp
}
f010dfd9:	90                   	nop
f010dfda:	c9                   	leave  
f010dfdb:	c3                   	ret    

f010dfdc <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010dfdc:	55                   	push   %ebp
f010dfdd:	89 e5                	mov    %esp,%ebp
f010dfdf:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010dfe2:	9c                   	pushf  
f010dfe3:	58                   	pop    %eax
f010dfe4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010dfe7:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010dfea:	25 00 02 00 00       	and    $0x200,%eax
f010dfef:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010dff2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010dff6:	74 10                	je     f010e008 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010dff8:	e8 c7 2d ff ff       	call   f0100dc4 <cons_getc2>
f010dffd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e000:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e004:	74 f2                	je     f010dff8 <sys_cgetc+0x1c>
f010e006:	eb 0e                	jmp    f010e016 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e008:	e8 5c 2d ff ff       	call   f0100d69 <cons_getc>
f010e00d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e010:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e014:	74 f2                	je     f010e008 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e016:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e019:	c9                   	leave  
f010e01a:	c3                   	ret    

f010e01b <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e01b:	55                   	push   %ebp
f010e01c:	89 e5                	mov    %esp,%ebp
f010e01e:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e021:	e8 8a 2e ff ff       	call   f0100eb0 <cons_lock>
}
f010e026:	90                   	nop
f010e027:	c9                   	leave  
f010e028:	c3                   	ret    

f010e029 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e029:	55                   	push   %ebp
f010e02a:	89 e5                	mov    %esp,%ebp
f010e02c:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e02f:	e8 c3 2e ff ff       	call   f0100ef7 <cons_unlock>
}
f010e034:	90                   	nop
f010e035:	c9                   	leave  
f010e036:	c3                   	ret    

f010e037 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e037:	55                   	push   %ebp
f010e038:	89 e5                	mov    %esp,%ebp
f010e03a:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010e03d:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e042:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010e045:	83 ec 0c             	sub    $0xc,%esp
f010e048:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e04b:	50                   	push   %eax
f010e04c:	e8 61 a1 ff ff       	call   f01081b2 <allocate_frame>
f010e051:	83 c4 10             	add    $0x10,%esp
f010e054:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e057:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e05b:	75 08                	jne    f010e065 <__sys_allocate_page+0x2e>
		return r ;
f010e05d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e060:	e9 e9 00 00 00       	jmp    f010e14e <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e065:	8b 45 08             	mov    0x8(%ebp),%eax
f010e068:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e06d:	77 0c                	ja     f010e07b <__sys_allocate_page+0x44>
f010e06f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e072:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e077:	85 c0                	test   %eax,%eax
f010e079:	74 0a                	je     f010e085 <__sys_allocate_page+0x4e>
		return E_INVAL;
f010e07b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e080:	e9 c9 00 00 00       	jmp    f010e14e <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e085:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e088:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e08d:	83 f8 04             	cmp    $0x4,%eax
f010e090:	74 0a                	je     f010e09c <__sys_allocate_page+0x65>
		return E_INVAL;
f010e092:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e097:	e9 b2 00 00 00       	jmp    f010e14e <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010e09c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e09f:	83 ec 0c             	sub    $0xc,%esp
f010e0a2:	50                   	push   %eax
f010e0a3:	e8 a5 fe ff ff       	call   f010df4d <to_physical_address>
f010e0a8:	83 c4 10             	add    $0x10,%esp
f010e0ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010e0ae:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e0b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e0b4:	8b 40 64             	mov    0x64(%eax),%eax
f010e0b7:	6a 02                	push   $0x2
f010e0b9:	68 00 00 80 ef       	push   $0xef800000
f010e0be:	52                   	push   %edx
f010e0bf:	50                   	push   %eax
f010e0c0:	e8 ba a5 ff ff       	call   f010867f <map_frame>
f010e0c5:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010e0c8:	83 ec 04             	sub    $0x4,%esp
f010e0cb:	68 00 10 00 00       	push   $0x1000
f010e0d0:	6a 00                	push   $0x0
f010e0d2:	68 00 00 80 ef       	push   $0xef800000
f010e0d7:	e8 eb 15 01 00       	call   f011f6c7 <memset>
f010e0dc:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010e0df:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e0e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e0e5:	8b 40 08             	mov    0x8(%eax),%eax
f010e0e8:	40                   	inc    %eax
f010e0e9:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010e0ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e0f0:	8b 40 64             	mov    0x64(%eax),%eax
f010e0f3:	83 ec 08             	sub    $0x8,%esp
f010e0f6:	68 00 00 80 ef       	push   $0xef800000
f010e0fb:	50                   	push   %eax
f010e0fc:	e8 de a6 ff ff       	call   f01087df <unmap_frame>
f010e101:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010e104:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e107:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e10a:	8b 40 08             	mov    0x8(%eax),%eax
f010e10d:	48                   	dec    %eax
f010e10e:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010e112:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e115:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e118:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e11b:	8b 40 64             	mov    0x64(%eax),%eax
f010e11e:	ff 75 0c             	pushl  0xc(%ebp)
f010e121:	51                   	push   %ecx
f010e122:	52                   	push   %edx
f010e123:	50                   	push   %eax
f010e124:	e8 56 a5 ff ff       	call   f010867f <map_frame>
f010e129:	83 c4 10             	add    $0x10,%esp
f010e12c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e12f:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e133:	75 14                	jne    f010e149 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010e135:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e138:	83 ec 0c             	sub    $0xc,%esp
f010e13b:	50                   	push   %eax
f010e13c:	e8 7e a2 ff ff       	call   f01083bf <decrement_references>
f010e141:	83 c4 10             	add    $0x10,%esp
		return r;
f010e144:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e147:	eb 05                	jmp    f010e14e <__sys_allocate_page+0x117>
	}
	return 0 ;
f010e149:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e14e:	c9                   	leave  
f010e14f:	c3                   	ret    

f010e150 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e150:	55                   	push   %ebp
f010e151:	89 e5                	mov    %esp,%ebp
f010e153:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e156:	83 ec 04             	sub    $0x4,%esp
f010e159:	68 81 6f 12 f0       	push   $0xf0126f81
f010e15e:	68 dc 00 00 00       	push   $0xdc
f010e163:	68 9f 6f 12 f0       	push   $0xf0126f9f
f010e168:	e8 cc 21 ff ff       	call   f0100339 <_panic>

f010e16d <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010e16d:	55                   	push   %ebp
f010e16e:	89 e5                	mov    %esp,%ebp
f010e170:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010e173:	83 ec 04             	sub    $0x4,%esp
f010e176:	68 b4 6f 12 f0       	push   $0xf0126fb4
f010e17b:	68 ed 00 00 00       	push   $0xed
f010e180:	68 9f 6f 12 f0       	push   $0xf0126f9f
f010e185:	e8 af 21 ff ff       	call   f0100339 <_panic>

f010e18a <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e18a:	55                   	push   %ebp
f010e18b:	89 e5                	mov    %esp,%ebp
f010e18d:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e190:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e195:	8b 40 64             	mov    0x64(%eax),%eax
f010e198:	83 ec 04             	sub    $0x4,%esp
f010e19b:	ff 75 0c             	pushl  0xc(%ebp)
f010e19e:	ff 75 08             	pushl  0x8(%ebp)
f010e1a1:	50                   	push   %eax
f010e1a2:	e8 26 c2 ff ff       	call   f010a3cd <calculate_required_frames>
f010e1a7:	83 c4 10             	add    $0x10,%esp
}
f010e1aa:	c9                   	leave  
f010e1ab:	c3                   	ret    

f010e1ac <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e1ac:	55                   	push   %ebp
f010e1ad:	89 e5                	mov    %esp,%ebp
f010e1af:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e1b2:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e1b5:	83 ec 0c             	sub    $0xc,%esp
f010e1b8:	50                   	push   %eax
f010e1b9:	e8 a3 a7 ff ff       	call   f0108961 <calculate_available_frames>
f010e1be:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e1c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e1c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e1c7:	01 d0                	add    %edx,%eax
}
f010e1c9:	c9                   	leave  
f010e1ca:	c3                   	ret    

f010e1cb <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e1cb:	55                   	push   %ebp
f010e1cc:	89 e5                	mov    %esp,%ebp
f010e1ce:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e1d1:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e1d4:	83 ec 0c             	sub    $0xc,%esp
f010e1d7:	50                   	push   %eax
f010e1d8:	e8 84 a7 ff ff       	call   f0108961 <calculate_available_frames>
f010e1dd:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e1e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e1e3:	c9                   	leave  
f010e1e4:	c3                   	ret    

f010e1e5 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e1e5:	55                   	push   %ebp
f010e1e6:	89 e5                	mov    %esp,%ebp
f010e1e8:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e1eb:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e1ee:	83 ec 0c             	sub    $0xc,%esp
f010e1f1:	50                   	push   %eax
f010e1f2:	e8 6a a7 ff ff       	call   f0108961 <calculate_available_frames>
f010e1f7:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010e1fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010e1fd:	c9                   	leave  
f010e1fe:	c3                   	ret    

f010e1ff <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010e1ff:	55                   	push   %ebp
f010e200:	89 e5                	mov    %esp,%ebp
f010e202:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010e205:	83 ec 0c             	sub    $0xc,%esp
f010e208:	ff 75 08             	pushl  0x8(%ebp)
f010e20b:	e8 60 00 01 00       	call   f011e270 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010e210:	83 c4 10             	add    $0x10,%esp
}
f010e213:	c9                   	leave  
f010e214:	c3                   	ret    

f010e215 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010e215:	55                   	push   %ebp
f010e216:	89 e5                	mov    %esp,%ebp
f010e218:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010e21b:	e8 7b ff 00 00       	call   f011e19b <scarce_memory>
}
f010e220:	90                   	nop
f010e221:	c9                   	leave  
f010e222:	c3                   	ret    

f010e223 <sys_clearFFL>:

void sys_clearFFL()
{
f010e223:	55                   	push   %ebp
f010e224:	89 e5                	mov    %esp,%ebp
f010e226:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010e229:	83 ec 0c             	sub    $0xc,%esp
f010e22c:	68 80 b3 6b f0       	push   $0xf06bb380
f010e231:	e8 e2 12 00 00       	call   f010f518 <acquire_spinlock>
f010e236:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010e239:	a1 6c b3 6b f0       	mov    0xf06bb36c,%eax
f010e23e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e241:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e248:	eb 12                	jmp    f010e25c <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010e24a:	83 ec 0c             	sub    $0xc,%esp
f010e24d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e250:	50                   	push   %eax
f010e251:	e8 5c 9f ff ff       	call   f01081b2 <allocate_frame>
f010e256:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e259:	ff 45 f4             	incl   -0xc(%ebp)
f010e25c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e25f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e262:	7c e6                	jl     f010e24a <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010e264:	83 ec 0c             	sub    $0xc,%esp
f010e267:	68 80 b3 6b f0       	push   $0xf06bb380
f010e26c:	e8 2e 13 00 00       	call   f010f59f <release_spinlock>
f010e271:	83 c4 10             	add    $0x10,%esp
}
f010e274:	90                   	nop
f010e275:	c9                   	leave  
f010e276:	c3                   	ret    

f010e277 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010e277:	55                   	push   %ebp
f010e278:	89 e5                	mov    %esp,%ebp
f010e27a:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010e27d:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e282:	83 ec 0c             	sub    $0xc,%esp
f010e285:	50                   	push   %eax
f010e286:	e8 74 65 ff ff       	call   f01047ff <pf_calculate_allocated_pages>
f010e28b:	83 c4 10             	add    $0x10,%esp
}
f010e28e:	c9                   	leave  
f010e28f:	c3                   	ret    

f010e290 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010e290:	55                   	push   %ebp
f010e291:	89 e5                	mov    %esp,%ebp
f010e293:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010e296:	e8 ed 0c 00 00       	call   f010ef88 <isBufferingEnabled>
f010e29b:	84 c0                	test   %al,%al
f010e29d:	74 19                	je     f010e2b8 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010e29f:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e2a4:	83 ec 04             	sub    $0x4,%esp
f010e2a7:	ff 75 0c             	pushl  0xc(%ebp)
f010e2aa:	ff 75 08             	pushl  0x8(%ebp)
f010e2ad:	50                   	push   %eax
f010e2ae:	e8 49 c3 ff ff       	call   f010a5fc <__free_user_mem_with_buffering>
f010e2b3:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010e2b6:	eb 18                	jmp    f010e2d0 <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010e2b8:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e2bd:	83 ec 04             	sub    $0x4,%esp
f010e2c0:	ff 75 0c             	pushl  0xc(%ebp)
f010e2c3:	ff 75 08             	pushl  0x8(%ebp)
f010e2c6:	50                   	push   %eax
f010e2c7:	e8 60 c2 ff ff       	call   f010a52c <free_user_mem>
f010e2cc:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010e2cf:	90                   	nop
}
f010e2d0:	c9                   	leave  
f010e2d1:	c3                   	ret    

f010e2d2 <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010e2d2:	55                   	push   %ebp
f010e2d3:	89 e5                	mov    %esp,%ebp
f010e2d5:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010e2d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e2dc:	75 07                	jne    f010e2e5 <check_Param+0x13>
	{
		env_exit();
f010e2de:	e8 65 cf ff ff       	call   f010b248 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010e2e3:	eb 25                	jmp    f010e30a <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010e2e5:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010e2ec:	77 07                	ja     f010e2f5 <check_Param+0x23>
f010e2ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2f1:	85 c0                	test   %eax,%eax
f010e2f3:	78 07                	js     f010e2fc <check_Param+0x2a>
	{
		env_exit();
f010e2f5:	e8 4e cf ff ff       	call   f010b248 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010e2fa:	eb 0e                	jmp    f010e30a <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010e2fc:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010e303:	76 05                	jbe    f010e30a <check_Param+0x38>
	{
		env_exit();
f010e305:	e8 3e cf ff ff       	call   f010b248 <env_exit>
	}
}
f010e30a:	90                   	nop
f010e30b:	c9                   	leave  
f010e30c:	c3                   	ret    

f010e30d <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010e30d:	55                   	push   %ebp
f010e30e:	89 e5                	mov    %esp,%ebp
f010e310:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010e313:	83 ec 0c             	sub    $0xc,%esp
f010e316:	ff 75 08             	pushl  0x8(%ebp)
f010e319:	e8 b4 ff ff ff       	call   f010e2d2 <check_Param>
f010e31e:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010e321:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e326:	83 ec 04             	sub    $0x4,%esp
f010e329:	ff 75 0c             	pushl  0xc(%ebp)
f010e32c:	ff 75 08             	pushl  0x8(%ebp)
f010e32f:	50                   	push   %eax
f010e330:	e8 3c c1 ff ff       	call   f010a471 <allocate_user_mem>
f010e335:	83 c4 10             	add    $0x10,%esp
	return;
f010e338:	90                   	nop
}
f010e339:	c9                   	leave  
f010e33a:	c3                   	ret    

f010e33b <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010e33b:	55                   	push   %ebp
f010e33c:	89 e5                	mov    %esp,%ebp
f010e33e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010e341:	83 ec 0c             	sub    $0xc,%esp
f010e344:	ff 75 08             	pushl  0x8(%ebp)
f010e347:	e8 86 ff ff ff       	call   f010e2d2 <check_Param>
f010e34c:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010e34f:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e354:	8b 40 64             	mov    0x64(%eax),%eax
f010e357:	ff 75 10             	pushl  0x10(%ebp)
f010e35a:	ff 75 0c             	pushl  0xc(%ebp)
f010e35d:	ff 75 08             	pushl  0x8(%ebp)
f010e360:	50                   	push   %eax
f010e361:	e8 33 c0 ff ff       	call   f010a399 <allocate_chunk>
f010e366:	83 c4 10             	add    $0x10,%esp
	return;
f010e369:	90                   	nop
}
f010e36a:	c9                   	leave  
f010e36b:	c3                   	ret    

f010e36c <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010e36c:	55                   	push   %ebp
f010e36d:	89 e5                	mov    %esp,%ebp
f010e36f:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010e372:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e377:	ff 75 10             	pushl  0x10(%ebp)
f010e37a:	ff 75 0c             	pushl  0xc(%ebp)
f010e37d:	ff 75 08             	pushl  0x8(%ebp)
f010e380:	50                   	push   %eax
f010e381:	e8 93 c2 ff ff       	call   f010a619 <move_user_mem>
f010e386:	83 c4 10             	add    $0x10,%esp
	return;
f010e389:	90                   	nop
}
f010e38a:	c9                   	leave  
f010e38b:	c3                   	ret    

f010e38c <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010e38c:	55                   	push   %ebp
f010e38d:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010e38f:	a1 a4 b7 6b f0       	mov    0xf06bb7a4,%eax
}
f010e394:	5d                   	pop    %ebp
f010e395:	c3                   	ret    

f010e396 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010e396:	55                   	push   %ebp
f010e397:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010e399:	8b 45 08             	mov    0x8(%ebp),%eax
f010e39c:	a3 a4 b7 6b f0       	mov    %eax,0xf06bb7a4
}
f010e3a1:	90                   	nop
f010e3a2:	5d                   	pop    %ebp
f010e3a3:	c3                   	ret    

f010e3a4 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010e3a4:	55                   	push   %ebp
f010e3a5:	89 e5                	mov    %esp,%ebp
f010e3a7:	83 ec 18             	sub    $0x18,%esp
f010e3aa:	8b 45 10             	mov    0x10(%ebp),%eax
f010e3ad:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010e3b0:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010e3b4:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e3b9:	8b 40 10             	mov    0x10(%eax),%eax
f010e3bc:	83 ec 0c             	sub    $0xc,%esp
f010e3bf:	ff 75 14             	pushl  0x14(%ebp)
f010e3c2:	52                   	push   %edx
f010e3c3:	ff 75 0c             	pushl  0xc(%ebp)
f010e3c6:	ff 75 08             	pushl  0x8(%ebp)
f010e3c9:	50                   	push   %eax
f010e3ca:	e8 68 a8 ff ff       	call   f0108c37 <createSharedObject>
f010e3cf:	83 c4 20             	add    $0x20,%esp
}
f010e3d2:	c9                   	leave  
f010e3d3:	c3                   	ret    

f010e3d4 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010e3d4:	55                   	push   %ebp
f010e3d5:	89 e5                	mov    %esp,%ebp
f010e3d7:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010e3da:	83 ec 08             	sub    $0x8,%esp
f010e3dd:	ff 75 0c             	pushl  0xc(%ebp)
f010e3e0:	ff 75 08             	pushl  0x8(%ebp)
f010e3e3:	e8 98 a6 ff ff       	call   f0108a80 <getSizeOfSharedObject>
f010e3e8:	83 c4 10             	add    $0x10,%esp
}
f010e3eb:	c9                   	leave  
f010e3ec:	c3                   	ret    

f010e3ed <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010e3ed:	55                   	push   %ebp
f010e3ee:	89 e5                	mov    %esp,%ebp
f010e3f0:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010e3f3:	83 ec 04             	sub    $0x4,%esp
f010e3f6:	ff 75 10             	pushl  0x10(%ebp)
f010e3f9:	ff 75 0c             	pushl  0xc(%ebp)
f010e3fc:	ff 75 08             	pushl  0x8(%ebp)
f010e3ff:	e8 d1 a9 ff ff       	call   f0108dd5 <getSharedObject>
f010e404:	83 c4 10             	add    $0x10,%esp
}
f010e407:	c9                   	leave  
f010e408:	c3                   	ret    

f010e409 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010e409:	55                   	push   %ebp
f010e40a:	89 e5                	mov    %esp,%ebp
f010e40c:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010e40f:	83 ec 08             	sub    $0x8,%esp
f010e412:	ff 75 0c             	pushl  0xc(%ebp)
f010e415:	ff 75 08             	pushl  0x8(%ebp)
f010e418:	e8 f2 a9 ff ff       	call   f0108e0f <freeSharedObject>
f010e41d:	83 c4 10             	add    $0x10,%esp
}
f010e420:	c9                   	leave  
f010e421:	c3                   	ret    

f010e422 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010e422:	55                   	push   %ebp
f010e423:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010e425:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e42a:	8b 40 10             	mov    0x10(%eax),%eax
}
f010e42d:	5d                   	pop    %ebp
f010e42e:	c3                   	ret    

f010e42f <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010e42f:	55                   	push   %ebp
f010e430:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010e432:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e437:	89 c2                	mov    %eax,%edx
f010e439:	a1 d0 27 69 f0       	mov    0xf06927d0,%eax
f010e43e:	29 c2                	sub    %eax,%edx
f010e440:	89 d0                	mov    %edx,%eax
f010e442:	c1 f8 02             	sar    $0x2,%eax
f010e445:	89 c2                	mov    %eax,%edx
f010e447:	89 d0                	mov    %edx,%eax
f010e449:	c1 e0 03             	shl    $0x3,%eax
f010e44c:	01 d0                	add    %edx,%eax
f010e44e:	c1 e0 03             	shl    $0x3,%eax
f010e451:	01 d0                	add    %edx,%eax
f010e453:	c1 e0 02             	shl    $0x2,%eax
f010e456:	01 d0                	add    %edx,%eax
f010e458:	01 c0                	add    %eax,%eax
f010e45a:	01 d0                	add    %edx,%eax
f010e45c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010e463:	01 c8                	add    %ecx,%eax
f010e465:	c1 e0 02             	shl    $0x2,%eax
f010e468:	01 d0                	add    %edx,%eax
f010e46a:	c1 e0 03             	shl    $0x3,%eax
f010e46d:	01 d0                	add    %edx,%eax
f010e46f:	c1 e0 05             	shl    $0x5,%eax
f010e472:	29 d0                	sub    %edx,%eax
f010e474:	c1 e0 02             	shl    $0x2,%eax
f010e477:	01 d0                	add    %edx,%eax
f010e479:	01 c0                	add    %eax,%eax
f010e47b:	01 d0                	add    %edx,%eax
f010e47d:	c1 e0 03             	shl    $0x3,%eax
f010e480:	01 d0                	add    %edx,%eax
f010e482:	c1 e0 04             	shl    $0x4,%eax
f010e485:	29 d0                	sub    %edx,%eax
}
f010e487:	5d                   	pop    %ebp
f010e488:	c3                   	ret    

f010e489 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010e489:	55                   	push   %ebp
f010e48a:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010e48c:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e491:	8b 40 14             	mov    0x14(%eax),%eax
}
f010e494:	5d                   	pop    %ebp
f010e495:	c3                   	ret    

f010e496 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010e496:	55                   	push   %ebp
f010e497:	89 e5                	mov    %esp,%ebp
f010e499:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010e49c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e4a0:	75 0a                	jne    f010e4ac <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010e4a2:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e4a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e4aa:	eb 22                	jmp    f010e4ce <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010e4ac:	83 ec 04             	sub    $0x4,%esp
f010e4af:	6a 00                	push   $0x0
f010e4b1:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010e4b4:	50                   	push   %eax
f010e4b5:	ff 75 08             	pushl  0x8(%ebp)
f010e4b8:	e8 1d ce ff ff       	call   f010b2da <envid2env>
f010e4bd:	83 c4 10             	add    $0x10,%esp
f010e4c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e4c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e4c7:	79 05                	jns    f010e4ce <sys_destroy_env+0x38>
	{
		return r;
f010e4c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e4cc:	eb 5e                	jmp    f010e52c <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010e4ce:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e4d1:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e4d6:	39 c2                	cmp    %eax,%edx
f010e4d8:	75 1b                	jne    f010e4f5 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010e4da:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e4df:	8b 40 10             	mov    0x10(%eax),%eax
f010e4e2:	83 ec 08             	sub    $0x8,%esp
f010e4e5:	50                   	push   %eax
f010e4e6:	68 d3 6f 12 f0       	push   $0xf0126fd3
f010e4eb:	e8 9b 2a ff ff       	call   f0100f8b <cprintf>
f010e4f0:	83 c4 10             	add    $0x10,%esp
f010e4f3:	eb 20                	jmp    f010e515 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010e4f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e4f8:	8b 50 10             	mov    0x10(%eax),%edx
f010e4fb:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e500:	8b 40 10             	mov    0x10(%eax),%eax
f010e503:	83 ec 04             	sub    $0x4,%esp
f010e506:	52                   	push   %edx
f010e507:	50                   	push   %eax
f010e508:	68 ee 6f 12 f0       	push   $0xf0126fee
f010e50d:	e8 79 2a ff ff       	call   f0100f8b <cprintf>
f010e512:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010e515:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e518:	8b 40 10             	mov    0x10(%eax),%eax
f010e51b:	83 ec 0c             	sub    $0xc,%esp
f010e51e:	50                   	push   %eax
f010e51f:	e8 94 75 ff ff       	call   f0105ab8 <sched_kill_env>
f010e524:	83 c4 10             	add    $0x10,%esp

	return 0;
f010e527:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e52c:	c9                   	leave  
f010e52d:	c3                   	ret    

f010e52e <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010e52e:	55                   	push   %ebp
f010e52f:	89 e5                	mov    %esp,%ebp
f010e531:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010e534:	e8 0f cd ff ff       	call   f010b248 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010e539:	90                   	nop
f010e53a:	c9                   	leave  
f010e53b:	c3                   	ret    

f010e53c <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010e53c:	55                   	push   %ebp
f010e53d:	89 e5                	mov    %esp,%ebp
f010e53f:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010e542:	ff 75 14             	pushl  0x14(%ebp)
f010e545:	ff 75 10             	pushl  0x10(%ebp)
f010e548:	ff 75 0c             	pushl  0xc(%ebp)
f010e54b:	ff 75 08             	pushl  0x8(%ebp)
f010e54e:	e8 b9 c2 ff ff       	call   f010a80c <env_create>
f010e553:	83 c4 10             	add    $0x10,%esp
f010e556:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010e559:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e55d:	75 07                	jne    f010e566 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010e55f:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010e564:	eb 14                	jmp    f010e57a <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010e566:	83 ec 0c             	sub    $0xc,%esp
f010e569:	ff 75 f4             	pushl  -0xc(%ebp)
f010e56c:	e8 ab 71 ff ff       	call   f010571c <sched_new_env>
f010e571:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010e574:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e577:	8b 40 10             	mov    0x10(%eax),%eax
}
f010e57a:	c9                   	leave  
f010e57b:	c3                   	ret    

f010e57c <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010e57c:	55                   	push   %ebp
f010e57d:	89 e5                	mov    %esp,%ebp
f010e57f:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010e582:	8b 45 08             	mov    0x8(%ebp),%eax
f010e585:	83 ec 0c             	sub    $0xc,%esp
f010e588:	50                   	push   %eax
f010e589:	e8 e4 71 ff ff       	call   f0105772 <sched_run_env>
f010e58e:	83 c4 10             	add    $0x10,%esp
}
f010e591:	90                   	nop
f010e592:	c9                   	leave  
f010e593:	c3                   	ret    

f010e594 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010e594:	55                   	push   %ebp
f010e595:	89 e5                	mov    %esp,%ebp
f010e597:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010e59a:	0f 31                	rdtsc  
f010e59c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e59f:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010e5a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e5a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e5a8:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e5ab:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010e5ae:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e5b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e5b4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e5b7:	89 01                	mov    %eax,(%ecx)
f010e5b9:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010e5bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5bf:	c9                   	leave  
f010e5c0:	c2 04 00             	ret    $0x4

f010e5c3 <sys_rcr2>:

uint32 sys_rcr2()
{
f010e5c3:	55                   	push   %ebp
f010e5c4:	89 e5                	mov    %esp,%ebp
f010e5c6:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e5c9:	0f 20 d0             	mov    %cr2,%eax
f010e5cc:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010e5cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010e5d2:	90                   	nop
}
f010e5d3:	c9                   	leave  
f010e5d4:	c3                   	ret    

f010e5d5 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010e5d5:	55                   	push   %ebp
f010e5d6:	89 e5                	mov    %esp,%ebp
f010e5d8:	83 ec 04             	sub    $0x4,%esp
f010e5db:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5de:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010e5e1:	8a 45 fc             	mov    -0x4(%ebp),%al
f010e5e4:	a2 40 30 69 f0       	mov    %al,0xf0693040
}
f010e5e9:	90                   	nop
f010e5ea:	c9                   	leave  
f010e5eb:	c3                   	ret    

f010e5ec <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010e5ec:	55                   	push   %ebp
f010e5ed:	89 e5                	mov    %esp,%ebp
f010e5ef:	56                   	push   %esi
f010e5f0:	53                   	push   %ebx
f010e5f1:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010e5f4:	e8 91 cc ff ff       	call   f010b28a <get_cpu_proc>
f010e5f9:	a3 a0 1f b0 f0       	mov    %eax,0xf0b01fa0
	assert(cur_env != NULL);
f010e5fe:	a1 a0 1f b0 f0       	mov    0xf0b01fa0,%eax
f010e603:	85 c0                	test   %eax,%eax
f010e605:	75 19                	jne    f010e620 <syscall+0x34>
f010e607:	68 06 70 12 f0       	push   $0xf0127006
f010e60c:	68 16 70 12 f0       	push   $0xf0127016
f010e611:	68 05 02 00 00       	push   $0x205
f010e616:	68 9f 6f 12 f0       	push   $0xf0126f9f
f010e61b:	e8 19 1d ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010e620:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010e624:	0f 87 06 04 00 00    	ja     f010ea30 <syscall+0x444>
f010e62a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e62d:	c1 e0 02             	shl    $0x2,%eax
f010e630:	05 2c 70 12 f0       	add    $0xf012702c,%eax
f010e635:	8b 00                	mov    (%eax),%eax
f010e637:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010e639:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e63c:	83 ec 0c             	sub    $0xc,%esp
f010e63f:	50                   	push   %eax
f010e640:	e8 a2 bd ff ff       	call   f010a3e7 <sys_sbrk>
f010e645:	83 c4 10             	add    $0x10,%esp
f010e648:	e9 e8 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010e64d:	83 ec 08             	sub    $0x8,%esp
f010e650:	ff 75 10             	pushl  0x10(%ebp)
f010e653:	ff 75 0c             	pushl  0xc(%ebp)
f010e656:	e8 35 fc ff ff       	call   f010e290 <sys_free_user_mem>
f010e65b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e65e:	b8 00 00 00 00       	mov    $0x0,%eax
f010e663:	e9 cd 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010e668:	83 ec 08             	sub    $0x8,%esp
f010e66b:	ff 75 10             	pushl  0x10(%ebp)
f010e66e:	ff 75 0c             	pushl  0xc(%ebp)
f010e671:	e8 97 fc ff ff       	call   f010e30d <sys_allocate_user_mem>
f010e676:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e679:	b8 00 00 00 00       	mov    $0x0,%eax
f010e67e:	e9 b2 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010e683:	8b 45 14             	mov    0x14(%ebp),%eax
f010e686:	0f b6 d0             	movzbl %al,%edx
f010e689:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e68c:	83 ec 04             	sub    $0x4,%esp
f010e68f:	52                   	push   %edx
f010e690:	ff 75 10             	pushl  0x10(%ebp)
f010e693:	50                   	push   %eax
f010e694:	e8 c7 f8 ff ff       	call   f010df60 <sys_cputs>
f010e699:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e69c:	b8 00 00 00 00       	mov    $0x0,%eax
f010e6a1:	e9 8f 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010e6a6:	e8 31 f9 ff ff       	call   f010dfdc <sys_cgetc>
f010e6ab:	e9 85 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010e6b0:	e8 66 f9 ff ff       	call   f010e01b <sys_lock_cons>
		return 0;
f010e6b5:	b8 00 00 00 00       	mov    $0x0,%eax
f010e6ba:	e9 76 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010e6bf:	e8 65 f9 ff ff       	call   f010e029 <sys_unlock_cons>
		return 0;
f010e6c4:	b8 00 00 00 00       	mov    $0x0,%eax
f010e6c9:	e9 67 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010e6ce:	83 ec 08             	sub    $0x8,%esp
f010e6d1:	ff 75 10             	pushl  0x10(%ebp)
f010e6d4:	ff 75 0c             	pushl  0xc(%ebp)
f010e6d7:	e8 ae fa ff ff       	call   f010e18a <sys_calculate_required_frames>
f010e6dc:	83 c4 10             	add    $0x10,%esp
f010e6df:	e9 51 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010e6e4:	e8 c3 fa ff ff       	call   f010e1ac <sys_calculate_free_frames>
f010e6e9:	e9 47 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010e6ee:	e8 d8 fa ff ff       	call   f010e1cb <sys_calculate_modified_frames>
f010e6f3:	e9 3d 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010e6f8:	e8 e8 fa ff ff       	call   f010e1e5 <sys_calculate_notmod_frames>
f010e6fd:	e9 33 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010e702:	e8 70 fb ff ff       	call   f010e277 <sys_pf_calculate_allocated_pages>
f010e707:	e9 29 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010e70c:	83 ec 0c             	sub    $0xc,%esp
f010e70f:	ff 75 0c             	pushl  0xc(%ebp)
f010e712:	e8 e8 fa ff ff       	call   f010e1ff <sys_calculate_pages_tobe_removed_ready_exit>
f010e717:	83 c4 10             	add    $0x10,%esp
f010e71a:	e9 16 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010e71f:	e8 f1 fa ff ff       	call   f010e215 <sys_scarce_memory>
		return 0;
f010e724:	b8 00 00 00 00       	mov    $0x0,%eax
f010e729:	e9 07 03 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010e72e:	83 ec 04             	sub    $0x4,%esp
f010e731:	ff 75 14             	pushl  0x14(%ebp)
f010e734:	ff 75 10             	pushl  0x10(%ebp)
f010e737:	ff 75 0c             	pushl  0xc(%ebp)
f010e73a:	e8 fc fb ff ff       	call   f010e33b <sys_allocate_chunk>
f010e73f:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e742:	b8 00 00 00 00       	mov    $0x0,%eax
f010e747:	e9 e9 02 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010e74c:	8b 55 10             	mov    0x10(%ebp),%edx
f010e74f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e752:	83 ec 08             	sub    $0x8,%esp
f010e755:	52                   	push   %edx
f010e756:	50                   	push   %eax
f010e757:	e8 db f8 ff ff       	call   f010e037 <__sys_allocate_page>
f010e75c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e75f:	b8 00 00 00 00       	mov    $0x0,%eax
f010e764:	e9 cc 02 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010e769:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010e76c:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010e76f:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e772:	8b 55 10             	mov    0x10(%ebp),%edx
f010e775:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e778:	83 ec 0c             	sub    $0xc,%esp
f010e77b:	56                   	push   %esi
f010e77c:	53                   	push   %ebx
f010e77d:	51                   	push   %ecx
f010e77e:	52                   	push   %edx
f010e77f:	50                   	push   %eax
f010e780:	e8 cb f9 ff ff       	call   f010e150 <__sys_map_frame>
f010e785:	83 c4 20             	add    $0x20,%esp
		return 0;
f010e788:	b8 00 00 00 00       	mov    $0x0,%eax
f010e78d:	e9 a3 02 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010e792:	8b 55 10             	mov    0x10(%ebp),%edx
f010e795:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e798:	83 ec 08             	sub    $0x8,%esp
f010e79b:	52                   	push   %edx
f010e79c:	50                   	push   %eax
f010e79d:	e8 cb f9 ff ff       	call   f010e16d <__sys_unmap_frame>
f010e7a2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e7a5:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7aa:	e9 86 02 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010e7af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e7b2:	0f be c0             	movsbl %al,%eax
f010e7b5:	83 ec 0c             	sub    $0xc,%esp
f010e7b8:	50                   	push   %eax
f010e7b9:	e8 fa f7 ff ff       	call   f010dfb8 <sys_cputc>
f010e7be:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e7c1:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7c6:	e9 6a 02 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010e7cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e7ce:	0f be c0             	movsbl %al,%eax
f010e7d1:	83 ec 0c             	sub    $0xc,%esp
f010e7d4:	50                   	push   %eax
f010e7d5:	e8 49 fa ff ff       	call   f010e223 <sys_clearFFL>
f010e7da:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e7dd:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7e2:	e9 4e 02 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010e7e7:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e7ea:	8b 45 14             	mov    0x14(%ebp),%eax
f010e7ed:	0f b6 d0             	movzbl %al,%edx
f010e7f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e7f3:	51                   	push   %ecx
f010e7f4:	52                   	push   %edx
f010e7f5:	ff 75 10             	pushl  0x10(%ebp)
f010e7f8:	50                   	push   %eax
f010e7f9:	e8 a6 fb ff ff       	call   f010e3a4 <sys_createSharedObject>
f010e7fe:	83 c4 10             	add    $0x10,%esp
f010e801:	e9 2f 02 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010e806:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e809:	8b 55 10             	mov    0x10(%ebp),%edx
f010e80c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e80f:	83 ec 04             	sub    $0x4,%esp
f010e812:	51                   	push   %ecx
f010e813:	52                   	push   %edx
f010e814:	50                   	push   %eax
f010e815:	e8 d3 fb ff ff       	call   f010e3ed <sys_getSharedObject>
f010e81a:	83 c4 10             	add    $0x10,%esp
f010e81d:	e9 13 02 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010e822:	8b 55 10             	mov    0x10(%ebp),%edx
f010e825:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e828:	83 ec 08             	sub    $0x8,%esp
f010e82b:	52                   	push   %edx
f010e82c:	50                   	push   %eax
f010e82d:	e8 d7 fb ff ff       	call   f010e409 <sys_freeSharedObject>
f010e832:	83 c4 10             	add    $0x10,%esp
f010e835:	e9 fb 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010e83a:	8b 55 10             	mov    0x10(%ebp),%edx
f010e83d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e840:	83 ec 08             	sub    $0x8,%esp
f010e843:	52                   	push   %edx
f010e844:	50                   	push   %eax
f010e845:	e8 8a fb ff ff       	call   f010e3d4 <sys_getSizeOfSharedObject>
f010e84a:	83 c4 10             	add    $0x10,%esp
f010e84d:	e9 e3 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010e852:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e855:	ff 75 18             	pushl  0x18(%ebp)
f010e858:	ff 75 14             	pushl  0x14(%ebp)
f010e85b:	ff 75 10             	pushl  0x10(%ebp)
f010e85e:	50                   	push   %eax
f010e85f:	e8 d8 fc ff ff       	call   f010e53c <sys_create_env>
f010e864:	83 c4 10             	add    $0x10,%esp
f010e867:	e9 c9 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010e86c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e86f:	83 ec 0c             	sub    $0xc,%esp
f010e872:	50                   	push   %eax
f010e873:	e8 04 fd ff ff       	call   f010e57c <sys_run_env>
f010e878:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e87b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e880:	e9 b0 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010e885:	e8 a5 fb ff ff       	call   f010e42f <sys_getenvindex>
f010e88a:	e9 a6 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010e88f:	e8 8e fb ff ff       	call   f010e422 <sys_getenvid>
f010e894:	e9 9c 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010e899:	e8 eb fb ff ff       	call   f010e489 <sys_getparentenvid>
f010e89e:	e9 92 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010e8a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8a6:	83 ec 0c             	sub    $0xc,%esp
f010e8a9:	50                   	push   %eax
f010e8aa:	e8 e7 fb ff ff       	call   f010e496 <sys_destroy_env>
f010e8af:	83 c4 10             	add    $0x10,%esp
f010e8b2:	e9 7e 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010e8b7:	e8 72 fc ff ff       	call   f010e52e <sys_exit_env>
		return 0;
f010e8bc:	b8 00 00 00 00       	mov    $0x0,%eax
f010e8c1:	e9 6f 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010e8c6:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e8c9:	83 ec 0c             	sub    $0xc,%esp
f010e8cc:	50                   	push   %eax
f010e8cd:	e8 c2 fc ff ff       	call   f010e594 <sys_get_virtual_time>
f010e8d2:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010e8d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010e8db:	8b 45 10             	mov    0x10(%ebp),%eax
f010e8de:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010e8e1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e8e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e8e7:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010e8e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e8ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e8ef:	89 10                	mov    %edx,(%eax)
		return 0;
f010e8f1:	b8 00 00 00 00       	mov    $0x0,%eax
f010e8f6:	e9 3a 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010e8fb:	83 ec 04             	sub    $0x4,%esp
f010e8fe:	ff 75 14             	pushl  0x14(%ebp)
f010e901:	ff 75 10             	pushl  0x10(%ebp)
f010e904:	ff 75 0c             	pushl  0xc(%ebp)
f010e907:	e8 60 fa ff ff       	call   f010e36c <sys_move_user_mem>
f010e90c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e90f:	b8 00 00 00 00       	mov    $0x0,%eax
f010e914:	e9 1c 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010e919:	e8 a5 fc ff ff       	call   f010e5c3 <sys_rcr2>
f010e91e:	e9 12 01 00 00       	jmp    f010ea35 <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010e923:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e926:	0f b6 c0             	movzbl %al,%eax
f010e929:	83 ec 0c             	sub    $0xc,%esp
f010e92c:	50                   	push   %eax
f010e92d:	e8 a3 fc ff ff       	call   f010e5d5 <sys_bypassPageFault>
f010e932:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e935:	b8 00 00 00 00       	mov    $0x0,%eax
f010e93a:	e9 f6 00 00 00       	jmp    f010ea35 <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010e93f:	e8 0b ef 00 00       	call   f011d84f <rsttst>
		return 0;
f010e944:	b8 00 00 00 00       	mov    $0x0,%eax
f010e949:	e9 e7 00 00 00       	jmp    f010ea35 <syscall+0x449>
	case SYS_inctst:
		inctst();
f010e94e:	e8 44 ef 00 00       	call   f011d897 <inctst>
		return 0;
f010e953:	b8 00 00 00 00       	mov    $0x0,%eax
f010e958:	e9 d8 00 00 00       	jmp    f010ea35 <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010e95d:	83 ec 0c             	sub    $0xc,%esp
f010e960:	ff 75 0c             	pushl  0xc(%ebp)
f010e963:	e8 71 f0 00 00       	call   f011d9d9 <chktst>
f010e968:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e96b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e970:	e9 c0 00 00 00       	jmp    f010ea35 <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010e975:	e8 51 ef 00 00       	call   f011d8cb <gettst>
f010e97a:	e9 b6 00 00 00       	jmp    f010ea35 <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010e97f:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010e982:	8b 45 18             	mov    0x18(%ebp),%eax
f010e985:	0f be c0             	movsbl %al,%eax
f010e988:	83 ec 0c             	sub    $0xc,%esp
f010e98b:	52                   	push   %edx
f010e98c:	50                   	push   %eax
f010e98d:	ff 75 14             	pushl  0x14(%ebp)
f010e990:	ff 75 10             	pushl  0x10(%ebp)
f010e993:	ff 75 0c             	pushl  0xc(%ebp)
f010e996:	e8 3a ef 00 00       	call   f011d8d5 <tst>
f010e99b:	83 c4 20             	add    $0x20,%esp
		return 0;
f010e99e:	b8 00 00 00 00       	mov    $0x0,%eax
f010e9a3:	e9 8d 00 00 00       	jmp    f010ea35 <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010e9a8:	e8 df f9 ff ff       	call   f010e38c <sys_get_heap_strategy>
f010e9ad:	e9 83 00 00 00       	jmp    f010ea35 <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010e9b2:	83 ec 0c             	sub    $0xc,%esp
f010e9b5:	ff 75 0c             	pushl  0xc(%ebp)
f010e9b8:	e8 d9 f9 ff ff       	call   f010e396 <sys_set_uheap_strategy>
f010e9bd:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e9c0:	b8 00 00 00 00       	mov    $0x0,%eax
f010e9c5:	eb 6e                	jmp    f010ea35 <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010e9c7:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010e9ca:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e9cd:	8b 55 10             	mov    0x10(%ebp),%edx
f010e9d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9d3:	53                   	push   %ebx
f010e9d4:	51                   	push   %ecx
f010e9d5:	52                   	push   %edx
f010e9d6:	50                   	push   %eax
f010e9d7:	e8 b3 1d 00 00       	call   f011078f <sys_check_LRU_lists>
f010e9dc:	83 c4 10             	add    $0x10,%esp
f010e9df:	eb 54                	jmp    f010ea35 <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010e9e1:	8b 55 10             	mov    0x10(%ebp),%edx
f010e9e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9e7:	83 ec 08             	sub    $0x8,%esp
f010e9ea:	52                   	push   %edx
f010e9eb:	50                   	push   %eax
f010e9ec:	e8 60 1f 00 00       	call   f0110951 <sys_check_LRU_lists_free>
f010e9f1:	83 c4 10             	add    $0x10,%esp
f010e9f4:	eb 3f                	jmp    f010ea35 <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010e9f6:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e9f9:	8b 55 10             	mov    0x10(%ebp),%edx
f010e9fc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9ff:	51                   	push   %ecx
f010ea00:	ff 75 14             	pushl  0x14(%ebp)
f010ea03:	52                   	push   %edx
f010ea04:	50                   	push   %eax
f010ea05:	e8 d4 20 00 00       	call   f0110ade <sys_check_WS_list>
f010ea0a:	83 c4 10             	add    $0x10,%esp
f010ea0d:	eb 26                	jmp    f010ea35 <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010ea0f:	8b 55 10             	mov    0x10(%ebp),%edx
f010ea12:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ea15:	83 ec 08             	sub    $0x8,%esp
f010ea18:	52                   	push   %edx
f010ea19:	50                   	push   %eax
f010ea1a:	e8 bb f1 00 00       	call   f011dbda <sys_utilities>
f010ea1f:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ea22:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea27:	eb 0c                	jmp    f010ea35 <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010ea29:	b8 03 00 00 00       	mov    $0x3,%eax
f010ea2e:	eb 05                	jmp    f010ea35 <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010ea30:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010ea35:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010ea38:	5b                   	pop    %ebx
f010ea39:	5e                   	pop    %esi
f010ea3a:	5d                   	pop    %ebp
f010ea3b:	c3                   	ret    

f010ea3c <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010ea3c:	55                   	push   %ebp
f010ea3d:	89 e5                	mov    %esp,%ebp
f010ea3f:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010ea42:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ea45:	8b 00                	mov    (%eax),%eax
f010ea47:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010ea4a:	8b 45 10             	mov    0x10(%ebp),%eax
f010ea4d:	8b 00                	mov    (%eax),%eax
f010ea4f:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ea52:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010ea59:	e9 ca 00 00 00       	jmp    f010eb28 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010ea5e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ea61:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ea64:	01 d0                	add    %edx,%eax
f010ea66:	89 c2                	mov    %eax,%edx
f010ea68:	c1 ea 1f             	shr    $0x1f,%edx
f010ea6b:	01 d0                	add    %edx,%eax
f010ea6d:	d1 f8                	sar    %eax
f010ea6f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ea72:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ea75:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010ea78:	eb 03                	jmp    f010ea7d <stab_binsearch+0x41>
			m--;
f010ea7a:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010ea7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ea80:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010ea83:	7c 1e                	jl     f010eaa3 <stab_binsearch+0x67>
f010ea85:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ea88:	89 d0                	mov    %edx,%eax
f010ea8a:	01 c0                	add    %eax,%eax
f010ea8c:	01 d0                	add    %edx,%eax
f010ea8e:	c1 e0 02             	shl    $0x2,%eax
f010ea91:	89 c2                	mov    %eax,%edx
f010ea93:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea96:	01 d0                	add    %edx,%eax
f010ea98:	8a 40 04             	mov    0x4(%eax),%al
f010ea9b:	0f b6 c0             	movzbl %al,%eax
f010ea9e:	3b 45 14             	cmp    0x14(%ebp),%eax
f010eaa1:	75 d7                	jne    f010ea7a <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010eaa3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eaa6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010eaa9:	7d 09                	jge    f010eab4 <stab_binsearch+0x78>
			l = true_m + 1;
f010eaab:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eaae:	40                   	inc    %eax
f010eaaf:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010eab2:	eb 74                	jmp    f010eb28 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010eab4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010eabb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010eabe:	89 d0                	mov    %edx,%eax
f010eac0:	01 c0                	add    %eax,%eax
f010eac2:	01 d0                	add    %edx,%eax
f010eac4:	c1 e0 02             	shl    $0x2,%eax
f010eac7:	89 c2                	mov    %eax,%edx
f010eac9:	8b 45 08             	mov    0x8(%ebp),%eax
f010eacc:	01 d0                	add    %edx,%eax
f010eace:	8b 40 08             	mov    0x8(%eax),%eax
f010ead1:	3b 45 18             	cmp    0x18(%ebp),%eax
f010ead4:	73 11                	jae    f010eae7 <stab_binsearch+0xab>
			*region_left = m;
f010ead6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ead9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010eadc:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010eade:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eae1:	40                   	inc    %eax
f010eae2:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010eae5:	eb 41                	jmp    f010eb28 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010eae7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010eaea:	89 d0                	mov    %edx,%eax
f010eaec:	01 c0                	add    %eax,%eax
f010eaee:	01 d0                	add    %edx,%eax
f010eaf0:	c1 e0 02             	shl    $0x2,%eax
f010eaf3:	89 c2                	mov    %eax,%edx
f010eaf5:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaf8:	01 d0                	add    %edx,%eax
f010eafa:	8b 40 08             	mov    0x8(%eax),%eax
f010eafd:	3b 45 18             	cmp    0x18(%ebp),%eax
f010eb00:	76 14                	jbe    f010eb16 <stab_binsearch+0xda>
			*region_right = m - 1;
f010eb02:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eb05:	8d 50 ff             	lea    -0x1(%eax),%edx
f010eb08:	8b 45 10             	mov    0x10(%ebp),%eax
f010eb0b:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010eb0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eb10:	48                   	dec    %eax
f010eb11:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010eb14:	eb 12                	jmp    f010eb28 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010eb16:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb19:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010eb1c:	89 10                	mov    %edx,(%eax)
			l = m;
f010eb1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eb21:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010eb24:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010eb28:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010eb2b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010eb2e:	0f 8e 2a ff ff ff    	jle    f010ea5e <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010eb34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eb38:	75 0f                	jne    f010eb49 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010eb3a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb3d:	8b 00                	mov    (%eax),%eax
f010eb3f:	8d 50 ff             	lea    -0x1(%eax),%edx
f010eb42:	8b 45 10             	mov    0x10(%ebp),%eax
f010eb45:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010eb47:	eb 3d                	jmp    f010eb86 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010eb49:	8b 45 10             	mov    0x10(%ebp),%eax
f010eb4c:	8b 00                	mov    (%eax),%eax
f010eb4e:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010eb51:	eb 03                	jmp    f010eb56 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010eb53:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010eb56:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb59:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010eb5b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010eb5e:	7d 1e                	jge    f010eb7e <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010eb60:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010eb63:	89 d0                	mov    %edx,%eax
f010eb65:	01 c0                	add    %eax,%eax
f010eb67:	01 d0                	add    %edx,%eax
f010eb69:	c1 e0 02             	shl    $0x2,%eax
f010eb6c:	89 c2                	mov    %eax,%edx
f010eb6e:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb71:	01 d0                	add    %edx,%eax
f010eb73:	8a 40 04             	mov    0x4(%eax),%al
f010eb76:	0f b6 c0             	movzbl %al,%eax
f010eb79:	3b 45 14             	cmp    0x14(%ebp),%eax
f010eb7c:	75 d5                	jne    f010eb53 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010eb7e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb81:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010eb84:	89 10                	mov    %edx,(%eax)
	}
}
f010eb86:	90                   	nop
f010eb87:	c9                   	leave  
f010eb88:	c3                   	ret    

f010eb89 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010eb89:	55                   	push   %ebp
f010eb8a:	89 e5                	mov    %esp,%ebp
f010eb8c:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010eb8f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb92:	c7 00 e8 70 12 f0    	movl   $0xf01270e8,(%eax)
	info->eip_line = 0;
f010eb98:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb9b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010eba2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eba5:	c7 40 08 e8 70 12 f0 	movl   $0xf01270e8,0x8(%eax)
	info->eip_fn_namelen = 9;
f010ebac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ebaf:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010ebb6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ebb9:	8b 55 08             	mov    0x8(%ebp),%edx
f010ebbc:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010ebbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ebc2:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010ebc9:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebcc:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010ebd1:	76 1e                	jbe    f010ebf1 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010ebd3:	c7 45 f4 7c 0e 13 f0 	movl   $0xf0130e7c,-0xc(%ebp)
		stab_end = __STAB_END__;
f010ebda:	c7 45 f0 84 3c 16 f0 	movl   $0xf0163c84,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010ebe1:	c7 45 ec 85 3c 16 f0 	movl   $0xf0163c85,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010ebe8:	c7 45 e8 94 55 17 f0 	movl   $0xf0175594,-0x18(%ebp)
f010ebef:	eb 2a                	jmp    f010ec1b <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010ebf1:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010ebf8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ebfb:	8b 00                	mov    (%eax),%eax
f010ebfd:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010ec00:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ec03:	8b 40 04             	mov    0x4(%eax),%eax
f010ec06:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010ec09:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ec0c:	8b 40 08             	mov    0x8(%eax),%eax
f010ec0f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010ec12:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ec15:	8b 40 0c             	mov    0xc(%eax),%eax
f010ec18:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010ec1b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ec1e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010ec21:	76 0a                	jbe    f010ec2d <debuginfo_eip+0xa4>
f010ec23:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ec26:	48                   	dec    %eax
f010ec27:	8a 00                	mov    (%eax),%al
f010ec29:	84 c0                	test   %al,%al
f010ec2b:	74 0a                	je     f010ec37 <debuginfo_eip+0xae>
		return -1;
f010ec2d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010ec32:	e9 01 02 00 00       	jmp    f010ee38 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010ec37:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010ec3e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ec41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec44:	29 c2                	sub    %eax,%edx
f010ec46:	89 d0                	mov    %edx,%eax
f010ec48:	c1 f8 02             	sar    $0x2,%eax
f010ec4b:	89 c2                	mov    %eax,%edx
f010ec4d:	89 d0                	mov    %edx,%eax
f010ec4f:	c1 e0 02             	shl    $0x2,%eax
f010ec52:	01 d0                	add    %edx,%eax
f010ec54:	c1 e0 02             	shl    $0x2,%eax
f010ec57:	01 d0                	add    %edx,%eax
f010ec59:	c1 e0 02             	shl    $0x2,%eax
f010ec5c:	01 d0                	add    %edx,%eax
f010ec5e:	89 c1                	mov    %eax,%ecx
f010ec60:	c1 e1 08             	shl    $0x8,%ecx
f010ec63:	01 c8                	add    %ecx,%eax
f010ec65:	89 c1                	mov    %eax,%ecx
f010ec67:	c1 e1 10             	shl    $0x10,%ecx
f010ec6a:	01 c8                	add    %ecx,%eax
f010ec6c:	01 c0                	add    %eax,%eax
f010ec6e:	01 d0                	add    %edx,%eax
f010ec70:	48                   	dec    %eax
f010ec71:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010ec74:	ff 75 08             	pushl  0x8(%ebp)
f010ec77:	6a 64                	push   $0x64
f010ec79:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010ec7c:	50                   	push   %eax
f010ec7d:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010ec80:	50                   	push   %eax
f010ec81:	ff 75 f4             	pushl  -0xc(%ebp)
f010ec84:	e8 b3 fd ff ff       	call   f010ea3c <stab_binsearch>
f010ec89:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010ec8c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ec8f:	85 c0                	test   %eax,%eax
f010ec91:	75 0a                	jne    f010ec9d <debuginfo_eip+0x114>
		return -1;
f010ec93:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010ec98:	e9 9b 01 00 00       	jmp    f010ee38 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010ec9d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010eca0:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010eca3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010eca6:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010eca9:	ff 75 08             	pushl  0x8(%ebp)
f010ecac:	6a 24                	push   $0x24
f010ecae:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010ecb1:	50                   	push   %eax
f010ecb2:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010ecb5:	50                   	push   %eax
f010ecb6:	ff 75 f4             	pushl  -0xc(%ebp)
f010ecb9:	e8 7e fd ff ff       	call   f010ea3c <stab_binsearch>
f010ecbe:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010ecc1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010ecc4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ecc7:	39 c2                	cmp    %eax,%edx
f010ecc9:	0f 8f 86 00 00 00    	jg     f010ed55 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010eccf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ecd2:	89 c2                	mov    %eax,%edx
f010ecd4:	89 d0                	mov    %edx,%eax
f010ecd6:	01 c0                	add    %eax,%eax
f010ecd8:	01 d0                	add    %edx,%eax
f010ecda:	c1 e0 02             	shl    $0x2,%eax
f010ecdd:	89 c2                	mov    %eax,%edx
f010ecdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ece2:	01 d0                	add    %edx,%eax
f010ece4:	8b 00                	mov    (%eax),%eax
f010ece6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010ece9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ecec:	29 d1                	sub    %edx,%ecx
f010ecee:	89 ca                	mov    %ecx,%edx
f010ecf0:	39 d0                	cmp    %edx,%eax
f010ecf2:	73 22                	jae    f010ed16 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010ecf4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ecf7:	89 c2                	mov    %eax,%edx
f010ecf9:	89 d0                	mov    %edx,%eax
f010ecfb:	01 c0                	add    %eax,%eax
f010ecfd:	01 d0                	add    %edx,%eax
f010ecff:	c1 e0 02             	shl    $0x2,%eax
f010ed02:	89 c2                	mov    %eax,%edx
f010ed04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed07:	01 d0                	add    %edx,%eax
f010ed09:	8b 10                	mov    (%eax),%edx
f010ed0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ed0e:	01 c2                	add    %eax,%edx
f010ed10:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed13:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010ed16:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ed19:	89 c2                	mov    %eax,%edx
f010ed1b:	89 d0                	mov    %edx,%eax
f010ed1d:	01 c0                	add    %eax,%eax
f010ed1f:	01 d0                	add    %edx,%eax
f010ed21:	c1 e0 02             	shl    $0x2,%eax
f010ed24:	89 c2                	mov    %eax,%edx
f010ed26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed29:	01 d0                	add    %edx,%eax
f010ed2b:	8b 50 08             	mov    0x8(%eax),%edx
f010ed2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed31:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010ed34:	8b 55 08             	mov    0x8(%ebp),%edx
f010ed37:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed3a:	8b 40 10             	mov    0x10(%eax),%eax
f010ed3d:	29 c2                	sub    %eax,%edx
f010ed3f:	89 d0                	mov    %edx,%eax
f010ed41:	c1 f8 02             	sar    $0x2,%eax
f010ed44:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010ed47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ed4a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010ed4d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ed50:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010ed53:	eb 15                	jmp    f010ed6a <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010ed55:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed58:	8b 55 08             	mov    0x8(%ebp),%edx
f010ed5b:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010ed5e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ed61:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010ed64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ed67:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010ed6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed6d:	8b 40 08             	mov    0x8(%eax),%eax
f010ed70:	83 ec 08             	sub    $0x8,%esp
f010ed73:	6a 3a                	push   $0x3a
f010ed75:	50                   	push   %eax
f010ed76:	e8 20 09 01 00       	call   f011f69b <strfind>
f010ed7b:	83 c4 10             	add    $0x10,%esp
f010ed7e:	89 c2                	mov    %eax,%edx
f010ed80:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed83:	8b 40 08             	mov    0x8(%eax),%eax
f010ed86:	29 c2                	sub    %eax,%edx
f010ed88:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed8b:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010ed8e:	eb 03                	jmp    f010ed93 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010ed90:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010ed93:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ed96:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010ed99:	7c 4e                	jl     f010ede9 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010ed9b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010ed9e:	89 d0                	mov    %edx,%eax
f010eda0:	01 c0                	add    %eax,%eax
f010eda2:	01 d0                	add    %edx,%eax
f010eda4:	c1 e0 02             	shl    $0x2,%eax
f010eda7:	89 c2                	mov    %eax,%edx
f010eda9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010edac:	01 d0                	add    %edx,%eax
f010edae:	8a 40 04             	mov    0x4(%eax),%al
f010edb1:	3c 84                	cmp    $0x84,%al
f010edb3:	74 34                	je     f010ede9 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010edb5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010edb8:	89 d0                	mov    %edx,%eax
f010edba:	01 c0                	add    %eax,%eax
f010edbc:	01 d0                	add    %edx,%eax
f010edbe:	c1 e0 02             	shl    $0x2,%eax
f010edc1:	89 c2                	mov    %eax,%edx
f010edc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010edc6:	01 d0                	add    %edx,%eax
f010edc8:	8a 40 04             	mov    0x4(%eax),%al
f010edcb:	3c 64                	cmp    $0x64,%al
f010edcd:	75 c1                	jne    f010ed90 <debuginfo_eip+0x207>
f010edcf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010edd2:	89 d0                	mov    %edx,%eax
f010edd4:	01 c0                	add    %eax,%eax
f010edd6:	01 d0                	add    %edx,%eax
f010edd8:	c1 e0 02             	shl    $0x2,%eax
f010eddb:	89 c2                	mov    %eax,%edx
f010eddd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ede0:	01 d0                	add    %edx,%eax
f010ede2:	8b 40 08             	mov    0x8(%eax),%eax
f010ede5:	85 c0                	test   %eax,%eax
f010ede7:	74 a7                	je     f010ed90 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010ede9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010edec:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010edef:	7c 42                	jl     f010ee33 <debuginfo_eip+0x2aa>
f010edf1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010edf4:	89 d0                	mov    %edx,%eax
f010edf6:	01 c0                	add    %eax,%eax
f010edf8:	01 d0                	add    %edx,%eax
f010edfa:	c1 e0 02             	shl    $0x2,%eax
f010edfd:	89 c2                	mov    %eax,%edx
f010edff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee02:	01 d0                	add    %edx,%eax
f010ee04:	8b 00                	mov    (%eax),%eax
f010ee06:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010ee09:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ee0c:	29 d1                	sub    %edx,%ecx
f010ee0e:	89 ca                	mov    %ecx,%edx
f010ee10:	39 d0                	cmp    %edx,%eax
f010ee12:	73 1f                	jae    f010ee33 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010ee14:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010ee17:	89 d0                	mov    %edx,%eax
f010ee19:	01 c0                	add    %eax,%eax
f010ee1b:	01 d0                	add    %edx,%eax
f010ee1d:	c1 e0 02             	shl    $0x2,%eax
f010ee20:	89 c2                	mov    %eax,%edx
f010ee22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee25:	01 d0                	add    %edx,%eax
f010ee27:	8b 10                	mov    (%eax),%edx
f010ee29:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee2c:	01 c2                	add    %eax,%edx
f010ee2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee31:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010ee33:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ee38:	c9                   	leave  
f010ee39:	c3                   	ret    

f010ee3a <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010ee3a:	55                   	push   %ebp
f010ee3b:	89 e5                	mov    %esp,%ebp
f010ee3d:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010ee40:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010ee44:	74 1c                	je     f010ee62 <setPageReplacmentAlgorithmLRU+0x28>
f010ee46:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ee4a:	74 16                	je     f010ee62 <setPageReplacmentAlgorithmLRU+0x28>
f010ee4c:	68 f4 70 12 f0       	push   $0xf01270f4
f010ee51:	68 3e 71 12 f0       	push   $0xf012713e
f010ee56:	6a 1a                	push   $0x1a
f010ee58:	68 53 71 12 f0       	push   $0xf0127153
f010ee5d:	e8 d7 14 ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010ee62:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee65:	a3 10 ba 6b f0       	mov    %eax,0xf06bba10
}
f010ee6a:	90                   	nop
f010ee6b:	c9                   	leave  
f010ee6c:	c3                   	ret    

f010ee6d <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010ee6d:	55                   	push   %ebp
f010ee6e:	89 e5                	mov    %esp,%ebp
f010ee70:	c7 05 10 ba 6b f0 03 	movl   $0x3,0xf06bba10
f010ee77:	00 00 00 
f010ee7a:	90                   	nop
f010ee7b:	5d                   	pop    %ebp
f010ee7c:	c3                   	ret    

f010ee7d <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010ee7d:	55                   	push   %ebp
f010ee7e:	89 e5                	mov    %esp,%ebp
f010ee80:	c7 05 10 ba 6b f0 04 	movl   $0x4,0xf06bba10
f010ee87:	00 00 00 
f010ee8a:	90                   	nop
f010ee8b:	5d                   	pop    %ebp
f010ee8c:	c3                   	ret    

f010ee8d <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010ee8d:	55                   	push   %ebp
f010ee8e:	89 e5                	mov    %esp,%ebp
f010ee90:	c7 05 10 ba 6b f0 05 	movl   $0x5,0xf06bba10
f010ee97:	00 00 00 
f010ee9a:	90                   	nop
f010ee9b:	5d                   	pop    %ebp
f010ee9c:	c3                   	ret    

f010ee9d <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010ee9d:	55                   	push   %ebp
f010ee9e:	89 e5                	mov    %esp,%ebp
f010eea0:	c7 05 10 ba 6b f0 07 	movl   $0x7,0xf06bba10
f010eea7:	00 00 00 
f010eeaa:	90                   	nop
f010eeab:	5d                   	pop    %ebp
f010eeac:	c3                   	ret    

f010eead <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010eead:	55                   	push   %ebp
f010eeae:	89 e5                	mov    %esp,%ebp
f010eeb0:	c7 05 10 ba 6b f0 06 	movl   $0x6,0xf06bba10
f010eeb7:	00 00 00 
f010eeba:	8b 45 08             	mov    0x8(%ebp),%eax
f010eebd:	a3 54 b3 6b f0       	mov    %eax,0xf06bb354
f010eec2:	90                   	nop
f010eec3:	5d                   	pop    %ebp
f010eec4:	c3                   	ret    

f010eec5 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010eec5:	55                   	push   %ebp
f010eec6:	89 e5                	mov    %esp,%ebp
f010eec8:	8b 15 10 ba 6b f0    	mov    0xf06bba10,%edx
f010eece:	8b 45 08             	mov    0x8(%ebp),%eax
f010eed1:	39 c2                	cmp    %eax,%edx
f010eed3:	0f 94 c0             	sete   %al
f010eed6:	0f b6 c0             	movzbl %al,%eax
f010eed9:	5d                   	pop    %ebp
f010eeda:	c3                   	ret    

f010eedb <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010eedb:	55                   	push   %ebp
f010eedc:	89 e5                	mov    %esp,%ebp
f010eede:	a1 10 ba 6b f0       	mov    0xf06bba10,%eax
f010eee3:	83 f8 03             	cmp    $0x3,%eax
f010eee6:	75 07                	jne    f010eeef <isPageReplacmentAlgorithmCLOCK+0x14>
f010eee8:	b8 01 00 00 00       	mov    $0x1,%eax
f010eeed:	eb 05                	jmp    f010eef4 <isPageReplacmentAlgorithmCLOCK+0x19>
f010eeef:	b8 00 00 00 00       	mov    $0x0,%eax
f010eef4:	5d                   	pop    %ebp
f010eef5:	c3                   	ret    

f010eef6 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010eef6:	55                   	push   %ebp
f010eef7:	89 e5                	mov    %esp,%ebp
f010eef9:	a1 10 ba 6b f0       	mov    0xf06bba10,%eax
f010eefe:	83 f8 04             	cmp    $0x4,%eax
f010ef01:	75 07                	jne    f010ef0a <isPageReplacmentAlgorithmFIFO+0x14>
f010ef03:	b8 01 00 00 00       	mov    $0x1,%eax
f010ef08:	eb 05                	jmp    f010ef0f <isPageReplacmentAlgorithmFIFO+0x19>
f010ef0a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef0f:	5d                   	pop    %ebp
f010ef10:	c3                   	ret    

f010ef11 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010ef11:	55                   	push   %ebp
f010ef12:	89 e5                	mov    %esp,%ebp
f010ef14:	a1 10 ba 6b f0       	mov    0xf06bba10,%eax
f010ef19:	83 f8 05             	cmp    $0x5,%eax
f010ef1c:	75 07                	jne    f010ef25 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010ef1e:	b8 01 00 00 00       	mov    $0x1,%eax
f010ef23:	eb 05                	jmp    f010ef2a <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010ef25:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef2a:	5d                   	pop    %ebp
f010ef2b:	c3                   	ret    

f010ef2c <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010ef2c:	55                   	push   %ebp
f010ef2d:	89 e5                	mov    %esp,%ebp
f010ef2f:	a1 10 ba 6b f0       	mov    0xf06bba10,%eax
f010ef34:	83 f8 07             	cmp    $0x7,%eax
f010ef37:	75 07                	jne    f010ef40 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010ef39:	b8 01 00 00 00       	mov    $0x1,%eax
f010ef3e:	eb 05                	jmp    f010ef45 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010ef40:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef45:	5d                   	pop    %ebp
f010ef46:	c3                   	ret    

f010ef47 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010ef47:	55                   	push   %ebp
f010ef48:	89 e5                	mov    %esp,%ebp
f010ef4a:	a1 10 ba 6b f0       	mov    0xf06bba10,%eax
f010ef4f:	83 f8 06             	cmp    $0x6,%eax
f010ef52:	75 07                	jne    f010ef5b <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010ef54:	b8 01 00 00 00       	mov    $0x1,%eax
f010ef59:	eb 05                	jmp    f010ef60 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010ef5b:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef60:	5d                   	pop    %ebp
f010ef61:	c3                   	ret    

f010ef62 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010ef62:	55                   	push   %ebp
f010ef63:	89 e5                	mov    %esp,%ebp
f010ef65:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef68:	a3 b8 b7 6b f0       	mov    %eax,0xf06bb7b8
f010ef6d:	90                   	nop
f010ef6e:	5d                   	pop    %ebp
f010ef6f:	c3                   	ret    

f010ef70 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010ef70:	55                   	push   %ebp
f010ef71:	89 e5                	mov    %esp,%ebp
f010ef73:	a1 b8 b7 6b f0       	mov    0xf06bb7b8,%eax
f010ef78:	5d                   	pop    %ebp
f010ef79:	c3                   	ret    

f010ef7a <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010ef7a:	55                   	push   %ebp
f010ef7b:	89 e5                	mov    %esp,%ebp
f010ef7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef80:	a3 94 ba 6b f0       	mov    %eax,0xf06bba94
f010ef85:	90                   	nop
f010ef86:	5d                   	pop    %ebp
f010ef87:	c3                   	ret    

f010ef88 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010ef88:	55                   	push   %ebp
f010ef89:	89 e5                	mov    %esp,%ebp
f010ef8b:	a1 94 ba 6b f0       	mov    0xf06bba94,%eax
f010ef90:	5d                   	pop    %ebp
f010ef91:	c3                   	ret    

f010ef92 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010ef92:	55                   	push   %ebp
f010ef93:	89 e5                	mov    %esp,%ebp
f010ef95:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef98:	a3 30 bb 6b f0       	mov    %eax,0xf06bbb30
f010ef9d:	90                   	nop
f010ef9e:	5d                   	pop    %ebp
f010ef9f:	c3                   	ret    

f010efa0 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010efa0:	55                   	push   %ebp
f010efa1:	89 e5                	mov    %esp,%ebp
f010efa3:	a1 30 bb 6b f0       	mov    0xf06bbb30,%eax
f010efa8:	5d                   	pop    %ebp
f010efa9:	c3                   	ret    

f010efaa <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010efaa:	55                   	push   %ebp
f010efab:	89 e5                	mov    %esp,%ebp
f010efad:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010efb0:	0f 20 d0             	mov    %cr2,%eax
f010efb3:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010efb6:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010efb9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010efbc:	e8 c9 c2 ff ff       	call   f010b28a <get_cpu_proc>
f010efc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010efc4:	a1 4c 30 69 f0       	mov    0xf069304c,%eax
f010efc9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010efcc:	75 50                	jne    f010f01e <fault_handler+0x74>
f010efce:	a1 58 30 69 f0       	mov    0xf0693058,%eax
f010efd3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010efd6:	75 46                	jne    f010f01e <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010efd8:	a0 54 30 69 f0       	mov    0xf0693054,%al
f010efdd:	40                   	inc    %eax
f010efde:	a2 54 30 69 f0       	mov    %al,0xf0693054
		if (num_repeated_fault == 3)
f010efe3:	a0 54 30 69 f0       	mov    0xf0693054,%al
f010efe8:	3c 03                	cmp    $0x3,%al
f010efea:	75 4d                	jne    f010f039 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010efec:	83 ec 0c             	sub    $0xc,%esp
f010efef:	ff 75 08             	pushl  0x8(%ebp)
f010eff2:	e8 49 e9 ff ff       	call   f010d940 <print_trapframe>
f010eff7:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010effa:	8b 15 48 30 69 f0    	mov    0xf0693048,%edx
f010f000:	a1 50 30 69 f0       	mov    0xf0693050,%eax
f010f005:	83 ec 08             	sub    $0x8,%esp
f010f008:	ff 75 ec             	pushl  -0x14(%ebp)
f010f00b:	52                   	push   %edx
f010f00c:	50                   	push   %eax
f010f00d:	68 70 71 12 f0       	push   $0xf0127170
f010f012:	6a 58                	push   $0x58
f010f014:	68 53 71 12 f0       	push   $0xf0127153
f010f019:	e8 1b 13 ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010f01e:	a1 4c 30 69 f0       	mov    0xf069304c,%eax
f010f023:	a3 50 30 69 f0       	mov    %eax,0xf0693050
		before_last_eip = last_eip;
f010f028:	a1 44 30 69 f0       	mov    0xf0693044,%eax
f010f02d:	a3 48 30 69 f0       	mov    %eax,0xf0693048
		num_repeated_fault = 0;
f010f032:	c6 05 54 30 69 f0 00 	movb   $0x0,0xf0693054
	}
	last_eip = (uint32)tf->tf_eip;
f010f039:	8b 45 08             	mov    0x8(%ebp),%eax
f010f03c:	8b 40 30             	mov    0x30(%eax),%eax
f010f03f:	a3 44 30 69 f0       	mov    %eax,0xf0693044
	last_fault_va = fault_va ;
f010f044:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f047:	a3 4c 30 69 f0       	mov    %eax,0xf069304c
	last_faulted_env = cur_env;
f010f04c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f04f:	a3 58 30 69 f0       	mov    %eax,0xf0693058
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010f054:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010f05b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f05e:	8b 40 34             	mov    0x34(%eax),%eax
f010f061:	0f b7 c0             	movzwl %ax,%eax
f010f064:	83 e0 03             	and    $0x3,%eax
f010f067:	83 f8 03             	cmp    $0x3,%eax
f010f06a:	75 07                	jne    f010f073 <fault_handler+0xc9>
		userTrap = 1;
f010f06c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010f073:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f077:	0f 85 c2 00 00 00    	jne    f010f13f <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010f07d:	e8 8a 80 ff ff       	call   f010710c <mycpu>
f010f082:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010f085:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010f089:	74 2f                	je     f010f0ba <fault_handler+0x110>
f010f08b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f08e:	8b 40 70             	mov    0x70(%eax),%eax
f010f091:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f094:	77 24                	ja     f010f0ba <fault_handler+0x110>
f010f096:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f099:	8b 40 70             	mov    0x70(%eax),%eax
f010f09c:	05 00 10 00 00       	add    $0x1000,%eax
f010f0a1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f0a4:	76 14                	jbe    f010f0ba <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010f0a6:	83 ec 04             	sub    $0x4,%esp
f010f0a9:	68 e0 71 12 f0       	push   $0xf01271e0
f010f0ae:	6a 6f                	push   $0x6f
f010f0b0:	68 53 71 12 f0       	push   $0xf0127153
f010f0b5:	e8 7f 12 ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010f0ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f0bd:	8b 40 08             	mov    0x8(%eax),%eax
f010f0c0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f0c3:	77 5d                	ja     f010f122 <fault_handler+0x178>
f010f0c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f0c8:	8b 40 08             	mov    0x8(%eax),%eax
f010f0cb:	05 00 10 00 00       	add    $0x1000,%eax
f010f0d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f0d3:	76 4d                	jbe    f010f122 <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010f0d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f0d8:	ba a0 b4 6b f0       	mov    $0xf06bb4a0,%edx
f010f0dd:	29 d0                	sub    %edx,%eax
f010f0df:	c1 f8 03             	sar    $0x3,%eax
f010f0e2:	89 c2                	mov    %eax,%edx
f010f0e4:	89 d0                	mov    %edx,%eax
f010f0e6:	c1 e0 02             	shl    $0x2,%eax
f010f0e9:	01 d0                	add    %edx,%eax
f010f0eb:	01 c0                	add    %eax,%eax
f010f0ed:	01 d0                	add    %edx,%eax
f010f0ef:	c1 e0 03             	shl    $0x3,%eax
f010f0f2:	01 d0                	add    %edx,%eax
f010f0f4:	89 c1                	mov    %eax,%ecx
f010f0f6:	c1 e1 0b             	shl    $0xb,%ecx
f010f0f9:	01 c8                	add    %ecx,%eax
f010f0fb:	c1 e0 05             	shl    $0x5,%eax
f010f0fe:	01 d0                	add    %edx,%eax
f010f100:	c1 e0 02             	shl    $0x2,%eax
f010f103:	01 d0                	add    %edx,%eax
f010f105:	01 c0                	add    %eax,%eax
f010f107:	01 d0                	add    %edx,%eax
f010f109:	c1 e0 03             	shl    $0x3,%eax
f010f10c:	01 d0                	add    %edx,%eax
f010f10e:	f7 d8                	neg    %eax
f010f110:	50                   	push   %eax
f010f111:	68 08 72 12 f0       	push   $0xf0127208
f010f116:	6a 71                	push   $0x71
f010f118:	68 53 71 12 f0       	push   $0xf0127153
f010f11d:	e8 17 12 ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010f122:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010f129:	76 3a                	jbe    f010f165 <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010f12b:	83 ec 04             	sub    $0x4,%esp
f010f12e:	68 3c 72 12 f0       	push   $0xf012723c
f010f133:	6a 74                	push   $0x74
f010f135:	68 53 71 12 f0       	push   $0xf0127153
f010f13a:	e8 fa 11 ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010f13f:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010f146:	76 1d                	jbe    f010f165 <fault_handler+0x1bb>
f010f148:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010f14f:	77 14                	ja     f010f165 <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010f151:	83 ec 04             	sub    $0x4,%esp
f010f154:	68 60 72 12 f0       	push   $0xf0127260
f010f159:	6a 7c                	push   $0x7c
f010f15b:	68 53 71 12 f0       	push   $0xf0127153
f010f160:	e8 d4 11 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010f165:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f168:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010f16b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010f16f:	75 25                	jne    f010f196 <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010f171:	83 ec 0c             	sub    $0xc,%esp
f010f174:	ff 75 08             	pushl  0x8(%ebp)
f010f177:	e8 c4 e7 ff ff       	call   f010d940 <print_trapframe>
f010f17c:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010f17f:	83 ec 04             	sub    $0x4,%esp
f010f182:	68 81 72 12 f0       	push   $0xf0127281
f010f187:	68 85 00 00 00       	push   $0x85
f010f18c:	68 53 71 12 f0       	push   $0xf0127153
f010f191:	e8 a3 11 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010f196:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f199:	8b 40 64             	mov    0x64(%eax),%eax
f010f19c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f19f:	c1 ea 16             	shr    $0x16,%edx
f010f1a2:	c1 e2 02             	shl    $0x2,%edx
f010f1a5:	01 d0                	add    %edx,%eax
f010f1a7:	8b 00                	mov    (%eax),%eax
f010f1a9:	83 e0 01             	and    $0x1,%eax
f010f1ac:	85 c0                	test   %eax,%eax
f010f1ae:	75 2b                	jne    f010f1db <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010f1b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f1b3:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010f1b9:	8d 50 01             	lea    0x1(%eax),%edx
f010f1bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f1bf:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010f1c5:	83 ec 08             	sub    $0x8,%esp
f010f1c8:	ff 75 ec             	pushl  -0x14(%ebp)
f010f1cb:	ff 75 e0             	pushl  -0x20(%ebp)
f010f1ce:	e8 1e 01 00 00       	call   f010f2f1 <table_fault_handler>
f010f1d3:	83 c4 10             	add    $0x10,%esp
f010f1d6:	e9 07 01 00 00       	jmp    f010f2e2 <fault_handler+0x338>
	}
	else
	{
		if (userTrap)
f010f1db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f1df:	0f 84 82 00 00 00    	je     f010f267 <fault_handler+0x2bd>
		{
			/*============================================================================================*/
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010f1e5:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010f1ec:	76 07                	jbe    f010f1f5 <fault_handler+0x24b>
			{
				env_exit();
f010f1ee:	e8 55 c0 ff ff       	call   f010b248 <env_exit>
f010f1f3:	eb 72                	jmp    f010f267 <fault_handler+0x2bd>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010f1f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f1f8:	8b 40 64             	mov    0x64(%eax),%eax
f010f1fb:	83 ec 08             	sub    $0x8,%esp
f010f1fe:	ff 75 ec             	pushl  -0x14(%ebp)
f010f201:	50                   	push   %eax
f010f202:	e8 87 a3 ff ff       	call   f010958e <pt_get_page_permissions>
f010f207:	83 c4 10             	add    $0x10,%esp
f010f20a:	25 00 02 00 00       	and    $0x200,%eax
f010f20f:	85 c0                	test   %eax,%eax
f010f211:	75 17                	jne    f010f22a <fault_handler+0x280>
f010f213:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f216:	85 c0                	test   %eax,%eax
f010f218:	79 10                	jns    f010f22a <fault_handler+0x280>
f010f21a:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010f221:	77 07                	ja     f010f22a <fault_handler+0x280>
			{
			env_exit();
f010f223:	e8 20 c0 ff ff       	call   f010b248 <env_exit>
f010f228:	eb 3d                	jmp    f010f267 <fault_handler+0x2bd>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && (pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE) != PERM_WRITEABLE)
f010f22a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f22d:	8b 40 64             	mov    0x64(%eax),%eax
f010f230:	83 ec 08             	sub    $0x8,%esp
f010f233:	ff 75 ec             	pushl  -0x14(%ebp)
f010f236:	50                   	push   %eax
f010f237:	e8 52 a3 ff ff       	call   f010958e <pt_get_page_permissions>
f010f23c:	83 c4 10             	add    $0x10,%esp
f010f23f:	83 e0 01             	and    $0x1,%eax
f010f242:	85 c0                	test   %eax,%eax
f010f244:	74 21                	je     f010f267 <fault_handler+0x2bd>
f010f246:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f249:	8b 40 64             	mov    0x64(%eax),%eax
f010f24c:	83 ec 08             	sub    $0x8,%esp
f010f24f:	ff 75 ec             	pushl  -0x14(%ebp)
f010f252:	50                   	push   %eax
f010f253:	e8 36 a3 ff ff       	call   f010958e <pt_get_page_permissions>
f010f258:	83 c4 10             	add    $0x10,%esp
f010f25b:	83 e0 02             	and    $0x2,%eax
f010f25e:	85 c0                	test   %eax,%eax
f010f260:	75 05                	jne    f010f267 <fault_handler+0x2bd>
			{
				env_exit();
f010f262:	e8 e1 bf ff ff       	call   f010b248 <env_exit>
			}
			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010f267:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f26a:	8b 40 64             	mov    0x64(%eax),%eax
f010f26d:	83 ec 08             	sub    $0x8,%esp
f010f270:	ff 75 ec             	pushl  -0x14(%ebp)
f010f273:	50                   	push   %eax
f010f274:	e8 15 a3 ff ff       	call   f010958e <pt_get_page_permissions>
f010f279:	83 c4 10             	add    $0x10,%esp
f010f27c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010f27f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f282:	83 e0 01             	and    $0x1,%eax
f010f285:	85 c0                	test   %eax,%eax
f010f287:	74 17                	je     f010f2a0 <fault_handler+0x2f6>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010f289:	ff 75 ec             	pushl  -0x14(%ebp)
f010f28c:	68 98 72 12 f0       	push   $0xf0127298
f010f291:	68 ad 00 00 00       	push   $0xad
f010f296:	68 53 71 12 f0       	push   $0xf0127153
f010f29b:	e8 99 10 ff ff       	call   f0100339 <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010f2a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f2a3:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010f2a9:	8d 50 01             	lea    0x1(%eax),%edx
f010f2ac:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f2af:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010f2b5:	e8 ce fc ff ff       	call   f010ef88 <isBufferingEnabled>
f010f2ba:	84 c0                	test   %al,%al
f010f2bc:	74 13                	je     f010f2d1 <fault_handler+0x327>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010f2be:	83 ec 08             	sub    $0x8,%esp
f010f2c1:	ff 75 ec             	pushl  -0x14(%ebp)
f010f2c4:	ff 75 e0             	pushl  -0x20(%ebp)
f010f2c7:	e8 fe 01 00 00       	call   f010f4ca <__page_fault_handler_with_buffering>
f010f2cc:	83 c4 10             	add    $0x10,%esp
f010f2cf:	eb 11                	jmp    f010f2e2 <fault_handler+0x338>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010f2d1:	83 ec 08             	sub    $0x8,%esp
f010f2d4:	ff 75 ec             	pushl  -0x14(%ebp)
f010f2d7:	ff 75 e0             	pushl  -0x20(%ebp)
f010f2da:	e8 33 00 00 00       	call   f010f312 <page_fault_handler>
f010f2df:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010f2e2:	0f 20 d8             	mov    %cr3,%eax
f010f2e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010f2e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f2eb:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010f2ee:	90                   	nop
f010f2ef:	c9                   	leave  
f010f2f0:	c3                   	ret    

f010f2f1 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010f2f1:	55                   	push   %ebp
f010f2f2:	89 e5                	mov    %esp,%ebp
f010f2f4:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010f2f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010f2fa:	8b 40 64             	mov    0x64(%eax),%eax
f010f2fd:	83 ec 08             	sub    $0x8,%esp
f010f300:	ff 75 0c             	pushl  0xc(%ebp)
f010f303:	50                   	push   %eax
f010f304:	e8 3c 92 ff ff       	call   f0108545 <create_page_table>
f010f309:	83 c4 10             	add    $0x10,%esp
f010f30c:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010f30f:	90                   	nop
f010f310:	c9                   	leave  
f010f311:	c3                   	ret    

f010f312 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010f312:	55                   	push   %ebp
f010f313:	89 e5                	mov    %esp,%ebp
f010f315:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010f318:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010f31f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f322:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010f328:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010f32b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f32e:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010f334:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010f337:	0f 86 74 01 00 00    	jbe    f010f4b1 <page_fault_handler+0x19f>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010f33d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f340:	83 ec 08             	sub    $0x8,%esp
f010f343:	50                   	push   %eax
f010f344:	ff 75 08             	pushl  0x8(%ebp)
f010f347:	e8 95 51 ff ff       	call   f01044e1 <pf_read_env_page>
f010f34c:	83 c4 10             	add    $0x10,%esp
f010f34f:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010f352:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010f356:	75 45                	jne    f010f39d <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010f358:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f35b:	85 c0                	test   %eax,%eax
f010f35d:	79 09                	jns    f010f368 <page_fault_handler+0x56>
f010f35f:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010f366:	76 35                	jbe    f010f39d <page_fault_handler+0x8b>
f010f368:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010f36f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f372:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010f377:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010f37a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f37d:	ba 00 00 00 00       	mov    $0x0,%edx
f010f382:	f7 75 e8             	divl   -0x18(%ebp)
f010f385:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f388:	29 d0                	sub    %edx,%eax
f010f38a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010f38d:	77 09                	ja     f010f398 <page_fault_handler+0x86>
f010f38f:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010f396:	76 05                	jbe    f010f39d <page_fault_handler+0x8b>
			{
				env_exit();
f010f398:	e8 ab be ff ff       	call   f010b248 <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010f39d:	83 ec 0c             	sub    $0xc,%esp
f010f3a0:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f3a3:	50                   	push   %eax
f010f3a4:	e8 09 8e ff ff       	call   f01081b2 <allocate_frame>
f010f3a9:	83 c4 10             	add    $0x10,%esp
f010f3ac:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010f3af:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010f3b3:	74 34                	je     f010f3e9 <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010f3b5:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010f3b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010f3bb:	8b 40 64             	mov    0x64(%eax),%eax
f010f3be:	6a 06                	push   $0x6
f010f3c0:	ff 75 0c             	pushl  0xc(%ebp)
f010f3c3:	52                   	push   %edx
f010f3c4:	50                   	push   %eax
f010f3c5:	e8 b5 92 ff ff       	call   f010867f <map_frame>
f010f3ca:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010f3cd:	83 ec 08             	sub    $0x8,%esp
f010f3d0:	ff 75 0c             	pushl  0xc(%ebp)
f010f3d3:	ff 75 08             	pushl  0x8(%ebp)
f010f3d6:	e8 25 a3 ff ff       	call   f0109700 <env_page_ws_list_create_element>
f010f3db:	83 c4 10             	add    $0x10,%esp
f010f3de:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010f3e1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010f3e5:	75 30                	jne    f010f417 <page_fault_handler+0x105>
f010f3e7:	eb 17                	jmp    f010f400 <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010f3e9:	83 ec 04             	sub    $0x4,%esp
f010f3ec:	68 dc 72 12 f0       	push   $0xf01272dc
f010f3f1:	68 03 01 00 00       	push   $0x103
f010f3f6:	68 53 71 12 f0       	push   $0xf0127153
f010f3fb:	e8 39 0f ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010f400:	83 ec 04             	sub    $0x4,%esp
f010f403:	68 f4 72 12 f0       	push   $0xf01272f4
f010f408:	68 05 01 00 00       	push   $0x105
f010f40d:	68 53 71 12 f0       	push   $0xf0127153
f010f412:	e8 22 0f ff ff       	call   f0100339 <_panic>
f010f417:	8b 45 08             	mov    0x8(%ebp),%eax
f010f41a:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010f420:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f423:	89 50 14             	mov    %edx,0x14(%eax)
f010f426:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f429:	8b 40 14             	mov    0x14(%eax),%eax
f010f42c:	85 c0                	test   %eax,%eax
f010f42e:	74 11                	je     f010f441 <page_fault_handler+0x12f>
f010f430:	8b 45 08             	mov    0x8(%ebp),%eax
f010f433:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010f439:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010f43c:	89 50 10             	mov    %edx,0x10(%eax)
f010f43f:	eb 0c                	jmp    f010f44d <page_fault_handler+0x13b>
f010f441:	8b 45 08             	mov    0x8(%ebp),%eax
f010f444:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010f447:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010f44d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f450:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010f453:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010f459:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f45c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010f463:	8b 45 08             	mov    0x8(%ebp),%eax
f010f466:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010f46c:	8d 50 01             	lea    0x1(%eax),%edx
f010f46f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f472:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010f478:	8b 45 08             	mov    0x8(%ebp),%eax
f010f47b:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010f481:	8b 45 08             	mov    0x8(%ebp),%eax
f010f484:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010f48a:	39 c2                	cmp    %eax,%edx
f010f48c:	75 14                	jne    f010f4a2 <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010f48e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f491:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010f497:	8b 45 08             	mov    0x8(%ebp),%eax
f010f49a:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010f4a0:	eb 26                	jmp    f010f4c8 <page_fault_handler+0x1b6>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f010f4a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010f4a5:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010f4ac:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010f4af:	eb 17                	jmp    f010f4c8 <page_fault_handler+0x1b6>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010f4b1:	83 ec 04             	sub    $0x4,%esp
f010f4b4:	68 18 73 12 f0       	push   $0xf0127318
f010f4b9:	68 15 01 00 00       	push   $0x115
f010f4be:	68 53 71 12 f0       	push   $0xf0127153
f010f4c3:	e8 71 0e ff ff       	call   f0100339 <_panic>
	}
}
f010f4c8:	c9                   	leave  
f010f4c9:	c3                   	ret    

f010f4ca <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010f4ca:	55                   	push   %ebp
f010f4cb:	89 e5                	mov    %esp,%ebp
f010f4cd:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010f4d0:	83 ec 04             	sub    $0x4,%esp
f010f4d3:	68 58 73 12 f0       	push   $0xf0127358
f010f4d8:	68 1d 01 00 00       	push   $0x11d
f010f4dd:	68 53 71 12 f0       	push   $0xf0127153
f010f4e2:	e8 52 0e ff ff       	call   f0100339 <_panic>

f010f4e7 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010f4e7:	55                   	push   %ebp
f010f4e8:	89 e5                	mov    %esp,%ebp
f010f4ea:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010f4ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010f4f0:	83 c0 04             	add    $0x4,%eax
f010f4f3:	83 ec 08             	sub    $0x8,%esp
f010f4f6:	ff 75 0c             	pushl  0xc(%ebp)
f010f4f9:	50                   	push   %eax
f010f4fa:	e8 29 00 01 00       	call   f011f528 <strcpy>
f010f4ff:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010f502:	8b 45 08             	mov    0x8(%ebp),%eax
f010f505:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010f50b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f50e:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010f515:	90                   	nop
f010f516:	c9                   	leave  
f010f517:	c3                   	ret    

f010f518 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010f518:	55                   	push   %ebp
f010f519:	89 e5                	mov    %esp,%ebp
f010f51b:	53                   	push   %ebx
f010f51c:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010f51f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f522:	83 ec 0c             	sub    $0xc,%esp
f010f525:	50                   	push   %eax
f010f526:	e8 06 02 00 00       	call   f010f731 <holding_spinlock>
f010f52b:	83 c4 10             	add    $0x10,%esp
f010f52e:	85 c0                	test   %eax,%eax
f010f530:	74 18                	je     f010f54a <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010f532:	8b 45 08             	mov    0x8(%ebp),%eax
f010f535:	83 c0 04             	add    $0x4,%eax
f010f538:	50                   	push   %eax
f010f539:	68 9c 73 12 f0       	push   $0xf012739c
f010f53e:	6a 1f                	push   $0x1f
f010f540:	68 d9 73 12 f0       	push   $0xf01273d9
f010f545:	e8 ef 0d ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010f54a:	e8 80 7c ff ff       	call   f01071cf <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010f54f:	90                   	nop
f010f550:	8b 45 08             	mov    0x8(%ebp),%eax
f010f553:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010f556:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010f55d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f560:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f563:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010f566:	f0 87 02             	lock xchg %eax,(%edx)
f010f569:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010f56c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f56f:	85 c0                	test   %eax,%eax
f010f571:	75 dd                	jne    f010f550 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010f573:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010f578:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010f57b:	e8 8c 7b ff ff       	call   f010710c <mycpu>
f010f580:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010f583:	8b 45 08             	mov    0x8(%ebp),%eax
f010f586:	83 c0 48             	add    $0x48,%eax
f010f589:	83 ec 08             	sub    $0x8,%esp
f010f58c:	50                   	push   %eax
f010f58d:	8d 45 08             	lea    0x8(%ebp),%eax
f010f590:	50                   	push   %eax
f010f591:	e8 74 00 00 00       	call   f010f60a <getcallerpcs>
f010f596:	83 c4 10             	add    $0x10,%esp

}
f010f599:	90                   	nop
f010f59a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010f59d:	c9                   	leave  
f010f59e:	c3                   	ret    

f010f59f <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010f59f:	55                   	push   %ebp
f010f5a0:	89 e5                	mov    %esp,%ebp
f010f5a2:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010f5a5:	83 ec 0c             	sub    $0xc,%esp
f010f5a8:	ff 75 08             	pushl  0x8(%ebp)
f010f5ab:	e8 81 01 00 00       	call   f010f731 <holding_spinlock>
f010f5b0:	83 c4 10             	add    $0x10,%esp
f010f5b3:	85 c0                	test   %eax,%eax
f010f5b5:	75 26                	jne    f010f5dd <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010f5b7:	83 ec 0c             	sub    $0xc,%esp
f010f5ba:	ff 75 08             	pushl  0x8(%ebp)
f010f5bd:	e8 08 01 00 00       	call   f010f6ca <printcallstack>
f010f5c2:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010f5c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5c8:	83 c0 04             	add    $0x4,%eax
f010f5cb:	50                   	push   %eax
f010f5cc:	68 f0 73 12 f0       	push   $0xf01273f0
f010f5d1:	6a 3c                	push   $0x3c
f010f5d3:	68 d9 73 12 f0       	push   $0xf01273d9
f010f5d8:	e8 5c 0d ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010f5dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5e0:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010f5e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5ea:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010f5f1:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010f5f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5f9:	8b 55 08             	mov    0x8(%ebp),%edx
f010f5fc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010f602:	e8 1a 7c ff ff       	call   f0107221 <popcli>
}
f010f607:	90                   	nop
f010f608:	c9                   	leave  
f010f609:	c3                   	ret    

f010f60a <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010f60a:	55                   	push   %ebp
f010f60b:	89 e5                	mov    %esp,%ebp
f010f60d:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010f610:	e8 75 bc ff ff       	call   f010b28a <get_cpu_proc>
f010f615:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010f618:	e8 ef 7a ff ff       	call   f010710c <mycpu>
f010f61d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010f620:	8b 45 08             	mov    0x8(%ebp),%eax
f010f623:	83 e8 08             	sub    $0x8,%eax
f010f626:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010f629:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010f630:	eb 67                	jmp    f010f699 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010f632:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f636:	74 67                	je     f010f69f <getcallerpcs+0x95>
f010f638:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010f63f:	76 5e                	jbe    f010f69f <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010f641:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f644:	8b 40 08             	mov    0x8(%eax),%eax
f010f647:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010f64c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f64f:	77 10                	ja     f010f661 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010f651:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f654:	8b 40 08             	mov    0x8(%eax),%eax
f010f657:	05 00 90 00 00       	add    $0x9000,%eax
f010f65c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f65f:	77 3e                	ja     f010f69f <getcallerpcs+0x95>
f010f661:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f665:	74 10                	je     f010f677 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010f667:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f66a:	8b 40 70             	mov    0x70(%eax),%eax
f010f66d:	05 00 80 00 00       	add    $0x8000,%eax
f010f672:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f675:	76 28                	jbe    f010f69f <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010f677:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f67a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f681:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f684:	01 c2                	add    %eax,%edx
f010f686:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f689:	8b 40 04             	mov    0x4(%eax),%eax
f010f68c:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010f68e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f691:	8b 00                	mov    (%eax),%eax
f010f693:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010f696:	ff 45 f0             	incl   -0x10(%ebp)
f010f699:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010f69d:	7e 93                	jle    f010f632 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010f69f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f6a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010f6a5:	eb 18                	jmp    f010f6bf <getcallerpcs+0xb5>
		pcs[i] = 0;
f010f6a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f6aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f6b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6b4:	01 d0                	add    %edx,%eax
f010f6b6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010f6bc:	ff 45 f0             	incl   -0x10(%ebp)
f010f6bf:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010f6c3:	7e e2                	jle    f010f6a7 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010f6c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010f6c8:	c9                   	leave  
f010f6c9:	c3                   	ret    

f010f6ca <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010f6ca:	55                   	push   %ebp
f010f6cb:	89 e5                	mov    %esp,%ebp
f010f6cd:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010f6d0:	83 ec 0c             	sub    $0xc,%esp
f010f6d3:	68 2e 74 12 f0       	push   $0xf012742e
f010f6d8:	e8 ae 18 ff ff       	call   f0100f8b <cprintf>
f010f6dd:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010f6e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6e3:	83 c0 48             	add    $0x48,%eax
f010f6e6:	83 ec 08             	sub    $0x8,%esp
f010f6e9:	50                   	push   %eax
f010f6ea:	8d 45 08             	lea    0x8(%ebp),%eax
f010f6ed:	50                   	push   %eax
f010f6ee:	e8 17 ff ff ff       	call   f010f60a <getcallerpcs>
f010f6f3:	83 c4 10             	add    $0x10,%esp
f010f6f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010f6f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010f700:	eb 24                	jmp    f010f726 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010f702:	8b 45 08             	mov    0x8(%ebp),%eax
f010f705:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f708:	83 c2 10             	add    $0x10,%edx
f010f70b:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010f70f:	83 ec 04             	sub    $0x4,%esp
f010f712:	50                   	push   %eax
f010f713:	ff 75 f4             	pushl  -0xc(%ebp)
f010f716:	68 3e 74 12 f0       	push   $0xf012743e
f010f71b:	e8 6b 18 ff ff       	call   f0100f8b <cprintf>
f010f720:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010f723:	ff 45 f4             	incl   -0xc(%ebp)
f010f726:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f729:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010f72c:	7c d4                	jl     f010f702 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010f72e:	90                   	nop
f010f72f:	c9                   	leave  
f010f730:	c3                   	ret    

f010f731 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010f731:	55                   	push   %ebp
f010f732:	89 e5                	mov    %esp,%ebp
f010f734:	53                   	push   %ebx
f010f735:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010f738:	e8 92 7a ff ff       	call   f01071cf <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010f73d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f740:	8b 00                	mov    (%eax),%eax
f010f742:	85 c0                	test   %eax,%eax
f010f744:	74 16                	je     f010f75c <holding_spinlock+0x2b>
f010f746:	8b 45 08             	mov    0x8(%ebp),%eax
f010f749:	8b 58 44             	mov    0x44(%eax),%ebx
f010f74c:	e8 bb 79 ff ff       	call   f010710c <mycpu>
f010f751:	39 c3                	cmp    %eax,%ebx
f010f753:	75 07                	jne    f010f75c <holding_spinlock+0x2b>
f010f755:	b8 01 00 00 00       	mov    $0x1,%eax
f010f75a:	eb 05                	jmp    f010f761 <holding_spinlock+0x30>
f010f75c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f761:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010f764:	e8 b8 7a ff ff       	call   f0107221 <popcli>
	return r;
f010f769:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010f76c:	83 c4 14             	add    $0x14,%esp
f010f76f:	5b                   	pop    %ebx
f010f770:	5d                   	pop    %ebp
f010f771:	c3                   	ret    

f010f772 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010f772:	55                   	push   %ebp
f010f773:	89 e5                	mov    %esp,%ebp
f010f775:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f010f778:	8b 45 08             	mov    0x8(%ebp),%eax
f010f77b:	83 c0 74             	add    $0x74,%eax
f010f77e:	83 ec 08             	sub    $0x8,%esp
f010f781:	68 4d 74 12 f0       	push   $0xf012744d
f010f786:	50                   	push   %eax
f010f787:	e8 4c 01 00 00       	call   f010f8d8 <init_channel>
f010f78c:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010f78f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f792:	83 c0 04             	add    $0x4,%eax
f010f795:	83 ec 08             	sub    $0x8,%esp
f010f798:	68 60 74 12 f0       	push   $0xf0127460
f010f79d:	50                   	push   %eax
f010f79e:	e8 44 fd ff ff       	call   f010f4e7 <init_spinlock>
f010f7a3:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010f7a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7a9:	05 c4 00 00 00       	add    $0xc4,%eax
f010f7ae:	83 ec 08             	sub    $0x8,%esp
f010f7b1:	ff 75 0c             	pushl  0xc(%ebp)
f010f7b4:	50                   	push   %eax
f010f7b5:	e8 6e fd 00 00       	call   f011f528 <strcpy>
f010f7ba:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010f7bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010f7c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7c9:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010f7d0:	00 00 00 
}
f010f7d3:	90                   	nop
f010f7d4:	c9                   	leave  
f010f7d5:	c3                   	ret    

f010f7d6 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010f7d6:	55                   	push   %ebp
f010f7d7:	89 e5                	mov    %esp,%ebp
f010f7d9:	53                   	push   %ebx
f010f7da:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010f7dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7e0:	83 c0 04             	add    $0x4,%eax
f010f7e3:	83 ec 0c             	sub    $0xc,%esp
f010f7e6:	50                   	push   %eax
f010f7e7:	e8 2c fd ff ff       	call   f010f518 <acquire_spinlock>
f010f7ec:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010f7ef:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7f2:	8b 00                	mov    (%eax),%eax
f010f7f4:	85 c0                	test   %eax,%eax
f010f7f6:	74 1c                	je     f010f814 <holding_sleeplock+0x3e>
f010f7f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7fb:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010f801:	e8 84 ba ff ff       	call   f010b28a <get_cpu_proc>
f010f806:	8b 40 10             	mov    0x10(%eax),%eax
f010f809:	39 c3                	cmp    %eax,%ebx
f010f80b:	75 07                	jne    f010f814 <holding_sleeplock+0x3e>
f010f80d:	b8 01 00 00 00       	mov    $0x1,%eax
f010f812:	eb 05                	jmp    f010f819 <holding_sleeplock+0x43>
f010f814:	b8 00 00 00 00       	mov    $0x0,%eax
f010f819:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010f81c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f81f:	83 c0 04             	add    $0x4,%eax
f010f822:	83 ec 0c             	sub    $0xc,%esp
f010f825:	50                   	push   %eax
f010f826:	e8 74 fd ff ff       	call   f010f59f <release_spinlock>
f010f82b:	83 c4 10             	add    $0x10,%esp
	return r;
f010f82e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010f831:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010f834:	c9                   	leave  
f010f835:	c3                   	ret    

f010f836 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010f836:	55                   	push   %ebp
f010f837:	89 e5                	mov    %esp,%ebp
f010f839:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010f83c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f83f:	83 c0 04             	add    $0x4,%eax
f010f842:	83 ec 0c             	sub    $0xc,%esp
f010f845:	50                   	push   %eax
f010f846:	e8 cd fc ff ff       	call   f010f518 <acquire_spinlock>
f010f84b:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f010f84e:	eb 19                	jmp    f010f869 <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f010f850:	8b 45 08             	mov    0x8(%ebp),%eax
f010f853:	8d 50 04             	lea    0x4(%eax),%edx
f010f856:	8b 45 08             	mov    0x8(%ebp),%eax
f010f859:	83 c0 74             	add    $0x74,%eax
f010f85c:	83 ec 08             	sub    $0x8,%esp
f010f85f:	52                   	push   %edx
f010f860:	50                   	push   %eax
f010f861:	e8 9f 00 00 00       	call   f010f905 <sleep>
f010f866:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f010f869:	8b 45 08             	mov    0x8(%ebp),%eax
f010f86c:	8b 00                	mov    (%eax),%eax
f010f86e:	85 c0                	test   %eax,%eax
f010f870:	75 de                	jne    f010f850 <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f010f872:	8b 45 08             	mov    0x8(%ebp),%eax
f010f875:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f010f87b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f87e:	83 c0 04             	add    $0x4,%eax
f010f881:	83 ec 0c             	sub    $0xc,%esp
f010f884:	50                   	push   %eax
f010f885:	e8 15 fd ff ff       	call   f010f59f <release_spinlock>
f010f88a:	83 c4 10             	add    $0x10,%esp

}
f010f88d:	90                   	nop
f010f88e:	c9                   	leave  
f010f88f:	c3                   	ret    

f010f890 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f010f890:	55                   	push   %ebp
f010f891:	89 e5                	mov    %esp,%ebp
f010f893:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010f896:	8b 45 08             	mov    0x8(%ebp),%eax
f010f899:	83 c0 04             	add    $0x4,%eax
f010f89c:	83 ec 0c             	sub    $0xc,%esp
f010f89f:	50                   	push   %eax
f010f8a0:	e8 73 fc ff ff       	call   f010f518 <acquire_spinlock>
f010f8a5:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f010f8a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8ab:	83 c0 74             	add    $0x74,%eax
f010f8ae:	83 ec 0c             	sub    $0xc,%esp
f010f8b1:	50                   	push   %eax
f010f8b2:	e8 3f 01 00 00       	call   f010f9f6 <wakeup_all>
f010f8b7:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f010f8ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8bd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f010f8c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8c6:	83 c0 04             	add    $0x4,%eax
f010f8c9:	83 ec 0c             	sub    $0xc,%esp
f010f8cc:	50                   	push   %eax
f010f8cd:	e8 cd fc ff ff       	call   f010f59f <release_spinlock>
f010f8d2:	83 c4 10             	add    $0x10,%esp
}
f010f8d5:	90                   	nop
f010f8d6:	c9                   	leave  
f010f8d7:	c3                   	ret    

f010f8d8 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010f8d8:	55                   	push   %ebp
f010f8d9:	89 e5                	mov    %esp,%ebp
f010f8db:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010f8de:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8e1:	83 c0 10             	add    $0x10,%eax
f010f8e4:	83 ec 08             	sub    $0x8,%esp
f010f8e7:	ff 75 0c             	pushl  0xc(%ebp)
f010f8ea:	50                   	push   %eax
f010f8eb:	e8 38 fc 00 00       	call   f011f528 <strcpy>
f010f8f0:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010f8f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8f6:	83 ec 0c             	sub    $0xc,%esp
f010f8f9:	50                   	push   %eax
f010f8fa:	e8 6a 56 ff ff       	call   f0104f69 <init_queue>
f010f8ff:	83 c4 10             	add    $0x10,%esp
}
f010f902:	90                   	nop
f010f903:	c9                   	leave  
f010f904:	c3                   	ret    

f010f905 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010f905:	55                   	push   %ebp
f010f906:	89 e5                	mov    %esp,%ebp
f010f908:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f010f90b:	83 ec 0c             	sub    $0xc,%esp
f010f90e:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010f913:	e8 00 fc ff ff       	call   f010f518 <acquire_spinlock>
f010f918:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f010f91b:	e8 6a b9 ff ff       	call   f010b28a <get_cpu_proc>
f010f920:	89 c2                	mov    %eax,%edx
f010f922:	8b 45 08             	mov    0x8(%ebp),%eax
f010f925:	83 ec 08             	sub    $0x8,%esp
f010f928:	52                   	push   %edx
f010f929:	50                   	push   %eax
f010f92a:	e8 7b 56 ff ff       	call   f0104faa <enqueue>
f010f92f:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f010f932:	e8 53 b9 ff ff       	call   f010b28a <get_cpu_proc>
f010f937:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f010f93e:	83 ec 0c             	sub    $0xc,%esp
f010f941:	ff 75 0c             	pushl  0xc(%ebp)
f010f944:	e8 56 fc ff ff       	call   f010f59f <release_spinlock>
f010f949:	83 c4 10             	add    $0x10,%esp
	sched();
f010f94c:	e8 ba ba ff ff       	call   f010b40b <sched>
	release_spinlock(&(ProcessQueues.qlock));
f010f951:	83 ec 0c             	sub    $0xc,%esp
f010f954:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010f959:	e8 41 fc ff ff       	call   f010f59f <release_spinlock>
f010f95e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f010f961:	83 ec 0c             	sub    $0xc,%esp
f010f964:	ff 75 0c             	pushl  0xc(%ebp)
f010f967:	e8 ac fb ff ff       	call   f010f518 <acquire_spinlock>
f010f96c:	83 c4 10             	add    $0x10,%esp
}
f010f96f:	90                   	nop
f010f970:	c9                   	leave  
f010f971:	c3                   	ret    

f010f972 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010f972:	55                   	push   %ebp
f010f973:	89 e5                	mov    %esp,%ebp
f010f975:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f010f978:	8b 45 08             	mov    0x8(%ebp),%eax
f010f97b:	83 ec 0c             	sub    $0xc,%esp
f010f97e:	50                   	push   %eax
f010f97f:	e8 0e 56 ff ff       	call   f0104f92 <queue_size>
f010f984:	83 c4 10             	add    $0x10,%esp
f010f987:	85 c0                	test   %eax,%eax
f010f989:	74 68                	je     f010f9f3 <wakeup_one+0x81>
		bool locked_by_me = 0;
f010f98b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f010f992:	83 ec 0c             	sub    $0xc,%esp
f010f995:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010f99a:	e8 92 fd ff ff       	call   f010f731 <holding_spinlock>
f010f99f:	83 c4 10             	add    $0x10,%esp
f010f9a2:	85 c0                	test   %eax,%eax
f010f9a4:	75 17                	jne    f010f9bd <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f010f9a6:	83 ec 0c             	sub    $0xc,%esp
f010f9a9:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010f9ae:	e8 65 fb ff ff       	call   f010f518 <acquire_spinlock>
f010f9b3:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f010f9b6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f010f9bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9c0:	83 ec 0c             	sub    $0xc,%esp
f010f9c3:	50                   	push   %eax
f010f9c4:	e8 72 56 ff ff       	call   f010503b <dequeue>
f010f9c9:	83 c4 10             	add    $0x10,%esp
f010f9cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f010f9cf:	83 ec 0c             	sub    $0xc,%esp
f010f9d2:	ff 75 f0             	pushl  -0x10(%ebp)
f010f9d5:	e8 9c 58 ff ff       	call   f0105276 <sched_insert_ready0>
f010f9da:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f010f9dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f9e1:	74 10                	je     f010f9f3 <wakeup_one+0x81>
f010f9e3:	83 ec 0c             	sub    $0xc,%esp
f010f9e6:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010f9eb:	e8 af fb ff ff       	call   f010f59f <release_spinlock>
f010f9f0:	83 c4 10             	add    $0x10,%esp
	}
}
f010f9f3:	90                   	nop
f010f9f4:	c9                   	leave  
f010f9f5:	c3                   	ret    

f010f9f6 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010f9f6:	55                   	push   %ebp
f010f9f7:	89 e5                	mov    %esp,%ebp
f010f9f9:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f010f9fc:	83 ec 0c             	sub    $0xc,%esp
f010f9ff:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010fa04:	e8 0f fb ff ff       	call   f010f518 <acquire_spinlock>
f010fa09:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f010fa0c:	eb 0e                	jmp    f010fa1c <wakeup_all+0x26>
		wakeup_one(chan);
f010fa0e:	83 ec 0c             	sub    $0xc,%esp
f010fa11:	ff 75 08             	pushl  0x8(%ebp)
f010fa14:	e8 59 ff ff ff       	call   f010f972 <wakeup_one>
f010fa19:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f010fa1c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa1f:	83 ec 0c             	sub    $0xc,%esp
f010fa22:	50                   	push   %eax
f010fa23:	e8 6a 55 ff ff       	call   f0104f92 <queue_size>
f010fa28:	83 c4 10             	add    $0x10,%esp
f010fa2b:	85 c0                	test   %eax,%eax
f010fa2d:	75 df                	jne    f010fa0e <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f010fa2f:	83 ec 0c             	sub    $0xc,%esp
f010fa32:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010fa37:	e8 63 fb ff ff       	call   f010f59f <release_spinlock>
f010fa3c:	83 c4 10             	add    $0x10,%esp
}
f010fa3f:	90                   	nop
f010fa40:	c9                   	leave  
f010fa41:	c3                   	ret    

f010fa42 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010fa42:	55                   	push   %ebp
f010fa43:	89 e5                	mov    %esp,%ebp
f010fa45:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010fa48:	83 ec 04             	sub    $0x4,%esp
f010fa4b:	68 74 74 12 f0       	push   $0xf0127474
f010fa50:	6a 13                	push   $0x13
f010fa52:	68 9b 74 12 f0       	push   $0xf012749b
f010fa57:	e8 dd 08 ff ff       	call   f0100339 <_panic>

f010fa5c <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010fa5c:	55                   	push   %ebp
f010fa5d:	89 e5                	mov    %esp,%ebp
f010fa5f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010fa62:	83 ec 04             	sub    $0x4,%esp
f010fa65:	68 b4 74 12 f0       	push   $0xf01274b4
f010fa6a:	6a 1b                	push   $0x1b
f010fa6c:	68 9b 74 12 f0       	push   $0xf012749b
f010fa71:	e8 c3 08 ff ff       	call   f0100339 <_panic>

f010fa76 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010fa76:	55                   	push   %ebp
f010fa77:	89 e5                	mov    %esp,%ebp
f010fa79:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010fa7c:	83 ec 04             	sub    $0x4,%esp
f010fa7f:	68 dc 74 12 f0       	push   $0xf01274dc
f010fa84:	6a 24                	push   $0x24
f010fa86:	68 9b 74 12 f0       	push   $0xf012749b
f010fa8b:	e8 a9 08 ff ff       	call   f0100339 <_panic>

f010fa90 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010fa90:	55                   	push   %ebp
f010fa91:	89 e5                	mov    %esp,%ebp
f010fa93:	c7 05 58 b8 6b f0 01 	movl   $0x1,0xf06bb858
f010fa9a:	00 00 00 
f010fa9d:	90                   	nop
f010fa9e:	5d                   	pop    %ebp
f010fa9f:	c3                   	ret    

f010faa0 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010faa0:	55                   	push   %ebp
f010faa1:	89 e5                	mov    %esp,%ebp
f010faa3:	c7 05 58 b8 6b f0 02 	movl   $0x2,0xf06bb858
f010faaa:	00 00 00 
f010faad:	90                   	nop
f010faae:	5d                   	pop    %ebp
f010faaf:	c3                   	ret    

f010fab0 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010fab0:	55                   	push   %ebp
f010fab1:	89 e5                	mov    %esp,%ebp
f010fab3:	c7 05 58 b8 6b f0 03 	movl   $0x3,0xf06bb858
f010faba:	00 00 00 
f010fabd:	90                   	nop
f010fabe:	5d                   	pop    %ebp
f010fabf:	c3                   	ret    

f010fac0 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010fac0:	55                   	push   %ebp
f010fac1:	89 e5                	mov    %esp,%ebp
f010fac3:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f010fac8:	83 f8 01             	cmp    $0x1,%eax
f010facb:	75 04                	jne    f010fad1 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010facd:	b0 01                	mov    $0x1,%al
f010facf:	eb 02                	jmp    f010fad3 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010fad1:	b0 00                	mov    $0x0,%al
f010fad3:	5d                   	pop    %ebp
f010fad4:	c3                   	ret    

f010fad5 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010fad5:	55                   	push   %ebp
f010fad6:	89 e5                	mov    %esp,%ebp
f010fad8:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f010fadd:	83 f8 02             	cmp    $0x2,%eax
f010fae0:	75 04                	jne    f010fae6 <isKHeapPlacementStrategyBESTFIT+0x11>
f010fae2:	b0 01                	mov    $0x1,%al
f010fae4:	eb 02                	jmp    f010fae8 <isKHeapPlacementStrategyBESTFIT+0x13>
f010fae6:	b0 00                	mov    $0x0,%al
f010fae8:	5d                   	pop    %ebp
f010fae9:	c3                   	ret    

f010faea <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010faea:	55                   	push   %ebp
f010faeb:	89 e5                	mov    %esp,%ebp
f010faed:	a1 58 b8 6b f0       	mov    0xf06bb858,%eax
f010faf2:	83 f8 03             	cmp    $0x3,%eax
f010faf5:	75 04                	jne    f010fafb <isKHeapPlacementStrategyNEXTFIT+0x11>
f010faf7:	b0 01                	mov    $0x1,%al
f010faf9:	eb 02                	jmp    f010fafd <isKHeapPlacementStrategyNEXTFIT+0x13>
f010fafb:	b0 00                	mov    $0x0,%al
f010fafd:	5d                   	pop    %ebp
f010fafe:	c3                   	ret    

f010faff <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010faff:	55                   	push   %ebp
f010fb00:	89 e5                	mov    %esp,%ebp
f010fb02:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010fb05:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010fb0c:	eb 26                	jmp    f010fb34 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010fb0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fb11:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fb18:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb1b:	01 c2                	add    %eax,%edx
f010fb1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fb20:	40                   	inc    %eax
f010fb21:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010fb28:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb2b:	01 c8                	add    %ecx,%eax
f010fb2d:	8b 00                	mov    (%eax),%eax
f010fb2f:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010fb31:	ff 45 f4             	incl   -0xc(%ebp)
f010fb34:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb37:	48                   	dec    %eax
f010fb38:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fb3b:	7f d1                	jg     f010fb0e <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010fb3d:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010fb40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010fb47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010fb4e:	eb 35                	jmp    f010fb85 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010fb50:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fb53:	89 d0                	mov    %edx,%eax
f010fb55:	01 c0                	add    %eax,%eax
f010fb57:	01 d0                	add    %edx,%eax
f010fb59:	c1 e0 02             	shl    $0x2,%eax
f010fb5c:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f010fb61:	8b 10                	mov    (%eax),%edx
f010fb63:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb66:	8b 00                	mov    (%eax),%eax
f010fb68:	83 ec 08             	sub    $0x8,%esp
f010fb6b:	52                   	push   %edx
f010fb6c:	50                   	push   %eax
f010fb6d:	e8 73 fa 00 00       	call   f011f5e5 <strcmp>
f010fb72:	83 c4 10             	add    $0x10,%esp
f010fb75:	85 c0                	test   %eax,%eax
f010fb77:	75 09                	jne    f010fb82 <tst_handler+0x83>
		{
			test_found = 1;
f010fb79:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010fb80:	eb 0f                	jmp    f010fb91 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010fb82:	ff 45 ec             	incl   -0x14(%ebp)
f010fb85:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fb88:	a1 b4 ed 17 f0       	mov    0xf017edb4,%eax
f010fb8d:	39 c2                	cmp    %eax,%edx
f010fb8f:	72 bf                	jb     f010fb50 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010fb91:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fb95:	74 29                	je     f010fbc0 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010fb97:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fb9a:	89 d0                	mov    %edx,%eax
f010fb9c:	01 c0                	add    %eax,%eax
f010fb9e:	01 d0                	add    %edx,%eax
f010fba0:	c1 e0 02             	shl    $0x2,%eax
f010fba3:	05 08 ed 17 f0       	add    $0xf017ed08,%eax
f010fba8:	8b 00                	mov    (%eax),%eax
f010fbaa:	83 ec 08             	sub    $0x8,%esp
f010fbad:	ff 75 0c             	pushl  0xc(%ebp)
f010fbb0:	ff 75 08             	pushl  0x8(%ebp)
f010fbb3:	ff d0                	call   *%eax
f010fbb5:	83 c4 10             	add    $0x10,%esp
f010fbb8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010fbbb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fbbe:	eb 1b                	jmp    f010fbdb <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010fbc0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fbc3:	8b 00                	mov    (%eax),%eax
f010fbc5:	83 ec 08             	sub    $0x8,%esp
f010fbc8:	50                   	push   %eax
f010fbc9:	68 1c 78 12 f0       	push   $0xf012781c
f010fbce:	e8 b8 13 ff ff       	call   f0100f8b <cprintf>
f010fbd3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fbd6:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010fbdb:	c9                   	leave  
f010fbdc:	c3                   	ret    

f010fbdd <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010fbdd:	55                   	push   %ebp
f010fbde:	89 e5                	mov    %esp,%ebp
f010fbe0:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010fbe3:	e8 7c d0 00 00       	call   f011cc64 <test_three_creation_functions>
	return 0;
f010fbe8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fbed:	c9                   	leave  
f010fbee:	c3                   	ret    

f010fbef <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010fbef:	55                   	push   %ebp
f010fbf0:	89 e5                	mov    %esp,%ebp
f010fbf2:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010fbf5:	e8 03 69 00 00       	call   f01164fd <test_priority_normal_and_higher>
	return 0;
f010fbfa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fbff:	c9                   	leave  
f010fc00:	c3                   	ret    

f010fc01 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010fc01:	55                   	push   %ebp
f010fc02:	89 e5                	mov    %esp,%ebp
f010fc04:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010fc07:	e8 0b 69 00 00       	call   f0116517 <test_priority_normal_and_lower>
	return 0;
f010fc0c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fc11:	c9                   	leave  
f010fc12:	c3                   	ret    

f010fc13 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010fc13:	55                   	push   %ebp
f010fc14:	89 e5                	mov    %esp,%ebp
f010fc16:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010fc19:	e8 f9 d1 00 00       	call   f011ce17 <test_kfreeall>
	return 0;
f010fc1e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fc23:	c9                   	leave  
f010fc24:	c3                   	ret    

f010fc25 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010fc25:	55                   	push   %ebp
f010fc26:	89 e5                	mov    %esp,%ebp
f010fc28:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010fc2b:	e8 04 d2 00 00       	call   f011ce34 <test_kexpand>
	return 0;
f010fc30:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fc35:	c9                   	leave  
f010fc36:	c3                   	ret    

f010fc37 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010fc37:	55                   	push   %ebp
f010fc38:	89 e5                	mov    %esp,%ebp
f010fc3a:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010fc3d:	e8 0f d2 00 00       	call   f011ce51 <test_kshrink>
	return 0;
f010fc42:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fc47:	c9                   	leave  
f010fc48:	c3                   	ret    

f010fc49 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010fc49:	55                   	push   %ebp
f010fc4a:	89 e5                	mov    %esp,%ebp
f010fc4c:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010fc4f:	e8 1a d2 00 00       	call   f011ce6e <test_kfreelast>
	return 0;
f010fc54:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fc59:	c9                   	leave  
f010fc5a:	c3                   	ret    

f010fc5b <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010fc5b:	55                   	push   %ebp
f010fc5c:	89 e5                	mov    %esp,%ebp
f010fc5e:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010fc61:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc64:	83 c0 04             	add    $0x4,%eax
f010fc67:	8b 00                	mov    (%eax),%eax
f010fc69:	83 ec 04             	sub    $0x4,%esp
f010fc6c:	6a 0a                	push   $0xa
f010fc6e:	6a 00                	push   $0x0
f010fc70:	50                   	push   %eax
f010fc71:	e8 c3 fb 00 00       	call   f011f839 <strtol>
f010fc76:	83 c4 10             	add    $0x10,%esp
f010fc79:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010fc7c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010fc83:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010fc8a:	83 ec 0c             	sub    $0xc,%esp
f010fc8d:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010fc92:	e8 81 f8 ff ff       	call   f010f518 <acquire_spinlock>
f010fc97:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010fc9a:	a1 40 b3 6b f0       	mov    0xf06bb340,%eax
f010fc9f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fca2:	eb 3b                	jmp    f010fcdf <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010fca4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fca7:	83 c0 20             	add    $0x20,%eax
f010fcaa:	83 ec 08             	sub    $0x8,%esp
f010fcad:	68 2f 78 12 f0       	push   $0xf012782f
f010fcb2:	50                   	push   %eax
f010fcb3:	e8 2d f9 00 00       	call   f011f5e5 <strcmp>
f010fcb8:	83 c4 10             	add    $0x10,%esp
f010fcbb:	85 c0                	test   %eax,%eax
f010fcbd:	75 12                	jne    f010fcd1 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010fcbf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fcc3:	74 07                	je     f010fccc <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010fcc5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010fccc:	ff 45 f4             	incl   -0xc(%ebp)
f010fccf:	eb 06                	jmp    f010fcd7 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010fcd1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fcd5:	74 31                	je     f010fd08 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010fcd7:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f010fcdc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fcdf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fce3:	74 08                	je     f010fced <tst_sc_MLFQ+0x92>
f010fce5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fce8:	8b 40 08             	mov    0x8(%eax),%eax
f010fceb:	eb 05                	jmp    f010fcf2 <tst_sc_MLFQ+0x97>
f010fced:	b8 00 00 00 00       	mov    $0x0,%eax
f010fcf2:	a3 48 b3 6b f0       	mov    %eax,0xf06bb348
f010fcf7:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f010fcfc:	85 c0                	test   %eax,%eax
f010fcfe:	75 a4                	jne    f010fca4 <tst_sc_MLFQ+0x49>
f010fd00:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fd04:	75 9e                	jne    f010fca4 <tst_sc_MLFQ+0x49>
f010fd06:	eb 01                	jmp    f010fd09 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010fd08:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010fd09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fd0c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010fd0f:	75 12                	jne    f010fd23 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010fd11:	83 ec 0c             	sub    $0xc,%esp
f010fd14:	68 38 78 12 f0       	push   $0xf0127838
f010fd19:	e8 6d 12 ff ff       	call   f0100f8b <cprintf>
f010fd1e:	83 c4 10             	add    $0x10,%esp
f010fd21:	eb 17                	jmp    f010fd3a <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010fd23:	83 ec 04             	sub    $0x4,%esp
f010fd26:	68 71 78 12 f0       	push   $0xf0127871
f010fd2b:	68 9b 00 00 00       	push   $0x9b
f010fd30:	68 87 78 12 f0       	push   $0xf0127887
f010fd35:	e8 ff 05 ff ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010fd3a:	83 ec 0c             	sub    $0xc,%esp
f010fd3d:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f010fd42:	e8 58 f8 ff ff       	call   f010f59f <release_spinlock>
f010fd47:	83 c4 10             	add    $0x10,%esp
	return 0;
f010fd4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd4f:	c9                   	leave  
f010fd50:	c3                   	ret    

f010fd51 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010fd51:	55                   	push   %ebp
f010fd52:	89 e5                	mov    %esp,%ebp
f010fd54:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010fd57:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010fd5b:	74 17                	je     f010fd74 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010fd5d:	83 ec 0c             	sub    $0xc,%esp
f010fd60:	68 a0 78 12 f0       	push   $0xf01278a0
f010fd65:	e8 21 12 ff ff       	call   f0100f8b <cprintf>
f010fd6a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fd6d:	b8 00 00 00 00       	mov    $0x0,%eax
f010fd72:	eb 45                	jmp    f010fdb9 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010fd74:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fd77:	83 c0 04             	add    $0x4,%eax
f010fd7a:	8b 00                	mov    (%eax),%eax
f010fd7c:	83 ec 04             	sub    $0x4,%esp
f010fd7f:	6a 0a                	push   $0xa
f010fd81:	6a 00                	push   $0x0
f010fd83:	50                   	push   %eax
f010fd84:	e8 b0 fa 00 00       	call   f011f839 <strtol>
f010fd89:	83 c4 10             	add    $0x10,%esp
f010fd8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010fd8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fd92:	83 f8 01             	cmp    $0x1,%eax
f010fd95:	74 10                	je     f010fda7 <tst_bsd_nice+0x56>
f010fd97:	83 f8 02             	cmp    $0x2,%eax
f010fd9a:	74 12                	je     f010fdae <tst_bsd_nice+0x5d>
f010fd9c:	85 c0                	test   %eax,%eax
f010fd9e:	75 14                	jne    f010fdb4 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010fda0:	e8 cc d2 00 00       	call   f011d071 <test_bsd_nice_0>
		break;
f010fda5:	eb 0d                	jmp    f010fdb4 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010fda7:	e8 4f d5 00 00       	call   f011d2fb <test_bsd_nice_1>
		break;
f010fdac:	eb 06                	jmp    f010fdb4 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010fdae:	e8 5c d7 00 00       	call   f011d50f <test_bsd_nice_2>
		break;
f010fdb3:	90                   	nop
	}
	return 0;
f010fdb4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fdb9:	c9                   	leave  
f010fdba:	c3                   	ret    

f010fdbb <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010fdbb:	55                   	push   %ebp
f010fdbc:	89 e5                	mov    %esp,%ebp
f010fdbe:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010fdc1:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010fdc5:	74 17                	je     f010fdde <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010fdc7:	83 ec 0c             	sub    $0xc,%esp
f010fdca:	68 e0 78 12 f0       	push   $0xf01278e0
f010fdcf:	e8 b7 11 ff ff       	call   f0100f8b <cprintf>
f010fdd4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fdd7:	b8 00 00 00 00       	mov    $0x0,%eax
f010fddc:	eb 0a                	jmp    f010fde8 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010fdde:	e8 3f 15 00 00       	call   f0111322 <test_str2lower_function>
	return 0;
f010fde3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fde8:	c9                   	leave  
f010fde9:	c3                   	ret    

f010fdea <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010fdea:	55                   	push   %ebp
f010fdeb:	89 e5                	mov    %esp,%ebp
f010fded:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010fdf0:	e8 63 11 00 00       	call   f0110f58 <TestAutoCompleteCommand>
f010fdf5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010fdf8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fdfd:	c9                   	leave  
f010fdfe:	c3                   	ret    

f010fdff <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010fdff:	55                   	push   %ebp
f010fe00:	89 e5                	mov    %esp,%ebp
f010fe02:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010fe05:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010fe09:	74 1a                	je     f010fe25 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010fe0b:	83 ec 0c             	sub    $0xc,%esp
f010fe0e:	68 14 79 12 f0       	push   $0xf0127914
f010fe13:	e8 73 11 ff ff       	call   f0100f8b <cprintf>
f010fe18:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fe1b:	b8 00 00 00 00       	mov    $0x0,%eax
f010fe20:	e9 2f 01 00 00       	jmp    f010ff54 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010fe25:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe28:	83 c0 04             	add    $0x4,%eax
f010fe2b:	8b 00                	mov    (%eax),%eax
f010fe2d:	83 ec 08             	sub    $0x8,%esp
f010fe30:	68 51 79 12 f0       	push   $0xf0127951
f010fe35:	50                   	push   %eax
f010fe36:	e8 aa f7 00 00       	call   f011f5e5 <strcmp>
f010fe3b:	83 c4 10             	add    $0x10,%esp
f010fe3e:	85 c0                	test   %eax,%eax
f010fe40:	75 0a                	jne    f010fe4c <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010fe42:	e8 40 08 00 00       	call   f0110687 <test_initialize_dynamic_allocator>
f010fe47:	e9 03 01 00 00       	jmp    f010ff4f <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010fe4c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe4f:	83 c0 04             	add    $0x4,%eax
f010fe52:	8b 00                	mov    (%eax),%eax
f010fe54:	83 ec 08             	sub    $0x8,%esp
f010fe57:	68 56 79 12 f0       	push   $0xf0127956
f010fe5c:	50                   	push   %eax
f010fe5d:	e8 83 f7 00 00       	call   f011f5e5 <strcmp>
f010fe62:	83 c4 10             	add    $0x10,%esp
f010fe65:	85 c0                	test   %eax,%eax
f010fe67:	75 0a                	jne    f010fe73 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010fe69:	e8 4d 08 00 00       	call   f01106bb <test_alloc_block_FF>
f010fe6e:	e9 dc 00 00 00       	jmp    f010ff4f <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010fe73:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe76:	83 c0 04             	add    $0x4,%eax
f010fe79:	8b 00                	mov    (%eax),%eax
f010fe7b:	83 ec 08             	sub    $0x8,%esp
f010fe7e:	68 5e 79 12 f0       	push   $0xf012795e
f010fe83:	50                   	push   %eax
f010fe84:	e8 5c f7 00 00       	call   f011f5e5 <strcmp>
f010fe89:	83 c4 10             	add    $0x10,%esp
f010fe8c:	85 c0                	test   %eax,%eax
f010fe8e:	75 0a                	jne    f010fe9a <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010fe90:	e8 43 08 00 00       	call   f01106d8 <test_alloc_block_BF>
f010fe95:	e9 b5 00 00 00       	jmp    f010ff4f <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010fe9a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe9d:	83 c0 04             	add    $0x4,%eax
f010fea0:	8b 00                	mov    (%eax),%eax
f010fea2:	83 ec 08             	sub    $0x8,%esp
f010fea5:	68 66 79 12 f0       	push   $0xf0127966
f010feaa:	50                   	push   %eax
f010feab:	e8 35 f7 00 00       	call   f011f5e5 <strcmp>
f010feb0:	83 c4 10             	add    $0x10,%esp
f010feb3:	85 c0                	test   %eax,%eax
f010feb5:	75 0a                	jne    f010fec1 <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010feb7:	e8 3c 08 00 00       	call   f01106f8 <test_alloc_block_NF>
f010febc:	e9 8e 00 00 00       	jmp    f010ff4f <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010fec1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fec4:	83 c0 04             	add    $0x4,%eax
f010fec7:	8b 00                	mov    (%eax),%eax
f010fec9:	83 ec 08             	sub    $0x8,%esp
f010fecc:	68 6e 79 12 f0       	push   $0xf012796e
f010fed1:	50                   	push   %eax
f010fed2:	e8 0e f7 00 00       	call   f011f5e5 <strcmp>
f010fed7:	83 c4 10             	add    $0x10,%esp
f010feda:	85 c0                	test   %eax,%eax
f010fedc:	75 07                	jne    f010fee5 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f010fede:	e8 1b 08 00 00       	call   f01106fe <test_free_block_FF>
f010fee3:	eb 6a                	jmp    f010ff4f <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f010fee5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fee8:	83 c0 04             	add    $0x4,%eax
f010feeb:	8b 00                	mov    (%eax),%eax
f010feed:	83 ec 08             	sub    $0x8,%esp
f010fef0:	68 75 79 12 f0       	push   $0xf0127975
f010fef5:	50                   	push   %eax
f010fef6:	e8 ea f6 00 00       	call   f011f5e5 <strcmp>
f010fefb:	83 c4 10             	add    $0x10,%esp
f010fefe:	85 c0                	test   %eax,%eax
f010ff00:	75 07                	jne    f010ff09 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f010ff02:	e8 14 08 00 00       	call   f011071b <test_free_block_BF>
f010ff07:	eb 46                	jmp    f010ff4f <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f010ff09:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff0c:	83 c0 04             	add    $0x4,%eax
f010ff0f:	8b 00                	mov    (%eax),%eax
f010ff11:	83 ec 08             	sub    $0x8,%esp
f010ff14:	68 7c 79 12 f0       	push   $0xf012797c
f010ff19:	50                   	push   %eax
f010ff1a:	e8 c6 f6 00 00       	call   f011f5e5 <strcmp>
f010ff1f:	83 c4 10             	add    $0x10,%esp
f010ff22:	85 c0                	test   %eax,%eax
f010ff24:	75 07                	jne    f010ff2d <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f010ff26:	e8 0d 08 00 00       	call   f0110738 <test_free_block_NF>
f010ff2b:	eb 22                	jmp    f010ff4f <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f010ff2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff30:	83 c0 04             	add    $0x4,%eax
f010ff33:	8b 00                	mov    (%eax),%eax
f010ff35:	83 ec 08             	sub    $0x8,%esp
f010ff38:	68 83 79 12 f0       	push   $0xf0127983
f010ff3d:	50                   	push   %eax
f010ff3e:	e8 a2 f6 00 00       	call   f011f5e5 <strcmp>
f010ff43:	83 c4 10             	add    $0x10,%esp
f010ff46:	85 c0                	test   %eax,%eax
f010ff48:	75 05                	jne    f010ff4f <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f010ff4a:	e8 06 08 00 00       	call   f0110755 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f010ff4f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ff54:	c9                   	leave  
f010ff55:	c3                   	ret    

f010ff56 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f010ff56:	55                   	push   %ebp
f010ff57:	89 e5                	mov    %esp,%ebp
f010ff59:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010ff5c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ff60:	74 1a                	je     f010ff7c <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f010ff62:	83 ec 0c             	sub    $0xc,%esp
f010ff65:	68 90 79 12 f0       	push   $0xf0127990
f010ff6a:	e8 1c 10 ff ff       	call   f0100f8b <cprintf>
f010ff6f:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ff72:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff77:	e9 e1 00 00 00       	jmp    f011005d <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f010ff7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff7f:	83 c0 04             	add    $0x4,%eax
f010ff82:	8b 00                	mov    (%eax),%eax
f010ff84:	83 ec 08             	sub    $0x8,%esp
f010ff87:	68 c9 79 12 f0       	push   $0xf01279c9
f010ff8c:	50                   	push   %eax
f010ff8d:	e8 53 f6 00 00       	call   f011f5e5 <strcmp>
f010ff92:	83 c4 10             	add    $0x10,%esp
f010ff95:	85 c0                	test   %eax,%eax
f010ff97:	75 0a                	jne    f010ffa3 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f010ff99:	e8 97 1c 00 00       	call   f0111c35 <test_cut_paste_pages>
f010ff9e:	e9 b5 00 00 00       	jmp    f0110058 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f010ffa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ffa6:	83 c0 04             	add    $0x4,%eax
f010ffa9:	8b 00                	mov    (%eax),%eax
f010ffab:	83 ec 08             	sub    $0x8,%esp
f010ffae:	68 d2 79 12 f0       	push   $0xf01279d2
f010ffb3:	50                   	push   %eax
f010ffb4:	e8 2c f6 00 00       	call   f011f5e5 <strcmp>
f010ffb9:	83 c4 10             	add    $0x10,%esp
f010ffbc:	85 c0                	test   %eax,%eax
f010ffbe:	75 0a                	jne    f010ffca <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f010ffc0:	e8 bb 26 00 00       	call   f0112680 <test_copy_paste_chunk>
f010ffc5:	e9 8e 00 00 00       	jmp    f0110058 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f010ffca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ffcd:	83 c0 04             	add    $0x4,%eax
f010ffd0:	8b 00                	mov    (%eax),%eax
f010ffd2:	83 ec 08             	sub    $0x8,%esp
f010ffd5:	68 dc 79 12 f0       	push   $0xf01279dc
f010ffda:	50                   	push   %eax
f010ffdb:	e8 05 f6 00 00       	call   f011f5e5 <strcmp>
f010ffe0:	83 c4 10             	add    $0x10,%esp
f010ffe3:	85 c0                	test   %eax,%eax
f010ffe5:	75 07                	jne    f010ffee <tst_chunks+0x98>
	{
		test_share_chunk();
f010ffe7:	e8 92 37 00 00       	call   f011377e <test_share_chunk>
f010ffec:	eb 6a                	jmp    f0110058 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f010ffee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fff1:	83 c0 04             	add    $0x4,%eax
f010fff4:	8b 00                	mov    (%eax),%eax
f010fff6:	83 ec 08             	sub    $0x8,%esp
f010fff9:	68 e2 79 12 f0       	push   $0xf01279e2
f010fffe:	50                   	push   %eax
f010ffff:	e8 e1 f5 00 00       	call   f011f5e5 <strcmp>
f0110004:	83 c4 10             	add    $0x10,%esp
f0110007:	85 c0                	test   %eax,%eax
f0110009:	75 07                	jne    f0110012 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f011000b:	e8 96 41 00 00       	call   f01141a6 <test_allocate_chunk>
f0110010:	eb 46                	jmp    f0110058 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110012:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110015:	83 c0 04             	add    $0x4,%eax
f0110018:	8b 00                	mov    (%eax),%eax
f011001a:	83 ec 08             	sub    $0x8,%esp
f011001d:	68 eb 79 12 f0       	push   $0xf01279eb
f0110022:	50                   	push   %eax
f0110023:	e8 bd f5 00 00       	call   f011f5e5 <strcmp>
f0110028:	83 c4 10             	add    $0x10,%esp
f011002b:	85 c0                	test   %eax,%eax
f011002d:	75 07                	jne    f0110036 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f011002f:	e8 79 4a 00 00       	call   f0114aad <test_calculate_required_frames>
f0110034:	eb 22                	jmp    f0110058 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f0110036:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110039:	83 c0 04             	add    $0x4,%eax
f011003c:	8b 00                	mov    (%eax),%eax
f011003e:	83 ec 08             	sub    $0x8,%esp
f0110041:	68 fa 79 12 f0       	push   $0xf01279fa
f0110046:	50                   	push   %eax
f0110047:	e8 99 f5 00 00       	call   f011f5e5 <strcmp>
f011004c:	83 c4 10             	add    $0x10,%esp
f011004f:	85 c0                	test   %eax,%eax
f0110051:	75 05                	jne    f0110058 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110053:	e8 c9 52 00 00       	call   f0115321 <test_calculate_allocated_space>
	}
	return 0;
f0110058:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011005d:	c9                   	leave  
f011005e:	c3                   	ret    

f011005f <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f011005f:	55                   	push   %ebp
f0110060:	89 e5                	mov    %esp,%ebp
f0110062:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110065:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110069:	74 1a                	je     f0110085 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f011006b:	83 ec 0c             	sub    $0xc,%esp
f011006e:	68 0c 7a 12 f0       	push   $0xf0127a0c
f0110073:	e8 13 0f ff ff       	call   f0100f8b <cprintf>
f0110078:	83 c4 10             	add    $0x10,%esp
		return 0;
f011007b:	b8 00 00 00 00       	mov    $0x0,%eax
f0110080:	e9 ba 00 00 00       	jmp    f011013f <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f0110085:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110088:	83 c0 04             	add    $0x4,%eax
f011008b:	8b 00                	mov    (%eax),%eax
f011008d:	83 ec 08             	sub    $0x8,%esp
f0110090:	68 42 7a 12 f0       	push   $0xf0127a42
f0110095:	50                   	push   %eax
f0110096:	e8 4a f5 00 00       	call   f011f5e5 <strcmp>
f011009b:	83 c4 10             	add    $0x10,%esp
f011009e:	85 c0                	test   %eax,%eax
f01100a0:	75 0a                	jne    f01100ac <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01100a2:	e8 01 16 00 00       	call   f01116a8 <test_pt_set_page_permissions>
f01100a7:	e9 8e 00 00 00       	jmp    f011013a <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f01100ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f01100af:	83 c0 04             	add    $0x4,%eax
f01100b2:	8b 00                	mov    (%eax),%eax
f01100b4:	83 ec 08             	sub    $0x8,%esp
f01100b7:	68 4a 7a 12 f0       	push   $0xf0127a4a
f01100bc:	50                   	push   %eax
f01100bd:	e8 23 f5 00 00       	call   f011f5e5 <strcmp>
f01100c2:	83 c4 10             	add    $0x10,%esp
f01100c5:	85 c0                	test   %eax,%eax
f01100c7:	75 07                	jne    f01100d0 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f01100c9:	e8 49 18 00 00       	call   f0111917 <test_pt_set_page_permissions_invalid_va>
f01100ce:	eb 6a                	jmp    f011013a <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f01100d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01100d3:	83 c0 04             	add    $0x4,%eax
f01100d6:	8b 00                	mov    (%eax),%eax
f01100d8:	83 ec 08             	sub    $0x8,%esp
f01100db:	68 52 7a 12 f0       	push   $0xf0127a52
f01100e0:	50                   	push   %eax
f01100e1:	e8 ff f4 00 00       	call   f011f5e5 <strcmp>
f01100e6:	83 c4 10             	add    $0x10,%esp
f01100e9:	85 c0                	test   %eax,%eax
f01100eb:	75 07                	jne    f01100f4 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f01100ed:	e8 6e 18 00 00       	call   f0111960 <test_pt_get_page_permissions>
f01100f2:	eb 46                	jmp    f011013a <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f01100f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01100f7:	83 c0 04             	add    $0x4,%eax
f01100fa:	8b 00                	mov    (%eax),%eax
f01100fc:	83 ec 08             	sub    $0x8,%esp
f01100ff:	68 5a 7a 12 f0       	push   $0xf0127a5a
f0110104:	50                   	push   %eax
f0110105:	e8 db f4 00 00       	call   f011f5e5 <strcmp>
f011010a:	83 c4 10             	add    $0x10,%esp
f011010d:	85 c0                	test   %eax,%eax
f011010f:	75 07                	jne    f0110118 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f0110111:	e8 8e 19 00 00       	call   f0111aa4 <test_pt_clear_page_table_entry>
f0110116:	eb 22                	jmp    f011013a <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110118:	8b 45 0c             	mov    0xc(%ebp),%eax
f011011b:	83 c0 04             	add    $0x4,%eax
f011011e:	8b 00                	mov    (%eax),%eax
f0110120:	83 ec 08             	sub    $0x8,%esp
f0110123:	68 61 7a 12 f0       	push   $0xf0127a61
f0110128:	50                   	push   %eax
f0110129:	e8 b7 f4 00 00       	call   f011f5e5 <strcmp>
f011012e:	83 c4 10             	add    $0x10,%esp
f0110131:	85 c0                	test   %eax,%eax
f0110133:	75 05                	jne    f011013a <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f0110135:	e8 c3 1a 00 00       	call   f0111bfd <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f011013a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011013f:	c9                   	leave  
f0110140:	c3                   	ret    

f0110141 <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f0110141:	55                   	push   %ebp
f0110142:	89 e5                	mov    %esp,%ebp
f0110144:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0110147:	8b 45 0c             	mov    0xc(%ebp),%eax
f011014a:	83 c0 08             	add    $0x8,%eax
f011014d:	8b 00                	mov    (%eax),%eax
f011014f:	83 ec 08             	sub    $0x8,%esp
f0110152:	68 68 7a 12 f0       	push   $0xf0127a68
f0110157:	50                   	push   %eax
f0110158:	e8 88 f4 00 00       	call   f011f5e5 <strcmp>
f011015d:	83 c4 10             	add    $0x10,%esp
f0110160:	85 c0                	test   %eax,%eax
f0110162:	75 20                	jne    f0110184 <tst_kheap+0x43>
f0110164:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110168:	74 1a                	je     f0110184 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f011016a:	83 ec 0c             	sub    $0xc,%esp
f011016d:	68 70 7a 12 f0       	push   $0xf0127a70
f0110172:	e8 14 0e ff ff       	call   f0100f8b <cprintf>
f0110177:	83 c4 10             	add    $0x10,%esp
		return 0;
f011017a:	b8 00 00 00 00       	mov    $0x0,%eax
f011017f:	e9 42 04 00 00       	jmp    f01105c6 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f0110184:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110187:	83 c0 08             	add    $0x8,%eax
f011018a:	8b 00                	mov    (%eax),%eax
f011018c:	83 ec 08             	sub    $0x8,%esp
f011018f:	68 68 7a 12 f0       	push   $0xf0127a68
f0110194:	50                   	push   %eax
f0110195:	e8 4b f4 00 00       	call   f011f5e5 <strcmp>
f011019a:	83 c4 10             	add    $0x10,%esp
f011019d:	85 c0                	test   %eax,%eax
f011019f:	74 43                	je     f01101e4 <tst_kheap+0xa3>
f01101a1:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01101a5:	74 3d                	je     f01101e4 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f01101a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101aa:	83 c0 08             	add    $0x8,%eax
f01101ad:	8b 00                	mov    (%eax),%eax
f01101af:	83 ec 08             	sub    $0x8,%esp
f01101b2:	68 c0 7a 12 f0       	push   $0xf0127ac0
f01101b7:	50                   	push   %eax
f01101b8:	e8 28 f4 00 00       	call   f011f5e5 <strcmp>
f01101bd:	83 c4 10             	add    $0x10,%esp
f01101c0:	85 c0                	test   %eax,%eax
f01101c2:	74 20                	je     f01101e4 <tst_kheap+0xa3>
f01101c4:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f01101c8:	74 1a                	je     f01101e4 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f01101ca:	83 ec 0c             	sub    $0xc,%esp
f01101cd:	68 cc 7a 12 f0       	push   $0xf0127acc
f01101d2:	e8 b4 0d ff ff       	call   f0100f8b <cprintf>
f01101d7:	83 c4 10             	add    $0x10,%esp
			return 0;
f01101da:	b8 00 00 00 00       	mov    $0x0,%eax
f01101df:	e9 e2 03 00 00       	jmp    f01105c6 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f01101e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101e7:	83 c0 04             	add    $0x4,%eax
f01101ea:	8b 00                	mov    (%eax),%eax
f01101ec:	83 ec 08             	sub    $0x8,%esp
f01101ef:	68 11 7b 12 f0       	push   $0xf0127b11
f01101f4:	50                   	push   %eax
f01101f5:	e8 eb f3 00 00       	call   f011f5e5 <strcmp>
f01101fa:	83 c4 10             	add    $0x10,%esp
f01101fd:	85 c0                	test   %eax,%eax
f01101ff:	74 1d                	je     f011021e <tst_kheap+0xdd>
f0110201:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110204:	83 c0 04             	add    $0x4,%eax
f0110207:	8b 00                	mov    (%eax),%eax
f0110209:	83 ec 08             	sub    $0x8,%esp
f011020c:	68 14 7b 12 f0       	push   $0xf0127b14
f0110211:	50                   	push   %eax
f0110212:	e8 ce f3 00 00       	call   f011f5e5 <strcmp>
f0110217:	83 c4 10             	add    $0x10,%esp
f011021a:	85 c0                	test   %eax,%eax
f011021c:	75 1a                	jne    f0110238 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f011021e:	e8 6d f8 ff ff       	call   f010fa90 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110223:	83 ec 0c             	sub    $0xc,%esp
f0110226:	68 18 7b 12 f0       	push   $0xf0127b18
f011022b:	e8 5b 0d ff ff       	call   f0100f8b <cprintf>
f0110230:	83 c4 10             	add    $0x10,%esp
f0110233:	e9 a0 00 00 00       	jmp    f01102d8 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110238:	8b 45 0c             	mov    0xc(%ebp),%eax
f011023b:	83 c0 04             	add    $0x4,%eax
f011023e:	8b 00                	mov    (%eax),%eax
f0110240:	83 ec 08             	sub    $0x8,%esp
f0110243:	68 45 7b 12 f0       	push   $0xf0127b45
f0110248:	50                   	push   %eax
f0110249:	e8 97 f3 00 00       	call   f011f5e5 <strcmp>
f011024e:	83 c4 10             	add    $0x10,%esp
f0110251:	85 c0                	test   %eax,%eax
f0110253:	74 1d                	je     f0110272 <tst_kheap+0x131>
f0110255:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110258:	83 c0 04             	add    $0x4,%eax
f011025b:	8b 00                	mov    (%eax),%eax
f011025d:	83 ec 08             	sub    $0x8,%esp
f0110260:	68 48 7b 12 f0       	push   $0xf0127b48
f0110265:	50                   	push   %eax
f0110266:	e8 7a f3 00 00       	call   f011f5e5 <strcmp>
f011026b:	83 c4 10             	add    $0x10,%esp
f011026e:	85 c0                	test   %eax,%eax
f0110270:	75 17                	jne    f0110289 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f0110272:	e8 29 f8 ff ff       	call   f010faa0 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110277:	83 ec 0c             	sub    $0xc,%esp
f011027a:	68 4c 7b 12 f0       	push   $0xf0127b4c
f011027f:	e8 07 0d ff ff       	call   f0100f8b <cprintf>
f0110284:	83 c4 10             	add    $0x10,%esp
f0110287:	eb 4f                	jmp    f01102d8 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110289:	8b 45 0c             	mov    0xc(%ebp),%eax
f011028c:	83 c0 04             	add    $0x4,%eax
f011028f:	8b 00                	mov    (%eax),%eax
f0110291:	83 ec 08             	sub    $0x8,%esp
f0110294:	68 78 7b 12 f0       	push   $0xf0127b78
f0110299:	50                   	push   %eax
f011029a:	e8 46 f3 00 00       	call   f011f5e5 <strcmp>
f011029f:	83 c4 10             	add    $0x10,%esp
f01102a2:	85 c0                	test   %eax,%eax
f01102a4:	74 1d                	je     f01102c3 <tst_kheap+0x182>
f01102a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102a9:	83 c0 04             	add    $0x4,%eax
f01102ac:	8b 00                	mov    (%eax),%eax
f01102ae:	83 ec 08             	sub    $0x8,%esp
f01102b1:	68 7b 7b 12 f0       	push   $0xf0127b7b
f01102b6:	50                   	push   %eax
f01102b7:	e8 29 f3 00 00       	call   f011f5e5 <strcmp>
f01102bc:	83 c4 10             	add    $0x10,%esp
f01102bf:	85 c0                	test   %eax,%eax
f01102c1:	75 15                	jne    f01102d8 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f01102c3:	e8 e8 f7 ff ff       	call   f010fab0 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f01102c8:	83 ec 0c             	sub    $0xc,%esp
f01102cb:	68 80 7b 12 f0       	push   $0xf0127b80
f01102d0:	e8 b6 0c ff ff       	call   f0100f8b <cprintf>
f01102d5:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f01102d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102db:	83 c0 08             	add    $0x8,%eax
f01102de:	8b 00                	mov    (%eax),%eax
f01102e0:	83 ec 08             	sub    $0x8,%esp
f01102e3:	68 68 7a 12 f0       	push   $0xf0127a68
f01102e8:	50                   	push   %eax
f01102e9:	e8 f7 f2 00 00       	call   f011f5e5 <strcmp>
f01102ee:	83 c4 10             	add    $0x10,%esp
f01102f1:	85 c0                	test   %eax,%eax
f01102f3:	0f 85 13 01 00 00    	jne    f011040c <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f01102f9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102fc:	83 c0 0c             	add    $0xc,%eax
f01102ff:	8b 00                	mov    (%eax),%eax
f0110301:	83 ec 04             	sub    $0x4,%esp
f0110304:	6a 0a                	push   $0xa
f0110306:	6a 00                	push   $0x0
f0110308:	50                   	push   %eax
f0110309:	e8 2b f5 00 00       	call   f011f839 <strtol>
f011030e:	83 c4 10             	add    $0x10,%esp
f0110311:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110314:	e8 a7 f7 ff ff       	call   f010fac0 <isKHeapPlacementStrategyFIRSTFIT>
f0110319:	84 c0                	test   %al,%al
f011031b:	74 54                	je     f0110371 <tst_kheap+0x230>
		{
			if (testNum == 0)
f011031d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110321:	75 1a                	jne    f011033d <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110323:	83 ec 0c             	sub    $0xc,%esp
f0110326:	68 ac 7b 12 f0       	push   $0xf0127bac
f011032b:	e8 5b 0c ff ff       	call   f0100f8b <cprintf>
f0110330:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110333:	b8 00 00 00 00       	mov    $0x0,%eax
f0110338:	e9 89 02 00 00       	jmp    f01105c6 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f011033d:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110341:	75 0a                	jne    f011034d <tst_kheap+0x20c>
				test_kmalloc();
f0110343:	e8 ec 61 00 00       	call   f0116534 <test_kmalloc>
f0110348:	e9 b5 00 00 00       	jmp    f0110402 <tst_kheap+0x2c1>
			else if (testNum == 2)
f011034d:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110351:	75 0a                	jne    f011035d <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110353:	e8 7b 6d 00 00       	call   f01170d3 <test_kmalloc_firstfit1>
f0110358:	e9 a5 00 00 00       	jmp    f0110402 <tst_kheap+0x2c1>
			else if (testNum == 3)
f011035d:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110361:	0f 85 9b 00 00 00    	jne    f0110402 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110367:	e8 4b 78 00 00       	call   f0117bb7 <test_kmalloc_firstfit2>
f011036c:	e9 91 00 00 00       	jmp    f0110402 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f0110371:	e8 5f f7 ff ff       	call   f010fad5 <isKHeapPlacementStrategyBESTFIT>
f0110376:	84 c0                	test   %al,%al
f0110378:	74 47                	je     f01103c1 <tst_kheap+0x280>
		{
			if (testNum == 0)
f011037a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011037e:	75 1a                	jne    f011039a <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f0110380:	83 ec 0c             	sub    $0xc,%esp
f0110383:	68 fc 7b 12 f0       	push   $0xf0127bfc
f0110388:	e8 fe 0b ff ff       	call   f0100f8b <cprintf>
f011038d:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110390:	b8 00 00 00 00       	mov    $0x0,%eax
f0110395:	e9 2c 02 00 00       	jmp    f01105c6 <tst_kheap+0x485>
			}
			if (testNum == 1)
f011039a:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f011039e:	75 07                	jne    f01103a7 <tst_kheap+0x266>
				test_kmalloc();
f01103a0:	e8 8f 61 00 00       	call   f0116534 <test_kmalloc>
f01103a5:	eb 5b                	jmp    f0110402 <tst_kheap+0x2c1>
			else if (testNum == 2)
f01103a7:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01103ab:	75 07                	jne    f01103b4 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f01103ad:	e8 3e c8 00 00       	call   f011cbf0 <test_kmalloc_bestfit1>
f01103b2:	eb 4e                	jmp    f0110402 <tst_kheap+0x2c1>
			else if (testNum == 3)
f01103b4:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f01103b8:	75 48                	jne    f0110402 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f01103ba:	e8 4e c8 00 00       	call   f011cc0d <test_kmalloc_bestfit2>
f01103bf:	eb 41                	jmp    f0110402 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f01103c1:	e8 24 f7 ff ff       	call   f010faea <isKHeapPlacementStrategyNEXTFIT>
f01103c6:	84 c0                	test   %al,%al
f01103c8:	74 38                	je     f0110402 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f01103ca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01103ce:	75 1a                	jne    f01103ea <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f01103d0:	83 ec 0c             	sub    $0xc,%esp
f01103d3:	68 4c 7c 12 f0       	push   $0xf0127c4c
f01103d8:	e8 ae 0b ff ff       	call   f0100f8b <cprintf>
f01103dd:	83 c4 10             	add    $0x10,%esp
				return 0;
f01103e0:	b8 00 00 00 00       	mov    $0x0,%eax
f01103e5:	e9 dc 01 00 00       	jmp    f01105c6 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f01103ea:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01103ee:	75 07                	jne    f01103f7 <tst_kheap+0x2b6>
				test_kmalloc();
f01103f0:	e8 3f 61 00 00       	call   f0116534 <test_kmalloc>
f01103f5:	eb 0b                	jmp    f0110402 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f01103f7:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01103fb:	75 05                	jne    f0110402 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f01103fd:	e8 d1 c7 00 00       	call   f011cbd3 <test_kmalloc_nextfit>
		}
		return 0;
f0110402:	b8 00 00 00 00       	mov    $0x0,%eax
f0110407:	e9 ba 01 00 00       	jmp    f01105c6 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f011040c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011040f:	83 c0 08             	add    $0x8,%eax
f0110412:	8b 00                	mov    (%eax),%eax
f0110414:	83 ec 08             	sub    $0x8,%esp
f0110417:	68 9a 7c 12 f0       	push   $0xf0127c9a
f011041c:	50                   	push   %eax
f011041d:	e8 c3 f1 00 00       	call   f011f5e5 <strcmp>
f0110422:	83 c4 10             	add    $0x10,%esp
f0110425:	85 c0                	test   %eax,%eax
f0110427:	75 2f                	jne    f0110458 <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110429:	e8 92 f6 ff ff       	call   f010fac0 <isKHeapPlacementStrategyFIRSTFIT>
f011042e:	84 c0                	test   %al,%al
f0110430:	74 0f                	je     f0110441 <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0110432:	e8 87 82 00 00       	call   f01186be <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110437:	b8 00 00 00 00       	mov    $0x0,%eax
f011043c:	e9 85 01 00 00       	jmp    f01105c6 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f0110441:	83 ec 04             	sub    $0x4,%esp
f0110444:	68 a0 7c 12 f0       	push   $0xf0127ca0
f0110449:	68 ac 01 00 00       	push   $0x1ac
f011044e:	68 87 78 12 f0       	push   $0xf0127887
f0110453:	e8 e1 fe fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110458:	8b 45 0c             	mov    0xc(%ebp),%eax
f011045b:	83 c0 08             	add    $0x8,%eax
f011045e:	8b 00                	mov    (%eax),%eax
f0110460:	83 ec 08             	sub    $0x8,%esp
f0110463:	68 e1 7c 12 f0       	push   $0xf0127ce1
f0110468:	50                   	push   %eax
f0110469:	e8 77 f1 00 00       	call   f011f5e5 <strcmp>
f011046e:	83 c4 10             	add    $0x10,%esp
f0110471:	85 c0                	test   %eax,%eax
f0110473:	75 28                	jne    f011049d <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0110475:	e8 5b f6 ff ff       	call   f010fad5 <isKHeapPlacementStrategyBESTFIT>
f011047a:	84 c0                	test   %al,%al
f011047c:	75 09                	jne    f0110487 <tst_kheap+0x346>
f011047e:	e8 3d f6 ff ff       	call   f010fac0 <isKHeapPlacementStrategyFIRSTFIT>
f0110483:	84 c0                	test   %al,%al
f0110485:	74 07                	je     f011048e <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0110487:	e8 01 8b 00 00       	call   f0118f8d <test_kfree_bestfirstfit>
f011048c:	eb 05                	jmp    f0110493 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f011048e:	e8 b4 c7 00 00       	call   f011cc47 <test_kfree>
		}
		return 0;
f0110493:	b8 00 00 00 00       	mov    $0x0,%eax
f0110498:	e9 29 01 00 00       	jmp    f01105c6 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f011049d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01104a0:	83 c0 08             	add    $0x8,%eax
f01104a3:	8b 00                	mov    (%eax),%eax
f01104a5:	83 ec 08             	sub    $0x8,%esp
f01104a8:	68 e7 7c 12 f0       	push   $0xf0127ce7
f01104ad:	50                   	push   %eax
f01104ae:	e8 32 f1 00 00       	call   f011f5e5 <strcmp>
f01104b3:	83 c4 10             	add    $0x10,%esp
f01104b6:	85 c0                	test   %eax,%eax
f01104b8:	75 0f                	jne    f01104c9 <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f01104ba:	e8 2a a1 00 00       	call   f011a5e9 <test_kheap_phys_addr>
		return 0;
f01104bf:	b8 00 00 00 00       	mov    $0x0,%eax
f01104c4:	e9 fd 00 00 00       	jmp    f01105c6 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f01104c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01104cc:	83 c0 08             	add    $0x8,%eax
f01104cf:	8b 00                	mov    (%eax),%eax
f01104d1:	83 ec 08             	sub    $0x8,%esp
f01104d4:	68 f1 7c 12 f0       	push   $0xf0127cf1
f01104d9:	50                   	push   %eax
f01104da:	e8 06 f1 00 00       	call   f011f5e5 <strcmp>
f01104df:	83 c4 10             	add    $0x10,%esp
f01104e2:	85 c0                	test   %eax,%eax
f01104e4:	75 0f                	jne    f01104f5 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f01104e6:	e8 e1 ae 00 00       	call   f011b3cc <test_kheap_virt_addr>
		return 0;
f01104eb:	b8 00 00 00 00       	mov    $0x0,%eax
f01104f0:	e9 d1 00 00 00       	jmp    f01105c6 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f01104f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01104f8:	83 c0 08             	add    $0x8,%eax
f01104fb:	8b 00                	mov    (%eax),%eax
f01104fd:	83 ec 08             	sub    $0x8,%esp
f0110500:	68 c0 7a 12 f0       	push   $0xf0127ac0
f0110505:	50                   	push   %eax
f0110506:	e8 da f0 00 00       	call   f011f5e5 <strcmp>
f011050b:	83 c4 10             	add    $0x10,%esp
f011050e:	85 c0                	test   %eax,%eax
f0110510:	0f 85 89 00 00 00    	jne    f011059f <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110516:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110519:	83 c0 0c             	add    $0xc,%eax
f011051c:	8b 00                	mov    (%eax),%eax
f011051e:	83 ec 04             	sub    $0x4,%esp
f0110521:	6a 0a                	push   $0xa
f0110523:	6a 00                	push   $0x0
f0110525:	50                   	push   %eax
f0110526:	e8 0e f3 00 00       	call   f011f839 <strtol>
f011052b:	83 c4 10             	add    $0x10,%esp
f011052e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110531:	e8 8a f5 ff ff       	call   f010fac0 <isKHeapPlacementStrategyFIRSTFIT>
f0110536:	84 c0                	test   %al,%al
f0110538:	74 42                	je     f011057c <tst_kheap+0x43b>
		{
			if (testNum == 0)
f011053a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011053e:	75 17                	jne    f0110557 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110540:	83 ec 0c             	sub    $0xc,%esp
f0110543:	68 ac 7b 12 f0       	push   $0xf0127bac
f0110548:	e8 3e 0a ff ff       	call   f0100f8b <cprintf>
f011054d:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110550:	b8 00 00 00 00       	mov    $0x0,%eax
f0110555:	eb 6f                	jmp    f01105c6 <tst_kheap+0x485>
			}
			if (testNum==1)
f0110557:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011055b:	75 07                	jne    f0110564 <tst_kheap+0x423>
				test_krealloc_FF1();
f011055d:	e8 63 c9 00 00       	call   f011cec5 <test_krealloc_FF1>
f0110562:	eb 18                	jmp    f011057c <tst_kheap+0x43b>
			else if (testNum==2)
f0110564:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0110568:	75 07                	jne    f0110571 <tst_kheap+0x430>
				test_krealloc_FF2();
f011056a:	e8 73 c9 00 00       	call   f011cee2 <test_krealloc_FF2>
f011056f:	eb 0b                	jmp    f011057c <tst_kheap+0x43b>
			else if (testNum==3)
f0110571:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0110575:	75 05                	jne    f011057c <tst_kheap+0x43b>
				test_krealloc_FF3();
f0110577:	e8 83 c9 00 00       	call   f011ceff <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f011057c:	e8 69 f5 ff ff       	call   f010faea <isKHeapPlacementStrategyNEXTFIT>
f0110581:	84 c0                	test   %al,%al
f0110583:	74 05                	je     f011058a <tst_kheap+0x449>
		{
			test_krealloc();
f0110585:	e8 01 c9 00 00       	call   f011ce8b <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f011058a:	e8 46 f5 ff ff       	call   f010fad5 <isKHeapPlacementStrategyBESTFIT>
f011058f:	84 c0                	test   %al,%al
f0110591:	74 05                	je     f0110598 <tst_kheap+0x457>
		{
			test_krealloc_BF();
f0110593:	e8 10 c9 00 00       	call   f011cea8 <test_krealloc_BF>
		}
		return 0;
f0110598:	b8 00 00 00 00       	mov    $0x0,%eax
f011059d:	eb 27                	jmp    f01105c6 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f011059f:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105a2:	83 c0 08             	add    $0x8,%eax
f01105a5:	8b 00                	mov    (%eax),%eax
f01105a7:	83 ec 08             	sub    $0x8,%esp
f01105aa:	68 fb 7c 12 f0       	push   $0xf0127cfb
f01105af:	50                   	push   %eax
f01105b0:	e8 30 f0 00 00       	call   f011f5e5 <strcmp>
f01105b5:	83 c4 10             	add    $0x10,%esp
f01105b8:	85 c0                	test   %eax,%eax
f01105ba:	75 05                	jne    f01105c1 <tst_kheap+0x480>
	{
		test_ksbrk();
f01105bc:	e8 30 bb 00 00       	call   f011c0f1 <test_ksbrk>
	}
	return 0;
f01105c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105c6:	c9                   	leave  
f01105c7:	c3                   	ret    

f01105c8 <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f01105c8:	55                   	push   %ebp
f01105c9:	89 e5                	mov    %esp,%ebp
f01105cb:	83 ec 28             	sub    $0x28,%esp
f01105ce:	8b 45 14             	mov    0x14(%ebp),%eax
f01105d1:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f01105d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01105d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01105da:	74 1d                	je     f01105f9 <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f01105dc:	83 ec 04             	sub    $0x4,%esp
f01105df:	ff 75 08             	pushl  0x8(%ebp)
f01105e2:	ff 75 0c             	pushl  0xc(%ebp)
f01105e5:	68 00 7d 12 f0       	push   $0xf0127d00
f01105ea:	e8 9c 09 ff ff       	call   f0100f8b <cprintf>
f01105ef:	83 c4 10             	add    $0x10,%esp
		return 0;
f01105f2:	b8 00 00 00 00       	mov    $0x0,%eax
f01105f7:	eb 55                	jmp    f011064e <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f01105f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01105fc:	8b 40 fc             	mov    -0x4(%eax),%eax
f01105ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f0110602:	8b 45 10             	mov    0x10(%ebp),%eax
f0110605:	8d 50 f8             	lea    -0x8(%eax),%edx
f0110608:	8b 45 08             	mov    0x8(%ebp),%eax
f011060b:	01 d0                	add    %edx,%eax
f011060d:	8b 00                	mov    (%eax),%eax
f011060f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f0110612:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0110616:	0b 45 10             	or     0x10(%ebp),%eax
f0110619:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f011061c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011061f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110622:	75 08                	jne    f011062c <check_block+0x64>
f0110624:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110627:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011062a:	74 1d                	je     f0110649 <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f011062c:	ff 75 f0             	pushl  -0x10(%ebp)
f011062f:	ff 75 f4             	pushl  -0xc(%ebp)
f0110632:	ff 75 ec             	pushl  -0x14(%ebp)
f0110635:	68 30 7d 12 f0       	push   $0xf0127d30
f011063a:	e8 4c 09 ff ff       	call   f0100f8b <cprintf>
f011063f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110642:	b8 00 00 00 00       	mov    $0x0,%eax
f0110647:	eb 05                	jmp    f011064e <check_block+0x86>
	}
	return 1;
f0110649:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011064e:	c9                   	leave  
f011064f:	c3                   	ret    

f0110650 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f0110650:	55                   	push   %ebp
f0110651:	89 e5                	mov    %esp,%ebp
f0110653:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f0110656:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f011065b:	3b 45 08             	cmp    0x8(%ebp),%eax
f011065e:	74 20                	je     f0110680 <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f0110660:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0110665:	83 ec 04             	sub    $0x4,%esp
f0110668:	50                   	push   %eax
f0110669:	ff 75 08             	pushl  0x8(%ebp)
f011066c:	68 6c 7d 12 f0       	push   $0xf0127d6c
f0110671:	e8 15 09 ff ff       	call   f0100f8b <cprintf>
f0110676:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110679:	b8 00 00 00 00       	mov    $0x0,%eax
f011067e:	eb 05                	jmp    f0110685 <check_list_size+0x35>
	}
	return 1;
f0110680:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110685:	c9                   	leave  
f0110686:	c3                   	ret    

f0110687 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0110687:	55                   	push   %ebp
f0110688:	89 e5                	mov    %esp,%ebp
f011068a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f011068d:	83 ec 04             	sub    $0x4,%esp
f0110690:	68 a0 7d 12 f0       	push   $0xf0127da0
f0110695:	6a 3f                	push   $0x3f
f0110697:	68 00 7e 12 f0       	push   $0xf0127e00
f011069c:	e8 98 fc fe ff       	call   f0100339 <_panic>

f01106a1 <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f01106a1:	55                   	push   %ebp
f01106a2:	89 e5                	mov    %esp,%ebp
f01106a4:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01106a7:	83 ec 04             	sub    $0x4,%esp
f01106aa:	68 24 7e 12 f0       	push   $0xf0127e24
f01106af:	6a 61                	push   $0x61
f01106b1:	68 00 7e 12 f0       	push   $0xf0127e00
f01106b6:	e8 7e fc fe ff       	call   f0100339 <_panic>

f01106bb <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f01106bb:	55                   	push   %ebp
f01106bc:	89 e5                	mov    %esp,%ebp
f01106be:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01106c1:	83 ec 04             	sub    $0x4,%esp
f01106c4:	68 74 7e 12 f0       	push   $0xf0127e74
f01106c9:	68 e7 00 00 00       	push   $0xe7
f01106ce:	68 00 7e 12 f0       	push   $0xf0127e00
f01106d3:	e8 61 fc fe ff       	call   f0100339 <_panic>

f01106d8 <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f01106d8:	55                   	push   %ebp
f01106d9:	89 e5                	mov    %esp,%ebp
f01106db:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01106e1:	83 ec 04             	sub    $0x4,%esp
f01106e4:	68 c8 7e 12 f0       	push   $0xf0127ec8
f01106e9:	68 88 01 00 00       	push   $0x188
f01106ee:	68 00 7e 12 f0       	push   $0xf0127e00
f01106f3:	e8 41 fc fe ff       	call   f0100339 <_panic>

f01106f8 <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f01106f8:	55                   	push   %ebp
f01106f9:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f01106fb:	90                   	nop
f01106fc:	5d                   	pop    %ebp
f01106fd:	c3                   	ret    

f01106fe <test_free_block_FF>:

void test_free_block_FF()
{
f01106fe:	55                   	push   %ebp
f01106ff:	89 e5                	mov    %esp,%ebp
f0110701:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110704:	83 ec 04             	sub    $0x4,%esp
f0110707:	68 1c 7f 12 f0       	push   $0xf0127f1c
f011070c:	68 4e 02 00 00       	push   $0x24e
f0110711:	68 00 7e 12 f0       	push   $0xf0127e00
f0110716:	e8 1e fc fe ff       	call   f0100339 <_panic>

f011071b <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f011071b:	55                   	push   %ebp
f011071c:	89 e5                	mov    %esp,%ebp
f011071e:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110721:	83 ec 04             	sub    $0x4,%esp
f0110724:	68 1c 7f 12 f0       	push   $0xf0127f1c
f0110729:	68 9a 03 00 00       	push   $0x39a
f011072e:	68 00 7e 12 f0       	push   $0xf0127e00
f0110733:	e8 01 fc fe ff       	call   f0100339 <_panic>

f0110738 <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f0110738:	55                   	push   %ebp
f0110739:	89 e5                	mov    %esp,%ebp
f011073b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011073e:	83 ec 04             	sub    $0x4,%esp
f0110741:	68 69 7f 12 f0       	push   $0xf0127f69
f0110746:	68 ba 04 00 00       	push   $0x4ba
f011074b:	68 00 7e 12 f0       	push   $0xf0127e00
f0110750:	e8 e4 fb fe ff       	call   f0100339 <_panic>

f0110755 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0110755:	55                   	push   %ebp
f0110756:	89 e5                	mov    %esp,%ebp
f0110758:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011075b:	83 ec 04             	sub    $0x4,%esp
f011075e:	68 1c 7f 12 f0       	push   $0xf0127f1c
f0110763:	68 c0 04 00 00       	push   $0x4c0
f0110768:	68 00 7e 12 f0       	push   $0xf0127e00
f011076d:	e8 c7 fb fe ff       	call   f0100339 <_panic>

f0110772 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0110772:	55                   	push   %ebp
f0110773:	89 e5                	mov    %esp,%ebp
f0110775:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110778:	83 ec 04             	sub    $0x4,%esp
f011077b:	68 1c 7f 12 f0       	push   $0xf0127f1c
f0110780:	68 e7 05 00 00       	push   $0x5e7
f0110785:	68 00 7e 12 f0       	push   $0xf0127e00
f011078a:	e8 aa fb fe ff       	call   f0100339 <_panic>

f011078f <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f011078f:	55                   	push   %ebp
f0110790:	89 e5                	mov    %esp,%ebp
f0110792:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110795:	e8 f0 aa ff ff       	call   f010b28a <get_cpu_proc>
f011079a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f011079d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01107a1:	75 16                	jne    f01107b9 <sys_check_LRU_lists+0x2a>
f01107a3:	68 7c 7f 12 f0       	push   $0xf0127f7c
f01107a8:	68 8c 7f 12 f0       	push   $0xf0127f8c
f01107ad:	6a 10                	push   $0x10
f01107af:	68 a1 7f 12 f0       	push   $0xf0127fa1
f01107b4:	e8 80 fb fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f01107b9:	83 ec 0c             	sub    $0xc,%esp
f01107bc:	68 c0 7f 12 f0       	push   $0xf0127fc0
f01107c1:	e8 c5 07 ff ff       	call   f0100f8b <cprintf>
f01107c6:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f01107c9:	83 ec 0c             	sub    $0xc,%esp
f01107cc:	ff 75 e0             	pushl  -0x20(%ebp)
f01107cf:	e8 f4 94 ff ff       	call   f0109cc8 <env_page_ws_print>
f01107d4:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f01107d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01107da:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f01107dd:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f01107e4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f01107eb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01107ef:	0f 84 a5 00 00 00    	je     f011089a <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f01107f5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01107fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01107ff:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0110805:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110808:	eb 4a                	jmp    f0110854 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f011080a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011080d:	8b 00                	mov    (%eax),%eax
f011080f:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0110812:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110815:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011081a:	89 c2                	mov    %eax,%edx
f011081c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011081f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110826:	8b 45 08             	mov    0x8(%ebp),%eax
f0110829:	01 c8                	add    %ecx,%eax
f011082b:	8b 00                	mov    (%eax),%eax
f011082d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0110830:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110833:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110838:	39 c2                	cmp    %eax,%edx
f011083a:	74 09                	je     f0110845 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f011083c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110843:	eb 3e                	jmp    f0110883 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0110845:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110848:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011084b:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110851:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110854:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110858:	74 08                	je     f0110862 <sys_check_LRU_lists+0xd3>
f011085a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011085d:	8b 40 10             	mov    0x10(%eax),%eax
f0110860:	eb 05                	jmp    f0110867 <sys_check_LRU_lists+0xd8>
f0110862:	b8 00 00 00 00       	mov    $0x0,%eax
f0110867:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011086a:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0110870:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110873:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110879:	85 c0                	test   %eax,%eax
f011087b:	75 8d                	jne    f011080a <sys_check_LRU_lists+0x7b>
f011087d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110881:	75 87                	jne    f011080a <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0110883:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110886:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f011088c:	8b 45 10             	mov    0x10(%ebp),%eax
f011088f:	39 c2                	cmp    %eax,%edx
f0110891:	74 07                	je     f011089a <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f0110893:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f011089a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011089e:	0f 84 a5 00 00 00    	je     f0110949 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f01108a4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01108ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01108ae:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01108b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01108b7:	eb 4a                	jmp    f0110903 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f01108b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01108bc:	8b 00                	mov    (%eax),%eax
f01108be:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01108c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01108c4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01108c9:	89 c2                	mov    %eax,%edx
f01108cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01108ce:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01108d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108d8:	01 c8                	add    %ecx,%eax
f01108da:	8b 00                	mov    (%eax),%eax
f01108dc:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01108df:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01108e2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01108e7:	39 c2                	cmp    %eax,%edx
f01108e9:	74 09                	je     f01108f4 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f01108eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f01108f2:	eb 3e                	jmp    f0110932 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f01108f4:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01108f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01108fa:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110900:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110903:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110907:	74 08                	je     f0110911 <sys_check_LRU_lists+0x182>
f0110909:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011090c:	8b 40 10             	mov    0x10(%eax),%eax
f011090f:	eb 05                	jmp    f0110916 <sys_check_LRU_lists+0x187>
f0110911:	b8 00 00 00 00       	mov    $0x0,%eax
f0110916:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0110919:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f011091f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110922:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110928:	85 c0                	test   %eax,%eax
f011092a:	75 8d                	jne    f01108b9 <sys_check_LRU_lists+0x12a>
f011092c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110930:	75 87                	jne    f01108b9 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0110932:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110935:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f011093b:	8b 45 14             	mov    0x14(%ebp),%eax
f011093e:	39 c2                	cmp    %eax,%edx
f0110940:	74 07                	je     f0110949 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0110942:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0110949:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011094c:	23 45 f0             	and    -0x10(%ebp),%eax
}
f011094f:	c9                   	leave  
f0110950:	c3                   	ret    

f0110951 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0110951:	55                   	push   %ebp
f0110952:	89 e5                	mov    %esp,%ebp
f0110954:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110957:	e8 2e a9 ff ff       	call   f010b28a <get_cpu_proc>
f011095c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f011095f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0110963:	75 16                	jne    f011097b <sys_check_LRU_lists_free+0x2a>
f0110965:	68 7c 7f 12 f0       	push   $0xf0127f7c
f011096a:	68 8c 7f 12 f0       	push   $0xf0127f8c
f011096f:	6a 45                	push   $0x45
f0110971:	68 a1 7f 12 f0       	push   $0xf0127fa1
f0110976:	e8 be f9 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f011097b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011097e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0110981:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110988:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011098b:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0110991:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110994:	eb 65                	jmp    f01109fb <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0110996:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011099d:	eb 3a                	jmp    f01109d9 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f011099f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01109a2:	8b 00                	mov    (%eax),%eax
f01109a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01109a7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01109aa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01109af:	89 c2                	mov    %eax,%edx
f01109b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01109b4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01109bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01109be:	01 c8                	add    %ecx,%eax
f01109c0:	8b 00                	mov    (%eax),%eax
f01109c2:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01109c5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01109c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01109cd:	39 c2                	cmp    %eax,%edx
f01109cf:	75 05                	jne    f01109d6 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f01109d1:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01109d4:	eb 0b                	jmp    f01109e1 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f01109d6:	ff 45 ec             	incl   -0x14(%ebp)
f01109d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01109dc:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01109df:	7c be                	jl     f011099f <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01109e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01109e5:	7e 08                	jle    f01109ef <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f01109e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01109ea:	e9 ed 00 00 00       	jmp    f0110adc <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01109ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01109f2:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01109f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01109fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01109ff:	74 08                	je     f0110a09 <sys_check_LRU_lists_free+0xb8>
f0110a01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110a04:	8b 40 10             	mov    0x10(%eax),%eax
f0110a07:	eb 05                	jmp    f0110a0e <sys_check_LRU_lists_free+0xbd>
f0110a09:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a0e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0110a11:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0110a17:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110a1a:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110a20:	85 c0                	test   %eax,%eax
f0110a22:	0f 85 6e ff ff ff    	jne    f0110996 <sys_check_LRU_lists_free+0x45>
f0110a28:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110a2c:	0f 85 64 ff ff ff    	jne    f0110996 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110a32:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110a35:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0110a3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110a3e:	eb 62                	jmp    f0110aa2 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0110a40:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110a47:	eb 3a                	jmp    f0110a83 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0110a49:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110a4c:	8b 00                	mov    (%eax),%eax
f0110a4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0110a51:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110a54:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110a59:	89 c2                	mov    %eax,%edx
f0110a5b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110a5e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110a65:	8b 45 08             	mov    0x8(%ebp),%eax
f0110a68:	01 c8                	add    %ecx,%eax
f0110a6a:	8b 00                	mov    (%eax),%eax
f0110a6c:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0110a6f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110a72:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110a77:	39 c2                	cmp    %eax,%edx
f0110a79:	75 05                	jne    f0110a80 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0110a7b:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0110a7e:	eb 0b                	jmp    f0110a8b <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0110a80:	ff 45 e8             	incl   -0x18(%ebp)
f0110a83:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110a86:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110a89:	7c be                	jl     f0110a49 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0110a8b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110a8f:	7e 05                	jle    f0110a96 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0110a91:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110a94:	eb 46                	jmp    f0110adc <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110a96:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110a99:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110a9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110aa2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110aa6:	74 08                	je     f0110ab0 <sys_check_LRU_lists_free+0x15f>
f0110aa8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110aab:	8b 40 10             	mov    0x10(%eax),%eax
f0110aae:	eb 05                	jmp    f0110ab5 <sys_check_LRU_lists_free+0x164>
f0110ab0:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ab5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0110ab8:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0110abe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110ac1:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110ac7:	85 c0                	test   %eax,%eax
f0110ac9:	0f 85 71 ff ff ff    	jne    f0110a40 <sys_check_LRU_lists_free+0xef>
f0110acf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110ad3:	0f 85 67 ff ff ff    	jne    f0110a40 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f0110ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110adc:	c9                   	leave  
f0110add:	c3                   	ret    

f0110ade <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0110ade:	55                   	push   %ebp
f0110adf:	89 e5                	mov    %esp,%ebp
f0110ae1:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f0110ae4:	e8 a1 a7 ff ff       	call   f010b28a <get_cpu_proc>
f0110ae9:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0110aec:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0110af0:	75 16                	jne    f0110b08 <sys_check_WS_list+0x2a>
f0110af2:	68 7c 7f 12 f0       	push   $0xf0127f7c
f0110af7:	68 8c 7f 12 f0       	push   $0xf0127f8c
f0110afc:	6a 79                	push   $0x79
f0110afe:	68 a1 7f 12 f0       	push   $0xf0127fa1
f0110b03:	e8 31 f8 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0110b08:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110b0b:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f0110b0e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f0110b15:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0110b19:	74 06                	je     f0110b21 <sys_check_WS_list+0x43>
f0110b1b:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0110b1f:	75 1f                	jne    f0110b40 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0110b21:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110b24:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f0110b2a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b2d:	39 c2                	cmp    %eax,%edx
f0110b2f:	74 0f                	je     f0110b40 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0110b31:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110b38:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110b3b:	e9 15 03 00 00       	jmp    f0110e55 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0110b40:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0110b44:	74 39                	je     f0110b7f <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0110b46:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110b49:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0110b4f:	8b 00                	mov    (%eax),%eax
f0110b51:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0110b54:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110b57:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110b5c:	89 c2                	mov    %eax,%edx
f0110b5e:	8b 45 10             	mov    0x10(%ebp),%eax
f0110b61:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0110b64:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110b67:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110b6c:	39 c2                	cmp    %eax,%edx
f0110b6e:	74 0f                	je     f0110b7f <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0110b70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110b77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110b7a:	e9 d6 02 00 00       	jmp    f0110e55 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0110b7f:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0110b83:	0f 85 3c 01 00 00    	jne    f0110cc5 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0110b89:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0110b90:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0110b94:	74 4c                	je     f0110be2 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0110b96:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110b9d:	eb 3b                	jmp    f0110bda <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0110b9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110ba2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110ba9:	8b 45 08             	mov    0x8(%ebp),%eax
f0110bac:	01 d0                	add    %edx,%eax
f0110bae:	8b 00                	mov    (%eax),%eax
f0110bb0:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0110bb3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110bb6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110bbb:	89 c2                	mov    %eax,%edx
f0110bbd:	8b 45 10             	mov    0x10(%ebp),%eax
f0110bc0:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0110bc3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0110bc6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110bcb:	39 c2                	cmp    %eax,%edx
f0110bcd:	75 08                	jne    f0110bd7 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f0110bcf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110bd2:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f0110bd5:	eb 0b                	jmp    f0110be2 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0110bd7:	ff 45 e8             	incl   -0x18(%ebp)
f0110bda:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110bdd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110be0:	7c bd                	jl     f0110b9f <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f0110be2:	83 ec 08             	sub    $0x8,%esp
f0110be5:	ff 75 ec             	pushl  -0x14(%ebp)
f0110be8:	68 e8 7f 12 f0       	push   $0xf0127fe8
f0110bed:	e8 99 03 ff ff       	call   f0100f8b <cprintf>
f0110bf2:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f0110bf5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110bf8:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0110bfe:	85 c0                	test   %eax,%eax
f0110c00:	74 0e                	je     f0110c10 <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f0110c02:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110c05:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0110c0b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110c0e:	eb 0c                	jmp    f0110c1c <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0110c10:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110c13:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110c19:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f0110c1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110c1f:	8b 00                	mov    (%eax),%eax
f0110c21:	83 ec 08             	sub    $0x8,%esp
f0110c24:	50                   	push   %eax
f0110c25:	68 07 80 12 f0       	push   $0xf0128007
f0110c2a:	e8 5c 03 ff ff       	call   f0100f8b <cprintf>
f0110c2f:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f0110c32:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0110c39:	eb 79                	jmp    f0110cb4 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f0110c3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110c3e:	8b 00                	mov    (%eax),%eax
f0110c40:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0110c43:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0110c46:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110c4b:	89 c2                	mov    %eax,%edx
f0110c4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110c50:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110c57:	8b 45 08             	mov    0x8(%ebp),%eax
f0110c5a:	01 c8                	add    %ecx,%eax
f0110c5c:	8b 00                	mov    (%eax),%eax
f0110c5e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0110c61:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0110c64:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110c69:	39 c2                	cmp    %eax,%edx
f0110c6b:	74 0c                	je     f0110c79 <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f0110c6d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110c74:	e9 d9 01 00 00       	jmp    f0110e52 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0110c79:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110c7c:	40                   	inc    %eax
f0110c7d:	89 c2                	mov    %eax,%edx
f0110c7f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110c82:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f0110c88:	89 d0                	mov    %edx,%eax
f0110c8a:	ba 00 00 00 00       	mov    $0x0,%edx
f0110c8f:	f7 f1                	div    %ecx
f0110c91:	89 d0                	mov    %edx,%eax
f0110c93:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0110c96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110c99:	8b 40 10             	mov    0x10(%eax),%eax
f0110c9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f0110c9f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110ca3:	75 0c                	jne    f0110cb1 <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0110ca5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110ca8:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110cae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0110cb1:	ff 45 e4             	incl   -0x1c(%ebp)
f0110cb4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110cb7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110cba:	0f 8c 7b ff ff ff    	jl     f0110c3b <sys_check_WS_list+0x15d>
f0110cc0:	e9 8d 01 00 00       	jmp    f0110e52 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0110cc5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0110cc9:	74 0a                	je     f0110cd5 <sys_check_WS_list+0x1f7>
f0110ccb:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0110ccf:	0f 85 be 00 00 00    	jne    f0110d93 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110cd5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0110cdc:	e9 a1 00 00 00       	jmp    f0110d82 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f0110ce1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110ce8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110ceb:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110cf1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110cf4:	eb 47                	jmp    f0110d3d <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110cf6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110cf9:	8b 00                	mov    (%eax),%eax
f0110cfb:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0110cfe:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110d01:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110d06:	89 c2                	mov    %eax,%edx
f0110d08:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110d0b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110d12:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d15:	01 c8                	add    %ecx,%eax
f0110d17:	8b 00                	mov    (%eax),%eax
f0110d19:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0110d1c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110d1f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110d24:	39 c2                	cmp    %eax,%edx
f0110d26:	75 09                	jne    f0110d31 <sys_check_WS_list+0x253>
				{
					found = 1;
f0110d28:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f0110d2f:	eb 3b                	jmp    f0110d6c <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110d31:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110d34:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110d3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110d3d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110d41:	74 08                	je     f0110d4b <sys_check_WS_list+0x26d>
f0110d43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110d46:	8b 40 10             	mov    0x10(%eax),%eax
f0110d49:	eb 05                	jmp    f0110d50 <sys_check_WS_list+0x272>
f0110d4b:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d50:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0110d53:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0110d59:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110d5c:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110d62:	85 c0                	test   %eax,%eax
f0110d64:	75 90                	jne    f0110cf6 <sys_check_WS_list+0x218>
f0110d66:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110d6a:	75 8a                	jne    f0110cf6 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f0110d6c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0110d70:	75 0d                	jne    f0110d7f <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f0110d72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110d79:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110d7a:	e9 d3 00 00 00       	jmp    f0110e52 <sys_check_WS_list+0x374>
f0110d7f:	ff 45 e0             	incl   -0x20(%ebp)
f0110d82:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110d85:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110d88:	0f 8c 53 ff ff ff    	jl     f0110ce1 <sys_check_WS_list+0x203>
f0110d8e:	e9 bf 00 00 00       	jmp    f0110e52 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0110d93:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0110d97:	0f 85 b5 00 00 00    	jne    f0110e52 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110d9d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0110da4:	e9 9d 00 00 00       	jmp    f0110e46 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f0110da9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110db0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110db3:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110db9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110dbc:	eb 47                	jmp    f0110e05 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110dbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110dc1:	8b 00                	mov    (%eax),%eax
f0110dc3:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0110dc6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110dc9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110dce:	89 c2                	mov    %eax,%edx
f0110dd0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110dd3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110dda:	8b 45 08             	mov    0x8(%ebp),%eax
f0110ddd:	01 c8                	add    %ecx,%eax
f0110ddf:	8b 00                	mov    (%eax),%eax
f0110de1:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0110de4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0110de7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110dec:	39 c2                	cmp    %eax,%edx
f0110dee:	75 09                	jne    f0110df9 <sys_check_WS_list+0x31b>
				{
					found = 1;
f0110df0:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f0110df7:	eb 3b                	jmp    f0110e34 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110df9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110dfc:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110e02:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110e05:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e09:	74 08                	je     f0110e13 <sys_check_WS_list+0x335>
f0110e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110e0e:	8b 40 10             	mov    0x10(%eax),%eax
f0110e11:	eb 05                	jmp    f0110e18 <sys_check_WS_list+0x33a>
f0110e13:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e18:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0110e1b:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0110e21:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110e24:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110e2a:	85 c0                	test   %eax,%eax
f0110e2c:	75 90                	jne    f0110dbe <sys_check_WS_list+0x2e0>
f0110e2e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e32:	75 8a                	jne    f0110dbe <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f0110e34:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0110e38:	74 09                	je     f0110e43 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f0110e3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110e41:	eb 0f                	jmp    f0110e52 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110e43:	ff 45 d8             	incl   -0x28(%ebp)
f0110e46:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110e49:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110e4c:	0f 8c 57 ff ff ff    	jl     f0110da9 <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f0110e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0110e55:	c9                   	leave  
f0110e56:	c3                   	ret    

f0110e57 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0110e57:	55                   	push   %ebp
f0110e58:	89 e5                	mov    %esp,%ebp
f0110e5a:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f0110e5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0110e64:	8b 15 24 ba 6b f0    	mov    0xf06bba24,%edx
f0110e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e6d:	39 c2                	cmp    %eax,%edx
f0110e6f:	74 0a                	je     f0110e7b <hasExpectedCommands+0x24>
		return 0;
f0110e71:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e76:	e9 8b 00 00 00       	jmp    f0110f06 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0110e7b:	a1 18 ba 6b f0       	mov    0xf06bba18,%eax
f0110e80:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110e83:	eb 55                	jmp    f0110eda <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0110e85:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0110e8c:	eb 2a                	jmp    f0110eb8 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f0110e8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110e91:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110e98:	8b 45 08             	mov    0x8(%ebp),%eax
f0110e9b:	01 d0                	add    %edx,%eax
f0110e9d:	8b 10                	mov    (%eax),%edx
f0110e9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110ea2:	8b 00                	mov    (%eax),%eax
f0110ea4:	83 ec 08             	sub    $0x8,%esp
f0110ea7:	52                   	push   %edx
f0110ea8:	50                   	push   %eax
f0110ea9:	e8 37 e7 00 00       	call   f011f5e5 <strcmp>
f0110eae:	83 c4 10             	add    $0x10,%esp
f0110eb1:	85 c0                	test   %eax,%eax
f0110eb3:	74 0d                	je     f0110ec2 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0110eb5:	ff 45 f0             	incl   -0x10(%ebp)
f0110eb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110ebb:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110ebe:	7c ce                	jl     f0110e8e <hasExpectedCommands+0x37>
f0110ec0:	eb 01                	jmp    f0110ec3 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0110ec2:	90                   	nop
		if (i == commandsCount)
f0110ec3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110ec6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110ec9:	75 07                	jne    f0110ed2 <hasExpectedCommands+0x7b>
			return 0;
f0110ecb:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ed0:	eb 34                	jmp    f0110f06 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0110ed2:	a1 20 ba 6b f0       	mov    0xf06bba20,%eax
f0110ed7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110eda:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110ede:	74 08                	je     f0110ee8 <hasExpectedCommands+0x91>
f0110ee0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110ee3:	8b 40 10             	mov    0x10(%eax),%eax
f0110ee6:	eb 05                	jmp    f0110eed <hasExpectedCommands+0x96>
f0110ee8:	b8 00 00 00 00       	mov    $0x0,%eax
f0110eed:	a3 20 ba 6b f0       	mov    %eax,0xf06bba20
f0110ef2:	a1 20 ba 6b f0       	mov    0xf06bba20,%eax
f0110ef7:	85 c0                	test   %eax,%eax
f0110ef9:	75 8a                	jne    f0110e85 <hasExpectedCommands+0x2e>
f0110efb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110eff:	75 84                	jne    f0110e85 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f0110f01:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110f06:	c9                   	leave  
f0110f07:	c3                   	ret    

f0110f08 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0110f08:	55                   	push   %ebp
f0110f09:	89 e5                	mov    %esp,%ebp
f0110f0b:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0110f0e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110f15:	eb 2e                	jmp    f0110f45 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0110f17:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0110f1a:	89 d0                	mov    %edx,%eax
f0110f1c:	01 c0                	add    %eax,%eax
f0110f1e:	01 d0                	add    %edx,%eax
f0110f20:	c1 e0 03             	shl    $0x3,%eax
f0110f23:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0110f28:	8b 00                	mov    (%eax),%eax
f0110f2a:	83 ec 08             	sub    $0x8,%esp
f0110f2d:	ff 75 08             	pushl  0x8(%ebp)
f0110f30:	50                   	push   %eax
f0110f31:	e8 af e6 00 00       	call   f011f5e5 <strcmp>
f0110f36:	83 c4 10             	add    $0x10,%esp
f0110f39:	85 c0                	test   %eax,%eax
f0110f3b:	75 05                	jne    f0110f42 <getIndexOfCommand+0x3a>
			return i;
f0110f3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110f40:	eb 14                	jmp    f0110f56 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0110f42:	ff 45 f4             	incl   -0xc(%ebp)
f0110f45:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0110f48:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f0110f4d:	39 c2                	cmp    %eax,%edx
f0110f4f:	72 c6                	jb     f0110f17 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f0110f51:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0110f56:	c9                   	leave  
f0110f57:	c3                   	ret    

f0110f58 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0110f58:	55                   	push   %ebp
f0110f59:	89 e5                	mov    %esp,%ebp
f0110f5b:	57                   	push   %edi
f0110f5c:	56                   	push   %esi
f0110f5d:	53                   	push   %ebx
f0110f5e:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0110f64:	83 ec 0c             	sub    $0xc,%esp
f0110f67:	68 40 80 12 f0       	push   $0xf0128040
f0110f6c:	e8 1a 00 ff ff       	call   f0100f8b <cprintf>
f0110f71:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0110f74:	83 ec 0c             	sub    $0xc,%esp
f0110f77:	68 64 80 12 f0       	push   $0xf0128064
f0110f7c:	e8 0a 00 ff ff       	call   f0100f8b <cprintf>
f0110f81:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0110f84:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0110f8b:	c7 45 8c 7f 80 12 f0 	movl   $0xf012807f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0110f92:	83 ec 08             	sub    $0x8,%esp
f0110f95:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0110f98:	50                   	push   %eax
f0110f99:	6a 01                	push   $0x1
f0110f9b:	e8 30 12 ff ff       	call   f01021d0 <process_command>
f0110fa0:	83 c4 10             	add    $0x10,%esp
f0110fa3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0110fa6:	83 ec 0c             	sub    $0xc,%esp
f0110fa9:	68 8c 80 12 f0       	push   $0xf012808c
f0110fae:	e8 d8 ff fe ff       	call   f0100f8b <cprintf>
f0110fb3:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0110fb6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0110fb9:	83 ec 0c             	sub    $0xc,%esp
f0110fbc:	50                   	push   %eax
f0110fbd:	e8 46 ff ff ff       	call   f0110f08 <getIndexOfCommand>
f0110fc2:	83 c4 10             	add    $0x10,%esp
f0110fc5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0110fc8:	75 0f                	jne    f0110fd9 <TestAutoCompleteCommand+0x81>
f0110fca:	a1 18 ba 6b f0       	mov    0xf06bba18,%eax
f0110fcf:	85 c0                	test   %eax,%eax
f0110fd1:	75 06                	jne    f0110fd9 <TestAutoCompleteCommand+0x81>
		eval += 15;
f0110fd3:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0110fd7:	eb 10                	jmp    f0110fe9 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0110fd9:	83 ec 0c             	sub    $0xc,%esp
f0110fdc:	68 bc 80 12 f0       	push   $0xf01280bc
f0110fe1:	e8 a5 ff fe ff       	call   f0100f8b <cprintf>
f0110fe6:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f0110fe9:	83 ec 0c             	sub    $0xc,%esp
f0110fec:	68 0c 81 12 f0       	push   $0xf012810c
f0110ff1:	e8 95 ff fe ff       	call   f0100f8b <cprintf>
f0110ff6:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f0110ff9:	c7 45 88 32 81 12 f0 	movl   $0xf0128132,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f0111000:	83 ec 08             	sub    $0x8,%esp
f0111003:	8d 45 88             	lea    -0x78(%ebp),%eax
f0111006:	50                   	push   %eax
f0111007:	6a 01                	push   $0x1
f0111009:	e8 c2 11 ff ff       	call   f01021d0 <process_command>
f011100e:	83 c4 10             	add    $0x10,%esp
f0111011:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0111014:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111018:	75 30                	jne    f011104a <TestAutoCompleteCommand+0xf2>
f011101a:	8d 45 90             	lea    -0x70(%ebp),%eax
f011101d:	bb 10 85 12 f0       	mov    $0xf0128510,%ebx
f0111022:	ba 03 00 00 00       	mov    $0x3,%edx
f0111027:	89 c7                	mov    %eax,%edi
f0111029:	89 de                	mov    %ebx,%esi
f011102b:	89 d1                	mov    %edx,%ecx
f011102d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011102f:	83 ec 08             	sub    $0x8,%esp
f0111032:	6a 03                	push   $0x3
f0111034:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111037:	50                   	push   %eax
f0111038:	e8 1a fe ff ff       	call   f0110e57 <hasExpectedCommands>
f011103d:	83 c4 10             	add    $0x10,%esp
f0111040:	85 c0                	test   %eax,%eax
f0111042:	74 06                	je     f011104a <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111044:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111048:	eb 10                	jmp    f011105a <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011104a:	83 ec 0c             	sub    $0xc,%esp
f011104d:	68 38 81 12 f0       	push   $0xf0128138
f0111052:	e8 34 ff fe ff       	call   f0100f8b <cprintf>
f0111057:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f011105a:	83 ec 0c             	sub    $0xc,%esp
f011105d:	68 88 81 12 f0       	push   $0xf0128188
f0111062:	e8 24 ff fe ff       	call   f0100f8b <cprintf>
f0111067:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f011106a:	c7 45 84 ad 81 12 f0 	movl   $0xf01281ad,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f0111071:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111074:	83 ec 04             	sub    $0x4,%esp
f0111077:	50                   	push   %eax
f0111078:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011107b:	50                   	push   %eax
f011107c:	68 b0 81 12 f0       	push   $0xf01281b0
f0111081:	e8 05 ff fe ff       	call   f0100f8b <cprintf>
f0111086:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0111089:	83 ec 08             	sub    $0x8,%esp
f011108c:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011108f:	50                   	push   %eax
f0111090:	6a 01                	push   $0x1
f0111092:	e8 39 11 ff ff       	call   f01021d0 <process_command>
f0111097:	83 c4 10             	add    $0x10,%esp
f011109a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f011109d:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01110a1:	75 1b                	jne    f01110be <TestAutoCompleteCommand+0x166>
f01110a3:	83 ec 08             	sub    $0x8,%esp
f01110a6:	6a 01                	push   $0x1
f01110a8:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01110ab:	50                   	push   %eax
f01110ac:	e8 a6 fd ff ff       	call   f0110e57 <hasExpectedCommands>
f01110b1:	83 c4 10             	add    $0x10,%esp
f01110b4:	85 c0                	test   %eax,%eax
f01110b6:	74 06                	je     f01110be <TestAutoCompleteCommand+0x166>
		eval += 15;
f01110b8:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01110bc:	eb 10                	jmp    f01110ce <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01110be:	83 ec 0c             	sub    $0xc,%esp
f01110c1:	68 d0 81 12 f0       	push   $0xf01281d0
f01110c6:	e8 c0 fe fe ff       	call   f0100f8b <cprintf>
f01110cb:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01110ce:	83 ec 0c             	sub    $0xc,%esp
f01110d1:	68 28 82 12 f0       	push   $0xf0128228
f01110d6:	e8 b0 fe fe ff       	call   f0100f8b <cprintf>
f01110db:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f01110de:	c7 45 80 4e 82 12 f0 	movl   $0xf012824e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f01110e5:	83 ec 08             	sub    $0x8,%esp
f01110e8:	8d 45 80             	lea    -0x80(%ebp),%eax
f01110eb:	50                   	push   %eax
f01110ec:	6a 01                	push   $0x1
f01110ee:	e8 dd 10 ff ff       	call   f01021d0 <process_command>
f01110f3:	83 c4 10             	add    $0x10,%esp
f01110f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f01110f9:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f01110fd:	75 0f                	jne    f011110e <TestAutoCompleteCommand+0x1b6>
f01110ff:	a1 24 ba 6b f0       	mov    0xf06bba24,%eax
f0111104:	85 c0                	test   %eax,%eax
f0111106:	75 06                	jne    f011110e <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0111108:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011110c:	eb 10                	jmp    f011111e <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011110e:	83 ec 0c             	sub    $0xc,%esp
f0111111:	68 54 82 12 f0       	push   $0xf0128254
f0111116:	e8 70 fe fe ff       	call   f0100f8b <cprintf>
f011111b:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f011111e:	83 ec 0c             	sub    $0xc,%esp
f0111121:	68 a4 82 12 f0       	push   $0xf01282a4
f0111126:	e8 60 fe fe ff       	call   f0100f8b <cprintf>
f011112b:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f011112e:	c7 85 7c ff ff ff c9 	movl   $0xf01282c9,-0x84(%ebp)
f0111135:	82 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111138:	83 ec 08             	sub    $0x8,%esp
f011113b:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f0111141:	50                   	push   %eax
f0111142:	6a 01                	push   $0x1
f0111144:	e8 87 10 ff ff       	call   f01021d0 <process_command>
f0111149:	83 c4 10             	add    $0x10,%esp
f011114c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f011114f:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111153:	75 30                	jne    f0111185 <TestAutoCompleteCommand+0x22d>
f0111155:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111158:	bb a0 85 12 f0       	mov    $0xf01285a0,%ebx
f011115d:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111162:	89 c7                	mov    %eax,%edi
f0111164:	89 de                	mov    %ebx,%esi
f0111166:	89 d1                	mov    %edx,%ecx
f0111168:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011116a:	83 ec 08             	sub    $0x8,%esp
f011116d:	6a 0c                	push   $0xc
f011116f:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111172:	50                   	push   %eax
f0111173:	e8 df fc ff ff       	call   f0110e57 <hasExpectedCommands>
f0111178:	83 c4 10             	add    $0x10,%esp
f011117b:	85 c0                	test   %eax,%eax
f011117d:	74 06                	je     f0111185 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f011117f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111183:	eb 10                	jmp    f0111195 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111185:	83 ec 0c             	sub    $0xc,%esp
f0111188:	68 cc 82 12 f0       	push   $0xf01282cc
f011118d:	e8 f9 fd fe ff       	call   f0100f8b <cprintf>
f0111192:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111195:	83 ec 0c             	sub    $0xc,%esp
f0111198:	68 24 83 12 f0       	push   $0xf0128324
f011119d:	e8 e9 fd fe ff       	call   f0100f8b <cprintf>
f01111a2:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f01111a5:	c7 85 78 ff ff ff 49 	movl   $0xf0128349,-0x88(%ebp)
f01111ac:	83 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f01111af:	83 ec 08             	sub    $0x8,%esp
f01111b2:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01111b8:	50                   	push   %eax
f01111b9:	6a 01                	push   $0x1
f01111bb:	e8 10 10 ff ff       	call   f01021d0 <process_command>
f01111c0:	83 c4 10             	add    $0x10,%esp
f01111c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f01111c6:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01111ca:	75 30                	jne    f01111fc <TestAutoCompleteCommand+0x2a4>
f01111cc:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01111cf:	bb e8 85 12 f0       	mov    $0xf01285e8,%ebx
f01111d4:	ba 05 00 00 00       	mov    $0x5,%edx
f01111d9:	89 c7                	mov    %eax,%edi
f01111db:	89 de                	mov    %ebx,%esi
f01111dd:	89 d1                	mov    %edx,%ecx
f01111df:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01111e1:	83 ec 08             	sub    $0x8,%esp
f01111e4:	6a 05                	push   $0x5
f01111e6:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01111e9:	50                   	push   %eax
f01111ea:	e8 68 fc ff ff       	call   f0110e57 <hasExpectedCommands>
f01111ef:	83 c4 10             	add    $0x10,%esp
f01111f2:	85 c0                	test   %eax,%eax
f01111f4:	74 06                	je     f01111fc <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f01111f6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01111fa:	eb 10                	jmp    f011120c <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f01111fc:	83 ec 0c             	sub    $0xc,%esp
f01111ff:	68 4c 83 12 f0       	push   $0xf012834c
f0111204:	e8 82 fd fe ff       	call   f0100f8b <cprintf>
f0111209:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f011120c:	83 ec 0c             	sub    $0xc,%esp
f011120f:	68 a4 83 12 f0       	push   $0xf01283a4
f0111214:	e8 72 fd fe ff       	call   f0100f8b <cprintf>
f0111219:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f011121c:	c7 85 70 ff ff ff d0 	movl   $0xf01283d0,-0x90(%ebp)
f0111223:	83 12 f0 
f0111226:	c7 85 74 ff ff ff d5 	movl   $0xf01283d5,-0x8c(%ebp)
f011122d:	83 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111230:	83 ec 08             	sub    $0x8,%esp
f0111233:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111239:	50                   	push   %eax
f011123a:	6a 02                	push   $0x2
f011123c:	e8 8f 0f ff ff       	call   f01021d0 <process_command>
f0111241:	83 c4 10             	add    $0x10,%esp
f0111244:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111247:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011124d:	83 ec 0c             	sub    $0xc,%esp
f0111250:	50                   	push   %eax
f0111251:	e8 b2 fc ff ff       	call   f0110f08 <getIndexOfCommand>
f0111256:	83 c4 10             	add    $0x10,%esp
f0111259:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011125c:	75 0f                	jne    f011126d <TestAutoCompleteCommand+0x315>
f011125e:	a1 18 ba 6b f0       	mov    0xf06bba18,%eax
f0111263:	85 c0                	test   %eax,%eax
f0111265:	75 06                	jne    f011126d <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111267:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011126b:	eb 10                	jmp    f011127d <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011126d:	83 ec 0c             	sub    $0xc,%esp
f0111270:	68 dc 83 12 f0       	push   $0xf01283dc
f0111275:	e8 11 fd fe ff       	call   f0100f8b <cprintf>
f011127a:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f011127d:	83 ec 0c             	sub    $0xc,%esp
f0111280:	68 2c 84 12 f0       	push   $0xf012842c
f0111285:	e8 01 fd fe ff       	call   f0100f8b <cprintf>
f011128a:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f011128d:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111293:	bb 10 86 12 f0       	mov    $0xf0128610,%ebx
f0111298:	ba 03 00 00 00       	mov    $0x3,%edx
f011129d:	89 c7                	mov    %eax,%edi
f011129f:	89 de                	mov    %ebx,%esi
f01112a1:	89 d1                	mov    %edx,%ecx
f01112a3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f01112a5:	83 ec 08             	sub    $0x8,%esp
f01112a8:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01112ae:	50                   	push   %eax
f01112af:	6a 03                	push   $0x3
f01112b1:	e8 1a 0f ff ff       	call   f01021d0 <process_command>
f01112b6:	83 c4 10             	add    $0x10,%esp
f01112b9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f01112bc:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f01112c2:	83 ec 0c             	sub    $0xc,%esp
f01112c5:	50                   	push   %eax
f01112c6:	e8 3d fc ff ff       	call   f0110f08 <getIndexOfCommand>
f01112cb:	83 c4 10             	add    $0x10,%esp
f01112ce:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01112d1:	75 0f                	jne    f01112e2 <TestAutoCompleteCommand+0x38a>
f01112d3:	a1 18 ba 6b f0       	mov    0xf06bba18,%eax
f01112d8:	85 c0                	test   %eax,%eax
f01112da:	75 06                	jne    f01112e2 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f01112dc:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01112e0:	eb 10                	jmp    f01112f2 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01112e2:	83 ec 0c             	sub    $0xc,%esp
f01112e5:	68 60 84 12 f0       	push   $0xf0128460
f01112ea:	e8 9c fc fe ff       	call   f0100f8b <cprintf>
f01112ef:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f01112f2:	83 ec 08             	sub    $0x8,%esp
f01112f5:	ff 75 e4             	pushl  -0x1c(%ebp)
f01112f8:	68 b0 84 12 f0       	push   $0xf01284b0
f01112fd:	e8 89 fc fe ff       	call   f0100f8b <cprintf>
f0111302:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111305:	83 ec 0c             	sub    $0xc,%esp
f0111308:	68 e0 84 12 f0       	push   $0xf01284e0
f011130d:	e8 79 fc fe ff       	call   f0100f8b <cprintf>
f0111312:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111315:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011131a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011131d:	5b                   	pop    %ebx
f011131e:	5e                   	pop    %esi
f011131f:	5f                   	pop    %edi
f0111320:	5d                   	pop    %ebp
f0111321:	c3                   	ret    

f0111322 <test_str2lower_function>:

int test_str2lower_function()
{
f0111322:	55                   	push   %ebp
f0111323:	89 e5                	mov    %esp,%ebp
f0111325:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f011132b:	83 ec 0c             	sub    $0xc,%esp
f011132e:	68 1c 86 12 f0       	push   $0xf012861c
f0111333:	e8 53 fc fe ff       	call   f0100f8b <cprintf>
f0111338:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f011133b:	83 ec 0c             	sub    $0xc,%esp
f011133e:	68 3d 86 12 f0       	push   $0xf012863d
f0111343:	e8 43 fc fe ff       	call   f0100f8b <cprintf>
f0111348:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f011134b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111352:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111359:	c7 45 ec 57 86 12 f0 	movl   $0xf0128657,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111360:	83 ec 08             	sub    $0x8,%esp
f0111363:	ff 75 ec             	pushl  -0x14(%ebp)
f0111366:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f011136c:	50                   	push   %eax
f011136d:	e8 50 e8 00 00       	call   f011fbc2 <str2lower>
f0111372:	83 c4 10             	add    $0x10,%esp
f0111375:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111378:	83 ec 0c             	sub    $0xc,%esp
f011137b:	ff 75 e8             	pushl  -0x18(%ebp)
f011137e:	e8 56 e1 00 00       	call   f011f4d9 <strlen>
f0111383:	83 c4 10             	add    $0x10,%esp
f0111386:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111389:	83 ec 08             	sub    $0x8,%esp
f011138c:	68 62 86 12 f0       	push   $0xf0128662
f0111391:	ff 75 e8             	pushl  -0x18(%ebp)
f0111394:	e8 4c e2 00 00       	call   f011f5e5 <strcmp>
f0111399:	83 c4 10             	add    $0x10,%esp
f011139c:	85 c0                	test   %eax,%eax
f011139e:	75 13                	jne    f01113b3 <test_str2lower_function+0x91>
f01113a0:	83 ec 0c             	sub    $0xc,%esp
f01113a3:	ff 75 ec             	pushl  -0x14(%ebp)
f01113a6:	e8 2e e1 00 00       	call   f011f4d9 <strlen>
f01113ab:	83 c4 10             	add    $0x10,%esp
f01113ae:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01113b1:	74 15                	je     f01113c8 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f01113b3:	83 ec 08             	sub    $0x8,%esp
f01113b6:	ff 75 e8             	pushl  -0x18(%ebp)
f01113b9:	68 70 86 12 f0       	push   $0xf0128670
f01113be:	e8 c8 fb fe ff       	call   f0100f8b <cprintf>
f01113c3:	83 c4 10             	add    $0x10,%esp
f01113c6:	eb 04                	jmp    f01113cc <test_str2lower_function+0xaa>
	else
		eval += 10;
f01113c8:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f01113cc:	c7 45 e0 d2 86 12 f0 	movl   $0xf01286d2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f01113d3:	83 ec 08             	sub    $0x8,%esp
f01113d6:	ff 75 e0             	pushl  -0x20(%ebp)
f01113d9:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01113df:	50                   	push   %eax
f01113e0:	e8 dd e7 00 00       	call   f011fbc2 <str2lower>
f01113e5:	83 c4 10             	add    $0x10,%esp
f01113e8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01113eb:	83 ec 0c             	sub    $0xc,%esp
f01113ee:	ff 75 e8             	pushl  -0x18(%ebp)
f01113f1:	e8 e3 e0 00 00       	call   f011f4d9 <strlen>
f01113f6:	83 c4 10             	add    $0x10,%esp
f01113f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f01113fc:	83 ec 08             	sub    $0x8,%esp
f01113ff:	68 d2 86 12 f0       	push   $0xf01286d2
f0111404:	ff 75 e8             	pushl  -0x18(%ebp)
f0111407:	e8 d9 e1 00 00       	call   f011f5e5 <strcmp>
f011140c:	83 c4 10             	add    $0x10,%esp
f011140f:	85 c0                	test   %eax,%eax
f0111411:	75 13                	jne    f0111426 <test_str2lower_function+0x104>
f0111413:	83 ec 0c             	sub    $0xc,%esp
f0111416:	ff 75 e0             	pushl  -0x20(%ebp)
f0111419:	e8 bb e0 00 00       	call   f011f4d9 <strlen>
f011141e:	83 c4 10             	add    $0x10,%esp
f0111421:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111424:	74 15                	je     f011143b <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111426:	83 ec 08             	sub    $0x8,%esp
f0111429:	ff 75 e8             	pushl  -0x18(%ebp)
f011142c:	68 d4 86 12 f0       	push   $0xf01286d4
f0111431:	e8 55 fb fe ff       	call   f0100f8b <cprintf>
f0111436:	83 c4 10             	add    $0x10,%esp
f0111439:	eb 04                	jmp    f011143f <test_str2lower_function+0x11d>
	else
		eval += 10;
f011143b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f011143f:	c7 45 dc 2c 87 12 f0 	movl   $0xf012872c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111446:	83 ec 08             	sub    $0x8,%esp
f0111449:	ff 75 dc             	pushl  -0x24(%ebp)
f011144c:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111452:	50                   	push   %eax
f0111453:	e8 6a e7 00 00       	call   f011fbc2 <str2lower>
f0111458:	83 c4 10             	add    $0x10,%esp
f011145b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011145e:	83 ec 0c             	sub    $0xc,%esp
f0111461:	ff 75 e8             	pushl  -0x18(%ebp)
f0111464:	e8 70 e0 00 00       	call   f011f4d9 <strlen>
f0111469:	83 c4 10             	add    $0x10,%esp
f011146c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f011146f:	83 ec 08             	sub    $0x8,%esp
f0111472:	68 2c 87 12 f0       	push   $0xf012872c
f0111477:	ff 75 e8             	pushl  -0x18(%ebp)
f011147a:	e8 66 e1 00 00       	call   f011f5e5 <strcmp>
f011147f:	83 c4 10             	add    $0x10,%esp
f0111482:	85 c0                	test   %eax,%eax
f0111484:	75 13                	jne    f0111499 <test_str2lower_function+0x177>
f0111486:	83 ec 0c             	sub    $0xc,%esp
f0111489:	ff 75 dc             	pushl  -0x24(%ebp)
f011148c:	e8 48 e0 00 00       	call   f011f4d9 <strlen>
f0111491:	83 c4 10             	add    $0x10,%esp
f0111494:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111497:	74 15                	je     f01114ae <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111499:	83 ec 08             	sub    $0x8,%esp
f011149c:	ff 75 e8             	pushl  -0x18(%ebp)
f011149f:	68 38 87 12 f0       	push   $0xf0128738
f01114a4:	e8 e2 fa fe ff       	call   f0100f8b <cprintf>
f01114a9:	83 c4 10             	add    $0x10,%esp
f01114ac:	eb 04                	jmp    f01114b2 <test_str2lower_function+0x190>
	else
		eval += 15;
f01114ae:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f01114b2:	c7 45 d8 9b 87 12 f0 	movl   $0xf012879b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f01114b9:	83 ec 08             	sub    $0x8,%esp
f01114bc:	ff 75 d8             	pushl  -0x28(%ebp)
f01114bf:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f01114c5:	50                   	push   %eax
f01114c6:	e8 f7 e6 00 00       	call   f011fbc2 <str2lower>
f01114cb:	83 c4 10             	add    $0x10,%esp
f01114ce:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01114d1:	83 ec 0c             	sub    $0xc,%esp
f01114d4:	ff 75 e8             	pushl  -0x18(%ebp)
f01114d7:	e8 fd df 00 00       	call   f011f4d9 <strlen>
f01114dc:	83 c4 10             	add    $0x10,%esp
f01114df:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f01114e2:	83 ec 08             	sub    $0x8,%esp
f01114e5:	68 9b 87 12 f0       	push   $0xf012879b
f01114ea:	ff 75 e8             	pushl  -0x18(%ebp)
f01114ed:	e8 f3 e0 00 00       	call   f011f5e5 <strcmp>
f01114f2:	83 c4 10             	add    $0x10,%esp
f01114f5:	85 c0                	test   %eax,%eax
f01114f7:	75 13                	jne    f011150c <test_str2lower_function+0x1ea>
f01114f9:	83 ec 0c             	sub    $0xc,%esp
f01114fc:	ff 75 d8             	pushl  -0x28(%ebp)
f01114ff:	e8 d5 df 00 00       	call   f011f4d9 <strlen>
f0111504:	83 c4 10             	add    $0x10,%esp
f0111507:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011150a:	74 15                	je     f0111521 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f011150c:	83 ec 08             	sub    $0x8,%esp
f011150f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111512:	68 a8 87 12 f0       	push   $0xf01287a8
f0111517:	e8 6f fa fe ff       	call   f0100f8b <cprintf>
f011151c:	83 c4 10             	add    $0x10,%esp
f011151f:	eb 04                	jmp    f0111525 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111521:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111525:	c7 45 d4 0a 88 12 f0 	movl   $0xf012880a,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f011152c:	83 ec 08             	sub    $0x8,%esp
f011152f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111532:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111538:	50                   	push   %eax
f0111539:	e8 84 e6 00 00       	call   f011fbc2 <str2lower>
f011153e:	83 c4 10             	add    $0x10,%esp
f0111541:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111544:	83 ec 0c             	sub    $0xc,%esp
f0111547:	ff 75 e8             	pushl  -0x18(%ebp)
f011154a:	e8 8a df 00 00       	call   f011f4d9 <strlen>
f011154f:	83 c4 10             	add    $0x10,%esp
f0111552:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111555:	83 ec 08             	sub    $0x8,%esp
f0111558:	68 20 88 12 f0       	push   $0xf0128820
f011155d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111560:	e8 80 e0 00 00       	call   f011f5e5 <strcmp>
f0111565:	83 c4 10             	add    $0x10,%esp
f0111568:	85 c0                	test   %eax,%eax
f011156a:	75 13                	jne    f011157f <test_str2lower_function+0x25d>
f011156c:	83 ec 0c             	sub    $0xc,%esp
f011156f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111572:	e8 62 df 00 00       	call   f011f4d9 <strlen>
f0111577:	83 c4 10             	add    $0x10,%esp
f011157a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011157d:	74 15                	je     f0111594 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f011157f:	83 ec 08             	sub    $0x8,%esp
f0111582:	ff 75 e8             	pushl  -0x18(%ebp)
f0111585:	68 38 88 12 f0       	push   $0xf0128838
f011158a:	e8 fc f9 fe ff       	call   f0100f8b <cprintf>
f011158f:	83 c4 10             	add    $0x10,%esp
f0111592:	eb 04                	jmp    f0111598 <test_str2lower_function+0x276>
	else
		eval += 15;
f0111594:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111598:	c7 45 d0 a5 88 12 f0 	movl   $0xf01288a5,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f011159f:	83 ec 08             	sub    $0x8,%esp
f01115a2:	ff 75 d0             	pushl  -0x30(%ebp)
f01115a5:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f01115ab:	50                   	push   %eax
f01115ac:	e8 11 e6 00 00       	call   f011fbc2 <str2lower>
f01115b1:	83 c4 10             	add    $0x10,%esp
f01115b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01115b7:	83 ec 0c             	sub    $0xc,%esp
f01115ba:	ff 75 e8             	pushl  -0x18(%ebp)
f01115bd:	e8 17 df 00 00       	call   f011f4d9 <strlen>
f01115c2:	83 c4 10             	add    $0x10,%esp
f01115c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f01115c8:	83 ec 08             	sub    $0x8,%esp
f01115cb:	68 b1 88 12 f0       	push   $0xf01288b1
f01115d0:	ff 75 e8             	pushl  -0x18(%ebp)
f01115d3:	e8 0d e0 00 00       	call   f011f5e5 <strcmp>
f01115d8:	83 c4 10             	add    $0x10,%esp
f01115db:	85 c0                	test   %eax,%eax
f01115dd:	75 13                	jne    f01115f2 <test_str2lower_function+0x2d0>
f01115df:	83 ec 0c             	sub    $0xc,%esp
f01115e2:	ff 75 d0             	pushl  -0x30(%ebp)
f01115e5:	e8 ef de 00 00       	call   f011f4d9 <strlen>
f01115ea:	83 c4 10             	add    $0x10,%esp
f01115ed:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01115f0:	74 15                	je     f0111607 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f01115f2:	83 ec 08             	sub    $0x8,%esp
f01115f5:	ff 75 e8             	pushl  -0x18(%ebp)
f01115f8:	68 c0 88 12 f0       	push   $0xf01288c0
f01115fd:	e8 89 f9 fe ff       	call   f0100f8b <cprintf>
f0111602:	83 c4 10             	add    $0x10,%esp
f0111605:	eb 04                	jmp    f011160b <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111607:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f011160b:	c7 45 cc 23 89 12 f0 	movl   $0xf0128923,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111612:	83 ec 08             	sub    $0x8,%esp
f0111615:	ff 75 cc             	pushl  -0x34(%ebp)
f0111618:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f011161e:	50                   	push   %eax
f011161f:	e8 9e e5 00 00       	call   f011fbc2 <str2lower>
f0111624:	83 c4 10             	add    $0x10,%esp
f0111627:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011162a:	83 ec 0c             	sub    $0xc,%esp
f011162d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111630:	e8 a4 de 00 00       	call   f011f4d9 <strlen>
f0111635:	83 c4 10             	add    $0x10,%esp
f0111638:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f011163b:	83 ec 08             	sub    $0x8,%esp
f011163e:	68 3e 89 12 f0       	push   $0xf012893e
f0111643:	ff 75 e8             	pushl  -0x18(%ebp)
f0111646:	e8 9a df 00 00       	call   f011f5e5 <strcmp>
f011164b:	83 c4 10             	add    $0x10,%esp
f011164e:	85 c0                	test   %eax,%eax
f0111650:	75 13                	jne    f0111665 <test_str2lower_function+0x343>
f0111652:	83 ec 0c             	sub    $0xc,%esp
f0111655:	ff 75 cc             	pushl  -0x34(%ebp)
f0111658:	e8 7c de 00 00       	call   f011f4d9 <strlen>
f011165d:	83 c4 10             	add    $0x10,%esp
f0111660:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111663:	74 15                	je     f011167a <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111665:	83 ec 08             	sub    $0x8,%esp
f0111668:	ff 75 e8             	pushl  -0x18(%ebp)
f011166b:	68 5c 89 12 f0       	push   $0xf012895c
f0111670:	e8 16 f9 fe ff       	call   f0100f8b <cprintf>
f0111675:	83 c4 10             	add    $0x10,%esp
f0111678:	eb 04                	jmp    f011167e <test_str2lower_function+0x35c>
	else
		eval += 20;
f011167a:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f011167e:	83 ec 08             	sub    $0x8,%esp
f0111681:	ff 75 f4             	pushl  -0xc(%ebp)
f0111684:	68 d0 89 12 f0       	push   $0xf01289d0
f0111689:	e8 fd f8 fe ff       	call   f0100f8b <cprintf>
f011168e:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111691:	83 ec 0c             	sub    $0xc,%esp
f0111694:	68 e0 84 12 f0       	push   $0xf01284e0
f0111699:	e8 ed f8 fe ff       	call   f0100f8b <cprintf>
f011169e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01116a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01116a6:	c9                   	leave  
f01116a7:	c3                   	ret    

f01116a8 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f01116a8:	55                   	push   %ebp
f01116a9:	89 e5                	mov    %esp,%ebp
f01116ab:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f01116ae:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f01116b5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f01116bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01116c3:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01116c8:	ff 75 ec             	pushl  -0x14(%ebp)
f01116cb:	ff 75 f0             	pushl  -0x10(%ebp)
f01116ce:	ff 75 f4             	pushl  -0xc(%ebp)
f01116d1:	50                   	push   %eax
f01116d2:	e8 f3 7d ff ff       	call   f01094ca <pt_set_page_permissions>
f01116d7:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01116da:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01116df:	ff 75 ec             	pushl  -0x14(%ebp)
f01116e2:	ff 75 f0             	pushl  -0x10(%ebp)
f01116e5:	ff 75 f4             	pushl  -0xc(%ebp)
f01116e8:	50                   	push   %eax
f01116e9:	e8 74 4b 00 00       	call   f0116262 <CP>
f01116ee:	83 c4 10             	add    $0x10,%esp
f01116f1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01116f4:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01116f8:	74 17                	je     f0111711 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f01116fa:	83 ec 04             	sub    $0x4,%esp
f01116fd:	68 00 8a 12 f0       	push   $0xf0128a00
f0111702:	68 23 01 00 00       	push   $0x123
f0111707:	68 22 8a 12 f0       	push   $0xf0128a22
f011170c:	e8 28 ec fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0111711:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0111718:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f011171f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111726:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011172b:	ff 75 ec             	pushl  -0x14(%ebp)
f011172e:	ff 75 f0             	pushl  -0x10(%ebp)
f0111731:	ff 75 f4             	pushl  -0xc(%ebp)
f0111734:	50                   	push   %eax
f0111735:	e8 90 7d ff ff       	call   f01094ca <pt_set_page_permissions>
f011173a:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011173d:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111742:	ff 75 ec             	pushl  -0x14(%ebp)
f0111745:	ff 75 f0             	pushl  -0x10(%ebp)
f0111748:	ff 75 f4             	pushl  -0xc(%ebp)
f011174b:	50                   	push   %eax
f011174c:	e8 11 4b 00 00       	call   f0116262 <CP>
f0111751:	83 c4 10             	add    $0x10,%esp
f0111754:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111757:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011175b:	74 17                	je     f0111774 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f011175d:	83 ec 04             	sub    $0x4,%esp
f0111760:	68 40 8a 12 f0       	push   $0xf0128a40
f0111765:	68 2f 01 00 00       	push   $0x12f
f011176a:	68 22 8a 12 f0       	push   $0xf0128a22
f011176f:	e8 c5 eb fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0111774:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f011177b:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0111782:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111789:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011178e:	ff 75 ec             	pushl  -0x14(%ebp)
f0111791:	ff 75 f0             	pushl  -0x10(%ebp)
f0111794:	ff 75 f4             	pushl  -0xc(%ebp)
f0111797:	50                   	push   %eax
f0111798:	e8 2d 7d ff ff       	call   f01094ca <pt_set_page_permissions>
f011179d:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01117a0:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01117a5:	ff 75 ec             	pushl  -0x14(%ebp)
f01117a8:	ff 75 f0             	pushl  -0x10(%ebp)
f01117ab:	ff 75 f4             	pushl  -0xc(%ebp)
f01117ae:	50                   	push   %eax
f01117af:	e8 ae 4a 00 00       	call   f0116262 <CP>
f01117b4:	83 c4 10             	add    $0x10,%esp
f01117b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01117ba:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01117be:	74 17                	je     f01117d7 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f01117c0:	83 ec 04             	sub    $0x4,%esp
f01117c3:	68 64 8a 12 f0       	push   $0xf0128a64
f01117c8:	68 3a 01 00 00       	push   $0x13a
f01117cd:	68 22 8a 12 f0       	push   $0xf0128a22
f01117d2:	e8 62 eb fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f01117d7:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f01117de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f01117e5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01117ec:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01117f1:	ff 75 ec             	pushl  -0x14(%ebp)
f01117f4:	ff 75 f0             	pushl  -0x10(%ebp)
f01117f7:	ff 75 f4             	pushl  -0xc(%ebp)
f01117fa:	50                   	push   %eax
f01117fb:	e8 ca 7c ff ff       	call   f01094ca <pt_set_page_permissions>
f0111800:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111803:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111808:	ff 75 ec             	pushl  -0x14(%ebp)
f011180b:	ff 75 f0             	pushl  -0x10(%ebp)
f011180e:	ff 75 f4             	pushl  -0xc(%ebp)
f0111811:	50                   	push   %eax
f0111812:	e8 4b 4a 00 00       	call   f0116262 <CP>
f0111817:	83 c4 10             	add    $0x10,%esp
f011181a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011181d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111821:	74 17                	je     f011183a <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0111823:	83 ec 04             	sub    $0x4,%esp
f0111826:	68 88 8a 12 f0       	push   $0xf0128a88
f011182b:	68 46 01 00 00       	push   $0x146
f0111830:	68 22 8a 12 f0       	push   $0xf0128a22
f0111835:	e8 ff ea fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f011183a:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0111841:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0111848:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011184f:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111854:	ff 75 ec             	pushl  -0x14(%ebp)
f0111857:	ff 75 f0             	pushl  -0x10(%ebp)
f011185a:	ff 75 f4             	pushl  -0xc(%ebp)
f011185d:	50                   	push   %eax
f011185e:	e8 67 7c ff ff       	call   f01094ca <pt_set_page_permissions>
f0111863:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111866:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011186b:	ff 75 ec             	pushl  -0x14(%ebp)
f011186e:	ff 75 f0             	pushl  -0x10(%ebp)
f0111871:	ff 75 f4             	pushl  -0xc(%ebp)
f0111874:	50                   	push   %eax
f0111875:	e8 e8 49 00 00       	call   f0116262 <CP>
f011187a:	83 c4 10             	add    $0x10,%esp
f011187d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111880:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111884:	74 17                	je     f011189d <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0111886:	83 ec 04             	sub    $0x4,%esp
f0111889:	68 ac 8a 12 f0       	push   $0xf0128aac
f011188e:	68 52 01 00 00       	push   $0x152
f0111893:	68 22 8a 12 f0       	push   $0xf0128a22
f0111898:	e8 9c ea fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f011189d:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f01118a4:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f01118ab:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01118b2:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01118b7:	ff 75 ec             	pushl  -0x14(%ebp)
f01118ba:	ff 75 f0             	pushl  -0x10(%ebp)
f01118bd:	ff 75 f4             	pushl  -0xc(%ebp)
f01118c0:	50                   	push   %eax
f01118c1:	e8 04 7c ff ff       	call   f01094ca <pt_set_page_permissions>
f01118c6:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01118c9:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01118ce:	ff 75 ec             	pushl  -0x14(%ebp)
f01118d1:	ff 75 f0             	pushl  -0x10(%ebp)
f01118d4:	ff 75 f4             	pushl  -0xc(%ebp)
f01118d7:	50                   	push   %eax
f01118d8:	e8 85 49 00 00       	call   f0116262 <CP>
f01118dd:	83 c4 10             	add    $0x10,%esp
f01118e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01118e3:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01118e7:	74 17                	je     f0111900 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f01118e9:	83 ec 04             	sub    $0x4,%esp
f01118ec:	68 d0 8a 12 f0       	push   $0xf0128ad0
f01118f1:	68 5e 01 00 00       	push   $0x15e
f01118f6:	68 22 8a 12 f0       	push   $0xf0128a22
f01118fb:	e8 39 ea fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0111900:	83 ec 0c             	sub    $0xc,%esp
f0111903:	68 fc 8a 12 f0       	push   $0xf0128afc
f0111908:	e8 7e f6 fe ff       	call   f0100f8b <cprintf>
f011190d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111910:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111915:	c9                   	leave  
f0111916:	c3                   	ret    

f0111917 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0111917:	55                   	push   %ebp
f0111918:	89 e5                	mov    %esp,%ebp
f011191a:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f011191d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111924:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f011192b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111932:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111937:	ff 75 ec             	pushl  -0x14(%ebp)
f011193a:	ff 75 f0             	pushl  -0x10(%ebp)
f011193d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111940:	50                   	push   %eax
f0111941:	e8 84 7b ff ff       	call   f01094ca <pt_set_page_permissions>
f0111946:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0111949:	83 ec 04             	sub    $0x4,%esp
f011194c:	68 4c 8b 12 f0       	push   $0xf0128b4c
f0111951:	68 6b 01 00 00       	push   $0x16b
f0111956:	68 22 8a 12 f0       	push   $0xf0128a22
f011195b:	e8 d9 e9 fe ff       	call   f0100339 <_panic>

f0111960 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0111960:	55                   	push   %ebp
f0111961:	89 e5                	mov    %esp,%ebp
f0111963:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0111966:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f011196d:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111972:	83 ec 08             	sub    $0x8,%esp
f0111975:	ff 75 f4             	pushl  -0xc(%ebp)
f0111978:	50                   	push   %eax
f0111979:	e8 10 7c ff ff       	call   f010958e <pt_get_page_permissions>
f011197e:	83 c4 10             	add    $0x10,%esp
f0111981:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0111984:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0111988:	74 17                	je     f01119a1 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f011198a:	83 ec 04             	sub    $0x4,%esp
f011198d:	68 e8 8b 12 f0       	push   $0xf0128be8
f0111992:	68 79 01 00 00       	push   $0x179
f0111997:	68 22 8a 12 f0       	push   $0xf0128a22
f011199c:	e8 98 e9 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f01119a1:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01119a8:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01119ad:	83 ec 08             	sub    $0x8,%esp
f01119b0:	ff 75 f4             	pushl  -0xc(%ebp)
f01119b3:	50                   	push   %eax
f01119b4:	e8 d5 7b ff ff       	call   f010958e <pt_get_page_permissions>
f01119b9:	83 c4 10             	add    $0x10,%esp
f01119bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f01119bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01119c3:	74 17                	je     f01119dc <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f01119c5:	83 ec 04             	sub    $0x4,%esp
f01119c8:	68 0c 8c 12 f0       	push   $0xf0128c0c
f01119cd:	68 81 01 00 00       	push   $0x181
f01119d2:	68 22 8a 12 f0       	push   $0xf0128a22
f01119d7:	e8 5d e9 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f01119dc:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01119e3:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f01119e8:	83 ec 08             	sub    $0x8,%esp
f01119eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01119ee:	50                   	push   %eax
f01119ef:	e8 9a 7b ff ff       	call   f010958e <pt_get_page_permissions>
f01119f4:	83 c4 10             	add    $0x10,%esp
f01119f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f01119fa:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01119fe:	74 17                	je     f0111a17 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0111a00:	83 ec 04             	sub    $0x4,%esp
f0111a03:	68 30 8c 12 f0       	push   $0xf0128c30
f0111a08:	68 89 01 00 00       	push   $0x189
f0111a0d:	68 22 8a 12 f0       	push   $0xf0128a22
f0111a12:	e8 22 e9 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f0111a17:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111a1e:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111a23:	83 ec 08             	sub    $0x8,%esp
f0111a26:	ff 75 f4             	pushl  -0xc(%ebp)
f0111a29:	50                   	push   %eax
f0111a2a:	e8 5f 7b ff ff       	call   f010958e <pt_get_page_permissions>
f0111a2f:	83 c4 10             	add    $0x10,%esp
f0111a32:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0111a35:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111a39:	74 17                	je     f0111a52 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0111a3b:	83 ec 04             	sub    $0x4,%esp
f0111a3e:	68 54 8c 12 f0       	push   $0xf0128c54
f0111a43:	68 90 01 00 00       	push   $0x190
f0111a48:	68 22 8a 12 f0       	push   $0xf0128a22
f0111a4d:	e8 e7 e8 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0111a52:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111a59:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111a5e:	83 ec 08             	sub    $0x8,%esp
f0111a61:	ff 75 f4             	pushl  -0xc(%ebp)
f0111a64:	50                   	push   %eax
f0111a65:	e8 24 7b ff ff       	call   f010958e <pt_get_page_permissions>
f0111a6a:	83 c4 10             	add    $0x10,%esp
f0111a6d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0111a70:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0111a74:	74 17                	je     f0111a8d <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0111a76:	83 ec 04             	sub    $0x4,%esp
f0111a79:	68 78 8c 12 f0       	push   $0xf0128c78
f0111a7e:	68 97 01 00 00       	push   $0x197
f0111a83:	68 22 8a 12 f0       	push   $0xf0128a22
f0111a88:	e8 ac e8 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0111a8d:	83 ec 0c             	sub    $0xc,%esp
f0111a90:	68 9c 8c 12 f0       	push   $0xf0128c9c
f0111a95:	e8 f1 f4 fe ff       	call   f0100f8b <cprintf>
f0111a9a:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111a9d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111aa2:	c9                   	leave  
f0111aa3:	c3                   	ret    

f0111aa4 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0111aa4:	55                   	push   %ebp
f0111aa5:	89 e5                	mov    %esp,%ebp
f0111aa7:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0111aaa:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111ab1:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111ab6:	83 ec 08             	sub    $0x8,%esp
f0111ab9:	ff 75 f4             	pushl  -0xc(%ebp)
f0111abc:	50                   	push   %eax
f0111abd:	e8 15 7b ff ff       	call   f01095d7 <pt_clear_page_table_entry>
f0111ac2:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0111ac5:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111aca:	83 ec 08             	sub    $0x8,%esp
f0111acd:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ad0:	50                   	push   %eax
f0111ad1:	e8 e8 46 00 00       	call   f01161be <CE>
f0111ad6:	83 c4 10             	add    $0x10,%esp
f0111ad9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111adc:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111ae0:	74 17                	je     f0111af9 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0111ae2:	83 ec 04             	sub    $0x4,%esp
f0111ae5:	68 e4 8c 12 f0       	push   $0xf0128ce4
f0111aea:	68 a7 01 00 00       	push   $0x1a7
f0111aef:	68 22 8a 12 f0       	push   $0xf0128a22
f0111af4:	e8 40 e8 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0111af9:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111b00:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111b05:	83 ec 08             	sub    $0x8,%esp
f0111b08:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b0b:	50                   	push   %eax
f0111b0c:	e8 c6 7a ff ff       	call   f01095d7 <pt_clear_page_table_entry>
f0111b11:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111b14:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111b19:	83 ec 08             	sub    $0x8,%esp
f0111b1c:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b1f:	50                   	push   %eax
f0111b20:	e8 99 46 00 00       	call   f01161be <CE>
f0111b25:	83 c4 10             	add    $0x10,%esp
f0111b28:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111b2b:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111b2f:	74 17                	je     f0111b48 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0111b31:	83 ec 04             	sub    $0x4,%esp
f0111b34:	68 10 8d 12 f0       	push   $0xf0128d10
f0111b39:	68 af 01 00 00       	push   $0x1af
f0111b3e:	68 22 8a 12 f0       	push   $0xf0128a22
f0111b43:	e8 f1 e7 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0111b48:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111b4f:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111b54:	83 ec 08             	sub    $0x8,%esp
f0111b57:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b5a:	50                   	push   %eax
f0111b5b:	e8 77 7a ff ff       	call   f01095d7 <pt_clear_page_table_entry>
f0111b60:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111b63:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111b68:	83 ec 08             	sub    $0x8,%esp
f0111b6b:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b6e:	50                   	push   %eax
f0111b6f:	e8 4a 46 00 00       	call   f01161be <CE>
f0111b74:	83 c4 10             	add    $0x10,%esp
f0111b77:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111b7a:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111b7e:	74 17                	je     f0111b97 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0111b80:	83 ec 04             	sub    $0x4,%esp
f0111b83:	68 3c 8d 12 f0       	push   $0xf0128d3c
f0111b88:	68 b7 01 00 00       	push   $0x1b7
f0111b8d:	68 22 8a 12 f0       	push   $0xf0128a22
f0111b92:	e8 a2 e7 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f0111b97:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111b9e:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111ba3:	83 ec 08             	sub    $0x8,%esp
f0111ba6:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ba9:	50                   	push   %eax
f0111baa:	e8 28 7a ff ff       	call   f01095d7 <pt_clear_page_table_entry>
f0111baf:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111bb2:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111bb7:	83 ec 08             	sub    $0x8,%esp
f0111bba:	ff 75 f4             	pushl  -0xc(%ebp)
f0111bbd:	50                   	push   %eax
f0111bbe:	e8 fb 45 00 00       	call   f01161be <CE>
f0111bc3:	83 c4 10             	add    $0x10,%esp
f0111bc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111bc9:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111bcd:	74 17                	je     f0111be6 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0111bcf:	83 ec 04             	sub    $0x4,%esp
f0111bd2:	68 68 8d 12 f0       	push   $0xf0128d68
f0111bd7:	68 bf 01 00 00       	push   $0x1bf
f0111bdc:	68 22 8a 12 f0       	push   $0xf0128a22
f0111be1:	e8 53 e7 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0111be6:	83 ec 0c             	sub    $0xc,%esp
f0111be9:	68 94 8d 12 f0       	push   $0xf0128d94
f0111bee:	e8 98 f3 fe ff       	call   f0100f8b <cprintf>
f0111bf3:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111bf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111bfb:	c9                   	leave  
f0111bfc:	c3                   	ret    

f0111bfd <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0111bfd:	55                   	push   %ebp
f0111bfe:	89 e5                	mov    %esp,%ebp
f0111c00:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0111c03:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111c0a:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f0111c0f:	83 ec 08             	sub    $0x8,%esp
f0111c12:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c15:	50                   	push   %eax
f0111c16:	e8 bc 79 ff ff       	call   f01095d7 <pt_clear_page_table_entry>
f0111c1b:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0111c1e:	83 ec 04             	sub    $0x4,%esp
f0111c21:	68 e0 8d 12 f0       	push   $0xf0128de0
f0111c26:	68 ca 01 00 00       	push   $0x1ca
f0111c2b:	68 22 8a 12 f0       	push   $0xf0128a22
f0111c30:	e8 04 e7 fe ff       	call   f0100339 <_panic>

f0111c35 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0111c35:	55                   	push   %ebp
f0111c36:	89 e5                	mov    %esp,%ebp
f0111c38:	57                   	push   %edi
f0111c39:	56                   	push   %esi
f0111c3a:	53                   	push   %ebx
f0111c3b:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0111c41:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0111c47:	bb 24 91 12 f0       	mov    $0xf0129124,%ebx
f0111c4c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111c51:	89 c7                	mov    %eax,%edi
f0111c53:	89 de                	mov    %ebx,%esi
f0111c55:	89 d1                	mov    %edx,%ecx
f0111c57:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111c59:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0111c5f:	b9 23 00 00 00       	mov    $0x23,%ecx
f0111c64:	b0 00                	mov    $0x0,%al
f0111c66:	89 d7                	mov    %edx,%edi
f0111c68:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0111c6a:	6a 00                	push   $0x0
f0111c6c:	6a 0a                	push   $0xa
f0111c6e:	6a 14                	push   $0x14
f0111c70:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0111c76:	50                   	push   %eax
f0111c77:	e8 90 8b ff ff       	call   f010a80c <env_create>
f0111c7c:	83 c4 10             	add    $0x10,%esp
f0111c7f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0111c82:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111c85:	8b 40 64             	mov    0x64(%eax),%eax
f0111c88:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0111c8b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111c8e:	8b 40 68             	mov    0x68(%eax),%eax
f0111c91:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0111c94:	8b 45 90             	mov    -0x70(%ebp),%eax
f0111c97:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0111c9a:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0111ca1:	75 70 20 
f0111ca4:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0111cab:	00 00 00 
f0111cae:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0111cb4:	b9 03 00 00 00       	mov    $0x3,%ecx
f0111cb9:	b8 00 00 00 00       	mov    $0x0,%eax
f0111cbe:	89 d7                	mov    %edx,%edi
f0111cc0:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0111cc2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111cc5:	8b 40 10             	mov    0x10(%eax),%eax
f0111cc8:	83 ec 08             	sub    $0x8,%esp
f0111ccb:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0111cd1:	52                   	push   %edx
f0111cd2:	50                   	push   %eax
f0111cd3:	e8 a7 dc 00 00       	call   f011f97f <ltostr>
f0111cd8:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0111cdb:	83 ec 04             	sub    $0x4,%esp
f0111cde:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111ce4:	50                   	push   %eax
f0111ce5:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0111ceb:	50                   	push   %eax
f0111cec:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0111cf2:	50                   	push   %eax
f0111cf3:	e8 60 dd 00 00       	call   f011fa58 <strcconcat>
f0111cf8:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0111cfb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0111d02:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0111d09:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0111d10:	83 ec 0c             	sub    $0xc,%esp
f0111d13:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111d16:	e8 85 45 00 00       	call   f01162a0 <ClearUserSpace>
f0111d1b:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0111d1e:	83 ec 04             	sub    $0x4,%esp
f0111d21:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0111d27:	50                   	push   %eax
f0111d28:	68 76 8e 12 f0       	push   $0xf0128e76
f0111d2d:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111d33:	50                   	push   %eax
f0111d34:	e8 1f dd 00 00       	call   f011fa58 <strcconcat>
f0111d39:	83 c4 10             	add    $0x10,%esp
f0111d3c:	83 ec 0c             	sub    $0xc,%esp
f0111d3f:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0111d45:	50                   	push   %eax
f0111d46:	e8 b0 01 ff ff       	call   f0101efb <execute_command>
f0111d4b:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f0111d4e:	83 ec 04             	sub    $0x4,%esp
f0111d51:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0111d57:	50                   	push   %eax
f0111d58:	68 81 8e 12 f0       	push   $0xf0128e81
f0111d5d:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111d63:	50                   	push   %eax
f0111d64:	e8 ef dc 00 00       	call   f011fa58 <strcconcat>
f0111d69:	83 c4 10             	add    $0x10,%esp
f0111d6c:	83 ec 0c             	sub    $0xc,%esp
f0111d6f:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0111d75:	50                   	push   %eax
f0111d76:	e8 80 01 ff ff       	call   f0101efb <execute_command>
f0111d7b:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0111d7e:	83 ec 04             	sub    $0x4,%esp
f0111d81:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0111d87:	50                   	push   %eax
f0111d88:	68 8c 8e 12 f0       	push   $0xf0128e8c
f0111d8d:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111d93:	50                   	push   %eax
f0111d94:	e8 bf dc 00 00       	call   f011fa58 <strcconcat>
f0111d99:	83 c4 10             	add    $0x10,%esp
f0111d9c:	83 ec 0c             	sub    $0xc,%esp
f0111d9f:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0111da5:	50                   	push   %eax
f0111da6:	e8 50 01 ff ff       	call   f0101efb <execute_command>
f0111dab:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0111dae:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0111db5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111db8:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0111dbb:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0111dc2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111dc5:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0111dc8:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0111dcf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111dd2:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0111dd5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111dd8:	83 ec 08             	sub    $0x8,%esp
f0111ddb:	50                   	push   %eax
f0111ddc:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111ddf:	e8 9d 44 00 00       	call   f0116281 <GP>
f0111de4:	83 c4 10             	add    $0x10,%esp
f0111de7:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0111dea:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0111df1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0111df8:	e8 af c3 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0111dfd:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0111e00:	83 ec 0c             	sub    $0xc,%esp
f0111e03:	68 98 8e 12 f0       	push   $0xf0128e98
f0111e08:	e8 7e f1 fe ff       	call   f0100f8b <cprintf>
f0111e0d:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0111e10:	6a 03                	push   $0x3
f0111e12:	68 00 00 90 02       	push   $0x2900000
f0111e17:	68 00 00 80 02       	push   $0x2800000
f0111e1c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111e1f:	e8 27 85 ff ff       	call   f010a34b <cut_paste_pages>
f0111e24:	83 c4 10             	add    $0x10,%esp
f0111e27:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0111e2a:	e8 7d c3 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0111e2f:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0111e32:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0111e39:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0111e3d:	75 08                	jne    f0111e47 <test_cut_paste_pages+0x212>
f0111e3f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111e42:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0111e45:	74 2b                	je     f0111e72 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0111e47:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111e4a:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111e4d:	83 ec 0c             	sub    $0xc,%esp
f0111e50:	50                   	push   %eax
f0111e51:	ff 75 b4             	pushl  -0x4c(%ebp)
f0111e54:	68 c8 8e 12 f0       	push   $0xf0128ec8
f0111e59:	68 04 02 00 00       	push   $0x204
f0111e5e:	68 22 8a 12 f0       	push   $0xf0128a22
f0111e63:	e8 6e e6 fe ff       	call   f01004d6 <_warn>
f0111e68:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0111e6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0111e72:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111e76:	74 04                	je     f0111e7c <test_cut_paste_pages+0x247>
f0111e78:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0111e7c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0111e83:	83 ec 08             	sub    $0x8,%esp
f0111e86:	6a 00                	push   $0x0
f0111e88:	6a 01                	push   $0x1
f0111e8a:	6a 00                	push   $0x0
f0111e8c:	68 ff 0f 00 00       	push   $0xfff
f0111e91:	ff 75 bc             	pushl  -0x44(%ebp)
f0111e94:	6a 01                	push   $0x1
f0111e96:	68 00 30 00 00       	push   $0x3000
f0111e9b:	68 00 00 90 02       	push   $0x2900000
f0111ea0:	68 00 00 80 02       	push   $0x2800000
f0111ea5:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111ea8:	e8 27 44 00 00       	call   f01162d4 <CCP>
f0111ead:	83 c4 30             	add    $0x30,%esp
f0111eb0:	83 f8 01             	cmp    $0x1,%eax
f0111eb3:	74 21                	je     f0111ed6 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0111eb5:	83 ec 04             	sub    $0x4,%esp
f0111eb8:	68 1c 8f 12 f0       	push   $0xf0128f1c
f0111ebd:	68 0c 02 00 00       	push   $0x20c
f0111ec2:	68 22 8a 12 f0       	push   $0xf0128a22
f0111ec7:	e8 0a e6 fe ff       	call   f01004d6 <_warn>
f0111ecc:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111ecf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0111ed6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111eda:	74 04                	je     f0111ee0 <test_cut_paste_pages+0x2ab>
f0111edc:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0111ee0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0111ee7:	83 ec 04             	sub    $0x4,%esp
f0111eea:	6a 00                	push   $0x0
f0111eec:	68 00 00 90 02       	push   $0x2900000
f0111ef1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111ef4:	e8 b7 41 00 00       	call   f01160b0 <CB>
f0111ef9:	83 c4 10             	add    $0x10,%esp
f0111efc:	85 c0                	test   %eax,%eax
f0111efe:	0f 84 f6 00 00 00    	je     f0111ffa <test_cut_paste_pages+0x3c5>
f0111f04:	83 ec 04             	sub    $0x4,%esp
f0111f07:	6a 00                	push   $0x0
f0111f09:	68 00 10 90 02       	push   $0x2901000
f0111f0e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111f11:	e8 9a 41 00 00       	call   f01160b0 <CB>
f0111f16:	83 c4 10             	add    $0x10,%esp
f0111f19:	85 c0                	test   %eax,%eax
f0111f1b:	0f 84 d9 00 00 00    	je     f0111ffa <test_cut_paste_pages+0x3c5>
f0111f21:	83 ec 04             	sub    $0x4,%esp
f0111f24:	6a 00                	push   $0x0
f0111f26:	68 00 20 90 02       	push   $0x2902000
f0111f2b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111f2e:	e8 7d 41 00 00       	call   f01160b0 <CB>
f0111f33:	83 c4 10             	add    $0x10,%esp
f0111f36:	85 c0                	test   %eax,%eax
f0111f38:	0f 84 bc 00 00 00    	je     f0111ffa <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f0111f3e:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0111f45:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0111f4c:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0111f53:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111f56:	8a 00                	mov    (%eax),%al
f0111f58:	3c 61                	cmp    $0x61,%al
f0111f5a:	75 12                	jne    f0111f6e <test_cut_paste_pages+0x339>
f0111f5c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111f5f:	8a 00                	mov    (%eax),%al
f0111f61:	3c 62                	cmp    $0x62,%al
f0111f63:	75 09                	jne    f0111f6e <test_cut_paste_pages+0x339>
f0111f65:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111f68:	8a 00                	mov    (%eax),%al
f0111f6a:	3c 63                	cmp    $0x63,%al
f0111f6c:	74 21                	je     f0111f8f <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0111f6e:	83 ec 04             	sub    $0x4,%esp
f0111f71:	68 68 8f 12 f0       	push   $0xf0128f68
f0111f76:	68 19 02 00 00       	push   $0x219
f0111f7b:	68 22 8a 12 f0       	push   $0xf0128a22
f0111f80:	e8 51 e5 fe ff       	call   f01004d6 <_warn>
f0111f85:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0111f88:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0111f8f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111f93:	74 04                	je     f0111f99 <test_cut_paste_pages+0x364>
f0111f95:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0111f99:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0111fa0:	83 ec 04             	sub    $0x4,%esp
f0111fa3:	6a 01                	push   $0x1
f0111fa5:	68 00 10 90 02       	push   $0x2901000
f0111faa:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111fad:	e8 fe 40 00 00       	call   f01160b0 <CB>
f0111fb2:	83 c4 10             	add    $0x10,%esp
f0111fb5:	85 c0                	test   %eax,%eax
f0111fb7:	74 41                	je     f0111ffa <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0111fb9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111fbc:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0111fbf:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111fc2:	8a 00                	mov    (%eax),%al
f0111fc4:	3c 79                	cmp    $0x79,%al
f0111fc6:	74 21                	je     f0111fe9 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0111fc8:	83 ec 04             	sub    $0x4,%esp
f0111fcb:	68 68 8f 12 f0       	push   $0xf0128f68
f0111fd0:	68 24 02 00 00       	push   $0x224
f0111fd5:	68 22 8a 12 f0       	push   $0xf0128a22
f0111fda:	e8 f7 e4 fe ff       	call   f01004d6 <_warn>
f0111fdf:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0111fe2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0111fe9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111fed:	74 04                	je     f0111ff3 <test_cut_paste_pages+0x3be>
f0111fef:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0111ff3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0111ffa:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111ffd:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0112000:	6a 02                	push   $0x2
f0112002:	68 00 f0 bf 02       	push   $0x2bff000
f0112007:	68 00 10 90 02       	push   $0x2901000
f011200c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011200f:	e8 37 83 ff ff       	call   f010a34b <cut_paste_pages>
f0112014:	83 c4 10             	add    $0x10,%esp
f0112017:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f011201a:	e8 8d c1 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011201f:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112022:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112026:	75 0b                	jne    f0112033 <test_cut_paste_pages+0x3fe>
f0112028:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011202b:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011202e:	83 f8 01             	cmp    $0x1,%eax
f0112031:	74 2b                	je     f011205e <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112033:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112036:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112039:	83 ec 0c             	sub    $0xc,%esp
f011203c:	50                   	push   %eax
f011203d:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112040:	68 c8 8e 12 f0       	push   $0xf0128ec8
f0112045:	68 35 02 00 00       	push   $0x235
f011204a:	68 22 8a 12 f0       	push   $0xf0128a22
f011204f:	e8 82 e4 fe ff       	call   f01004d6 <_warn>
f0112054:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112057:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011205e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112062:	74 04                	je     f0112068 <test_cut_paste_pages+0x433>
f0112064:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112068:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011206f:	83 ec 08             	sub    $0x8,%esp
f0112072:	6a 00                	push   $0x0
f0112074:	6a 01                	push   $0x1
f0112076:	6a 00                	push   $0x0
f0112078:	68 ff 0f 00 00       	push   $0xfff
f011207d:	ff 75 bc             	pushl  -0x44(%ebp)
f0112080:	6a 01                	push   $0x1
f0112082:	68 00 20 00 00       	push   $0x2000
f0112087:	68 00 f0 bf 02       	push   $0x2bff000
f011208c:	68 00 10 90 02       	push   $0x2901000
f0112091:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112094:	e8 3b 42 00 00       	call   f01162d4 <CCP>
f0112099:	83 c4 30             	add    $0x30,%esp
f011209c:	83 f8 01             	cmp    $0x1,%eax
f011209f:	74 21                	je     f01120c2 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01120a1:	83 ec 04             	sub    $0x4,%esp
f01120a4:	68 1c 8f 12 f0       	push   $0xf0128f1c
f01120a9:	68 3d 02 00 00       	push   $0x23d
f01120ae:	68 22 8a 12 f0       	push   $0xf0128a22
f01120b3:	e8 1e e4 fe ff       	call   f01004d6 <_warn>
f01120b8:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01120bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01120c2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01120c6:	74 04                	je     f01120cc <test_cut_paste_pages+0x497>
f01120c8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01120cc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f01120d3:	83 ec 04             	sub    $0x4,%esp
f01120d6:	6a 00                	push   $0x0
f01120d8:	68 ff f7 bf 02       	push   $0x2bff7ff
f01120dd:	ff 75 d4             	pushl  -0x2c(%ebp)
f01120e0:	e8 cb 3f 00 00       	call   f01160b0 <CB>
f01120e5:	83 c4 10             	add    $0x10,%esp
f01120e8:	85 c0                	test   %eax,%eax
f01120ea:	74 6b                	je     f0112157 <test_cut_paste_pages+0x522>
f01120ec:	83 ec 04             	sub    $0x4,%esp
f01120ef:	6a 00                	push   $0x0
f01120f1:	68 ff 0f c0 02       	push   $0x2c00fff
f01120f6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01120f9:	e8 b2 3f 00 00       	call   f01160b0 <CB>
f01120fe:	83 c4 10             	add    $0x10,%esp
f0112101:	85 c0                	test   %eax,%eax
f0112103:	74 52                	je     f0112157 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112105:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f011210c:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112113:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112116:	8a 00                	mov    (%eax),%al
f0112118:	3c 79                	cmp    $0x79,%al
f011211a:	75 09                	jne    f0112125 <test_cut_paste_pages+0x4f0>
f011211c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011211f:	8a 00                	mov    (%eax),%al
f0112121:	3c 63                	cmp    $0x63,%al
f0112123:	74 21                	je     f0112146 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112125:	83 ec 04             	sub    $0x4,%esp
f0112128:	68 68 8f 12 f0       	push   $0xf0128f68
f011212d:	68 49 02 00 00       	push   $0x249
f0112132:	68 22 8a 12 f0       	push   $0xf0128a22
f0112137:	e8 9a e3 fe ff       	call   f01004d6 <_warn>
f011213c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011213f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112146:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011214a:	74 04                	je     f0112150 <test_cut_paste_pages+0x51b>
f011214c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112150:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112157:	83 ec 0c             	sub    $0xc,%esp
f011215a:	68 a1 8f 12 f0       	push   $0xf0128fa1
f011215f:	e8 27 ee fe ff       	call   f0100f8b <cprintf>
f0112164:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112167:	83 ec 0c             	sub    $0xc,%esp
f011216a:	68 b0 8f 12 f0       	push   $0xf0128fb0
f011216f:	e8 17 ee fe ff       	call   f0100f8b <cprintf>
f0112174:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112177:	83 ec 04             	sub    $0x4,%esp
f011217a:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112180:	50                   	push   %eax
f0112181:	68 d9 8f 12 f0       	push   $0xf0128fd9
f0112186:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011218c:	50                   	push   %eax
f011218d:	e8 c6 d8 00 00       	call   f011fa58 <strcconcat>
f0112192:	83 c4 10             	add    $0x10,%esp
f0112195:	83 ec 0c             	sub    $0xc,%esp
f0112198:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f011219e:	50                   	push   %eax
f011219f:	e8 57 fd fe ff       	call   f0101efb <execute_command>
f01121a4:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f01121a7:	83 ec 04             	sub    $0x4,%esp
f01121aa:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01121b0:	50                   	push   %eax
f01121b1:	68 e4 8f 12 f0       	push   $0xf0128fe4
f01121b6:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01121bc:	50                   	push   %eax
f01121bd:	e8 96 d8 00 00       	call   f011fa58 <strcconcat>
f01121c2:	83 c4 10             	add    $0x10,%esp
f01121c5:	83 ec 0c             	sub    $0xc,%esp
f01121c8:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01121ce:	50                   	push   %eax
f01121cf:	e8 27 fd fe ff       	call   f0101efb <execute_command>
f01121d4:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f01121d7:	83 ec 04             	sub    $0x4,%esp
f01121da:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01121e0:	50                   	push   %eax
f01121e1:	68 ef 8f 12 f0       	push   $0xf0128fef
f01121e6:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01121ec:	50                   	push   %eax
f01121ed:	e8 66 d8 00 00       	call   f011fa58 <strcconcat>
f01121f2:	83 c4 10             	add    $0x10,%esp
f01121f5:	83 ec 0c             	sub    $0xc,%esp
f01121f8:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01121fe:	50                   	push   %eax
f01121ff:	e8 f7 fc fe ff       	call   f0101efb <execute_command>
f0112204:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112207:	83 ec 04             	sub    $0x4,%esp
f011220a:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112210:	50                   	push   %eax
f0112211:	68 fa 8f 12 f0       	push   $0xf0128ffa
f0112216:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011221c:	50                   	push   %eax
f011221d:	e8 36 d8 00 00       	call   f011fa58 <strcconcat>
f0112222:	83 c4 10             	add    $0x10,%esp
f0112225:	83 ec 0c             	sub    $0xc,%esp
f0112228:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011222e:	50                   	push   %eax
f011222f:	e8 c7 fc fe ff       	call   f0101efb <execute_command>
f0112234:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112237:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f011223e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112241:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112244:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f011224b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011224e:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112251:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112258:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011225b:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f011225e:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112265:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112268:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f011226b:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112272:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112275:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112278:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f011227f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112282:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112285:	83 ec 08             	sub    $0x8,%esp
f0112288:	68 00 00 c0 01       	push   $0x1c00000
f011228d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112290:	e8 ec 3f 00 00       	call   f0116281 <GP>
f0112295:	83 c4 10             	add    $0x10,%esp
f0112298:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f011229b:	83 ec 08             	sub    $0x8,%esp
f011229e:	68 00 00 40 01       	push   $0x1400000
f01122a3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01122a6:	e8 d6 3f 00 00       	call   f0116281 <GP>
f01122ab:	83 c4 10             	add    $0x10,%esp
f01122ae:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f01122b1:	e8 f6 be ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01122b6:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f01122b9:	6a 01                	push   $0x1
f01122bb:	68 00 00 40 01       	push   $0x1400000
f01122c0:	68 00 00 c0 01       	push   $0x1c00000
f01122c5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01122c8:	e8 7e 80 ff ff       	call   f010a34b <cut_paste_pages>
f01122cd:	83 c4 10             	add    $0x10,%esp
f01122d0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01122d3:	e8 d4 be ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01122d8:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f01122db:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f01122df:	75 08                	jne    f01122e9 <test_cut_paste_pages+0x6b4>
f01122e1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01122e4:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01122e7:	74 2b                	je     f0112314 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f01122e9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01122ec:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01122ef:	83 ec 0c             	sub    $0xc,%esp
f01122f2:	50                   	push   %eax
f01122f3:	ff 75 b4             	pushl  -0x4c(%ebp)
f01122f6:	68 08 90 12 f0       	push   $0xf0129008
f01122fb:	68 6c 02 00 00       	push   $0x26c
f0112300:	68 22 8a 12 f0       	push   $0xf0128a22
f0112305:	e8 cc e1 fe ff       	call   f01004d6 <_warn>
f011230a:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f011230d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112314:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112318:	74 04                	je     f011231e <test_cut_paste_pages+0x6e9>
f011231a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011231e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112325:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f011232c:	83 ec 08             	sub    $0x8,%esp
f011232f:	6a 00                	push   $0x0
f0112331:	68 ff 0f 00 00       	push   $0xfff
f0112336:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112339:	68 ff 0f 00 00       	push   $0xfff
f011233e:	ff 75 a0             	pushl  -0x60(%ebp)
f0112341:	6a 01                	push   $0x1
f0112343:	68 00 10 00 00       	push   $0x1000
f0112348:	68 00 00 40 01       	push   $0x1400000
f011234d:	68 00 00 c0 01       	push   $0x1c00000
f0112352:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112355:	e8 7a 3f 00 00       	call   f01162d4 <CCP>
f011235a:	83 c4 30             	add    $0x30,%esp
f011235d:	83 f8 01             	cmp    $0x1,%eax
f0112360:	74 28                	je     f011238a <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112362:	83 ec 04             	sub    $0x4,%esp
f0112365:	68 1c 8f 12 f0       	push   $0xf0128f1c
f011236a:	68 75 02 00 00       	push   $0x275
f011236f:	68 22 8a 12 f0       	push   $0xf0128a22
f0112374:	e8 5d e1 fe ff       	call   f01004d6 <_warn>
f0112379:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011237c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112383:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f011238a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011238e:	74 04                	je     f0112394 <test_cut_paste_pages+0x75f>
f0112390:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112394:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f011239b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011239f:	0f 84 92 00 00 00    	je     f0112437 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f01123a5:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f01123ac:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01123b3:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01123ba:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f01123c1:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f01123c8:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01123cf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01123d2:	8a 00                	mov    (%eax),%al
f01123d4:	3c 61                	cmp    $0x61,%al
f01123d6:	75 2d                	jne    f0112405 <test_cut_paste_pages+0x7d0>
f01123d8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01123db:	8a 00                	mov    (%eax),%al
f01123dd:	3c 78                	cmp    $0x78,%al
f01123df:	75 24                	jne    f0112405 <test_cut_paste_pages+0x7d0>
f01123e1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01123e4:	8a 00                	mov    (%eax),%al
f01123e6:	3c 62                	cmp    $0x62,%al
f01123e8:	75 1b                	jne    f0112405 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01123ea:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01123ed:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01123ef:	3c 79                	cmp    $0x79,%al
f01123f1:	75 12                	jne    f0112405 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01123f3:	8b 45 98             	mov    -0x68(%ebp),%eax
f01123f6:	8a 00                	mov    (%eax),%al
f01123f8:	3c 63                	cmp    $0x63,%al
f01123fa:	75 09                	jne    f0112405 <test_cut_paste_pages+0x7d0>
f01123fc:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01123ff:	8a 00                	mov    (%eax),%al
f0112401:	3c 7a                	cmp    $0x7a,%al
f0112403:	74 21                	je     f0112426 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112405:	83 ec 04             	sub    $0x4,%esp
f0112408:	68 68 8f 12 f0       	push   $0xf0128f68
f011240d:	68 87 02 00 00       	push   $0x287
f0112412:	68 22 8a 12 f0       	push   $0xf0128a22
f0112417:	e8 ba e0 fe ff       	call   f01004d6 <_warn>
f011241c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011241f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112426:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011242a:	74 04                	je     f0112430 <test_cut_paste_pages+0x7fb>
f011242c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112430:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112437:	e8 70 bd ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011243c:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f011243f:	6a 03                	push   $0x3
f0112441:	68 00 f0 bf 01       	push   $0x1bff000
f0112446:	68 00 00 40 01       	push   $0x1400000
f011244b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011244e:	e8 f8 7e ff ff       	call   f010a34b <cut_paste_pages>
f0112453:	83 c4 10             	add    $0x10,%esp
f0112456:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112459:	e8 4e bd ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011245e:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112461:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112465:	75 08                	jne    f011246f <test_cut_paste_pages+0x83a>
f0112467:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011246a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011246d:	74 2b                	je     f011249a <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011246f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112472:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112475:	83 ec 0c             	sub    $0xc,%esp
f0112478:	50                   	push   %eax
f0112479:	ff 75 b4             	pushl  -0x4c(%ebp)
f011247c:	68 08 90 12 f0       	push   $0xf0129008
f0112481:	68 96 02 00 00       	push   $0x296
f0112486:	68 22 8a 12 f0       	push   $0xf0128a22
f011248b:	e8 46 e0 fe ff       	call   f01004d6 <_warn>
f0112490:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112493:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011249a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011249e:	74 04                	je     f01124a4 <test_cut_paste_pages+0x86f>
f01124a0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01124a4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f01124ab:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01124b2:	83 ec 04             	sub    $0x4,%esp
f01124b5:	6a 00                	push   $0x0
f01124b7:	68 00 00 40 01       	push   $0x1400000
f01124bc:	ff 75 d4             	pushl  -0x2c(%ebp)
f01124bf:	e8 ec 3b 00 00       	call   f01160b0 <CB>
f01124c4:	83 c4 10             	add    $0x10,%esp
f01124c7:	83 f8 01             	cmp    $0x1,%eax
f01124ca:	0f 85 80 00 00 00    	jne    f0112550 <test_cut_paste_pages+0x91b>
f01124d0:	83 ec 04             	sub    $0x4,%esp
f01124d3:	6a 00                	push   $0x0
f01124d5:	68 00 10 40 01       	push   $0x1401000
f01124da:	ff 75 d4             	pushl  -0x2c(%ebp)
f01124dd:	e8 ce 3b 00 00       	call   f01160b0 <CB>
f01124e2:	83 c4 10             	add    $0x10,%esp
f01124e5:	83 f8 01             	cmp    $0x1,%eax
f01124e8:	75 66                	jne    f0112550 <test_cut_paste_pages+0x91b>
f01124ea:	83 ec 04             	sub    $0x4,%esp
f01124ed:	6a 00                	push   $0x0
f01124ef:	68 00 20 40 01       	push   $0x1402000
f01124f4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01124f7:	e8 b4 3b 00 00       	call   f01160b0 <CB>
f01124fc:	83 c4 10             	add    $0x10,%esp
f01124ff:	83 f8 01             	cmp    $0x1,%eax
f0112502:	75 4c                	jne    f0112550 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112504:	83 ec 04             	sub    $0x4,%esp
f0112507:	6a 00                	push   $0x0
f0112509:	68 00 f0 bf 01       	push   $0x1bff000
f011250e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112511:	e8 9a 3b 00 00       	call   f01160b0 <CB>
f0112516:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112519:	85 c0                	test   %eax,%eax
f011251b:	75 33                	jne    f0112550 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f011251d:	83 ec 04             	sub    $0x4,%esp
f0112520:	6a 00                	push   $0x0
f0112522:	68 00 00 c0 01       	push   $0x1c00000
f0112527:	ff 75 d4             	pushl  -0x2c(%ebp)
f011252a:	e8 81 3b 00 00       	call   f01160b0 <CB>
f011252f:	83 c4 10             	add    $0x10,%esp
f0112532:	83 f8 01             	cmp    $0x1,%eax
f0112535:	75 19                	jne    f0112550 <test_cut_paste_pages+0x91b>
f0112537:	83 ec 04             	sub    $0x4,%esp
f011253a:	6a 00                	push   $0x0
f011253c:	68 00 10 c0 01       	push   $0x1c01000
f0112541:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112544:	e8 67 3b 00 00       	call   f01160b0 <CB>
f0112549:	83 c4 10             	add    $0x10,%esp
f011254c:	85 c0                	test   %eax,%eax
f011254e:	74 28                	je     f0112578 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0112550:	83 ec 04             	sub    $0x4,%esp
f0112553:	68 68 90 12 f0       	push   $0xf0129068
f0112558:	68 9f 02 00 00       	push   $0x29f
f011255d:	68 22 8a 12 f0       	push   $0xf0128a22
f0112562:	e8 6f df fe ff       	call   f01004d6 <_warn>
f0112567:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011256a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112571:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112578:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011257c:	74 04                	je     f0112582 <test_cut_paste_pages+0x94d>
f011257e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112582:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112589:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011258d:	0f 84 99 00 00 00    	je     f011262c <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0112593:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f011259a:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01125a1:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01125a8:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f01125af:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f01125b6:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01125bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01125c0:	8a 00                	mov    (%eax),%al
f01125c2:	3c 61                	cmp    $0x61,%al
f01125c4:	75 2d                	jne    f01125f3 <test_cut_paste_pages+0x9be>
f01125c6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01125c9:	8a 00                	mov    (%eax),%al
f01125cb:	3c 78                	cmp    $0x78,%al
f01125cd:	75 24                	jne    f01125f3 <test_cut_paste_pages+0x9be>
f01125cf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01125d2:	8a 00                	mov    (%eax),%al
f01125d4:	3c 62                	cmp    $0x62,%al
f01125d6:	75 1b                	jne    f01125f3 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01125d8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01125db:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01125dd:	3c 79                	cmp    $0x79,%al
f01125df:	75 12                	jne    f01125f3 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01125e1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01125e4:	8a 00                	mov    (%eax),%al
f01125e6:	3c 63                	cmp    $0x63,%al
f01125e8:	75 09                	jne    f01125f3 <test_cut_paste_pages+0x9be>
f01125ea:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01125ed:	8a 00                	mov    (%eax),%al
f01125ef:	3c 7a                	cmp    $0x7a,%al
f01125f1:	74 28                	je     f011261b <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f01125f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f01125fa:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112601:	83 ec 04             	sub    $0x4,%esp
f0112604:	68 68 8f 12 f0       	push   $0xf0128f68
f0112609:	68 b3 02 00 00       	push   $0x2b3
f011260e:	68 22 8a 12 f0       	push   $0xf0128a22
f0112613:	e8 be de fe ff       	call   f01004d6 <_warn>
f0112618:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f011261b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011261f:	74 04                	je     f0112625 <test_cut_paste_pages+0x9f0>
f0112621:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112625:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f011262c:	83 ec 0c             	sub    $0xc,%esp
f011262f:	68 a1 90 12 f0       	push   $0xf01290a1
f0112634:	e8 52 e9 fe ff       	call   f0100f8b <cprintf>
f0112639:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f011263c:	83 ec 08             	sub    $0x8,%esp
f011263f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112642:	68 b0 90 12 f0       	push   $0xf01290b0
f0112647:	e8 3f e9 fe ff       	call   f0100f8b <cprintf>
f011264c:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011264f:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112653:	75 10                	jne    f0112665 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0112655:	83 ec 0c             	sub    $0xc,%esp
f0112658:	68 e4 90 12 f0       	push   $0xf01290e4
f011265d:	e8 29 e9 fe ff       	call   f0100f8b <cprintf>
f0112662:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112665:	a1 a4 ba 6b f0       	mov    0xf06bbaa4,%eax
f011266a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011266d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112670:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112673:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112678:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011267b:	5b                   	pop    %ebx
f011267c:	5e                   	pop    %esi
f011267d:	5f                   	pop    %edi
f011267e:	5d                   	pop    %ebp
f011267f:	c3                   	ret    

f0112680 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0112680:	55                   	push   %ebp
f0112681:	89 e5                	mov    %esp,%ebp
f0112683:	57                   	push   %edi
f0112684:	56                   	push   %esi
f0112685:	53                   	push   %ebx
f0112686:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011268c:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112692:	bb 24 91 12 f0       	mov    $0xf0129124,%ebx
f0112697:	ba 0f 00 00 00       	mov    $0xf,%edx
f011269c:	89 c7                	mov    %eax,%edi
f011269e:	89 de                	mov    %ebx,%esi
f01126a0:	89 d1                	mov    %edx,%ecx
f01126a2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01126a4:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f01126aa:	b9 23 00 00 00       	mov    $0x23,%ecx
f01126af:	b0 00                	mov    $0x0,%al
f01126b1:	89 d7                	mov    %edx,%edi
f01126b3:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01126b5:	6a 00                	push   $0x0
f01126b7:	6a 0a                	push   $0xa
f01126b9:	6a 14                	push   $0x14
f01126bb:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f01126c1:	50                   	push   %eax
f01126c2:	e8 45 81 ff ff       	call   f010a80c <env_create>
f01126c7:	83 c4 10             	add    $0x10,%esp
f01126ca:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01126cd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01126d0:	8b 40 64             	mov    0x64(%eax),%eax
f01126d3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01126d6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01126d9:	8b 40 68             	mov    0x68(%eax),%eax
f01126dc:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01126e2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01126e8:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01126eb:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f01126f2:	75 70 20 
f01126f5:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f01126fc:	00 00 00 
f01126ff:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112705:	b9 03 00 00 00       	mov    $0x3,%ecx
f011270a:	b8 00 00 00 00       	mov    $0x0,%eax
f011270f:	89 d7                	mov    %edx,%edi
f0112711:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112713:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112716:	8b 40 10             	mov    0x10(%eax),%eax
f0112719:	83 ec 08             	sub    $0x8,%esp
f011271c:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0112722:	52                   	push   %edx
f0112723:	50                   	push   %eax
f0112724:	e8 56 d2 00 00       	call   f011f97f <ltostr>
f0112729:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011272c:	83 ec 04             	sub    $0x4,%esp
f011272f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112735:	50                   	push   %eax
f0112736:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f011273c:	50                   	push   %eax
f011273d:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0112743:	50                   	push   %eax
f0112744:	e8 0f d3 00 00       	call   f011fa58 <strcconcat>
f0112749:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f011274c:	83 ec 0c             	sub    $0xc,%esp
f011274f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112752:	e8 49 3b 00 00       	call   f01162a0 <ClearUserSpace>
f0112757:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f011275a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0112761:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0112768:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011276f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0112776:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011277d:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0112784:	83 ec 0c             	sub    $0xc,%esp
f0112787:	68 58 91 12 f0       	push   $0xf0129158
f011278c:	e8 fa e7 fe ff       	call   f0100f8b <cprintf>
f0112791:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0112794:	83 ec 04             	sub    $0x4,%esp
f0112797:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011279d:	50                   	push   %eax
f011279e:	68 8e 91 12 f0       	push   $0xf012918e
f01127a3:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01127a9:	50                   	push   %eax
f01127aa:	e8 a9 d2 00 00       	call   f011fa58 <strcconcat>
f01127af:	83 c4 10             	add    $0x10,%esp
f01127b2:	83 ec 0c             	sub    $0xc,%esp
f01127b5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01127bb:	50                   	push   %eax
f01127bc:	e8 3a f7 fe ff       	call   f0101efb <execute_command>
f01127c1:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f01127c4:	83 ec 04             	sub    $0x4,%esp
f01127c7:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01127cd:	50                   	push   %eax
f01127ce:	68 93 91 12 f0       	push   $0xf0129193
f01127d3:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01127d9:	50                   	push   %eax
f01127da:	e8 79 d2 00 00       	call   f011fa58 <strcconcat>
f01127df:	83 c4 10             	add    $0x10,%esp
f01127e2:	83 ec 0c             	sub    $0xc,%esp
f01127e5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01127eb:	50                   	push   %eax
f01127ec:	e8 0a f7 fe ff       	call   f0101efb <execute_command>
f01127f1:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f01127f4:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01127fa:	bb 99 94 12 f0       	mov    $0xf0129499,%ebx
f01127ff:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112804:	89 c7                	mov    %eax,%edi
f0112806:	89 de                	mov    %ebx,%esi
f0112808:	89 d1                	mov    %edx,%ecx
f011280a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011280c:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112812:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112817:	b0 00                	mov    $0x0,%al
f0112819:	89 d7                	mov    %edx,%edi
f011281b:	f3 aa                	rep stos %al,%es:(%edi)
f011281d:	83 ec 0c             	sub    $0xc,%esp
f0112820:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112826:	50                   	push   %eax
f0112827:	e8 cf f6 fe ff       	call   f0101efb <execute_command>
f011282c:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f011282f:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112835:	bb fd 94 12 f0       	mov    $0xf01294fd,%ebx
f011283a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011283f:	89 c7                	mov    %eax,%edi
f0112841:	89 de                	mov    %ebx,%esi
f0112843:	89 d1                	mov    %edx,%ecx
f0112845:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112847:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f011284d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112852:	b0 00                	mov    $0x0,%al
f0112854:	89 d7                	mov    %edx,%edi
f0112856:	f3 aa                	rep stos %al,%es:(%edi)
f0112858:	83 ec 0c             	sub    $0xc,%esp
f011285b:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112861:	50                   	push   %eax
f0112862:	e8 94 f6 fe ff       	call   f0101efb <execute_command>
f0112867:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f011286a:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112870:	bb 61 95 12 f0       	mov    $0xf0129561,%ebx
f0112875:	ba 0f 00 00 00       	mov    $0xf,%edx
f011287a:	89 c7                	mov    %eax,%edi
f011287c:	89 de                	mov    %ebx,%esi
f011287e:	89 d1                	mov    %edx,%ecx
f0112880:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112882:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112888:	b9 55 00 00 00       	mov    $0x55,%ecx
f011288d:	b0 00                	mov    $0x0,%al
f011288f:	89 d7                	mov    %edx,%edi
f0112891:	f3 aa                	rep stos %al,%es:(%edi)
f0112893:	83 ec 0c             	sub    $0xc,%esp
f0112896:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011289c:	50                   	push   %eax
f011289d:	e8 59 f6 fe ff       	call   f0101efb <execute_command>
f01128a2:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f01128a5:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01128ab:	bb c5 95 12 f0       	mov    $0xf01295c5,%ebx
f01128b0:	ba 0f 00 00 00       	mov    $0xf,%edx
f01128b5:	89 c7                	mov    %eax,%edi
f01128b7:	89 de                	mov    %ebx,%esi
f01128b9:	89 d1                	mov    %edx,%ecx
f01128bb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01128bd:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01128c3:	b9 55 00 00 00       	mov    $0x55,%ecx
f01128c8:	b0 00                	mov    $0x0,%al
f01128ca:	89 d7                	mov    %edx,%edi
f01128cc:	f3 aa                	rep stos %al,%es:(%edi)
f01128ce:	83 ec 0c             	sub    $0xc,%esp
f01128d1:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01128d7:	50                   	push   %eax
f01128d8:	e8 1e f6 fe ff       	call   f0101efb <execute_command>
f01128dd:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f01128e0:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01128e6:	bb 29 96 12 f0       	mov    $0xf0129629,%ebx
f01128eb:	ba 0f 00 00 00       	mov    $0xf,%edx
f01128f0:	89 c7                	mov    %eax,%edi
f01128f2:	89 de                	mov    %ebx,%esi
f01128f4:	89 d1                	mov    %edx,%ecx
f01128f6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01128f8:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01128fe:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112903:	b0 00                	mov    $0x0,%al
f0112905:	89 d7                	mov    %edx,%edi
f0112907:	f3 aa                	rep stos %al,%es:(%edi)
f0112909:	83 ec 0c             	sub    $0xc,%esp
f011290c:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112912:	50                   	push   %eax
f0112913:	e8 e3 f5 fe ff       	call   f0101efb <execute_command>
f0112918:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f011291b:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112921:	bb 8d 96 12 f0       	mov    $0xf012968d,%ebx
f0112926:	ba 0f 00 00 00       	mov    $0xf,%edx
f011292b:	89 c7                	mov    %eax,%edi
f011292d:	89 de                	mov    %ebx,%esi
f011292f:	89 d1                	mov    %edx,%ecx
f0112931:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112933:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112939:	b9 55 00 00 00       	mov    $0x55,%ecx
f011293e:	b0 00                	mov    $0x0,%al
f0112940:	89 d7                	mov    %edx,%edi
f0112942:	f3 aa                	rep stos %al,%es:(%edi)
f0112944:	83 ec 0c             	sub    $0xc,%esp
f0112947:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011294d:	50                   	push   %eax
f011294e:	e8 a8 f5 fe ff       	call   f0101efb <execute_command>
f0112953:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0112956:	83 ec 04             	sub    $0x4,%esp
f0112959:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011295f:	50                   	push   %eax
f0112960:	68 9b 91 12 f0       	push   $0xf012919b
f0112965:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011296b:	50                   	push   %eax
f011296c:	e8 e7 d0 00 00       	call   f011fa58 <strcconcat>
f0112971:	83 c4 10             	add    $0x10,%esp
f0112974:	83 ec 0c             	sub    $0xc,%esp
f0112977:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011297d:	50                   	push   %eax
f011297e:	e8 78 f5 fe ff       	call   f0101efb <execute_command>
f0112983:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0112986:	83 ec 04             	sub    $0x4,%esp
f0112989:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011298f:	50                   	push   %eax
f0112990:	68 a5 91 12 f0       	push   $0xf01291a5
f0112995:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011299b:	50                   	push   %eax
f011299c:	e8 b7 d0 00 00       	call   f011fa58 <strcconcat>
f01129a1:	83 c4 10             	add    $0x10,%esp
f01129a4:	83 ec 0c             	sub    $0xc,%esp
f01129a7:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01129ad:	50                   	push   %eax
f01129ae:	e8 48 f5 fe ff       	call   f0101efb <execute_command>
f01129b3:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f01129b6:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01129bc:	bb f1 96 12 f0       	mov    $0xf01296f1,%ebx
f01129c1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01129c6:	89 c7                	mov    %eax,%edi
f01129c8:	89 de                	mov    %ebx,%esi
f01129ca:	89 d1                	mov    %edx,%ecx
f01129cc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01129ce:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01129d4:	b9 55 00 00 00       	mov    $0x55,%ecx
f01129d9:	b0 00                	mov    $0x0,%al
f01129db:	89 d7                	mov    %edx,%edi
f01129dd:	f3 aa                	rep stos %al,%es:(%edi)
f01129df:	83 ec 0c             	sub    $0xc,%esp
f01129e2:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01129e8:	50                   	push   %eax
f01129e9:	e8 0d f5 fe ff       	call   f0101efb <execute_command>
f01129ee:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f01129f1:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01129f7:	bb 55 97 12 f0       	mov    $0xf0129755,%ebx
f01129fc:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112a01:	89 c7                	mov    %eax,%edi
f0112a03:	89 de                	mov    %ebx,%esi
f0112a05:	89 d1                	mov    %edx,%ecx
f0112a07:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112a09:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112a0f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a14:	b0 00                	mov    $0x0,%al
f0112a16:	89 d7                	mov    %edx,%edi
f0112a18:	f3 aa                	rep stos %al,%es:(%edi)
f0112a1a:	83 ec 0c             	sub    $0xc,%esp
f0112a1d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112a23:	50                   	push   %eax
f0112a24:	e8 d2 f4 fe ff       	call   f0101efb <execute_command>
f0112a29:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0112a2c:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112a32:	bb b9 97 12 f0       	mov    $0xf01297b9,%ebx
f0112a37:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112a3c:	89 c7                	mov    %eax,%edi
f0112a3e:	89 de                	mov    %ebx,%esi
f0112a40:	89 d1                	mov    %edx,%ecx
f0112a42:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112a44:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112a4a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a4f:	b0 00                	mov    $0x0,%al
f0112a51:	89 d7                	mov    %edx,%edi
f0112a53:	f3 aa                	rep stos %al,%es:(%edi)
f0112a55:	83 ec 0c             	sub    $0xc,%esp
f0112a58:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112a5e:	50                   	push   %eax
f0112a5f:	e8 97 f4 fe ff       	call   f0101efb <execute_command>
f0112a64:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0112a67:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0112a6e:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0112a75:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0112a7c:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0112a83:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0112a8a:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0112a91:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0112a98:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0112a9f:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0112aa6:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0112aad:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0112ab4:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0112abb:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112abe:	8a 00                	mov    (%eax),%al
f0112ac0:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0112ac6:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112ac9:	8a 00                	mov    (%eax),%al
f0112acb:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0112ad1:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112ad4:	8a 00                	mov    (%eax),%al
f0112ad6:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112adc:	e8 cb b6 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0112ae1:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0112ae4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112ae7:	89 d0                	mov    %edx,%eax
f0112ae9:	01 c0                	add    %eax,%eax
f0112aeb:	01 d0                	add    %edx,%eax
f0112aed:	01 c0                	add    %eax,%eax
f0112aef:	50                   	push   %eax
f0112af0:	68 00 00 10 00       	push   $0x100000
f0112af5:	6a 00                	push   $0x0
f0112af7:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112afa:	e8 66 78 ff ff       	call   f010a365 <copy_paste_chunk>
f0112aff:	83 c4 10             	add    $0x10,%esp
f0112b02:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112b05:	e8 a2 b6 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0112b0a:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0112b0d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0112b14:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0112b18:	75 08                	jne    f0112b22 <test_copy_paste_chunk+0x4a2>
f0112b1a:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112b1d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0112b20:	74 2b                	je     f0112b4d <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112b22:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112b25:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112b28:	83 ec 0c             	sub    $0xc,%esp
f0112b2b:	50                   	push   %eax
f0112b2c:	ff 75 88             	pushl  -0x78(%ebp)
f0112b2f:	68 b4 91 12 f0       	push   $0xf01291b4
f0112b34:	68 06 03 00 00       	push   $0x306
f0112b39:	68 22 8a 12 f0       	push   $0xf0128a22
f0112b3e:	e8 93 d9 fe ff       	call   f01004d6 <_warn>
f0112b43:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112b46:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112b4d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b51:	74 04                	je     f0112b57 <test_copy_paste_chunk+0x4d7>
f0112b53:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112b57:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0112b5e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112b61:	8a 00                	mov    (%eax),%al
f0112b63:	3c 61                	cmp    $0x61,%al
f0112b65:	75 75                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112b67:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112b6a:	8a 00                	mov    (%eax),%al
f0112b6c:	3c 78                	cmp    $0x78,%al
f0112b6e:	75 6c                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112b70:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112b73:	8a 00                	mov    (%eax),%al
f0112b75:	3c 62                	cmp    $0x62,%al
f0112b77:	75 63                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112b79:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112b7c:	8a 00                	mov    (%eax),%al
f0112b7e:	3c 79                	cmp    $0x79,%al
f0112b80:	75 5a                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112b82:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112b85:	8a 00                	mov    (%eax),%al
f0112b87:	3c 63                	cmp    $0x63,%al
f0112b89:	75 51                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112b8b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112b8e:	8a 00                	mov    (%eax),%al
f0112b90:	3c 7a                	cmp    $0x7a,%al
f0112b92:	75 48                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0112b94:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112b97:	8a 00                	mov    (%eax),%al
f0112b99:	3c 64                	cmp    $0x64,%al
f0112b9b:	75 3f                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112b9d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112ba0:	8a 10                	mov    (%eax),%dl
f0112ba2:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0112ba8:	38 c2                	cmp    %al,%dl
f0112baa:	75 30                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112bac:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112baf:	8a 00                	mov    (%eax),%al
f0112bb1:	3c 65                	cmp    $0x65,%al
f0112bb3:	75 27                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112bb5:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112bb8:	8a 10                	mov    (%eax),%dl
f0112bba:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0112bc0:	38 c2                	cmp    %al,%dl
f0112bc2:	75 18                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112bc4:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112bc7:	8a 00                	mov    (%eax),%al
f0112bc9:	3c 66                	cmp    $0x66,%al
f0112bcb:	75 0f                	jne    f0112bdc <test_copy_paste_chunk+0x55c>
f0112bcd:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112bd0:	8a 10                	mov    (%eax),%dl
f0112bd2:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0112bd8:	38 c2                	cmp    %al,%dl
f0112bda:	74 21                	je     f0112bfd <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112bdc:	83 ec 04             	sub    $0x4,%esp
f0112bdf:	68 18 92 12 f0       	push   $0xf0129218
f0112be4:	68 0f 03 00 00       	push   $0x30f
f0112be9:	68 22 8a 12 f0       	push   $0xf0128a22
f0112bee:	e8 e3 d8 fe ff       	call   f01004d6 <_warn>
f0112bf3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112bf6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112bfd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c01:	74 04                	je     f0112c07 <test_copy_paste_chunk+0x587>
f0112c03:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112c07:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0112c0e:	83 ec 0c             	sub    $0xc,%esp
f0112c11:	68 52 92 12 f0       	push   $0xf0129252
f0112c16:	e8 70 e3 fe ff       	call   f0100f8b <cprintf>
f0112c1b:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0112c1e:	83 ec 0c             	sub    $0xc,%esp
f0112c21:	68 64 92 12 f0       	push   $0xf0129264
f0112c26:	e8 60 e3 fe ff       	call   f0100f8b <cprintf>
f0112c2b:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0112c2e:	83 ec 04             	sub    $0x4,%esp
f0112c31:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112c37:	50                   	push   %eax
f0112c38:	68 9a 92 12 f0       	push   $0xf012929a
f0112c3d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112c43:	50                   	push   %eax
f0112c44:	e8 0f ce 00 00       	call   f011fa58 <strcconcat>
f0112c49:	83 c4 10             	add    $0x10,%esp
f0112c4c:	83 ec 0c             	sub    $0xc,%esp
f0112c4f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112c55:	50                   	push   %eax
f0112c56:	e8 a0 f2 fe ff       	call   f0101efb <execute_command>
f0112c5b:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f0112c5e:	83 ec 04             	sub    $0x4,%esp
f0112c61:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112c67:	50                   	push   %eax
f0112c68:	68 a4 92 12 f0       	push   $0xf01292a4
f0112c6d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112c73:	50                   	push   %eax
f0112c74:	e8 df cd 00 00       	call   f011fa58 <strcconcat>
f0112c79:	83 c4 10             	add    $0x10,%esp
f0112c7c:	83 ec 0c             	sub    $0xc,%esp
f0112c7f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112c85:	50                   	push   %eax
f0112c86:	e8 70 f2 fe ff       	call   f0101efb <execute_command>
f0112c8b:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0112c8e:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112c94:	bb 1d 98 12 f0       	mov    $0xf012981d,%ebx
f0112c99:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112c9e:	89 c7                	mov    %eax,%edi
f0112ca0:	89 de                	mov    %ebx,%esi
f0112ca2:	89 d1                	mov    %edx,%ecx
f0112ca4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112ca6:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112cac:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112cb1:	b0 00                	mov    $0x0,%al
f0112cb3:	89 d7                	mov    %edx,%edi
f0112cb5:	f3 aa                	rep stos %al,%es:(%edi)
f0112cb7:	83 ec 0c             	sub    $0xc,%esp
f0112cba:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112cc0:	50                   	push   %eax
f0112cc1:	e8 35 f2 fe ff       	call   f0101efb <execute_command>
f0112cc6:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0112cc9:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112ccf:	bb 81 98 12 f0       	mov    $0xf0129881,%ebx
f0112cd4:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112cd9:	89 c7                	mov    %eax,%edi
f0112cdb:	89 de                	mov    %ebx,%esi
f0112cdd:	89 d1                	mov    %edx,%ecx
f0112cdf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112ce1:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0112ce7:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112cec:	b0 00                	mov    $0x0,%al
f0112cee:	89 d7                	mov    %edx,%edi
f0112cf0:	f3 aa                	rep stos %al,%es:(%edi)
f0112cf2:	83 ec 0c             	sub    $0xc,%esp
f0112cf5:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112cfb:	50                   	push   %eax
f0112cfc:	e8 fa f1 fe ff       	call   f0101efb <execute_command>
f0112d01:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0112d04:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112d0a:	bb e5 98 12 f0       	mov    $0xf01298e5,%ebx
f0112d0f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d14:	89 c7                	mov    %eax,%edi
f0112d16:	89 de                	mov    %ebx,%esi
f0112d18:	89 d1                	mov    %edx,%ecx
f0112d1a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112d1c:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112d22:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112d27:	b0 00                	mov    $0x0,%al
f0112d29:	89 d7                	mov    %edx,%edi
f0112d2b:	f3 aa                	rep stos %al,%es:(%edi)
f0112d2d:	83 ec 0c             	sub    $0xc,%esp
f0112d30:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112d36:	50                   	push   %eax
f0112d37:	e8 bf f1 fe ff       	call   f0101efb <execute_command>
f0112d3c:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0112d3f:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112d45:	bb 49 99 12 f0       	mov    $0xf0129949,%ebx
f0112d4a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d4f:	89 c7                	mov    %eax,%edi
f0112d51:	89 de                	mov    %ebx,%esi
f0112d53:	89 d1                	mov    %edx,%ecx
f0112d55:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112d57:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0112d5d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112d62:	b0 00                	mov    $0x0,%al
f0112d64:	89 d7                	mov    %edx,%edi
f0112d66:	f3 aa                	rep stos %al,%es:(%edi)
f0112d68:	83 ec 0c             	sub    $0xc,%esp
f0112d6b:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112d71:	50                   	push   %eax
f0112d72:	e8 84 f1 fe ff       	call   f0101efb <execute_command>
f0112d77:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0112d7a:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112d80:	bb ad 99 12 f0       	mov    $0xf01299ad,%ebx
f0112d85:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d8a:	89 c7                	mov    %eax,%edi
f0112d8c:	89 de                	mov    %ebx,%esi
f0112d8e:	89 d1                	mov    %edx,%ecx
f0112d90:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112d92:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0112d98:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112d9d:	b0 00                	mov    $0x0,%al
f0112d9f:	89 d7                	mov    %edx,%edi
f0112da1:	f3 aa                	rep stos %al,%es:(%edi)
f0112da3:	83 ec 0c             	sub    $0xc,%esp
f0112da6:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112dac:	50                   	push   %eax
f0112dad:	e8 49 f1 fe ff       	call   f0101efb <execute_command>
f0112db2:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0112db5:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112dbb:	bb 11 9a 12 f0       	mov    $0xf0129a11,%ebx
f0112dc0:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112dc5:	89 c7                	mov    %eax,%edi
f0112dc7:	89 de                	mov    %ebx,%esi
f0112dc9:	89 d1                	mov    %edx,%ecx
f0112dcb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112dcd:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112dd3:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112dd8:	b0 00                	mov    $0x0,%al
f0112dda:	89 d7                	mov    %edx,%edi
f0112ddc:	f3 aa                	rep stos %al,%es:(%edi)
f0112dde:	83 ec 0c             	sub    $0xc,%esp
f0112de1:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112de7:	50                   	push   %eax
f0112de8:	e8 0e f1 fe ff       	call   f0101efb <execute_command>
f0112ded:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0112df0:	83 ec 04             	sub    $0x4,%esp
f0112df3:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112df9:	50                   	push   %eax
f0112dfa:	68 ae 92 12 f0       	push   $0xf01292ae
f0112dff:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112e05:	50                   	push   %eax
f0112e06:	e8 4d cc 00 00       	call   f011fa58 <strcconcat>
f0112e0b:	83 c4 10             	add    $0x10,%esp
f0112e0e:	83 ec 0c             	sub    $0xc,%esp
f0112e11:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112e17:	50                   	push   %eax
f0112e18:	e8 de f0 fe ff       	call   f0101efb <execute_command>
f0112e1d:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0112e20:	83 ec 04             	sub    $0x4,%esp
f0112e23:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112e29:	50                   	push   %eax
f0112e2a:	68 b8 92 12 f0       	push   $0xf01292b8
f0112e2f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112e35:	50                   	push   %eax
f0112e36:	e8 1d cc 00 00       	call   f011fa58 <strcconcat>
f0112e3b:	83 c4 10             	add    $0x10,%esp
f0112e3e:	83 ec 0c             	sub    $0xc,%esp
f0112e41:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112e47:	50                   	push   %eax
f0112e48:	e8 ae f0 fe ff       	call   f0101efb <execute_command>
f0112e4d:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f0112e50:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112e56:	bb 75 9a 12 f0       	mov    $0xf0129a75,%ebx
f0112e5b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e60:	89 c7                	mov    %eax,%edi
f0112e62:	89 de                	mov    %ebx,%esi
f0112e64:	89 d1                	mov    %edx,%ecx
f0112e66:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e68:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112e6e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e73:	b0 00                	mov    $0x0,%al
f0112e75:	89 d7                	mov    %edx,%edi
f0112e77:	f3 aa                	rep stos %al,%es:(%edi)
f0112e79:	83 ec 0c             	sub    $0xc,%esp
f0112e7c:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112e82:	50                   	push   %eax
f0112e83:	e8 73 f0 fe ff       	call   f0101efb <execute_command>
f0112e88:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0112e8b:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112e91:	bb d9 9a 12 f0       	mov    $0xf0129ad9,%ebx
f0112e96:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e9b:	89 c7                	mov    %eax,%edi
f0112e9d:	89 de                	mov    %ebx,%esi
f0112e9f:	89 d1                	mov    %edx,%ecx
f0112ea1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112ea3:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112ea9:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112eae:	b0 00                	mov    $0x0,%al
f0112eb0:	89 d7                	mov    %edx,%edi
f0112eb2:	f3 aa                	rep stos %al,%es:(%edi)
f0112eb4:	83 ec 0c             	sub    $0xc,%esp
f0112eb7:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112ebd:	50                   	push   %eax
f0112ebe:	e8 38 f0 fe ff       	call   f0101efb <execute_command>
f0112ec3:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0112ec6:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112ecc:	bb 3d 9b 12 f0       	mov    $0xf0129b3d,%ebx
f0112ed1:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112ed6:	89 c7                	mov    %eax,%edi
f0112ed8:	89 de                	mov    %ebx,%esi
f0112eda:	89 d1                	mov    %edx,%ecx
f0112edc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112ede:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112ee4:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112ee9:	b0 00                	mov    $0x0,%al
f0112eeb:	89 d7                	mov    %edx,%edi
f0112eed:	f3 aa                	rep stos %al,%es:(%edi)
f0112eef:	83 ec 0c             	sub    $0xc,%esp
f0112ef2:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112ef8:	50                   	push   %eax
f0112ef9:	e8 fd ef fe ff       	call   f0101efb <execute_command>
f0112efe:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0112f01:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0112f08:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0112f0f:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0112f16:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0112f1d:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0112f24:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0112f2b:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0112f32:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0112f39:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f0112f40:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0112f47:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f0112f4e:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0112f55:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112f58:	8a 00                	mov    (%eax),%al
f0112f5a:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112f60:	e8 47 b2 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0112f65:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0112f68:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112f6b:	89 d0                	mov    %edx,%eax
f0112f6d:	01 c0                	add    %eax,%eax
f0112f6f:	01 d0                	add    %edx,%eax
f0112f71:	01 c0                	add    %eax,%eax
f0112f73:	50                   	push   %eax
f0112f74:	68 00 00 40 00       	push   $0x400000
f0112f79:	68 00 00 20 00       	push   $0x200000
f0112f7e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f81:	e8 df 73 ff ff       	call   f010a365 <copy_paste_chunk>
f0112f86:	83 c4 10             	add    $0x10,%esp
f0112f89:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112f8c:	e8 1b b2 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0112f91:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0112f94:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0112f9b:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0112f9f:	75 08                	jne    f0112fa9 <test_copy_paste_chunk+0x929>
f0112fa1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112fa4:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0112fa7:	74 2b                	je     f0112fd4 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112fa9:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112fac:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112faf:	83 ec 0c             	sub    $0xc,%esp
f0112fb2:	50                   	push   %eax
f0112fb3:	ff 75 80             	pushl  -0x80(%ebp)
f0112fb6:	68 c4 92 12 f0       	push   $0xf01292c4
f0112fbb:	68 3f 03 00 00       	push   $0x33f
f0112fc0:	68 22 8a 12 f0       	push   $0xf0128a22
f0112fc5:	e8 0c d5 fe ff       	call   f01004d6 <_warn>
f0112fca:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112fcd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112fd4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112fd8:	74 04                	je     f0112fde <test_copy_paste_chunk+0x95e>
f0112fda:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112fde:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0112fe5:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0112fec:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0112fef:	83 ec 08             	sub    $0x8,%esp
f0112ff2:	6a 01                	push   $0x1
f0112ff4:	6a 07                	push   $0x7
f0112ff6:	6a 07                	push   $0x7
f0112ff8:	6a 07                	push   $0x7
f0112ffa:	6a 07                	push   $0x7
f0112ffc:	6a 01                	push   $0x1
f0112ffe:	68 00 20 00 00       	push   $0x2000
f0113003:	68 00 00 40 00       	push   $0x400000
f0113008:	68 00 00 20 00       	push   $0x200000
f011300d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113010:	e8 bf 32 00 00       	call   f01162d4 <CCP>
f0113015:	83 c4 30             	add    $0x30,%esp
f0113018:	83 f8 01             	cmp    $0x1,%eax
f011301b:	74 2b                	je     f0113048 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f011301d:	83 ec 04             	sub    $0x4,%esp
f0113020:	68 18 93 12 f0       	push   $0xf0129318
f0113025:	68 48 03 00 00       	push   $0x348
f011302a:	68 22 8a 12 f0       	push   $0xf0128a22
f011302f:	e8 a2 d4 fe ff       	call   f01004d6 <_warn>
f0113034:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113037:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f011303e:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113045:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113048:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011304c:	74 04                	je     f0113052 <test_copy_paste_chunk+0x9d2>
f011304e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113052:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113059:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011305c:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f011305f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113062:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113065:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113068:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f011306b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011306e:	8a 00                	mov    (%eax),%al
f0113070:	3c 61                	cmp    $0x61,%al
f0113072:	75 69                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f0113074:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113077:	8a 00                	mov    (%eax),%al
f0113079:	3c 61                	cmp    $0x61,%al
f011307b:	75 60                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f011307d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113080:	8a 00                	mov    (%eax),%al
f0113082:	3c 79                	cmp    $0x79,%al
f0113084:	75 57                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f0113086:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113089:	8a 00                	mov    (%eax),%al
f011308b:	3c 62                	cmp    $0x62,%al
f011308d:	75 4e                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f011308f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113092:	8a 00                	mov    (%eax),%al
f0113094:	3c 63                	cmp    $0x63,%al
f0113096:	75 45                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f0113098:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011309b:	8a 00                	mov    (%eax),%al
f011309d:	3c 7a                	cmp    $0x7a,%al
f011309f:	75 3c                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f01130a1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01130a4:	8a 00                	mov    (%eax),%al
f01130a6:	3c 77                	cmp    $0x77,%al
f01130a8:	75 33                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f01130aa:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01130ad:	8a 00                	mov    (%eax),%al
f01130af:	3c 64                	cmp    $0x64,%al
f01130b1:	75 2a                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f01130b3:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01130b6:	8a 00                	mov    (%eax),%al
f01130b8:	3c 65                	cmp    $0x65,%al
f01130ba:	75 21                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f01130bc:	8b 45 98             	mov    -0x68(%ebp),%eax
f01130bf:	8a 00                	mov    (%eax),%al
f01130c1:	3c 65                	cmp    $0x65,%al
f01130c3:	75 18                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f01130c5:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01130c8:	8a 00                	mov    (%eax),%al
f01130ca:	3c 66                	cmp    $0x66,%al
f01130cc:	75 0f                	jne    f01130dd <test_copy_paste_chunk+0xa5d>
f01130ce:	8b 45 90             	mov    -0x70(%ebp),%eax
f01130d1:	8a 10                	mov    (%eax),%dl
f01130d3:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01130d9:	38 c2                	cmp    %al,%dl
f01130db:	74 21                	je     f01130fe <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01130dd:	83 ec 04             	sub    $0x4,%esp
f01130e0:	68 18 92 12 f0       	push   $0xf0129218
f01130e5:	68 56 03 00 00       	push   $0x356
f01130ea:	68 22 8a 12 f0       	push   $0xf0128a22
f01130ef:	e8 e2 d3 fe ff       	call   f01004d6 <_warn>
f01130f4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01130f7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01130fe:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113102:	74 04                	je     f0113108 <test_copy_paste_chunk+0xa88>
f0113104:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113108:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f011310f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113112:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113115:	e8 92 b0 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011311a:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f011311d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113120:	89 c2                	mov    %eax,%edx
f0113122:	01 d2                	add    %edx,%edx
f0113124:	01 d0                	add    %edx,%eax
f0113126:	50                   	push   %eax
f0113127:	68 00 08 20 00       	push   $0x200800
f011312c:	68 00 08 40 00       	push   $0x400800
f0113131:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113134:	e8 2c 72 ff ff       	call   f010a365 <copy_paste_chunk>
f0113139:	83 c4 10             	add    $0x10,%esp
f011313c:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011313f:	e8 68 b0 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0113144:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113147:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f011314b:	75 08                	jne    f0113155 <test_copy_paste_chunk+0xad5>
f011314d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113150:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113153:	74 2b                	je     f0113180 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113155:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113158:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011315b:	83 ec 0c             	sub    $0xc,%esp
f011315e:	50                   	push   %eax
f011315f:	ff 75 80             	pushl  -0x80(%ebp)
f0113162:	68 c4 92 12 f0       	push   $0xf01292c4
f0113167:	68 66 03 00 00       	push   $0x366
f011316c:	68 22 8a 12 f0       	push   $0xf0128a22
f0113171:	e8 60 d3 fe ff       	call   f01004d6 <_warn>
f0113176:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113179:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113180:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113184:	74 04                	je     f011318a <test_copy_paste_chunk+0xb0a>
f0113186:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011318a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113191:	83 ec 08             	sub    $0x8,%esp
f0113194:	6a 01                	push   $0x1
f0113196:	6a 07                	push   $0x7
f0113198:	6a 07                	push   $0x7
f011319a:	6a 07                	push   $0x7
f011319c:	6a 07                	push   $0x7
f011319e:	6a 01                	push   $0x1
f01131a0:	68 00 20 00 00       	push   $0x2000
f01131a5:	68 00 00 20 00       	push   $0x200000
f01131aa:	68 00 00 40 00       	push   $0x400000
f01131af:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131b2:	e8 1d 31 00 00       	call   f01162d4 <CCP>
f01131b7:	83 c4 30             	add    $0x30,%esp
f01131ba:	83 f8 01             	cmp    $0x1,%eax
f01131bd:	74 21                	je     f01131e0 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01131bf:	83 ec 04             	sub    $0x4,%esp
f01131c2:	68 64 93 12 f0       	push   $0xf0129364
f01131c7:	68 6e 03 00 00       	push   $0x36e
f01131cc:	68 22 8a 12 f0       	push   $0xf0128a22
f01131d1:	e8 00 d3 fe ff       	call   f01004d6 <_warn>
f01131d6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01131d9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01131e0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01131e4:	74 04                	je     f01131ea <test_copy_paste_chunk+0xb6a>
f01131e6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01131ea:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01131f1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01131f4:	8a 00                	mov    (%eax),%al
f01131f6:	3c 61                	cmp    $0x61,%al
f01131f8:	75 69                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
f01131fa:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01131fd:	8a 00                	mov    (%eax),%al
f01131ff:	3c 61                	cmp    $0x61,%al
f0113201:	75 60                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
f0113203:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113206:	8a 00                	mov    (%eax),%al
f0113208:	3c 79                	cmp    $0x79,%al
f011320a:	75 57                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
f011320c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011320f:	8a 00                	mov    (%eax),%al
f0113211:	3c 62                	cmp    $0x62,%al
f0113213:	75 4e                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
f0113215:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113218:	8a 00                	mov    (%eax),%al
f011321a:	3c 7a                	cmp    $0x7a,%al
f011321c:	75 45                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
f011321e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113221:	8a 00                	mov    (%eax),%al
f0113223:	3c 7a                	cmp    $0x7a,%al
f0113225:	75 3c                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113227:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011322a:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011322c:	3c 64                	cmp    $0x64,%al
f011322e:	75 33                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113230:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113233:	8a 00                	mov    (%eax),%al
f0113235:	3c 64                	cmp    $0x64,%al
f0113237:	75 2a                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
f0113239:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011323c:	8a 00                	mov    (%eax),%al
f011323e:	3c 65                	cmp    $0x65,%al
f0113240:	75 21                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
f0113242:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113245:	8a 00                	mov    (%eax),%al
f0113247:	3c 78                	cmp    $0x78,%al
f0113249:	75 18                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
f011324b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011324e:	8a 00                	mov    (%eax),%al
f0113250:	3c 66                	cmp    $0x66,%al
f0113252:	75 0f                	jne    f0113263 <test_copy_paste_chunk+0xbe3>
f0113254:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113257:	8a 10                	mov    (%eax),%dl
f0113259:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011325f:	38 c2                	cmp    %al,%dl
f0113261:	74 21                	je     f0113284 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113263:	83 ec 04             	sub    $0x4,%esp
f0113266:	68 18 92 12 f0       	push   $0xf0129218
f011326b:	68 77 03 00 00       	push   $0x377
f0113270:	68 22 8a 12 f0       	push   $0xf0128a22
f0113275:	e8 5c d2 fe ff       	call   f01004d6 <_warn>
f011327a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011327d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113284:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113288:	74 04                	je     f011328e <test_copy_paste_chunk+0xc0e>
f011328a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011328e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113295:	83 ec 0c             	sub    $0xc,%esp
f0113298:	68 af 93 12 f0       	push   $0xf01293af
f011329d:	e8 e9 dc fe ff       	call   f0100f8b <cprintf>
f01132a2:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f01132a5:	83 ec 0c             	sub    $0xc,%esp
f01132a8:	68 c0 93 12 f0       	push   $0xf01293c0
f01132ad:	e8 d9 dc fe ff       	call   f0100f8b <cprintf>
f01132b2:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f01132b5:	83 ec 04             	sub    $0x4,%esp
f01132b8:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01132be:	50                   	push   %eax
f01132bf:	68 f4 93 12 f0       	push   $0xf01293f4
f01132c4:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01132ca:	50                   	push   %eax
f01132cb:	e8 88 c7 00 00       	call   f011fa58 <strcconcat>
f01132d0:	83 c4 10             	add    $0x10,%esp
f01132d3:	83 ec 0c             	sub    $0xc,%esp
f01132d6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01132dc:	50                   	push   %eax
f01132dd:	e8 19 ec fe ff       	call   f0101efb <execute_command>
f01132e2:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f01132e5:	83 ec 04             	sub    $0x4,%esp
f01132e8:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01132ee:	50                   	push   %eax
f01132ef:	68 fe 93 12 f0       	push   $0xf01293fe
f01132f4:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01132fa:	50                   	push   %eax
f01132fb:	e8 58 c7 00 00       	call   f011fa58 <strcconcat>
f0113300:	83 c4 10             	add    $0x10,%esp
f0113303:	83 ec 0c             	sub    $0xc,%esp
f0113306:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011330c:	50                   	push   %eax
f011330d:	e8 e9 eb fe ff       	call   f0101efb <execute_command>
f0113312:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113315:	83 ec 04             	sub    $0x4,%esp
f0113318:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011331e:	50                   	push   %eax
f011331f:	68 08 94 12 f0       	push   $0xf0129408
f0113324:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011332a:	50                   	push   %eax
f011332b:	e8 28 c7 00 00       	call   f011fa58 <strcconcat>
f0113330:	83 c4 10             	add    $0x10,%esp
f0113333:	83 ec 0c             	sub    $0xc,%esp
f0113336:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011333c:	50                   	push   %eax
f011333d:	e8 b9 eb fe ff       	call   f0101efb <execute_command>
f0113342:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113345:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011334b:	bb a1 9b 12 f0       	mov    $0xf0129ba1,%ebx
f0113350:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113355:	89 c7                	mov    %eax,%edi
f0113357:	89 de                	mov    %ebx,%esi
f0113359:	89 d1                	mov    %edx,%ecx
f011335b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011335d:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113363:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113368:	b0 00                	mov    $0x0,%al
f011336a:	89 d7                	mov    %edx,%edi
f011336c:	f3 aa                	rep stos %al,%es:(%edi)
f011336e:	83 ec 0c             	sub    $0xc,%esp
f0113371:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113377:	50                   	push   %eax
f0113378:	e8 7e eb fe ff       	call   f0101efb <execute_command>
f011337d:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0113380:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113386:	bb 05 9c 12 f0       	mov    $0xf0129c05,%ebx
f011338b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113390:	89 c7                	mov    %eax,%edi
f0113392:	89 de                	mov    %ebx,%esi
f0113394:	89 d1                	mov    %edx,%ecx
f0113396:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113398:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011339e:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133a3:	b0 00                	mov    $0x0,%al
f01133a5:	89 d7                	mov    %edx,%edi
f01133a7:	f3 aa                	rep stos %al,%es:(%edi)
f01133a9:	83 ec 0c             	sub    $0xc,%esp
f01133ac:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01133b2:	50                   	push   %eax
f01133b3:	e8 43 eb fe ff       	call   f0101efb <execute_command>
f01133b8:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f01133bb:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01133c1:	bb 69 9c 12 f0       	mov    $0xf0129c69,%ebx
f01133c6:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133cb:	89 c7                	mov    %eax,%edi
f01133cd:	89 de                	mov    %ebx,%esi
f01133cf:	89 d1                	mov    %edx,%ecx
f01133d1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133d3:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01133d9:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133de:	b0 00                	mov    $0x0,%al
f01133e0:	89 d7                	mov    %edx,%edi
f01133e2:	f3 aa                	rep stos %al,%es:(%edi)
f01133e4:	83 ec 0c             	sub    $0xc,%esp
f01133e7:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01133ed:	50                   	push   %eax
f01133ee:	e8 08 eb fe ff       	call   f0101efb <execute_command>
f01133f3:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01133f6:	e8 b1 ad ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01133fb:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f01133fe:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113401:	89 d0                	mov    %edx,%eax
f0113403:	01 c0                	add    %eax,%eax
f0113405:	01 d0                	add    %edx,%eax
f0113407:	c1 e0 02             	shl    $0x2,%eax
f011340a:	50                   	push   %eax
f011340b:	68 00 00 90 00       	push   $0x900000
f0113410:	68 00 00 80 00       	push   $0x800000
f0113415:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113418:	e8 48 6f ff ff       	call   f010a365 <copy_paste_chunk>
f011341d:	83 c4 10             	add    $0x10,%esp
f0113420:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113426:	e8 81 ad ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011342b:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011342e:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113435:	75 0b                	jne    f0113442 <test_copy_paste_chunk+0xdc2>
f0113437:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011343a:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011343d:	83 f8 03             	cmp    $0x3,%eax
f0113440:	74 2e                	je     f0113470 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113442:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113445:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113448:	83 ec 0c             	sub    $0xc,%esp
f011344b:	50                   	push   %eax
f011344c:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113452:	68 c4 92 12 f0       	push   $0xf01292c4
f0113457:	68 95 03 00 00       	push   $0x395
f011345c:	68 22 8a 12 f0       	push   $0xf0128a22
f0113461:	e8 70 d0 fe ff       	call   f01004d6 <_warn>
f0113466:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113469:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113470:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113474:	74 04                	je     f011347a <test_copy_paste_chunk+0xdfa>
f0113476:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011347a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0113481:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113488:	83 ec 08             	sub    $0x8,%esp
f011348b:	6a 01                	push   $0x1
f011348d:	6a 07                	push   $0x7
f011348f:	6a 07                	push   $0x7
f0113491:	6a 07                	push   $0x7
f0113493:	6a 07                	push   $0x7
f0113495:	6a 01                	push   $0x1
f0113497:	68 00 30 00 00       	push   $0x3000
f011349c:	68 00 00 90 00       	push   $0x900000
f01134a1:	68 00 00 80 00       	push   $0x800000
f01134a6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01134a9:	e8 26 2e 00 00       	call   f01162d4 <CCP>
f01134ae:	83 c4 30             	add    $0x30,%esp
f01134b1:	83 f8 01             	cmp    $0x1,%eax
f01134b4:	74 28                	je     f01134de <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01134b6:	83 ec 04             	sub    $0x4,%esp
f01134b9:	68 64 93 12 f0       	push   $0xf0129364
f01134be:	68 9e 03 00 00       	push   $0x39e
f01134c3:	68 22 8a 12 f0       	push   $0xf0128a22
f01134c8:	e8 09 d0 fe ff       	call   f01004d6 <_warn>
f01134cd:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01134d0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f01134d7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f01134de:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01134e2:	74 04                	je     f01134e8 <test_copy_paste_chunk+0xe68>
f01134e4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01134e8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f01134ef:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01134f3:	0f 84 9e 00 00 00    	je     f0113597 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f01134f9:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0113500:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113507:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f011350e:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113515:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f011351c:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113523:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113526:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113529:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011352c:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f011352f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113532:	8a 00                	mov    (%eax),%al
f0113534:	3c 61                	cmp    $0x61,%al
f0113536:	75 2d                	jne    f0113565 <test_copy_paste_chunk+0xee5>
f0113538:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011353b:	8a 00                	mov    (%eax),%al
f011353d:	3c 61                	cmp    $0x61,%al
f011353f:	75 24                	jne    f0113565 <test_copy_paste_chunk+0xee5>
f0113541:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113544:	8a 00                	mov    (%eax),%al
f0113546:	3c 79                	cmp    $0x79,%al
f0113548:	75 1b                	jne    f0113565 <test_copy_paste_chunk+0xee5>
f011354a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011354d:	8a 00                	mov    (%eax),%al
f011354f:	3c 62                	cmp    $0x62,%al
f0113551:	75 12                	jne    f0113565 <test_copy_paste_chunk+0xee5>
f0113553:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113556:	8a 00                	mov    (%eax),%al
f0113558:	3c 63                	cmp    $0x63,%al
f011355a:	75 09                	jne    f0113565 <test_copy_paste_chunk+0xee5>
f011355c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011355f:	8a 00                	mov    (%eax),%al
f0113561:	3c 7a                	cmp    $0x7a,%al
f0113563:	74 21                	je     f0113586 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113565:	83 ec 04             	sub    $0x4,%esp
f0113568:	68 18 92 12 f0       	push   $0xf0129218
f011356d:	68 b0 03 00 00       	push   $0x3b0
f0113572:	68 22 8a 12 f0       	push   $0xf0128a22
f0113577:	e8 5a cf fe ff       	call   f01004d6 <_warn>
f011357c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011357f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0113586:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011358a:	74 04                	je     f0113590 <test_copy_paste_chunk+0xf10>
f011358c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0113590:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113597:	e8 10 ac ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011359c:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f011359f:	6a 00                	push   $0x0
f01135a1:	6a 02                	push   $0x2
f01135a3:	68 00 10 90 00       	push   $0x901000
f01135a8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01135ab:	e8 b1 2b 00 00       	call   f0116161 <SB>
f01135b0:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f01135b3:	6a 00                	push   $0x0
f01135b5:	6a 02                	push   $0x2
f01135b7:	68 00 20 90 00       	push   $0x902000
f01135bc:	ff 75 d4             	pushl  -0x2c(%ebp)
f01135bf:	e8 9d 2b 00 00       	call   f0116161 <SB>
f01135c4:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f01135c7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01135ca:	c1 e0 03             	shl    $0x3,%eax
f01135cd:	50                   	push   %eax
f01135ce:	68 00 f0 bf 00       	push   $0xbff000
f01135d3:	68 00 10 90 00       	push   $0x901000
f01135d8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01135db:	e8 85 6d ff ff       	call   f010a365 <copy_paste_chunk>
f01135e0:	83 c4 10             	add    $0x10,%esp
f01135e3:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01135e9:	e8 be ab ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01135ee:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f01135f1:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f01135f8:	75 0b                	jne    f0113605 <test_copy_paste_chunk+0xf85>
f01135fa:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01135fd:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113600:	83 f8 03             	cmp    $0x3,%eax
f0113603:	74 2e                	je     f0113633 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113605:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113608:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011360b:	83 ec 0c             	sub    $0xc,%esp
f011360e:	50                   	push   %eax
f011360f:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113615:	68 c4 92 12 f0       	push   $0xf01292c4
f011361a:	68 c0 03 00 00       	push   $0x3c0
f011361f:	68 22 8a 12 f0       	push   $0xf0128a22
f0113624:	e8 ad ce fe ff       	call   f01004d6 <_warn>
f0113629:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011362c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113633:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113637:	74 04                	je     f011363d <test_copy_paste_chunk+0xfbd>
f0113639:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011363d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0113644:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f011364b:	83 ec 08             	sub    $0x8,%esp
f011364e:	6a 01                	push   $0x1
f0113650:	6a 07                	push   $0x7
f0113652:	6a 03                	push   $0x3
f0113654:	6a 07                	push   $0x7
f0113656:	6a 03                	push   $0x3
f0113658:	6a 01                	push   $0x1
f011365a:	68 00 20 00 00       	push   $0x2000
f011365f:	68 00 f0 bf 00       	push   $0xbff000
f0113664:	68 00 10 90 00       	push   $0x901000
f0113669:	ff 75 d4             	pushl  -0x2c(%ebp)
f011366c:	e8 63 2c 00 00       	call   f01162d4 <CCP>
f0113671:	83 c4 30             	add    $0x30,%esp
f0113674:	83 f8 01             	cmp    $0x1,%eax
f0113677:	74 28                	je     f01136a1 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113679:	83 ec 04             	sub    $0x4,%esp
f011367c:	68 64 93 12 f0       	push   $0xf0129364
f0113681:	68 c9 03 00 00       	push   $0x3c9
f0113686:	68 22 8a 12 f0       	push   $0xf0128a22
f011368b:	e8 46 ce fe ff       	call   f01004d6 <_warn>
f0113690:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113693:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f011369a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f01136a1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01136a5:	74 04                	je     f01136ab <test_copy_paste_chunk+0x102b>
f01136a7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01136ab:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f01136b2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01136b6:	74 72                	je     f011372a <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f01136b8:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f01136bf:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f01136c6:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f01136cd:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f01136d4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01136d7:	8a 00                	mov    (%eax),%al
f01136d9:	3c 62                	cmp    $0x62,%al
f01136db:	75 1b                	jne    f01136f8 <test_copy_paste_chunk+0x1078>
f01136dd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01136e0:	8a 00                	mov    (%eax),%al
f01136e2:	3c 62                	cmp    $0x62,%al
f01136e4:	75 12                	jne    f01136f8 <test_copy_paste_chunk+0x1078>
f01136e6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01136e9:	8a 00                	mov    (%eax),%al
f01136eb:	3c 7a                	cmp    $0x7a,%al
f01136ed:	75 09                	jne    f01136f8 <test_copy_paste_chunk+0x1078>
f01136ef:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01136f2:	8a 00                	mov    (%eax),%al
f01136f4:	3c 7a                	cmp    $0x7a,%al
f01136f6:	74 21                	je     f0113719 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01136f8:	83 ec 04             	sub    $0x4,%esp
f01136fb:	68 18 92 12 f0       	push   $0xf0129218
f0113700:	68 d5 03 00 00       	push   $0x3d5
f0113705:	68 22 8a 12 f0       	push   $0xf0128a22
f011370a:	e8 c7 cd fe ff       	call   f01004d6 <_warn>
f011370f:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113712:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0113719:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011371d:	74 04                	je     f0113723 <test_copy_paste_chunk+0x10a3>
f011371f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113723:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f011372a:	83 ec 0c             	sub    $0xc,%esp
f011372d:	68 12 94 12 f0       	push   $0xf0129412
f0113732:	e8 54 d8 fe ff       	call   f0100f8b <cprintf>
f0113737:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f011373a:	83 ec 08             	sub    $0x8,%esp
f011373d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113740:	68 24 94 12 f0       	push   $0xf0129424
f0113745:	e8 41 d8 fe ff       	call   f0100f8b <cprintf>
f011374a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011374d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0113751:	75 10                	jne    f0113763 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0113753:	83 ec 0c             	sub    $0xc,%esp
f0113756:	68 58 94 12 f0       	push   $0xf0129458
f011375b:	e8 2b d8 fe ff       	call   f0100f8b <cprintf>
f0113760:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113763:	a1 a4 ba 6b f0       	mov    0xf06bbaa4,%eax
f0113768:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011376b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011376e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113771:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113776:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113779:	5b                   	pop    %ebx
f011377a:	5e                   	pop    %esi
f011377b:	5f                   	pop    %edi
f011377c:	5d                   	pop    %ebp
f011377d:	c3                   	ret    

f011377e <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f011377e:	55                   	push   %ebp
f011377f:	89 e5                	mov    %esp,%ebp
f0113781:	57                   	push   %edi
f0113782:	56                   	push   %esi
f0113783:	53                   	push   %ebx
f0113784:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011378a:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113790:	bb 24 91 12 f0       	mov    $0xf0129124,%ebx
f0113795:	ba 0f 00 00 00       	mov    $0xf,%edx
f011379a:	89 c7                	mov    %eax,%edi
f011379c:	89 de                	mov    %ebx,%esi
f011379e:	89 d1                	mov    %edx,%ecx
f01137a0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01137a2:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f01137a8:	b9 23 00 00 00       	mov    $0x23,%ecx
f01137ad:	b0 00                	mov    $0x0,%al
f01137af:	89 d7                	mov    %edx,%edi
f01137b1:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01137b3:	6a 00                	push   $0x0
f01137b5:	6a 0a                	push   $0xa
f01137b7:	6a 14                	push   $0x14
f01137b9:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f01137bf:	50                   	push   %eax
f01137c0:	e8 47 70 ff ff       	call   f010a80c <env_create>
f01137c5:	83 c4 10             	add    $0x10,%esp
f01137c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01137cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01137ce:	8b 40 64             	mov    0x64(%eax),%eax
f01137d1:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f01137d4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01137d7:	8b 40 68             	mov    0x68(%eax),%eax
f01137da:	89 45 80             	mov    %eax,-0x80(%ebp)
f01137dd:	8b 45 80             	mov    -0x80(%ebp),%eax
f01137e0:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f01137e3:	83 ec 0c             	sub    $0xc,%esp
f01137e6:	ff 75 cc             	pushl  -0x34(%ebp)
f01137e9:	e8 b2 2a 00 00       	call   f01162a0 <ClearUserSpace>
f01137ee:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01137f1:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f01137f8:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f01137ff:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0113806:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f011380a:	83 ec 0c             	sub    $0xc,%esp
f011380d:	68 d0 9c 12 f0       	push   $0xf0129cd0
f0113812:	e8 74 d7 fe ff       	call   f0100f8b <cprintf>
f0113817:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f011381a:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0113821:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0113828:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011382b:	8a 00                	mov    (%eax),%al
f011382d:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0113833:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113836:	8a 00                	mov    (%eax),%al
f0113838:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f011383e:	e8 69 a9 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0113843:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0113846:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113849:	89 d0                	mov    %edx,%eax
f011384b:	01 c0                	add    %eax,%eax
f011384d:	01 d0                	add    %edx,%eax
f011384f:	01 c0                	add    %eax,%eax
f0113851:	83 ec 0c             	sub    $0xc,%esp
f0113854:	6a 02                	push   $0x2
f0113856:	50                   	push   %eax
f0113857:	68 00 40 10 f0       	push   $0xf0104000
f011385c:	68 00 00 10 f0       	push   $0xf0100000
f0113861:	ff 75 cc             	pushl  -0x34(%ebp)
f0113864:	e8 16 6b ff ff       	call   f010a37f <share_chunk>
f0113869:	83 c4 20             	add    $0x20,%esp
f011386c:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011386f:	e8 38 a9 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0113874:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0113877:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f011387b:	75 08                	jne    f0113885 <test_share_chunk+0x107>
f011387d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113880:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113883:	74 28                	je     f01138ad <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0113885:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113888:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011388b:	83 ec 0c             	sub    $0xc,%esp
f011388e:	50                   	push   %eax
f011388f:	ff 75 b0             	pushl  -0x50(%ebp)
f0113892:	68 fc 9c 12 f0       	push   $0xf0129cfc
f0113897:	68 11 04 00 00       	push   $0x411
f011389c:	68 22 8a 12 f0       	push   $0xf0128a22
f01138a1:	e8 30 cc fe ff       	call   f01004d6 <_warn>
f01138a6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01138a9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01138ad:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01138b1:	74 04                	je     f01138b7 <test_share_chunk+0x139>
f01138b3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01138b7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f01138bb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01138be:	c1 e0 03             	shl    $0x3,%eax
f01138c1:	83 ec 08             	sub    $0x8,%esp
f01138c4:	68 fd 00 00 00       	push   $0xfd
f01138c9:	6a 07                	push   $0x7
f01138cb:	6a 03                	push   $0x3
f01138cd:	6a 07                	push   $0x7
f01138cf:	6a 03                	push   $0x3
f01138d1:	6a 01                	push   $0x1
f01138d3:	50                   	push   %eax
f01138d4:	68 00 40 10 f0       	push   $0xf0104000
f01138d9:	68 00 00 10 f0       	push   $0xf0100000
f01138de:	ff 75 cc             	pushl  -0x34(%ebp)
f01138e1:	e8 ee 29 00 00       	call   f01162d4 <CCP>
f01138e6:	83 c4 30             	add    $0x30,%esp
f01138e9:	85 c0                	test   %eax,%eax
f01138eb:	75 1e                	jne    f011390b <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01138ed:	83 ec 04             	sub    $0x4,%esp
f01138f0:	68 58 9d 12 f0       	push   $0xf0129d58
f01138f5:	68 19 04 00 00       	push   $0x419
f01138fa:	68 22 8a 12 f0       	push   $0xf0128a22
f01138ff:	e8 d2 cb fe ff       	call   f01004d6 <_warn>
f0113904:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113907:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011390b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011390f:	74 04                	je     f0113915 <test_share_chunk+0x197>
f0113911:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0113915:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113918:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f011391b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011391e:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0113921:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113924:	8a 00                	mov    (%eax),%al
f0113926:	3c 41                	cmp    $0x41,%al
f0113928:	75 09                	jne    f0113933 <test_share_chunk+0x1b5>
f011392a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011392d:	8a 00                	mov    (%eax),%al
f011392f:	3c 42                	cmp    $0x42,%al
f0113931:	74 1e                	je     f0113951 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113933:	83 ec 04             	sub    $0x4,%esp
f0113936:	68 a0 9d 12 f0       	push   $0xf0129da0
f011393b:	68 23 04 00 00       	push   $0x423
f0113940:	68 22 8a 12 f0       	push   $0xf0128a22
f0113945:	e8 8c cb fe ff       	call   f01004d6 <_warn>
f011394a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011394d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0113951:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113955:	74 04                	je     f011395b <test_share_chunk+0x1dd>
f0113957:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011395b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f011395f:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0113965:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113968:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f011396a:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0113970:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113973:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0113975:	83 ec 0c             	sub    $0xc,%esp
f0113978:	68 d5 9d 12 f0       	push   $0xf0129dd5
f011397d:	e8 09 d6 fe ff       	call   f0100f8b <cprintf>
f0113982:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0113985:	83 ec 0c             	sub    $0xc,%esp
f0113988:	68 e4 9d 12 f0       	push   $0xf0129de4
f011398d:	e8 f9 d5 fe ff       	call   f0100f8b <cprintf>
f0113992:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113995:	e8 12 a8 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011399a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f011399d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01139a0:	c1 e0 05             	shl    $0x5,%eax
f01139a3:	83 ec 0c             	sub    $0xc,%esp
f01139a6:	68 02 0e 00 00       	push   $0xe02
f01139ab:	50                   	push   %eax
f01139ac:	68 00 00 00 40       	push   $0x40000000
f01139b1:	68 00 00 00 f0       	push   $0xf0000000
f01139b6:	ff 75 cc             	pushl  -0x34(%ebp)
f01139b9:	e8 c1 69 ff ff       	call   f010a37f <share_chunk>
f01139be:	83 c4 20             	add    $0x20,%esp
f01139c1:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01139c4:	e8 e3 a7 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01139c9:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f01139cc:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01139d0:	75 1f                	jne    f01139f1 <test_share_chunk+0x273>
f01139d2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01139d5:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01139d8:	89 c1                	mov    %eax,%ecx
f01139da:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01139dd:	c1 e0 05             	shl    $0x5,%eax
f01139e0:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01139e3:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01139ea:	99                   	cltd   
f01139eb:	f7 fb                	idiv   %ebx
f01139ed:	39 c1                	cmp    %eax,%ecx
f01139ef:	74 28                	je     f0113a19 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01139f1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01139f4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01139f7:	83 ec 0c             	sub    $0xc,%esp
f01139fa:	50                   	push   %eax
f01139fb:	ff 75 a8             	pushl  -0x58(%ebp)
f01139fe:	68 20 9e 12 f0       	push   $0xf0129e20
f0113a03:	68 3b 04 00 00       	push   $0x43b
f0113a08:	68 22 8a 12 f0       	push   $0xf0128a22
f0113a0d:	e8 c4 ca fe ff       	call   f01004d6 <_warn>
f0113a12:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113a15:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113a19:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113a1d:	74 04                	je     f0113a23 <test_share_chunk+0x2a5>
f0113a1f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113a23:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113a27:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113a2e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113a31:	c1 e0 05             	shl    $0x5,%eax
f0113a34:	83 ec 08             	sub    $0x8,%esp
f0113a37:	6a 02                	push   $0x2
f0113a39:	6a 07                	push   $0x7
f0113a3b:	6a 03                	push   $0x3
f0113a3d:	68 07 0e 00 00       	push   $0xe07
f0113a42:	68 03 0e 00 00       	push   $0xe03
f0113a47:	6a ff                	push   $0xffffffff
f0113a49:	50                   	push   %eax
f0113a4a:	68 00 00 00 40       	push   $0x40000000
f0113a4f:	68 00 00 00 f0       	push   $0xf0000000
f0113a54:	ff 75 cc             	pushl  -0x34(%ebp)
f0113a57:	e8 78 28 00 00       	call   f01162d4 <CCP>
f0113a5c:	83 c4 30             	add    $0x30,%esp
f0113a5f:	85 c0                	test   %eax,%eax
f0113a61:	75 25                	jne    f0113a88 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113a63:	83 ec 04             	sub    $0x4,%esp
f0113a66:	68 58 9d 12 f0       	push   $0xf0129d58
f0113a6b:	68 44 04 00 00       	push   $0x444
f0113a70:	68 22 8a 12 f0       	push   $0xf0128a22
f0113a75:	e8 5c ca fe ff       	call   f01004d6 <_warn>
f0113a7a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113a7d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113a81:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113a88:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113a8b:	89 d0                	mov    %edx,%eax
f0113a8d:	01 c0                	add    %eax,%eax
f0113a8f:	01 d0                	add    %edx,%eax
f0113a91:	c1 e0 02             	shl    $0x2,%eax
f0113a94:	83 ec 08             	sub    $0x8,%esp
f0113a97:	6a 02                	push   $0x2
f0113a99:	6a 07                	push   $0x7
f0113a9b:	6a 03                	push   $0x3
f0113a9d:	68 07 0e 00 00       	push   $0xe07
f0113aa2:	68 03 0e 00 00       	push   $0xe03
f0113aa7:	6a 02                	push   $0x2
f0113aa9:	50                   	push   %eax
f0113aaa:	68 00 00 00 40       	push   $0x40000000
f0113aaf:	68 00 00 00 f0       	push   $0xf0000000
f0113ab4:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ab7:	e8 18 28 00 00       	call   f01162d4 <CCP>
f0113abc:	83 c4 30             	add    $0x30,%esp
f0113abf:	85 c0                	test   %eax,%eax
f0113ac1:	75 1e                	jne    f0113ae1 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113ac3:	83 ec 04             	sub    $0x4,%esp
f0113ac6:	68 58 9d 12 f0       	push   $0xf0129d58
f0113acb:	68 4b 04 00 00       	push   $0x44b
f0113ad0:	68 22 8a 12 f0       	push   $0xf0128a22
f0113ad5:	e8 fc c9 fe ff       	call   f01004d6 <_warn>
f0113ada:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113add:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113ae1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113ae5:	74 04                	je     f0113aeb <test_share_chunk+0x36d>
f0113ae7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113aeb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0113aef:	b8 90 64 b0 f0       	mov    $0xf0b06490,%eax
f0113af4:	05 00 00 00 10       	add    $0x10000000,%eax
f0113af9:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113afc:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113aff:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0113b04:	83 ec 08             	sub    $0x8,%esp
f0113b07:	6a 02                	push   $0x2
f0113b09:	6a 07                	push   $0x7
f0113b0b:	6a 03                	push   $0x3
f0113b0d:	68 07 0e 00 00       	push   $0xe07
f0113b12:	68 03 0e 00 00       	push   $0xe03
f0113b17:	6a 02                	push   $0x2
f0113b19:	50                   	push   %eax
f0113b1a:	68 00 00 0a 40       	push   $0x400a0000
f0113b1f:	68 00 00 0a f0       	push   $0xf00a0000
f0113b24:	ff 75 cc             	pushl  -0x34(%ebp)
f0113b27:	e8 a8 27 00 00       	call   f01162d4 <CCP>
f0113b2c:	83 c4 30             	add    $0x30,%esp
f0113b2f:	85 c0                	test   %eax,%eax
f0113b31:	75 1e                	jne    f0113b51 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113b33:	83 ec 04             	sub    $0x4,%esp
f0113b36:	68 58 9d 12 f0       	push   $0xf0129d58
f0113b3b:	68 55 04 00 00       	push   $0x455
f0113b40:	68 22 8a 12 f0       	push   $0xf0128a22
f0113b45:	e8 8c c9 fe ff       	call   f01004d6 <_warn>
f0113b4a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113b4d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113b51:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113b55:	74 04                	je     f0113b5b <test_share_chunk+0x3dd>
f0113b57:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113b5b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0113b5f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113b63:	0f 84 a4 00 00 00    	je     f0113c0d <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0113b69:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0113b70:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113b73:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0113b76:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0113b7d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113b80:	8a 00                	mov    (%eax),%al
f0113b82:	3c 41                	cmp    $0x41,%al
f0113b84:	75 09                	jne    f0113b8f <test_share_chunk+0x411>
f0113b86:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113b89:	8a 00                	mov    (%eax),%al
f0113b8b:	3c 41                	cmp    $0x41,%al
f0113b8d:	74 1e                	je     f0113bad <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113b8f:	83 ec 04             	sub    $0x4,%esp
f0113b92:	68 a0 9d 12 f0       	push   $0xf0129da0
f0113b97:	68 62 04 00 00       	push   $0x462
f0113b9c:	68 22 8a 12 f0       	push   $0xf0128a22
f0113ba1:	e8 30 c9 fe ff       	call   f01004d6 <_warn>
f0113ba6:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113ba9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113bad:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113bb1:	74 04                	je     f0113bb7 <test_share_chunk+0x439>
f0113bb3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113bb7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0113bbb:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0113bc2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113bc5:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0113bc8:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0113bcf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113bd2:	8a 00                	mov    (%eax),%al
f0113bd4:	3c 43                	cmp    $0x43,%al
f0113bd6:	75 09                	jne    f0113be1 <test_share_chunk+0x463>
f0113bd8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113bdb:	8a 00                	mov    (%eax),%al
f0113bdd:	3c 43                	cmp    $0x43,%al
f0113bdf:	74 1e                	je     f0113bff <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113be1:	83 ec 04             	sub    $0x4,%esp
f0113be4:	68 a0 9d 12 f0       	push   $0xf0129da0
f0113be9:	68 6d 04 00 00       	push   $0x46d
f0113bee:	68 22 8a 12 f0       	push   $0xf0128a22
f0113bf3:	e8 de c8 fe ff       	call   f01004d6 <_warn>
f0113bf8:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113bfb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113bff:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113c03:	74 04                	je     f0113c09 <test_share_chunk+0x48b>
f0113c05:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113c09:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0113c0d:	83 ec 0c             	sub    $0xc,%esp
f0113c10:	68 af 93 12 f0       	push   $0xf01293af
f0113c15:	e8 71 d3 fe ff       	call   f0100f8b <cprintf>
f0113c1a:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0113c1d:	83 ec 0c             	sub    $0xc,%esp
f0113c20:	68 70 9e 12 f0       	push   $0xf0129e70
f0113c25:	e8 61 d3 fe ff       	call   f0100f8b <cprintf>
f0113c2a:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113c2d:	e8 7a a5 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0113c32:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0113c35:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113c38:	89 d0                	mov    %edx,%eax
f0113c3a:	c1 e0 03             	shl    $0x3,%eax
f0113c3d:	01 d0                	add    %edx,%eax
f0113c3f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0113c46:	01 d0                	add    %edx,%eax
f0113c48:	c1 e0 03             	shl    $0x3,%eax
f0113c4b:	83 ec 0c             	sub    $0xc,%esp
f0113c4e:	6a 06                	push   $0x6
f0113c50:	50                   	push   %eax
f0113c51:	6a 00                	push   $0x0
f0113c53:	68 00 00 00 40       	push   $0x40000000
f0113c58:	ff 75 cc             	pushl  -0x34(%ebp)
f0113c5b:	e8 1f 67 ff ff       	call   f010a37f <share_chunk>
f0113c60:	83 c4 20             	add    $0x20,%esp
f0113c63:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113c66:	e8 41 a5 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0113c6b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0113c6e:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0113c72:	75 0b                	jne    f0113c7f <test_share_chunk+0x501>
f0113c74:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113c77:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113c7a:	83 f8 01             	cmp    $0x1,%eax
f0113c7d:	74 28                	je     f0113ca7 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113c7f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113c82:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113c85:	83 ec 0c             	sub    $0xc,%esp
f0113c88:	50                   	push   %eax
f0113c89:	ff 75 a0             	pushl  -0x60(%ebp)
f0113c8c:	68 20 9e 12 f0       	push   $0xf0129e20
f0113c91:	68 83 04 00 00       	push   $0x483
f0113c96:	68 22 8a 12 f0       	push   $0xf0128a22
f0113c9b:	e8 36 c8 fe ff       	call   f01004d6 <_warn>
f0113ca0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113ca3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113ca7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113cab:	74 04                	je     f0113cb1 <test_share_chunk+0x533>
f0113cad:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113cb1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113cb5:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113cbc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113cbf:	05 00 80 02 00       	add    $0x28000,%eax
f0113cc4:	c1 e0 02             	shl    $0x2,%eax
f0113cc7:	83 ec 08             	sub    $0x8,%esp
f0113cca:	6a 02                	push   $0x2
f0113ccc:	6a 07                	push   $0x7
f0113cce:	6a 03                	push   $0x3
f0113cd0:	6a 07                	push   $0x7
f0113cd2:	6a 07                	push   $0x7
f0113cd4:	6a ff                	push   $0xffffffff
f0113cd6:	50                   	push   %eax
f0113cd7:	6a 00                	push   $0x0
f0113cd9:	68 00 00 00 40       	push   $0x40000000
f0113cde:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ce1:	e8 ee 25 00 00       	call   f01162d4 <CCP>
f0113ce6:	83 c4 30             	add    $0x30,%esp
f0113ce9:	85 c0                	test   %eax,%eax
f0113ceb:	75 25                	jne    f0113d12 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113ced:	83 ec 04             	sub    $0x4,%esp
f0113cf0:	68 58 9d 12 f0       	push   $0xf0129d58
f0113cf5:	68 8c 04 00 00       	push   $0x48c
f0113cfa:	68 22 8a 12 f0       	push   $0xf0128a22
f0113cff:	e8 d2 c7 fe ff       	call   f01004d6 <_warn>
f0113d04:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113d07:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113d0b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113d12:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d15:	89 d0                	mov    %edx,%eax
f0113d17:	01 c0                	add    %eax,%eax
f0113d19:	01 d0                	add    %edx,%eax
f0113d1b:	c1 e0 02             	shl    $0x2,%eax
f0113d1e:	83 ec 08             	sub    $0x8,%esp
f0113d21:	6a 02                	push   $0x2
f0113d23:	6a 07                	push   $0x7
f0113d25:	6a 03                	push   $0x3
f0113d27:	6a 07                	push   $0x7
f0113d29:	6a 07                	push   $0x7
f0113d2b:	6a 03                	push   $0x3
f0113d2d:	50                   	push   %eax
f0113d2e:	6a 00                	push   $0x0
f0113d30:	68 00 00 00 40       	push   $0x40000000
f0113d35:	ff 75 cc             	pushl  -0x34(%ebp)
f0113d38:	e8 97 25 00 00       	call   f01162d4 <CCP>
f0113d3d:	83 c4 30             	add    $0x30,%esp
f0113d40:	85 c0                	test   %eax,%eax
f0113d42:	75 1e                	jne    f0113d62 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113d44:	83 ec 04             	sub    $0x4,%esp
f0113d47:	68 58 9d 12 f0       	push   $0xf0129d58
f0113d4c:	68 93 04 00 00       	push   $0x493
f0113d51:	68 22 8a 12 f0       	push   $0xf0128a22
f0113d56:	e8 7b c7 fe ff       	call   f01004d6 <_warn>
f0113d5b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113d5e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113d62:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113d66:	74 04                	je     f0113d6c <test_share_chunk+0x5ee>
f0113d68:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113d6c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113d70:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d73:	89 d0                	mov    %edx,%eax
f0113d75:	01 c0                	add    %eax,%eax
f0113d77:	01 d0                	add    %edx,%eax
f0113d79:	c1 e0 02             	shl    $0x2,%eax
f0113d7c:	f7 d8                	neg    %eax
f0113d7e:	05 00 00 0a 00       	add    $0xa0000,%eax
f0113d83:	83 ec 08             	sub    $0x8,%esp
f0113d86:	6a 02                	push   $0x2
f0113d88:	6a 07                	push   $0x7
f0113d8a:	6a 03                	push   $0x3
f0113d8c:	6a 07                	push   $0x7
f0113d8e:	6a 07                	push   $0x7
f0113d90:	6a 02                	push   $0x2
f0113d92:	50                   	push   %eax
f0113d93:	68 00 30 00 00       	push   $0x3000
f0113d98:	68 00 30 00 40       	push   $0x40003000
f0113d9d:	ff 75 cc             	pushl  -0x34(%ebp)
f0113da0:	e8 2f 25 00 00       	call   f01162d4 <CCP>
f0113da5:	83 c4 30             	add    $0x30,%esp
f0113da8:	85 c0                	test   %eax,%eax
f0113daa:	75 1e                	jne    f0113dca <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113dac:	83 ec 04             	sub    $0x4,%esp
f0113daf:	68 58 9d 12 f0       	push   $0xf0129d58
f0113db4:	68 9b 04 00 00       	push   $0x49b
f0113db9:	68 22 8a 12 f0       	push   $0xf0128a22
f0113dbe:	e8 13 c7 fe ff       	call   f01004d6 <_warn>
f0113dc3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113dc6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113dca:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113dce:	74 04                	je     f0113dd4 <test_share_chunk+0x656>
f0113dd0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113dd4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113dd8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113ddb:	c1 e0 02             	shl    $0x2,%eax
f0113dde:	83 ec 08             	sub    $0x8,%esp
f0113de1:	6a 02                	push   $0x2
f0113de3:	6a 07                	push   $0x7
f0113de5:	6a 03                	push   $0x3
f0113de7:	6a 07                	push   $0x7
f0113de9:	6a 07                	push   $0x7
f0113deb:	6a 03                	push   $0x3
f0113ded:	50                   	push   %eax
f0113dee:	68 00 00 0a 00       	push   $0xa0000
f0113df3:	68 00 00 0a 40       	push   $0x400a0000
f0113df8:	ff 75 cc             	pushl  -0x34(%ebp)
f0113dfb:	e8 d4 24 00 00       	call   f01162d4 <CCP>
f0113e00:	83 c4 30             	add    $0x30,%esp
f0113e03:	85 c0                	test   %eax,%eax
f0113e05:	75 1e                	jne    f0113e25 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113e07:	83 ec 04             	sub    $0x4,%esp
f0113e0a:	68 58 9d 12 f0       	push   $0xf0129d58
f0113e0f:	68 a3 04 00 00       	push   $0x4a3
f0113e14:	68 22 8a 12 f0       	push   $0xf0128a22
f0113e19:	e8 b8 c6 fe ff       	call   f01004d6 <_warn>
f0113e1e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e21:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113e25:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113e29:	74 04                	je     f0113e2f <test_share_chunk+0x6b1>
f0113e2b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113e2f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0113e33:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0113e37:	0f 84 92 00 00 00    	je     f0113ecf <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0113e3d:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0113e44:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0113e4b:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0113e52:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0113e59:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113e5c:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0113e5f:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0113e66:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0113e6d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e70:	8a 00                	mov    (%eax),%al
f0113e72:	3c 41                	cmp    $0x41,%al
f0113e74:	75 2d                	jne    f0113ea3 <test_share_chunk+0x725>
f0113e76:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e79:	8a 00                	mov    (%eax),%al
f0113e7b:	3c 41                	cmp    $0x41,%al
f0113e7d:	75 24                	jne    f0113ea3 <test_share_chunk+0x725>
f0113e7f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113e82:	8a 00                	mov    (%eax),%al
f0113e84:	3c 41                	cmp    $0x41,%al
f0113e86:	75 1b                	jne    f0113ea3 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0113e88:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113e8b:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0113e8d:	3c 44                	cmp    $0x44,%al
f0113e8f:	75 12                	jne    f0113ea3 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0113e91:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113e94:	8a 00                	mov    (%eax),%al
f0113e96:	3c 44                	cmp    $0x44,%al
f0113e98:	75 09                	jne    f0113ea3 <test_share_chunk+0x725>
f0113e9a:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113e9d:	8a 00                	mov    (%eax),%al
f0113e9f:	3c 44                	cmp    $0x44,%al
f0113ea1:	74 1e                	je     f0113ec1 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113ea3:	83 ec 04             	sub    $0x4,%esp
f0113ea6:	68 a0 9d 12 f0       	push   $0xf0129da0
f0113eab:	68 b5 04 00 00       	push   $0x4b5
f0113eb0:	68 22 8a 12 f0       	push   $0xf0128a22
f0113eb5:	e8 1c c6 fe ff       	call   f01004d6 <_warn>
f0113eba:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113ebd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113ec1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113ec5:	74 04                	je     f0113ecb <test_share_chunk+0x74d>
f0113ec7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113ecb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113ecf:	83 ec 0c             	sub    $0xc,%esp
f0113ed2:	68 12 94 12 f0       	push   $0xf0129412
f0113ed7:	e8 af d0 fe ff       	call   f0100f8b <cprintf>
f0113edc:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0113edf:	83 ec 0c             	sub    $0xc,%esp
f0113ee2:	68 ac 9e 12 f0       	push   $0xf0129eac
f0113ee7:	e8 9f d0 fe ff       	call   f0100f8b <cprintf>
f0113eec:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113eef:	e8 b8 a2 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0113ef4:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0113ef7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113efa:	89 d0                	mov    %edx,%eax
f0113efc:	01 c0                	add    %eax,%eax
f0113efe:	01 d0                	add    %edx,%eax
f0113f00:	01 c0                	add    %eax,%eax
f0113f02:	01 d0                	add    %edx,%eax
f0113f04:	83 ec 0c             	sub    $0xc,%esp
f0113f07:	6a 04                	push   $0x4
f0113f09:	50                   	push   %eax
f0113f0a:	68 00 fc 3f 00       	push   $0x3ffc00
f0113f0f:	68 00 fc 09 00       	push   $0x9fc00
f0113f14:	ff 75 cc             	pushl  -0x34(%ebp)
f0113f17:	e8 63 64 ff ff       	call   f010a37f <share_chunk>
f0113f1c:	83 c4 20             	add    $0x20,%esp
f0113f1f:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113f22:	e8 85 a2 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0113f27:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0113f2a:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0113f2e:	75 0b                	jne    f0113f3b <test_share_chunk+0x7bd>
f0113f30:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113f33:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113f36:	83 f8 01             	cmp    $0x1,%eax
f0113f39:	74 28                	je     f0113f63 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113f3b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113f3e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113f41:	83 ec 0c             	sub    $0xc,%esp
f0113f44:	50                   	push   %eax
f0113f45:	ff 75 8c             	pushl  -0x74(%ebp)
f0113f48:	68 20 9e 12 f0       	push   $0xf0129e20
f0113f4d:	68 cb 04 00 00       	push   $0x4cb
f0113f52:	68 22 8a 12 f0       	push   $0xf0128a22
f0113f57:	e8 7a c5 fe ff       	call   f01004d6 <_warn>
f0113f5c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113f5f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0113f63:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113f67:	74 04                	je     f0113f6d <test_share_chunk+0x7ef>
f0113f69:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113f6d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113f71:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0113f78:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113f7b:	89 d0                	mov    %edx,%eax
f0113f7d:	01 c0                	add    %eax,%eax
f0113f7f:	01 d0                	add    %edx,%eax
f0113f81:	c1 e0 02             	shl    $0x2,%eax
f0113f84:	83 ec 08             	sub    $0x8,%esp
f0113f87:	6a 02                	push   $0x2
f0113f89:	6a 07                	push   $0x7
f0113f8b:	6a 07                	push   $0x7
f0113f8d:	6a 07                	push   $0x7
f0113f8f:	6a 05                	push   $0x5
f0113f91:	6a ff                	push   $0xffffffff
f0113f93:	50                   	push   %eax
f0113f94:	68 00 f0 3f 00       	push   $0x3ff000
f0113f99:	68 00 f0 09 00       	push   $0x9f000
f0113f9e:	ff 75 cc             	pushl  -0x34(%ebp)
f0113fa1:	e8 2e 23 00 00       	call   f01162d4 <CCP>
f0113fa6:	83 c4 30             	add    $0x30,%esp
f0113fa9:	85 c0                	test   %eax,%eax
f0113fab:	75 25                	jne    f0113fd2 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113fad:	83 ec 04             	sub    $0x4,%esp
f0113fb0:	68 58 9d 12 f0       	push   $0xf0129d58
f0113fb5:	68 d4 04 00 00       	push   $0x4d4
f0113fba:	68 22 8a 12 f0       	push   $0xf0128a22
f0113fbf:	e8 12 c5 fe ff       	call   f01004d6 <_warn>
f0113fc4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113fc7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113fcb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0113fd2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113fd6:	74 04                	je     f0113fdc <test_share_chunk+0x85e>
f0113fd8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113fdc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0113fe0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113fe3:	c1 e0 02             	shl    $0x2,%eax
f0113fe6:	83 ec 08             	sub    $0x8,%esp
f0113fe9:	6a 02                	push   $0x2
f0113feb:	6a 07                	push   $0x7
f0113fed:	6a 07                	push   $0x7
f0113fef:	6a 07                	push   $0x7
f0113ff1:	6a 05                	push   $0x5
f0113ff3:	6a 03                	push   $0x3
f0113ff5:	50                   	push   %eax
f0113ff6:	68 00 f0 3f 00       	push   $0x3ff000
f0113ffb:	68 00 f0 09 00       	push   $0x9f000
f0114000:	ff 75 cc             	pushl  -0x34(%ebp)
f0114003:	e8 cc 22 00 00       	call   f01162d4 <CCP>
f0114008:	83 c4 30             	add    $0x30,%esp
f011400b:	85 c0                	test   %eax,%eax
f011400d:	75 1e                	jne    f011402d <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011400f:	83 ec 04             	sub    $0x4,%esp
f0114012:	68 58 9d 12 f0       	push   $0xf0129d58
f0114017:	68 dd 04 00 00       	push   $0x4dd
f011401c:	68 22 8a 12 f0       	push   $0xf0128a22
f0114021:	e8 b0 c4 fe ff       	call   f01004d6 <_warn>
f0114026:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114029:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011402d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114031:	74 04                	je     f0114037 <test_share_chunk+0x8b9>
f0114033:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114037:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011403b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011403e:	c1 e0 03             	shl    $0x3,%eax
f0114041:	83 ec 08             	sub    $0x8,%esp
f0114044:	6a 02                	push   $0x2
f0114046:	6a 07                	push   $0x7
f0114048:	6a 07                	push   $0x7
f011404a:	6a 07                	push   $0x7
f011404c:	6a 05                	push   $0x5
f011404e:	6a 04                	push   $0x4
f0114050:	50                   	push   %eax
f0114051:	68 00 00 40 00       	push   $0x400000
f0114056:	68 00 00 0a 00       	push   $0xa0000
f011405b:	ff 75 cc             	pushl  -0x34(%ebp)
f011405e:	e8 71 22 00 00       	call   f01162d4 <CCP>
f0114063:	83 c4 30             	add    $0x30,%esp
f0114066:	85 c0                	test   %eax,%eax
f0114068:	75 1e                	jne    f0114088 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011406a:	83 ec 04             	sub    $0x4,%esp
f011406d:	68 58 9d 12 f0       	push   $0xf0129d58
f0114072:	68 e5 04 00 00       	push   $0x4e5
f0114077:	68 22 8a 12 f0       	push   $0xf0128a22
f011407c:	e8 55 c4 fe ff       	call   f01004d6 <_warn>
f0114081:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114084:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114088:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011408c:	74 04                	je     f0114092 <test_share_chunk+0x914>
f011408e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114092:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114096:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011409a:	0f 84 b2 00 00 00    	je     f0114152 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f01140a0:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f01140a7:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f01140ae:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f01140b5:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f01140bc:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f01140c3:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f01140ca:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f01140d1:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01140d8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140db:	8a 00                	mov    (%eax),%al
f01140dd:	3c 44                	cmp    $0x44,%al
f01140df:	75 45                	jne    f0114126 <test_share_chunk+0x9a8>
f01140e1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01140e4:	8a 00                	mov    (%eax),%al
f01140e6:	3c 44                	cmp    $0x44,%al
f01140e8:	75 3c                	jne    f0114126 <test_share_chunk+0x9a8>
f01140ea:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01140ed:	8a 00                	mov    (%eax),%al
f01140ef:	3c 44                	cmp    $0x44,%al
f01140f1:	75 33                	jne    f0114126 <test_share_chunk+0x9a8>
f01140f3:	8b 45 98             	mov    -0x68(%ebp),%eax
f01140f6:	8a 00                	mov    (%eax),%al
f01140f8:	3c 44                	cmp    $0x44,%al
f01140fa:	75 2a                	jne    f0114126 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01140fc:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01140ff:	8a 10                	mov    (%eax),%dl
f0114101:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114104:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114106:	38 c2                	cmp    %al,%dl
f0114108:	75 1c                	jne    f0114126 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f011410a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011410d:	8a 10                	mov    (%eax),%dl
f011410f:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114112:	8a 00                	mov    (%eax),%al
f0114114:	38 c2                	cmp    %al,%dl
f0114116:	75 0e                	jne    f0114126 <test_share_chunk+0x9a8>
f0114118:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011411b:	8a 10                	mov    (%eax),%dl
f011411d:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114120:	8a 00                	mov    (%eax),%al
f0114122:	38 c2                	cmp    %al,%dl
f0114124:	74 1e                	je     f0114144 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114126:	83 ec 04             	sub    $0x4,%esp
f0114129:	68 a0 9d 12 f0       	push   $0xf0129da0
f011412e:	68 fa 04 00 00       	push   $0x4fa
f0114133:	68 22 8a 12 f0       	push   $0xf0128a22
f0114138:	e8 99 c3 fe ff       	call   f01004d6 <_warn>
f011413d:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114140:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114144:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114148:	74 04                	je     f011414e <test_share_chunk+0x9d0>
f011414a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011414e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114152:	83 ec 0c             	sub    $0xc,%esp
f0114155:	68 e4 9e 12 f0       	push   $0xf0129ee4
f011415a:	e8 2c ce fe ff       	call   f0100f8b <cprintf>
f011415f:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114162:	83 ec 08             	sub    $0x8,%esp
f0114165:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114168:	68 f4 9e 12 f0       	push   $0xf0129ef4
f011416d:	e8 19 ce fe ff       	call   f0100f8b <cprintf>
f0114172:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114175:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114179:	75 10                	jne    f011418b <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f011417b:	83 ec 0c             	sub    $0xc,%esp
f011417e:	68 24 9f 12 f0       	push   $0xf0129f24
f0114183:	e8 03 ce fe ff       	call   f0100f8b <cprintf>
f0114188:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011418b:	a1 a4 ba 6b f0       	mov    0xf06bbaa4,%eax
f0114190:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114193:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114196:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114199:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011419e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01141a1:	5b                   	pop    %ebx
f01141a2:	5e                   	pop    %esi
f01141a3:	5f                   	pop    %edi
f01141a4:	5d                   	pop    %ebp
f01141a5:	c3                   	ret    

f01141a6 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f01141a6:	55                   	push   %ebp
f01141a7:	89 e5                	mov    %esp,%ebp
f01141a9:	57                   	push   %edi
f01141aa:	56                   	push   %esi
f01141ab:	53                   	push   %ebx
f01141ac:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01141b2:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01141b8:	bb 24 91 12 f0       	mov    $0xf0129124,%ebx
f01141bd:	ba 0f 00 00 00       	mov    $0xf,%edx
f01141c2:	89 c7                	mov    %eax,%edi
f01141c4:	89 de                	mov    %ebx,%esi
f01141c6:	89 d1                	mov    %edx,%ecx
f01141c8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01141ca:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01141d0:	b9 23 00 00 00       	mov    $0x23,%ecx
f01141d5:	b0 00                	mov    $0x0,%al
f01141d7:	89 d7                	mov    %edx,%edi
f01141d9:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01141db:	6a 00                	push   $0x0
f01141dd:	6a 0a                	push   $0xa
f01141df:	6a 14                	push   $0x14
f01141e1:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01141e7:	50                   	push   %eax
f01141e8:	e8 1f 66 ff ff       	call   f010a80c <env_create>
f01141ed:	83 c4 10             	add    $0x10,%esp
f01141f0:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01141f3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01141f6:	8b 40 64             	mov    0x64(%eax),%eax
f01141f9:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f01141fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01141ff:	8b 40 68             	mov    0x68(%eax),%eax
f0114202:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114205:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114208:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f011420b:	83 ec 0c             	sub    $0xc,%esp
f011420e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114211:	e8 8a 20 00 00       	call   f01162a0 <ClearUserSpace>
f0114216:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114219:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114220:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114227:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f011422e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114232:	83 ec 0c             	sub    $0xc,%esp
f0114235:	68 60 9f 12 f0       	push   $0xf0129f60
f011423a:	e8 4c cd fe ff       	call   f0100f8b <cprintf>
f011423f:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114242:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114249:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114250:	eb 03                	jmp    f0114255 <test_allocate_chunk+0xaf>
f0114252:	ff 4d e4             	decl   -0x1c(%ebp)
f0114255:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011425c:	76 09                	jbe    f0114267 <test_allocate_chunk+0xc1>
f011425e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114261:	8a 00                	mov    (%eax),%al
f0114263:	84 c0                	test   %al,%al
f0114265:	74 eb                	je     f0114252 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114267:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011426e:	75 06                	jne    f0114276 <test_allocate_chunk+0xd0>
f0114270:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114273:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114276:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114279:	8a 00                	mov    (%eax),%al
f011427b:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0114281:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114284:	8a 00                	mov    (%eax),%al
f0114286:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f011428c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011428f:	8a 00                	mov    (%eax),%al
f0114291:	0f be c0             	movsbl %al,%eax
f0114294:	83 ec 08             	sub    $0x8,%esp
f0114297:	50                   	push   %eax
f0114298:	68 8a 9f 12 f0       	push   $0xf0129f8a
f011429d:	e8 e9 cc fe ff       	call   f0100f8b <cprintf>
f01142a2:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f01142a5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01142a8:	8a 00                	mov    (%eax),%al
f01142aa:	0f be c0             	movsbl %al,%eax
f01142ad:	83 ec 08             	sub    $0x8,%esp
f01142b0:	50                   	push   %eax
f01142b1:	68 96 9f 12 f0       	push   $0xf0129f96
f01142b6:	e8 d0 cc fe ff       	call   f0100f8b <cprintf>
f01142bb:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f01142be:	83 ec 08             	sub    $0x8,%esp
f01142c1:	68 00 f0 bf ef       	push   $0xefbff000
f01142c6:	ff 75 cc             	pushl  -0x34(%ebp)
f01142c9:	e8 b3 1f 00 00       	call   f0116281 <GP>
f01142ce:	83 c4 10             	add    $0x10,%esp
f01142d1:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01142d4:	e8 d3 9e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01142d9:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f01142dc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01142df:	c1 e0 02             	shl    $0x2,%eax
f01142e2:	6a 02                	push   $0x2
f01142e4:	50                   	push   %eax
f01142e5:	68 00 f0 bf ef       	push   $0xefbff000
f01142ea:	ff 75 cc             	pushl  -0x34(%ebp)
f01142ed:	e8 a7 60 ff ff       	call   f010a399 <allocate_chunk>
f01142f2:	83 c4 10             	add    $0x10,%esp
f01142f5:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01142f8:	e8 af 9e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01142fd:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114300:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114304:	75 08                	jne    f011430e <test_allocate_chunk+0x168>
f0114306:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114309:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011430c:	74 2a                	je     f0114338 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011430e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114311:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114314:	83 ec 08             	sub    $0x8,%esp
f0114317:	6a 00                	push   $0x0
f0114319:	50                   	push   %eax
f011431a:	ff 75 b0             	pushl  -0x50(%ebp)
f011431d:	68 a4 9f 12 f0       	push   $0xf0129fa4
f0114322:	68 3a 05 00 00       	push   $0x53a
f0114327:	68 22 8a 12 f0       	push   $0xf0128a22
f011432c:	e8 a5 c1 fe ff       	call   f01004d6 <_warn>
f0114331:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114334:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114338:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011433c:	74 04                	je     f0114342 <test_allocate_chunk+0x19c>
f011433e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114342:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114346:	e8 61 9e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011434b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f011434e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114351:	01 c0                	add    %eax,%eax
f0114353:	89 c1                	mov    %eax,%ecx
f0114355:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114358:	89 d0                	mov    %edx,%eax
f011435a:	c1 e0 02             	shl    $0x2,%eax
f011435d:	01 d0                	add    %edx,%eax
f011435f:	f7 d8                	neg    %eax
f0114361:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114366:	6a 02                	push   $0x2
f0114368:	51                   	push   %ecx
f0114369:	50                   	push   %eax
f011436a:	ff 75 cc             	pushl  -0x34(%ebp)
f011436d:	e8 27 60 ff ff       	call   f010a399 <allocate_chunk>
f0114372:	83 c4 10             	add    $0x10,%esp
f0114375:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114378:	e8 2f 9e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011437d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114380:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114384:	75 08                	jne    f011438e <test_allocate_chunk+0x1e8>
f0114386:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114389:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011438c:	74 2a                	je     f01143b8 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011438e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114391:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114394:	83 ec 08             	sub    $0x8,%esp
f0114397:	6a 00                	push   $0x0
f0114399:	50                   	push   %eax
f011439a:	ff 75 b0             	pushl  -0x50(%ebp)
f011439d:	68 a4 9f 12 f0       	push   $0xf0129fa4
f01143a2:	68 48 05 00 00       	push   $0x548
f01143a7:	68 22 8a 12 f0       	push   $0xf0128a22
f01143ac:	e8 25 c1 fe ff       	call   f01004d6 <_warn>
f01143b1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01143b4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01143b8:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01143bc:	74 04                	je     f01143c2 <test_allocate_chunk+0x21c>
f01143be:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01143c2:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f01143c6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01143c9:	c1 e0 02             	shl    $0x2,%eax
f01143cc:	83 ec 08             	sub    $0x8,%esp
f01143cf:	6a 03                	push   $0x3
f01143d1:	6a 00                	push   $0x0
f01143d3:	6a 00                	push   $0x0
f01143d5:	68 ff 0f 00 00       	push   $0xfff
f01143da:	ff 75 b8             	pushl  -0x48(%ebp)
f01143dd:	6a 01                	push   $0x1
f01143df:	50                   	push   %eax
f01143e0:	68 00 f0 bf ef       	push   $0xefbff000
f01143e5:	6a 00                	push   $0x0
f01143e7:	ff 75 cc             	pushl  -0x34(%ebp)
f01143ea:	e8 e5 1e 00 00       	call   f01162d4 <CCP>
f01143ef:	83 c4 30             	add    $0x30,%esp
f01143f2:	85 c0                	test   %eax,%eax
f01143f4:	75 1e                	jne    f0114414 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01143f6:	83 ec 04             	sub    $0x4,%esp
f01143f9:	68 0c a0 12 f0       	push   $0xf012a00c
f01143fe:	68 50 05 00 00       	push   $0x550
f0114403:	68 22 8a 12 f0       	push   $0xf0128a22
f0114408:	e8 c9 c0 fe ff       	call   f01004d6 <_warn>
f011440d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114410:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114414:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114418:	74 04                	je     f011441e <test_allocate_chunk+0x278>
f011441a:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011441e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114422:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114425:	8a 10                	mov    (%eax),%dl
f0114427:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f011442d:	38 c2                	cmp    %al,%dl
f011442f:	75 0f                	jne    f0114440 <test_allocate_chunk+0x29a>
f0114431:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114434:	8a 10                	mov    (%eax),%dl
f0114436:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f011443c:	38 c2                	cmp    %al,%dl
f011443e:	74 1e                	je     f011445e <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114440:	83 ec 04             	sub    $0x4,%esp
f0114443:	68 58 a0 12 f0       	push   $0xf012a058
f0114448:	68 58 05 00 00       	push   $0x558
f011444d:	68 22 8a 12 f0       	push   $0xf0128a22
f0114452:	e8 7f c0 fe ff       	call   f01004d6 <_warn>
f0114457:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011445a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011445e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114462:	74 04                	je     f0114468 <test_allocate_chunk+0x2c2>
f0114464:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114468:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011446c:	83 ec 0c             	sub    $0xc,%esp
f011446f:	68 d5 9d 12 f0       	push   $0xf0129dd5
f0114474:	e8 12 cb fe ff       	call   f0100f8b <cprintf>
f0114479:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f011447c:	83 ec 0c             	sub    $0xc,%esp
f011447f:	68 90 a0 12 f0       	push   $0xf012a090
f0114484:	e8 02 cb fe ff       	call   f0100f8b <cprintf>
f0114489:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011448c:	e8 1b 9d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0114491:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114494:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114497:	c1 e0 05             	shl    $0x5,%eax
f011449a:	68 02 0e 00 00       	push   $0xe02
f011449f:	50                   	push   %eax
f01144a0:	6a 00                	push   $0x0
f01144a2:	ff 75 cc             	pushl  -0x34(%ebp)
f01144a5:	e8 ef 5e ff ff       	call   f010a399 <allocate_chunk>
f01144aa:	83 c4 10             	add    $0x10,%esp
f01144ad:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01144b0:	e8 f7 9c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01144b5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f01144b8:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01144bc:	75 36                	jne    f01144f4 <test_allocate_chunk+0x34e>
f01144be:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01144c1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01144c4:	89 c1                	mov    %eax,%ecx
f01144c6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01144c9:	c1 e0 05             	shl    $0x5,%eax
f01144cc:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01144cf:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01144d6:	99                   	cltd   
f01144d7:	f7 fe                	idiv   %esi
f01144d9:	89 c3                	mov    %eax,%ebx
f01144db:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01144de:	c1 e0 05             	shl    $0x5,%eax
f01144e1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01144e4:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01144eb:	99                   	cltd   
f01144ec:	f7 fe                	idiv   %esi
f01144ee:	01 d8                	add    %ebx,%eax
f01144f0:	39 c1                	cmp    %eax,%ecx
f01144f2:	74 54                	je     f0114548 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f01144f4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01144f7:	c1 e0 05             	shl    $0x5,%eax
f01144fa:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01144fd:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114504:	99                   	cltd   
f0114505:	f7 ff                	idiv   %edi
f0114507:	89 c1                	mov    %eax,%ecx
f0114509:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011450c:	c1 e0 05             	shl    $0x5,%eax
f011450f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114512:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114519:	99                   	cltd   
f011451a:	f7 fe                	idiv   %esi
f011451c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011451f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114522:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114525:	83 ec 08             	sub    $0x8,%esp
f0114528:	52                   	push   %edx
f0114529:	50                   	push   %eax
f011452a:	ff 75 a8             	pushl  -0x58(%ebp)
f011452d:	68 d0 a0 12 f0       	push   $0xf012a0d0
f0114532:	68 6d 05 00 00       	push   $0x56d
f0114537:	68 22 8a 12 f0       	push   $0xf0128a22
f011453c:	e8 95 bf fe ff       	call   f01004d6 <_warn>
f0114541:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114544:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114548:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011454c:	74 04                	je     f0114552 <test_allocate_chunk+0x3ac>
f011454e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114552:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114556:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011455d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114560:	c1 e0 05             	shl    $0x5,%eax
f0114563:	83 ec 08             	sub    $0x8,%esp
f0114566:	6a 03                	push   $0x3
f0114568:	6a 00                	push   $0x0
f011456a:	6a 00                	push   $0x0
f011456c:	68 07 0e 00 00       	push   $0xe07
f0114571:	68 03 0e 00 00       	push   $0xe03
f0114576:	6a 01                	push   $0x1
f0114578:	50                   	push   %eax
f0114579:	6a 00                	push   $0x0
f011457b:	6a 00                	push   $0x0
f011457d:	ff 75 cc             	pushl  -0x34(%ebp)
f0114580:	e8 4f 1d 00 00       	call   f01162d4 <CCP>
f0114585:	83 c4 30             	add    $0x30,%esp
f0114588:	85 c0                	test   %eax,%eax
f011458a:	75 25                	jne    f01145b1 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011458c:	83 ec 04             	sub    $0x4,%esp
f011458f:	68 0c a0 12 f0       	push   $0xf012a00c
f0114594:	68 76 05 00 00       	push   $0x576
f0114599:	68 22 8a 12 f0       	push   $0xf0128a22
f011459e:	e8 33 bf fe ff       	call   f01004d6 <_warn>
f01145a3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145a6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01145aa:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f01145b1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01145b5:	74 04                	je     f01145bb <test_allocate_chunk+0x415>
f01145b7:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01145bb:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f01145bf:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01145c3:	74 5a                	je     f011461f <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f01145c5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01145c8:	01 c0                	add    %eax,%eax
f01145ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01145cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01145d0:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f01145d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01145d6:	01 c0                	add    %eax,%eax
f01145d8:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01145db:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145de:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f01145e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01145e4:	8a 00                	mov    (%eax),%al
f01145e6:	3c 4b                	cmp    $0x4b,%al
f01145e8:	75 09                	jne    f01145f3 <test_allocate_chunk+0x44d>
f01145ea:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145ed:	8a 00                	mov    (%eax),%al
f01145ef:	3c 4d                	cmp    $0x4d,%al
f01145f1:	74 1e                	je     f0114611 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01145f3:	83 ec 04             	sub    $0x4,%esp
f01145f6:	68 58 a0 12 f0       	push   $0xf012a058
f01145fb:	68 84 05 00 00       	push   $0x584
f0114600:	68 22 8a 12 f0       	push   $0xf0128a22
f0114605:	e8 cc be fe ff       	call   f01004d6 <_warn>
f011460a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011460d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114611:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114615:	74 04                	je     f011461b <test_allocate_chunk+0x475>
f0114617:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f011461b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f011461f:	83 ec 0c             	sub    $0xc,%esp
f0114622:	68 af 93 12 f0       	push   $0xf01293af
f0114627:	e8 5f c9 fe ff       	call   f0100f8b <cprintf>
f011462c:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f011462f:	83 ec 0c             	sub    $0xc,%esp
f0114632:	68 30 a1 12 f0       	push   $0xf012a130
f0114637:	e8 4f c9 fe ff       	call   f0100f8b <cprintf>
f011463c:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011463f:	e8 68 9b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0114644:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0114647:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011464a:	c1 e0 06             	shl    $0x6,%eax
f011464d:	89 c2                	mov    %eax,%edx
f011464f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114652:	c1 e0 05             	shl    $0x5,%eax
f0114655:	6a 00                	push   $0x0
f0114657:	52                   	push   %edx
f0114658:	50                   	push   %eax
f0114659:	ff 75 cc             	pushl  -0x34(%ebp)
f011465c:	e8 38 5d ff ff       	call   f010a399 <allocate_chunk>
f0114661:	83 c4 10             	add    $0x10,%esp
f0114664:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114667:	e8 40 9b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011466c:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f011466f:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0114673:	75 36                	jne    f01146ab <test_allocate_chunk+0x505>
f0114675:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114678:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011467b:	89 c1                	mov    %eax,%ecx
f011467d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114680:	c1 e0 06             	shl    $0x6,%eax
f0114683:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114686:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011468d:	99                   	cltd   
f011468e:	f7 ff                	idiv   %edi
f0114690:	89 c3                	mov    %eax,%ebx
f0114692:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114695:	c1 e0 06             	shl    $0x6,%eax
f0114698:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011469b:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01146a2:	99                   	cltd   
f01146a3:	f7 fe                	idiv   %esi
f01146a5:	01 d8                	add    %ebx,%eax
f01146a7:	39 c1                	cmp    %eax,%ecx
f01146a9:	74 54                	je     f01146ff <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f01146ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146ae:	c1 e0 06             	shl    $0x6,%eax
f01146b1:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01146b4:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01146bb:	99                   	cltd   
f01146bc:	f7 fb                	idiv   %ebx
f01146be:	89 c1                	mov    %eax,%ecx
f01146c0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146c3:	c1 e0 06             	shl    $0x6,%eax
f01146c6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01146c9:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01146d0:	99                   	cltd   
f01146d1:	f7 ff                	idiv   %edi
f01146d3:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01146d6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01146d9:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01146dc:	83 ec 08             	sub    $0x8,%esp
f01146df:	52                   	push   %edx
f01146e0:	50                   	push   %eax
f01146e1:	ff 75 a4             	pushl  -0x5c(%ebp)
f01146e4:	68 d0 a0 12 f0       	push   $0xf012a0d0
f01146e9:	68 9a 05 00 00       	push   $0x59a
f01146ee:	68 22 8a 12 f0       	push   $0xf0128a22
f01146f3:	e8 de bd fe ff       	call   f01004d6 <_warn>
f01146f8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01146fb:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01146ff:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114703:	74 04                	je     f0114709 <test_allocate_chunk+0x563>
f0114705:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114709:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f011470d:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114714:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114717:	c1 e0 06             	shl    $0x6,%eax
f011471a:	89 c2                	mov    %eax,%edx
f011471c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011471f:	c1 e0 05             	shl    $0x5,%eax
f0114722:	83 ec 08             	sub    $0x8,%esp
f0114725:	6a 03                	push   $0x3
f0114727:	6a 00                	push   $0x0
f0114729:	6a 00                	push   $0x0
f011472b:	68 07 0e 00 00       	push   $0xe07
f0114730:	6a 01                	push   $0x1
f0114732:	6a 01                	push   $0x1
f0114734:	52                   	push   %edx
f0114735:	50                   	push   %eax
f0114736:	6a 00                	push   $0x0
f0114738:	ff 75 cc             	pushl  -0x34(%ebp)
f011473b:	e8 94 1b 00 00       	call   f01162d4 <CCP>
f0114740:	83 c4 30             	add    $0x30,%esp
f0114743:	85 c0                	test   %eax,%eax
f0114745:	75 25                	jne    f011476c <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114747:	83 ec 04             	sub    $0x4,%esp
f011474a:	68 0c a0 12 f0       	push   $0xf012a00c
f011474f:	68 a3 05 00 00       	push   $0x5a3
f0114754:	68 22 8a 12 f0       	push   $0xf0128a22
f0114759:	e8 78 bd fe ff       	call   f01004d6 <_warn>
f011475e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114761:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114765:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f011476c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114770:	74 04                	je     f0114776 <test_allocate_chunk+0x5d0>
f0114772:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114776:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f011477a:	83 ec 0c             	sub    $0xc,%esp
f011477d:	68 12 94 12 f0       	push   $0xf0129412
f0114782:	e8 04 c8 fe ff       	call   f0100f8b <cprintf>
f0114787:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f011478a:	83 ec 0c             	sub    $0xc,%esp
f011478d:	68 70 a1 12 f0       	push   $0xf012a170
f0114792:	e8 f4 c7 fe ff       	call   f0100f8b <cprintf>
f0114797:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011479a:	e8 0d 9a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011479f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f01147a2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147a5:	c1 e0 06             	shl    $0x6,%eax
f01147a8:	68 06 0e 00 00       	push   $0xe06
f01147ad:	50                   	push   %eax
f01147ae:	68 00 00 00 80       	push   $0x80000000
f01147b3:	ff 75 cc             	pushl  -0x34(%ebp)
f01147b6:	e8 de 5b ff ff       	call   f010a399 <allocate_chunk>
f01147bb:	83 c4 10             	add    $0x10,%esp
f01147be:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01147c1:	e8 e6 99 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01147c6:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f01147c9:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f01147cd:	75 36                	jne    f0114805 <test_allocate_chunk+0x65f>
f01147cf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01147d2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01147d5:	89 c1                	mov    %eax,%ecx
f01147d7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147da:	c1 e0 06             	shl    $0x6,%eax
f01147dd:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01147e0:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01147e7:	99                   	cltd   
f01147e8:	f7 fb                	idiv   %ebx
f01147ea:	89 c3                	mov    %eax,%ebx
f01147ec:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147ef:	c1 e0 06             	shl    $0x6,%eax
f01147f2:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01147f5:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01147fc:	99                   	cltd   
f01147fd:	f7 fe                	idiv   %esi
f01147ff:	01 d8                	add    %ebx,%eax
f0114801:	39 c1                	cmp    %eax,%ecx
f0114803:	74 54                	je     f0114859 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0114805:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114808:	c1 e0 06             	shl    $0x6,%eax
f011480b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011480e:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114815:	99                   	cltd   
f0114816:	f7 ff                	idiv   %edi
f0114818:	89 c1                	mov    %eax,%ecx
f011481a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011481d:	c1 e0 06             	shl    $0x6,%eax
f0114820:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114823:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011482a:	99                   	cltd   
f011482b:	f7 fb                	idiv   %ebx
f011482d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114830:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114833:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114836:	83 ec 08             	sub    $0x8,%esp
f0114839:	52                   	push   %edx
f011483a:	50                   	push   %eax
f011483b:	ff 75 9c             	pushl  -0x64(%ebp)
f011483e:	68 d0 a0 12 f0       	push   $0xf012a0d0
f0114843:	68 b9 05 00 00       	push   $0x5b9
f0114848:	68 22 8a 12 f0       	push   $0xf0128a22
f011484d:	e8 84 bc fe ff       	call   f01004d6 <_warn>
f0114852:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114855:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114859:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011485d:	74 04                	je     f0114863 <test_allocate_chunk+0x6bd>
f011485f:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114863:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114867:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011486e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114871:	c1 e0 06             	shl    $0x6,%eax
f0114874:	83 ec 08             	sub    $0x8,%esp
f0114877:	6a 03                	push   $0x3
f0114879:	6a 00                	push   $0x0
f011487b:	6a 00                	push   $0x0
f011487d:	68 07 0e 00 00       	push   $0xe07
f0114882:	68 07 0e 00 00       	push   $0xe07
f0114887:	6a 01                	push   $0x1
f0114889:	50                   	push   %eax
f011488a:	68 00 00 00 80       	push   $0x80000000
f011488f:	6a 00                	push   $0x0
f0114891:	ff 75 cc             	pushl  -0x34(%ebp)
f0114894:	e8 3b 1a 00 00       	call   f01162d4 <CCP>
f0114899:	83 c4 30             	add    $0x30,%esp
f011489c:	85 c0                	test   %eax,%eax
f011489e:	75 25                	jne    f01148c5 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01148a0:	83 ec 04             	sub    $0x4,%esp
f01148a3:	68 0c a0 12 f0       	push   $0xf012a00c
f01148a8:	68 c2 05 00 00       	push   $0x5c2
f01148ad:	68 22 8a 12 f0       	push   $0xf0128a22
f01148b2:	e8 1f bc fe ff       	call   f01004d6 <_warn>
f01148b7:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01148ba:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01148be:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f01148c5:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01148c9:	74 04                	je     f01148cf <test_allocate_chunk+0x729>
f01148cb:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01148cf:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f01148d3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01148d7:	74 6f                	je     f0114948 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f01148d9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01148dc:	01 c0                	add    %eax,%eax
f01148de:	05 00 00 00 80       	add    $0x80000000,%eax
f01148e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01148e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01148e9:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f01148ec:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01148ef:	89 d0                	mov    %edx,%eax
f01148f1:	c1 e0 02             	shl    $0x2,%eax
f01148f4:	01 d0                	add    %edx,%eax
f01148f6:	01 c0                	add    %eax,%eax
f01148f8:	01 d0                	add    %edx,%eax
f01148fa:	01 c0                	add    %eax,%eax
f01148fc:	05 00 00 00 80       	add    $0x80000000,%eax
f0114901:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114904:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114907:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f011490a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011490d:	8a 00                	mov    (%eax),%al
f011490f:	3c 4b                	cmp    $0x4b,%al
f0114911:	75 09                	jne    f011491c <test_allocate_chunk+0x776>
f0114913:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114916:	8a 00                	mov    (%eax),%al
f0114918:	3c 4d                	cmp    $0x4d,%al
f011491a:	74 1e                	je     f011493a <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011491c:	83 ec 04             	sub    $0x4,%esp
f011491f:	68 58 a0 12 f0       	push   $0xf012a058
f0114924:	68 d0 05 00 00       	push   $0x5d0
f0114929:	68 22 8a 12 f0       	push   $0xf0128a22
f011492e:	e8 a3 bb fe ff       	call   f01004d6 <_warn>
f0114933:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114936:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f011493a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011493e:	74 04                	je     f0114944 <test_allocate_chunk+0x79e>
f0114940:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114944:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114948:	83 ec 0c             	sub    $0xc,%esp
f011494b:	68 e4 9e 12 f0       	push   $0xf0129ee4
f0114950:	e8 36 c6 fe ff       	call   f0100f8b <cprintf>
f0114955:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0114958:	83 ec 0c             	sub    $0xc,%esp
f011495b:	68 ac a1 12 f0       	push   $0xf012a1ac
f0114960:	e8 26 c6 fe ff       	call   f0100f8b <cprintf>
f0114965:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114968:	e8 3f 98 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011496d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0114970:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114973:	89 d0                	mov    %edx,%eax
f0114975:	01 c0                	add    %eax,%eax
f0114977:	01 d0                	add    %edx,%eax
f0114979:	01 c0                	add    %eax,%eax
f011497b:	01 d0                	add    %edx,%eax
f011497d:	68 04 0e 00 00       	push   $0xe04
f0114982:	50                   	push   %eax
f0114983:	68 00 fc 3f 40       	push   $0x403ffc00
f0114988:	ff 75 cc             	pushl  -0x34(%ebp)
f011498b:	e8 09 5a ff ff       	call   f010a399 <allocate_chunk>
f0114990:	83 c4 10             	add    $0x10,%esp
f0114993:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114996:	e8 11 98 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011499b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f011499e:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f01149a2:	75 0b                	jne    f01149af <test_allocate_chunk+0x809>
f01149a4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01149a7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01149aa:	83 f8 05             	cmp    $0x5,%eax
f01149ad:	74 2a                	je     f01149d9 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f01149af:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01149b2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01149b5:	83 ec 08             	sub    $0x8,%esp
f01149b8:	6a 05                	push   $0x5
f01149ba:	50                   	push   %eax
f01149bb:	ff 75 98             	pushl  -0x68(%ebp)
f01149be:	68 d0 a0 12 f0       	push   $0xf012a0d0
f01149c3:	68 e7 05 00 00       	push   $0x5e7
f01149c8:	68 22 8a 12 f0       	push   $0xf0128a22
f01149cd:	e8 04 bb fe ff       	call   f01004d6 <_warn>
f01149d2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01149d5:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01149d9:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01149dd:	74 04                	je     f01149e3 <test_allocate_chunk+0x83d>
f01149df:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01149e3:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01149e7:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01149ee:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01149f1:	89 d0                	mov    %edx,%eax
f01149f3:	01 c0                	add    %eax,%eax
f01149f5:	01 d0                	add    %edx,%eax
f01149f7:	c1 e0 02             	shl    $0x2,%eax
f01149fa:	83 ec 08             	sub    $0x8,%esp
f01149fd:	6a 03                	push   $0x3
f01149ff:	6a 00                	push   $0x0
f0114a01:	6a 00                	push   $0x0
f0114a03:	68 07 0e 00 00       	push   $0xe07
f0114a08:	68 05 0e 00 00       	push   $0xe05
f0114a0d:	6a 01                	push   $0x1
f0114a0f:	50                   	push   %eax
f0114a10:	68 00 f0 3f 40       	push   $0x403ff000
f0114a15:	6a 00                	push   $0x0
f0114a17:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a1a:	e8 b5 18 00 00       	call   f01162d4 <CCP>
f0114a1f:	83 c4 30             	add    $0x30,%esp
f0114a22:	85 c0                	test   %eax,%eax
f0114a24:	75 25                	jne    f0114a4b <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114a26:	83 ec 04             	sub    $0x4,%esp
f0114a29:	68 0c a0 12 f0       	push   $0xf012a00c
f0114a2e:	68 f0 05 00 00       	push   $0x5f0
f0114a33:	68 22 8a 12 f0       	push   $0xf0128a22
f0114a38:	e8 99 ba fe ff       	call   f01004d6 <_warn>
f0114a3d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114a40:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114a44:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0114a4b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114a4f:	74 04                	je     f0114a55 <test_allocate_chunk+0x8af>
f0114a51:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114a55:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0114a59:	83 ec 0c             	sub    $0xc,%esp
f0114a5c:	68 e3 a1 12 f0       	push   $0xf012a1e3
f0114a61:	e8 25 c5 fe ff       	call   f0100f8b <cprintf>
f0114a66:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0114a69:	83 ec 08             	sub    $0x8,%esp
f0114a6c:	ff 75 e0             	pushl  -0x20(%ebp)
f0114a6f:	68 f4 a1 12 f0       	push   $0xf012a1f4
f0114a74:	e8 12 c5 fe ff       	call   f0100f8b <cprintf>
f0114a79:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114a7c:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0114a80:	75 10                	jne    f0114a92 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0114a82:	83 ec 0c             	sub    $0xc,%esp
f0114a85:	68 28 a2 12 f0       	push   $0xf012a228
f0114a8a:	e8 fc c4 fe ff       	call   f0100f8b <cprintf>
f0114a8f:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114a92:	a1 a4 ba 6b f0       	mov    0xf06bbaa4,%eax
f0114a97:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114a9a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114a9d:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114aa0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114aa5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114aa8:	5b                   	pop    %ebx
f0114aa9:	5e                   	pop    %esi
f0114aaa:	5f                   	pop    %edi
f0114aab:	5d                   	pop    %ebp
f0114aac:	c3                   	ret    

f0114aad <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0114aad:	55                   	push   %ebp
f0114aae:	89 e5                	mov    %esp,%ebp
f0114ab0:	57                   	push   %edi
f0114ab1:	56                   	push   %esi
f0114ab2:	53                   	push   %ebx
f0114ab3:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114ab9:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114abc:	bb 24 91 12 f0       	mov    $0xf0129124,%ebx
f0114ac1:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114ac6:	89 c7                	mov    %eax,%edi
f0114ac8:	89 de                	mov    %ebx,%esi
f0114aca:	89 d1                	mov    %edx,%ecx
f0114acc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114ace:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0114ad1:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114ad6:	b0 00                	mov    $0x0,%al
f0114ad8:	89 d7                	mov    %edx,%edi
f0114ada:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114adc:	6a 00                	push   $0x0
f0114ade:	6a 0a                	push   $0xa
f0114ae0:	6a 14                	push   $0x14
f0114ae2:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114ae5:	50                   	push   %eax
f0114ae6:	e8 21 5d ff ff       	call   f010a80c <env_create>
f0114aeb:	83 c4 10             	add    $0x10,%esp
f0114aee:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114af1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114af4:	8b 40 64             	mov    0x64(%eax),%eax
f0114af7:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0114afa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114afd:	8b 40 68             	mov    0x68(%eax),%eax
f0114b00:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0114b03:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114b06:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0114b09:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0114b10:	75 70 20 
f0114b13:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0114b1a:	00 00 00 
f0114b1d:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0114b20:	b9 03 00 00 00       	mov    $0x3,%ecx
f0114b25:	b8 00 00 00 00       	mov    $0x0,%eax
f0114b2a:	89 d7                	mov    %edx,%edi
f0114b2c:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0114b2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114b31:	8b 40 10             	mov    0x10(%eax),%eax
f0114b34:	83 ec 08             	sub    $0x8,%esp
f0114b37:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0114b3d:	52                   	push   %edx
f0114b3e:	50                   	push   %eax
f0114b3f:	e8 3b ae 00 00       	call   f011f97f <ltostr>
f0114b44:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0114b47:	83 ec 04             	sub    $0x4,%esp
f0114b4a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114b50:	50                   	push   %eax
f0114b51:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0114b57:	50                   	push   %eax
f0114b58:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0114b5e:	50                   	push   %eax
f0114b5f:	e8 f4 ae 00 00       	call   f011fa58 <strcconcat>
f0114b64:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114b67:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0114b6e:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0114b75:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0114b7c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0114b83:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0114b87:	83 ec 0c             	sub    $0xc,%esp
f0114b8a:	ff 75 d8             	pushl  -0x28(%ebp)
f0114b8d:	e8 0e 17 00 00       	call   f01162a0 <ClearUserSpace>
f0114b92:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0114b95:	83 ec 0c             	sub    $0xc,%esp
f0114b98:	68 68 a2 12 f0       	push   $0xf012a268
f0114b9d:	e8 e9 c3 fe ff       	call   f0100f8b <cprintf>
f0114ba2:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0114ba5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114ba8:	c1 e0 03             	shl    $0x3,%eax
f0114bab:	83 ec 04             	sub    $0x4,%esp
f0114bae:	50                   	push   %eax
f0114baf:	6a 00                	push   $0x0
f0114bb1:	ff 75 d8             	pushl  -0x28(%ebp)
f0114bb4:	e8 14 58 ff ff       	call   f010a3cd <calculate_required_frames>
f0114bb9:	83 c4 10             	add    $0x10,%esp
f0114bbc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114bbf:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114bc3:	74 23                	je     f0114be8 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114bc5:	83 ec 0c             	sub    $0xc,%esp
f0114bc8:	6a 03                	push   $0x3
f0114bca:	ff 75 c8             	pushl  -0x38(%ebp)
f0114bcd:	68 9c a2 12 f0       	push   $0xf012a29c
f0114bd2:	68 29 06 00 00       	push   $0x629
f0114bd7:	68 22 8a 12 f0       	push   $0xf0128a22
f0114bdc:	e8 f5 b8 fe ff       	call   f01004d6 <_warn>
f0114be1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114be4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114be8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114bec:	74 04                	je     f0114bf2 <test_calculate_required_frames+0x145>
f0114bee:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114bf2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0114bf6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114bf9:	c1 e0 02             	shl    $0x2,%eax
f0114bfc:	83 ec 04             	sub    $0x4,%esp
f0114bff:	50                   	push   %eax
f0114c00:	6a 00                	push   $0x0
f0114c02:	ff 75 d8             	pushl  -0x28(%ebp)
f0114c05:	e8 c3 57 ff ff       	call   f010a3cd <calculate_required_frames>
f0114c0a:	83 c4 10             	add    $0x10,%esp
f0114c0d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0114c10:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0114c17:	74 26                	je     f0114c3f <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0114c19:	83 ec 0c             	sub    $0xc,%esp
f0114c1c:	68 01 04 00 00       	push   $0x401
f0114c21:	ff 75 c8             	pushl  -0x38(%ebp)
f0114c24:	68 9c a2 12 f0       	push   $0xf012a29c
f0114c29:	68 33 06 00 00       	push   $0x633
f0114c2e:	68 22 8a 12 f0       	push   $0xf0128a22
f0114c33:	e8 9e b8 fe ff       	call   f01004d6 <_warn>
f0114c38:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114c3b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114c3f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c43:	74 04                	je     f0114c49 <test_calculate_required_frames+0x19c>
f0114c45:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114c49:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0114c4d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114c50:	c1 e0 0a             	shl    $0xa,%eax
f0114c53:	83 ec 04             	sub    $0x4,%esp
f0114c56:	50                   	push   %eax
f0114c57:	6a 00                	push   $0x0
f0114c59:	ff 75 d8             	pushl  -0x28(%ebp)
f0114c5c:	e8 6c 57 ff ff       	call   f010a3cd <calculate_required_frames>
f0114c61:	83 c4 10             	add    $0x10,%esp
f0114c64:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0114c67:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114c6a:	c1 e0 0a             	shl    $0xa,%eax
f0114c6d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114c70:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114c77:	99                   	cltd   
f0114c78:	f7 fb                	idiv   %ebx
f0114c7a:	89 c1                	mov    %eax,%ecx
f0114c7c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114c7f:	c1 e0 0a             	shl    $0xa,%eax
f0114c82:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114c85:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114c8c:	99                   	cltd   
f0114c8d:	f7 fe                	idiv   %esi
f0114c8f:	01 c8                	add    %ecx,%eax
f0114c91:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0114c94:	74 4c                	je     f0114ce2 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0114c96:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114c99:	c1 e0 0a             	shl    $0xa,%eax
f0114c9c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114c9f:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114ca6:	99                   	cltd   
f0114ca7:	f7 fb                	idiv   %ebx
f0114ca9:	89 c1                	mov    %eax,%ecx
f0114cab:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114cae:	c1 e0 0a             	shl    $0xa,%eax
f0114cb1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114cb4:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114cbb:	99                   	cltd   
f0114cbc:	f7 fe                	idiv   %esi
f0114cbe:	01 c8                	add    %ecx,%eax
f0114cc0:	83 ec 0c             	sub    $0xc,%esp
f0114cc3:	50                   	push   %eax
f0114cc4:	ff 75 c8             	pushl  -0x38(%ebp)
f0114cc7:	68 9c a2 12 f0       	push   $0xf012a29c
f0114ccc:	68 3d 06 00 00       	push   $0x63d
f0114cd1:	68 22 8a 12 f0       	push   $0xf0128a22
f0114cd6:	e8 fb b7 fe ff       	call   f01004d6 <_warn>
f0114cdb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114cde:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ce2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ce6:	74 04                	je     f0114cec <test_calculate_required_frames+0x23f>
f0114ce8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114cec:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0114cf0:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114cf3:	89 d0                	mov    %edx,%eax
f0114cf5:	01 c0                	add    %eax,%eax
f0114cf7:	01 d0                	add    %edx,%eax
f0114cf9:	01 c0                	add    %eax,%eax
f0114cfb:	83 ec 04             	sub    $0x4,%esp
f0114cfe:	50                   	push   %eax
f0114cff:	68 00 10 00 00       	push   $0x1000
f0114d04:	ff 75 d8             	pushl  -0x28(%ebp)
f0114d07:	e8 c1 56 ff ff       	call   f010a3cd <calculate_required_frames>
f0114d0c:	83 c4 10             	add    $0x10,%esp
f0114d0f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114d12:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114d16:	74 23                	je     f0114d3b <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114d18:	83 ec 0c             	sub    $0xc,%esp
f0114d1b:	6a 03                	push   $0x3
f0114d1d:	ff 75 c8             	pushl  -0x38(%ebp)
f0114d20:	68 9c a2 12 f0       	push   $0xf012a29c
f0114d25:	68 49 06 00 00       	push   $0x649
f0114d2a:	68 22 8a 12 f0       	push   $0xf0128a22
f0114d2f:	e8 a2 b7 fe ff       	call   f01004d6 <_warn>
f0114d34:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d37:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114d3b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d3f:	74 04                	je     f0114d45 <test_calculate_required_frames+0x298>
f0114d41:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d45:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0114d49:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114d4c:	89 c2                	mov    %eax,%edx
f0114d4e:	01 d2                	add    %edx,%edx
f0114d50:	01 d0                	add    %edx,%eax
f0114d52:	83 ec 04             	sub    $0x4,%esp
f0114d55:	50                   	push   %eax
f0114d56:	68 00 18 00 00       	push   $0x1800
f0114d5b:	ff 75 d8             	pushl  -0x28(%ebp)
f0114d5e:	e8 6a 56 ff ff       	call   f010a3cd <calculate_required_frames>
f0114d63:	83 c4 10             	add    $0x10,%esp
f0114d66:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114d69:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114d6d:	74 23                	je     f0114d92 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114d6f:	83 ec 0c             	sub    $0xc,%esp
f0114d72:	6a 03                	push   $0x3
f0114d74:	ff 75 c8             	pushl  -0x38(%ebp)
f0114d77:	68 9c a2 12 f0       	push   $0xf012a29c
f0114d7c:	68 53 06 00 00       	push   $0x653
f0114d81:	68 22 8a 12 f0       	push   $0xf0128a22
f0114d86:	e8 4b b7 fe ff       	call   f01004d6 <_warn>
f0114d8b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d8e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114d92:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d96:	74 04                	je     f0114d9c <test_calculate_required_frames+0x2ef>
f0114d98:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d9c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0114da0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114da3:	89 d0                	mov    %edx,%eax
f0114da5:	c1 e0 02             	shl    $0x2,%eax
f0114da8:	01 d0                	add    %edx,%eax
f0114daa:	01 c0                	add    %eax,%eax
f0114dac:	83 ec 04             	sub    $0x4,%esp
f0114daf:	50                   	push   %eax
f0114db0:	68 00 00 40 00       	push   $0x400000
f0114db5:	ff 75 d8             	pushl  -0x28(%ebp)
f0114db8:	e8 10 56 ff ff       	call   f010a3cd <calculate_required_frames>
f0114dbd:	83 c4 10             	add    $0x10,%esp
f0114dc0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0114dc3:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0114dca:	74 26                	je     f0114df2 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0114dcc:	83 ec 0c             	sub    $0xc,%esp
f0114dcf:	68 03 0a 00 00       	push   $0xa03
f0114dd4:	ff 75 c8             	pushl  -0x38(%ebp)
f0114dd7:	68 9c a2 12 f0       	push   $0xf012a29c
f0114ddc:	68 5d 06 00 00       	push   $0x65d
f0114de1:	68 22 8a 12 f0       	push   $0xf0128a22
f0114de6:	e8 eb b6 fe ff       	call   f01004d6 <_warn>
f0114deb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114dee:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114df2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114df6:	74 04                	je     f0114dfc <test_calculate_required_frames+0x34f>
f0114df8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114dfc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0114e00:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114e03:	01 c0                	add    %eax,%eax
f0114e05:	83 ec 04             	sub    $0x4,%esp
f0114e08:	50                   	push   %eax
f0114e09:	68 00 00 70 00       	push   $0x700000
f0114e0e:	ff 75 d8             	pushl  -0x28(%ebp)
f0114e11:	e8 b7 55 ff ff       	call   f010a3cd <calculate_required_frames>
f0114e16:	83 c4 10             	add    $0x10,%esp
f0114e19:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0114e1c:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0114e23:	74 26                	je     f0114e4b <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0114e25:	83 ec 0c             	sub    $0xc,%esp
f0114e28:	68 02 02 00 00       	push   $0x202
f0114e2d:	ff 75 c8             	pushl  -0x38(%ebp)
f0114e30:	68 9c a2 12 f0       	push   $0xf012a29c
f0114e35:	68 69 06 00 00       	push   $0x669
f0114e3a:	68 22 8a 12 f0       	push   $0xf0128a22
f0114e3f:	e8 92 b6 fe ff       	call   f01004d6 <_warn>
f0114e44:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e47:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114e4b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114e4f:	74 04                	je     f0114e55 <test_calculate_required_frames+0x3a8>
f0114e51:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114e55:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0114e59:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114e5c:	83 ec 04             	sub    $0x4,%esp
f0114e5f:	50                   	push   %eax
f0114e60:	68 ff ff 3f 00       	push   $0x3fffff
f0114e65:	ff 75 d8             	pushl  -0x28(%ebp)
f0114e68:	e8 60 55 ff ff       	call   f010a3cd <calculate_required_frames>
f0114e6d:	83 c4 10             	add    $0x10,%esp
f0114e70:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0114e73:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0114e77:	74 23                	je     f0114e9c <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0114e79:	83 ec 0c             	sub    $0xc,%esp
f0114e7c:	6a 04                	push   $0x4
f0114e7e:	ff 75 c8             	pushl  -0x38(%ebp)
f0114e81:	68 9c a2 12 f0       	push   $0xf012a29c
f0114e86:	68 73 06 00 00       	push   $0x673
f0114e8b:	68 22 8a 12 f0       	push   $0xf0128a22
f0114e90:	e8 41 b6 fe ff       	call   f01004d6 <_warn>
f0114e95:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e98:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114e9c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ea0:	74 04                	je     f0114ea6 <test_calculate_required_frames+0x3f9>
f0114ea2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114ea6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114eaa:	83 ec 0c             	sub    $0xc,%esp
f0114ead:	68 d5 9d 12 f0       	push   $0xf0129dd5
f0114eb2:	e8 d4 c0 fe ff       	call   f0100f8b <cprintf>
f0114eb7:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0114eba:	83 ec 0c             	sub    $0xc,%esp
f0114ebd:	68 f4 a2 12 f0       	push   $0xf012a2f4
f0114ec2:	e8 c4 c0 fe ff       	call   f0100f8b <cprintf>
f0114ec7:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0114eca:	83 ec 04             	sub    $0x4,%esp
f0114ecd:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0114ed3:	50                   	push   %eax
f0114ed4:	68 8e 91 12 f0       	push   $0xf012918e
f0114ed9:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114edf:	50                   	push   %eax
f0114ee0:	e8 73 ab 00 00       	call   f011fa58 <strcconcat>
f0114ee5:	83 c4 10             	add    $0x10,%esp
f0114ee8:	83 ec 0c             	sub    $0xc,%esp
f0114eeb:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0114ef1:	50                   	push   %eax
f0114ef2:	e8 04 d0 fe ff       	call   f0101efb <execute_command>
f0114ef7:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0114efa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114efd:	c1 e0 03             	shl    $0x3,%eax
f0114f00:	83 ec 04             	sub    $0x4,%esp
f0114f03:	50                   	push   %eax
f0114f04:	6a 00                	push   $0x0
f0114f06:	ff 75 d8             	pushl  -0x28(%ebp)
f0114f09:	e8 bf 54 ff ff       	call   f010a3cd <calculate_required_frames>
f0114f0e:	83 c4 10             	add    $0x10,%esp
f0114f11:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0114f14:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0114f1b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114f1e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114f21:	74 24                	je     f0114f47 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0114f23:	83 ec 0c             	sub    $0xc,%esp
f0114f26:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114f29:	ff 75 c8             	pushl  -0x38(%ebp)
f0114f2c:	68 9c a2 12 f0       	push   $0xf012a29c
f0114f31:	68 87 06 00 00       	push   $0x687
f0114f36:	68 22 8a 12 f0       	push   $0xf0128a22
f0114f3b:	e8 96 b5 fe ff       	call   f01004d6 <_warn>
f0114f40:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f43:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114f47:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114f4b:	74 04                	je     f0114f51 <test_calculate_required_frames+0x4a4>
f0114f4d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114f51:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0114f55:	83 ec 04             	sub    $0x4,%esp
f0114f58:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114f5e:	50                   	push   %eax
f0114f5f:	68 9b 91 12 f0       	push   $0xf012919b
f0114f64:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114f6a:	50                   	push   %eax
f0114f6b:	e8 e8 aa 00 00       	call   f011fa58 <strcconcat>
f0114f70:	83 c4 10             	add    $0x10,%esp
f0114f73:	83 ec 0c             	sub    $0xc,%esp
f0114f76:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114f7c:	50                   	push   %eax
f0114f7d:	e8 79 cf fe ff       	call   f0101efb <execute_command>
f0114f82:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0114f85:	83 ec 04             	sub    $0x4,%esp
f0114f88:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114f8e:	50                   	push   %eax
f0114f8f:	68 28 a3 12 f0       	push   $0xf012a328
f0114f94:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114f9a:	50                   	push   %eax
f0114f9b:	e8 b8 aa 00 00       	call   f011fa58 <strcconcat>
f0114fa0:	83 c4 10             	add    $0x10,%esp
f0114fa3:	83 ec 0c             	sub    $0xc,%esp
f0114fa6:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114fac:	50                   	push   %eax
f0114fad:	e8 49 cf fe ff       	call   f0101efb <execute_command>
f0114fb2:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0114fb5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114fb8:	c1 e0 03             	shl    $0x3,%eax
f0114fbb:	83 ec 04             	sub    $0x4,%esp
f0114fbe:	50                   	push   %eax
f0114fbf:	6a 00                	push   $0x0
f0114fc1:	ff 75 d8             	pushl  -0x28(%ebp)
f0114fc4:	e8 04 54 ff ff       	call   f010a3cd <calculate_required_frames>
f0114fc9:	83 c4 10             	add    $0x10,%esp
f0114fcc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0114fcf:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0114fd6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114fd9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114fdc:	74 24                	je     f0115002 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0114fde:	83 ec 0c             	sub    $0xc,%esp
f0114fe1:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114fe4:	ff 75 c8             	pushl  -0x38(%ebp)
f0114fe7:	68 9c a2 12 f0       	push   $0xf012a29c
f0114fec:	68 95 06 00 00       	push   $0x695
f0114ff1:	68 22 8a 12 f0       	push   $0xf0128a22
f0114ff6:	e8 db b4 fe ff       	call   f01004d6 <_warn>
f0114ffb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ffe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115002:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115006:	74 04                	je     f011500c <test_calculate_required_frames+0x55f>
f0115008:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011500c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115010:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115013:	c1 e0 0a             	shl    $0xa,%eax
f0115016:	83 ec 04             	sub    $0x4,%esp
f0115019:	50                   	push   %eax
f011501a:	6a 00                	push   $0x0
f011501c:	ff 75 d8             	pushl  -0x28(%ebp)
f011501f:	e8 a9 53 ff ff       	call   f010a3cd <calculate_required_frames>
f0115024:	83 c4 10             	add    $0x10,%esp
f0115027:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f011502a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011502d:	c1 e0 0a             	shl    $0xa,%eax
f0115030:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115033:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011503a:	99                   	cltd   
f011503b:	f7 fb                	idiv   %ebx
f011503d:	89 c1                	mov    %eax,%ecx
f011503f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115042:	c1 e0 0a             	shl    $0xa,%eax
f0115045:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115048:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011504f:	99                   	cltd   
f0115050:	f7 fe                	idiv   %esi
f0115052:	01 c8                	add    %ecx,%eax
f0115054:	83 e8 05             	sub    $0x5,%eax
f0115057:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f011505a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011505d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115060:	74 24                	je     f0115086 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115062:	83 ec 0c             	sub    $0xc,%esp
f0115065:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115068:	ff 75 c8             	pushl  -0x38(%ebp)
f011506b:	68 9c a2 12 f0       	push   $0xf012a29c
f0115070:	68 a0 06 00 00       	push   $0x6a0
f0115075:	68 22 8a 12 f0       	push   $0xf0128a22
f011507a:	e8 57 b4 fe ff       	call   f01004d6 <_warn>
f011507f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115082:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115086:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011508a:	74 04                	je     f0115090 <test_calculate_required_frames+0x5e3>
f011508c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115090:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115094:	83 ec 04             	sub    $0x4,%esp
f0115097:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011509d:	50                   	push   %eax
f011509e:	68 34 a3 12 f0       	push   $0xf012a334
f01150a3:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01150a9:	50                   	push   %eax
f01150aa:	e8 a9 a9 00 00       	call   f011fa58 <strcconcat>
f01150af:	83 c4 10             	add    $0x10,%esp
f01150b2:	83 ec 0c             	sub    $0xc,%esp
f01150b5:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01150bb:	50                   	push   %eax
f01150bc:	e8 3a ce fe ff       	call   f0101efb <execute_command>
f01150c1:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01150c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01150c7:	89 c2                	mov    %eax,%edx
f01150c9:	01 d2                	add    %edx,%edx
f01150cb:	01 d0                	add    %edx,%eax
f01150cd:	83 ec 04             	sub    $0x4,%esp
f01150d0:	50                   	push   %eax
f01150d1:	68 00 18 00 00       	push   $0x1800
f01150d6:	ff 75 d8             	pushl  -0x28(%ebp)
f01150d9:	e8 ef 52 ff ff       	call   f010a3cd <calculate_required_frames>
f01150de:	83 c4 10             	add    $0x10,%esp
f01150e1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01150e4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01150eb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01150ee:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01150f1:	74 24                	je     f0115117 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01150f3:	83 ec 0c             	sub    $0xc,%esp
f01150f6:	ff 75 c4             	pushl  -0x3c(%ebp)
f01150f9:	ff 75 c8             	pushl  -0x38(%ebp)
f01150fc:	68 9c a2 12 f0       	push   $0xf012a29c
f0115101:	68 af 06 00 00       	push   $0x6af
f0115106:	68 22 8a 12 f0       	push   $0xf0128a22
f011510b:	e8 c6 b3 fe ff       	call   f01004d6 <_warn>
f0115110:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115113:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115117:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011511b:	74 04                	je     f0115121 <test_calculate_required_frames+0x674>
f011511d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115121:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115125:	83 ec 04             	sub    $0x4,%esp
f0115128:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011512e:	50                   	push   %eax
f011512f:	68 f4 93 12 f0       	push   $0xf01293f4
f0115134:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011513a:	50                   	push   %eax
f011513b:	e8 18 a9 00 00       	call   f011fa58 <strcconcat>
f0115140:	83 c4 10             	add    $0x10,%esp
f0115143:	83 ec 0c             	sub    $0xc,%esp
f0115146:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011514c:	50                   	push   %eax
f011514d:	e8 a9 cd fe ff       	call   f0101efb <execute_command>
f0115152:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115155:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115158:	89 d0                	mov    %edx,%eax
f011515a:	c1 e0 02             	shl    $0x2,%eax
f011515d:	01 d0                	add    %edx,%eax
f011515f:	01 c0                	add    %eax,%eax
f0115161:	83 ec 04             	sub    $0x4,%esp
f0115164:	50                   	push   %eax
f0115165:	68 00 00 40 00       	push   $0x400000
f011516a:	ff 75 d8             	pushl  -0x28(%ebp)
f011516d:	e8 5b 52 ff ff       	call   f010a3cd <calculate_required_frames>
f0115172:	83 c4 10             	add    $0x10,%esp
f0115175:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115178:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f011517f:	74 26                	je     f01151a7 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115181:	83 ec 0c             	sub    $0xc,%esp
f0115184:	68 03 0a 00 00       	push   $0xa03
f0115189:	ff 75 c8             	pushl  -0x38(%ebp)
f011518c:	68 9c a2 12 f0       	push   $0xf012a29c
f0115191:	68 bb 06 00 00       	push   $0x6bb
f0115196:	68 22 8a 12 f0       	push   $0xf0128a22
f011519b:	e8 36 b3 fe ff       	call   f01004d6 <_warn>
f01151a0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01151a3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01151a7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01151ab:	74 04                	je     f01151b1 <test_calculate_required_frames+0x704>
f01151ad:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01151b1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01151b5:	83 ec 04             	sub    $0x4,%esp
f01151b8:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01151be:	50                   	push   %eax
f01151bf:	68 fe 93 12 f0       	push   $0xf01293fe
f01151c4:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01151ca:	50                   	push   %eax
f01151cb:	e8 88 a8 00 00       	call   f011fa58 <strcconcat>
f01151d0:	83 c4 10             	add    $0x10,%esp
f01151d3:	83 ec 0c             	sub    $0xc,%esp
f01151d6:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01151dc:	50                   	push   %eax
f01151dd:	e8 19 cd fe ff       	call   f0101efb <execute_command>
f01151e2:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01151e5:	83 ec 04             	sub    $0x4,%esp
f01151e8:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01151ee:	50                   	push   %eax
f01151ef:	68 3c a3 12 f0       	push   $0xf012a33c
f01151f4:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01151fa:	50                   	push   %eax
f01151fb:	e8 58 a8 00 00       	call   f011fa58 <strcconcat>
f0115200:	83 c4 10             	add    $0x10,%esp
f0115203:	83 ec 0c             	sub    $0xc,%esp
f0115206:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011520c:	50                   	push   %eax
f011520d:	e8 e9 cc fe ff       	call   f0101efb <execute_command>
f0115212:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115215:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115218:	01 c0                	add    %eax,%eax
f011521a:	83 ec 04             	sub    $0x4,%esp
f011521d:	50                   	push   %eax
f011521e:	68 00 00 70 00       	push   $0x700000
f0115223:	ff 75 d8             	pushl  -0x28(%ebp)
f0115226:	e8 a2 51 ff ff       	call   f010a3cd <calculate_required_frames>
f011522b:	83 c4 10             	add    $0x10,%esp
f011522e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115231:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115238:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011523b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011523e:	74 24                	je     f0115264 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115240:	83 ec 0c             	sub    $0xc,%esp
f0115243:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115246:	ff 75 c8             	pushl  -0x38(%ebp)
f0115249:	68 9c a2 12 f0       	push   $0xf012a29c
f011524e:	68 cb 06 00 00       	push   $0x6cb
f0115253:	68 22 8a 12 f0       	push   $0xf0128a22
f0115258:	e8 79 b2 fe ff       	call   f01004d6 <_warn>
f011525d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115260:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115264:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115268:	74 04                	je     f011526e <test_calculate_required_frames+0x7c1>
f011526a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011526e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115272:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115275:	83 ec 04             	sub    $0x4,%esp
f0115278:	50                   	push   %eax
f0115279:	68 ff ff 3f 00       	push   $0x3fffff
f011527e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115281:	e8 47 51 ff ff       	call   f010a3cd <calculate_required_frames>
f0115286:	83 c4 10             	add    $0x10,%esp
f0115289:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f011528c:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115293:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115296:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115299:	74 24                	je     f01152bf <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011529b:	83 ec 0c             	sub    $0xc,%esp
f011529e:	ff 75 c4             	pushl  -0x3c(%ebp)
f01152a1:	ff 75 c8             	pushl  -0x38(%ebp)
f01152a4:	68 9c a2 12 f0       	push   $0xf012a29c
f01152a9:	68 d6 06 00 00       	push   $0x6d6
f01152ae:	68 22 8a 12 f0       	push   $0xf0128a22
f01152b3:	e8 1e b2 fe ff       	call   f01004d6 <_warn>
f01152b8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152bb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01152bf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01152c3:	74 04                	je     f01152c9 <test_calculate_required_frames+0x81c>
f01152c5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01152c9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01152cd:	83 ec 0c             	sub    $0xc,%esp
f01152d0:	68 af 93 12 f0       	push   $0xf01293af
f01152d5:	e8 b1 bc fe ff       	call   f0100f8b <cprintf>
f01152da:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f01152dd:	83 ec 08             	sub    $0x8,%esp
f01152e0:	ff 75 e4             	pushl  -0x1c(%ebp)
f01152e3:	68 48 a3 12 f0       	push   $0xf012a348
f01152e8:	e8 9e bc fe ff       	call   f0100f8b <cprintf>
f01152ed:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01152f0:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01152f4:	75 10                	jne    f0115306 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f01152f6:	83 ec 0c             	sub    $0xc,%esp
f01152f9:	68 88 a3 12 f0       	push   $0xf012a388
f01152fe:	e8 88 bc fe ff       	call   f0100f8b <cprintf>
f0115303:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115306:	a1 a4 ba 6b f0       	mov    0xf06bbaa4,%eax
f011530b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011530e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115311:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115314:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115319:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011531c:	5b                   	pop    %ebx
f011531d:	5e                   	pop    %esi
f011531e:	5f                   	pop    %edi
f011531f:	5d                   	pop    %ebp
f0115320:	c3                   	ret    

f0115321 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115321:	55                   	push   %ebp
f0115322:	89 e5                	mov    %esp,%ebp
f0115324:	57                   	push   %edi
f0115325:	56                   	push   %esi
f0115326:	53                   	push   %ebx
f0115327:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011532d:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115330:	bb 24 91 12 f0       	mov    $0xf0129124,%ebx
f0115335:	ba 0f 00 00 00       	mov    $0xf,%edx
f011533a:	89 c7                	mov    %eax,%edi
f011533c:	89 de                	mov    %ebx,%esi
f011533e:	89 d1                	mov    %edx,%ecx
f0115340:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115342:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115345:	b9 23 00 00 00       	mov    $0x23,%ecx
f011534a:	b0 00                	mov    $0x0,%al
f011534c:	89 d7                	mov    %edx,%edi
f011534e:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115350:	6a 00                	push   $0x0
f0115352:	6a 0a                	push   $0xa
f0115354:	6a 14                	push   $0x14
f0115356:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115359:	50                   	push   %eax
f011535a:	e8 ad 54 ff ff       	call   f010a80c <env_create>
f011535f:	83 c4 10             	add    $0x10,%esp
f0115362:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115365:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115368:	8b 40 64             	mov    0x64(%eax),%eax
f011536b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011536e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115371:	8b 40 68             	mov    0x68(%eax),%eax
f0115374:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115377:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011537a:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011537d:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115384:	75 70 20 
f0115387:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011538e:	00 00 00 
f0115391:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115394:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115399:	b8 00 00 00 00       	mov    $0x0,%eax
f011539e:	89 d7                	mov    %edx,%edi
f01153a0:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01153a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01153a5:	8b 40 10             	mov    0x10(%eax),%eax
f01153a8:	83 ec 08             	sub    $0x8,%esp
f01153ab:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01153b1:	52                   	push   %edx
f01153b2:	50                   	push   %eax
f01153b3:	e8 c7 a5 00 00       	call   f011f97f <ltostr>
f01153b8:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01153bb:	83 ec 04             	sub    $0x4,%esp
f01153be:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01153c4:	50                   	push   %eax
f01153c5:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01153cb:	50                   	push   %eax
f01153cc:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01153d2:	50                   	push   %eax
f01153d3:	e8 80 a6 00 00       	call   f011fa58 <strcconcat>
f01153d8:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01153db:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f01153e2:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f01153e9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f01153f0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f01153f4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01153fb:	00 00 00 
	uint32 num_tables = 0;
f01153fe:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115405:	00 00 00 
	ClearUserSpace(proc_directory);
f0115408:	83 ec 0c             	sub    $0xc,%esp
f011540b:	ff 75 d8             	pushl  -0x28(%ebp)
f011540e:	e8 8d 0e 00 00       	call   f01162a0 <ClearUserSpace>
f0115413:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115416:	83 ec 0c             	sub    $0xc,%esp
f0115419:	68 68 a2 12 f0       	push   $0xf012a268
f011541e:	e8 68 bb fe ff       	call   f0100f8b <cprintf>
f0115423:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115426:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115429:	c1 e0 03             	shl    $0x3,%eax
f011542c:	89 c2                	mov    %eax,%edx
f011542e:	83 ec 0c             	sub    $0xc,%esp
f0115431:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115437:	50                   	push   %eax
f0115438:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011543e:	50                   	push   %eax
f011543f:	52                   	push   %edx
f0115440:	6a 00                	push   $0x0
f0115442:	ff 75 d8             	pushl  -0x28(%ebp)
f0115445:	e8 69 4f ff ff       	call   f010a3b3 <calculate_allocated_space>
f011544a:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011544d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115453:	85 c0                	test   %eax,%eax
f0115455:	74 27                	je     f011547e <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115457:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011545d:	83 ec 0c             	sub    $0xc,%esp
f0115460:	6a 00                	push   $0x0
f0115462:	50                   	push   %eax
f0115463:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115468:	68 0b 07 00 00       	push   $0x70b
f011546d:	68 22 8a 12 f0       	push   $0xf0128a22
f0115472:	e8 5f b0 fe ff       	call   f01004d6 <_warn>
f0115477:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011547a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011547e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115484:	85 c0                	test   %eax,%eax
f0115486:	74 27                	je     f01154af <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115488:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011548e:	83 ec 0c             	sub    $0xc,%esp
f0115491:	6a 00                	push   $0x0
f0115493:	50                   	push   %eax
f0115494:	68 34 a4 12 f0       	push   $0xf012a434
f0115499:	68 10 07 00 00       	push   $0x710
f011549e:	68 22 8a 12 f0       	push   $0xf0128a22
f01154a3:	e8 2e b0 fe ff       	call   f01004d6 <_warn>
f01154a8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154ab:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01154af:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01154b3:	74 04                	je     f01154b9 <test_calculate_allocated_space+0x198>
f01154b5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01154b9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f01154bd:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01154c4:	00 00 00 
		num_pages = 0;
f01154c7:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01154ce:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f01154d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01154d4:	c1 e0 02             	shl    $0x2,%eax
f01154d7:	89 c2                	mov    %eax,%edx
f01154d9:	83 ec 0c             	sub    $0xc,%esp
f01154dc:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01154e2:	50                   	push   %eax
f01154e3:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01154e9:	50                   	push   %eax
f01154ea:	52                   	push   %edx
f01154eb:	6a 00                	push   $0x0
f01154ed:	ff 75 d8             	pushl  -0x28(%ebp)
f01154f0:	e8 be 4e ff ff       	call   f010a3b3 <calculate_allocated_space>
f01154f5:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01154f8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01154fe:	85 c0                	test   %eax,%eax
f0115500:	74 27                	je     f0115529 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115502:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115508:	83 ec 0c             	sub    $0xc,%esp
f011550b:	6a 00                	push   $0x0
f011550d:	50                   	push   %eax
f011550e:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115513:	68 1c 07 00 00       	push   $0x71c
f0115518:	68 22 8a 12 f0       	push   $0xf0128a22
f011551d:	e8 b4 af fe ff       	call   f01004d6 <_warn>
f0115522:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115525:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115529:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011552f:	85 c0                	test   %eax,%eax
f0115531:	74 27                	je     f011555a <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115533:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115539:	83 ec 0c             	sub    $0xc,%esp
f011553c:	6a 00                	push   $0x0
f011553e:	50                   	push   %eax
f011553f:	68 34 a4 12 f0       	push   $0xf012a434
f0115544:	68 21 07 00 00       	push   $0x721
f0115549:	68 22 8a 12 f0       	push   $0xf0128a22
f011554e:	e8 83 af fe ff       	call   f01004d6 <_warn>
f0115553:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115556:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011555a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011555e:	74 04                	je     f0115564 <test_calculate_allocated_space+0x243>
f0115560:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115564:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115568:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011556f:	00 00 00 
		num_pages = 0;
f0115572:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115579:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011557c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011557f:	c1 e0 0a             	shl    $0xa,%eax
f0115582:	89 c2                	mov    %eax,%edx
f0115584:	83 ec 0c             	sub    $0xc,%esp
f0115587:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011558d:	50                   	push   %eax
f011558e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115594:	50                   	push   %eax
f0115595:	52                   	push   %edx
f0115596:	6a 00                	push   $0x0
f0115598:	ff 75 d8             	pushl  -0x28(%ebp)
f011559b:	e8 13 4e ff ff       	call   f010a3b3 <calculate_allocated_space>
f01155a0:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01155a3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01155a9:	85 c0                	test   %eax,%eax
f01155ab:	74 27                	je     f01155d4 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01155ad:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01155b3:	83 ec 0c             	sub    $0xc,%esp
f01155b6:	6a 00                	push   $0x0
f01155b8:	50                   	push   %eax
f01155b9:	68 d4 a3 12 f0       	push   $0xf012a3d4
f01155be:	68 2d 07 00 00       	push   $0x72d
f01155c3:	68 22 8a 12 f0       	push   $0xf0128a22
f01155c8:	e8 09 af fe ff       	call   f01004d6 <_warn>
f01155cd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155d0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01155d4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01155da:	85 c0                	test   %eax,%eax
f01155dc:	74 27                	je     f0115605 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01155de:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01155e4:	83 ec 0c             	sub    $0xc,%esp
f01155e7:	6a 00                	push   $0x0
f01155e9:	50                   	push   %eax
f01155ea:	68 34 a4 12 f0       	push   $0xf012a434
f01155ef:	68 32 07 00 00       	push   $0x732
f01155f4:	68 22 8a 12 f0       	push   $0xf0128a22
f01155f9:	e8 d8 ae fe ff       	call   f01004d6 <_warn>
f01155fe:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115601:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115605:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115609:	74 04                	je     f011560f <test_calculate_allocated_space+0x2ee>
f011560b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011560f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115613:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011561a:	00 00 00 
		num_pages = 0;
f011561d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115624:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0115627:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011562a:	89 d0                	mov    %edx,%eax
f011562c:	01 c0                	add    %eax,%eax
f011562e:	01 d0                	add    %edx,%eax
f0115630:	01 c0                	add    %eax,%eax
f0115632:	05 00 10 00 00       	add    $0x1000,%eax
f0115637:	89 c2                	mov    %eax,%edx
f0115639:	83 ec 0c             	sub    $0xc,%esp
f011563c:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115642:	50                   	push   %eax
f0115643:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115649:	50                   	push   %eax
f011564a:	52                   	push   %edx
f011564b:	68 00 10 00 00       	push   $0x1000
f0115650:	ff 75 d8             	pushl  -0x28(%ebp)
f0115653:	e8 5b 4d ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115658:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011565b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115661:	85 c0                	test   %eax,%eax
f0115663:	74 27                	je     f011568c <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115665:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011566b:	83 ec 0c             	sub    $0xc,%esp
f011566e:	6a 00                	push   $0x0
f0115670:	50                   	push   %eax
f0115671:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115676:	68 3f 07 00 00       	push   $0x73f
f011567b:	68 22 8a 12 f0       	push   $0xf0128a22
f0115680:	e8 51 ae fe ff       	call   f01004d6 <_warn>
f0115685:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115688:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011568c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115692:	85 c0                	test   %eax,%eax
f0115694:	74 27                	je     f01156bd <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115696:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011569c:	83 ec 0c             	sub    $0xc,%esp
f011569f:	6a 00                	push   $0x0
f01156a1:	50                   	push   %eax
f01156a2:	68 34 a4 12 f0       	push   $0xf012a434
f01156a7:	68 44 07 00 00       	push   $0x744
f01156ac:	68 22 8a 12 f0       	push   $0xf0128a22
f01156b1:	e8 20 ae fe ff       	call   f01004d6 <_warn>
f01156b6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156b9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01156bd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01156c1:	74 04                	je     f01156c7 <test_calculate_allocated_space+0x3a6>
f01156c3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01156c7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f01156cb:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01156d2:	00 00 00 
		num_pages = 0;
f01156d5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01156dc:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f01156df:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01156e2:	89 c2                	mov    %eax,%edx
f01156e4:	01 d2                	add    %edx,%edx
f01156e6:	01 d0                	add    %edx,%eax
f01156e8:	05 00 18 00 00       	add    $0x1800,%eax
f01156ed:	89 c2                	mov    %eax,%edx
f01156ef:	83 ec 0c             	sub    $0xc,%esp
f01156f2:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01156f8:	50                   	push   %eax
f01156f9:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01156ff:	50                   	push   %eax
f0115700:	52                   	push   %edx
f0115701:	68 00 18 00 00       	push   $0x1800
f0115706:	ff 75 d8             	pushl  -0x28(%ebp)
f0115709:	e8 a5 4c ff ff       	call   f010a3b3 <calculate_allocated_space>
f011570e:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115711:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115717:	85 c0                	test   %eax,%eax
f0115719:	74 27                	je     f0115742 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011571b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115721:	83 ec 0c             	sub    $0xc,%esp
f0115724:	6a 00                	push   $0x0
f0115726:	50                   	push   %eax
f0115727:	68 d4 a3 12 f0       	push   $0xf012a3d4
f011572c:	68 50 07 00 00       	push   $0x750
f0115731:	68 22 8a 12 f0       	push   $0xf0128a22
f0115736:	e8 9b ad fe ff       	call   f01004d6 <_warn>
f011573b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011573e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115742:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115748:	85 c0                	test   %eax,%eax
f011574a:	74 27                	je     f0115773 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011574c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115752:	83 ec 0c             	sub    $0xc,%esp
f0115755:	6a 00                	push   $0x0
f0115757:	50                   	push   %eax
f0115758:	68 34 a4 12 f0       	push   $0xf012a434
f011575d:	68 55 07 00 00       	push   $0x755
f0115762:	68 22 8a 12 f0       	push   $0xf0128a22
f0115767:	e8 6a ad fe ff       	call   f01004d6 <_warn>
f011576c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011576f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115773:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115777:	74 04                	je     f011577d <test_calculate_allocated_space+0x45c>
f0115779:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011577d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0115781:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115788:	00 00 00 
		num_pages = 0;
f011578b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115792:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115795:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115798:	89 d0                	mov    %edx,%eax
f011579a:	c1 e0 02             	shl    $0x2,%eax
f011579d:	01 d0                	add    %edx,%eax
f011579f:	01 c0                	add    %eax,%eax
f01157a1:	05 00 00 40 00       	add    $0x400000,%eax
f01157a6:	89 c2                	mov    %eax,%edx
f01157a8:	83 ec 0c             	sub    $0xc,%esp
f01157ab:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01157b1:	50                   	push   %eax
f01157b2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01157b8:	50                   	push   %eax
f01157b9:	52                   	push   %edx
f01157ba:	68 00 00 40 00       	push   $0x400000
f01157bf:	ff 75 d8             	pushl  -0x28(%ebp)
f01157c2:	e8 ec 4b ff ff       	call   f010a3b3 <calculate_allocated_space>
f01157c7:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01157ca:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01157d0:	85 c0                	test   %eax,%eax
f01157d2:	74 27                	je     f01157fb <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01157d4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01157da:	83 ec 0c             	sub    $0xc,%esp
f01157dd:	6a 00                	push   $0x0
f01157df:	50                   	push   %eax
f01157e0:	68 d4 a3 12 f0       	push   $0xf012a3d4
f01157e5:	68 61 07 00 00       	push   $0x761
f01157ea:	68 22 8a 12 f0       	push   $0xf0128a22
f01157ef:	e8 e2 ac fe ff       	call   f01004d6 <_warn>
f01157f4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157f7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01157fb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115801:	85 c0                	test   %eax,%eax
f0115803:	74 27                	je     f011582c <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115805:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011580b:	83 ec 0c             	sub    $0xc,%esp
f011580e:	6a 00                	push   $0x0
f0115810:	50                   	push   %eax
f0115811:	68 34 a4 12 f0       	push   $0xf012a434
f0115816:	68 66 07 00 00       	push   $0x766
f011581b:	68 22 8a 12 f0       	push   $0xf0128a22
f0115820:	e8 b1 ac fe ff       	call   f01004d6 <_warn>
f0115825:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115828:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011582c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115830:	74 04                	je     f0115836 <test_calculate_allocated_space+0x515>
f0115832:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115836:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f011583a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115841:	00 00 00 
		num_pages = 0;
f0115844:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011584b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f011584e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115851:	05 00 00 38 00       	add    $0x380000,%eax
f0115856:	01 c0                	add    %eax,%eax
f0115858:	89 c2                	mov    %eax,%edx
f011585a:	83 ec 0c             	sub    $0xc,%esp
f011585d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115863:	50                   	push   %eax
f0115864:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011586a:	50                   	push   %eax
f011586b:	52                   	push   %edx
f011586c:	68 00 00 70 00       	push   $0x700000
f0115871:	ff 75 d8             	pushl  -0x28(%ebp)
f0115874:	e8 3a 4b ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115879:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011587c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115882:	85 c0                	test   %eax,%eax
f0115884:	74 27                	je     f01158ad <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115886:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011588c:	83 ec 0c             	sub    $0xc,%esp
f011588f:	6a 00                	push   $0x0
f0115891:	50                   	push   %eax
f0115892:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115897:	68 73 07 00 00       	push   $0x773
f011589c:	68 22 8a 12 f0       	push   $0xf0128a22
f01158a1:	e8 30 ac fe ff       	call   f01004d6 <_warn>
f01158a6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158a9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01158ad:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01158b3:	85 c0                	test   %eax,%eax
f01158b5:	74 27                	je     f01158de <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01158b7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01158bd:	83 ec 0c             	sub    $0xc,%esp
f01158c0:	6a 00                	push   $0x0
f01158c2:	50                   	push   %eax
f01158c3:	68 34 a4 12 f0       	push   $0xf012a434
f01158c8:	68 78 07 00 00       	push   $0x778
f01158cd:	68 22 8a 12 f0       	push   $0xf0128a22
f01158d2:	e8 ff ab fe ff       	call   f01004d6 <_warn>
f01158d7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158da:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01158de:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01158e2:	74 04                	je     f01158e8 <test_calculate_allocated_space+0x5c7>
f01158e4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01158e8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f01158ec:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01158f3:	00 00 00 
		num_pages = 0;
f01158f6:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01158fd:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0115900:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115903:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0115908:	89 c2                	mov    %eax,%edx
f011590a:	83 ec 0c             	sub    $0xc,%esp
f011590d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115913:	50                   	push   %eax
f0115914:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011591a:	50                   	push   %eax
f011591b:	52                   	push   %edx
f011591c:	68 ff ff 3f 00       	push   $0x3fffff
f0115921:	ff 75 d8             	pushl  -0x28(%ebp)
f0115924:	e8 8a 4a ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115929:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011592c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115932:	85 c0                	test   %eax,%eax
f0115934:	74 27                	je     f011595d <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115936:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011593c:	83 ec 0c             	sub    $0xc,%esp
f011593f:	6a 00                	push   $0x0
f0115941:	50                   	push   %eax
f0115942:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115947:	68 84 07 00 00       	push   $0x784
f011594c:	68 22 8a 12 f0       	push   $0xf0128a22
f0115951:	e8 80 ab fe ff       	call   f01004d6 <_warn>
f0115956:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115959:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011595d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115963:	85 c0                	test   %eax,%eax
f0115965:	74 27                	je     f011598e <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115967:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011596d:	83 ec 0c             	sub    $0xc,%esp
f0115970:	6a 00                	push   $0x0
f0115972:	50                   	push   %eax
f0115973:	68 34 a4 12 f0       	push   $0xf012a434
f0115978:	68 89 07 00 00       	push   $0x789
f011597d:	68 22 8a 12 f0       	push   $0xf0128a22
f0115982:	e8 4f ab fe ff       	call   f01004d6 <_warn>
f0115987:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011598a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011598e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115992:	74 04                	je     f0115998 <test_calculate_allocated_space+0x677>
f0115994:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115998:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011599c:	83 ec 0c             	sub    $0xc,%esp
f011599f:	68 d5 9d 12 f0       	push   $0xf0129dd5
f01159a4:	e8 e2 b5 fe ff       	call   f0100f8b <cprintf>
f01159a9:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f01159ac:	83 ec 0c             	sub    $0xc,%esp
f01159af:	68 f4 a2 12 f0       	push   $0xf012a2f4
f01159b4:	e8 d2 b5 fe ff       	call   f0100f8b <cprintf>
f01159b9:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01159bc:	83 ec 04             	sub    $0x4,%esp
f01159bf:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f01159c5:	50                   	push   %eax
f01159c6:	68 8e 91 12 f0       	push   $0xf012918e
f01159cb:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01159d1:	50                   	push   %eax
f01159d2:	e8 81 a0 00 00       	call   f011fa58 <strcconcat>
f01159d7:	83 c4 10             	add    $0x10,%esp
f01159da:	83 ec 0c             	sub    $0xc,%esp
f01159dd:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f01159e3:	50                   	push   %eax
f01159e4:	e8 12 c5 fe ff       	call   f0101efb <execute_command>
f01159e9:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f01159ec:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01159f3:	00 00 00 
		num_pages = 0;
f01159f6:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01159fd:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115a00:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115a03:	c1 e0 03             	shl    $0x3,%eax
f0115a06:	89 c2                	mov    %eax,%edx
f0115a08:	83 ec 0c             	sub    $0xc,%esp
f0115a0b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115a11:	50                   	push   %eax
f0115a12:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115a18:	50                   	push   %eax
f0115a19:	52                   	push   %edx
f0115a1a:	6a 00                	push   $0x0
f0115a1c:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a1f:	e8 8f 49 ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115a24:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0115a27:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0115a2e:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115a35:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a3b:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115a3e:	74 28                	je     f0115a68 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115a40:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a46:	83 ec 0c             	sub    $0xc,%esp
f0115a49:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a4c:	50                   	push   %eax
f0115a4d:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115a52:	68 a0 07 00 00       	push   $0x7a0
f0115a57:	68 22 8a 12 f0       	push   $0xf0128a22
f0115a5c:	e8 75 aa fe ff       	call   f01004d6 <_warn>
f0115a61:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a64:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115a68:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a6e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115a71:	74 28                	je     f0115a9b <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115a73:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a79:	83 ec 0c             	sub    $0xc,%esp
f0115a7c:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115a7f:	50                   	push   %eax
f0115a80:	68 34 a4 12 f0       	push   $0xf012a434
f0115a85:	68 a5 07 00 00       	push   $0x7a5
f0115a8a:	68 22 8a 12 f0       	push   $0xf0128a22
f0115a8f:	e8 42 aa fe ff       	call   f01004d6 <_warn>
f0115a94:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a97:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a9b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a9f:	74 04                	je     f0115aa5 <test_calculate_allocated_space+0x784>
f0115aa1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115aa5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115aa9:	83 ec 04             	sub    $0x4,%esp
f0115aac:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115ab2:	50                   	push   %eax
f0115ab3:	68 9b 91 12 f0       	push   $0xf012919b
f0115ab8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115abe:	50                   	push   %eax
f0115abf:	e8 94 9f 00 00       	call   f011fa58 <strcconcat>
f0115ac4:	83 c4 10             	add    $0x10,%esp
f0115ac7:	83 ec 0c             	sub    $0xc,%esp
f0115aca:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115ad0:	50                   	push   %eax
f0115ad1:	e8 25 c4 fe ff       	call   f0101efb <execute_command>
f0115ad6:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115ad9:	83 ec 04             	sub    $0x4,%esp
f0115adc:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115ae2:	50                   	push   %eax
f0115ae3:	68 28 a3 12 f0       	push   $0xf012a328
f0115ae8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115aee:	50                   	push   %eax
f0115aef:	e8 64 9f 00 00       	call   f011fa58 <strcconcat>
f0115af4:	83 c4 10             	add    $0x10,%esp
f0115af7:	83 ec 0c             	sub    $0xc,%esp
f0115afa:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115b00:	50                   	push   %eax
f0115b01:	e8 f5 c3 fe ff       	call   f0101efb <execute_command>
f0115b06:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0115b09:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115b10:	00 00 00 
		num_pages = 0;
f0115b13:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115b1a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0115b1d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115b20:	c1 e0 03             	shl    $0x3,%eax
f0115b23:	89 c2                	mov    %eax,%edx
f0115b25:	83 ec 0c             	sub    $0xc,%esp
f0115b28:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115b2e:	50                   	push   %eax
f0115b2f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115b35:	50                   	push   %eax
f0115b36:	52                   	push   %edx
f0115b37:	6a 00                	push   $0x0
f0115b39:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b3c:	e8 72 48 ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115b41:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0115b44:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0115b4b:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115b52:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b58:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115b5b:	74 28                	je     f0115b85 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115b5d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b63:	83 ec 0c             	sub    $0xc,%esp
f0115b66:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b69:	50                   	push   %eax
f0115b6a:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115b6f:	68 b6 07 00 00       	push   $0x7b6
f0115b74:	68 22 8a 12 f0       	push   $0xf0128a22
f0115b79:	e8 58 a9 fe ff       	call   f01004d6 <_warn>
f0115b7e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b81:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115b85:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115b8b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115b8e:	74 28                	je     f0115bb8 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115b90:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115b96:	83 ec 0c             	sub    $0xc,%esp
f0115b99:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115b9c:	50                   	push   %eax
f0115b9d:	68 34 a4 12 f0       	push   $0xf012a434
f0115ba2:	68 bb 07 00 00       	push   $0x7bb
f0115ba7:	68 22 8a 12 f0       	push   $0xf0128a22
f0115bac:	e8 25 a9 fe ff       	call   f01004d6 <_warn>
f0115bb1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115bb4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115bb8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115bbc:	74 04                	je     f0115bc2 <test_calculate_allocated_space+0x8a1>
f0115bbe:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115bc2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115bc6:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115bcd:	00 00 00 
		num_pages = 0;
f0115bd0:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115bd7:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115bda:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115bdd:	c1 e0 0a             	shl    $0xa,%eax
f0115be0:	89 c2                	mov    %eax,%edx
f0115be2:	83 ec 0c             	sub    $0xc,%esp
f0115be5:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115beb:	50                   	push   %eax
f0115bec:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115bf2:	50                   	push   %eax
f0115bf3:	52                   	push   %edx
f0115bf4:	6a 00                	push   $0x0
f0115bf6:	ff 75 d8             	pushl  -0x28(%ebp)
f0115bf9:	e8 b5 47 ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115bfe:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0115c01:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0115c08:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115c0f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c15:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115c18:	74 28                	je     f0115c42 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115c1a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c20:	83 ec 0c             	sub    $0xc,%esp
f0115c23:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c26:	50                   	push   %eax
f0115c27:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115c2c:	68 c9 07 00 00       	push   $0x7c9
f0115c31:	68 22 8a 12 f0       	push   $0xf0128a22
f0115c36:	e8 9b a8 fe ff       	call   f01004d6 <_warn>
f0115c3b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c3e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115c42:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c48:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115c4b:	74 28                	je     f0115c75 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115c4d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c53:	83 ec 0c             	sub    $0xc,%esp
f0115c56:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115c59:	50                   	push   %eax
f0115c5a:	68 34 a4 12 f0       	push   $0xf012a434
f0115c5f:	68 ce 07 00 00       	push   $0x7ce
f0115c64:	68 22 8a 12 f0       	push   $0xf0128a22
f0115c69:	e8 68 a8 fe ff       	call   f01004d6 <_warn>
f0115c6e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c71:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115c75:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115c79:	74 04                	je     f0115c7f <test_calculate_allocated_space+0x95e>
f0115c7b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115c7f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115c83:	83 ec 04             	sub    $0x4,%esp
f0115c86:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115c8c:	50                   	push   %eax
f0115c8d:	68 34 a3 12 f0       	push   $0xf012a334
f0115c92:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c98:	50                   	push   %eax
f0115c99:	e8 ba 9d 00 00       	call   f011fa58 <strcconcat>
f0115c9e:	83 c4 10             	add    $0x10,%esp
f0115ca1:	83 ec 0c             	sub    $0xc,%esp
f0115ca4:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115caa:	50                   	push   %eax
f0115cab:	e8 4b c2 fe ff       	call   f0101efb <execute_command>
f0115cb0:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0115cb3:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115cba:	00 00 00 
		num_pages = 0;
f0115cbd:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115cc4:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115cc7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115cca:	89 c2                	mov    %eax,%edx
f0115ccc:	01 d2                	add    %edx,%edx
f0115cce:	01 d0                	add    %edx,%eax
f0115cd0:	05 00 18 00 00       	add    $0x1800,%eax
f0115cd5:	89 c2                	mov    %eax,%edx
f0115cd7:	83 ec 0c             	sub    $0xc,%esp
f0115cda:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115ce0:	50                   	push   %eax
f0115ce1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115ce7:	50                   	push   %eax
f0115ce8:	52                   	push   %edx
f0115ce9:	68 00 18 00 00       	push   $0x1800
f0115cee:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cf1:	e8 bd 46 ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115cf6:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115cf9:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0115d00:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115d07:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d0d:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115d10:	74 28                	je     f0115d3a <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115d12:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d18:	83 ec 0c             	sub    $0xc,%esp
f0115d1b:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d1e:	50                   	push   %eax
f0115d1f:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115d24:	68 df 07 00 00       	push   $0x7df
f0115d29:	68 22 8a 12 f0       	push   $0xf0128a22
f0115d2e:	e8 a3 a7 fe ff       	call   f01004d6 <_warn>
f0115d33:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d36:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115d3a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d40:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115d43:	74 28                	je     f0115d6d <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115d45:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d4b:	83 ec 0c             	sub    $0xc,%esp
f0115d4e:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d51:	50                   	push   %eax
f0115d52:	68 34 a4 12 f0       	push   $0xf012a434
f0115d57:	68 e4 07 00 00       	push   $0x7e4
f0115d5c:	68 22 8a 12 f0       	push   $0xf0128a22
f0115d61:	e8 70 a7 fe ff       	call   f01004d6 <_warn>
f0115d66:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d69:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d6d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d71:	74 04                	je     f0115d77 <test_calculate_allocated_space+0xa56>
f0115d73:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d77:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115d7b:	83 ec 04             	sub    $0x4,%esp
f0115d7e:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115d84:	50                   	push   %eax
f0115d85:	68 f4 93 12 f0       	push   $0xf01293f4
f0115d8a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115d90:	50                   	push   %eax
f0115d91:	e8 c2 9c 00 00       	call   f011fa58 <strcconcat>
f0115d96:	83 c4 10             	add    $0x10,%esp
f0115d99:	83 ec 0c             	sub    $0xc,%esp
f0115d9c:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115da2:	50                   	push   %eax
f0115da3:	e8 53 c1 fe ff       	call   f0101efb <execute_command>
f0115da8:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0115dab:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115db2:	00 00 00 
		num_pages = 0;
f0115db5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115dbc:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115dbf:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115dc2:	89 d0                	mov    %edx,%eax
f0115dc4:	c1 e0 02             	shl    $0x2,%eax
f0115dc7:	01 d0                	add    %edx,%eax
f0115dc9:	01 c0                	add    %eax,%eax
f0115dcb:	05 00 00 40 00       	add    $0x400000,%eax
f0115dd0:	89 c2                	mov    %eax,%edx
f0115dd2:	83 ec 0c             	sub    $0xc,%esp
f0115dd5:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115ddb:	50                   	push   %eax
f0115ddc:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115de2:	50                   	push   %eax
f0115de3:	52                   	push   %edx
f0115de4:	68 00 00 40 00       	push   $0x400000
f0115de9:	ff 75 d8             	pushl  -0x28(%ebp)
f0115dec:	e8 c2 45 ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115df1:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115df4:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0115dfb:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115e02:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e08:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115e0b:	74 28                	je     f0115e35 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115e0d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e13:	83 ec 0c             	sub    $0xc,%esp
f0115e16:	ff 75 c8             	pushl  -0x38(%ebp)
f0115e19:	50                   	push   %eax
f0115e1a:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115e1f:	68 f4 07 00 00       	push   $0x7f4
f0115e24:	68 22 8a 12 f0       	push   $0xf0128a22
f0115e29:	e8 a8 a6 fe ff       	call   f01004d6 <_warn>
f0115e2e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e31:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115e35:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e3b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115e3e:	74 28                	je     f0115e68 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115e40:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e46:	83 ec 0c             	sub    $0xc,%esp
f0115e49:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115e4c:	50                   	push   %eax
f0115e4d:	68 34 a4 12 f0       	push   $0xf012a434
f0115e52:	68 f9 07 00 00       	push   $0x7f9
f0115e57:	68 22 8a 12 f0       	push   $0xf0128a22
f0115e5c:	e8 75 a6 fe ff       	call   f01004d6 <_warn>
f0115e61:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e64:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e68:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e6c:	74 04                	je     f0115e72 <test_calculate_allocated_space+0xb51>
f0115e6e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e72:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115e76:	83 ec 04             	sub    $0x4,%esp
f0115e79:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115e7f:	50                   	push   %eax
f0115e80:	68 fe 93 12 f0       	push   $0xf01293fe
f0115e85:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115e8b:	50                   	push   %eax
f0115e8c:	e8 c7 9b 00 00       	call   f011fa58 <strcconcat>
f0115e91:	83 c4 10             	add    $0x10,%esp
f0115e94:	83 ec 0c             	sub    $0xc,%esp
f0115e97:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115e9d:	50                   	push   %eax
f0115e9e:	e8 58 c0 fe ff       	call   f0101efb <execute_command>
f0115ea3:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115ea6:	83 ec 04             	sub    $0x4,%esp
f0115ea9:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115eaf:	50                   	push   %eax
f0115eb0:	68 3c a3 12 f0       	push   $0xf012a33c
f0115eb5:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115ebb:	50                   	push   %eax
f0115ebc:	e8 97 9b 00 00       	call   f011fa58 <strcconcat>
f0115ec1:	83 c4 10             	add    $0x10,%esp
f0115ec4:	83 ec 0c             	sub    $0xc,%esp
f0115ec7:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115ecd:	50                   	push   %eax
f0115ece:	e8 28 c0 fe ff       	call   f0101efb <execute_command>
f0115ed3:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0115ed6:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115edd:	00 00 00 
		num_pages = 0;
f0115ee0:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115ee7:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0115eea:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115eed:	05 00 00 38 00       	add    $0x380000,%eax
f0115ef2:	01 c0                	add    %eax,%eax
f0115ef4:	89 c2                	mov    %eax,%edx
f0115ef6:	83 ec 0c             	sub    $0xc,%esp
f0115ef9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115eff:	50                   	push   %eax
f0115f00:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f06:	50                   	push   %eax
f0115f07:	52                   	push   %edx
f0115f08:	68 00 00 70 00       	push   $0x700000
f0115f0d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f10:	e8 9e 44 ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115f15:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115f18:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0115f1f:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115f26:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f2c:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115f2f:	74 28                	je     f0115f59 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115f31:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f37:	83 ec 0c             	sub    $0xc,%esp
f0115f3a:	ff 75 c8             	pushl  -0x38(%ebp)
f0115f3d:	50                   	push   %eax
f0115f3e:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115f43:	68 0b 08 00 00       	push   $0x80b
f0115f48:	68 22 8a 12 f0       	push   $0xf0128a22
f0115f4d:	e8 84 a5 fe ff       	call   f01004d6 <_warn>
f0115f52:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f55:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115f59:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f5f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115f62:	74 28                	je     f0115f8c <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115f64:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f6a:	83 ec 0c             	sub    $0xc,%esp
f0115f6d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115f70:	50                   	push   %eax
f0115f71:	68 34 a4 12 f0       	push   $0xf012a434
f0115f76:	68 10 08 00 00       	push   $0x810
f0115f7b:	68 22 8a 12 f0       	push   $0xf0128a22
f0115f80:	e8 51 a5 fe ff       	call   f01004d6 <_warn>
f0115f85:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f88:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115f8c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f90:	74 04                	je     f0115f96 <test_calculate_allocated_space+0xc75>
f0115f92:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115f96:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0115f9a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115fa1:	00 00 00 
		num_pages = 0;
f0115fa4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115fab:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0115fae:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115fb1:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0115fb6:	89 c2                	mov    %eax,%edx
f0115fb8:	83 ec 0c             	sub    $0xc,%esp
f0115fbb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115fc1:	50                   	push   %eax
f0115fc2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115fc8:	50                   	push   %eax
f0115fc9:	52                   	push   %edx
f0115fca:	68 ff ff 3f 00       	push   $0x3fffff
f0115fcf:	ff 75 d8             	pushl  -0x28(%ebp)
f0115fd2:	e8 dc 43 ff ff       	call   f010a3b3 <calculate_allocated_space>
f0115fd7:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115fda:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0115fe1:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115fe8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115fee:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115ff1:	74 28                	je     f011601b <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115ff3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ff9:	83 ec 0c             	sub    $0xc,%esp
f0115ffc:	ff 75 c8             	pushl  -0x38(%ebp)
f0115fff:	50                   	push   %eax
f0116000:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0116005:	68 1e 08 00 00       	push   $0x81e
f011600a:	68 22 8a 12 f0       	push   $0xf0128a22
f011600f:	e8 c2 a4 fe ff       	call   f01004d6 <_warn>
f0116014:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116017:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011601b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116021:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116024:	74 28                	je     f011604e <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116026:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011602c:	83 ec 0c             	sub    $0xc,%esp
f011602f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116032:	50                   	push   %eax
f0116033:	68 34 a4 12 f0       	push   $0xf012a434
f0116038:	68 23 08 00 00       	push   $0x823
f011603d:	68 22 8a 12 f0       	push   $0xf0128a22
f0116042:	e8 8f a4 fe ff       	call   f01004d6 <_warn>
f0116047:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011604a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011604e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116052:	74 04                	je     f0116058 <test_calculate_allocated_space+0xd37>
f0116054:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116058:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011605c:	83 ec 0c             	sub    $0xc,%esp
f011605f:	68 af 93 12 f0       	push   $0xf01293af
f0116064:	e8 22 af fe ff       	call   f0100f8b <cprintf>
f0116069:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f011606c:	83 ec 08             	sub    $0x8,%esp
f011606f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116072:	68 90 a4 12 f0       	push   $0xf012a490
f0116077:	e8 0f af fe ff       	call   f0100f8b <cprintf>
f011607c:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011607f:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116083:	75 10                	jne    f0116095 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116085:	83 ec 0c             	sub    $0xc,%esp
f0116088:	68 d0 a4 12 f0       	push   $0xf012a4d0
f011608d:	e8 f9 ae fe ff       	call   f0100f8b <cprintf>
f0116092:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116095:	a1 a4 ba 6b f0       	mov    0xf06bbaa4,%eax
f011609a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011609d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01160a0:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01160a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01160a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01160ab:	5b                   	pop    %ebx
f01160ac:	5e                   	pop    %esi
f01160ad:	5f                   	pop    %edi
f01160ae:	5d                   	pop    %ebp
f01160af:	c3                   	ret    

f01160b0 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f01160b0:	55                   	push   %ebp
f01160b1:	89 e5                	mov    %esp,%ebp
f01160b3:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f01160b6:	8b 45 10             	mov    0x10(%ebp),%eax
f01160b9:	ba 01 00 00 00       	mov    $0x1,%edx
f01160be:	88 c1                	mov    %al,%cl
f01160c0:	d3 e2                	shl    %cl,%edx
f01160c2:	89 d0                	mov    %edx,%eax
f01160c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01160c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01160ca:	c1 e8 16             	shr    $0x16,%eax
f01160cd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01160d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01160d7:	01 d0                	add    %edx,%eax
f01160d9:	8b 00                	mov    (%eax),%eax
f01160db:	83 e0 01             	and    $0x1,%eax
f01160de:	85 c0                	test   %eax,%eax
f01160e0:	75 07                	jne    f01160e9 <CB+0x39>
f01160e2:	b8 00 00 00 00       	mov    $0x0,%eax
f01160e7:	eb 76                	jmp    f011615f <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01160e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01160ec:	c1 e8 16             	shr    $0x16,%eax
f01160ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01160f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01160f9:	01 d0                	add    %edx,%eax
f01160fb:	8b 00                	mov    (%eax),%eax
f01160fd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116102:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116105:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116108:	c1 e8 0c             	shr    $0xc,%eax
f011610b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011610e:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f0116113:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116116:	72 17                	jb     f011612f <CB+0x7f>
f0116118:	ff 75 f0             	pushl  -0x10(%ebp)
f011611b:	68 1c a5 12 f0       	push   $0xf012a51c
f0116120:	68 3e 08 00 00       	push   $0x83e
f0116125:	68 22 8a 12 f0       	push   $0xf0128a22
f011612a:	e8 0a a2 fe ff       	call   f0100339 <_panic>
f011612f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116132:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116137:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f011613a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011613d:	c1 e8 0c             	shr    $0xc,%eax
f0116140:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116145:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011614c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011614f:	01 d0                	add    %edx,%eax
f0116151:	8b 00                	mov    (%eax),%eax
f0116153:	23 45 f4             	and    -0xc(%ebp),%eax
f0116156:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116159:	0f 94 c0             	sete   %al
f011615c:	0f b6 c0             	movzbl %al,%eax
}
f011615f:	c9                   	leave  
f0116160:	c3                   	ret    

f0116161 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0116161:	55                   	push   %ebp
f0116162:	89 e5                	mov    %esp,%ebp
f0116164:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116167:	68 4b a5 12 f0       	push   $0xf012a54b
f011616c:	68 5a a5 12 f0       	push   $0xf012a55a
f0116171:	68 43 08 00 00       	push   $0x843
f0116176:	68 22 8a 12 f0       	push   $0xf0128a22
f011617b:	e8 b9 a1 fe ff       	call   f0100339 <_panic>

f0116180 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116180:	55                   	push   %ebp
f0116181:	89 e5                	mov    %esp,%ebp
f0116183:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116186:	68 4b a5 12 f0       	push   $0xf012a54b
f011618b:	68 5a a5 12 f0       	push   $0xf012a55a
f0116190:	68 4d 08 00 00       	push   $0x84d
f0116195:	68 22 8a 12 f0       	push   $0xf0128a22
f011619a:	e8 9a a1 fe ff       	call   f0100339 <_panic>

f011619f <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f011619f:	55                   	push   %ebp
f01161a0:	89 e5                	mov    %esp,%ebp
f01161a2:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01161a5:	68 4b a5 12 f0       	push   $0xf012a54b
f01161aa:	68 5a a5 12 f0       	push   $0xf012a55a
f01161af:	68 5c 08 00 00       	push   $0x85c
f01161b4:	68 22 8a 12 f0       	push   $0xf0128a22
f01161b9:	e8 7b a1 fe ff       	call   f0100339 <_panic>

f01161be <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f01161be:	55                   	push   %ebp
f01161bf:	89 e5                	mov    %esp,%ebp
f01161c1:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01161c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01161c7:	c1 e8 16             	shr    $0x16,%eax
f01161ca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01161d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01161d4:	01 d0                	add    %edx,%eax
f01161d6:	8b 00                	mov    (%eax),%eax
f01161d8:	83 e0 01             	and    $0x1,%eax
f01161db:	85 c0                	test   %eax,%eax
f01161dd:	75 07                	jne    f01161e6 <CE+0x28>
f01161df:	b8 00 00 00 00       	mov    $0x0,%eax
f01161e4:	eb 7a                	jmp    f0116260 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01161e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01161e9:	c1 e8 16             	shr    $0x16,%eax
f01161ec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01161f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01161f6:	01 d0                	add    %edx,%eax
f01161f8:	8b 00                	mov    (%eax),%eax
f01161fa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01161ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116202:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116205:	c1 e8 0c             	shr    $0xc,%eax
f0116208:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011620b:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f0116210:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116213:	72 17                	jb     f011622c <CE+0x6e>
f0116215:	ff 75 f4             	pushl  -0xc(%ebp)
f0116218:	68 1c a5 12 f0       	push   $0xf012a51c
f011621d:	68 65 08 00 00       	push   $0x865
f0116222:	68 22 8a 12 f0       	push   $0xf0128a22
f0116227:	e8 0d a1 fe ff       	call   f0100339 <_panic>
f011622c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011622f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116234:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116237:	8b 45 0c             	mov    0xc(%ebp),%eax
f011623a:	c1 e8 0c             	shr    $0xc,%eax
f011623d:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116242:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116249:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011624c:	01 d0                	add    %edx,%eax
f011624e:	8b 00                	mov    (%eax),%eax
f0116250:	85 c0                	test   %eax,%eax
f0116252:	74 07                	je     f011625b <CE+0x9d>
f0116254:	b8 00 00 00 00       	mov    $0x0,%eax
f0116259:	eb 05                	jmp    f0116260 <CE+0xa2>
	return 1;
f011625b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116260:	c9                   	leave  
f0116261:	c3                   	ret    

f0116262 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116262:	55                   	push   %ebp
f0116263:	89 e5                	mov    %esp,%ebp
f0116265:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116268:	68 4b a5 12 f0       	push   $0xf012a54b
f011626d:	68 5a a5 12 f0       	push   $0xf012a55a
f0116272:	68 6c 08 00 00       	push   $0x86c
f0116277:	68 22 8a 12 f0       	push   $0xf0128a22
f011627c:	e8 b8 a0 fe ff       	call   f0100339 <_panic>

f0116281 <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116281:	55                   	push   %ebp
f0116282:	89 e5                	mov    %esp,%ebp
f0116284:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116287:	68 4b a5 12 f0       	push   $0xf012a54b
f011628c:	68 5a a5 12 f0       	push   $0xf012a55a
f0116291:	68 7c 08 00 00       	push   $0x87c
f0116296:	68 22 8a 12 f0       	push   $0xf0128a22
f011629b:	e8 99 a0 fe ff       	call   f0100339 <_panic>

f01162a0 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f01162a0:	55                   	push   %ebp
f01162a1:	89 e5                	mov    %esp,%ebp
f01162a3:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01162a6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01162ad:	eb 18                	jmp    f01162c7 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f01162af:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01162b2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01162b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01162bc:	01 d0                	add    %edx,%eax
f01162be:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01162c4:	ff 45 fc             	incl   -0x4(%ebp)
f01162c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01162ca:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f01162cf:	76 de                	jbe    f01162af <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f01162d1:	90                   	nop
f01162d2:	c9                   	leave  
f01162d3:	c3                   	ret    

f01162d4 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f01162d4:	55                   	push   %ebp
f01162d5:	89 e5                	mov    %esp,%ebp
f01162d7:	83 ec 38             	sub    $0x38,%esp
f01162da:	8b 45 2c             	mov    0x2c(%ebp),%eax
f01162dd:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f01162e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01162e3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01162e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f01162eb:	8b 45 10             	mov    0x10(%ebp),%eax
f01162ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01162f3:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f01162f6:	e9 ea 01 00 00       	jmp    f01164e5 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f01162fb:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01162ff:	74 44                	je     f0116345 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116301:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116304:	83 ec 04             	sub    $0x4,%esp
f0116307:	8d 55 dc             	lea    -0x24(%ebp),%edx
f011630a:	52                   	push   %edx
f011630b:	50                   	push   %eax
f011630c:	ff 75 08             	pushl  0x8(%ebp)
f011630f:	e8 55 24 ff ff       	call   f0108769 <get_frame_info>
f0116314:	83 c4 10             	add    $0x10,%esp
f0116317:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f011631a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011631d:	85 c0                	test   %eax,%eax
f011631f:	75 24                	jne    f0116345 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116321:	83 ec 04             	sub    $0x4,%esp
f0116324:	68 70 a5 12 f0       	push   $0xf012a570
f0116329:	68 99 08 00 00       	push   $0x899
f011632e:	68 22 8a 12 f0       	push   $0xf0128a22
f0116333:	e8 9e a1 fe ff       	call   f01004d6 <_warn>
f0116338:	83 c4 10             	add    $0x10,%esp
				return 0;
f011633b:	b8 00 00 00 00       	mov    $0x0,%eax
f0116340:	e9 b6 01 00 00       	jmp    f01164fb <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116345:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116348:	83 ec 04             	sub    $0x4,%esp
f011634b:	8d 55 d8             	lea    -0x28(%ebp),%edx
f011634e:	52                   	push   %edx
f011634f:	50                   	push   %eax
f0116350:	ff 75 08             	pushl  0x8(%ebp)
f0116353:	e8 11 24 ff ff       	call   f0108769 <get_frame_info>
f0116358:	83 c4 10             	add    $0x10,%esp
f011635b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f011635e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116361:	85 c0                	test   %eax,%eax
f0116363:	75 24                	jne    f0116389 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116365:	83 ec 04             	sub    $0x4,%esp
f0116368:	68 9c a5 12 f0       	push   $0xf012a59c
f011636d:	68 a0 08 00 00       	push   $0x8a0
f0116372:	68 22 8a 12 f0       	push   $0xf0128a22
f0116377:	e8 5a a1 fe ff       	call   f01004d6 <_warn>
f011637c:	83 c4 10             	add    $0x10,%esp
			return 0;
f011637f:	b8 00 00 00 00       	mov    $0x0,%eax
f0116384:	e9 72 01 00 00       	jmp    f01164fb <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116389:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f011638d:	75 70                	jne    f01163ff <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f011638f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116392:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116395:	c1 ea 0c             	shr    $0xc,%edx
f0116398:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011639e:	c1 e2 02             	shl    $0x2,%edx
f01163a1:	01 d0                	add    %edx,%eax
f01163a3:	8b 00                	mov    (%eax),%eax
f01163a5:	c1 e8 0c             	shr    $0xc,%eax
f01163a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f01163ab:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01163ae:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01163b1:	c1 ea 0c             	shr    $0xc,%edx
f01163b4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01163ba:	c1 e2 02             	shl    $0x2,%edx
f01163bd:	01 d0                	add    %edx,%eax
f01163bf:	8b 00                	mov    (%eax),%eax
f01163c1:	c1 e8 0c             	shr    $0xc,%eax
f01163c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f01163c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01163ca:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01163cd:	74 30                	je     f01163ff <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f01163cf:	83 ec 04             	sub    $0x4,%esp
f01163d2:	ff 75 e4             	pushl  -0x1c(%ebp)
f01163d5:	ff 75 e8             	pushl  -0x18(%ebp)
f01163d8:	ff 75 f0             	pushl  -0x10(%ebp)
f01163db:	ff 75 f4             	pushl  -0xc(%ebp)
f01163de:	68 c8 a5 12 f0       	push   $0xf012a5c8
f01163e3:	68 aa 08 00 00       	push   $0x8aa
f01163e8:	68 22 8a 12 f0       	push   $0xf0128a22
f01163ed:	e8 e4 a0 fe ff       	call   f01004d6 <_warn>
f01163f2:	83 c4 20             	add    $0x20,%esp
				return 0;
f01163f5:	b8 00 00 00 00       	mov    $0x0,%eax
f01163fa:	e9 fc 00 00 00       	jmp    f01164fb <CCP+0x227>
			}
		}
		if (ref != -1)
f01163ff:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116403:	74 52                	je     f0116457 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116405:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116409:	74 0e                	je     f0116419 <CCP+0x145>
f011640b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011640e:	8b 40 08             	mov    0x8(%eax),%eax
f0116411:	0f b7 c0             	movzwl %ax,%eax
f0116414:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116417:	74 3e                	je     f0116457 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116419:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011641d:	74 0b                	je     f011642a <CCP+0x156>
f011641f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116422:	8b 40 08             	mov    0x8(%eax),%eax
f0116425:	0f b7 c0             	movzwl %ax,%eax
f0116428:	eb 05                	jmp    f011642f <CCP+0x15b>
f011642a:	b8 00 00 00 00       	mov    $0x0,%eax
f011642f:	83 ec 0c             	sub    $0xc,%esp
f0116432:	50                   	push   %eax
f0116433:	ff 75 f0             	pushl  -0x10(%ebp)
f0116436:	68 24 a6 12 f0       	push   $0xf012a624
f011643b:	68 b2 08 00 00       	push   $0x8b2
f0116440:	68 22 8a 12 f0       	push   $0xf0128a22
f0116445:	e8 8c a0 fe ff       	call   f01004d6 <_warn>
f011644a:	83 c4 20             	add    $0x20,%esp
				return 0;
f011644d:	b8 00 00 00 00       	mov    $0x0,%eax
f0116452:	e9 a4 00 00 00       	jmp    f01164fb <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116457:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011645a:	ff 75 20             	pushl  0x20(%ebp)
f011645d:	ff 75 1c             	pushl  0x1c(%ebp)
f0116460:	50                   	push   %eax
f0116461:	ff 75 08             	pushl  0x8(%ebp)
f0116464:	e8 17 fd ff ff       	call   f0116180 <CPs>
f0116469:	83 c4 10             	add    $0x10,%esp
f011646c:	85 c0                	test   %eax,%eax
f011646e:	7f 21                	jg     f0116491 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116470:	83 ec 04             	sub    $0x4,%esp
f0116473:	68 94 a6 12 f0       	push   $0xf012a694
f0116478:	68 b8 08 00 00       	push   $0x8b8
f011647d:	68 22 8a 12 f0       	push   $0xf0128a22
f0116482:	e8 4f a0 fe ff       	call   f01004d6 <_warn>
f0116487:	83 c4 10             	add    $0x10,%esp
			return 0;
f011648a:	b8 00 00 00 00       	mov    $0x0,%eax
f011648f:	eb 6a                	jmp    f01164fb <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116491:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116495:	74 3a                	je     f01164d1 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116497:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011649a:	ff 75 28             	pushl  0x28(%ebp)
f011649d:	ff 75 24             	pushl  0x24(%ebp)
f01164a0:	50                   	push   %eax
f01164a1:	ff 75 08             	pushl  0x8(%ebp)
f01164a4:	e8 d7 fc ff ff       	call   f0116180 <CPs>
f01164a9:	83 c4 10             	add    $0x10,%esp
f01164ac:	85 c0                	test   %eax,%eax
f01164ae:	7f 21                	jg     f01164d1 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f01164b0:	83 ec 04             	sub    $0x4,%esp
f01164b3:	68 dc a6 12 f0       	push   $0xf012a6dc
f01164b8:	68 bf 08 00 00       	push   $0x8bf
f01164bd:	68 22 8a 12 f0       	push   $0xf0128a22
f01164c2:	e8 0f a0 fe ff       	call   f01004d6 <_warn>
f01164c7:	83 c4 10             	add    $0x10,%esp
				return 0;
f01164ca:	b8 00 00 00 00       	mov    $0x0,%eax
f01164cf:	eb 2a                	jmp    f01164fb <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f01164d1:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01164d5:	74 07                	je     f01164de <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f01164d7:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f01164de:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f01164e5:	8b 55 10             	mov    0x10(%ebp),%edx
f01164e8:	8b 45 14             	mov    0x14(%ebp),%eax
f01164eb:	01 d0                	add    %edx,%eax
f01164ed:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01164f0:	0f 87 05 fe ff ff    	ja     f01162fb <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f01164f6:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01164fb:	c9                   	leave  
f01164fc:	c3                   	ret    

f01164fd <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f01164fd:	55                   	push   %ebp
f01164fe:	89 e5                	mov    %esp,%ebp
f0116500:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116503:	83 ec 04             	sub    $0x4,%esp
f0116506:	68 1c a7 12 f0       	push   $0xf012a71c
f011650b:	6a 0e                	push   $0xe
f011650d:	68 2c a7 12 f0       	push   $0xf012a72c
f0116512:	e8 22 9e fe ff       	call   f0100339 <_panic>

f0116517 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0116517:	55                   	push   %ebp
f0116518:	89 e5                	mov    %esp,%ebp
f011651a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f011651d:	83 ec 04             	sub    $0x4,%esp
f0116520:	68 1c a7 12 f0       	push   $0xf012a71c
f0116525:	68 d7 00 00 00       	push   $0xd7
f011652a:	68 2c a7 12 f0       	push   $0xf012a72c
f011652f:	e8 05 9e fe ff       	call   f0100339 <_panic>

f0116534 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0116534:	55                   	push   %ebp
f0116535:	89 e5                	mov    %esp,%ebp
f0116537:	57                   	push   %edi
f0116538:	53                   	push   %ebx
f0116539:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011653f:	83 ec 0c             	sub    $0xc,%esp
f0116542:	68 48 a7 12 f0       	push   $0xf012a748
f0116547:	e8 3f aa fe ff       	call   f0100f8b <cprintf>
f011654c:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011654f:	83 ec 0c             	sub    $0xc,%esp
f0116552:	68 78 a7 12 f0       	push   $0xf012a778
f0116557:	e8 2f aa fe ff       	call   f0100f8b <cprintf>
f011655c:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011655f:	83 ec 0c             	sub    $0xc,%esp
f0116562:	68 48 a7 12 f0       	push   $0xf012a748
f0116567:	e8 1f aa fe ff       	call   f0100f8b <cprintf>
f011656c:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011656f:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0116573:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0116577:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f011657d:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0116583:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f011658a:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f0116591:	e8 16 7c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116596:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0116599:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01165a0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f01165a7:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f01165ad:	b9 14 00 00 00       	mov    $0x14,%ecx
f01165b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01165b7:	89 d7                	mov    %edx,%edi
f01165b9:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f01165bb:	83 ec 0c             	sub    $0xc,%esp
f01165be:	68 d1 a7 12 f0       	push   $0xf012a7d1
f01165c3:	e8 c3 a9 fe ff       	call   f0100f8b <cprintf>
f01165c8:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01165cb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f01165d2:	e8 d5 7b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01165d7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01165da:	e8 c6 e2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01165df:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f01165e2:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f01165e9:	83 ec 0c             	sub    $0xc,%esp
f01165ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01165ef:	e8 f7 2a ff ff       	call   f01090eb <kmalloc>
f01165f4:	83 c4 10             	add    $0x10,%esp
f01165f7:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f01165fd:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116603:	85 c0                	test   %eax,%eax
f0116605:	74 17                	je     f011661e <test_kmalloc+0xea>
f0116607:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011660e:	83 ec 0c             	sub    $0xc,%esp
f0116611:	68 f0 a7 12 f0       	push   $0xf012a7f0
f0116616:	e8 70 a9 fe ff       	call   f0100f8b <cprintf>
f011661b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011661e:	e8 82 e2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116623:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116626:	74 17                	je     f011663f <test_kmalloc+0x10b>
f0116628:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011662f:	83 ec 0c             	sub    $0xc,%esp
f0116632:	68 24 a8 12 f0       	push   $0xf012a824
f0116637:	e8 4f a9 fe ff       	call   f0100f8b <cprintf>
f011663c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011663f:	e8 68 7b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116644:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116647:	74 17                	je     f0116660 <test_kmalloc+0x12c>
f0116649:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116650:	83 ec 0c             	sub    $0xc,%esp
f0116653:	68 90 a8 12 f0       	push   $0xf012a890
f0116658:	e8 2e a9 fe ff       	call   f0100f8b <cprintf>
f011665d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116660:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116664:	74 04                	je     f011666a <test_kmalloc+0x136>
f0116666:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f011666a:	83 ec 0c             	sub    $0xc,%esp
f011666d:	68 d4 a8 12 f0       	push   $0xf012a8d4
f0116672:	e8 14 a9 fe ff       	call   f0100f8b <cprintf>
f0116677:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011667a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116681:	e8 26 7b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116686:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116689:	e8 17 e2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011668e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0116691:	83 ec 0c             	sub    $0xc,%esp
f0116694:	68 00 fc 1f 00       	push   $0x1ffc00
f0116699:	e8 4d 2a ff ff       	call   f01090eb <kmalloc>
f011669e:	83 c4 10             	add    $0x10,%esp
f01166a1:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01166a7:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01166ad:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01166b2:	74 17                	je     f01166cb <test_kmalloc+0x197>
f01166b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01166bb:	83 ec 0c             	sub    $0xc,%esp
f01166be:	68 18 a9 12 f0       	push   $0xf012a918
f01166c3:	e8 c3 a8 fe ff       	call   f0100f8b <cprintf>
f01166c8:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01166cb:	e8 d5 e1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01166d0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01166d3:	74 17                	je     f01166ec <test_kmalloc+0x1b8>
f01166d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01166dc:	83 ec 0c             	sub    $0xc,%esp
f01166df:	68 6c a9 12 f0       	push   $0xf012a96c
f01166e4:	e8 a2 a8 fe ff       	call   f0100f8b <cprintf>
f01166e9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01166ec:	e8 bb 7a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01166f1:	89 c2                	mov    %eax,%edx
f01166f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01166f6:	29 d0                	sub    %edx,%eax
f01166f8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01166fd:	7f 17                	jg     f0116716 <test_kmalloc+0x1e2>
f01166ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116706:	83 ec 0c             	sub    $0xc,%esp
f0116709:	68 d8 a9 12 f0       	push   $0xf012a9d8
f011670e:	e8 78 a8 fe ff       	call   f0100f8b <cprintf>
f0116713:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116716:	e8 91 7a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011671b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011671e:	e8 82 e1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116723:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0116726:	83 ec 0c             	sub    $0xc,%esp
f0116729:	68 00 fc 1f 00       	push   $0x1ffc00
f011672e:	e8 b8 29 ff ff       	call   f01090eb <kmalloc>
f0116733:	83 c4 10             	add    $0x10,%esp
f0116736:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011673c:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116742:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0116747:	74 17                	je     f0116760 <test_kmalloc+0x22c>
f0116749:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116750:	83 ec 0c             	sub    $0xc,%esp
f0116753:	68 1c aa 12 f0       	push   $0xf012aa1c
f0116758:	e8 2e a8 fe ff       	call   f0100f8b <cprintf>
f011675d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116760:	e8 40 e1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116765:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116768:	74 17                	je     f0116781 <test_kmalloc+0x24d>
f011676a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116771:	83 ec 0c             	sub    $0xc,%esp
f0116774:	68 70 aa 12 f0       	push   $0xf012aa70
f0116779:	e8 0d a8 fe ff       	call   f0100f8b <cprintf>
f011677e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116781:	e8 26 7a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116786:	89 c2                	mov    %eax,%edx
f0116788:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011678b:	29 d0                	sub    %edx,%eax
f011678d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116792:	7f 17                	jg     f01167ab <test_kmalloc+0x277>
f0116794:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011679b:	83 ec 0c             	sub    $0xc,%esp
f011679e:	68 dc aa 12 f0       	push   $0xf012aadc
f01167a3:	e8 e3 a7 fe ff       	call   f0100f8b <cprintf>
f01167a8:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f01167ab:	e8 fc 79 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01167b0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01167b3:	e8 ed e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01167b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f01167bb:	83 ec 0c             	sub    $0xc,%esp
f01167be:	68 ff 07 00 00       	push   $0x7ff
f01167c3:	e8 23 29 ff ff       	call   f01090eb <kmalloc>
f01167c8:	83 c4 10             	add    $0x10,%esp
f01167cb:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01167d1:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01167d7:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01167dc:	76 28                	jbe    f0116806 <test_kmalloc+0x2d2>
f01167de:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f01167e4:	83 ec 0c             	sub    $0xc,%esp
f01167e7:	6a 00                	push   $0x0
f01167e9:	e8 ca 27 ff ff       	call   f0108fb8 <sbrk>
f01167ee:	83 c4 10             	add    $0x10,%esp
f01167f1:	39 c3                	cmp    %eax,%ebx
f01167f3:	73 11                	jae    f0116806 <test_kmalloc+0x2d2>
f01167f5:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01167fb:	89 c2                	mov    %eax,%edx
f01167fd:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f0116802:	39 c2                	cmp    %eax,%edx
f0116804:	72 17                	jb     f011681d <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0116806:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011680d:	83 ec 0c             	sub    $0xc,%esp
f0116810:	68 20 ab 12 f0       	push   $0xf012ab20
f0116815:	e8 71 a7 fe ff       	call   f0100f8b <cprintf>
f011681a:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011681d:	e8 83 e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116822:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116825:	74 17                	je     f011683e <test_kmalloc+0x30a>
f0116827:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011682e:	83 ec 0c             	sub    $0xc,%esp
f0116831:	68 ac ab 12 f0       	push   $0xf012abac
f0116836:	e8 50 a7 fe ff       	call   f0100f8b <cprintf>
f011683b:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011683e:	e8 62 e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116843:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0116846:	83 ec 0c             	sub    $0xc,%esp
f0116849:	68 ff 07 00 00       	push   $0x7ff
f011684e:	e8 98 28 ff ff       	call   f01090eb <kmalloc>
f0116853:	83 c4 10             	add    $0x10,%esp
f0116856:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011685c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116862:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116867:	76 28                	jbe    f0116891 <test_kmalloc+0x35d>
f0116869:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f011686f:	83 ec 0c             	sub    $0xc,%esp
f0116872:	6a 00                	push   $0x0
f0116874:	e8 3f 27 ff ff       	call   f0108fb8 <sbrk>
f0116879:	83 c4 10             	add    $0x10,%esp
f011687c:	39 c3                	cmp    %eax,%ebx
f011687e:	73 11                	jae    f0116891 <test_kmalloc+0x35d>
f0116880:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116886:	89 c2                	mov    %eax,%edx
f0116888:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011688d:	39 c2                	cmp    %eax,%edx
f011688f:	72 17                	jb     f01168a8 <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0116891:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116898:	83 ec 0c             	sub    $0xc,%esp
f011689b:	68 18 ac 12 f0       	push   $0xf012ac18
f01168a0:	e8 e6 a6 fe ff       	call   f0100f8b <cprintf>
f01168a5:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01168a8:	e8 f8 df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01168ad:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01168b0:	74 17                	je     f01168c9 <test_kmalloc+0x395>
f01168b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01168b9:	83 ec 0c             	sub    $0xc,%esp
f01168bc:	68 a4 ac 12 f0       	push   $0xf012aca4
f01168c1:	e8 c5 a6 fe ff       	call   f0100f8b <cprintf>
f01168c6:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f01168c9:	e8 de 78 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01168ce:	89 c2                	mov    %eax,%edx
f01168d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01168d3:	29 d0                	sub    %edx,%eax
f01168d5:	83 f8 01             	cmp    $0x1,%eax
f01168d8:	74 17                	je     f01168f1 <test_kmalloc+0x3bd>
f01168da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01168e1:	83 ec 0c             	sub    $0xc,%esp
f01168e4:	68 10 ad 12 f0       	push   $0xf012ad10
f01168e9:	e8 9d a6 fe ff       	call   f0100f8b <cprintf>
f01168ee:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01168f1:	e8 b6 78 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01168f6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01168f9:	e8 a7 df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01168fe:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0116901:	83 ec 0c             	sub    $0xc,%esp
f0116904:	68 00 1c 00 00       	push   $0x1c00
f0116909:	e8 dd 27 ff ff       	call   f01090eb <kmalloc>
f011690e:	83 c4 10             	add    $0x10,%esp
f0116911:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116917:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011691d:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0116922:	74 17                	je     f011693b <test_kmalloc+0x407>
f0116924:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011692b:	83 ec 0c             	sub    $0xc,%esp
f011692e:	68 30 ad 12 f0       	push   $0xf012ad30
f0116933:	e8 53 a6 fe ff       	call   f0100f8b <cprintf>
f0116938:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011693b:	e8 65 df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116940:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116943:	74 17                	je     f011695c <test_kmalloc+0x428>
f0116945:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011694c:	83 ec 0c             	sub    $0xc,%esp
f011694f:	68 84 ad 12 f0       	push   $0xf012ad84
f0116954:	e8 32 a6 fe ff       	call   f0100f8b <cprintf>
f0116959:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011695c:	e8 4b 78 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116961:	89 c2                	mov    %eax,%edx
f0116963:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116966:	29 d0                	sub    %edx,%eax
f0116968:	83 f8 01             	cmp    $0x1,%eax
f011696b:	7f 17                	jg     f0116984 <test_kmalloc+0x450>
f011696d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116974:	83 ec 0c             	sub    $0xc,%esp
f0116977:	68 f0 ad 12 f0       	push   $0xf012adf0
f011697c:	e8 0a a6 fe ff       	call   f0100f8b <cprintf>
f0116981:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116984:	e8 23 78 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116989:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011698c:	e8 14 df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116991:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0116994:	83 ec 0c             	sub    $0xc,%esp
f0116997:	68 00 fc 2f 00       	push   $0x2ffc00
f011699c:	e8 4a 27 ff ff       	call   f01090eb <kmalloc>
f01169a1:	83 c4 10             	add    $0x10,%esp
f01169a4:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01169aa:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f01169b0:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01169b5:	74 17                	je     f01169ce <test_kmalloc+0x49a>
f01169b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169be:	83 ec 0c             	sub    $0xc,%esp
f01169c1:	68 34 ae 12 f0       	push   $0xf012ae34
f01169c6:	e8 c0 a5 fe ff       	call   f0100f8b <cprintf>
f01169cb:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01169ce:	e8 d2 de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01169d3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01169d6:	74 17                	je     f01169ef <test_kmalloc+0x4bb>
f01169d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169df:	83 ec 0c             	sub    $0xc,%esp
f01169e2:	68 88 ae 12 f0       	push   $0xf012ae88
f01169e7:	e8 9f a5 fe ff       	call   f0100f8b <cprintf>
f01169ec:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01169ef:	e8 b8 77 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01169f4:	89 c2                	mov    %eax,%edx
f01169f6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01169f9:	29 d0                	sub    %edx,%eax
f01169fb:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116a00:	7f 17                	jg     f0116a19 <test_kmalloc+0x4e5>
f0116a02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a09:	83 ec 0c             	sub    $0xc,%esp
f0116a0c:	68 f4 ae 12 f0       	push   $0xf012aef4
f0116a11:	e8 75 a5 fe ff       	call   f0100f8b <cprintf>
f0116a16:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116a19:	e8 8e 77 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116a1e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116a21:	e8 7f de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116a26:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0116a29:	83 ec 0c             	sub    $0xc,%esp
f0116a2c:	68 00 fc 5f 00       	push   $0x5ffc00
f0116a31:	e8 b5 26 ff ff       	call   f01090eb <kmalloc>
f0116a36:	83 c4 10             	add    $0x10,%esp
f0116a39:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116a3f:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0116a45:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0116a4a:	74 17                	je     f0116a63 <test_kmalloc+0x52f>
f0116a4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a53:	83 ec 0c             	sub    $0xc,%esp
f0116a56:	68 38 af 12 f0       	push   $0xf012af38
f0116a5b:	e8 2b a5 fe ff       	call   f0100f8b <cprintf>
f0116a60:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116a63:	e8 3d de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116a68:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116a6b:	74 17                	je     f0116a84 <test_kmalloc+0x550>
f0116a6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a74:	83 ec 0c             	sub    $0xc,%esp
f0116a77:	68 8c af 12 f0       	push   $0xf012af8c
f0116a7c:	e8 0a a5 fe ff       	call   f0100f8b <cprintf>
f0116a81:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116a84:	e8 23 77 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116a89:	89 c2                	mov    %eax,%edx
f0116a8b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116a8e:	29 d0                	sub    %edx,%eax
f0116a90:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0116a95:	7f 17                	jg     f0116aae <test_kmalloc+0x57a>
f0116a97:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a9e:	83 ec 0c             	sub    $0xc,%esp
f0116aa1:	68 f8 af 12 f0       	push   $0xf012aff8
f0116aa6:	e8 e0 a4 fe ff       	call   f0100f8b <cprintf>
f0116aab:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116aae:	e8 f9 76 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116ab3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ab6:	e8 ea dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116abb:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0116abe:	83 ec 0c             	sub    $0xc,%esp
f0116ac1:	68 00 38 00 00       	push   $0x3800
f0116ac6:	e8 20 26 ff ff       	call   f01090eb <kmalloc>
f0116acb:	83 c4 10             	add    $0x10,%esp
f0116ace:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116ad4:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0116ada:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0116adf:	74 17                	je     f0116af8 <test_kmalloc+0x5c4>
f0116ae1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ae8:	83 ec 0c             	sub    $0xc,%esp
f0116aeb:	68 3c b0 12 f0       	push   $0xf012b03c
f0116af0:	e8 96 a4 fe ff       	call   f0100f8b <cprintf>
f0116af5:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116af8:	e8 a8 dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116afd:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116b00:	74 17                	je     f0116b19 <test_kmalloc+0x5e5>
f0116b02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b09:	83 ec 0c             	sub    $0xc,%esp
f0116b0c:	68 90 b0 12 f0       	push   $0xf012b090
f0116b11:	e8 75 a4 fe ff       	call   f0100f8b <cprintf>
f0116b16:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116b19:	e8 8e 76 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116b1e:	89 c2                	mov    %eax,%edx
f0116b20:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116b23:	29 d0                	sub    %edx,%eax
f0116b25:	83 f8 03             	cmp    $0x3,%eax
f0116b28:	7f 17                	jg     f0116b41 <test_kmalloc+0x60d>
f0116b2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b31:	83 ec 0c             	sub    $0xc,%esp
f0116b34:	68 fc b0 12 f0       	push   $0xf012b0fc
f0116b39:	e8 4d a4 fe ff       	call   f0100f8b <cprintf>
f0116b3e:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0116b41:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116b45:	74 04                	je     f0116b4b <test_kmalloc+0x617>
f0116b47:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0116b4b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f0116b52:	83 ec 0c             	sub    $0xc,%esp
f0116b55:	68 40 b1 12 f0       	push   $0xf012b140
f0116b5a:	e8 2c a4 fe ff       	call   f0100f8b <cprintf>
f0116b5f:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0116b62:	e8 45 76 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116b67:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116b6a:	e8 36 dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116b6f:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f0116b72:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0116b79:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116b7f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f0116b82:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116b85:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116b88:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0116b8a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116b8d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116b90:	01 c2                	add    %eax,%edx
f0116b92:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116b95:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0116b97:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116b9d:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0116ba0:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f0116ba7:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116baa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116bad:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0116bb0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116bb3:	01 c0                	add    %eax,%eax
f0116bb5:	89 c2                	mov    %eax,%edx
f0116bb7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116bba:	01 c2                	add    %eax,%edx
f0116bbc:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116bc0:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f0116bc3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116bc9:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0116bcc:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f0116bd3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116bd6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116bd9:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0116bdb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116bde:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116be5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116be8:	01 c2                	add    %eax,%edx
f0116bea:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116bed:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0116bef:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116bf5:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f0116bf8:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0116bff:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116c02:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116c05:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f0116c07:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0116c0a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116c0d:	01 c2                	add    %eax,%edx
f0116c0f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116c12:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f0116c14:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0116c1a:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f0116c1d:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f0116c24:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116c27:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116c2a:	88 10                	mov    %dl,(%eax)
f0116c2c:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0116c2f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116c32:	66 89 42 02          	mov    %ax,0x2(%edx)
f0116c36:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116c39:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116c3c:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f0116c3f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116c42:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116c49:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116c4c:	01 c2                	add    %eax,%edx
f0116c4e:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116c51:	88 02                	mov    %al,(%edx)
f0116c53:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116c56:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116c5d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116c60:	01 c2                	add    %eax,%edx
f0116c62:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116c66:	66 89 42 02          	mov    %ax,0x2(%edx)
f0116c6a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116c6d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116c74:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116c77:	01 c2                	add    %eax,%edx
f0116c79:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116c7c:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0116c7f:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f0116c86:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0116c8c:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0116c8f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116c92:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116c95:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0116c97:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0116c9a:	89 c2                	mov    %eax,%edx
f0116c9c:	c1 ea 1f             	shr    $0x1f,%edx
f0116c9f:	01 d0                	add    %edx,%eax
f0116ca1:	d1 f8                	sar    %eax
f0116ca3:	89 c2                	mov    %eax,%edx
f0116ca5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116ca8:	01 c2                	add    %eax,%edx
f0116caa:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116cad:	88 c1                	mov    %al,%cl
f0116caf:	c0 e9 07             	shr    $0x7,%cl
f0116cb2:	01 c8                	add    %ecx,%eax
f0116cb4:	d0 f8                	sar    %al
f0116cb6:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f0116cb8:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116cbb:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116cbe:	01 c2                	add    %eax,%edx
f0116cc0:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116cc3:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f0116cc5:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0116ccb:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0116cce:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f0116cd5:	8b 55 98             	mov    -0x68(%ebp),%edx
f0116cd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116cdb:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0116cde:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116ce1:	01 c0                	add    %eax,%eax
f0116ce3:	89 c2                	mov    %eax,%edx
f0116ce5:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116ce8:	01 c2                	add    %eax,%edx
f0116cea:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116cee:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f0116cf1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116cf4:	8a 00                	mov    (%eax),%al
f0116cf6:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116cf9:	75 0f                	jne    f0116d0a <test_kmalloc+0x7d6>
f0116cfb:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116cfe:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116d01:	01 d0                	add    %edx,%eax
f0116d03:	8a 00                	mov    (%eax),%al
f0116d05:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116d08:	74 17                	je     f0116d21 <test_kmalloc+0x7ed>
f0116d0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d11:	83 ec 0c             	sub    $0xc,%esp
f0116d14:	68 78 b1 12 f0       	push   $0xf012b178
f0116d19:	e8 6d a2 fe ff       	call   f0100f8b <cprintf>
f0116d1e:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0116d21:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116d24:	66 8b 00             	mov    (%eax),%ax
f0116d27:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116d2b:	75 15                	jne    f0116d42 <test_kmalloc+0x80e>
f0116d2d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116d30:	01 c0                	add    %eax,%eax
f0116d32:	89 c2                	mov    %eax,%edx
f0116d34:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116d37:	01 d0                	add    %edx,%eax
f0116d39:	66 8b 00             	mov    (%eax),%ax
f0116d3c:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116d40:	74 17                	je     f0116d59 <test_kmalloc+0x825>
f0116d42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d49:	83 ec 0c             	sub    $0xc,%esp
f0116d4c:	68 b0 b1 12 f0       	push   $0xf012b1b0
f0116d51:	e8 35 a2 fe ff       	call   f0100f8b <cprintf>
f0116d56:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f0116d59:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116d5c:	8b 00                	mov    (%eax),%eax
f0116d5e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0116d61:	75 16                	jne    f0116d79 <test_kmalloc+0x845>
f0116d63:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116d66:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d6d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116d70:	01 d0                	add    %edx,%eax
f0116d72:	8b 00                	mov    (%eax),%eax
f0116d74:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0116d77:	74 17                	je     f0116d90 <test_kmalloc+0x85c>
f0116d79:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d80:	83 ec 0c             	sub    $0xc,%esp
f0116d83:	68 ec b1 12 f0       	push   $0xf012b1ec
f0116d88:	e8 fe a1 fe ff       	call   f0100f8b <cprintf>
f0116d8d:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f0116d90:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116d93:	8a 00                	mov    (%eax),%al
f0116d95:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116d98:	75 0f                	jne    f0116da9 <test_kmalloc+0x875>
f0116d9a:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0116d9d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116da0:	01 d0                	add    %edx,%eax
f0116da2:	8a 00                	mov    (%eax),%al
f0116da4:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116da7:	74 17                	je     f0116dc0 <test_kmalloc+0x88c>
f0116da9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116db0:	83 ec 0c             	sub    $0xc,%esp
f0116db3:	68 28 b2 12 f0       	push   $0xf012b228
f0116db8:	e8 ce a1 fe ff       	call   f0100f8b <cprintf>
f0116dbd:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f0116dc0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116dc3:	8a 00                	mov    (%eax),%al
f0116dc5:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116dc8:	75 16                	jne    f0116de0 <test_kmalloc+0x8ac>
f0116dca:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116dcd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116dd4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116dd7:	01 d0                	add    %edx,%eax
f0116dd9:	8a 00                	mov    (%eax),%al
f0116ddb:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116dde:	74 17                	je     f0116df7 <test_kmalloc+0x8c3>
f0116de0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116de7:	83 ec 0c             	sub    $0xc,%esp
f0116dea:	68 64 b2 12 f0       	push   $0xf012b264
f0116def:	e8 97 a1 fe ff       	call   f0100f8b <cprintf>
f0116df4:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f0116df7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116dfa:	66 8b 40 02          	mov    0x2(%eax),%ax
f0116dfe:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116e02:	75 19                	jne    f0116e1d <test_kmalloc+0x8e9>
f0116e04:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116e07:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116e0e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116e11:	01 d0                	add    %edx,%eax
f0116e13:	66 8b 40 02          	mov    0x2(%eax),%ax
f0116e17:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116e1b:	74 17                	je     f0116e34 <test_kmalloc+0x900>
f0116e1d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e24:	83 ec 0c             	sub    $0xc,%esp
f0116e27:	68 a0 b2 12 f0       	push   $0xf012b2a0
f0116e2c:	e8 5a a1 fe ff       	call   f0100f8b <cprintf>
f0116e31:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f0116e34:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116e37:	8b 40 04             	mov    0x4(%eax),%eax
f0116e3a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0116e3d:	75 17                	jne    f0116e56 <test_kmalloc+0x922>
f0116e3f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116e42:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116e49:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116e4c:	01 d0                	add    %edx,%eax
f0116e4e:	8b 40 04             	mov    0x4(%eax),%eax
f0116e51:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0116e54:	74 17                	je     f0116e6d <test_kmalloc+0x939>
f0116e56:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e5d:	83 ec 0c             	sub    $0xc,%esp
f0116e60:	68 dc b2 12 f0       	push   $0xf012b2dc
f0116e65:	e8 21 a1 fe ff       	call   f0100f8b <cprintf>
f0116e6a:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0116e6d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116e70:	8a 00                	mov    (%eax),%al
f0116e72:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116e75:	75 34                	jne    f0116eab <test_kmalloc+0x977>
f0116e77:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0116e7a:	89 c2                	mov    %eax,%edx
f0116e7c:	c1 ea 1f             	shr    $0x1f,%edx
f0116e7f:	01 d0                	add    %edx,%eax
f0116e81:	d1 f8                	sar    %eax
f0116e83:	89 c2                	mov    %eax,%edx
f0116e85:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116e88:	01 d0                	add    %edx,%eax
f0116e8a:	8a 10                	mov    (%eax),%dl
f0116e8c:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116e8f:	88 c1                	mov    %al,%cl
f0116e91:	c0 e9 07             	shr    $0x7,%cl
f0116e94:	01 c8                	add    %ecx,%eax
f0116e96:	d0 f8                	sar    %al
f0116e98:	38 c2                	cmp    %al,%dl
f0116e9a:	75 0f                	jne    f0116eab <test_kmalloc+0x977>
f0116e9c:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116e9f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116ea2:	01 d0                	add    %edx,%eax
f0116ea4:	8a 00                	mov    (%eax),%al
f0116ea6:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116ea9:	74 17                	je     f0116ec2 <test_kmalloc+0x98e>
f0116eab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116eb2:	83 ec 0c             	sub    $0xc,%esp
f0116eb5:	68 18 b3 12 f0       	push   $0xf012b318
f0116eba:	e8 cc a0 fe ff       	call   f0100f8b <cprintf>
f0116ebf:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f0116ec2:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116ec5:	66 8b 00             	mov    (%eax),%ax
f0116ec8:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116ecc:	75 15                	jne    f0116ee3 <test_kmalloc+0x9af>
f0116ece:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116ed1:	01 c0                	add    %eax,%eax
f0116ed3:	89 c2                	mov    %eax,%edx
f0116ed5:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116ed8:	01 d0                	add    %edx,%eax
f0116eda:	66 8b 00             	mov    (%eax),%ax
f0116edd:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116ee1:	74 17                	je     f0116efa <test_kmalloc+0x9c6>
f0116ee3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116eea:	83 ec 0c             	sub    $0xc,%esp
f0116eed:	68 50 b3 12 f0       	push   $0xf012b350
f0116ef2:	e8 94 a0 fe ff       	call   f0100f8b <cprintf>
f0116ef7:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116efa:	e8 ad 72 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116eff:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116f02:	74 17                	je     f0116f1b <test_kmalloc+0x9e7>
f0116f04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f0b:	83 ec 0c             	sub    $0xc,%esp
f0116f0e:	68 8c b3 12 f0       	push   $0xf012b38c
f0116f13:	e8 73 a0 fe ff       	call   f0100f8b <cprintf>
f0116f18:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116f1b:	e8 85 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f20:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116f23:	74 17                	je     f0116f3c <test_kmalloc+0xa08>
f0116f25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f2c:	83 ec 0c             	sub    $0xc,%esp
f0116f2f:	68 d0 b3 12 f0       	push   $0xf012b3d0
f0116f34:	e8 52 a0 fe ff       	call   f0100f8b <cprintf>
f0116f39:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f0116f3c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116f40:	74 04                	je     f0116f46 <test_kmalloc+0xa12>
f0116f42:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0116f46:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f0116f4d:	83 ec 0c             	sub    $0xc,%esp
f0116f50:	68 3c b4 12 f0       	push   $0xf012b43c
f0116f55:	e8 31 a0 fe ff       	call   f0100f8b <cprintf>
f0116f5a:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0116f5d:	e8 4a 72 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116f62:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116f65:	e8 3b d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f6a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f0116f6d:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		cprintf("restOfKheap : %x\n",restOfKHeap);
f0116f74:	83 ec 08             	sub    $0x8,%esp
f0116f77:	ff 75 90             	pushl  -0x70(%ebp)
f0116f7a:	68 60 b4 12 f0       	push   $0xf012b460
f0116f7f:	e8 07 a0 fe ff       	call   f0100f8b <cprintf>
f0116f84:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f0116f87:	8b 45 90             	mov    -0x70(%ebp),%eax
f0116f8a:	40                   	inc    %eax
f0116f8b:	83 ec 0c             	sub    $0xc,%esp
f0116f8e:	50                   	push   %eax
f0116f8f:	e8 57 21 ff ff       	call   f01090eb <kmalloc>
f0116f94:	83 c4 10             	add    $0x10,%esp
f0116f97:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f0116f9d:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0116fa3:	85 c0                	test   %eax,%eax
f0116fa5:	74 17                	je     f0116fbe <test_kmalloc+0xa8a>
f0116fa7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fae:	83 ec 0c             	sub    $0xc,%esp
f0116fb1:	68 74 b4 12 f0       	push   $0xf012b474
f0116fb6:	e8 d0 9f fe ff       	call   f0100f8b <cprintf>
f0116fbb:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116fbe:	e8 e2 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116fc3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116fc6:	74 17                	je     f0116fdf <test_kmalloc+0xaab>
f0116fc8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fcf:	83 ec 0c             	sub    $0xc,%esp
f0116fd2:	68 ac b4 12 f0       	push   $0xf012b4ac
f0116fd7:	e8 af 9f fe ff       	call   f0100f8b <cprintf>
f0116fdc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116fdf:	e8 c8 71 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0116fe4:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116fe7:	74 17                	je     f0117000 <test_kmalloc+0xacc>
f0116fe9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ff0:	83 ec 0c             	sub    $0xc,%esp
f0116ff3:	68 18 b5 12 f0       	push   $0xf012b518
f0116ff8:	e8 8e 9f fe ff       	call   f0100f8b <cprintf>
f0116ffd:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117000:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117004:	74 04                	je     f011700a <test_kmalloc+0xad6>
f0117006:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011700a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f0117011:	83 ec 0c             	sub    $0xc,%esp
f0117014:	68 5c b5 12 f0       	push   $0xf012b55c
f0117019:	e8 6d 9f fe ff       	call   f0100f8b <cprintf>
f011701e:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f0117021:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117027:	05 00 40 00 00       	add    $0x4000,%eax
f011702c:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011702f:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0117036:	eb 6a                	jmp    f01170a2 <test_kmalloc+0xb6e>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0117038:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011703d:	83 ec 04             	sub    $0x4,%esp
f0117040:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0117046:	52                   	push   %edx
f0117047:	ff 75 ec             	pushl  -0x14(%ebp)
f011704a:	50                   	push   %eax
f011704b:	e8 9f 13 ff ff       	call   f01083ef <get_page_table>
f0117050:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0117053:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0117059:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011705c:	c1 ea 0c             	shr    $0xc,%edx
f011705f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117065:	c1 e2 02             	shl    $0x2,%edx
f0117068:	01 d0                	add    %edx,%eax
f011706a:	8b 00                	mov    (%eax),%eax
f011706c:	25 ff 0f 00 00       	and    $0xfff,%eax
f0117071:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f0117074:	8b 45 88             	mov    -0x78(%ebp),%eax
f0117077:	83 e0 04             	and    $0x4,%eax
f011707a:	85 c0                	test   %eax,%eax
f011707c:	74 1d                	je     f011709b <test_kmalloc+0xb67>
			{
				if (correct)
f011707e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117082:	74 17                	je     f011709b <test_kmalloc+0xb67>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f0117084:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011708b:	83 ec 0c             	sub    $0xc,%esp
f011708e:	68 a0 b5 12 f0       	push   $0xf012b5a0
f0117093:	e8 f3 9e fe ff       	call   f0100f8b <cprintf>
f0117098:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011709b:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f01170a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01170a5:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f01170a8:	72 8e                	jb     f0117038 <test_kmalloc+0xb04>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f01170aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01170ae:	74 04                	je     f01170b4 <test_kmalloc+0xb80>
f01170b0:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f01170b4:	83 ec 08             	sub    $0x8,%esp
f01170b7:	ff 75 f4             	pushl  -0xc(%ebp)
f01170ba:	68 f0 b5 12 f0       	push   $0xf012b5f0
f01170bf:	e8 c7 9e fe ff       	call   f0100f8b <cprintf>
f01170c4:	83 c4 10             	add    $0x10,%esp

	return 1;
f01170c7:	b8 01 00 00 00       	mov    $0x1,%eax

}
f01170cc:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01170cf:	5b                   	pop    %ebx
f01170d0:	5f                   	pop    %edi
f01170d1:	5d                   	pop    %ebp
f01170d2:	c3                   	ret    

f01170d3 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f01170d3:	55                   	push   %ebp
f01170d4:	89 e5                	mov    %esp,%ebp
f01170d6:	57                   	push   %edi
f01170d7:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01170da:	83 ec 0c             	sub    $0xc,%esp
f01170dd:	68 48 a7 12 f0       	push   $0xf012a748
f01170e2:	e8 a4 9e fe ff       	call   f0100f8b <cprintf>
f01170e7:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01170ea:	83 ec 0c             	sub    $0xc,%esp
f01170ed:	68 78 a7 12 f0       	push   $0xf012a778
f01170f2:	e8 94 9e fe ff       	call   f0100f8b <cprintf>
f01170f7:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01170fa:	83 ec 0c             	sub    $0xc,%esp
f01170fd:	68 48 a7 12 f0       	push   $0xf012a748
f0117102:	e8 84 9e fe ff       	call   f0100f8b <cprintf>
f0117107:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f011710a:	8d 55 98             	lea    -0x68(%ebp),%edx
f011710d:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117112:	b8 00 00 00 00       	mov    $0x0,%eax
f0117117:	89 d7                	mov    %edx,%edi
f0117119:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f011711b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0117122:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117129:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f0117130:	83 ec 0c             	sub    $0xc,%esp
f0117133:	68 1c b6 12 f0       	push   $0xf012b61c
f0117138:	e8 4e 9e fe ff       	call   f0100f8b <cprintf>
f011713d:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117140:	e8 67 70 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117145:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117148:	e8 58 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011714d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f0117150:	83 ec 0c             	sub    $0xc,%esp
f0117153:	68 00 fc 0f 00       	push   $0xffc00
f0117158:	e8 8e 1f ff ff       	call   f01090eb <kmalloc>
f011715d:	83 c4 10             	add    $0x10,%esp
f0117160:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f0117163:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117166:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011716b:	74 17                	je     f0117184 <test_kmalloc_firstfit1+0xb1>
f011716d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117174:	83 ec 0c             	sub    $0xc,%esp
f0117177:	68 5c b6 12 f0       	push   $0xf012b65c
f011717c:	e8 0a 9e fe ff       	call   f0100f8b <cprintf>
f0117181:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117184:	e8 1c d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117189:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011718c:	74 17                	je     f01171a5 <test_kmalloc_firstfit1+0xd2>
f011718e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117195:	83 ec 0c             	sub    $0xc,%esp
f0117198:	68 6c a9 12 f0       	push   $0xf012a96c
f011719d:	e8 e9 9d fe ff       	call   f0100f8b <cprintf>
f01171a2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f01171a5:	e8 02 70 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01171aa:	89 c2                	mov    %eax,%edx
f01171ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01171af:	29 d0                	sub    %edx,%eax
f01171b1:	3d ff 00 00 00       	cmp    $0xff,%eax
f01171b6:	7f 17                	jg     f01171cf <test_kmalloc_firstfit1+0xfc>
f01171b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171bf:	83 ec 0c             	sub    $0xc,%esp
f01171c2:	68 8f b6 12 f0       	push   $0xf012b68f
f01171c7:	e8 bf 9d fe ff       	call   f0100f8b <cprintf>
f01171cc:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01171cf:	e8 d8 6f ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01171d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01171d7:	e8 c9 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01171dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f01171df:	83 ec 0c             	sub    $0xc,%esp
f01171e2:	68 00 fc 0f 00       	push   $0xffc00
f01171e7:	e8 ff 1e ff ff       	call   f01090eb <kmalloc>
f01171ec:	83 c4 10             	add    $0x10,%esp
f01171ef:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f01171f2:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01171f5:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f01171fa:	74 17                	je     f0117213 <test_kmalloc_firstfit1+0x140>
f01171fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117203:	83 ec 0c             	sub    $0xc,%esp
f0117206:	68 a8 b6 12 f0       	push   $0xf012b6a8
f011720b:	e8 7b 9d fe ff       	call   f0100f8b <cprintf>
f0117210:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117213:	e8 8d d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117218:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011721b:	74 17                	je     f0117234 <test_kmalloc_firstfit1+0x161>
f011721d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117224:	83 ec 0c             	sub    $0xc,%esp
f0117227:	68 70 aa 12 f0       	push   $0xf012aa70
f011722c:	e8 5a 9d fe ff       	call   f0100f8b <cprintf>
f0117231:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117234:	e8 73 6f ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117239:	89 c2                	mov    %eax,%edx
f011723b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011723e:	29 d0                	sub    %edx,%eax
f0117240:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117245:	7f 17                	jg     f011725e <test_kmalloc_firstfit1+0x18b>
f0117247:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011724e:	83 ec 0c             	sub    $0xc,%esp
f0117251:	68 db b6 12 f0       	push   $0xf012b6db
f0117256:	e8 30 9d fe ff       	call   f0100f8b <cprintf>
f011725b:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011725e:	e8 49 6f ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117263:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117266:	e8 3a d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011726b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f011726e:	83 ec 0c             	sub    $0xc,%esp
f0117271:	68 00 fc 0f 00       	push   $0xffc00
f0117276:	e8 70 1e ff ff       	call   f01090eb <kmalloc>
f011727b:	83 c4 10             	add    $0x10,%esp
f011727e:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117281:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117284:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117289:	74 17                	je     f01172a2 <test_kmalloc_firstfit1+0x1cf>
f011728b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117292:	83 ec 0c             	sub    $0xc,%esp
f0117295:	68 f4 b6 12 f0       	push   $0xf012b6f4
f011729a:	e8 ec 9c fe ff       	call   f0100f8b <cprintf>
f011729f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01172a2:	e8 fe d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01172a7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01172aa:	74 17                	je     f01172c3 <test_kmalloc_firstfit1+0x1f0>
f01172ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172b3:	83 ec 0c             	sub    $0xc,%esp
f01172b6:	68 ac ab 12 f0       	push   $0xf012abac
f01172bb:	e8 cb 9c fe ff       	call   f0100f8b <cprintf>
f01172c0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01172c3:	e8 e4 6e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01172c8:	89 c2                	mov    %eax,%edx
f01172ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01172cd:	29 d0                	sub    %edx,%eax
f01172cf:	3d ff 00 00 00       	cmp    $0xff,%eax
f01172d4:	7f 17                	jg     f01172ed <test_kmalloc_firstfit1+0x21a>
f01172d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172dd:	83 ec 0c             	sub    $0xc,%esp
f01172e0:	68 27 b7 12 f0       	push   $0xf012b727
f01172e5:	e8 a1 9c fe ff       	call   f0100f8b <cprintf>
f01172ea:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01172ed:	e8 ba 6e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01172f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01172f5:	e8 ab d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01172fa:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f01172fd:	83 ec 0c             	sub    $0xc,%esp
f0117300:	68 00 fc 0f 00       	push   $0xffc00
f0117305:	e8 e1 1d ff ff       	call   f01090eb <kmalloc>
f011730a:	83 c4 10             	add    $0x10,%esp
f011730d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117310:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117313:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117318:	74 17                	je     f0117331 <test_kmalloc_firstfit1+0x25e>
f011731a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117321:	83 ec 0c             	sub    $0xc,%esp
f0117324:	68 40 b7 12 f0       	push   $0xf012b740
f0117329:	e8 5d 9c fe ff       	call   f0100f8b <cprintf>
f011732e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117331:	e8 6f d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117336:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117339:	74 17                	je     f0117352 <test_kmalloc_firstfit1+0x27f>
f011733b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117342:	83 ec 0c             	sub    $0xc,%esp
f0117345:	68 a4 ac 12 f0       	push   $0xf012aca4
f011734a:	e8 3c 9c fe ff       	call   f0100f8b <cprintf>
f011734f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117352:	e8 55 6e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117357:	89 c2                	mov    %eax,%edx
f0117359:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011735c:	29 d0                	sub    %edx,%eax
f011735e:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117363:	7f 17                	jg     f011737c <test_kmalloc_firstfit1+0x2a9>
f0117365:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011736c:	83 ec 0c             	sub    $0xc,%esp
f011736f:	68 73 b7 12 f0       	push   $0xf012b773
f0117374:	e8 12 9c fe ff       	call   f0100f8b <cprintf>
f0117379:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011737c:	e8 2b 6e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117381:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117384:	e8 1c d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117389:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f011738c:	83 ec 0c             	sub    $0xc,%esp
f011738f:	68 00 fc 1f 00       	push   $0x1ffc00
f0117394:	e8 52 1d ff ff       	call   f01090eb <kmalloc>
f0117399:	83 c4 10             	add    $0x10,%esp
f011739c:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f011739f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01173a2:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01173a7:	74 17                	je     f01173c0 <test_kmalloc_firstfit1+0x2ed>
f01173a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173b0:	83 ec 0c             	sub    $0xc,%esp
f01173b3:	68 8c b7 12 f0       	push   $0xf012b78c
f01173b8:	e8 ce 9b fe ff       	call   f0100f8b <cprintf>
f01173bd:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01173c0:	e8 e0 d4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01173c5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01173c8:	74 17                	je     f01173e1 <test_kmalloc_firstfit1+0x30e>
f01173ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173d1:	83 ec 0c             	sub    $0xc,%esp
f01173d4:	68 84 ad 12 f0       	push   $0xf012ad84
f01173d9:	e8 ad 9b fe ff       	call   f0100f8b <cprintf>
f01173de:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f01173e1:	e8 c6 6d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01173e6:	89 c2                	mov    %eax,%edx
f01173e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01173eb:	29 d0                	sub    %edx,%eax
f01173ed:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01173f2:	7f 17                	jg     f011740b <test_kmalloc_firstfit1+0x338>
f01173f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173fb:	83 ec 0c             	sub    $0xc,%esp
f01173fe:	68 bf b7 12 f0       	push   $0xf012b7bf
f0117403:	e8 83 9b fe ff       	call   f0100f8b <cprintf>
f0117408:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011740b:	e8 9c 6d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117410:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117413:	e8 8d d4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117418:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f011741b:	83 ec 0c             	sub    $0xc,%esp
f011741e:	68 00 fc 1f 00       	push   $0x1ffc00
f0117423:	e8 c3 1c ff ff       	call   f01090eb <kmalloc>
f0117428:	83 c4 10             	add    $0x10,%esp
f011742b:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f011742e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117431:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117436:	74 17                	je     f011744f <test_kmalloc_firstfit1+0x37c>
f0117438:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011743f:	83 ec 0c             	sub    $0xc,%esp
f0117442:	68 d8 b7 12 f0       	push   $0xf012b7d8
f0117447:	e8 3f 9b fe ff       	call   f0100f8b <cprintf>
f011744c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011744f:	e8 51 d4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117454:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117457:	74 17                	je     f0117470 <test_kmalloc_firstfit1+0x39d>
f0117459:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117460:	83 ec 0c             	sub    $0xc,%esp
f0117463:	68 88 ae 12 f0       	push   $0xf012ae88
f0117468:	e8 1e 9b fe ff       	call   f0100f8b <cprintf>
f011746d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117470:	e8 37 6d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117475:	89 c2                	mov    %eax,%edx
f0117477:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011747a:	29 d0                	sub    %edx,%eax
f011747c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117481:	7f 17                	jg     f011749a <test_kmalloc_firstfit1+0x3c7>
f0117483:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011748a:	83 ec 0c             	sub    $0xc,%esp
f011748d:	68 0b b8 12 f0       	push   $0xf012b80b
f0117492:	e8 f4 9a fe ff       	call   f0100f8b <cprintf>
f0117497:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011749a:	e8 0d 6d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011749f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01174a2:	e8 fe d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01174a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f01174aa:	83 ec 0c             	sub    $0xc,%esp
f01174ad:	68 00 fc 2f 00       	push   $0x2ffc00
f01174b2:	e8 34 1c ff ff       	call   f01090eb <kmalloc>
f01174b7:	83 c4 10             	add    $0x10,%esp
f01174ba:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f01174bd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01174c0:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f01174c5:	74 17                	je     f01174de <test_kmalloc_firstfit1+0x40b>
f01174c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174ce:	83 ec 0c             	sub    $0xc,%esp
f01174d1:	68 24 b8 12 f0       	push   $0xf012b824
f01174d6:	e8 b0 9a fe ff       	call   f0100f8b <cprintf>
f01174db:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01174de:	e8 c2 d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01174e3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01174e6:	74 17                	je     f01174ff <test_kmalloc_firstfit1+0x42c>
f01174e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174ef:	83 ec 0c             	sub    $0xc,%esp
f01174f2:	68 8c af 12 f0       	push   $0xf012af8c
f01174f7:	e8 8f 9a fe ff       	call   f0100f8b <cprintf>
f01174fc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f01174ff:	e8 a8 6c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117504:	89 c2                	mov    %eax,%edx
f0117506:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117509:	29 d0                	sub    %edx,%eax
f011750b:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117510:	7f 17                	jg     f0117529 <test_kmalloc_firstfit1+0x456>
f0117512:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117519:	83 ec 0c             	sub    $0xc,%esp
f011751c:	68 57 b8 12 f0       	push   $0xf012b857
f0117521:	e8 65 9a fe ff       	call   f0100f8b <cprintf>
f0117526:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117529:	e8 7e 6c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011752e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117531:	e8 6f d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117536:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0117539:	83 ec 0c             	sub    $0xc,%esp
f011753c:	68 00 fc 2f 00       	push   $0x2ffc00
f0117541:	e8 a5 1b ff ff       	call   f01090eb <kmalloc>
f0117546:	83 c4 10             	add    $0x10,%esp
f0117549:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f011754c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011754f:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0117554:	74 17                	je     f011756d <test_kmalloc_firstfit1+0x49a>
f0117556:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011755d:	83 ec 0c             	sub    $0xc,%esp
f0117560:	68 70 b8 12 f0       	push   $0xf012b870
f0117565:	e8 21 9a fe ff       	call   f0100f8b <cprintf>
f011756a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011756d:	e8 33 d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117572:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117575:	74 17                	je     f011758e <test_kmalloc_firstfit1+0x4bb>
f0117577:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011757e:	83 ec 0c             	sub    $0xc,%esp
f0117581:	68 90 b0 12 f0       	push   $0xf012b090
f0117586:	e8 00 9a fe ff       	call   f0100f8b <cprintf>
f011758b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f011758e:	e8 19 6c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117593:	89 c2                	mov    %eax,%edx
f0117595:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117598:	29 d0                	sub    %edx,%eax
f011759a:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011759f:	7f 17                	jg     f01175b8 <test_kmalloc_firstfit1+0x4e5>
f01175a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175a8:	83 ec 0c             	sub    $0xc,%esp
f01175ab:	68 a3 b8 12 f0       	push   $0xf012b8a3
f01175b0:	e8 d6 99 fe ff       	call   f0100f8b <cprintf>
f01175b5:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01175b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01175bc:	74 04                	je     f01175c2 <test_kmalloc_firstfit1+0x4ef>
f01175be:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01175c2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f01175c9:	83 ec 0c             	sub    $0xc,%esp
f01175cc:	68 bc b8 12 f0       	push   $0xf012b8bc
f01175d1:	e8 b5 99 fe ff       	call   f0100f8b <cprintf>
f01175d6:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01175d9:	e8 ce 6b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01175de:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01175e1:	e8 bf d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01175e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f01175e9:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01175ec:	83 ec 0c             	sub    $0xc,%esp
f01175ef:	50                   	push   %eax
f01175f0:	e8 56 1d ff ff       	call   f010934b <kfree>
f01175f5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01175f8:	e8 a8 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01175fd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117600:	74 17                	je     f0117619 <test_kmalloc_firstfit1+0x546>
f0117602:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117609:	83 ec 0c             	sub    $0xc,%esp
f011760c:	68 e4 b8 12 f0       	push   $0xf012b8e4
f0117611:	e8 75 99 fe ff       	call   f0100f8b <cprintf>
f0117616:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0117619:	e8 8e 6b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011761e:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117621:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117626:	7f 17                	jg     f011763f <test_kmalloc_firstfit1+0x56c>
f0117628:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011762f:	83 ec 0c             	sub    $0xc,%esp
f0117632:	68 4f b9 12 f0       	push   $0xf012b94f
f0117637:	e8 4f 99 fe ff       	call   f0100f8b <cprintf>
f011763c:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011763f:	e8 68 6b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117644:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117647:	e8 59 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011764c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f011764f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117652:	83 ec 0c             	sub    $0xc,%esp
f0117655:	50                   	push   %eax
f0117656:	e8 f0 1c ff ff       	call   f010934b <kfree>
f011765b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011765e:	e8 42 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117663:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117666:	74 17                	je     f011767f <test_kmalloc_firstfit1+0x5ac>
f0117668:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011766f:	83 ec 0c             	sub    $0xc,%esp
f0117672:	68 60 b9 12 f0       	push   $0xf012b960
f0117677:	e8 0f 99 fe ff       	call   f0100f8b <cprintf>
f011767c:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f011767f:	e8 28 6b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117684:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117687:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011768c:	7f 17                	jg     f01176a5 <test_kmalloc_firstfit1+0x5d2>
f011768e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117695:	83 ec 0c             	sub    $0xc,%esp
f0117698:	68 cc b9 12 f0       	push   $0xf012b9cc
f011769d:	e8 e9 98 fe ff       	call   f0100f8b <cprintf>
f01176a2:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01176a5:	e8 02 6b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01176aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01176ad:	e8 f3 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01176b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01176b5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01176b8:	83 ec 0c             	sub    $0xc,%esp
f01176bb:	50                   	push   %eax
f01176bc:	e8 8a 1c ff ff       	call   f010934b <kfree>
f01176c1:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01176c4:	e8 dc d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01176c9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01176cc:	74 17                	je     f01176e5 <test_kmalloc_firstfit1+0x612>
f01176ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176d5:	83 ec 0c             	sub    $0xc,%esp
f01176d8:	68 e0 b9 12 f0       	push   $0xf012b9e0
f01176dd:	e8 a9 98 fe ff       	call   f0100f8b <cprintf>
f01176e2:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f01176e5:	e8 c2 6a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01176ea:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01176ed:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01176f2:	7f 17                	jg     f011770b <test_kmalloc_firstfit1+0x638>
f01176f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176fb:	83 ec 0c             	sub    $0xc,%esp
f01176fe:	68 4c ba 12 f0       	push   $0xf012ba4c
f0117703:	e8 83 98 fe ff       	call   f0100f8b <cprintf>
f0117708:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011770b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011770f:	74 04                	je     f0117715 <test_kmalloc_firstfit1+0x642>
f0117711:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117715:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f011771c:	83 ec 0c             	sub    $0xc,%esp
f011771f:	68 60 ba 12 f0       	push   $0xf012ba60
f0117724:	e8 62 98 fe ff       	call   f0100f8b <cprintf>
f0117729:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011772c:	e8 7b 6a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117731:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117734:	e8 6c d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117739:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f011773c:	83 ec 0c             	sub    $0xc,%esp
f011773f:	68 00 fc 07 00       	push   $0x7fc00
f0117744:	e8 a2 19 ff ff       	call   f01090eb <kmalloc>
f0117749:	83 c4 10             	add    $0x10,%esp
f011774c:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f011774f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117752:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117757:	74 17                	je     f0117770 <test_kmalloc_firstfit1+0x69d>
f0117759:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117760:	83 ec 0c             	sub    $0xc,%esp
f0117763:	68 8c ba 12 f0       	push   $0xf012ba8c
f0117768:	e8 1e 98 fe ff       	call   f0100f8b <cprintf>
f011776d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117770:	e8 30 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117775:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117778:	74 17                	je     f0117791 <test_kmalloc_firstfit1+0x6be>
f011777a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117781:	83 ec 0c             	sub    $0xc,%esp
f0117784:	68 c0 ba 12 f0       	push   $0xf012bac0
f0117789:	e8 fd 97 fe ff       	call   f0100f8b <cprintf>
f011778e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0117791:	e8 16 6a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117796:	89 c2                	mov    %eax,%edx
f0117798:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011779b:	29 d0                	sub    %edx,%eax
f011779d:	83 f8 7f             	cmp    $0x7f,%eax
f01177a0:	7f 17                	jg     f01177b9 <test_kmalloc_firstfit1+0x6e6>
f01177a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177a9:	83 ec 0c             	sub    $0xc,%esp
f01177ac:	68 2c bb 12 f0       	push   $0xf012bb2c
f01177b1:	e8 d5 97 fe ff       	call   f0100f8b <cprintf>
f01177b6:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01177b9:	e8 ee 69 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01177be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01177c1:	e8 df d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01177c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f01177c9:	83 ec 0c             	sub    $0xc,%esp
f01177cc:	68 00 fc 0f 00       	push   $0xffc00
f01177d1:	e8 15 19 ff ff       	call   f01090eb <kmalloc>
f01177d6:	83 c4 10             	add    $0x10,%esp
f01177d9:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f01177dc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01177df:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01177e4:	74 17                	je     f01177fd <test_kmalloc_firstfit1+0x72a>
f01177e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177ed:	83 ec 0c             	sub    $0xc,%esp
f01177f0:	68 44 bb 12 f0       	push   $0xf012bb44
f01177f5:	e8 91 97 fe ff       	call   f0100f8b <cprintf>
f01177fa:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01177fd:	e8 a3 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117802:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117805:	74 17                	je     f011781e <test_kmalloc_firstfit1+0x74b>
f0117807:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011780e:	83 ec 0c             	sub    $0xc,%esp
f0117811:	68 78 bb 12 f0       	push   $0xf012bb78
f0117816:	e8 70 97 fe ff       	call   f0100f8b <cprintf>
f011781b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f011781e:	e8 89 69 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117823:	89 c2                	mov    %eax,%edx
f0117825:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117828:	29 d0                	sub    %edx,%eax
f011782a:	3d ff 00 00 00       	cmp    $0xff,%eax
f011782f:	7f 17                	jg     f0117848 <test_kmalloc_firstfit1+0x775>
f0117831:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117838:	83 ec 0c             	sub    $0xc,%esp
f011783b:	68 e4 bb 12 f0       	push   $0xf012bbe4
f0117840:	e8 46 97 fe ff       	call   f0100f8b <cprintf>
f0117845:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117848:	e8 5f 69 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011784d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117850:	e8 50 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117855:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0117858:	83 ec 0c             	sub    $0xc,%esp
f011785b:	68 00 fc 03 00       	push   $0x3fc00
f0117860:	e8 86 18 ff ff       	call   f01090eb <kmalloc>
f0117865:	83 c4 10             	add    $0x10,%esp
f0117868:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f011786b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011786e:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0117873:	74 17                	je     f011788c <test_kmalloc_firstfit1+0x7b9>
f0117875:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011787c:	83 ec 0c             	sub    $0xc,%esp
f011787f:	68 fc bb 12 f0       	push   $0xf012bbfc
f0117884:	e8 02 97 fe ff       	call   f0100f8b <cprintf>
f0117889:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011788c:	e8 14 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117891:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117894:	74 17                	je     f01178ad <test_kmalloc_firstfit1+0x7da>
f0117896:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011789d:	83 ec 0c             	sub    $0xc,%esp
f01178a0:	68 30 bc 12 f0       	push   $0xf012bc30
f01178a5:	e8 e1 96 fe ff       	call   f0100f8b <cprintf>
f01178aa:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f01178ad:	e8 fa 68 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01178b2:	89 c2                	mov    %eax,%edx
f01178b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01178b7:	29 d0                	sub    %edx,%eax
f01178b9:	83 f8 3f             	cmp    $0x3f,%eax
f01178bc:	7f 17                	jg     f01178d5 <test_kmalloc_firstfit1+0x802>
f01178be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178c5:	83 ec 0c             	sub    $0xc,%esp
f01178c8:	68 9c bc 12 f0       	push   $0xf012bc9c
f01178cd:	e8 b9 96 fe ff       	call   f0100f8b <cprintf>
f01178d2:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01178d5:	e8 d2 68 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01178da:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01178dd:	e8 c3 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01178e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f01178e5:	83 ec 0c             	sub    $0xc,%esp
f01178e8:	68 00 00 20 00       	push   $0x200000
f01178ed:	e8 f9 17 ff ff       	call   f01090eb <kmalloc>
f01178f2:	83 c4 10             	add    $0x10,%esp
f01178f5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f01178f8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01178fb:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0117900:	74 17                	je     f0117919 <test_kmalloc_firstfit1+0x846>
f0117902:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117909:	83 ec 0c             	sub    $0xc,%esp
f011790c:	68 b4 bc 12 f0       	push   $0xf012bcb4
f0117911:	e8 75 96 fe ff       	call   f0100f8b <cprintf>
f0117916:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f0117919:	e8 8e 68 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011791e:	89 c2                	mov    %eax,%edx
f0117920:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117923:	29 d0                	sub    %edx,%eax
f0117925:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011792a:	7f 17                	jg     f0117943 <test_kmalloc_firstfit1+0x870>
f011792c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117933:	83 ec 0c             	sub    $0xc,%esp
f0117936:	68 e8 bc 12 f0       	push   $0xf012bce8
f011793b:	e8 4b 96 fe ff       	call   f0100f8b <cprintf>
f0117940:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117943:	e8 5d cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117948:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011794b:	74 17                	je     f0117964 <test_kmalloc_firstfit1+0x891>
f011794d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117954:	83 ec 0c             	sub    $0xc,%esp
f0117957:	68 00 bd 12 f0       	push   $0xf012bd00
f011795c:	e8 2a 96 fe ff       	call   f0100f8b <cprintf>
f0117961:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0117964:	e8 43 68 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117969:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011796c:	e8 34 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117971:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0117974:	83 ec 0c             	sub    $0xc,%esp
f0117977:	68 00 fc 3f 00       	push   $0x3ffc00
f011797c:	e8 6a 17 ff ff       	call   f01090eb <kmalloc>
f0117981:	83 c4 10             	add    $0x10,%esp
f0117984:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0117987:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011798a:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f011798f:	74 17                	je     f01179a8 <test_kmalloc_firstfit1+0x8d5>
f0117991:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117998:	83 ec 0c             	sub    $0xc,%esp
f011799b:	68 6c bd 12 f0       	push   $0xf012bd6c
f01179a0:	e8 e6 95 fe ff       	call   f0100f8b <cprintf>
f01179a5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01179a8:	e8 f8 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01179ad:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01179b0:	74 17                	je     f01179c9 <test_kmalloc_firstfit1+0x8f6>
f01179b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179b9:	83 ec 0c             	sub    $0xc,%esp
f01179bc:	68 a0 bd 12 f0       	push   $0xf012bda0
f01179c1:	e8 c5 95 fe ff       	call   f0100f8b <cprintf>
f01179c6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f01179c9:	e8 de 67 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01179ce:	89 c2                	mov    %eax,%edx
f01179d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01179d3:	29 d0                	sub    %edx,%eax
f01179d5:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f01179da:	7f 17                	jg     f01179f3 <test_kmalloc_firstfit1+0x920>
f01179dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179e3:	83 ec 0c             	sub    $0xc,%esp
f01179e6:	68 0c be 12 f0       	push   $0xf012be0c
f01179eb:	e8 9b 95 fe ff       	call   f0100f8b <cprintf>
f01179f0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01179f3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01179f7:	74 04                	je     f01179fd <test_kmalloc_firstfit1+0x92a>
f01179f9:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01179fd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f0117a04:	83 ec 0c             	sub    $0xc,%esp
f0117a07:	68 24 be 12 f0       	push   $0xf012be24
f0117a0c:	e8 7a 95 fe ff       	call   f0100f8b <cprintf>
f0117a11:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a14:	e8 93 67 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117a19:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a1c:	e8 84 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a21:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0117a24:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117a27:	83 ec 0c             	sub    $0xc,%esp
f0117a2a:	50                   	push   %eax
f0117a2b:	e8 1b 19 ff ff       	call   f010934b <kfree>
f0117a30:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a33:	e8 6d ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a38:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a3b:	74 17                	je     f0117a54 <test_kmalloc_firstfit1+0x981>
f0117a3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a44:	83 ec 0c             	sub    $0xc,%esp
f0117a47:	68 d0 b3 12 f0       	push   $0xf012b3d0
f0117a4c:	e8 3a 95 fe ff       	call   f0100f8b <cprintf>
f0117a51:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0117a54:	e8 53 67 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117a59:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117a5c:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117a61:	7f 17                	jg     f0117a7a <test_kmalloc_firstfit1+0x9a7>
f0117a63:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a6a:	83 ec 0c             	sub    $0xc,%esp
f0117a6d:	68 58 be 12 f0       	push   $0xf012be58
f0117a72:	e8 14 95 fe ff       	call   f0100f8b <cprintf>
f0117a77:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a7a:	e8 2d 67 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117a7f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a82:	e8 1e ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a87:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0117a8a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117a8d:	83 ec 0c             	sub    $0xc,%esp
f0117a90:	50                   	push   %eax
f0117a91:	e8 b5 18 ff ff       	call   f010934b <kfree>
f0117a96:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a99:	e8 07 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a9e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117aa1:	74 17                	je     f0117aba <test_kmalloc_firstfit1+0x9e7>
f0117aa3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117aaa:	83 ec 0c             	sub    $0xc,%esp
f0117aad:	68 ac b4 12 f0       	push   $0xf012b4ac
f0117ab2:	e8 d4 94 fe ff       	call   f0100f8b <cprintf>
f0117ab7:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f0117aba:	e8 ed 66 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117abf:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117ac2:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117ac7:	7f 17                	jg     f0117ae0 <test_kmalloc_firstfit1+0xa0d>
f0117ac9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ad0:	83 ec 0c             	sub    $0xc,%esp
f0117ad3:	68 69 be 12 f0       	push   $0xf012be69
f0117ad8:	e8 ae 94 fe ff       	call   f0100f8b <cprintf>
f0117add:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117ae0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117ae4:	74 04                	je     f0117aea <test_kmalloc_firstfit1+0xa17>
f0117ae6:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117aea:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f0117af1:	83 ec 0c             	sub    $0xc,%esp
f0117af4:	68 7c be 12 f0       	push   $0xf012be7c
f0117af9:	e8 8d 94 fe ff       	call   f0100f8b <cprintf>
f0117afe:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b01:	e8 a6 66 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117b06:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b09:	e8 97 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b0e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0117b11:	83 ec 0c             	sub    $0xc,%esp
f0117b14:	68 00 00 10 00       	push   $0x100000
f0117b19:	e8 cd 15 ff ff       	call   f01090eb <kmalloc>
f0117b1e:	83 c4 10             	add    $0x10,%esp
f0117b21:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0117b24:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117b27:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f0117b2c:	74 17                	je     f0117b45 <test_kmalloc_firstfit1+0xa72>
f0117b2e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b35:	83 ec 0c             	sub    $0xc,%esp
f0117b38:	68 bc be 12 f0       	push   $0xf012bebc
f0117b3d:	e8 49 94 fe ff       	call   f0100f8b <cprintf>
f0117b42:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b45:	e8 5b cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b4a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b4d:	74 17                	je     f0117b66 <test_kmalloc_firstfit1+0xa93>
f0117b4f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b56:	83 ec 0c             	sub    $0xc,%esp
f0117b59:	68 f0 be 12 f0       	push   $0xf012bef0
f0117b5e:	e8 28 94 fe ff       	call   f0100f8b <cprintf>
f0117b63:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0117b66:	e8 41 66 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117b6b:	89 c2                	mov    %eax,%edx
f0117b6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117b70:	29 d0                	sub    %edx,%eax
f0117b72:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117b77:	7f 17                	jg     f0117b90 <test_kmalloc_firstfit1+0xabd>
f0117b79:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b80:	83 ec 0c             	sub    $0xc,%esp
f0117b83:	68 5c bf 12 f0       	push   $0xf012bf5c
f0117b88:	e8 fe 93 fe ff       	call   f0100f8b <cprintf>
f0117b8d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0117b90:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117b94:	74 04                	je     f0117b9a <test_kmalloc_firstfit1+0xac7>
f0117b96:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0117b9a:	83 ec 08             	sub    $0x8,%esp
f0117b9d:	ff 75 f4             	pushl  -0xc(%ebp)
f0117ba0:	68 74 bf 12 f0       	push   $0xf012bf74
f0117ba5:	e8 e1 93 fe ff       	call   f0100f8b <cprintf>
f0117baa:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117bad:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117bb2:	8b 7d fc             	mov    -0x4(%ebp),%edi
f0117bb5:	c9                   	leave  
f0117bb6:	c3                   	ret    

f0117bb7 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f0117bb7:	55                   	push   %ebp
f0117bb8:	89 e5                	mov    %esp,%ebp
f0117bba:	57                   	push   %edi
f0117bbb:	53                   	push   %ebx
f0117bbc:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117bbf:	83 ec 0c             	sub    $0xc,%esp
f0117bc2:	68 48 a7 12 f0       	push   $0xf012a748
f0117bc7:	e8 bf 93 fe ff       	call   f0100f8b <cprintf>
f0117bcc:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117bcf:	83 ec 0c             	sub    $0xc,%esp
f0117bd2:	68 78 a7 12 f0       	push   $0xf012a778
f0117bd7:	e8 af 93 fe ff       	call   f0100f8b <cprintf>
f0117bdc:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117bdf:	83 ec 0c             	sub    $0xc,%esp
f0117be2:	68 48 a7 12 f0       	push   $0xf012a748
f0117be7:	e8 9f 93 fe ff       	call   f0100f8b <cprintf>
f0117bec:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117bef:	8d 55 98             	lea    -0x68(%ebp),%edx
f0117bf2:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117bf7:	b8 00 00 00 00       	mov    $0x0,%eax
f0117bfc:	89 d7                	mov    %edx,%edi
f0117bfe:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117c00:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0117c07:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117c0e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0117c15:	83 ec 0c             	sub    $0xc,%esp
f0117c18:	68 ac bf 12 f0       	push   $0xf012bfac
f0117c1d:	e8 69 93 fe ff       	call   f0100f8b <cprintf>
f0117c22:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0117c25:	83 ec 0c             	sub    $0xc,%esp
f0117c28:	68 01 e0 ff 07       	push   $0x7ffe001
f0117c2d:	e8 b9 14 ff ff       	call   f01090eb <kmalloc>
f0117c32:	83 c4 10             	add    $0x10,%esp
f0117c35:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f0117c38:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117c3b:	85 c0                	test   %eax,%eax
f0117c3d:	74 17                	je     f0117c56 <test_kmalloc_firstfit2+0x9f>
f0117c3f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c46:	83 ec 0c             	sub    $0xc,%esp
f0117c49:	68 e0 bf 12 f0       	push   $0xf012bfe0
f0117c4e:	e8 38 93 fe ff       	call   f0100f8b <cprintf>
f0117c53:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117c56:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117c5a:	74 04                	je     f0117c60 <test_kmalloc_firstfit2+0xa9>
f0117c5c:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117c60:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f0117c67:	83 ec 0c             	sub    $0xc,%esp
f0117c6a:	68 28 c0 12 f0       	push   $0xf012c028
f0117c6f:	e8 17 93 fe ff       	call   f0100f8b <cprintf>
f0117c74:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c77:	e8 30 65 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117c7c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c7f:	e8 21 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c84:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0117c87:	83 ec 0c             	sub    $0xc,%esp
f0117c8a:	68 00 fc 1f 00       	push   $0x1ffc00
f0117c8f:	e8 57 14 ff ff       	call   f01090eb <kmalloc>
f0117c94:	83 c4 10             	add    $0x10,%esp
f0117c97:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0117c9a:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117c9d:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117ca2:	74 17                	je     f0117cbb <test_kmalloc_firstfit2+0x104>
f0117ca4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cab:	83 ec 0c             	sub    $0xc,%esp
f0117cae:	68 a8 b6 12 f0       	push   $0xf012b6a8
f0117cb3:	e8 d3 92 fe ff       	call   f0100f8b <cprintf>
f0117cb8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117cbb:	e8 e5 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117cc0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117cc3:	74 17                	je     f0117cdc <test_kmalloc_firstfit2+0x125>
f0117cc5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ccc:	83 ec 0c             	sub    $0xc,%esp
f0117ccf:	68 70 aa 12 f0       	push   $0xf012aa70
f0117cd4:	e8 b2 92 fe ff       	call   f0100f8b <cprintf>
f0117cd9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117cdc:	e8 cb 64 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117ce1:	89 c2                	mov    %eax,%edx
f0117ce3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ce6:	29 d0                	sub    %edx,%eax
f0117ce8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117ced:	7f 17                	jg     f0117d06 <test_kmalloc_firstfit2+0x14f>
f0117cef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cf6:	83 ec 0c             	sub    $0xc,%esp
f0117cf9:	68 db b6 12 f0       	push   $0xf012b6db
f0117cfe:	e8 88 92 fe ff       	call   f0100f8b <cprintf>
f0117d03:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d06:	e8 a1 64 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117d0b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d0e:	e8 92 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d13:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0117d16:	83 ec 0c             	sub    $0xc,%esp
f0117d19:	68 00 fc 1f 00       	push   $0x1ffc00
f0117d1e:	e8 c8 13 ff ff       	call   f01090eb <kmalloc>
f0117d23:	83 c4 10             	add    $0x10,%esp
f0117d26:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117d29:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117d2c:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117d31:	74 17                	je     f0117d4a <test_kmalloc_firstfit2+0x193>
f0117d33:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d3a:	83 ec 0c             	sub    $0xc,%esp
f0117d3d:	68 f4 b6 12 f0       	push   $0xf012b6f4
f0117d42:	e8 44 92 fe ff       	call   f0100f8b <cprintf>
f0117d47:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d4a:	e8 56 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d4f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d52:	74 17                	je     f0117d6b <test_kmalloc_firstfit2+0x1b4>
f0117d54:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d5b:	83 ec 0c             	sub    $0xc,%esp
f0117d5e:	68 ac ab 12 f0       	push   $0xf012abac
f0117d63:	e8 23 92 fe ff       	call   f0100f8b <cprintf>
f0117d68:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117d6b:	e8 3c 64 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117d70:	89 c2                	mov    %eax,%edx
f0117d72:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117d75:	29 d0                	sub    %edx,%eax
f0117d77:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117d7c:	7f 17                	jg     f0117d95 <test_kmalloc_firstfit2+0x1de>
f0117d7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d85:	83 ec 0c             	sub    $0xc,%esp
f0117d88:	68 27 b7 12 f0       	push   $0xf012b727
f0117d8d:	e8 f9 91 fe ff       	call   f0100f8b <cprintf>
f0117d92:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d95:	e8 12 64 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117d9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d9d:	e8 03 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117da2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0117da5:	83 ec 0c             	sub    $0xc,%esp
f0117da8:	68 00 1c 00 00       	push   $0x1c00
f0117dad:	e8 39 13 ff ff       	call   f01090eb <kmalloc>
f0117db2:	83 c4 10             	add    $0x10,%esp
f0117db5:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117db8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117dbb:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117dc0:	74 17                	je     f0117dd9 <test_kmalloc_firstfit2+0x222>
f0117dc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dc9:	83 ec 0c             	sub    $0xc,%esp
f0117dcc:	68 40 b7 12 f0       	push   $0xf012b740
f0117dd1:	e8 b5 91 fe ff       	call   f0100f8b <cprintf>
f0117dd6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117dd9:	e8 c7 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117dde:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117de1:	74 17                	je     f0117dfa <test_kmalloc_firstfit2+0x243>
f0117de3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dea:	83 ec 0c             	sub    $0xc,%esp
f0117ded:	68 a4 ac 12 f0       	push   $0xf012aca4
f0117df2:	e8 94 91 fe ff       	call   f0100f8b <cprintf>
f0117df7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117dfa:	e8 ad 63 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117dff:	89 c2                	mov    %eax,%edx
f0117e01:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117e04:	29 d0                	sub    %edx,%eax
f0117e06:	83 f8 01             	cmp    $0x1,%eax
f0117e09:	7f 17                	jg     f0117e22 <test_kmalloc_firstfit2+0x26b>
f0117e0b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e12:	83 ec 0c             	sub    $0xc,%esp
f0117e15:	68 73 b7 12 f0       	push   $0xf012b773
f0117e1a:	e8 6c 91 fe ff       	call   f0100f8b <cprintf>
f0117e1f:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e22:	e8 85 63 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117e27:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e2a:	e8 76 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0117e32:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117e35:	83 ec 0c             	sub    $0xc,%esp
f0117e38:	50                   	push   %eax
f0117e39:	e8 0d 15 ff ff       	call   f010934b <kfree>
f0117e3e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e41:	e8 5f ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e46:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e49:	74 17                	je     f0117e62 <test_kmalloc_firstfit2+0x2ab>
f0117e4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e52:	83 ec 0c             	sub    $0xc,%esp
f0117e55:	68 84 ad 12 f0       	push   $0xf012ad84
f0117e5a:	e8 2c 91 fe ff       	call   f0100f8b <cprintf>
f0117e5f:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f0117e62:	e8 45 63 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117e67:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117e6a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117e6f:	7f 17                	jg     f0117e88 <test_kmalloc_firstfit2+0x2d1>
f0117e71:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e78:	83 ec 0c             	sub    $0xc,%esp
f0117e7b:	68 6e c0 12 f0       	push   $0xf012c06e
f0117e80:	e8 06 91 fe ff       	call   f0100f8b <cprintf>
f0117e85:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e88:	e8 1f 63 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117e8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e90:	e8 10 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e95:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117e98:	83 ec 0c             	sub    $0xc,%esp
f0117e9b:	68 00 fc 2f 00       	push   $0x2ffc00
f0117ea0:	e8 46 12 ff ff       	call   f01090eb <kmalloc>
f0117ea5:	83 c4 10             	add    $0x10,%esp
f0117ea8:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117eab:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117eae:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0117eb3:	74 17                	je     f0117ecc <test_kmalloc_firstfit2+0x315>
f0117eb5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ebc:	83 ec 0c             	sub    $0xc,%esp
f0117ebf:	68 d8 b7 12 f0       	push   $0xf012b7d8
f0117ec4:	e8 c2 90 fe ff       	call   f0100f8b <cprintf>
f0117ec9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ecc:	e8 d4 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ed1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ed4:	74 17                	je     f0117eed <test_kmalloc_firstfit2+0x336>
f0117ed6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117edd:	83 ec 0c             	sub    $0xc,%esp
f0117ee0:	68 88 ae 12 f0       	push   $0xf012ae88
f0117ee5:	e8 a1 90 fe ff       	call   f0100f8b <cprintf>
f0117eea:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117eed:	e8 ba 62 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117ef2:	89 c2                	mov    %eax,%edx
f0117ef4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ef7:	29 d0                	sub    %edx,%eax
f0117ef9:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117efe:	7f 17                	jg     f0117f17 <test_kmalloc_firstfit2+0x360>
f0117f00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f07:	83 ec 0c             	sub    $0xc,%esp
f0117f0a:	68 0b b8 12 f0       	push   $0xf012b80b
f0117f0f:	e8 77 90 fe ff       	call   f0100f8b <cprintf>
f0117f14:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f17:	e8 90 62 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117f1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f1f:	e8 81 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f24:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f0117f27:	83 ec 0c             	sub    $0xc,%esp
f0117f2a:	68 00 18 20 00       	push   $0x201800
f0117f2f:	e8 b7 11 ff ff       	call   f01090eb <kmalloc>
f0117f34:	83 c4 10             	add    $0x10,%esp
f0117f37:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0117f3a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117f3d:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0117f42:	74 17                	je     f0117f5b <test_kmalloc_firstfit2+0x3a4>
f0117f44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f4b:	83 ec 0c             	sub    $0xc,%esp
f0117f4e:	68 24 b8 12 f0       	push   $0xf012b824
f0117f53:	e8 33 90 fe ff       	call   f0100f8b <cprintf>
f0117f58:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f5b:	e8 45 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f60:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f63:	74 17                	je     f0117f7c <test_kmalloc_firstfit2+0x3c5>
f0117f65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f6c:	83 ec 0c             	sub    $0xc,%esp
f0117f6f:	68 8c af 12 f0       	push   $0xf012af8c
f0117f74:	e8 12 90 fe ff       	call   f0100f8b <cprintf>
f0117f79:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0117f7c:	e8 2b 62 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117f81:	89 c2                	mov    %eax,%edx
f0117f83:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f86:	29 d0                	sub    %edx,%eax
f0117f88:	3d 01 02 00 00       	cmp    $0x201,%eax
f0117f8d:	7f 17                	jg     f0117fa6 <test_kmalloc_firstfit2+0x3ef>
f0117f8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f96:	83 ec 0c             	sub    $0xc,%esp
f0117f99:	68 57 b8 12 f0       	push   $0xf012b857
f0117f9e:	e8 e8 8f fe ff       	call   f0100f8b <cprintf>
f0117fa3:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117fa6:	e8 01 62 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117fab:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117fae:	e8 f2 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117fb3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0117fb6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117fb9:	83 ec 0c             	sub    $0xc,%esp
f0117fbc:	50                   	push   %eax
f0117fbd:	e8 89 13 ff ff       	call   f010934b <kfree>
f0117fc2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117fc5:	e8 db c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117fca:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117fcd:	74 17                	je     f0117fe6 <test_kmalloc_firstfit2+0x42f>
f0117fcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fd6:	83 ec 0c             	sub    $0xc,%esp
f0117fd9:	68 90 b0 12 f0       	push   $0xf012b090
f0117fde:	e8 a8 8f fe ff       	call   f0100f8b <cprintf>
f0117fe3:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f0117fe6:	e8 c1 61 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0117feb:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117fee:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117ff3:	7f 17                	jg     f011800c <test_kmalloc_firstfit2+0x455>
f0117ff5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ffc:	83 ec 0c             	sub    $0xc,%esp
f0117fff:	68 7e c0 12 f0       	push   $0xf012c07e
f0118004:	e8 82 8f fe ff       	call   f0100f8b <cprintf>
f0118009:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f011800c:	e8 9b 61 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118011:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118014:	e8 8c c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118019:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011801c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011801f:	83 ec 0c             	sub    $0xc,%esp
f0118022:	50                   	push   %eax
f0118023:	e8 23 13 ff ff       	call   f010934b <kfree>
f0118028:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f011802b:	e8 7c 61 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118030:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118033:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118038:	7f 17                	jg     f0118051 <test_kmalloc_firstfit2+0x49a>
f011803a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118041:	83 ec 0c             	sub    $0xc,%esp
f0118044:	68 4f b9 12 f0       	push   $0xf012b94f
f0118049:	e8 3d 8f fe ff       	call   f0100f8b <cprintf>
f011804e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118051:	e8 4f c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118056:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118059:	74 17                	je     f0118072 <test_kmalloc_firstfit2+0x4bb>
f011805b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118062:	83 ec 0c             	sub    $0xc,%esp
f0118065:	68 e4 b8 12 f0       	push   $0xf012b8e4
f011806a:	e8 1c 8f fe ff       	call   f0100f8b <cprintf>
f011806f:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118072:	e8 35 61 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118077:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011807a:	e8 26 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011807f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f0118082:	83 ec 0c             	sub    $0xc,%esp
f0118085:	68 00 fc 4f 00       	push   $0x4ffc00
f011808a:	e8 5c 10 ff ff       	call   f01090eb <kmalloc>
f011808f:	83 c4 10             	add    $0x10,%esp
f0118092:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f0118095:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118098:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f011809d:	74 17                	je     f01180b6 <test_kmalloc_firstfit2+0x4ff>
f011809f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180a6:	83 ec 0c             	sub    $0xc,%esp
f01180a9:	68 90 c0 12 f0       	push   $0xf012c090
f01180ae:	e8 d8 8e fe ff       	call   f0100f8b <cprintf>
f01180b3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01180b6:	e8 ea c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01180bb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01180be:	74 17                	je     f01180d7 <test_kmalloc_firstfit2+0x520>
f01180c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180c7:	83 ec 0c             	sub    $0xc,%esp
f01180ca:	68 60 b9 12 f0       	push   $0xf012b960
f01180cf:	e8 b7 8e fe ff       	call   f0100f8b <cprintf>
f01180d4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f01180d7:	e8 d0 60 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01180dc:	89 c2                	mov    %eax,%edx
f01180de:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01180e1:	29 d0                	sub    %edx,%eax
f01180e3:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f01180e8:	7f 17                	jg     f0118101 <test_kmalloc_firstfit2+0x54a>
f01180ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180f1:	83 ec 0c             	sub    $0xc,%esp
f01180f4:	68 c4 c0 12 f0       	push   $0xf012c0c4
f01180f9:	e8 8d 8e fe ff       	call   f0100f8b <cprintf>
f01180fe:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0118101:	e8 a6 60 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118106:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118109:	e8 97 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011810e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0118111:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118114:	83 ec 0c             	sub    $0xc,%esp
f0118117:	50                   	push   %eax
f0118118:	e8 2e 12 ff ff       	call   f010934b <kfree>
f011811d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118120:	e8 80 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118125:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118128:	74 17                	je     f0118141 <test_kmalloc_firstfit2+0x58a>
f011812a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118131:	83 ec 0c             	sub    $0xc,%esp
f0118134:	68 e0 b9 12 f0       	push   $0xf012b9e0
f0118139:	e8 4d 8e fe ff       	call   f0100f8b <cprintf>
f011813e:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f0118141:	e8 66 60 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118146:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118149:	83 f8 01             	cmp    $0x1,%eax
f011814c:	7f 17                	jg     f0118165 <test_kmalloc_firstfit2+0x5ae>
f011814e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118155:	83 ec 0c             	sub    $0xc,%esp
f0118158:	68 4c ba 12 f0       	push   $0xf012ba4c
f011815d:	e8 29 8e fe ff       	call   f0100f8b <cprintf>
f0118162:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f0118165:	e8 42 60 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011816a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011816d:	e8 33 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118172:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0118175:	83 ec 0c             	sub    $0xc,%esp
f0118178:	68 00 04 00 00       	push   $0x400
f011817d:	e8 69 0f ff ff       	call   f01090eb <kmalloc>
f0118182:	83 c4 10             	add    $0x10,%esp
f0118185:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118188:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011818b:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118190:	76 22                	jbe    f01181b4 <test_kmalloc_firstfit2+0x5fd>
f0118192:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f0118195:	83 ec 0c             	sub    $0xc,%esp
f0118198:	6a 00                	push   $0x0
f011819a:	e8 19 0e ff ff       	call   f0108fb8 <sbrk>
f011819f:	83 c4 10             	add    $0x10,%esp
f01181a2:	39 c3                	cmp    %eax,%ebx
f01181a4:	73 0e                	jae    f01181b4 <test_kmalloc_firstfit2+0x5fd>
f01181a6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01181a9:	89 c2                	mov    %eax,%edx
f01181ab:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f01181b0:	39 c2                	cmp    %eax,%edx
f01181b2:	72 17                	jb     f01181cb <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01181b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181bb:	83 ec 0c             	sub    $0xc,%esp
f01181be:	68 dc c0 12 f0       	push   $0xf012c0dc
f01181c3:	e8 c3 8d fe ff       	call   f0100f8b <cprintf>
f01181c8:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181cb:	e8 d5 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181d0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181d3:	74 17                	je     f01181ec <test_kmalloc_firstfit2+0x635>
f01181d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181dc:	83 ec 0c             	sub    $0xc,%esp
f01181df:	68 c0 ba 12 f0       	push   $0xf012bac0
f01181e4:	e8 a2 8d fe ff       	call   f0100f8b <cprintf>
f01181e9:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01181ec:	e8 b4 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181f1:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f01181f4:	83 ec 0c             	sub    $0xc,%esp
f01181f7:	68 00 08 00 00       	push   $0x800
f01181fc:	e8 ea 0e ff ff       	call   f01090eb <kmalloc>
f0118201:	83 c4 10             	add    $0x10,%esp
f0118204:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0118207:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011820a:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011820f:	76 22                	jbe    f0118233 <test_kmalloc_firstfit2+0x67c>
f0118211:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0118214:	83 ec 0c             	sub    $0xc,%esp
f0118217:	6a 00                	push   $0x0
f0118219:	e8 9a 0d ff ff       	call   f0108fb8 <sbrk>
f011821e:	83 c4 10             	add    $0x10,%esp
f0118221:	39 c3                	cmp    %eax,%ebx
f0118223:	73 0e                	jae    f0118233 <test_kmalloc_firstfit2+0x67c>
f0118225:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118228:	89 c2                	mov    %eax,%edx
f011822a:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011822f:	39 c2                	cmp    %eax,%edx
f0118231:	72 17                	jb     f011824a <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118233:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011823a:	83 ec 0c             	sub    $0xc,%esp
f011823d:	68 68 c1 12 f0       	push   $0xf012c168
f0118242:	e8 44 8d fe ff       	call   f0100f8b <cprintf>
f0118247:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011824a:	e8 56 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011824f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118252:	74 17                	je     f011826b <test_kmalloc_firstfit2+0x6b4>
f0118254:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011825b:	83 ec 0c             	sub    $0xc,%esp
f011825e:	68 78 bb 12 f0       	push   $0xf012bb78
f0118263:	e8 23 8d fe ff       	call   f0100f8b <cprintf>
f0118268:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011826b:	e8 35 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118270:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f0118273:	83 ec 0c             	sub    $0xc,%esp
f0118276:	68 00 04 00 00       	push   $0x400
f011827b:	e8 6b 0e ff ff       	call   f01090eb <kmalloc>
f0118280:	83 c4 10             	add    $0x10,%esp
f0118283:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0118286:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118289:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011828e:	76 22                	jbe    f01182b2 <test_kmalloc_firstfit2+0x6fb>
f0118290:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0118293:	83 ec 0c             	sub    $0xc,%esp
f0118296:	6a 00                	push   $0x0
f0118298:	e8 1b 0d ff ff       	call   f0108fb8 <sbrk>
f011829d:	83 c4 10             	add    $0x10,%esp
f01182a0:	39 c3                	cmp    %eax,%ebx
f01182a2:	73 0e                	jae    f01182b2 <test_kmalloc_firstfit2+0x6fb>
f01182a4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01182a7:	89 c2                	mov    %eax,%edx
f01182a9:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f01182ae:	39 c2                	cmp    %eax,%edx
f01182b0:	72 17                	jb     f01182c9 <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01182b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182b9:	83 ec 0c             	sub    $0xc,%esp
f01182bc:	68 f4 c1 12 f0       	push   $0xf012c1f4
f01182c1:	e8 c5 8c fe ff       	call   f0100f8b <cprintf>
f01182c6:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01182c9:	e8 d7 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01182ce:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01182d1:	74 17                	je     f01182ea <test_kmalloc_firstfit2+0x733>
f01182d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182da:	83 ec 0c             	sub    $0xc,%esp
f01182dd:	68 30 bc 12 f0       	push   $0xf012bc30
f01182e2:	e8 a4 8c fe ff       	call   f0100f8b <cprintf>
f01182e7:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f01182ea:	e8 bd 5e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01182ef:	89 c2                	mov    %eax,%edx
f01182f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01182f4:	29 d0                	sub    %edx,%eax
f01182f6:	83 f8 01             	cmp    $0x1,%eax
f01182f9:	74 17                	je     f0118312 <test_kmalloc_firstfit2+0x75b>
f01182fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118302:	83 ec 0c             	sub    $0xc,%esp
f0118305:	68 80 c2 12 f0       	push   $0xf012c280
f011830a:	e8 7c 8c fe ff       	call   f0100f8b <cprintf>
f011830f:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0118312:	e8 95 5e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118317:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011831a:	e8 86 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011831f:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0118322:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118325:	83 ec 0c             	sub    $0xc,%esp
f0118328:	50                   	push   %eax
f0118329:	e8 1d 10 ff ff       	call   f010934b <kfree>
f011832e:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118331:	e8 6f c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118336:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118339:	74 17                	je     f0118352 <test_kmalloc_firstfit2+0x79b>
f011833b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118342:	83 ec 0c             	sub    $0xc,%esp
f0118345:	68 00 bd 12 f0       	push   $0xf012bd00
f011834a:	e8 3c 8c fe ff       	call   f0100f8b <cprintf>
f011834f:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118352:	e8 55 5e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118357:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011835a:	74 17                	je     f0118373 <test_kmalloc_firstfit2+0x7bc>
f011835c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118363:	83 ec 0c             	sub    $0xc,%esp
f0118366:	68 a4 c2 12 f0       	push   $0xf012c2a4
f011836b:	e8 1b 8c fe ff       	call   f0100f8b <cprintf>
f0118370:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f0118373:	e8 34 5e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118378:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011837b:	e8 25 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118380:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f0118383:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118386:	83 ec 0c             	sub    $0xc,%esp
f0118389:	50                   	push   %eax
f011838a:	e8 bc 0f ff ff       	call   f010934b <kfree>
f011838f:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118392:	e8 0e c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118397:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011839a:	74 17                	je     f01183b3 <test_kmalloc_firstfit2+0x7fc>
f011839c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183a3:	83 ec 0c             	sub    $0xc,%esp
f01183a6:	68 a0 bd 12 f0       	push   $0xf012bda0
f01183ab:	e8 db 8b fe ff       	call   f0100f8b <cprintf>
f01183b0:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f01183b3:	e8 f4 5d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01183b8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01183bb:	74 17                	je     f01183d4 <test_kmalloc_firstfit2+0x81d>
f01183bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183c4:	83 ec 0c             	sub    $0xc,%esp
f01183c7:	68 04 c3 12 f0       	push   $0xf012c304
f01183cc:	e8 ba 8b fe ff       	call   f0100f8b <cprintf>
f01183d1:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f01183d4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01183d8:	74 04                	je     f01183de <test_kmalloc_firstfit2+0x827>
f01183da:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f01183de:	83 ec 0c             	sub    $0xc,%esp
f01183e1:	68 64 c3 12 f0       	push   $0xf012c364
f01183e6:	e8 a0 8b fe ff       	call   f0100f8b <cprintf>
f01183eb:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01183ee:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01183f5:	e8 b2 5d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01183fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01183fd:	e8 a3 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118402:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0118405:	83 ec 0c             	sub    $0xc,%esp
f0118408:	68 00 08 00 00       	push   $0x800
f011840d:	e8 d9 0c ff ff       	call   f01090eb <kmalloc>
f0118412:	83 c4 10             	add    $0x10,%esp
f0118415:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118418:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011841b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011841e:	39 c2                	cmp    %eax,%edx
f0118420:	74 17                	je     f0118439 <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0118422:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118429:	83 ec 0c             	sub    $0xc,%esp
f011842c:	68 9c c3 12 f0       	push   $0xf012c39c
f0118431:	e8 55 8b fe ff       	call   f0100f8b <cprintf>
f0118436:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118439:	e8 67 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011843e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118441:	74 17                	je     f011845a <test_kmalloc_firstfit2+0x8a3>
f0118443:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011844a:	83 ec 0c             	sub    $0xc,%esp
f011844d:	68 d0 b3 12 f0       	push   $0xf012b3d0
f0118452:	e8 34 8b fe ff       	call   f0100f8b <cprintf>
f0118457:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f011845a:	e8 4d 5d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011845f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118462:	74 17                	je     f011847b <test_kmalloc_firstfit2+0x8c4>
f0118464:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011846b:	83 ec 0c             	sub    $0xc,%esp
f011846e:	68 d0 c3 12 f0       	push   $0xf012c3d0
f0118473:	e8 13 8b fe ff       	call   f0100f8b <cprintf>
f0118478:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011847b:	e8 2c 5d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118480:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118483:	e8 1d c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118488:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f011848b:	83 ec 0c             	sub    $0xc,%esp
f011848e:	68 00 04 00 00       	push   $0x400
f0118493:	e8 53 0c ff ff       	call   f01090eb <kmalloc>
f0118498:	83 c4 10             	add    $0x10,%esp
f011849b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f011849e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01184a1:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01184a4:	81 c2 08 08 00 00    	add    $0x808,%edx
f01184aa:	39 d0                	cmp    %edx,%eax
f01184ac:	74 17                	je     f01184c5 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f01184ae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184b5:	83 ec 0c             	sub    $0xc,%esp
f01184b8:	68 e8 c3 12 f0       	push   $0xf012c3e8
f01184bd:	e8 c9 8a fe ff       	call   f0100f8b <cprintf>
f01184c2:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184c5:	e8 db c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01184ca:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01184cd:	74 17                	je     f01184e6 <test_kmalloc_firstfit2+0x92f>
f01184cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184d6:	83 ec 0c             	sub    $0xc,%esp
f01184d9:	68 ac b4 12 f0       	push   $0xf012b4ac
f01184de:	e8 a8 8a fe ff       	call   f0100f8b <cprintf>
f01184e3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f01184e6:	e8 c1 5c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01184eb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01184ee:	74 17                	je     f0118507 <test_kmalloc_firstfit2+0x950>
f01184f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184f7:	83 ec 0c             	sub    $0xc,%esp
f01184fa:	68 1c c4 12 f0       	push   $0xf012c41c
f01184ff:	e8 87 8a fe ff       	call   f0100f8b <cprintf>
f0118504:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0118507:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011850b:	74 04                	je     f0118511 <test_kmalloc_firstfit2+0x95a>
f011850d:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118511:	83 ec 0c             	sub    $0xc,%esp
f0118514:	68 34 c4 12 f0       	push   $0xf012c434
f0118519:	e8 6d 8a fe ff       	call   f0100f8b <cprintf>
f011851e:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118521:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118528:	e8 7f 5c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011852d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118530:	e8 70 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118535:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0118538:	83 ec 0c             	sub    $0xc,%esp
f011853b:	68 00 04 70 00       	push   $0x700400
f0118540:	e8 a6 0b ff ff       	call   f01090eb <kmalloc>
f0118545:	83 c4 10             	add    $0x10,%esp
f0118548:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f011854b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011854e:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118553:	74 17                	je     f011856c <test_kmalloc_firstfit2+0x9b5>
f0118555:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011855c:	83 ec 0c             	sub    $0xc,%esp
f011855f:	68 bc be 12 f0       	push   $0xf012bebc
f0118564:	e8 22 8a fe ff       	call   f0100f8b <cprintf>
f0118569:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011856c:	e8 34 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118571:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118574:	74 17                	je     f011858d <test_kmalloc_firstfit2+0x9d6>
f0118576:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011857d:	83 ec 0c             	sub    $0xc,%esp
f0118580:	68 f0 be 12 f0       	push   $0xf012bef0
f0118585:	e8 01 8a fe ff       	call   f0100f8b <cprintf>
f011858a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f011858d:	e8 1a 5c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118592:	89 c2                	mov    %eax,%edx
f0118594:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118597:	29 d0                	sub    %edx,%eax
f0118599:	3d 00 07 00 00       	cmp    $0x700,%eax
f011859e:	7f 17                	jg     f01185b7 <test_kmalloc_firstfit2+0xa00>
f01185a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185a7:	83 ec 0c             	sub    $0xc,%esp
f01185aa:	68 5c bf 12 f0       	push   $0xf012bf5c
f01185af:	e8 d7 89 fe ff       	call   f0100f8b <cprintf>
f01185b4:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01185b7:	e8 f0 5b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01185bc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01185bf:	e8 e1 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01185c4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f01185c7:	83 ec 0c             	sub    $0xc,%esp
f01185ca:	68 00 0c 00 00       	push   $0xc00
f01185cf:	e8 17 0b ff ff       	call   f01090eb <kmalloc>
f01185d4:	83 c4 10             	add    $0x10,%esp
f01185d7:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f01185da:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01185dd:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f01185e2:	74 17                	je     f01185fb <test_kmalloc_firstfit2+0xa44>
f01185e4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185eb:	83 ec 0c             	sub    $0xc,%esp
f01185ee:	68 68 c4 12 f0       	push   $0xf012c468
f01185f3:	e8 93 89 fe ff       	call   f0100f8b <cprintf>
f01185f8:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185fb:	e8 a5 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118600:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118603:	74 17                	je     f011861c <test_kmalloc_firstfit2+0xa65>
f0118605:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011860c:	83 ec 0c             	sub    $0xc,%esp
f011860f:	68 9c c4 12 f0       	push   $0xf012c49c
f0118614:	e8 72 89 fe ff       	call   f0100f8b <cprintf>
f0118619:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f011861c:	e8 8b 5b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118621:	89 c2                	mov    %eax,%edx
f0118623:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118626:	29 d0                	sub    %edx,%eax
f0118628:	85 c0                	test   %eax,%eax
f011862a:	7f 17                	jg     f0118643 <test_kmalloc_firstfit2+0xa8c>
f011862c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118633:	83 ec 0c             	sub    $0xc,%esp
f0118636:	68 08 c5 12 f0       	push   $0xf012c508
f011863b:	e8 4b 89 fe ff       	call   f0100f8b <cprintf>
f0118640:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0118643:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118647:	74 04                	je     f011864d <test_kmalloc_firstfit2+0xa96>
f0118649:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f011864d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0118654:	83 ec 0c             	sub    $0xc,%esp
f0118657:	68 20 c5 12 f0       	push   $0xf012c520
f011865c:	e8 2a 89 fe ff       	call   f0100f8b <cprintf>
f0118661:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f0118664:	83 ec 0c             	sub    $0xc,%esp
f0118667:	68 00 e0 1f 07       	push   $0x71fe000
f011866c:	e8 7a 0a ff ff       	call   f01090eb <kmalloc>
f0118671:	83 c4 10             	add    $0x10,%esp
f0118674:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0118677:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011867a:	85 c0                	test   %eax,%eax
f011867c:	74 17                	je     f0118695 <test_kmalloc_firstfit2+0xade>
f011867e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118685:	83 ec 0c             	sub    $0xc,%esp
f0118688:	68 74 c5 12 f0       	push   $0xf012c574
f011868d:	e8 f9 88 fe ff       	call   f0100f8b <cprintf>
f0118692:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0118695:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118699:	74 04                	je     f011869f <test_kmalloc_firstfit2+0xae8>
f011869b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f011869f:	83 ec 08             	sub    $0x8,%esp
f01186a2:	ff 75 f4             	pushl  -0xc(%ebp)
f01186a5:	68 dc c5 12 f0       	push   $0xf012c5dc
f01186aa:	e8 dc 88 fe ff       	call   f0100f8b <cprintf>
f01186af:	83 c4 10             	add    $0x10,%esp

	return 1;
f01186b2:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01186b7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01186ba:	5b                   	pop    %ebx
f01186bb:	5f                   	pop    %edi
f01186bc:	5d                   	pop    %ebp
f01186bd:	c3                   	ret    

f01186be <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f01186be:	55                   	push   %ebp
f01186bf:	89 e5                	mov    %esp,%ebp
f01186c1:	53                   	push   %ebx
f01186c2:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01186c5:	83 ec 0c             	sub    $0xc,%esp
f01186c8:	68 48 a7 12 f0       	push   $0xf012a748
f01186cd:	e8 b9 88 fe ff       	call   f0100f8b <cprintf>
f01186d2:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01186d5:	83 ec 0c             	sub    $0xc,%esp
f01186d8:	68 78 a7 12 f0       	push   $0xf012a778
f01186dd:	e8 a9 88 fe ff       	call   f0100f8b <cprintf>
f01186e2:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01186e5:	83 ec 0c             	sub    $0xc,%esp
f01186e8:	68 48 a7 12 f0       	push   $0xf012a748
f01186ed:	e8 99 88 fe ff       	call   f0100f8b <cprintf>
f01186f2:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f01186f5:	e8 b2 5a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01186fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f01186fd:	e8 a3 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118702:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0118705:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f011870c:	83 ec 0c             	sub    $0xc,%esp
f011870f:	68 11 c6 12 f0       	push   $0xf012c611
f0118714:	e8 72 88 fe ff       	call   f0100f8b <cprintf>
f0118719:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f011871c:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0118721:	ba 00 00 00 00       	mov    $0x0,%edx
f0118726:	f7 75 e4             	divl   -0x1c(%ebp)
f0118729:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f011872c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118733:	eb 1d                	jmp    f0118752 <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0118735:	83 ec 0c             	sub    $0xc,%esp
f0118738:	ff 75 e4             	pushl  -0x1c(%ebp)
f011873b:	e8 ab 09 ff ff       	call   f01090eb <kmalloc>
f0118740:	83 c4 10             	add    $0x10,%esp
f0118743:	89 c2                	mov    %eax,%edx
f0118745:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118748:	89 14 85 60 30 69 f0 	mov    %edx,-0xf96cfa0(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f011874f:	ff 45 f4             	incl   -0xc(%ebp)
f0118752:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118755:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118758:	7c db                	jl     f0118735 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f011875a:	83 ec 0c             	sub    $0xc,%esp
f011875d:	68 15 c6 12 f0       	push   $0xf012c615
f0118762:	e8 24 88 fe ff       	call   f0100f8b <cprintf>
f0118767:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f011876a:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f011876f:	ba 00 00 00 00       	mov    $0x0,%edx
f0118774:	f7 75 e4             	divl   -0x1c(%ebp)
f0118777:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f011877a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011877e:	74 1e                	je     f011879e <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0118780:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0118783:	8d 43 01             	lea    0x1(%ebx),%eax
f0118786:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118789:	83 ec 0c             	sub    $0xc,%esp
f011878c:	ff 75 e0             	pushl  -0x20(%ebp)
f011878f:	e8 57 09 ff ff       	call   f01090eb <kmalloc>
f0118794:	83 c4 10             	add    $0x10,%esp
f0118797:	89 04 9d 60 30 69 f0 	mov    %eax,-0xf96cfa0(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f011879e:	83 ec 04             	sub    $0x4,%esp
f01187a1:	ff 75 f0             	pushl  -0x10(%ebp)
f01187a4:	ff 75 e4             	pushl  -0x1c(%ebp)
f01187a7:	68 1c c6 12 f0       	push   $0xf012c61c
f01187ac:	e8 da 87 fe ff       	call   f0100f8b <cprintf>
f01187b1:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f01187b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01187bb:	eb 36                	jmp    f01187f3 <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f01187bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01187c0:	8b 04 85 60 30 69 f0 	mov    -0xf96cfa0(,%eax,4),%eax
f01187c7:	89 c2                	mov    %eax,%edx
f01187c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01187cc:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01187d0:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f01187d5:	39 c2                	cmp    %eax,%edx
f01187d7:	74 17                	je     f01187f0 <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f01187d9:	83 ec 04             	sub    $0x4,%esp
f01187dc:	68 64 c6 12 f0       	push   $0xf012c664
f01187e1:	68 e4 02 00 00       	push   $0x2e4
f01187e6:	68 a7 c6 12 f0       	push   $0xf012c6a7
f01187eb:	e8 49 7b fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f01187f0:	ff 45 f4             	incl   -0xc(%ebp)
f01187f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01187f6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01187f9:	7c c2                	jl     f01187bd <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01187fb:	e8 a5 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118800:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118803:	74 17                	je     f011881c <test_fastfirstfit+0x15e>
f0118805:	83 ec 04             	sub    $0x4,%esp
f0118808:	68 c0 c6 12 f0       	push   $0xf012c6c0
f011880d:	68 e7 02 00 00       	push   $0x2e7
f0118812:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118817:	e8 1d 7b fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f011881c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011881f:	e8 88 59 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118824:	29 c3                	sub    %eax,%ebx
f0118826:	89 d8                	mov    %ebx,%eax
f0118828:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f011882d:	77 17                	ja     f0118846 <test_fastfirstfit+0x188>
f011882f:	83 ec 04             	sub    $0x4,%esp
f0118832:	68 28 c7 12 f0       	push   $0xf012c728
f0118837:	68 e8 02 00 00       	push   $0x2e8
f011883c:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118841:	e8 f3 7a fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0118846:	e8 5a c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011884b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f011884e:	e8 59 59 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118853:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0118856:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f011885a:	7f 17                	jg     f0118873 <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f011885c:	83 ec 04             	sub    $0x4,%esp
f011885f:	68 3c c7 12 f0       	push   $0xf012c73c
f0118864:	68 ef 02 00 00       	push   $0x2ef
f0118869:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011886e:	e8 c6 7a fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f0118873:	a1 60 30 69 f0       	mov    0xf0693060,%eax
f0118878:	83 ec 0c             	sub    $0xc,%esp
f011887b:	50                   	push   %eax
f011887c:	e8 ca 0a ff ff       	call   f010934b <kfree>
f0118881:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f0118884:	a1 68 30 69 f0       	mov    0xf0693068,%eax
f0118889:	83 ec 0c             	sub    $0xc,%esp
f011888c:	50                   	push   %eax
f011888d:	e8 b9 0a ff ff       	call   f010934b <kfree>
f0118892:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0118895:	a1 6c 30 69 f0       	mov    0xf069306c,%eax
f011889a:	83 ec 0c             	sub    $0xc,%esp
f011889d:	50                   	push   %eax
f011889e:	e8 a8 0a ff ff       	call   f010934b <kfree>
f01188a3:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f01188a6:	a1 74 30 69 f0       	mov    0xf0693074,%eax
f01188ab:	83 ec 0c             	sub    $0xc,%esp
f01188ae:	50                   	push   %eax
f01188af:	e8 97 0a ff ff       	call   f010934b <kfree>
f01188b4:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f01188b7:	a1 88 30 69 f0       	mov    0xf0693088,%eax
f01188bc:	83 ec 0c             	sub    $0xc,%esp
f01188bf:	50                   	push   %eax
f01188c0:	e8 86 0a ff ff       	call   f010934b <kfree>
f01188c5:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f01188c8:	a1 90 30 69 f0       	mov    0xf0693090,%eax
f01188cd:	83 ec 0c             	sub    $0xc,%esp
f01188d0:	50                   	push   %eax
f01188d1:	e8 75 0a ff ff       	call   f010934b <kfree>
f01188d6:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f01188d9:	a1 8c 30 69 f0       	mov    0xf069308c,%eax
f01188de:	83 ec 0c             	sub    $0xc,%esp
f01188e1:	50                   	push   %eax
f01188e2:	e8 64 0a ff ff       	call   f010934b <kfree>
f01188e7:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f01188ea:	a1 b0 30 69 f0       	mov    0xf06930b0,%eax
f01188ef:	83 ec 0c             	sub    $0xc,%esp
f01188f2:	50                   	push   %eax
f01188f3:	e8 53 0a ff ff       	call   f010934b <kfree>
f01188f8:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f01188fb:	a1 c4 30 69 f0       	mov    0xf06930c4,%eax
f0118900:	83 ec 0c             	sub    $0xc,%esp
f0118903:	50                   	push   %eax
f0118904:	e8 42 0a ff ff       	call   f010934b <kfree>
f0118909:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f011890c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011890f:	83 e8 02             	sub    $0x2,%eax
f0118912:	8b 04 85 60 30 69 f0 	mov    -0xf96cfa0(,%eax,4),%eax
f0118919:	83 ec 0c             	sub    $0xc,%esp
f011891c:	50                   	push   %eax
f011891d:	e8 29 0a ff ff       	call   f010934b <kfree>
f0118922:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0118925:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118928:	83 e8 03             	sub    $0x3,%eax
f011892b:	8b 04 85 60 30 69 f0 	mov    -0xf96cfa0(,%eax,4),%eax
f0118932:	83 ec 0c             	sub    $0xc,%esp
f0118935:	50                   	push   %eax
f0118936:	e8 10 0a ff ff       	call   f010934b <kfree>
f011893b:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011893e:	e8 62 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118943:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118946:	74 17                	je     f011895f <test_fastfirstfit+0x2a1>
f0118948:	83 ec 04             	sub    $0x4,%esp
f011894b:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118950:	68 fc 02 00 00       	push   $0x2fc
f0118955:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011895a:	e8 da 79 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f011895f:	e8 48 58 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118964:	89 c2                	mov    %eax,%edx
f0118966:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118969:	89 d1                	mov    %edx,%ecx
f011896b:	29 c1                	sub    %eax,%ecx
f011896d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118970:	89 d0                	mov    %edx,%eax
f0118972:	c1 e0 02             	shl    $0x2,%eax
f0118975:	01 d0                	add    %edx,%eax
f0118977:	01 c0                	add    %eax,%eax
f0118979:	01 d0                	add    %edx,%eax
f011897b:	c1 e8 0c             	shr    $0xc,%eax
f011897e:	39 c1                	cmp    %eax,%ecx
f0118980:	74 17                	je     f0118999 <test_fastfirstfit+0x2db>
f0118982:	83 ec 04             	sub    $0x4,%esp
f0118985:	68 78 c7 12 f0       	push   $0xf012c778
f011898a:	68 fd 02 00 00       	push   $0x2fd
f011898f:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118994:	e8 a0 79 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f0118999:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011899c:	01 c0                	add    %eax,%eax
f011899e:	89 c2                	mov    %eax,%edx
f01189a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01189a3:	d1 e8                	shr    %eax
f01189a5:	01 d0                	add    %edx,%eax
f01189a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01189aa:	e8 f6 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01189af:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01189b2:	e8 f5 57 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01189b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01189ba:	83 ec 0c             	sub    $0xc,%esp
f01189bd:	ff 75 dc             	pushl  -0x24(%ebp)
f01189c0:	e8 26 07 ff ff       	call   f01090eb <kmalloc>
f01189c5:	83 c4 10             	add    $0x10,%esp
f01189c8:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f01189cb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01189ce:	89 d0                	mov    %edx,%eax
f01189d0:	c1 e0 02             	shl    $0x2,%eax
f01189d3:	01 d0                	add    %edx,%eax
f01189d5:	01 c0                	add    %eax,%eax
f01189d7:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01189dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01189e0:	39 c2                	cmp    %eax,%edx
f01189e2:	74 17                	je     f01189fb <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f01189e4:	83 ec 04             	sub    $0x4,%esp
f01189e7:	68 b8 c7 12 f0       	push   $0xf012c7b8
f01189ec:	68 08 03 00 00       	push   $0x308
f01189f1:	68 a7 c6 12 f0       	push   $0xf012c6a7
f01189f6:	e8 3e 79 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01189fb:	e8 a5 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a00:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a03:	74 17                	je     f0118a1c <test_fastfirstfit+0x35e>
f0118a05:	83 ec 04             	sub    $0x4,%esp
f0118a08:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118a0d:	68 09 03 00 00       	push   $0x309
f0118a12:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118a17:	e8 1d 79 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118a1c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118a1f:	e8 88 57 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118a24:	29 c3                	sub    %eax,%ebx
f0118a26:	89 da                	mov    %ebx,%edx
f0118a28:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118a2b:	c1 e8 0c             	shr    $0xc,%eax
f0118a2e:	39 c2                	cmp    %eax,%edx
f0118a30:	73 17                	jae    f0118a49 <test_fastfirstfit+0x38b>
f0118a32:	83 ec 04             	sub    $0x4,%esp
f0118a35:	68 28 c7 12 f0       	push   $0xf012c728
f0118a3a:	68 0a 03 00 00       	push   $0x30a
f0118a3f:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118a44:	e8 f0 78 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f0118a49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118a4c:	01 c0                	add    %eax,%eax
f0118a4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118a51:	e8 4f be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a56:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118a59:	e8 4e 57 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118a5e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118a61:	83 ec 0c             	sub    $0xc,%esp
f0118a64:	ff 75 dc             	pushl  -0x24(%ebp)
f0118a67:	e8 7f 06 ff ff       	call   f01090eb <kmalloc>
f0118a6c:	83 c4 10             	add    $0x10,%esp
f0118a6f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f0118a72:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118a75:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0118a7a:	01 c0                	add    %eax,%eax
f0118a7c:	89 c2                	mov    %eax,%edx
f0118a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118a81:	39 c2                	cmp    %eax,%edx
f0118a83:	74 17                	je     f0118a9c <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f0118a85:	83 ec 04             	sub    $0x4,%esp
f0118a88:	68 b8 c7 12 f0       	push   $0xf012c7b8
f0118a8d:	68 14 03 00 00       	push   $0x314
f0118a92:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118a97:	e8 9d 78 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118a9c:	e8 04 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118aa1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118aa4:	74 17                	je     f0118abd <test_fastfirstfit+0x3ff>
f0118aa6:	83 ec 04             	sub    $0x4,%esp
f0118aa9:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118aae:	68 15 03 00 00       	push   $0x315
f0118ab3:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118ab8:	e8 7c 78 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118abd:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118ac0:	e8 e7 56 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118ac5:	29 c3                	sub    %eax,%ebx
f0118ac7:	89 da                	mov    %ebx,%edx
f0118ac9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118acc:	c1 e8 0c             	shr    $0xc,%eax
f0118acf:	39 c2                	cmp    %eax,%edx
f0118ad1:	73 17                	jae    f0118aea <test_fastfirstfit+0x42c>
f0118ad3:	83 ec 04             	sub    $0x4,%esp
f0118ad6:	68 28 c7 12 f0       	push   $0xf012c728
f0118adb:	68 16 03 00 00       	push   $0x316
f0118ae0:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118ae5:	e8 4f 78 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f0118aea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118aed:	89 c2                	mov    %eax,%edx
f0118aef:	01 d2                	add    %edx,%edx
f0118af1:	01 d0                	add    %edx,%eax
f0118af3:	d1 e8                	shr    %eax
f0118af5:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118af8:	e8 a8 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118afd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118b00:	e8 a7 56 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118b05:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118b08:	83 ec 0c             	sub    $0xc,%esp
f0118b0b:	ff 75 dc             	pushl  -0x24(%ebp)
f0118b0e:	e8 d8 05 ff ff       	call   f01090eb <kmalloc>
f0118b13:	83 c4 10             	add    $0x10,%esp
f0118b16:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f0118b19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118b1c:	83 e8 03             	sub    $0x3,%eax
f0118b1f:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118b23:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118b29:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0118b2c:	39 c2                	cmp    %eax,%edx
f0118b2e:	74 17                	je     f0118b47 <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f0118b30:	83 ec 04             	sub    $0x4,%esp
f0118b33:	68 b8 c7 12 f0       	push   $0xf012c7b8
f0118b38:	68 20 03 00 00       	push   $0x320
f0118b3d:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118b42:	e8 f2 77 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118b47:	e8 59 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b4c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b4f:	74 17                	je     f0118b68 <test_fastfirstfit+0x4aa>
f0118b51:	83 ec 04             	sub    $0x4,%esp
f0118b54:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118b59:	68 21 03 00 00       	push   $0x321
f0118b5e:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118b63:	e8 d1 77 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118b68:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118b6b:	e8 3c 56 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118b70:	29 c3                	sub    %eax,%ebx
f0118b72:	89 da                	mov    %ebx,%edx
f0118b74:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118b77:	c1 e8 0c             	shr    $0xc,%eax
f0118b7a:	39 c2                	cmp    %eax,%edx
f0118b7c:	73 17                	jae    f0118b95 <test_fastfirstfit+0x4d7>
f0118b7e:	83 ec 04             	sub    $0x4,%esp
f0118b81:	68 28 c7 12 f0       	push   $0xf012c728
f0118b86:	68 22 03 00 00       	push   $0x322
f0118b8b:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118b90:	e8 a4 77 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118b95:	e8 0b bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118b9d:	e8 0a 56 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118ba2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118ba5:	83 ec 0c             	sub    $0xc,%esp
f0118ba8:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118bab:	e8 3b 05 ff ff       	call   f01090eb <kmalloc>
f0118bb0:	83 c4 10             	add    $0x10,%esp
f0118bb3:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f0118bb6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118bb9:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118bbe:	74 17                	je     f0118bd7 <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0118bc0:	83 ec 04             	sub    $0x4,%esp
f0118bc3:	68 b8 c7 12 f0       	push   $0xf012c7b8
f0118bc8:	68 2b 03 00 00       	push   $0x32b
f0118bcd:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118bd2:	e8 62 77 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118bd7:	e8 c9 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118bdc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118bdf:	74 17                	je     f0118bf8 <test_fastfirstfit+0x53a>
f0118be1:	83 ec 04             	sub    $0x4,%esp
f0118be4:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118be9:	68 2c 03 00 00       	push   $0x32c
f0118bee:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118bf3:	e8 41 77 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118bf8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118bfb:	e8 ac 55 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118c00:	29 c3                	sub    %eax,%ebx
f0118c02:	89 da                	mov    %ebx,%edx
f0118c04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118c07:	c1 e8 0c             	shr    $0xc,%eax
f0118c0a:	39 c2                	cmp    %eax,%edx
f0118c0c:	73 17                	jae    f0118c25 <test_fastfirstfit+0x567>
f0118c0e:	83 ec 04             	sub    $0x4,%esp
f0118c11:	68 28 c7 12 f0       	push   $0xf012c728
f0118c16:	68 2d 03 00 00       	push   $0x32d
f0118c1b:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118c20:	e8 14 77 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118c25:	e8 7b bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118c2d:	e8 7a 55 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118c32:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118c35:	83 ec 0c             	sub    $0xc,%esp
f0118c38:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118c3b:	e8 ab 04 ff ff       	call   f01090eb <kmalloc>
f0118c40:	83 c4 10             	add    $0x10,%esp
f0118c43:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0118c46:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118c49:	89 d0                	mov    %edx,%eax
f0118c4b:	c1 e0 02             	shl    $0x2,%eax
f0118c4e:	01 d0                	add    %edx,%eax
f0118c50:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118c56:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118c59:	39 c2                	cmp    %eax,%edx
f0118c5b:	74 17                	je     f0118c74 <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f0118c5d:	83 ec 04             	sub    $0x4,%esp
f0118c60:	68 b8 c7 12 f0       	push   $0xf012c7b8
f0118c65:	68 36 03 00 00       	push   $0x336
f0118c6a:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118c6f:	e8 c5 76 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118c74:	e8 2c bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c79:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c7c:	74 17                	je     f0118c95 <test_fastfirstfit+0x5d7>
f0118c7e:	83 ec 04             	sub    $0x4,%esp
f0118c81:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118c86:	68 37 03 00 00       	push   $0x337
f0118c8b:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118c90:	e8 a4 76 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118c95:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118c98:	e8 0f 55 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118c9d:	29 c3                	sub    %eax,%ebx
f0118c9f:	89 da                	mov    %ebx,%edx
f0118ca1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118ca4:	c1 e8 0c             	shr    $0xc,%eax
f0118ca7:	39 c2                	cmp    %eax,%edx
f0118ca9:	73 17                	jae    f0118cc2 <test_fastfirstfit+0x604>
f0118cab:	83 ec 04             	sub    $0x4,%esp
f0118cae:	68 28 c7 12 f0       	push   $0xf012c728
f0118cb3:	68 38 03 00 00       	push   $0x338
f0118cb8:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118cbd:	e8 77 76 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118cc2:	e8 de bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118cc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118cca:	e8 dd 54 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118ccf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118cd2:	83 ec 0c             	sub    $0xc,%esp
f0118cd5:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118cd8:	e8 0e 04 ff ff       	call   f01090eb <kmalloc>
f0118cdd:	83 c4 10             	add    $0x10,%esp
f0118ce0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f0118ce3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118ce6:	89 d0                	mov    %edx,%eax
f0118ce8:	c1 e0 02             	shl    $0x2,%eax
f0118ceb:	01 d0                	add    %edx,%eax
f0118ced:	c1 e0 02             	shl    $0x2,%eax
f0118cf0:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118cf6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118cf9:	39 c2                	cmp    %eax,%edx
f0118cfb:	74 17                	je     f0118d14 <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f0118cfd:	83 ec 04             	sub    $0x4,%esp
f0118d00:	68 b8 c7 12 f0       	push   $0xf012c7b8
f0118d05:	68 41 03 00 00       	push   $0x341
f0118d0a:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118d0f:	e8 25 76 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118d14:	e8 8c bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d19:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d1c:	74 17                	je     f0118d35 <test_fastfirstfit+0x677>
f0118d1e:	83 ec 04             	sub    $0x4,%esp
f0118d21:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118d26:	68 42 03 00 00       	push   $0x342
f0118d2b:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118d30:	e8 04 76 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118d35:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118d38:	e8 6f 54 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118d3d:	29 c3                	sub    %eax,%ebx
f0118d3f:	89 da                	mov    %ebx,%edx
f0118d41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118d44:	c1 e8 0c             	shr    $0xc,%eax
f0118d47:	39 c2                	cmp    %eax,%edx
f0118d49:	73 17                	jae    f0118d62 <test_fastfirstfit+0x6a4>
f0118d4b:	83 ec 04             	sub    $0x4,%esp
f0118d4e:	68 28 c7 12 f0       	push   $0xf012c728
f0118d53:	68 43 03 00 00       	push   $0x343
f0118d58:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118d5d:	e8 d7 75 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118d62:	e8 3e bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d67:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118d6a:	e8 3d 54 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118d6f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118d72:	83 ec 0c             	sub    $0xc,%esp
f0118d75:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118d78:	e8 6e 03 ff ff       	call   f01090eb <kmalloc>
f0118d7d:	83 c4 10             	add    $0x10,%esp
f0118d80:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f0118d83:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118d86:	89 d0                	mov    %edx,%eax
f0118d88:	c1 e0 02             	shl    $0x2,%eax
f0118d8b:	01 d0                	add    %edx,%eax
f0118d8d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118d94:	01 d0                	add    %edx,%eax
f0118d96:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118d9c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118d9f:	39 c2                	cmp    %eax,%edx
f0118da1:	74 17                	je     f0118dba <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f0118da3:	83 ec 04             	sub    $0x4,%esp
f0118da6:	68 b8 c7 12 f0       	push   $0xf012c7b8
f0118dab:	68 4c 03 00 00       	push   $0x34c
f0118db0:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118db5:	e8 7f 75 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118dba:	e8 e6 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118dbf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118dc2:	74 17                	je     f0118ddb <test_fastfirstfit+0x71d>
f0118dc4:	83 ec 04             	sub    $0x4,%esp
f0118dc7:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118dcc:	68 4d 03 00 00       	push   $0x34d
f0118dd1:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118dd6:	e8 5e 75 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118ddb:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118dde:	e8 c9 53 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118de3:	29 c3                	sub    %eax,%ebx
f0118de5:	89 da                	mov    %ebx,%edx
f0118de7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118dea:	c1 e8 0c             	shr    $0xc,%eax
f0118ded:	39 c2                	cmp    %eax,%edx
f0118def:	73 17                	jae    f0118e08 <test_fastfirstfit+0x74a>
f0118df1:	83 ec 04             	sub    $0x4,%esp
f0118df4:	68 28 c7 12 f0       	push   $0xf012c728
f0118df9:	68 4e 03 00 00       	push   $0x34e
f0118dfe:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118e03:	e8 31 75 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0118e08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118e0b:	d1 e8                	shr    %eax
f0118e0d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118e10:	e8 90 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118e15:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118e18:	e8 8f 53 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118e1d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118e20:	83 ec 0c             	sub    $0xc,%esp
f0118e23:	ff 75 dc             	pushl  -0x24(%ebp)
f0118e26:	e8 c0 02 ff ff       	call   f01090eb <kmalloc>
f0118e2b:	83 c4 10             	add    $0x10,%esp
f0118e2e:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f0118e31:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118e34:	89 d0                	mov    %edx,%eax
f0118e36:	c1 e0 02             	shl    $0x2,%eax
f0118e39:	01 d0                	add    %edx,%eax
f0118e3b:	01 c0                	add    %eax,%eax
f0118e3d:	89 c1                	mov    %eax,%ecx
f0118e3f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118e42:	89 d0                	mov    %edx,%eax
f0118e44:	c1 e0 02             	shl    $0x2,%eax
f0118e47:	01 d0                	add    %edx,%eax
f0118e49:	d1 e8                	shr    %eax
f0118e4b:	01 c8                	add    %ecx,%eax
f0118e4d:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118e53:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118e56:	39 c2                	cmp    %eax,%edx
f0118e58:	74 17                	je     f0118e71 <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f0118e5a:	83 ec 04             	sub    $0x4,%esp
f0118e5d:	68 b8 c7 12 f0       	push   $0xf012c7b8
f0118e62:	68 58 03 00 00       	push   $0x358
f0118e67:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118e6c:	e8 c8 74 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118e71:	e8 2f ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118e76:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e79:	74 17                	je     f0118e92 <test_fastfirstfit+0x7d4>
f0118e7b:	83 ec 04             	sub    $0x4,%esp
f0118e7e:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118e83:	68 59 03 00 00       	push   $0x359
f0118e88:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118e8d:	e8 a7 74 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118e92:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118e95:	e8 12 53 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118e9a:	29 c3                	sub    %eax,%ebx
f0118e9c:	89 da                	mov    %ebx,%edx
f0118e9e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118ea1:	c1 e8 0c             	shr    $0xc,%eax
f0118ea4:	39 c2                	cmp    %eax,%edx
f0118ea6:	73 17                	jae    f0118ebf <test_fastfirstfit+0x801>
f0118ea8:	83 ec 04             	sub    $0x4,%esp
f0118eab:	68 28 c7 12 f0       	push   $0xf012c728
f0118eb0:	68 5a 03 00 00       	push   $0x35a
f0118eb5:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118eba:	e8 7a 74 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0118ebf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118ec2:	d1 e8                	shr    %eax
f0118ec4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118ec7:	e8 d9 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118ecc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118ecf:	e8 d8 52 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118ed4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118ed7:	83 ec 0c             	sub    $0xc,%esp
f0118eda:	ff 75 dc             	pushl  -0x24(%ebp)
f0118edd:	e8 09 02 ff ff       	call   f01090eb <kmalloc>
f0118ee2:	83 c4 10             	add    $0x10,%esp
f0118ee5:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f0118ee8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118eeb:	83 e8 03             	sub    $0x3,%eax
f0118eee:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118ef2:	89 c2                	mov    %eax,%edx
f0118ef4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118ef7:	89 c1                	mov    %eax,%ecx
f0118ef9:	01 c9                	add    %ecx,%ecx
f0118efb:	01 c8                	add    %ecx,%eax
f0118efd:	d1 e8                	shr    %eax
f0118eff:	01 d0                	add    %edx,%eax
f0118f01:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118f07:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118f0a:	39 c2                	cmp    %eax,%edx
f0118f0c:	74 17                	je     f0118f25 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f0118f0e:	83 ec 04             	sub    $0x4,%esp
f0118f11:	68 b8 c7 12 f0       	push   $0xf012c7b8
f0118f16:	68 64 03 00 00       	push   $0x364
f0118f1b:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118f20:	e8 14 74 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118f25:	e8 7b b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118f2a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f2d:	74 17                	je     f0118f46 <test_fastfirstfit+0x888>
f0118f2f:	83 ec 04             	sub    $0x4,%esp
f0118f32:	68 c0 c6 12 f0       	push   $0xf012c6c0
f0118f37:	68 65 03 00 00       	push   $0x365
f0118f3c:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118f41:	e8 f3 73 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118f46:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118f49:	e8 5e 52 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118f4e:	29 c3                	sub    %eax,%ebx
f0118f50:	89 da                	mov    %ebx,%edx
f0118f52:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118f55:	c1 e8 0c             	shr    $0xc,%eax
f0118f58:	39 c2                	cmp    %eax,%edx
f0118f5a:	73 17                	jae    f0118f73 <test_fastfirstfit+0x8b5>
f0118f5c:	83 ec 04             	sub    $0x4,%esp
f0118f5f:	68 28 c7 12 f0       	push   $0xf012c728
f0118f64:	68 66 03 00 00       	push   $0x366
f0118f69:	68 a7 c6 12 f0       	push   $0xf012c6a7
f0118f6e:	e8 c6 73 fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f0118f73:	83 ec 0c             	sub    $0xc,%esp
f0118f76:	68 d8 c7 12 f0       	push   $0xf012c7d8
f0118f7b:	e8 0b 80 fe ff       	call   f0100f8b <cprintf>
f0118f80:	83 c4 10             	add    $0x10,%esp
	return 1;
f0118f83:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0118f88:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0118f8b:	c9                   	leave  
f0118f8c:	c3                   	ret    

f0118f8d <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f0118f8d:	55                   	push   %ebp
f0118f8e:	89 e5                	mov    %esp,%ebp
f0118f90:	57                   	push   %edi
f0118f91:	53                   	push   %ebx
f0118f92:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118f98:	83 ec 0c             	sub    $0xc,%esp
f0118f9b:	68 48 a7 12 f0       	push   $0xf012a748
f0118fa0:	e8 e6 7f fe ff       	call   f0100f8b <cprintf>
f0118fa5:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118fa8:	83 ec 0c             	sub    $0xc,%esp
f0118fab:	68 78 a7 12 f0       	push   $0xf012a778
f0118fb0:	e8 d6 7f fe ff       	call   f0100f8b <cprintf>
f0118fb5:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118fb8:	83 ec 0c             	sub    $0xc,%esp
f0118fbb:	68 48 a7 12 f0       	push   $0xf012a748
f0118fc0:	e8 c6 7f fe ff       	call   f0100f8b <cprintf>
f0118fc5:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0118fc8:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f0118fcc:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f0118fd0:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f0118fd6:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f0118fdc:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0118fe3:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f0118fea:	e8 bd 51 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0118fef:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0118ff2:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f0118ff8:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118ffd:	b8 00 00 00 00       	mov    $0x0,%eax
f0119002:	89 d7                	mov    %edx,%edi
f0119004:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f0119006:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f011900c:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119011:	b8 00 00 00 00       	mov    $0x0,%eax
f0119016:	89 d7                	mov    %edx,%edi
f0119018:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011901a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f0119021:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f0119028:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011902f:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f0119035:	b9 14 00 00 00       	mov    $0x14,%ecx
f011903a:	b8 00 00 00 00       	mov    $0x0,%eax
f011903f:	89 d7                	mov    %edx,%edi
f0119041:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f0119043:	83 ec 0c             	sub    $0xc,%esp
f0119046:	68 1c c8 12 f0       	push   $0xf012c81c
f011904b:	e8 3b 7f fe ff       	call   f0100f8b <cprintf>
f0119050:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119053:	e8 54 51 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119058:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011905b:	e8 45 b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119060:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119063:	83 ec 0c             	sub    $0xc,%esp
f0119066:	68 00 fc 1f 00       	push   $0x1ffc00
f011906b:	e8 7b 00 ff ff       	call   f01090eb <kmalloc>
f0119070:	83 c4 10             	add    $0x10,%esp
f0119073:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119079:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011907f:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119084:	74 17                	je     f011909d <test_kfree_bestfirstfit+0x110>
f0119086:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011908d:	83 ec 0c             	sub    $0xc,%esp
f0119090:	68 54 c8 12 f0       	push   $0xf012c854
f0119095:	e8 f1 7e fe ff       	call   f0100f8b <cprintf>
f011909a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011909d:	e8 03 b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01190a2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01190a5:	74 17                	je     f01190be <test_kfree_bestfirstfit+0x131>
f01190a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01190ae:	83 ec 0c             	sub    $0xc,%esp
f01190b1:	68 a8 c8 12 f0       	push   $0xf012c8a8
f01190b6:	e8 d0 7e fe ff       	call   f0100f8b <cprintf>
f01190bb:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01190be:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01190c1:	e8 e6 50 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01190c6:	29 c3                	sub    %eax,%ebx
f01190c8:	89 d8                	mov    %ebx,%eax
f01190ca:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01190cf:	77 17                	ja     f01190e8 <test_kfree_bestfirstfit+0x15b>
f01190d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01190d8:	83 ec 0c             	sub    $0xc,%esp
f01190db:	68 18 c9 12 f0       	push   $0xf012c918
f01190e0:	e8 a6 7e fe ff       	call   f0100f8b <cprintf>
f01190e5:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f01190e8:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f01190ef:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f01190f2:	e8 b5 50 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01190f7:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01190fa:	e8 a6 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01190ff:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0119102:	83 ec 0c             	sub    $0xc,%esp
f0119105:	68 00 fc 1f 00       	push   $0x1ffc00
f011910a:	e8 dc ff fe ff       	call   f01090eb <kmalloc>
f011910f:	83 c4 10             	add    $0x10,%esp
f0119112:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119118:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011911e:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119123:	74 17                	je     f011913c <test_kfree_bestfirstfit+0x1af>
f0119125:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011912c:	83 ec 0c             	sub    $0xc,%esp
f011912f:	68 60 c9 12 f0       	push   $0xf012c960
f0119134:	e8 52 7e fe ff       	call   f0100f8b <cprintf>
f0119139:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011913c:	e8 64 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119141:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119144:	74 17                	je     f011915d <test_kfree_bestfirstfit+0x1d0>
f0119146:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011914d:	83 ec 0c             	sub    $0xc,%esp
f0119150:	68 b4 c9 12 f0       	push   $0xf012c9b4
f0119155:	e8 31 7e fe ff       	call   f0100f8b <cprintf>
f011915a:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011915d:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119160:	e8 47 50 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119165:	29 c3                	sub    %eax,%ebx
f0119167:	89 d8                	mov    %ebx,%eax
f0119169:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011916e:	77 17                	ja     f0119187 <test_kfree_bestfirstfit+0x1fa>
f0119170:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119177:	83 ec 0c             	sub    $0xc,%esp
f011917a:	68 24 ca 12 f0       	push   $0xf012ca24
f011917f:	e8 07 7e fe ff       	call   f0100f8b <cprintf>
f0119184:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f0119187:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f011918e:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f0119191:	e8 16 50 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119196:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119199:	e8 07 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011919e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f01191a1:	83 ec 0c             	sub    $0xc,%esp
f01191a4:	68 00 1c 00 00       	push   $0x1c00
f01191a9:	e8 3d ff fe ff       	call   f01090eb <kmalloc>
f01191ae:	83 c4 10             	add    $0x10,%esp
f01191b1:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01191b7:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01191bd:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01191c2:	74 17                	je     f01191db <test_kfree_bestfirstfit+0x24e>
f01191c4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01191cb:	83 ec 0c             	sub    $0xc,%esp
f01191ce:	68 6c ca 12 f0       	push   $0xf012ca6c
f01191d3:	e8 b3 7d fe ff       	call   f0100f8b <cprintf>
f01191d8:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01191db:	e8 c5 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01191e0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01191e3:	74 17                	je     f01191fc <test_kfree_bestfirstfit+0x26f>
f01191e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01191ec:	83 ec 0c             	sub    $0xc,%esp
f01191ef:	68 c0 ca 12 f0       	push   $0xf012cac0
f01191f4:	e8 92 7d fe ff       	call   f0100f8b <cprintf>
f01191f9:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01191fc:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01191ff:	e8 a8 4f ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119204:	29 c3                	sub    %eax,%ebx
f0119206:	89 d8                	mov    %ebx,%eax
f0119208:	83 f8 01             	cmp    $0x1,%eax
f011920b:	77 17                	ja     f0119224 <test_kfree_bestfirstfit+0x297>
f011920d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119214:	83 ec 0c             	sub    $0xc,%esp
f0119217:	68 30 cb 12 f0       	push   $0xf012cb30
f011921c:	e8 6a 7d fe ff       	call   f0100f8b <cprintf>
f0119221:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f0119224:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f011922b:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f011922e:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119234:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f0119237:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011923e:	eb 0e                	jmp    f011924e <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f0119240:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119243:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119246:	01 d0                	add    %edx,%eax
f0119248:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f011924b:	ff 45 f4             	incl   -0xc(%ebp)
f011924e:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119254:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119257:	7f e7                	jg     f0119240 <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0119259:	e8 4e 4f ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011925e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119261:	e8 3f b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119266:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0119269:	83 ec 0c             	sub    $0xc,%esp
f011926c:	68 00 fc 2f 00       	push   $0x2ffc00
f0119271:	e8 75 fe fe ff       	call   f01090eb <kmalloc>
f0119276:	83 c4 10             	add    $0x10,%esp
f0119279:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011927f:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119285:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011928a:	74 17                	je     f01192a3 <test_kfree_bestfirstfit+0x316>
f011928c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119293:	83 ec 0c             	sub    $0xc,%esp
f0119296:	68 78 cb 12 f0       	push   $0xf012cb78
f011929b:	e8 eb 7c fe ff       	call   f0100f8b <cprintf>
f01192a0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01192a3:	e8 fd b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01192a8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01192ab:	74 17                	je     f01192c4 <test_kfree_bestfirstfit+0x337>
f01192ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192b4:	83 ec 0c             	sub    $0xc,%esp
f01192b7:	68 cc cb 12 f0       	push   $0xf012cbcc
f01192bc:	e8 ca 7c fe ff       	call   f0100f8b <cprintf>
f01192c1:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01192c4:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01192c7:	e8 e0 4e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01192cc:	29 c3                	sub    %eax,%ebx
f01192ce:	89 d8                	mov    %ebx,%eax
f01192d0:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01192d5:	77 17                	ja     f01192ee <test_kfree_bestfirstfit+0x361>
f01192d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192de:	83 ec 0c             	sub    $0xc,%esp
f01192e1:	68 3c cc 12 f0       	push   $0xf012cc3c
f01192e6:	e8 a0 7c fe ff       	call   f0100f8b <cprintf>
f01192eb:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f01192ee:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f01192f5:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f01192f8:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01192fe:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f0119301:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119308:	eb 0e                	jmp    f0119318 <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f011930a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011930d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119310:	01 d0                	add    %edx,%eax
f0119312:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119315:	ff 45 f4             	incl   -0xc(%ebp)
f0119318:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011931e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119321:	7f e7                	jg     f011930a <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0119323:	e8 84 4e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119328:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011932b:	e8 75 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119330:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0119333:	83 ec 0c             	sub    $0xc,%esp
f0119336:	68 00 fc 5f 00       	push   $0x5ffc00
f011933b:	e8 ab fd fe ff       	call   f01090eb <kmalloc>
f0119340:	83 c4 10             	add    $0x10,%esp
f0119343:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119349:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011934f:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119354:	74 17                	je     f011936d <test_kfree_bestfirstfit+0x3e0>
f0119356:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011935d:	83 ec 0c             	sub    $0xc,%esp
f0119360:	68 84 cc 12 f0       	push   $0xf012cc84
f0119365:	e8 21 7c fe ff       	call   f0100f8b <cprintf>
f011936a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011936d:	e8 33 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119372:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119375:	74 17                	je     f011938e <test_kfree_bestfirstfit+0x401>
f0119377:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011937e:	83 ec 0c             	sub    $0xc,%esp
f0119381:	68 d8 cc 12 f0       	push   $0xf012ccd8
f0119386:	e8 00 7c fe ff       	call   f0100f8b <cprintf>
f011938b:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011938e:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119391:	e8 16 4e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119396:	29 c3                	sub    %eax,%ebx
f0119398:	89 d8                	mov    %ebx,%eax
f011939a:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011939f:	77 17                	ja     f01193b8 <test_kfree_bestfirstfit+0x42b>
f01193a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193a8:	83 ec 0c             	sub    $0xc,%esp
f01193ab:	68 48 cd 12 f0       	push   $0xf012cd48
f01193b0:	e8 d6 7b fe ff       	call   f0100f8b <cprintf>
f01193b5:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f01193b8:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f01193bf:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f01193c2:	e8 e5 4d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01193c7:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01193ca:	e8 d6 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01193cf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f01193d2:	83 ec 0c             	sub    $0xc,%esp
f01193d5:	68 00 38 00 00       	push   $0x3800
f01193da:	e8 0c fd fe ff       	call   f01090eb <kmalloc>
f01193df:	83 c4 10             	add    $0x10,%esp
f01193e2:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01193e8:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f01193ee:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f01193f3:	74 17                	je     f011940c <test_kfree_bestfirstfit+0x47f>
f01193f5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193fc:	83 ec 0c             	sub    $0xc,%esp
f01193ff:	68 90 cd 12 f0       	push   $0xf012cd90
f0119404:	e8 82 7b fe ff       	call   f0100f8b <cprintf>
f0119409:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011940c:	e8 94 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119411:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119414:	74 17                	je     f011942d <test_kfree_bestfirstfit+0x4a0>
f0119416:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011941d:	83 ec 0c             	sub    $0xc,%esp
f0119420:	68 e4 cd 12 f0       	push   $0xf012cde4
f0119425:	e8 61 7b fe ff       	call   f0100f8b <cprintf>
f011942a:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011942d:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119430:	e8 77 4d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119435:	29 c3                	sub    %eax,%ebx
f0119437:	89 d8                	mov    %ebx,%eax
f0119439:	83 f8 03             	cmp    $0x3,%eax
f011943c:	77 17                	ja     f0119455 <test_kfree_bestfirstfit+0x4c8>
f011943e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119445:	83 ec 0c             	sub    $0xc,%esp
f0119448:	68 54 ce 12 f0       	push   $0xf012ce54
f011944d:	e8 39 7b fe ff       	call   f0100f8b <cprintf>
f0119452:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119455:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f011945c:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119462:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119465:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011946c:	eb 0e                	jmp    f011947c <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f011946e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119471:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119474:	01 d0                	add    %edx,%eax
f0119476:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0119479:	ff 45 f4             	incl   -0xc(%ebp)
f011947c:	8b 45 80             	mov    -0x80(%ebp),%eax
f011947f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119482:	7f ea                	jg     f011946e <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0119484:	e8 23 4d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119489:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f011948c:	e8 14 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119491:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0119494:	83 ec 0c             	sub    $0xc,%esp
f0119497:	68 00 08 00 00       	push   $0x800
f011949c:	e8 4a fc fe ff       	call   f01090eb <kmalloc>
f01194a1:	83 c4 10             	add    $0x10,%esp
f01194a4:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01194aa:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01194b0:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01194b5:	76 28                	jbe    f01194df <test_kfree_bestfirstfit+0x552>
f01194b7:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f01194bd:	83 ec 0c             	sub    $0xc,%esp
f01194c0:	6a 00                	push   $0x0
f01194c2:	e8 f1 fa fe ff       	call   f0108fb8 <sbrk>
f01194c7:	83 c4 10             	add    $0x10,%esp
f01194ca:	39 c3                	cmp    %eax,%ebx
f01194cc:	73 11                	jae    f01194df <test_kfree_bestfirstfit+0x552>
f01194ce:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01194d4:	89 c2                	mov    %eax,%edx
f01194d6:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f01194db:	39 c2                	cmp    %eax,%edx
f01194dd:	72 17                	jb     f01194f6 <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01194df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194e6:	83 ec 0c             	sub    $0xc,%esp
f01194e9:	68 9c ce 12 f0       	push   $0xf012ce9c
f01194ee:	e8 98 7a fe ff       	call   f0100f8b <cprintf>
f01194f3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01194f6:	e8 aa b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01194fb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01194fe:	74 17                	je     f0119517 <test_kfree_bestfirstfit+0x58a>
f0119500:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119507:	83 ec 0c             	sub    $0xc,%esp
f011950a:	68 28 cf 12 f0       	push   $0xf012cf28
f011950f:	e8 77 7a fe ff       	call   f0100f8b <cprintf>
f0119514:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0119517:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f011951e:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0119521:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119527:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f011952a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119531:	eb 0e                	jmp    f0119541 <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0119533:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119536:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119539:	01 d0                	add    %edx,%eax
f011953b:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f011953e:	ff 45 f4             	incl   -0xc(%ebp)
f0119541:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0119547:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011954a:	7f e7                	jg     f0119533 <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f011954c:	e8 54 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119551:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119554:	83 ec 0c             	sub    $0xc,%esp
f0119557:	68 00 08 00 00       	push   $0x800
f011955c:	e8 8a fb fe ff       	call   f01090eb <kmalloc>
f0119561:	83 c4 10             	add    $0x10,%esp
f0119564:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011956a:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119570:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119575:	76 28                	jbe    f011959f <test_kfree_bestfirstfit+0x612>
f0119577:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f011957d:	83 ec 0c             	sub    $0xc,%esp
f0119580:	6a 00                	push   $0x0
f0119582:	e8 31 fa fe ff       	call   f0108fb8 <sbrk>
f0119587:	83 c4 10             	add    $0x10,%esp
f011958a:	39 c3                	cmp    %eax,%ebx
f011958c:	73 11                	jae    f011959f <test_kfree_bestfirstfit+0x612>
f011958e:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119594:	89 c2                	mov    %eax,%edx
f0119596:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011959b:	39 c2                	cmp    %eax,%edx
f011959d:	72 17                	jb     f01195b6 <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011959f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01195a6:	83 ec 0c             	sub    $0xc,%esp
f01195a9:	68 98 cf 12 f0       	push   $0xf012cf98
f01195ae:	e8 d8 79 fe ff       	call   f0100f8b <cprintf>
f01195b3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01195b6:	e8 ea b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01195bb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01195be:	74 17                	je     f01195d7 <test_kfree_bestfirstfit+0x64a>
f01195c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01195c7:	83 ec 0c             	sub    $0xc,%esp
f01195ca:	68 24 d0 12 f0       	push   $0xf012d024
f01195cf:	e8 b7 79 fe ff       	call   f0100f8b <cprintf>
f01195d4:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f01195d7:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f01195de:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f01195e1:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f01195e7:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f01195ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01195f1:	eb 0e                	jmp    f0119601 <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f01195f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01195f6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01195f9:	01 d0                	add    %edx,%eax
f01195fb:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f01195fe:	ff 45 f4             	incl   -0xc(%ebp)
f0119601:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119607:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011960a:	7f e7                	jg     f01195f3 <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f011960c:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011960f:	e8 98 4b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119614:	29 c3                	sub    %eax,%ebx
f0119616:	89 d8                	mov    %ebx,%eax
f0119618:	83 f8 01             	cmp    $0x1,%eax
f011961b:	74 17                	je     f0119634 <test_kfree_bestfirstfit+0x6a7>
f011961d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119624:	83 ec 0c             	sub    $0xc,%esp
f0119627:	68 94 d0 12 f0       	push   $0xf012d094
f011962c:	e8 5a 79 fe ff       	call   f0100f8b <cprintf>
f0119631:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f0119634:	83 ec 0c             	sub    $0xc,%esp
f0119637:	68 b8 d0 12 f0       	push   $0xf012d0b8
f011963c:	e8 4a 79 fe ff       	call   f0100f8b <cprintf>
f0119641:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f0119644:	e8 63 4b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119649:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011964c:	e8 54 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119651:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f0119654:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011965a:	83 ec 0c             	sub    $0xc,%esp
f011965d:	50                   	push   %eax
f011965e:	e8 e8 fc fe ff       	call   f010934b <kfree>
f0119663:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119666:	e8 3a b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011966b:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011966e:	74 17                	je     f0119687 <test_kfree_bestfirstfit+0x6fa>
f0119670:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119677:	83 ec 0c             	sub    $0xc,%esp
f011967a:	68 e8 d0 12 f0       	push   $0xf012d0e8
f011967f:	e8 07 79 fe ff       	call   f0100f8b <cprintf>
f0119684:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119687:	e8 20 4b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011968c:	89 c2                	mov    %eax,%edx
f011968e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119691:	29 c2                	sub    %eax,%edx
f0119693:	89 d0                	mov    %edx,%eax
f0119695:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011969a:	77 17                	ja     f01196b3 <test_kfree_bestfirstfit+0x726>
f011969c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01196a3:	83 ec 0c             	sub    $0xc,%esp
f01196a6:	68 58 d1 12 f0       	push   $0xf012d158
f01196ab:	e8 db 78 fe ff       	call   f0100f8b <cprintf>
f01196b0:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f01196b3:	e8 f4 4a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01196b8:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01196bb:	e8 e5 b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01196c0:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f01196c3:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01196c9:	83 ec 0c             	sub    $0xc,%esp
f01196cc:	50                   	push   %eax
f01196cd:	e8 79 fc fe ff       	call   f010934b <kfree>
f01196d2:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01196d5:	e8 cb b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01196da:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01196dd:	74 17                	je     f01196f6 <test_kfree_bestfirstfit+0x769>
f01196df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01196e6:	83 ec 0c             	sub    $0xc,%esp
f01196e9:	68 94 d1 12 f0       	push   $0xf012d194
f01196ee:	e8 98 78 fe ff       	call   f0100f8b <cprintf>
f01196f3:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f01196f6:	e8 b1 4a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01196fb:	89 c2                	mov    %eax,%edx
f01196fd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119700:	39 c2                	cmp    %eax,%edx
f0119702:	74 17                	je     f011971b <test_kfree_bestfirstfit+0x78e>
f0119704:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011970b:	83 ec 0c             	sub    $0xc,%esp
f011970e:	68 04 d2 12 f0       	push   $0xf012d204
f0119713:	e8 73 78 fe ff       	call   f0100f8b <cprintf>
f0119718:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011971b:	e8 8c 4a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119720:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119723:	e8 7d b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119728:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f011972b:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119731:	83 ec 0c             	sub    $0xc,%esp
f0119734:	50                   	push   %eax
f0119735:	e8 11 fc fe ff       	call   f010934b <kfree>
f011973a:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011973d:	e8 63 b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119742:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119745:	74 17                	je     f011975e <test_kfree_bestfirstfit+0x7d1>
f0119747:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011974e:	83 ec 0c             	sub    $0xc,%esp
f0119751:	68 64 d2 12 f0       	push   $0xf012d264
f0119756:	e8 30 78 fe ff       	call   f0100f8b <cprintf>
f011975b:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011975e:	e8 49 4a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119763:	89 c2                	mov    %eax,%edx
f0119765:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119768:	29 c2                	sub    %eax,%edx
f011976a:	89 d0                	mov    %edx,%eax
f011976c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119771:	77 17                	ja     f011978a <test_kfree_bestfirstfit+0x7fd>
f0119773:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011977a:	83 ec 0c             	sub    $0xc,%esp
f011977d:	68 d4 d2 12 f0       	push   $0xf012d2d4
f0119782:	e8 04 78 fe ff       	call   f0100f8b <cprintf>
f0119787:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011978a:	e8 1d 4a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011978f:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119792:	e8 0e b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119797:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f011979a:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f01197a0:	83 ec 0c             	sub    $0xc,%esp
f01197a3:	50                   	push   %eax
f01197a4:	e8 a2 fb fe ff       	call   f010934b <kfree>
f01197a9:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01197ac:	e8 f4 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01197b1:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01197b4:	74 17                	je     f01197cd <test_kfree_bestfirstfit+0x840>
f01197b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197bd:	83 ec 0c             	sub    $0xc,%esp
f01197c0:	68 10 d3 12 f0       	push   $0xf012d310
f01197c5:	e8 c1 77 fe ff       	call   f0100f8b <cprintf>
f01197ca:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f01197cd:	e8 da 49 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01197d2:	89 c2                	mov    %eax,%edx
f01197d4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01197d7:	29 c2                	sub    %eax,%edx
f01197d9:	89 d0                	mov    %edx,%eax
f01197db:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f01197e0:	77 17                	ja     f01197f9 <test_kfree_bestfirstfit+0x86c>
f01197e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197e9:	83 ec 0c             	sub    $0xc,%esp
f01197ec:	68 80 d3 12 f0       	push   $0xf012d380
f01197f1:	e8 95 77 fe ff       	call   f0100f8b <cprintf>
f01197f6:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01197f9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01197fd:	74 04                	je     f0119803 <test_kfree_bestfirstfit+0x876>
f01197ff:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0119803:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f011980a:	83 ec 0c             	sub    $0xc,%esp
f011980d:	68 bc d3 12 f0       	push   $0xf012d3bc
f0119812:	e8 74 77 fe ff       	call   f0100f8b <cprintf>
f0119817:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011981a:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119820:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f0119823:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011982a:	eb 1e                	jmp    f011984a <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f011982c:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0119832:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119835:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119838:	01 c8                	add    %ecx,%eax
f011983a:	8a 00                	mov    (%eax),%al
f011983c:	0f be c0             	movsbl %al,%eax
f011983f:	01 d0                	add    %edx,%eax
f0119841:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f0119847:	ff 45 f4             	incl   -0xc(%ebp)
f011984a:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119850:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119853:	7f d7                	jg     f011982c <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f0119855:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011985b:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119861:	89 c1                	mov    %eax,%ecx
f0119863:	01 c9                	add    %ecx,%ecx
f0119865:	01 c8                	add    %ecx,%eax
f0119867:	39 c2                	cmp    %eax,%edx
f0119869:	74 17                	je     f0119882 <test_kfree_bestfirstfit+0x8f5>
f011986b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119872:	83 ec 0c             	sub    $0xc,%esp
f0119875:	68 04 d4 12 f0       	push   $0xf012d404
f011987a:	e8 0c 77 fe ff       	call   f0100f8b <cprintf>
f011987f:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f0119882:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119888:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011988b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119892:	eb 1e                	jmp    f01198b2 <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f0119894:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011989a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011989d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01198a0:	01 c8                	add    %ecx,%eax
f01198a2:	8a 00                	mov    (%eax),%al
f01198a4:	0f be c0             	movsbl %al,%eax
f01198a7:	01 d0                	add    %edx,%eax
f01198a9:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f01198af:	ff 45 f4             	incl   -0xc(%ebp)
f01198b2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01198b8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01198bb:	7f d7                	jg     f0119894 <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f01198bd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01198c3:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f01198c9:	c1 e2 02             	shl    $0x2,%edx
f01198cc:	39 d0                	cmp    %edx,%eax
f01198ce:	74 17                	je     f01198e7 <test_kfree_bestfirstfit+0x95a>
f01198d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198d7:	83 ec 0c             	sub    $0xc,%esp
f01198da:	68 3c d4 12 f0       	push   $0xf012d43c
f01198df:	e8 a7 76 fe ff       	call   f0100f8b <cprintf>
f01198e4:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f01198e7:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01198ed:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f01198f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01198f7:	eb 1e                	jmp    f0119917 <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f01198f9:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f01198ff:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119902:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119905:	01 c8                	add    %ecx,%eax
f0119907:	8a 00                	mov    (%eax),%al
f0119909:	0f be c0             	movsbl %al,%eax
f011990c:	01 d0                	add    %edx,%eax
f011990e:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f0119914:	ff 45 f4             	incl   -0xc(%ebp)
f0119917:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011991d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119920:	7f d7                	jg     f01198f9 <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f0119922:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f0119928:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011992e:	89 d0                	mov    %edx,%eax
f0119930:	c1 e0 02             	shl    $0x2,%eax
f0119933:	01 d0                	add    %edx,%eax
f0119935:	39 c1                	cmp    %eax,%ecx
f0119937:	74 17                	je     f0119950 <test_kfree_bestfirstfit+0x9c3>
f0119939:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119940:	83 ec 0c             	sub    $0xc,%esp
f0119943:	68 74 d4 12 f0       	push   $0xf012d474
f0119948:	e8 3e 76 fe ff       	call   f0100f8b <cprintf>
f011994d:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f0119950:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119956:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f0119959:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119960:	eb 1e                	jmp    f0119980 <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f0119962:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f0119968:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011996b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011996e:	01 c8                	add    %ecx,%eax
f0119970:	8a 00                	mov    (%eax),%al
f0119972:	0f be c0             	movsbl %al,%eax
f0119975:	01 d0                	add    %edx,%eax
f0119977:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011997d:	ff 45 f4             	incl   -0xc(%ebp)
f0119980:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119983:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119986:	7f da                	jg     f0119962 <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f0119988:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f011998e:	8b 55 80             	mov    -0x80(%ebp),%edx
f0119991:	89 d0                	mov    %edx,%eax
f0119993:	01 c0                	add    %eax,%eax
f0119995:	01 d0                	add    %edx,%eax
f0119997:	01 c0                	add    %eax,%eax
f0119999:	01 d0                	add    %edx,%eax
f011999b:	39 c1                	cmp    %eax,%ecx
f011999d:	74 17                	je     f01199b6 <test_kfree_bestfirstfit+0xa29>
f011999f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199a6:	83 ec 0c             	sub    $0xc,%esp
f01199a9:	68 ac d4 12 f0       	push   $0xf012d4ac
f01199ae:	e8 d8 75 fe ff       	call   f0100f8b <cprintf>
f01199b3:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01199b6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01199ba:	74 04                	je     f01199c0 <test_kfree_bestfirstfit+0xa33>
f01199bc:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f01199c0:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f01199c7:	83 ec 0c             	sub    $0xc,%esp
f01199ca:	68 e4 d4 12 f0       	push   $0xf012d4e4
f01199cf:	e8 b7 75 fe ff       	call   f0100f8b <cprintf>
f01199d4:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f01199d7:	e8 d0 47 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f01199dc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01199df:	e8 c1 ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01199e4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f01199e7:	83 ec 0c             	sub    $0xc,%esp
f01199ea:	68 00 04 00 00       	push   $0x400
f01199ef:	e8 f7 f6 fe ff       	call   f01090eb <kmalloc>
f01199f4:	83 c4 10             	add    $0x10,%esp
f01199f7:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f01199fd:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f0119a03:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119a09:	39 c2                	cmp    %eax,%edx
f0119a0b:	74 17                	je     f0119a24 <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119a0d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a14:	83 ec 0c             	sub    $0xc,%esp
f0119a17:	68 04 d5 12 f0       	push   $0xf012d504
f0119a1c:	e8 6a 75 fe ff       	call   f0100f8b <cprintf>
f0119a21:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119a24:	e8 7c ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119a29:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119a2c:	74 17                	je     f0119a45 <test_kfree_bestfirstfit+0xab8>
f0119a2e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a35:	83 ec 0c             	sub    $0xc,%esp
f0119a38:	68 58 d5 12 f0       	push   $0xf012d558
f0119a3d:	e8 49 75 fe ff       	call   f0100f8b <cprintf>
f0119a42:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f0119a45:	e8 62 47 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119a4a:	89 c2                	mov    %eax,%edx
f0119a4c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119a4f:	39 c2                	cmp    %eax,%edx
f0119a51:	74 17                	je     f0119a6a <test_kfree_bestfirstfit+0xadd>
f0119a53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a5a:	83 ec 0c             	sub    $0xc,%esp
f0119a5d:	68 c8 d5 12 f0       	push   $0xf012d5c8
f0119a62:	e8 24 75 fe ff       	call   f0100f8b <cprintf>
f0119a67:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f0119a6a:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f0119a71:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f0119a77:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f0119a7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a81:	eb 0e                	jmp    f0119a91 <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f0119a83:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119a86:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119a89:	01 d0                	add    %edx,%eax
f0119a8b:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f0119a8e:	ff 45 f4             	incl   -0xc(%ebp)
f0119a91:	8b 45 88             	mov    -0x78(%ebp),%eax
f0119a94:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a97:	7f ea                	jg     f0119a83 <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f0119a99:	e8 0e 47 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119a9e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119aa1:	e8 ff ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119aa6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f0119aa9:	83 ec 0c             	sub    $0xc,%esp
f0119aac:	68 00 00 30 00       	push   $0x300000
f0119ab1:	e8 35 f6 fe ff       	call   f01090eb <kmalloc>
f0119ab6:	83 c4 10             	add    $0x10,%esp
f0119ab9:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119abf:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119ac5:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119aca:	74 17                	je     f0119ae3 <test_kfree_bestfirstfit+0xb56>
f0119acc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ad3:	83 ec 0c             	sub    $0xc,%esp
f0119ad6:	68 44 d6 12 f0       	push   $0xf012d644
f0119adb:	e8 ab 74 fe ff       	call   f0100f8b <cprintf>
f0119ae0:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ae3:	e8 bd ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ae8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119aeb:	74 17                	je     f0119b04 <test_kfree_bestfirstfit+0xb77>
f0119aed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119af4:	83 ec 0c             	sub    $0xc,%esp
f0119af7:	68 98 d6 12 f0       	push   $0xf012d698
f0119afc:	e8 8a 74 fe ff       	call   f0100f8b <cprintf>
f0119b01:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119b04:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119b07:	e8 a0 46 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119b0c:	29 c3                	sub    %eax,%ebx
f0119b0e:	89 d8                	mov    %ebx,%eax
f0119b10:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119b15:	77 17                	ja     f0119b2e <test_kfree_bestfirstfit+0xba1>
f0119b17:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b1e:	83 ec 0c             	sub    $0xc,%esp
f0119b21:	68 08 d7 12 f0       	push   $0xf012d708
f0119b26:	e8 60 74 fe ff       	call   f0100f8b <cprintf>
f0119b2b:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f0119b2e:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f0119b35:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119b3b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f0119b3e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119b45:	eb 0e                	jmp    f0119b55 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f0119b47:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119b4a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119b4d:	01 d0                	add    %edx,%eax
f0119b4f:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f0119b52:	ff 45 f4             	incl   -0xc(%ebp)
f0119b55:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0119b58:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119b5b:	7f ea                	jg     f0119b47 <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f0119b5d:	e8 4a 46 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119b62:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119b65:	e8 3b ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b6a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f0119b6d:	83 ec 0c             	sub    $0xc,%esp
f0119b70:	68 00 00 10 00       	push   $0x100000
f0119b75:	e8 71 f5 fe ff       	call   f01090eb <kmalloc>
f0119b7a:	83 c4 10             	add    $0x10,%esp
f0119b7d:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119b83:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119b89:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0119b8e:	74 17                	je     f0119ba7 <test_kfree_bestfirstfit+0xc1a>
f0119b90:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b97:	83 ec 0c             	sub    $0xc,%esp
f0119b9a:	68 50 d7 12 f0       	push   $0xf012d750
f0119b9f:	e8 e7 73 fe ff       	call   f0100f8b <cprintf>
f0119ba4:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ba7:	e8 f9 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119bac:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119baf:	74 17                	je     f0119bc8 <test_kfree_bestfirstfit+0xc3b>
f0119bb1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bb8:	83 ec 0c             	sub    $0xc,%esp
f0119bbb:	68 a4 d7 12 f0       	push   $0xf012d7a4
f0119bc0:	e8 c6 73 fe ff       	call   f0100f8b <cprintf>
f0119bc5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119bc8:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119bcb:	e8 dc 45 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119bd0:	29 c3                	sub    %eax,%ebx
f0119bd2:	89 d8                	mov    %ebx,%eax
f0119bd4:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119bd9:	77 17                	ja     f0119bf2 <test_kfree_bestfirstfit+0xc65>
f0119bdb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119be2:	83 ec 0c             	sub    $0xc,%esp
f0119be5:	68 14 d8 12 f0       	push   $0xf012d814
f0119bea:	e8 9c 73 fe ff       	call   f0100f8b <cprintf>
f0119bef:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f0119bf2:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f0119bf9:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119bff:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f0119c02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119c09:	eb 0e                	jmp    f0119c19 <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f0119c0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c0e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119c11:	01 d0                	add    %edx,%eax
f0119c13:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f0119c16:	ff 45 f4             	incl   -0xc(%ebp)
f0119c19:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0119c1c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119c1f:	7f ea                	jg     f0119c0b <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f0119c21:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119c25:	74 04                	je     f0119c2b <test_kfree_bestfirstfit+0xc9e>
f0119c27:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f0119c2b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f0119c32:	83 ec 0c             	sub    $0xc,%esp
f0119c35:	68 5c d8 12 f0       	push   $0xf012d85c
f0119c3a:	e8 4c 73 fe ff       	call   f0100f8b <cprintf>
f0119c3f:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f0119c42:	e8 65 45 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119c47:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119c4a:	e8 56 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c4f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f0119c52:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119c58:	83 ec 0c             	sub    $0xc,%esp
f0119c5b:	50                   	push   %eax
f0119c5c:	e8 ea f6 fe ff       	call   f010934b <kfree>
f0119c61:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c64:	e8 3c ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c69:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119c6c:	74 17                	je     f0119c85 <test_kfree_bestfirstfit+0xcf8>
f0119c6e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c75:	83 ec 0c             	sub    $0xc,%esp
f0119c78:	68 88 d8 12 f0       	push   $0xf012d888
f0119c7d:	e8 09 73 fe ff       	call   f0100f8b <cprintf>
f0119c82:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119c85:	e8 22 45 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119c8a:	89 c2                	mov    %eax,%edx
f0119c8c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119c8f:	29 c2                	sub    %eax,%edx
f0119c91:	89 d0                	mov    %edx,%eax
f0119c93:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119c98:	77 17                	ja     f0119cb1 <test_kfree_bestfirstfit+0xd24>
f0119c9a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ca1:	83 ec 0c             	sub    $0xc,%esp
f0119ca4:	68 f8 d8 12 f0       	push   $0xf012d8f8
f0119ca9:	e8 dd 72 fe ff       	call   f0100f8b <cprintf>
f0119cae:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f0119cb1:	e8 f6 44 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119cb6:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119cb9:	e8 e7 ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119cbe:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f0119cc1:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119cc7:	83 ec 0c             	sub    $0xc,%esp
f0119cca:	50                   	push   %eax
f0119ccb:	e8 7b f6 fe ff       	call   f010934b <kfree>
f0119cd0:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119cd3:	e8 cd ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119cd8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119cdb:	74 17                	je     f0119cf4 <test_kfree_bestfirstfit+0xd67>
f0119cdd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ce4:	83 ec 0c             	sub    $0xc,%esp
f0119ce7:	68 34 d9 12 f0       	push   $0xf012d934
f0119cec:	e8 9a 72 fe ff       	call   f0100f8b <cprintf>
f0119cf1:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119cf4:	e8 b3 44 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119cf9:	89 c2                	mov    %eax,%edx
f0119cfb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119cfe:	29 c2                	sub    %eax,%edx
f0119d00:	89 d0                	mov    %edx,%eax
f0119d02:	83 f8 01             	cmp    $0x1,%eax
f0119d05:	77 17                	ja     f0119d1e <test_kfree_bestfirstfit+0xd91>
f0119d07:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d0e:	83 ec 0c             	sub    $0xc,%esp
f0119d11:	68 a4 d9 12 f0       	push   $0xf012d9a4
f0119d16:	e8 70 72 fe ff       	call   f0100f8b <cprintf>
f0119d1b:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f0119d1e:	e8 89 44 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119d23:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119d26:	e8 7a ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d2b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f0119d2e:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119d34:	83 ec 0c             	sub    $0xc,%esp
f0119d37:	50                   	push   %eax
f0119d38:	e8 0e f6 fe ff       	call   f010934b <kfree>
f0119d3d:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d40:	e8 60 ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d45:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119d48:	74 17                	je     f0119d61 <test_kfree_bestfirstfit+0xdd4>
f0119d4a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d51:	83 ec 0c             	sub    $0xc,%esp
f0119d54:	68 e0 d9 12 f0       	push   $0xf012d9e0
f0119d59:	e8 2d 72 fe ff       	call   f0100f8b <cprintf>
f0119d5e:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119d61:	e8 46 44 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119d66:	89 c2                	mov    %eax,%edx
f0119d68:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119d6b:	29 c2                	sub    %eax,%edx
f0119d6d:	89 d0                	mov    %edx,%eax
f0119d6f:	83 f8 03             	cmp    $0x3,%eax
f0119d72:	77 17                	ja     f0119d8b <test_kfree_bestfirstfit+0xdfe>
f0119d74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d7b:	83 ec 0c             	sub    $0xc,%esp
f0119d7e:	68 50 da 12 f0       	push   $0xf012da50
f0119d83:	e8 03 72 fe ff       	call   f0100f8b <cprintf>
f0119d88:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f0119d8b:	e8 1c 44 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119d90:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119d93:	e8 0d ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d98:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f0119d9b:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119da1:	83 ec 0c             	sub    $0xc,%esp
f0119da4:	50                   	push   %eax
f0119da5:	e8 a1 f5 fe ff       	call   f010934b <kfree>
f0119daa:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119dad:	e8 f3 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119db2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119db5:	74 17                	je     f0119dce <test_kfree_bestfirstfit+0xe41>
f0119db7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dbe:	83 ec 0c             	sub    $0xc,%esp
f0119dc1:	68 8c da 12 f0       	push   $0xf012da8c
f0119dc6:	e8 c0 71 fe ff       	call   f0100f8b <cprintf>
f0119dcb:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119dce:	e8 d9 43 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119dd3:	89 c2                	mov    %eax,%edx
f0119dd5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119dd8:	29 c2                	sub    %eax,%edx
f0119dda:	89 d0                	mov    %edx,%eax
f0119ddc:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119de1:	77 17                	ja     f0119dfa <test_kfree_bestfirstfit+0xe6d>
f0119de3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dea:	83 ec 0c             	sub    $0xc,%esp
f0119ded:	68 fc da 12 f0       	push   $0xf012dafc
f0119df2:	e8 94 71 fe ff       	call   f0100f8b <cprintf>
f0119df7:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f0119dfa:	e8 ad 43 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119dff:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119e02:	e8 9e aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e07:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f0119e0a:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119e10:	83 ec 0c             	sub    $0xc,%esp
f0119e13:	50                   	push   %eax
f0119e14:	e8 32 f5 fe ff       	call   f010934b <kfree>
f0119e19:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e1c:	e8 84 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e21:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119e24:	74 17                	je     f0119e3d <test_kfree_bestfirstfit+0xeb0>
f0119e26:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e2d:	83 ec 0c             	sub    $0xc,%esp
f0119e30:	68 38 db 12 f0       	push   $0xf012db38
f0119e35:	e8 51 71 fe ff       	call   f0100f8b <cprintf>
f0119e3a:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119e3d:	e8 6a 43 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119e42:	89 c2                	mov    %eax,%edx
f0119e44:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119e47:	29 c2                	sub    %eax,%edx
f0119e49:	89 d0                	mov    %edx,%eax
f0119e4b:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119e50:	77 17                	ja     f0119e69 <test_kfree_bestfirstfit+0xedc>
f0119e52:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e59:	83 ec 0c             	sub    $0xc,%esp
f0119e5c:	68 a8 db 12 f0       	push   $0xf012dba8
f0119e61:	e8 25 71 fe ff       	call   f0100f8b <cprintf>
f0119e66:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f0119e69:	e8 3e 43 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119e6e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119e71:	e8 2f aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e76:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f0119e79:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f0119e7f:	83 ec 0c             	sub    $0xc,%esp
f0119e82:	50                   	push   %eax
f0119e83:	e8 c3 f4 fe ff       	call   f010934b <kfree>
f0119e88:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e8b:	e8 15 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e90:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119e93:	74 17                	je     f0119eac <test_kfree_bestfirstfit+0xf1f>
f0119e95:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e9c:	83 ec 0c             	sub    $0xc,%esp
f0119e9f:	68 e4 db 12 f0       	push   $0xf012dbe4
f0119ea4:	e8 e2 70 fe ff       	call   f0100f8b <cprintf>
f0119ea9:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119eac:	e8 fb 42 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119eb1:	89 c2                	mov    %eax,%edx
f0119eb3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119eb6:	39 c2                	cmp    %eax,%edx
f0119eb8:	74 17                	je     f0119ed1 <test_kfree_bestfirstfit+0xf44>
f0119eba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ec1:	83 ec 0c             	sub    $0xc,%esp
f0119ec4:	68 54 dc 12 f0       	push   $0xf012dc54
f0119ec9:	e8 bd 70 fe ff       	call   f0100f8b <cprintf>
f0119ece:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f0119ed1:	e8 d6 42 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119ed6:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119ed9:	e8 c7 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ede:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f0119ee1:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119ee7:	83 ec 0c             	sub    $0xc,%esp
f0119eea:	50                   	push   %eax
f0119eeb:	e8 5b f4 fe ff       	call   f010934b <kfree>
f0119ef0:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ef3:	e8 ad a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ef8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119efb:	74 17                	je     f0119f14 <test_kfree_bestfirstfit+0xf87>
f0119efd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f04:	83 ec 0c             	sub    $0xc,%esp
f0119f07:	68 90 dc 12 f0       	push   $0xf012dc90
f0119f0c:	e8 7a 70 fe ff       	call   f0100f8b <cprintf>
f0119f11:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119f14:	e8 93 42 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f0119f19:	89 c2                	mov    %eax,%edx
f0119f1b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119f1e:	39 c2                	cmp    %eax,%edx
f0119f20:	74 17                	je     f0119f39 <test_kfree_bestfirstfit+0xfac>
f0119f22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f29:	83 ec 0c             	sub    $0xc,%esp
f0119f2c:	68 00 dd 12 f0       	push   $0xf012dd00
f0119f31:	e8 55 70 fe ff       	call   f0100f8b <cprintf>
f0119f36:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f0119f39:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119f3d:	74 04                	je     f0119f43 <test_kfree_bestfirstfit+0xfb6>
f0119f3f:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f0119f43:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f0119f4a:	83 ec 0c             	sub    $0xc,%esp
f0119f4d:	68 60 dd 12 f0       	push   $0xf012dd60
f0119f52:	e8 34 70 fe ff       	call   f0100f8b <cprintf>
f0119f57:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f0119f5a:	83 ec 0c             	sub    $0xc,%esp
f0119f5d:	6a 03                	push   $0x3
f0119f5f:	e8 71 46 ff ff       	call   f010e5d5 <sys_bypassPageFault>
f0119f64:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f0119f67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119f6e:	e9 af 00 00 00       	jmp    f011a022 <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f0119f73:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0119f77:	0f 84 a1 00 00 00    	je     f011a01e <test_kfree_bestfirstfit+0x1091>
f0119f7d:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0119f81:	0f 84 97 00 00 00    	je     f011a01e <test_kfree_bestfirstfit+0x1091>
f0119f87:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f0119f8b:	0f 84 8d 00 00 00    	je     f011a01e <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f0119f91:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f94:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f0119f9b:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f0119f9e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119fa1:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f0119fa4:	e8 1a 46 ff ff       	call   f010e5c3 <sys_rcr2>
f0119fa9:	89 c2                	mov    %eax,%edx
f0119fab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119fae:	39 c2                	cmp    %eax,%edx
f0119fb0:	74 1d                	je     f0119fcf <test_kfree_bestfirstfit+0x1042>
				if (correct)
f0119fb2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119fb6:	74 17                	je     f0119fcf <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f0119fb8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fbf:	83 ec 0c             	sub    $0xc,%esp
f0119fc2:	68 a0 dd 12 f0       	push   $0xf012dda0
f0119fc7:	e8 bf 6f fe ff       	call   f0100f8b <cprintf>
f0119fcc:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f0119fcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119fd2:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f0119fd9:	89 c2                	mov    %eax,%edx
f0119fdb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119fde:	01 d0                	add    %edx,%eax
f0119fe0:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f0119fe3:	e8 db 45 ff ff       	call   f010e5c3 <sys_rcr2>
f0119fe8:	89 c2                	mov    %eax,%edx
f0119fea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119fed:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f0119ff4:	89 c1                	mov    %eax,%ecx
f0119ff6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119ff9:	01 c8                	add    %ecx,%eax
f0119ffb:	39 c2                	cmp    %eax,%edx
f0119ffd:	74 20                	je     f011a01f <test_kfree_bestfirstfit+0x1092>
				if (correct)
f0119fff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a003:	74 1a                	je     f011a01f <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a005:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a00c:	83 ec 0c             	sub    $0xc,%esp
f011a00f:	68 ec dd 12 f0       	push   $0xf012ddec
f011a014:	e8 72 6f fe ff       	call   f0100f8b <cprintf>
f011a019:	83 c4 10             	add    $0x10,%esp
f011a01c:	eb 01                	jmp    f011a01f <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011a01e:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011a01f:	ff 45 f4             	incl   -0xc(%ebp)
f011a022:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011a026:	0f 8e 47 ff ff ff    	jle    f0119f73 <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011a02c:	83 ec 0c             	sub    $0xc,%esp
f011a02f:	6a 00                	push   $0x0
f011a031:	e8 9f 45 ff ff       	call   f010e5d5 <sys_bypassPageFault>
f011a036:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011a039:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a03d:	74 04                	je     f011a043 <test_kfree_bestfirstfit+0x10b6>
f011a03f:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a043:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011a04a:	83 ec 0c             	sub    $0xc,%esp
f011a04d:	68 38 de 12 f0       	push   $0xf012de38
f011a052:	e8 34 6f fe ff       	call   f0100f8b <cprintf>
f011a057:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a05a:	e8 4d 41 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a05f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a062:	e8 3e a8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a067:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011a06a:	83 ec 0c             	sub    $0xc,%esp
f011a06d:	68 00 04 00 00       	push   $0x400
f011a072:	e8 74 f0 fe ff       	call   f01090eb <kmalloc>
f011a077:	83 c4 10             	add    $0x10,%esp
f011a07a:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011a080:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011a086:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a08c:	39 c2                	cmp    %eax,%edx
f011a08e:	74 17                	je     f011a0a7 <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a090:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a097:	83 ec 0c             	sub    $0xc,%esp
f011a09a:	68 5c de 12 f0       	push   $0xf012de5c
f011a09f:	e8 e7 6e fe ff       	call   f0100f8b <cprintf>
f011a0a4:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a0a7:	e8 f9 a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a0ac:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a0af:	74 17                	je     f011a0c8 <test_kfree_bestfirstfit+0x113b>
f011a0b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0b8:	83 ec 0c             	sub    $0xc,%esp
f011a0bb:	68 b0 de 12 f0       	push   $0xf012deb0
f011a0c0:	e8 c6 6e fe ff       	call   f0100f8b <cprintf>
f011a0c5:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a0c8:	e8 df 40 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a0cd:	89 c2                	mov    %eax,%edx
f011a0cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a0d2:	39 c2                	cmp    %eax,%edx
f011a0d4:	74 17                	je     f011a0ed <test_kfree_bestfirstfit+0x1160>
f011a0d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0dd:	83 ec 0c             	sub    $0xc,%esp
f011a0e0:	68 20 df 12 f0       	push   $0xf012df20
f011a0e5:	e8 a1 6e fe ff       	call   f0100f8b <cprintf>
f011a0ea:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011a0ed:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011a0f4:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a0fa:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a0fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a104:	eb 0e                	jmp    f011a114 <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011a106:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a109:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a10c:	01 d0                	add    %edx,%eax
f011a10e:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a111:	ff 45 f4             	incl   -0xc(%ebp)
f011a114:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a117:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a11a:	7f ea                	jg     f011a106 <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a11c:	e8 8b 40 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a121:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a124:	e8 7c a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a129:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011a12c:	83 ec 0c             	sub    $0xc,%esp
f011a12f:	68 00 08 00 00       	push   $0x800
f011a134:	e8 b2 ef fe ff       	call   f01090eb <kmalloc>
f011a139:	83 c4 10             	add    $0x10,%esp
f011a13c:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011a142:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a148:	05 08 04 00 00       	add    $0x408,%eax
f011a14d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011a150:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a156:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a159:	74 35                	je     f011a190 <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011a15b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011a162:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a168:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a16e:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011a174:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a17a:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a180:	50                   	push   %eax
f011a181:	51                   	push   %ecx
f011a182:	52                   	push   %edx
f011a183:	68 9c df 12 f0       	push   $0xf012df9c
f011a188:	e8 fe 6d fe ff       	call   f0100f8b <cprintf>
f011a18d:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a190:	e8 10 a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a195:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a198:	74 17                	je     f011a1b1 <test_kfree_bestfirstfit+0x1224>
f011a19a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1a1:	83 ec 0c             	sub    $0xc,%esp
f011a1a4:	68 10 e0 12 f0       	push   $0xf012e010
f011a1a9:	e8 dd 6d fe ff       	call   f0100f8b <cprintf>
f011a1ae:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a1b1:	e8 f6 3f ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a1b6:	89 c2                	mov    %eax,%edx
f011a1b8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a1bb:	39 c2                	cmp    %eax,%edx
f011a1bd:	74 17                	je     f011a1d6 <test_kfree_bestfirstfit+0x1249>
f011a1bf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1c6:	83 ec 0c             	sub    $0xc,%esp
f011a1c9:	68 80 e0 12 f0       	push   $0xf012e080
f011a1ce:	e8 b8 6d fe ff       	call   f0100f8b <cprintf>
f011a1d3:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011a1d6:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011a1dd:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a1e3:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a1e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a1ed:	eb 0e                	jmp    f011a1fd <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011a1ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a1f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a1f5:	01 d0                	add    %edx,%eax
f011a1f7:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a1fa:	ff 45 f4             	incl   -0xc(%ebp)
f011a1fd:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a200:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a203:	7f ea                	jg     f011a1ef <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011a205:	e8 a2 3f ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a20a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a20d:	e8 93 a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a212:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011a215:	83 ec 0c             	sub    $0xc,%esp
f011a218:	68 00 06 00 00       	push   $0x600
f011a21d:	e8 c9 ee fe ff       	call   f01090eb <kmalloc>
f011a222:	83 c4 10             	add    $0x10,%esp
f011a225:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011a22b:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a231:	05 10 0c 00 00       	add    $0xc10,%eax
f011a236:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011a239:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a23f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a242:	74 17                	je     f011a25b <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a244:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a24b:	83 ec 0c             	sub    $0xc,%esp
f011a24e:	68 fc e0 12 f0       	push   $0xf012e0fc
f011a253:	e8 33 6d fe ff       	call   f0100f8b <cprintf>
f011a258:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a25b:	e8 45 a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a260:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a263:	74 17                	je     f011a27c <test_kfree_bestfirstfit+0x12ef>
f011a265:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a26c:	83 ec 0c             	sub    $0xc,%esp
f011a26f:	68 50 e1 12 f0       	push   $0xf012e150
f011a274:	e8 12 6d fe ff       	call   f0100f8b <cprintf>
f011a279:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a27c:	e8 2b 3f ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a281:	89 c2                	mov    %eax,%edx
f011a283:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a286:	39 c2                	cmp    %eax,%edx
f011a288:	74 17                	je     f011a2a1 <test_kfree_bestfirstfit+0x1314>
f011a28a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a291:	83 ec 0c             	sub    $0xc,%esp
f011a294:	68 c0 e1 12 f0       	push   $0xf012e1c0
f011a299:	e8 ed 6c fe ff       	call   f0100f8b <cprintf>
f011a29e:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011a2a1:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011a2a8:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a2ae:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011a2b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a2b8:	eb 0e                	jmp    f011a2c8 <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011a2ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a2bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a2c0:	01 d0                	add    %edx,%eax
f011a2c2:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011a2c5:	ff 45 f4             	incl   -0xc(%ebp)
f011a2c8:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a2cb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a2ce:	7f ea                	jg     f011a2ba <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011a2d0:	e8 d7 3e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a2d5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a2d8:	e8 c8 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a2dd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011a2e0:	83 ec 0c             	sub    $0xc,%esp
f011a2e3:	68 00 00 e0 01       	push   $0x1e00000
f011a2e8:	e8 fe ed fe ff       	call   f01090eb <kmalloc>
f011a2ed:	83 c4 10             	add    $0x10,%esp
f011a2f0:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a2f6:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a2fc:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a301:	74 17                	je     f011a31a <test_kfree_bestfirstfit+0x138d>
f011a303:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a30a:	83 ec 0c             	sub    $0xc,%esp
f011a30d:	68 3c e2 12 f0       	push   $0xf012e23c
f011a312:	e8 74 6c fe ff       	call   f0100f8b <cprintf>
f011a317:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a31a:	e8 86 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a31f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a322:	74 17                	je     f011a33b <test_kfree_bestfirstfit+0x13ae>
f011a324:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a32b:	83 ec 0c             	sub    $0xc,%esp
f011a32e:	68 90 e2 12 f0       	push   $0xf012e290
f011a333:	e8 53 6c fe ff       	call   f0100f8b <cprintf>
f011a338:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a33b:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a33e:	e8 69 3e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a343:	29 c3                	sub    %eax,%ebx
f011a345:	89 d8                	mov    %ebx,%eax
f011a347:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011a34c:	77 17                	ja     f011a365 <test_kfree_bestfirstfit+0x13d8>
f011a34e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a355:	83 ec 0c             	sub    $0xc,%esp
f011a358:	68 00 e3 12 f0       	push   $0xf012e300
f011a35d:	e8 29 6c fe ff       	call   f0100f8b <cprintf>
f011a362:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011a365:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011a36c:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a372:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011a375:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a37c:	eb 0e                	jmp    f011a38c <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011a37e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a381:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a384:	01 d0                	add    %edx,%eax
f011a386:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011a389:	ff 45 f4             	incl   -0xc(%ebp)
f011a38c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a38f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a392:	7f ea                	jg     f011a37e <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011a394:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a39a:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011a39d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a3a4:	eb 1e                	jmp    f011a3c4 <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011a3a6:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011a3ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a3af:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a3b2:	01 c8                	add    %ecx,%eax
f011a3b4:	8a 00                	mov    (%eax),%al
f011a3b6:	0f be c0             	movsbl %al,%eax
f011a3b9:	01 d0                	add    %edx,%eax
f011a3bb:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011a3c1:	ff 45 f4             	incl   -0xc(%ebp)
f011a3c4:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a3c7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a3ca:	7f da                	jg     f011a3a6 <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011a3cc:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011a3d2:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011a3d5:	89 d0                	mov    %edx,%eax
f011a3d7:	c1 e0 02             	shl    $0x2,%eax
f011a3da:	01 d0                	add    %edx,%eax
f011a3dc:	01 c0                	add    %eax,%eax
f011a3de:	39 c1                	cmp    %eax,%ecx
f011a3e0:	74 17                	je     f011a3f9 <test_kfree_bestfirstfit+0x146c>
f011a3e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3e9:	83 ec 0c             	sub    $0xc,%esp
f011a3ec:	68 48 e3 12 f0       	push   $0xf012e348
f011a3f1:	e8 95 6b fe ff       	call   f0100f8b <cprintf>
f011a3f6:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011a3f9:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a3ff:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a402:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a409:	eb 1e                	jmp    f011a429 <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011a40b:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011a411:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a414:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a417:	01 c8                	add    %ecx,%eax
f011a419:	8a 00                	mov    (%eax),%al
f011a41b:	0f be c0             	movsbl %al,%eax
f011a41e:	01 d0                	add    %edx,%eax
f011a420:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a426:	ff 45 f4             	incl   -0xc(%ebp)
f011a429:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a42c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a42f:	7f da                	jg     f011a40b <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011a431:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011a437:	8b 55 90             	mov    -0x70(%ebp),%edx
f011a43a:	89 d0                	mov    %edx,%eax
f011a43c:	c1 e0 02             	shl    $0x2,%eax
f011a43f:	01 d0                	add    %edx,%eax
f011a441:	01 c0                	add    %eax,%eax
f011a443:	01 d0                	add    %edx,%eax
f011a445:	39 c1                	cmp    %eax,%ecx
f011a447:	74 17                	je     f011a460 <test_kfree_bestfirstfit+0x14d3>
f011a449:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a450:	83 ec 0c             	sub    $0xc,%esp
f011a453:	68 78 e3 12 f0       	push   $0xf012e378
f011a458:	e8 2e 6b fe ff       	call   f0100f8b <cprintf>
f011a45d:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011a460:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a466:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a469:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a470:	eb 1e                	jmp    f011a490 <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011a472:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011a478:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a47b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a47e:	01 c8                	add    %ecx,%eax
f011a480:	8a 00                	mov    (%eax),%al
f011a482:	0f be c0             	movsbl %al,%eax
f011a485:	01 d0                	add    %edx,%eax
f011a487:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a48d:	ff 45 f4             	incl   -0xc(%ebp)
f011a490:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a493:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a496:	7f da                	jg     f011a472 <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011a498:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011a49e:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011a4a1:	89 d0                	mov    %edx,%eax
f011a4a3:	01 c0                	add    %eax,%eax
f011a4a5:	01 d0                	add    %edx,%eax
f011a4a7:	c1 e0 02             	shl    $0x2,%eax
f011a4aa:	39 c1                	cmp    %eax,%ecx
f011a4ac:	74 17                	je     f011a4c5 <test_kfree_bestfirstfit+0x1538>
f011a4ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4b5:	83 ec 0c             	sub    $0xc,%esp
f011a4b8:	68 a8 e3 12 f0       	push   $0xf012e3a8
f011a4bd:	e8 c9 6a fe ff       	call   f0100f8b <cprintf>
f011a4c2:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011a4c5:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a4cb:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011a4ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a4d5:	eb 1e                	jmp    f011a4f5 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011a4d7:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011a4dd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a4e0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a4e3:	01 c8                	add    %ecx,%eax
f011a4e5:	8a 00                	mov    (%eax),%al
f011a4e7:	0f be c0             	movsbl %al,%eax
f011a4ea:	01 d0                	add    %edx,%eax
f011a4ec:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011a4f2:	ff 45 f4             	incl   -0xc(%ebp)
f011a4f5:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a4f8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a4fb:	7f da                	jg     f011a4d7 <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011a4fd:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011a503:	8b 55 98             	mov    -0x68(%ebp),%edx
f011a506:	89 d0                	mov    %edx,%eax
f011a508:	01 c0                	add    %eax,%eax
f011a50a:	01 d0                	add    %edx,%eax
f011a50c:	c1 e0 02             	shl    $0x2,%eax
f011a50f:	01 d0                	add    %edx,%eax
f011a511:	39 c1                	cmp    %eax,%ecx
f011a513:	74 17                	je     f011a52c <test_kfree_bestfirstfit+0x159f>
f011a515:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a51c:	83 ec 0c             	sub    $0xc,%esp
f011a51f:	68 d8 e3 12 f0       	push   $0xf012e3d8
f011a524:	e8 62 6a fe ff       	call   f0100f8b <cprintf>
f011a529:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011a52c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a530:	74 04                	je     f011a536 <test_kfree_bestfirstfit+0x15a9>
f011a532:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011a536:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011a53d:	83 ec 0c             	sub    $0xc,%esp
f011a540:	68 05 e4 12 f0       	push   $0xf012e405
f011a545:	e8 41 6a fe ff       	call   f0100f8b <cprintf>
f011a54a:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011a54d:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011a554:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011a55b:	eb 4e                	jmp    f011a5ab <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011a55d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a560:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011a565:	83 ec 04             	sub    $0x4,%esp
f011a568:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011a56e:	51                   	push   %ecx
f011a56f:	52                   	push   %edx
f011a570:	50                   	push   %eax
f011a571:	e8 79 de fe ff       	call   f01083ef <get_page_table>
f011a576:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a579:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011a57f:	85 c0                	test   %eax,%eax
f011a581:	75 1d                	jne    f011a5a0 <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011a583:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a587:	74 17                	je     f011a5a0 <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011a589:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a590:	83 ec 0c             	sub    $0xc,%esp
f011a593:	68 24 e4 12 f0       	push   $0xf012e424
f011a598:	e8 ee 69 fe ff       	call   f0100f8b <cprintf>
f011a59d:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011a5a0:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011a5a7:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011a5ab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a5af:	78 ac                	js     f011a55d <test_kfree_bestfirstfit+0x15d0>
f011a5b1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a5b5:	7f 09                	jg     f011a5c0 <test_kfree_bestfirstfit+0x1633>
f011a5b7:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011a5be:	76 9d                	jbe    f011a55d <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011a5c0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a5c4:	74 04                	je     f011a5ca <test_kfree_bestfirstfit+0x163d>
f011a5c6:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011a5ca:	83 ec 08             	sub    $0x8,%esp
f011a5cd:	ff 75 f0             	pushl  -0x10(%ebp)
f011a5d0:	68 8c e4 12 f0       	push   $0xf012e48c
f011a5d5:	e8 b1 69 fe ff       	call   f0100f8b <cprintf>
f011a5da:	83 c4 10             	add    $0x10,%esp

	return 1;
f011a5dd:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011a5e2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011a5e5:	5b                   	pop    %ebx
f011a5e6:	5f                   	pop    %edi
f011a5e7:	5d                   	pop    %ebp
f011a5e8:	c3                   	ret    

f011a5e9 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011a5e9:	55                   	push   %ebp
f011a5ea:	89 e5                	mov    %esp,%ebp
f011a5ec:	57                   	push   %edi
f011a5ed:	53                   	push   %ebx
f011a5ee:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011a5f4:	83 ec 0c             	sub    $0xc,%esp
f011a5f7:	68 48 a7 12 f0       	push   $0xf012a748
f011a5fc:	e8 8a 69 fe ff       	call   f0100f8b <cprintf>
f011a601:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011a604:	83 ec 0c             	sub    $0xc,%esp
f011a607:	68 78 a7 12 f0       	push   $0xf012a778
f011a60c:	e8 7a 69 fe ff       	call   f0100f8b <cprintf>
f011a611:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011a614:	83 ec 0c             	sub    $0xc,%esp
f011a617:	68 48 a7 12 f0       	push   $0xf012a748
f011a61c:	e8 6a 69 fe ff       	call   f0100f8b <cprintf>
f011a621:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011a624:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011a628:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011a62c:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011a632:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011a638:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011a63f:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011a646:	e8 61 3b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a64b:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011a64e:	83 ec 0c             	sub    $0xc,%esp
f011a651:	68 b0 e4 12 f0       	push   $0xf012e4b0
f011a656:	e8 30 69 fe ff       	call   f0100f8b <cprintf>
f011a65b:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011a65e:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011a664:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a669:	b8 00 00 00 00       	mov    $0x0,%eax
f011a66e:	89 d7                	mov    %edx,%edi
f011a670:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011a672:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011a678:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a67d:	b8 00 00 00 00       	mov    $0x0,%eax
f011a682:	89 d7                	mov    %edx,%edi
f011a684:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011a686:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011a68d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011a694:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011a69a:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a69f:	b8 00 00 00 00       	mov    $0x0,%eax
f011a6a4:	89 d7                	mov    %edx,%edi
f011a6a6:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a6a8:	e8 ff 3a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a6ad:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a6b0:	e8 f0 a1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a6b5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011a6b8:	83 ec 0c             	sub    $0xc,%esp
f011a6bb:	68 00 fc 1f 00       	push   $0x1ffc00
f011a6c0:	e8 26 ea fe ff       	call   f01090eb <kmalloc>
f011a6c5:	83 c4 10             	add    $0x10,%esp
f011a6c8:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a6ce:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011a6d4:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a6d9:	74 17                	je     f011a6f2 <test_kheap_phys_addr+0x109>
f011a6db:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6e2:	83 ec 0c             	sub    $0xc,%esp
f011a6e5:	68 54 c8 12 f0       	push   $0xf012c854
f011a6ea:	e8 9c 68 fe ff       	call   f0100f8b <cprintf>
f011a6ef:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a6f2:	e8 ae a1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a6f7:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a6fa:	74 17                	je     f011a713 <test_kheap_phys_addr+0x12a>
f011a6fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a703:	83 ec 0c             	sub    $0xc,%esp
f011a706:	68 a8 c8 12 f0       	push   $0xf012c8a8
f011a70b:	e8 7b 68 fe ff       	call   f0100f8b <cprintf>
f011a710:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a713:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a716:	e8 91 3a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a71b:	29 c3                	sub    %eax,%ebx
f011a71d:	89 d8                	mov    %ebx,%eax
f011a71f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a724:	77 17                	ja     f011a73d <test_kheap_phys_addr+0x154>
f011a726:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a72d:	83 ec 0c             	sub    $0xc,%esp
f011a730:	68 18 c9 12 f0       	push   $0xf012c918
f011a735:	e8 51 68 fe ff       	call   f0100f8b <cprintf>
f011a73a:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a73d:	e8 6a 3a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a742:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a745:	e8 5b a1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a74a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011a74d:	83 ec 0c             	sub    $0xc,%esp
f011a750:	68 00 fc 1f 00       	push   $0x1ffc00
f011a755:	e8 91 e9 fe ff       	call   f01090eb <kmalloc>
f011a75a:	83 c4 10             	add    $0x10,%esp
f011a75d:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a763:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011a769:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011a76e:	74 17                	je     f011a787 <test_kheap_phys_addr+0x19e>
f011a770:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a777:	83 ec 0c             	sub    $0xc,%esp
f011a77a:	68 60 c9 12 f0       	push   $0xf012c960
f011a77f:	e8 07 68 fe ff       	call   f0100f8b <cprintf>
f011a784:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a787:	e8 19 a1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a78c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a78f:	74 17                	je     f011a7a8 <test_kheap_phys_addr+0x1bf>
f011a791:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a798:	83 ec 0c             	sub    $0xc,%esp
f011a79b:	68 b4 c9 12 f0       	push   $0xf012c9b4
f011a7a0:	e8 e6 67 fe ff       	call   f0100f8b <cprintf>
f011a7a5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a7a8:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a7ab:	e8 fc 39 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a7b0:	29 c3                	sub    %eax,%ebx
f011a7b2:	89 d8                	mov    %ebx,%eax
f011a7b4:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a7b9:	77 17                	ja     f011a7d2 <test_kheap_phys_addr+0x1e9>
f011a7bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7c2:	83 ec 0c             	sub    $0xc,%esp
f011a7c5:	68 24 ca 12 f0       	push   $0xf012ca24
f011a7ca:	e8 bc 67 fe ff       	call   f0100f8b <cprintf>
f011a7cf:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a7d2:	e8 d5 39 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a7d7:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a7da:	e8 c6 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a7df:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011a7e2:	83 ec 0c             	sub    $0xc,%esp
f011a7e5:	68 00 04 00 00       	push   $0x400
f011a7ea:	e8 fc e8 fe ff       	call   f01090eb <kmalloc>
f011a7ef:	83 c4 10             	add    $0x10,%esp
f011a7f2:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011a7f8:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011a7fe:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a803:	76 28                	jbe    f011a82d <test_kheap_phys_addr+0x244>
f011a805:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011a80b:	83 ec 0c             	sub    $0xc,%esp
f011a80e:	6a 00                	push   $0x0
f011a810:	e8 a3 e7 fe ff       	call   f0108fb8 <sbrk>
f011a815:	83 c4 10             	add    $0x10,%esp
f011a818:	39 c3                	cmp    %eax,%ebx
f011a81a:	73 11                	jae    f011a82d <test_kheap_phys_addr+0x244>
f011a81c:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011a822:	89 c2                	mov    %eax,%edx
f011a824:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011a829:	39 c2                	cmp    %eax,%edx
f011a82b:	72 17                	jb     f011a844 <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a82d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a834:	83 ec 0c             	sub    $0xc,%esp
f011a837:	68 e0 e4 12 f0       	push   $0xf012e4e0
f011a83c:	e8 4a 67 fe ff       	call   f0100f8b <cprintf>
f011a841:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a844:	e8 5c a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a849:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a84c:	74 17                	je     f011a865 <test_kheap_phys_addr+0x27c>
f011a84e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a855:	83 ec 0c             	sub    $0xc,%esp
f011a858:	68 c0 ca 12 f0       	push   $0xf012cac0
f011a85d:	e8 29 67 fe ff       	call   f0100f8b <cprintf>
f011a862:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a865:	e8 42 39 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a86a:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a86d:	e8 33 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a872:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011a875:	83 ec 0c             	sub    $0xc,%esp
f011a878:	68 00 08 00 00       	push   $0x800
f011a87d:	e8 69 e8 fe ff       	call   f01090eb <kmalloc>
f011a882:	83 c4 10             	add    $0x10,%esp
f011a885:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a88b:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011a891:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a896:	76 28                	jbe    f011a8c0 <test_kheap_phys_addr+0x2d7>
f011a898:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011a89e:	83 ec 0c             	sub    $0xc,%esp
f011a8a1:	6a 00                	push   $0x0
f011a8a3:	e8 10 e7 fe ff       	call   f0108fb8 <sbrk>
f011a8a8:	83 c4 10             	add    $0x10,%esp
f011a8ab:	39 c3                	cmp    %eax,%ebx
f011a8ad:	73 11                	jae    f011a8c0 <test_kheap_phys_addr+0x2d7>
f011a8af:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011a8b5:	89 c2                	mov    %eax,%edx
f011a8b7:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011a8bc:	39 c2                	cmp    %eax,%edx
f011a8be:	72 17                	jb     f011a8d7 <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a8c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8c7:	83 ec 0c             	sub    $0xc,%esp
f011a8ca:	68 6c e5 12 f0       	push   $0xf012e56c
f011a8cf:	e8 b7 66 fe ff       	call   f0100f8b <cprintf>
f011a8d4:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a8d7:	e8 c9 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a8dc:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a8df:	74 17                	je     f011a8f8 <test_kheap_phys_addr+0x30f>
f011a8e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8e8:	83 ec 0c             	sub    $0xc,%esp
f011a8eb:	68 cc cb 12 f0       	push   $0xf012cbcc
f011a8f0:	e8 96 66 fe ff       	call   f0100f8b <cprintf>
f011a8f5:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011a8f8:	e8 af 38 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a8fd:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a900:	e8 a0 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a905:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011a908:	83 ec 0c             	sub    $0xc,%esp
f011a90b:	68 00 06 00 00       	push   $0x600
f011a910:	e8 d6 e7 fe ff       	call   f01090eb <kmalloc>
f011a915:	83 c4 10             	add    $0x10,%esp
f011a918:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011a91e:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011a924:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a929:	76 28                	jbe    f011a953 <test_kheap_phys_addr+0x36a>
f011a92b:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011a931:	83 ec 0c             	sub    $0xc,%esp
f011a934:	6a 00                	push   $0x0
f011a936:	e8 7d e6 fe ff       	call   f0108fb8 <sbrk>
f011a93b:	83 c4 10             	add    $0x10,%esp
f011a93e:	39 c3                	cmp    %eax,%ebx
f011a940:	73 11                	jae    f011a953 <test_kheap_phys_addr+0x36a>
f011a942:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011a948:	89 c2                	mov    %eax,%edx
f011a94a:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011a94f:	39 c2                	cmp    %eax,%edx
f011a951:	72 17                	jb     f011a96a <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a953:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a95a:	83 ec 0c             	sub    $0xc,%esp
f011a95d:	68 f8 e5 12 f0       	push   $0xf012e5f8
f011a962:	e8 24 66 fe ff       	call   f0100f8b <cprintf>
f011a967:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a96a:	e8 36 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a96f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a972:	74 17                	je     f011a98b <test_kheap_phys_addr+0x3a2>
f011a974:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a97b:	83 ec 0c             	sub    $0xc,%esp
f011a97e:	68 d8 cc 12 f0       	push   $0xf012ccd8
f011a983:	e8 03 66 fe ff       	call   f0100f8b <cprintf>
f011a988:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011a98b:	e8 1c 38 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a990:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a993:	e8 0d 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a998:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011a99b:	83 ec 0c             	sub    $0xc,%esp
f011a99e:	68 00 1c 00 00       	push   $0x1c00
f011a9a3:	e8 43 e7 fe ff       	call   f01090eb <kmalloc>
f011a9a8:	83 c4 10             	add    $0x10,%esp
f011a9ab:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a9b1:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011a9b7:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011a9bc:	74 17                	je     f011a9d5 <test_kheap_phys_addr+0x3ec>
f011a9be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9c5:	83 ec 0c             	sub    $0xc,%esp
f011a9c8:	68 90 cd 12 f0       	push   $0xf012cd90
f011a9cd:	e8 b9 65 fe ff       	call   f0100f8b <cprintf>
f011a9d2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a9d5:	e8 cb 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a9da:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a9dd:	74 17                	je     f011a9f6 <test_kheap_phys_addr+0x40d>
f011a9df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9e6:	83 ec 0c             	sub    $0xc,%esp
f011a9e9:	68 e4 cd 12 f0       	push   $0xf012cde4
f011a9ee:	e8 98 65 fe ff       	call   f0100f8b <cprintf>
f011a9f3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a9f6:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a9f9:	e8 ae 37 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011a9fe:	29 c3                	sub    %eax,%ebx
f011aa00:	89 d8                	mov    %ebx,%eax
f011aa02:	83 f8 01             	cmp    $0x1,%eax
f011aa05:	77 17                	ja     f011aa1e <test_kheap_phys_addr+0x435>
f011aa07:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa0e:	83 ec 0c             	sub    $0xc,%esp
f011aa11:	68 54 ce 12 f0       	push   $0xf012ce54
f011aa16:	e8 70 65 fe ff       	call   f0100f8b <cprintf>
f011aa1b:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011aa1e:	e8 89 37 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011aa23:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aa26:	e8 7a 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa2b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011aa2e:	83 ec 0c             	sub    $0xc,%esp
f011aa31:	68 00 fc 2f 00       	push   $0x2ffc00
f011aa36:	e8 b0 e6 fe ff       	call   f01090eb <kmalloc>
f011aa3b:	83 c4 10             	add    $0x10,%esp
f011aa3e:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aa44:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011aa4a:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011aa4f:	74 17                	je     f011aa68 <test_kheap_phys_addr+0x47f>
f011aa51:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa58:	83 ec 0c             	sub    $0xc,%esp
f011aa5b:	68 84 e6 12 f0       	push   $0xf012e684
f011aa60:	e8 26 65 fe ff       	call   f0100f8b <cprintf>
f011aa65:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa68:	e8 38 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa6d:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011aa70:	74 17                	je     f011aa89 <test_kheap_phys_addr+0x4a0>
f011aa72:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa79:	83 ec 0c             	sub    $0xc,%esp
f011aa7c:	68 28 cf 12 f0       	push   $0xf012cf28
f011aa81:	e8 05 65 fe ff       	call   f0100f8b <cprintf>
f011aa86:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aa89:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011aa8c:	e8 1b 37 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011aa91:	29 c3                	sub    %eax,%ebx
f011aa93:	89 d8                	mov    %ebx,%eax
f011aa95:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011aa9a:	77 17                	ja     f011aab3 <test_kheap_phys_addr+0x4ca>
f011aa9c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aaa3:	83 ec 0c             	sub    $0xc,%esp
f011aaa6:	68 d8 e6 12 f0       	push   $0xf012e6d8
f011aaab:	e8 db 64 fe ff       	call   f0100f8b <cprintf>
f011aab0:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011aab3:	e8 f4 36 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011aab8:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aabb:	e8 e5 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aac0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011aac3:	83 ec 0c             	sub    $0xc,%esp
f011aac6:	68 00 fc 5f 00       	push   $0x5ffc00
f011aacb:	e8 1b e6 fe ff       	call   f01090eb <kmalloc>
f011aad0:	83 c4 10             	add    $0x10,%esp
f011aad3:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aad9:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011aadf:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011aae4:	74 17                	je     f011aafd <test_kheap_phys_addr+0x514>
f011aae6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aaed:	83 ec 0c             	sub    $0xc,%esp
f011aaf0:	68 20 e7 12 f0       	push   $0xf012e720
f011aaf5:	e8 91 64 fe ff       	call   f0100f8b <cprintf>
f011aafa:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aafd:	e8 a3 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ab02:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ab05:	74 17                	je     f011ab1e <test_kheap_phys_addr+0x535>
f011ab07:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab0e:	83 ec 0c             	sub    $0xc,%esp
f011ab11:	68 24 d0 12 f0       	push   $0xf012d024
f011ab16:	e8 70 64 fe ff       	call   f0100f8b <cprintf>
f011ab1b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ab1e:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ab21:	e8 86 36 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011ab26:	29 c3                	sub    %eax,%ebx
f011ab28:	89 d8                	mov    %ebx,%eax
f011ab2a:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ab2f:	77 17                	ja     f011ab48 <test_kheap_phys_addr+0x55f>
f011ab31:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab38:	83 ec 0c             	sub    $0xc,%esp
f011ab3b:	68 74 e7 12 f0       	push   $0xf012e774
f011ab40:	e8 46 64 fe ff       	call   f0100f8b <cprintf>
f011ab45:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011ab48:	e8 5f 36 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011ab4d:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ab50:	e8 50 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ab55:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011ab58:	83 ec 0c             	sub    $0xc,%esp
f011ab5b:	68 00 38 00 00       	push   $0x3800
f011ab60:	e8 86 e5 fe ff       	call   f01090eb <kmalloc>
f011ab65:	83 c4 10             	add    $0x10,%esp
f011ab68:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ab6e:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011ab74:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011ab79:	74 17                	je     f011ab92 <test_kheap_phys_addr+0x5a9>
f011ab7b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab82:	83 ec 0c             	sub    $0xc,%esp
f011ab85:	68 bc e7 12 f0       	push   $0xf012e7bc
f011ab8a:	e8 fc 63 fe ff       	call   f0100f8b <cprintf>
f011ab8f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab92:	e8 0e 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ab97:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ab9a:	74 17                	je     f011abb3 <test_kheap_phys_addr+0x5ca>
f011ab9c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aba3:	83 ec 0c             	sub    $0xc,%esp
f011aba6:	68 10 e8 12 f0       	push   $0xf012e810
f011abab:	e8 db 63 fe ff       	call   f0100f8b <cprintf>
f011abb0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011abb3:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011abb6:	e8 f1 35 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011abbb:	29 c3                	sub    %eax,%ebx
f011abbd:	89 d8                	mov    %ebx,%eax
f011abbf:	83 f8 03             	cmp    $0x3,%eax
f011abc2:	77 17                	ja     f011abdb <test_kheap_phys_addr+0x5f2>
f011abc4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abcb:	83 ec 0c             	sub    $0xc,%esp
f011abce:	68 80 e8 12 f0       	push   $0xf012e880
f011abd3:	e8 b3 63 fe ff       	call   f0100f8b <cprintf>
f011abd8:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011abdb:	83 ec 0c             	sub    $0xc,%esp
f011abde:	68 c8 e8 12 f0       	push   $0xf012e8c8
f011abe3:	e8 a3 63 fe ff       	call   f0100f8b <cprintf>
f011abe8:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011abeb:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011abf2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011abf9:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011ac00:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011ac05:	05 00 10 00 00       	add    $0x1000,%eax
f011ac0a:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011ac0d:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ac10:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ac13:	eb 2e                	jmp    f011ac43 <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011ac15:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011ac18:	8d 43 01             	lea    0x1(%ebx),%eax
f011ac1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ac1e:	83 ec 0c             	sub    $0xc,%esp
f011ac21:	ff 75 e8             	pushl  -0x18(%ebp)
f011ac24:	e8 08 e8 fe ff       	call   f0109431 <kheap_physical_address>
f011ac29:	83 c4 10             	add    $0x10,%esp
f011ac2c:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011ac33:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011ac36:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ac39:	01 d0                	add    %edx,%eax
f011ac3b:	05 00 10 00 00       	add    $0x1000,%eax
f011ac40:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ac43:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ac46:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011ac49:	72 ca                	jb     f011ac15 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011ac4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ac4e:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011ac51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011ac58:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ac5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ac5e:	e9 ce 00 00 00       	jmp    f011ad31 <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ac63:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011ac68:	83 ec 04             	sub    $0x4,%esp
f011ac6b:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011ac71:	52                   	push   %edx
f011ac72:	ff 75 e8             	pushl  -0x18(%ebp)
f011ac75:	50                   	push   %eax
f011ac76:	e8 74 d7 fe ff       	call   f01083ef <get_page_table>
f011ac7b:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ac7e:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011ac84:	85 c0                	test   %eax,%eax
f011ac86:	75 1e                	jne    f011aca6 <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ac88:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac8f:	83 ec 04             	sub    $0x4,%esp
f011ac92:	68 14 e9 12 f0       	push   $0xf012e914
f011ac97:	68 e8 05 00 00       	push   $0x5e8
f011ac9c:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011aca1:	e8 93 56 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011aca6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011aca9:	c1 e8 0c             	shr    $0xc,%eax
f011acac:	25 ff 03 00 00       	and    $0x3ff,%eax
f011acb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011acb4:	eb 62                	jmp    f011ad18 <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011acb6:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011acbc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011acbf:	c1 e2 02             	shl    $0x2,%edx
f011acc2:	01 d0                	add    %edx,%eax
f011acc4:	8b 00                	mov    (%eax),%eax
f011acc6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011accb:	89 c2                	mov    %eax,%edx
f011accd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011acd0:	25 ff 0f 00 00       	and    $0xfff,%eax
f011acd5:	01 c2                	add    %eax,%edx
f011acd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011acda:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011ace1:	39 c2                	cmp    %eax,%edx
f011ace3:	74 1d                	je     f011ad02 <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011ace5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ace9:	74 17                	je     f011ad02 <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011aceb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acf2:	83 ec 0c             	sub    $0xc,%esp
f011acf5:	68 74 e9 12 f0       	push   $0xf012e974
f011acfa:	e8 8c 62 fe ff       	call   f0100f8b <cprintf>
f011acff:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011ad02:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011ad05:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ad08:	01 d0                	add    %edx,%eax
f011ad0a:	05 00 10 00 00       	add    $0x1000,%eax
f011ad0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011ad12:	ff 45 e4             	incl   -0x1c(%ebp)
f011ad15:	ff 45 f4             	incl   -0xc(%ebp)
f011ad18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ad1b:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011ad1e:	7d 11                	jge    f011ad31 <test_kheap_phys_addr+0x748>
f011ad20:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011ad27:	7f 08                	jg     f011ad31 <test_kheap_phys_addr+0x748>
f011ad29:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ad2c:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011ad2f:	72 85                	jb     f011acb6 <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011ad31:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ad34:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011ad37:	0f 82 26 ff ff ff    	jb     f011ac63 <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011ad3d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ad41:	74 04                	je     f011ad47 <test_kheap_phys_addr+0x75e>
f011ad43:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011ad47:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011ad4e:	83 ec 0c             	sub    $0xc,%esp
f011ad51:	68 98 e9 12 f0       	push   $0xf012e998
f011ad56:	e8 30 62 fe ff       	call   f0100f8b <cprintf>
f011ad5b:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011ad5e:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011ad65:	e9 b0 00 00 00       	jmp    f011ae1a <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011ad6a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ad6d:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011ad74:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011ad77:	83 ec 0c             	sub    $0xc,%esp
f011ad7a:	ff 75 90             	pushl  -0x70(%ebp)
f011ad7d:	e8 af e6 fe ff       	call   f0109431 <kheap_physical_address>
f011ad82:	83 c4 10             	add    $0x10,%esp
f011ad85:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ad88:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011ad8d:	83 ec 04             	sub    $0x4,%esp
f011ad90:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011ad96:	52                   	push   %edx
f011ad97:	ff 75 90             	pushl  -0x70(%ebp)
f011ad9a:	50                   	push   %eax
f011ad9b:	e8 4f d6 fe ff       	call   f01083ef <get_page_table>
f011ada0:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ada3:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011ada9:	85 c0                	test   %eax,%eax
f011adab:	75 1e                	jne    f011adcb <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011adad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011adb4:	83 ec 04             	sub    $0x4,%esp
f011adb7:	68 e8 e9 12 f0       	push   $0xf012e9e8
f011adbc:	68 05 06 00 00       	push   $0x605
f011adc1:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011adc6:	e8 6e 55 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011adcb:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011add1:	8b 55 90             	mov    -0x70(%ebp),%edx
f011add4:	c1 ea 0c             	shr    $0xc,%edx
f011add7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011addd:	c1 e2 02             	shl    $0x2,%edx
f011ade0:	01 d0                	add    %edx,%eax
f011ade2:	8b 00                	mov    (%eax),%eax
f011ade4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ade9:	89 c2                	mov    %eax,%edx
f011adeb:	8b 45 90             	mov    -0x70(%ebp),%eax
f011adee:	25 ff 0f 00 00       	and    $0xfff,%eax
f011adf3:	01 d0                	add    %edx,%eax
f011adf5:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011adf8:	74 1d                	je     f011ae17 <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011adfa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011adfe:	74 17                	je     f011ae17 <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011ae00:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae07:	83 ec 0c             	sub    $0xc,%esp
f011ae0a:	68 48 ea 12 f0       	push   $0xf012ea48
f011ae0f:	e8 77 61 fe ff       	call   f0100f8b <cprintf>
f011ae14:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011ae17:	ff 45 e0             	incl   -0x20(%ebp)
f011ae1a:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011ae1e:	0f 8e 46 ff ff ff    	jle    f011ad6a <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011ae24:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ae28:	74 04                	je     f011ae2e <test_kheap_phys_addr+0x845>
f011ae2a:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011ae2e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011ae35:	83 ec 0c             	sub    $0xc,%esp
f011ae38:	68 6c ea 12 f0       	push   $0xf012ea6c
f011ae3d:	e8 49 61 fe ff       	call   f0100f8b <cprintf>
f011ae42:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011ae45:	e8 62 33 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011ae4a:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011ae4d:	e8 53 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ae52:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011ae55:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011ae5b:	83 ec 0c             	sub    $0xc,%esp
f011ae5e:	50                   	push   %eax
f011ae5f:	e8 e7 e4 fe ff       	call   f010934b <kfree>
f011ae64:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae67:	e8 39 9a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ae6c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ae6f:	74 17                	je     f011ae88 <test_kheap_phys_addr+0x89f>
f011ae71:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae78:	83 ec 0c             	sub    $0xc,%esp
f011ae7b:	68 58 d5 12 f0       	push   $0xf012d558
f011ae80:	e8 06 61 fe ff       	call   f0100f8b <cprintf>
f011ae85:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011ae88:	e8 1f 33 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011ae8d:	89 c2                	mov    %eax,%edx
f011ae8f:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ae92:	29 c2                	sub    %eax,%edx
f011ae94:	89 d0                	mov    %edx,%eax
f011ae96:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ae9b:	77 17                	ja     f011aeb4 <test_kheap_phys_addr+0x8cb>
f011ae9d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aea4:	83 ec 0c             	sub    $0xc,%esp
f011aea7:	68 94 ea 12 f0       	push   $0xf012ea94
f011aeac:	e8 da 60 fe ff       	call   f0100f8b <cprintf>
f011aeb1:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011aeb4:	e8 f3 32 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011aeb9:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aebc:	e8 e4 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aec1:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011aec4:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011aeca:	83 ec 0c             	sub    $0xc,%esp
f011aecd:	50                   	push   %eax
f011aece:	e8 78 e4 fe ff       	call   f010934b <kfree>
f011aed3:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aed6:	e8 ca 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aedb:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011aede:	74 17                	je     f011aef7 <test_kheap_phys_addr+0x90e>
f011aee0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aee7:	83 ec 0c             	sub    $0xc,%esp
f011aeea:	68 98 d6 12 f0       	push   $0xf012d698
f011aeef:	e8 97 60 fe ff       	call   f0100f8b <cprintf>
f011aef4:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011aef7:	e8 b0 32 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011aefc:	89 c2                	mov    %eax,%edx
f011aefe:	8b 45 88             	mov    -0x78(%ebp),%eax
f011af01:	29 c2                	sub    %eax,%edx
f011af03:	89 d0                	mov    %edx,%eax
f011af05:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011af0a:	77 17                	ja     f011af23 <test_kheap_phys_addr+0x93a>
f011af0c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af13:	83 ec 0c             	sub    $0xc,%esp
f011af16:	68 d0 ea 12 f0       	push   $0xf012ead0
f011af1b:	e8 6b 60 fe ff       	call   f0100f8b <cprintf>
f011af20:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011af23:	e8 84 32 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011af28:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011af2b:	e8 75 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af30:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011af33:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011af39:	83 ec 0c             	sub    $0xc,%esp
f011af3c:	50                   	push   %eax
f011af3d:	e8 09 e4 fe ff       	call   f010934b <kfree>
f011af42:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af45:	e8 5b 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af4a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011af4d:	74 17                	je     f011af66 <test_kheap_phys_addr+0x97d>
f011af4f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af56:	83 ec 0c             	sub    $0xc,%esp
f011af59:	68 a4 d7 12 f0       	push   $0xf012d7a4
f011af5e:	e8 28 60 fe ff       	call   f0100f8b <cprintf>
f011af63:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011af66:	e8 41 32 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011af6b:	89 c2                	mov    %eax,%edx
f011af6d:	8b 45 88             	mov    -0x78(%ebp),%eax
f011af70:	29 c2                	sub    %eax,%edx
f011af72:	89 d0                	mov    %edx,%eax
f011af74:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011af79:	77 17                	ja     f011af92 <test_kheap_phys_addr+0x9a9>
f011af7b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af82:	83 ec 0c             	sub    $0xc,%esp
f011af85:	68 0c eb 12 f0       	push   $0xf012eb0c
f011af8a:	e8 fc 5f fe ff       	call   f0100f8b <cprintf>
f011af8f:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011af92:	83 ec 0c             	sub    $0xc,%esp
f011af95:	68 48 eb 12 f0       	push   $0xf012eb48
f011af9a:	e8 ec 5f fe ff       	call   f0100f8b <cprintf>
f011af9f:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011afa2:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011afa9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011afb0:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011afb7:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011afba:	8b 15 d8 ed 17 f0    	mov    0xf017edd8,%edx
f011afc0:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011afc6:	01 d0                	add    %edx,%eax
f011afc8:	05 00 10 00 00       	add    $0x1000,%eax
f011afcd:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011afd3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011afd9:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011afdc:	eb 25                	jmp    f011b003 <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011afde:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011afe1:	8d 43 01             	lea    0x1(%ebx),%eax
f011afe4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011afe7:	83 ec 0c             	sub    $0xc,%esp
f011afea:	ff 75 d8             	pushl  -0x28(%ebp)
f011afed:	e8 3f e4 fe ff       	call   f0109431 <kheap_physical_address>
f011aff2:	83 c4 10             	add    $0x10,%esp
f011aff5:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011affc:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011b003:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b006:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b009:	72 d3                	jb     f011afde <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b00b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b00e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011b014:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b01b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b021:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b024:	e9 f4 00 00 00       	jmp    f011b11d <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b029:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011b02e:	83 ec 04             	sub    $0x4,%esp
f011b031:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b037:	52                   	push   %edx
f011b038:	ff 75 d8             	pushl  -0x28(%ebp)
f011b03b:	50                   	push   %eax
f011b03c:	e8 ae d3 fe ff       	call   f01083ef <get_page_table>
f011b041:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b044:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b04a:	85 c0                	test   %eax,%eax
f011b04c:	75 24                	jne    f011b072 <test_kheap_phys_addr+0xa89>
				if (correct)
f011b04e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b052:	74 1e                	je     f011b072 <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b054:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b05b:	83 ec 04             	sub    $0x4,%esp
f011b05e:	68 98 eb 12 f0       	push   $0xf012eb98
f011b063:	68 43 06 00 00       	push   $0x643
f011b068:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011b06d:	e8 c7 52 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b072:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b075:	c1 e8 0c             	shr    $0xc,%eax
f011b078:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b07d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b080:	eb 7b                	jmp    f011b0fd <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011b082:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011b089:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b08f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b092:	c1 e2 02             	shl    $0x2,%edx
f011b095:	01 d0                	add    %edx,%eax
f011b097:	8b 00                	mov    (%eax),%eax
f011b099:	83 e0 01             	and    $0x1,%eax
f011b09c:	85 c0                	test   %eax,%eax
f011b09e:	74 24                	je     f011b0c4 <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011b0a0:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b0a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b0a9:	c1 e2 02             	shl    $0x2,%edx
f011b0ac:	01 d0                	add    %edx,%eax
f011b0ae:	8b 00                	mov    (%eax),%eax
f011b0b0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b0b5:	89 c2                	mov    %eax,%edx
f011b0b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b0ba:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b0bf:	01 d0                	add    %edx,%eax
f011b0c1:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011b0c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b0c7:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b0ce:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011b0d1:	74 1d                	je     f011b0f0 <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b0d3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b0d7:	74 17                	je     f011b0f0 <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011b0d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0e0:	83 ec 0c             	sub    $0xc,%esp
f011b0e3:	68 f8 eb 12 f0       	push   $0xf012ebf8
f011b0e8:	e8 9e 5e fe ff       	call   f0100f8b <cprintf>
f011b0ed:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011b0f0:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b0f7:	ff 45 d4             	incl   -0x2c(%ebp)
f011b0fa:	ff 45 f4             	incl   -0xc(%ebp)
f011b0fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b100:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011b106:	7d 15                	jge    f011b11d <test_kheap_phys_addr+0xb34>
f011b108:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011b10f:	7f 0c                	jg     f011b11d <test_kheap_phys_addr+0xb34>
f011b111:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b114:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b117:	0f 82 65 ff ff ff    	jb     f011b082 <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b11d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b120:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b123:	0f 82 00 ff ff ff    	jb     f011b029 <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011b129:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b12d:	74 04                	je     f011b133 <test_kheap_phys_addr+0xb4a>
f011b12f:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011b133:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011b13a:	83 ec 0c             	sub    $0xc,%esp
f011b13d:	68 1c ec 12 f0       	push   $0xf012ec1c
f011b142:	e8 44 5e fe ff       	call   f0100f8b <cprintf>
f011b147:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011b14a:	83 ec 0c             	sub    $0xc,%esp
f011b14d:	6a 00                	push   $0x0
f011b14f:	e8 64 de fe ff       	call   f0108fb8 <sbrk>
f011b154:	83 c4 10             	add    $0x10,%esp
f011b157:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b15c:	77 17                	ja     f011b175 <test_kheap_phys_addr+0xb8c>
f011b15e:	83 ec 04             	sub    $0x4,%esp
f011b161:	68 74 ec 12 f0       	push   $0xf012ec74
f011b166:	68 5e 06 00 00       	push   $0x65e
f011b16b:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011b170:	e8 c4 51 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b175:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011b17c:	e9 af 00 00 00       	jmp    f011b230 <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011b181:	83 ec 0c             	sub    $0xc,%esp
f011b184:	ff 75 d0             	pushl  -0x30(%ebp)
f011b187:	e8 a5 e2 fe ff       	call   f0109431 <kheap_physical_address>
f011b18c:	83 c4 10             	add    $0x10,%esp
f011b18f:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b195:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011b19a:	83 ec 04             	sub    $0x4,%esp
f011b19d:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011b1a3:	52                   	push   %edx
f011b1a4:	ff 75 d0             	pushl  -0x30(%ebp)
f011b1a7:	50                   	push   %eax
f011b1a8:	e8 42 d2 fe ff       	call   f01083ef <get_page_table>
f011b1ad:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b1b0:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b1b6:	85 c0                	test   %eax,%eax
f011b1b8:	75 24                	jne    f011b1de <test_kheap_phys_addr+0xbf5>
				if (correct)
f011b1ba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b1be:	74 1e                	je     f011b1de <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b1c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1c7:	83 ec 04             	sub    $0x4,%esp
f011b1ca:	68 90 ec 12 f0       	push   $0xf012ec90
f011b1cf:	68 66 06 00 00       	push   $0x666
f011b1d4:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011b1d9:	e8 5b 51 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b1de:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b1e4:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b1e7:	c1 ea 0c             	shr    $0xc,%edx
f011b1ea:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b1f0:	c1 e2 02             	shl    $0x2,%edx
f011b1f3:	01 d0                	add    %edx,%eax
f011b1f5:	8b 00                	mov    (%eax),%eax
f011b1f7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b1fc:	89 c2                	mov    %eax,%edx
f011b1fe:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b201:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b206:	01 d0                	add    %edx,%eax
f011b208:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011b20e:	74 1d                	je     f011b22d <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b210:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b214:	74 17                	je     f011b22d <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011b216:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b21d:	83 ec 0c             	sub    $0xc,%esp
f011b220:	68 f0 ec 12 f0       	push   $0xf012ecf0
f011b225:	e8 61 5d fe ff       	call   f0100f8b <cprintf>
f011b22a:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b22d:	ff 45 d0             	incl   -0x30(%ebp)
f011b230:	83 ec 0c             	sub    $0xc,%esp
f011b233:	6a 00                	push   $0x0
f011b235:	e8 7e dd fe ff       	call   f0108fb8 <sbrk>
f011b23a:	83 c4 10             	add    $0x10,%esp
f011b23d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011b240:	0f 87 3b ff ff ff    	ja     f011b181 <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011b246:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b24a:	74 04                	je     f011b250 <test_kheap_phys_addr+0xc67>
f011b24c:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b250:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011b257:	83 ec 0c             	sub    $0xc,%esp
f011b25a:	68 14 ed 12 f0       	push   $0xf012ed14
f011b25f:	e8 27 5d fe ff       	call   f0100f8b <cprintf>
f011b264:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011b267:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011b26e:	10 00 f9 
		i = 0;
f011b271:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b278:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b27e:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011b281:	eb 0a                	jmp    f011b28d <test_kheap_phys_addr+0xca4>
		{
			i++;
f011b283:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b286:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011b28d:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011b294:	76 ed                	jbe    f011b283 <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011b296:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b299:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011b29f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011b2a6:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b2ac:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011b2af:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011b2b6:	e9 cb 00 00 00       	jmp    f011b386 <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011b2bb:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011b2be:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011b2c3:	83 ec 04             	sub    $0x4,%esp
f011b2c6:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011b2cc:	51                   	push   %ecx
f011b2cd:	52                   	push   %edx
f011b2ce:	50                   	push   %eax
f011b2cf:	e8 1b d1 fe ff       	call   f01083ef <get_page_table>
f011b2d4:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b2d7:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011b2dd:	85 c0                	test   %eax,%eax
f011b2df:	75 24                	jne    f011b305 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011b2e1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b2e5:	74 1e                	je     f011b305 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b2e7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2ee:	83 ec 04             	sub    $0x4,%esp
f011b2f1:	68 50 ed 12 f0       	push   $0xf012ed50
f011b2f6:	68 88 06 00 00       	push   $0x688
f011b2fb:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011b300:	e8 34 50 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011b305:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011b30c:	eb 59                	jmp    f011b367 <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011b30e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b311:	c1 e0 0c             	shl    $0xc,%eax
f011b314:	89 c2                	mov    %eax,%edx
f011b316:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b31c:	01 d0                	add    %edx,%eax
f011b31e:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011b324:	83 ec 0c             	sub    $0xc,%esp
f011b327:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011b32d:	e8 ff e0 fe ff       	call   f0109431 <kheap_physical_address>
f011b332:	83 c4 10             	add    $0x10,%esp
f011b335:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011b33b:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011b342:	74 1d                	je     f011b361 <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b344:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b348:	74 17                	je     f011b361 <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011b34a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b351:	83 ec 0c             	sub    $0xc,%esp
f011b354:	68 b0 ed 12 f0       	push   $0xf012edb0
f011b359:	e8 2d 5c fe ff       	call   f0100f8b <cprintf>
f011b35e:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011b361:	ff 45 c8             	incl   -0x38(%ebp)
f011b364:	ff 45 f4             	incl   -0xc(%ebp)
f011b367:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b36a:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011b370:	7d 09                	jge    f011b37b <test_kheap_phys_addr+0xd92>
f011b372:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011b379:	7e 93                	jle    f011b30e <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011b37b:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011b382:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011b386:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011b38a:	0f 88 2b ff ff ff    	js     f011b2bb <test_kheap_phys_addr+0xcd2>
f011b390:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011b394:	7f 0d                	jg     f011b3a3 <test_kheap_phys_addr+0xdba>
f011b396:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011b39d:	0f 86 18 ff ff ff    	jbe    f011b2bb <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011b3a3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b3a7:	74 04                	je     f011b3ad <test_kheap_phys_addr+0xdc4>
f011b3a9:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011b3ad:	83 ec 08             	sub    $0x8,%esp
f011b3b0:	ff 75 f0             	pushl  -0x10(%ebp)
f011b3b3:	68 d4 ed 12 f0       	push   $0xf012edd4
f011b3b8:	e8 ce 5b fe ff       	call   f0100f8b <cprintf>
f011b3bd:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b3c0:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011b3c5:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b3c8:	5b                   	pop    %ebx
f011b3c9:	5f                   	pop    %edi
f011b3ca:	5d                   	pop    %ebp
f011b3cb:	c3                   	ret    

f011b3cc <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011b3cc:	55                   	push   %ebp
f011b3cd:	89 e5                	mov    %esp,%ebp
f011b3cf:	57                   	push   %edi
f011b3d0:	56                   	push   %esi
f011b3d1:	53                   	push   %ebx
f011b3d2:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011b3d8:	89 e0                	mov    %esp,%eax
f011b3da:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b3dc:	83 ec 0c             	sub    $0xc,%esp
f011b3df:	68 48 a7 12 f0       	push   $0xf012a748
f011b3e4:	e8 a2 5b fe ff       	call   f0100f8b <cprintf>
f011b3e9:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b3ec:	83 ec 0c             	sub    $0xc,%esp
f011b3ef:	68 78 a7 12 f0       	push   $0xf012a778
f011b3f4:	e8 92 5b fe ff       	call   f0100f8b <cprintf>
f011b3f9:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b3fc:	83 ec 0c             	sub    $0xc,%esp
f011b3ff:	68 48 a7 12 f0       	push   $0xf012a748
f011b404:	e8 82 5b fe ff       	call   f0100f8b <cprintf>
f011b409:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011b40c:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011b410:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011b414:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011b41a:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011b420:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011b427:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011b42e:	e8 79 2d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b433:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011b436:	83 ec 0c             	sub    $0xc,%esp
f011b439:	68 b0 e4 12 f0       	push   $0xf012e4b0
f011b43e:	e8 48 5b fe ff       	call   f0100f8b <cprintf>
f011b443:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011b446:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011b44c:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b451:	b8 00 00 00 00       	mov    $0x0,%eax
f011b456:	89 d7                	mov    %edx,%edi
f011b458:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011b45a:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011b460:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b465:	b8 00 00 00 00       	mov    $0x0,%eax
f011b46a:	89 d7                	mov    %edx,%edi
f011b46c:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011b46e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011b475:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011b47c:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b482:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b487:	b8 00 00 00 00       	mov    $0x0,%eax
f011b48c:	89 d7                	mov    %edx,%edi
f011b48e:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b490:	e8 17 2d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b495:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b498:	e8 08 94 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b49d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b4a0:	83 ec 0c             	sub    $0xc,%esp
f011b4a3:	68 00 fc 1f 00       	push   $0x1ffc00
f011b4a8:	e8 3e dc fe ff       	call   f01090eb <kmalloc>
f011b4ad:	83 c4 10             	add    $0x10,%esp
f011b4b0:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b4b6:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b4bc:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b4c1:	74 17                	je     f011b4da <test_kheap_virt_addr+0x10e>
f011b4c3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b4ca:	83 ec 0c             	sub    $0xc,%esp
f011b4cd:	68 54 c8 12 f0       	push   $0xf012c854
f011b4d2:	e8 b4 5a fe ff       	call   f0100f8b <cprintf>
f011b4d7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b4da:	e8 c6 93 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b4df:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b4e2:	74 17                	je     f011b4fb <test_kheap_virt_addr+0x12f>
f011b4e4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b4eb:	83 ec 0c             	sub    $0xc,%esp
f011b4ee:	68 a8 c8 12 f0       	push   $0xf012c8a8
f011b4f3:	e8 93 5a fe ff       	call   f0100f8b <cprintf>
f011b4f8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b4fb:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b4fe:	e8 a9 2c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b503:	29 c3                	sub    %eax,%ebx
f011b505:	89 d8                	mov    %ebx,%eax
f011b507:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b50c:	77 17                	ja     f011b525 <test_kheap_virt_addr+0x159>
f011b50e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b515:	83 ec 0c             	sub    $0xc,%esp
f011b518:	68 18 c9 12 f0       	push   $0xf012c918
f011b51d:	e8 69 5a fe ff       	call   f0100f8b <cprintf>
f011b522:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b525:	e8 82 2c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b52a:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b52d:	e8 73 93 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b532:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b535:	83 ec 0c             	sub    $0xc,%esp
f011b538:	68 00 fc 1f 00       	push   $0x1ffc00
f011b53d:	e8 a9 db fe ff       	call   f01090eb <kmalloc>
f011b542:	83 c4 10             	add    $0x10,%esp
f011b545:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b54b:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b551:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011b556:	74 17                	je     f011b56f <test_kheap_virt_addr+0x1a3>
f011b558:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b55f:	83 ec 0c             	sub    $0xc,%esp
f011b562:	68 60 c9 12 f0       	push   $0xf012c960
f011b567:	e8 1f 5a fe ff       	call   f0100f8b <cprintf>
f011b56c:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b56f:	e8 31 93 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b574:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b577:	74 17                	je     f011b590 <test_kheap_virt_addr+0x1c4>
f011b579:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b580:	83 ec 0c             	sub    $0xc,%esp
f011b583:	68 b4 c9 12 f0       	push   $0xf012c9b4
f011b588:	e8 fe 59 fe ff       	call   f0100f8b <cprintf>
f011b58d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b590:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b593:	e8 14 2c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b598:	29 c3                	sub    %eax,%ebx
f011b59a:	89 d8                	mov    %ebx,%eax
f011b59c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b5a1:	77 17                	ja     f011b5ba <test_kheap_virt_addr+0x1ee>
f011b5a3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b5aa:	83 ec 0c             	sub    $0xc,%esp
f011b5ad:	68 24 ca 12 f0       	push   $0xf012ca24
f011b5b2:	e8 d4 59 fe ff       	call   f0100f8b <cprintf>
f011b5b7:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011b5ba:	e8 ed 2b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b5bf:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b5c2:	e8 de 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b5c7:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011b5ca:	83 ec 0c             	sub    $0xc,%esp
f011b5cd:	68 00 04 00 00       	push   $0x400
f011b5d2:	e8 14 db fe ff       	call   f01090eb <kmalloc>
f011b5d7:	83 c4 10             	add    $0x10,%esp
f011b5da:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011b5e0:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b5e6:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b5eb:	76 28                	jbe    f011b615 <test_kheap_virt_addr+0x249>
f011b5ed:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011b5f3:	83 ec 0c             	sub    $0xc,%esp
f011b5f6:	6a 00                	push   $0x0
f011b5f8:	e8 bb d9 fe ff       	call   f0108fb8 <sbrk>
f011b5fd:	83 c4 10             	add    $0x10,%esp
f011b600:	39 c3                	cmp    %eax,%ebx
f011b602:	73 11                	jae    f011b615 <test_kheap_virt_addr+0x249>
f011b604:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b60a:	89 c2                	mov    %eax,%edx
f011b60c:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011b611:	39 c2                	cmp    %eax,%edx
f011b613:	72 17                	jb     f011b62c <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b615:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b61c:	83 ec 0c             	sub    $0xc,%esp
f011b61f:	68 e0 e4 12 f0       	push   $0xf012e4e0
f011b624:	e8 62 59 fe ff       	call   f0100f8b <cprintf>
f011b629:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b62c:	e8 74 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b631:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b634:	74 17                	je     f011b64d <test_kheap_virt_addr+0x281>
f011b636:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b63d:	83 ec 0c             	sub    $0xc,%esp
f011b640:	68 c0 ca 12 f0       	push   $0xf012cac0
f011b645:	e8 41 59 fe ff       	call   f0100f8b <cprintf>
f011b64a:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011b64d:	e8 5a 2b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b652:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b655:	e8 4b 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b65a:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011b65d:	83 ec 0c             	sub    $0xc,%esp
f011b660:	68 00 08 00 00       	push   $0x800
f011b665:	e8 81 da fe ff       	call   f01090eb <kmalloc>
f011b66a:	83 c4 10             	add    $0x10,%esp
f011b66d:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b673:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b679:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b67e:	76 28                	jbe    f011b6a8 <test_kheap_virt_addr+0x2dc>
f011b680:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011b686:	83 ec 0c             	sub    $0xc,%esp
f011b689:	6a 00                	push   $0x0
f011b68b:	e8 28 d9 fe ff       	call   f0108fb8 <sbrk>
f011b690:	83 c4 10             	add    $0x10,%esp
f011b693:	39 c3                	cmp    %eax,%ebx
f011b695:	73 11                	jae    f011b6a8 <test_kheap_virt_addr+0x2dc>
f011b697:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b69d:	89 c2                	mov    %eax,%edx
f011b69f:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011b6a4:	39 c2                	cmp    %eax,%edx
f011b6a6:	72 17                	jb     f011b6bf <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b6a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b6af:	83 ec 0c             	sub    $0xc,%esp
f011b6b2:	68 6c e5 12 f0       	push   $0xf012e56c
f011b6b7:	e8 cf 58 fe ff       	call   f0100f8b <cprintf>
f011b6bc:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b6bf:	e8 e1 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b6c4:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b6c7:	74 17                	je     f011b6e0 <test_kheap_virt_addr+0x314>
f011b6c9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b6d0:	83 ec 0c             	sub    $0xc,%esp
f011b6d3:	68 cc cb 12 f0       	push   $0xf012cbcc
f011b6d8:	e8 ae 58 fe ff       	call   f0100f8b <cprintf>
f011b6dd:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b6e0:	e8 c7 2a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b6e5:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b6e8:	e8 b8 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b6ed:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011b6f0:	83 ec 0c             	sub    $0xc,%esp
f011b6f3:	68 00 06 00 00       	push   $0x600
f011b6f8:	e8 ee d9 fe ff       	call   f01090eb <kmalloc>
f011b6fd:	83 c4 10             	add    $0x10,%esp
f011b700:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b706:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b70c:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b711:	76 28                	jbe    f011b73b <test_kheap_virt_addr+0x36f>
f011b713:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011b719:	83 ec 0c             	sub    $0xc,%esp
f011b71c:	6a 00                	push   $0x0
f011b71e:	e8 95 d8 fe ff       	call   f0108fb8 <sbrk>
f011b723:	83 c4 10             	add    $0x10,%esp
f011b726:	39 c3                	cmp    %eax,%ebx
f011b728:	73 11                	jae    f011b73b <test_kheap_virt_addr+0x36f>
f011b72a:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b730:	89 c2                	mov    %eax,%edx
f011b732:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011b737:	39 c2                	cmp    %eax,%edx
f011b739:	72 17                	jb     f011b752 <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b73b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b742:	83 ec 0c             	sub    $0xc,%esp
f011b745:	68 f8 e5 12 f0       	push   $0xf012e5f8
f011b74a:	e8 3c 58 fe ff       	call   f0100f8b <cprintf>
f011b74f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b752:	e8 4e 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b757:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b75a:	74 17                	je     f011b773 <test_kheap_virt_addr+0x3a7>
f011b75c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b763:	83 ec 0c             	sub    $0xc,%esp
f011b766:	68 d8 cc 12 f0       	push   $0xf012ccd8
f011b76b:	e8 1b 58 fe ff       	call   f0100f8b <cprintf>
f011b770:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b773:	e8 34 2a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b778:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b77b:	e8 25 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b780:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b783:	83 ec 0c             	sub    $0xc,%esp
f011b786:	68 00 1c 00 00       	push   $0x1c00
f011b78b:	e8 5b d9 fe ff       	call   f01090eb <kmalloc>
f011b790:	83 c4 10             	add    $0x10,%esp
f011b793:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b799:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b79f:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b7a4:	74 17                	je     f011b7bd <test_kheap_virt_addr+0x3f1>
f011b7a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b7ad:	83 ec 0c             	sub    $0xc,%esp
f011b7b0:	68 90 cd 12 f0       	push   $0xf012cd90
f011b7b5:	e8 d1 57 fe ff       	call   f0100f8b <cprintf>
f011b7ba:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b7bd:	e8 e3 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b7c2:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b7c5:	74 17                	je     f011b7de <test_kheap_virt_addr+0x412>
f011b7c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b7ce:	83 ec 0c             	sub    $0xc,%esp
f011b7d1:	68 e4 cd 12 f0       	push   $0xf012cde4
f011b7d6:	e8 b0 57 fe ff       	call   f0100f8b <cprintf>
f011b7db:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b7de:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b7e1:	e8 c6 29 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b7e6:	29 c3                	sub    %eax,%ebx
f011b7e8:	89 d8                	mov    %ebx,%eax
f011b7ea:	83 f8 01             	cmp    $0x1,%eax
f011b7ed:	77 17                	ja     f011b806 <test_kheap_virt_addr+0x43a>
f011b7ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b7f6:	83 ec 0c             	sub    $0xc,%esp
f011b7f9:	68 54 ce 12 f0       	push   $0xf012ce54
f011b7fe:	e8 88 57 fe ff       	call   f0100f8b <cprintf>
f011b803:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b806:	e8 a1 29 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b80b:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b80e:	e8 92 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b813:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b816:	83 ec 0c             	sub    $0xc,%esp
f011b819:	68 00 fc 2f 00       	push   $0x2ffc00
f011b81e:	e8 c8 d8 fe ff       	call   f01090eb <kmalloc>
f011b823:	83 c4 10             	add    $0x10,%esp
f011b826:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b82c:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b832:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b837:	74 17                	je     f011b850 <test_kheap_virt_addr+0x484>
f011b839:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b840:	83 ec 0c             	sub    $0xc,%esp
f011b843:	68 84 e6 12 f0       	push   $0xf012e684
f011b848:	e8 3e 57 fe ff       	call   f0100f8b <cprintf>
f011b84d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b850:	e8 50 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b855:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b858:	74 17                	je     f011b871 <test_kheap_virt_addr+0x4a5>
f011b85a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b861:	83 ec 0c             	sub    $0xc,%esp
f011b864:	68 28 cf 12 f0       	push   $0xf012cf28
f011b869:	e8 1d 57 fe ff       	call   f0100f8b <cprintf>
f011b86e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b871:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b874:	e8 33 29 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b879:	29 c3                	sub    %eax,%ebx
f011b87b:	89 d8                	mov    %ebx,%eax
f011b87d:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b882:	77 17                	ja     f011b89b <test_kheap_virt_addr+0x4cf>
f011b884:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b88b:	83 ec 0c             	sub    $0xc,%esp
f011b88e:	68 d8 e6 12 f0       	push   $0xf012e6d8
f011b893:	e8 f3 56 fe ff       	call   f0100f8b <cprintf>
f011b898:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b89b:	e8 0c 29 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b8a0:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b8a3:	e8 fd 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b8a8:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b8ab:	83 ec 0c             	sub    $0xc,%esp
f011b8ae:	68 00 fc 5f 00       	push   $0x5ffc00
f011b8b3:	e8 33 d8 fe ff       	call   f01090eb <kmalloc>
f011b8b8:	83 c4 10             	add    $0x10,%esp
f011b8bb:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b8c1:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b8c7:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b8cc:	74 17                	je     f011b8e5 <test_kheap_virt_addr+0x519>
f011b8ce:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b8d5:	83 ec 0c             	sub    $0xc,%esp
f011b8d8:	68 20 e7 12 f0       	push   $0xf012e720
f011b8dd:	e8 a9 56 fe ff       	call   f0100f8b <cprintf>
f011b8e2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b8e5:	e8 bb 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b8ea:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b8ed:	74 17                	je     f011b906 <test_kheap_virt_addr+0x53a>
f011b8ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b8f6:	83 ec 0c             	sub    $0xc,%esp
f011b8f9:	68 24 d0 12 f0       	push   $0xf012d024
f011b8fe:	e8 88 56 fe ff       	call   f0100f8b <cprintf>
f011b903:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b906:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b909:	e8 9e 28 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b90e:	29 c3                	sub    %eax,%ebx
f011b910:	89 d8                	mov    %ebx,%eax
f011b912:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b917:	77 17                	ja     f011b930 <test_kheap_virt_addr+0x564>
f011b919:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b920:	83 ec 0c             	sub    $0xc,%esp
f011b923:	68 74 e7 12 f0       	push   $0xf012e774
f011b928:	e8 5e 56 fe ff       	call   f0100f8b <cprintf>
f011b92d:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011b930:	e8 77 28 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b935:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b938:	e8 68 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b93d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011b940:	83 ec 0c             	sub    $0xc,%esp
f011b943:	68 00 38 00 00       	push   $0x3800
f011b948:	e8 9e d7 fe ff       	call   f01090eb <kmalloc>
f011b94d:	83 c4 10             	add    $0x10,%esp
f011b950:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b956:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b95c:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011b961:	74 17                	je     f011b97a <test_kheap_virt_addr+0x5ae>
f011b963:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b96a:	83 ec 0c             	sub    $0xc,%esp
f011b96d:	68 bc e7 12 f0       	push   $0xf012e7bc
f011b972:	e8 14 56 fe ff       	call   f0100f8b <cprintf>
f011b977:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b97a:	e8 26 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b97f:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b982:	74 17                	je     f011b99b <test_kheap_virt_addr+0x5cf>
f011b984:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b98b:	83 ec 0c             	sub    $0xc,%esp
f011b98e:	68 10 e8 12 f0       	push   $0xf012e810
f011b993:	e8 f3 55 fe ff       	call   f0100f8b <cprintf>
f011b998:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b99b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b99e:	e8 09 28 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011b9a3:	29 c3                	sub    %eax,%ebx
f011b9a5:	89 d8                	mov    %ebx,%eax
f011b9a7:	83 f8 03             	cmp    $0x3,%eax
f011b9aa:	77 17                	ja     f011b9c3 <test_kheap_virt_addr+0x5f7>
f011b9ac:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b9b3:	83 ec 0c             	sub    $0xc,%esp
f011b9b6:	68 80 e8 12 f0       	push   $0xf012e880
f011b9bb:	e8 cb 55 fe ff       	call   f0100f8b <cprintf>
f011b9c0:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011b9c3:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011b9ca:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b9cd:	c1 e8 0c             	shr    $0xc,%eax
f011b9d0:	89 c2                	mov    %eax,%edx
f011b9d2:	4a                   	dec    %edx
f011b9d3:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011b9d6:	c1 e0 02             	shl    $0x2,%eax
f011b9d9:	8d 50 03             	lea    0x3(%eax),%edx
f011b9dc:	b8 10 00 00 00       	mov    $0x10,%eax
f011b9e1:	48                   	dec    %eax
f011b9e2:	01 d0                	add    %edx,%eax
f011b9e4:	bf 10 00 00 00       	mov    $0x10,%edi
f011b9e9:	ba 00 00 00 00       	mov    $0x0,%edx
f011b9ee:	f7 f7                	div    %edi
f011b9f0:	6b c0 10             	imul   $0x10,%eax,%eax
f011b9f3:	29 c4                	sub    %eax,%esp
f011b9f5:	89 e0                	mov    %esp,%eax
f011b9f7:	83 c0 03             	add    $0x3,%eax
f011b9fa:	c1 e8 02             	shr    $0x2,%eax
f011b9fd:	c1 e0 02             	shl    $0x2,%eax
f011ba00:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011ba03:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011ba06:	c1 e8 0c             	shr    $0xc,%eax
f011ba09:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011ba0c:	83 ec 0c             	sub    $0xc,%esp
f011ba0f:	68 08 ee 12 f0       	push   $0xf012ee08
f011ba14:	e8 72 55 fe ff       	call   f0100f8b <cprintf>
f011ba19:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011ba1c:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011ba23:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011ba28:	05 00 10 00 00       	add    $0x1000,%eax
f011ba2d:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011ba30:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011ba37:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ba3a:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ba3d:	e9 2d 01 00 00       	jmp    f011bb6f <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ba42:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011ba47:	83 ec 04             	sub    $0x4,%esp
f011ba4a:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011ba50:	52                   	push   %edx
f011ba51:	ff 75 dc             	pushl  -0x24(%ebp)
f011ba54:	50                   	push   %eax
f011ba55:	e8 95 c9 fe ff       	call   f01083ef <get_page_table>
f011ba5a:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ba5d:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011ba63:	85 c0                	test   %eax,%eax
f011ba65:	75 1e                	jne    f011ba85 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ba67:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba6e:	83 ec 04             	sub    $0x4,%esp
f011ba71:	68 14 e9 12 f0       	push   $0xf012e914
f011ba76:	68 27 07 00 00       	push   $0x727
f011ba7b:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011ba80:	e8 b4 48 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011ba85:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ba88:	c1 e8 0c             	shr    $0xc,%eax
f011ba8b:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ba90:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011ba93:	e9 ba 00 00 00       	jmp    f011bb52 <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011ba98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ba9b:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011ba9e:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011baa4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011baa7:	c1 e2 02             	shl    $0x2,%edx
f011baaa:	01 d0                	add    %edx,%eax
f011baac:	8b 00                	mov    (%eax),%eax
f011baae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bab3:	89 c2                	mov    %eax,%edx
f011bab5:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bab8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011babb:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011babe:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011bac1:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bac4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bac7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011baca:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bacd:	83 ec 0c             	sub    $0xc,%esp
f011bad0:	50                   	push   %eax
f011bad1:	e8 b8 d9 fe ff       	call   f010948e <kheap_virtual_address>
f011bad6:	83 c4 10             	add    $0x10,%esp
f011bad9:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011badc:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011badf:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bae2:	01 d0                	add    %edx,%eax
f011bae4:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011bae7:	74 5c                	je     f011bb45 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011bae9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011baed:	74 56                	je     f011bb45 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011baef:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011baf2:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011baf5:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011baf8:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011bafe:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011bb01:	c1 e1 02             	shl    $0x2,%ecx
f011bb04:	01 ca                	add    %ecx,%edx
f011bb06:	8b 12                	mov    (%edx),%edx
f011bb08:	89 d1                	mov    %edx,%ecx
f011bb0a:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011bb10:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011bb13:	8b 55 90             	mov    -0x70(%ebp),%edx
f011bb16:	01 da                	add    %ebx,%edx
f011bb18:	83 ec 0c             	sub    $0xc,%esp
f011bb1b:	50                   	push   %eax
f011bb1c:	51                   	push   %ecx
f011bb1d:	52                   	push   %edx
f011bb1e:	ff 75 8c             	pushl  -0x74(%ebp)
f011bb21:	68 54 ee 12 f0       	push   $0xf012ee54
f011bb26:	e8 60 54 fe ff       	call   f0100f8b <cprintf>
f011bb2b:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011bb2e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb35:	83 ec 0c             	sub    $0xc,%esp
f011bb38:	68 98 ee 12 f0       	push   $0xf012ee98
f011bb3d:	e8 49 54 fe ff       	call   f0100f8b <cprintf>
f011bb42:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011bb45:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011bb4c:	ff 45 d4             	incl   -0x2c(%ebp)
f011bb4f:	ff 45 d8             	incl   -0x28(%ebp)
f011bb52:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bb55:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011bb58:	7d 15                	jge    f011bb6f <test_kheap_virt_addr+0x7a3>
f011bb5a:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011bb61:	7f 0c                	jg     f011bb6f <test_kheap_virt_addr+0x7a3>
f011bb63:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bb66:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011bb69:	0f 82 29 ff ff ff    	jb     f011ba98 <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011bb6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bb72:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011bb75:	0f 82 c7 fe ff ff    	jb     f011ba42 <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011bb7b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bb7f:	74 04                	je     f011bb85 <test_kheap_virt_addr+0x7b9>
f011bb81:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011bb85:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011bb8c:	83 ec 0c             	sub    $0xc,%esp
f011bb8f:	68 bc ee 12 f0       	push   $0xf012eebc
f011bb94:	e8 f2 53 fe ff       	call   f0100f8b <cprintf>
f011bb99:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011bb9c:	e8 0b 26 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011bba1:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011bba4:	e8 fc 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bba9:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011bbac:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bbb2:	83 ec 0c             	sub    $0xc,%esp
f011bbb5:	50                   	push   %eax
f011bbb6:	e8 90 d7 fe ff       	call   f010934b <kfree>
f011bbbb:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bbbe:	e8 e2 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bbc3:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011bbc6:	74 17                	je     f011bbdf <test_kheap_virt_addr+0x813>
f011bbc8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bbcf:	83 ec 0c             	sub    $0xc,%esp
f011bbd2:	68 e4 ee 12 f0       	push   $0xf012eee4
f011bbd7:	e8 af 53 fe ff       	call   f0100f8b <cprintf>
f011bbdc:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011bbdf:	e8 c8 25 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011bbe4:	89 c2                	mov    %eax,%edx
f011bbe6:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bbe9:	29 c2                	sub    %eax,%edx
f011bbeb:	89 d0                	mov    %edx,%eax
f011bbed:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bbf2:	77 17                	ja     f011bc0b <test_kheap_virt_addr+0x83f>
f011bbf4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bbfb:	83 ec 0c             	sub    $0xc,%esp
f011bbfe:	68 54 ef 12 f0       	push   $0xf012ef54
f011bc03:	e8 83 53 fe ff       	call   f0100f8b <cprintf>
f011bc08:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bc0b:	e8 9c 25 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011bc10:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bc13:	e8 8d 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc18:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011bc1b:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bc21:	83 ec 0c             	sub    $0xc,%esp
f011bc24:	50                   	push   %eax
f011bc25:	e8 21 d7 fe ff       	call   f010934b <kfree>
f011bc2a:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc2d:	e8 73 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc32:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011bc35:	74 17                	je     f011bc4e <test_kheap_virt_addr+0x882>
f011bc37:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc3e:	83 ec 0c             	sub    $0xc,%esp
f011bc41:	68 90 ef 12 f0       	push   $0xf012ef90
f011bc46:	e8 40 53 fe ff       	call   f0100f8b <cprintf>
f011bc4b:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011bc4e:	e8 59 25 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011bc53:	89 c2                	mov    %eax,%edx
f011bc55:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bc58:	29 c2                	sub    %eax,%edx
f011bc5a:	89 d0                	mov    %edx,%eax
f011bc5c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bc61:	77 17                	ja     f011bc7a <test_kheap_virt_addr+0x8ae>
f011bc63:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc6a:	83 ec 0c             	sub    $0xc,%esp
f011bc6d:	68 00 f0 12 f0       	push   $0xf012f000
f011bc72:	e8 14 53 fe ff       	call   f0100f8b <cprintf>
f011bc77:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011bc7a:	e8 2d 25 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011bc7f:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bc82:	e8 1e 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc87:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011bc8a:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011bc90:	83 ec 0c             	sub    $0xc,%esp
f011bc93:	50                   	push   %eax
f011bc94:	e8 b2 d6 fe ff       	call   f010934b <kfree>
f011bc99:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc9c:	e8 04 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bca1:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011bca4:	74 17                	je     f011bcbd <test_kheap_virt_addr+0x8f1>
f011bca6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bcad:	83 ec 0c             	sub    $0xc,%esp
f011bcb0:	68 3c f0 12 f0       	push   $0xf012f03c
f011bcb5:	e8 d1 52 fe ff       	call   f0100f8b <cprintf>
f011bcba:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011bcbd:	e8 ea 24 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011bcc2:	89 c2                	mov    %eax,%edx
f011bcc4:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bcc7:	29 c2                	sub    %eax,%edx
f011bcc9:	89 d0                	mov    %edx,%eax
f011bccb:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011bcd0:	77 17                	ja     f011bce9 <test_kheap_virt_addr+0x91d>
f011bcd2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bcd9:	83 ec 0c             	sub    $0xc,%esp
f011bcdc:	68 ac f0 12 f0       	push   $0xf012f0ac
f011bce1:	e8 a5 52 fe ff       	call   f0100f8b <cprintf>
f011bce6:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011bce9:	83 ec 0c             	sub    $0xc,%esp
f011bcec:	68 e8 f0 12 f0       	push   $0xf012f0e8
f011bcf1:	e8 95 52 fe ff       	call   f0100f8b <cprintf>
f011bcf6:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011bcf9:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011bd00:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011bd05:	05 00 10 00 00       	add    $0x1000,%eax
f011bd0a:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011bd10:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011bd17:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011bd1e:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011bd21:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bd27:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011bd2a:	eb 44                	jmp    f011bd70 <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bd2c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bd2f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bd32:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bd35:	83 ec 0c             	sub    $0xc,%esp
f011bd38:	50                   	push   %eax
f011bd39:	e8 50 d7 fe ff       	call   f010948e <kheap_virtual_address>
f011bd3e:	83 c4 10             	add    $0x10,%esp
f011bd41:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011bd47:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011bd4e:	74 1d                	je     f011bd6d <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011bd50:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bd54:	74 17                	je     f011bd6d <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011bd56:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd5d:	83 ec 0c             	sub    $0xc,%esp
f011bd60:	68 38 f1 12 f0       	push   $0xf012f138
f011bd65:	e8 21 52 fe ff       	call   f0100f8b <cprintf>
f011bd6a:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011bd6d:	ff 45 d0             	incl   -0x30(%ebp)
f011bd70:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bd76:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011bd7c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bd7f:	39 c2                	cmp    %eax,%edx
f011bd81:	77 a9                	ja     f011bd2c <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011bd83:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bd89:	05 00 04 00 00       	add    $0x400,%eax
f011bd8e:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011bd91:	eb 64                	jmp    f011bdf7 <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bd93:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bd96:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bd99:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bd9c:	83 ec 0c             	sub    $0xc,%esp
f011bd9f:	50                   	push   %eax
f011bda0:	e8 e9 d6 fe ff       	call   f010948e <kheap_virtual_address>
f011bda5:	83 c4 10             	add    $0x10,%esp
f011bda8:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011bdae:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bdb1:	c1 e0 0c             	shl    $0xc,%eax
f011bdb4:	89 c2                	mov    %eax,%edx
f011bdb6:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011bdbc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011bdbf:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bdc2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bdc5:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bdc8:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bdcd:	01 c8                	add    %ecx,%eax
f011bdcf:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011bdd5:	74 1d                	je     f011bdf4 <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011bdd7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bddb:	74 17                	je     f011bdf4 <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011bddd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bde4:	83 ec 0c             	sub    $0xc,%esp
f011bde7:	68 5c f1 12 f0       	push   $0xf012f15c
f011bdec:	e8 9a 51 fe ff       	call   f0100f8b <cprintf>
f011bdf1:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011bdf4:	ff 45 d0             	incl   -0x30(%ebp)
f011bdf7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bdfd:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011be03:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011be06:	39 c2                	cmp    %eax,%edx
f011be08:	77 89                	ja     f011bd93 <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011be0a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011be10:	05 02 07 00 00       	add    $0x702,%eax
f011be15:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011be18:	eb 44                	jmp    f011be5e <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011be1a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011be1d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011be20:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011be23:	83 ec 0c             	sub    $0xc,%esp
f011be26:	50                   	push   %eax
f011be27:	e8 62 d6 fe ff       	call   f010948e <kheap_virtual_address>
f011be2c:	83 c4 10             	add    $0x10,%esp
f011be2f:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011be35:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011be3c:	74 1d                	je     f011be5b <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011be3e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011be42:	74 17                	je     f011be5b <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011be44:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be4b:	83 ec 0c             	sub    $0xc,%esp
f011be4e:	68 80 f1 12 f0       	push   $0xf012f180
f011be53:	e8 33 51 fe ff       	call   f0100f8b <cprintf>
f011be58:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011be5b:	ff 45 d0             	incl   -0x30(%ebp)
f011be5e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011be64:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011be6a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011be6d:	39 c2                	cmp    %eax,%edx
f011be6f:	77 a9                	ja     f011be1a <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011be71:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011be77:	05 02 0d 00 00       	add    $0xd02,%eax
f011be7c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011be7f:	eb 64                	jmp    f011bee5 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011be81:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011be84:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011be87:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011be8a:	83 ec 0c             	sub    $0xc,%esp
f011be8d:	50                   	push   %eax
f011be8e:	e8 fb d5 fe ff       	call   f010948e <kheap_virtual_address>
f011be93:	83 c4 10             	add    $0x10,%esp
f011be96:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011be9c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011be9f:	c1 e0 0c             	shl    $0xc,%eax
f011bea2:	89 c2                	mov    %eax,%edx
f011bea4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011beaa:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011bead:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011beb0:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011beb3:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011beb6:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bebb:	01 c8                	add    %ecx,%eax
f011bebd:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011bec3:	74 1d                	je     f011bee2 <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011bec5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bec9:	74 17                	je     f011bee2 <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011becb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bed2:	83 ec 0c             	sub    $0xc,%esp
f011bed5:	68 a4 f1 12 f0       	push   $0xf012f1a4
f011beda:	e8 ac 50 fe ff       	call   f0100f8b <cprintf>
f011bedf:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011bee2:	ff 45 d0             	incl   -0x30(%ebp)
f011bee5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011beeb:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011bef1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bef4:	39 c2                	cmp    %eax,%edx
f011bef6:	77 89                	ja     f011be81 <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011bef8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011befc:	74 04                	je     f011bf02 <test_kheap_virt_addr+0xb36>
f011befe:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011bf02:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011bf09:	83 ec 0c             	sub    $0xc,%esp
f011bf0c:	68 c8 f1 12 f0       	push   $0xf012f1c8
f011bf11:	e8 75 50 fe ff       	call   f0100f8b <cprintf>
f011bf16:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011bf19:	83 ec 0c             	sub    $0xc,%esp
f011bf1c:	6a 00                	push   $0x0
f011bf1e:	e8 95 d0 fe ff       	call   f0108fb8 <sbrk>
f011bf23:	83 c4 10             	add    $0x10,%esp
f011bf26:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011bf2b:	77 17                	ja     f011bf44 <test_kheap_virt_addr+0xb78>
f011bf2d:	83 ec 04             	sub    $0x4,%esp
f011bf30:	68 0f f2 12 f0       	push   $0xf012f20f
f011bf35:	68 92 07 00 00       	push   $0x792
f011bf3a:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011bf3f:	e8 f5 43 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011bf44:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011bf4b:	e9 d1 00 00 00       	jmp    f011c021 <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bf50:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011bf55:	83 ec 04             	sub    $0x4,%esp
f011bf58:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011bf5e:	52                   	push   %edx
f011bf5f:	ff 75 cc             	pushl  -0x34(%ebp)
f011bf62:	50                   	push   %eax
f011bf63:	e8 87 c4 fe ff       	call   f01083ef <get_page_table>
f011bf68:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bf6b:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011bf71:	85 c0                	test   %eax,%eax
f011bf73:	75 1e                	jne    f011bf93 <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bf75:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf7c:	83 ec 04             	sub    $0x4,%esp
f011bf7f:	68 98 eb 12 f0       	push   $0xf012eb98
f011bf84:	68 98 07 00 00       	push   $0x798
f011bf89:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011bf8e:	e8 a6 43 fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011bf93:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011bf99:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011bf9c:	c1 ea 0c             	shr    $0xc,%edx
f011bf9f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011bfa5:	c1 e2 02             	shl    $0x2,%edx
f011bfa8:	01 d0                	add    %edx,%eax
f011bfaa:	8b 00                	mov    (%eax),%eax
f011bfac:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bfb1:	89 c2                	mov    %eax,%edx
f011bfb3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011bfb6:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bfbb:	01 d0                	add    %edx,%eax
f011bfbd:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011bfc3:	83 ec 0c             	sub    $0xc,%esp
f011bfc6:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011bfcc:	e8 bd d4 fe ff       	call   f010948e <kheap_virtual_address>
f011bfd1:	83 c4 10             	add    $0x10,%esp
f011bfd4:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011bfda:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011bfe0:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011bfe3:	74 39                	je     f011c01e <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011bfe5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bfe9:	74 33                	je     f011c01e <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011bfeb:	ff 75 cc             	pushl  -0x34(%ebp)
f011bfee:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011bff4:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011bffa:	68 28 f2 12 f0       	push   $0xf012f228
f011bfff:	e8 87 4f fe ff       	call   f0100f8b <cprintf>
f011c004:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011c007:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c00e:	83 ec 0c             	sub    $0xc,%esp
f011c011:	68 54 f2 12 f0       	push   $0xf012f254
f011c016:	e8 70 4f fe ff       	call   f0100f8b <cprintf>
f011c01b:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c01e:	ff 45 cc             	incl   -0x34(%ebp)
f011c021:	83 ec 0c             	sub    $0xc,%esp
f011c024:	6a 00                	push   $0x0
f011c026:	e8 8d cf fe ff       	call   f0108fb8 <sbrk>
f011c02b:	83 c4 10             	add    $0x10,%esp
f011c02e:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c031:	0f 87 19 ff ff ff    	ja     f011bf50 <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011c037:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c03b:	74 04                	je     f011c041 <test_kheap_virt_addr+0xc75>
f011c03d:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011c041:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011c048:	83 ec 0c             	sub    $0xc,%esp
f011c04b:	68 78 f2 12 f0       	push   $0xf012f278
f011c050:	e8 36 4f fe ff       	call   f0100f8b <cprintf>
f011c055:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c058:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011c05f:	eb 5a                	jmp    f011c0bb <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011c061:	83 ec 0c             	sub    $0xc,%esp
f011c064:	ff 75 c8             	pushl  -0x38(%ebp)
f011c067:	e8 22 d4 fe ff       	call   f010948e <kheap_virtual_address>
f011c06c:	83 c4 10             	add    $0x10,%esp
f011c06f:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011c075:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011c07c:	74 36                	je     f011c0b4 <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011c07e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c082:	74 30                	je     f011c0b4 <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011c084:	83 ec 04             	sub    $0x4,%esp
f011c087:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011c08d:	ff 75 c8             	pushl  -0x38(%ebp)
f011c090:	68 b7 f2 12 f0       	push   $0xf012f2b7
f011c095:	e8 f1 4e fe ff       	call   f0100f8b <cprintf>
f011c09a:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011c09d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0a4:	83 ec 0c             	sub    $0xc,%esp
f011c0a7:	68 d4 f2 12 f0       	push   $0xf012f2d4
f011c0ac:	e8 da 4e fe ff       	call   f0100f8b <cprintf>
f011c0b1:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c0b4:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011c0bb:	b8 90 64 b0 00       	mov    $0xb06490,%eax
f011c0c0:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011c0c3:	72 9c                	jb     f011c061 <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011c0c5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c0c9:	74 04                	je     f011c0cf <test_kheap_virt_addr+0xd03>
f011c0cb:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011c0cf:	83 ec 08             	sub    $0x8,%esp
f011c0d2:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c0d5:	68 f8 f2 12 f0       	push   $0xf012f2f8
f011c0da:	e8 ac 4e fe ff       	call   f0100f8b <cprintf>
f011c0df:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c0e2:	b8 01 00 00 00       	mov    $0x1,%eax
f011c0e7:	89 f4                	mov    %esi,%esp

}
f011c0e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c0ec:	5b                   	pop    %ebx
f011c0ed:	5e                   	pop    %esi
f011c0ee:	5f                   	pop    %edi
f011c0ef:	5d                   	pop    %ebp
f011c0f0:	c3                   	ret    

f011c0f1 <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011c0f1:	55                   	push   %ebp
f011c0f2:	89 e5                	mov    %esp,%ebp
f011c0f4:	57                   	push   %edi
f011c0f5:	56                   	push   %esi
f011c0f6:	53                   	push   %ebx
f011c0f7:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011c0fd:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011c103:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c108:	b8 00 00 00 00       	mov    $0x0,%eax
f011c10d:	89 d7                	mov    %edx,%edi
f011c10f:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011c111:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011c118:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c11f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011c126:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f011c12b:	0f b6 c0             	movzbl %al,%eax
f011c12e:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011c131:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011c138:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c13b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c13e:	39 c2                	cmp    %eax,%edx
f011c140:	73 02                	jae    f011c144 <test_ksbrk+0x53>
f011c142:	89 c2                	mov    %eax,%edx
f011c144:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f011c149:	0f b6 c0             	movzbl %al,%eax
f011c14c:	c1 e0 04             	shl    $0x4,%eax
f011c14f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011c152:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011c159:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011c15c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c15f:	39 c8                	cmp    %ecx,%eax
f011c161:	73 02                	jae    f011c165 <test_ksbrk+0x74>
f011c163:	89 c8                	mov    %ecx,%eax
f011c165:	01 d0                	add    %edx,%eax
f011c167:	83 c0 10             	add    $0x10,%eax
f011c16a:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011c16f:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011c172:	83 ec 0c             	sub    $0xc,%esp
f011c175:	68 2c f3 12 f0       	push   $0xf012f32c
f011c17a:	e8 0c 4e fe ff       	call   f0100f8b <cprintf>
f011c17f:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011c182:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c189:	e8 1e 20 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c18e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c191:	e8 0f 87 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c196:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011c199:	83 ec 10             	sub    $0x10,%esp
f011c19c:	89 e0                	mov    %esp,%eax
f011c19e:	89 c2                	mov    %eax,%edx
f011c1a0:	bb f0 b3 6b f0       	mov    $0xf06bb3f0,%ebx
f011c1a5:	b8 04 00 00 00       	mov    $0x4,%eax
f011c1aa:	89 d7                	mov    %edx,%edi
f011c1ac:	89 de                	mov    %ebx,%esi
f011c1ae:	89 c1                	mov    %eax,%ecx
f011c1b0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011c1b2:	e8 53 3e 00 00       	call   f012000a <print_blocks_list>
f011c1b7:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c1ba:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c1bd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c1c0:	29 c2                	sub    %eax,%edx
f011c1c2:	89 d0                	mov    %edx,%eax
f011c1c4:	83 ec 0c             	sub    $0xc,%esp
f011c1c7:	50                   	push   %eax
f011c1c8:	e8 1e cf fe ff       	call   f01090eb <kmalloc>
f011c1cd:	83 c4 10             	add    $0x10,%esp
f011c1d0:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011c1d6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c1d9:	89 c2                	mov    %eax,%edx
f011c1db:	c1 ea 1f             	shr    $0x1f,%edx
f011c1de:	01 d0                	add    %edx,%eax
f011c1e0:	d1 f8                	sar    %eax
f011c1e2:	89 c2                	mov    %eax,%edx
f011c1e4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c1e7:	01 d0                	add    %edx,%eax
f011c1e9:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c1ec:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c1f2:	6a 01                	push   $0x1
f011c1f4:	ff 75 b8             	pushl  -0x48(%ebp)
f011c1f7:	ff 75 ac             	pushl  -0x54(%ebp)
f011c1fa:	50                   	push   %eax
f011c1fb:	e8 c8 43 ff ff       	call   f01105c8 <check_block>
f011c200:	83 c4 10             	add    $0x10,%esp
f011c203:	85 c0                	test   %eax,%eax
f011c205:	75 17                	jne    f011c21e <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011c207:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c20e:	83 ec 0c             	sub    $0xc,%esp
f011c211:	68 7d f3 12 f0       	push   $0xf012f37d
f011c216:	e8 70 4d fe ff       	call   f0100f8b <cprintf>
f011c21b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c21e:	e8 89 1f ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c223:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c226:	74 17                	je     f011c23f <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011c228:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c22f:	83 ec 0c             	sub    $0xc,%esp
f011c232:	68 94 f3 12 f0       	push   $0xf012f394
f011c237:	e8 4f 4d fe ff       	call   f0100f8b <cprintf>
f011c23c:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c23f:	e8 61 86 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c244:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c247:	74 17                	je     f011c260 <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c249:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c250:	83 ec 0c             	sub    $0xc,%esp
f011c253:	68 b4 f3 12 f0       	push   $0xf012f3b4
f011c258:	e8 2e 4d fe ff       	call   f0100f8b <cprintf>
f011c25d:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011c260:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f011c265:	0f b6 c0             	movzbl %al,%eax
f011c268:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011c26b:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011c272:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011c275:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011c278:	39 c2                	cmp    %eax,%edx
f011c27a:	73 02                	jae    f011c27e <test_ksbrk+0x18d>
f011c27c:	89 c2                	mov    %eax,%edx
f011c27e:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f011c283:	0f b6 c0             	movzbl %al,%eax
f011c286:	c1 e0 04             	shl    $0x4,%eax
f011c289:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011c28c:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011c293:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011c296:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c299:	39 c8                	cmp    %ecx,%eax
f011c29b:	73 02                	jae    f011c29f <test_ksbrk+0x1ae>
f011c29d:	89 c8                	mov    %ecx,%eax
f011c29f:	01 d0                	add    %edx,%eax
f011c2a1:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011c2a6:	29 c2                	sub    %eax,%edx
f011c2a8:	89 d0                	mov    %edx,%eax
f011c2aa:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c2ad:	e8 fa 1e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c2b2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c2b5:	e8 eb 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c2ba:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011c2bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c2c0:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c2c3:	29 c2                	sub    %eax,%edx
f011c2c5:	89 d0                	mov    %edx,%eax
f011c2c7:	83 ec 0c             	sub    $0xc,%esp
f011c2ca:	50                   	push   %eax
f011c2cb:	e8 1b ce fe ff       	call   f01090eb <kmalloc>
f011c2d0:	83 c4 10             	add    $0x10,%esp
f011c2d3:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011c2d9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c2dc:	89 c2                	mov    %eax,%edx
f011c2de:	c1 ea 1f             	shr    $0x1f,%edx
f011c2e1:	01 d0                	add    %edx,%eax
f011c2e3:	d1 f8                	sar    %eax
f011c2e5:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011c2eb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c2ee:	01 d0                	add    %edx,%eax
f011c2f0:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011c2f3:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011c2f9:	6a 01                	push   $0x1
f011c2fb:	ff 75 b8             	pushl  -0x48(%ebp)
f011c2fe:	ff 75 ac             	pushl  -0x54(%ebp)
f011c301:	50                   	push   %eax
f011c302:	e8 c1 42 ff ff       	call   f01105c8 <check_block>
f011c307:	83 c4 10             	add    $0x10,%esp
f011c30a:	85 c0                	test   %eax,%eax
f011c30c:	75 17                	jne    f011c325 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011c30e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c315:	83 ec 0c             	sub    $0xc,%esp
f011c318:	68 22 f4 12 f0       	push   $0xf012f422
f011c31d:	e8 69 4c fe ff       	call   f0100f8b <cprintf>
f011c322:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c325:	e8 82 1e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c32a:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c32d:	74 17                	je     f011c346 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011c32f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c336:	83 ec 0c             	sub    $0xc,%esp
f011c339:	68 3c f4 12 f0       	push   $0xf012f43c
f011c33e:	e8 48 4c fe ff       	call   f0100f8b <cprintf>
f011c343:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c346:	e8 5a 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c34b:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c34e:	74 17                	je     f011c367 <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c350:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c357:	83 ec 0c             	sub    $0xc,%esp
f011c35a:	68 5c f4 12 f0       	push   $0xf012f45c
f011c35f:	e8 27 4c fe ff       	call   f0100f8b <cprintf>
f011c364:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011c367:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011c36e:	e8 39 1e ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c373:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c376:	e8 2a 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c37b:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011c37e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c381:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c384:	29 c2                	sub    %eax,%edx
f011c386:	89 d0                	mov    %edx,%eax
f011c388:	83 ec 0c             	sub    $0xc,%esp
f011c38b:	50                   	push   %eax
f011c38c:	e8 5a cd fe ff       	call   f01090eb <kmalloc>
f011c391:	83 c4 10             	add    $0x10,%esp
f011c394:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011c39a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c39d:	89 c2                	mov    %eax,%edx
f011c39f:	c1 ea 1f             	shr    $0x1f,%edx
f011c3a2:	01 d0                	add    %edx,%eax
f011c3a4:	d1 f8                	sar    %eax
f011c3a6:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011c3ab:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011c3ae:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011c3b4:	6a 01                	push   $0x1
f011c3b6:	ff 75 b8             	pushl  -0x48(%ebp)
f011c3b9:	ff 75 ac             	pushl  -0x54(%ebp)
f011c3bc:	50                   	push   %eax
f011c3bd:	e8 06 42 ff ff       	call   f01105c8 <check_block>
f011c3c2:	83 c4 10             	add    $0x10,%esp
f011c3c5:	85 c0                	test   %eax,%eax
f011c3c7:	75 17                	jne    f011c3e0 <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011c3c9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3d0:	83 ec 0c             	sub    $0xc,%esp
f011c3d3:	68 ca f4 12 f0       	push   $0xf012f4ca
f011c3d8:	e8 ae 4b fe ff       	call   f0100f8b <cprintf>
f011c3dd:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011c3e0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011c3e3:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011c3e6:	b8 00 10 00 00       	mov    $0x1000,%eax
f011c3eb:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011c3ee:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011c3f1:	6a 00                	push   $0x0
f011c3f3:	ff 75 98             	pushl  -0x68(%ebp)
f011c3f6:	ff 75 ac             	pushl  -0x54(%ebp)
f011c3f9:	ff 75 ac             	pushl  -0x54(%ebp)
f011c3fc:	e8 c7 41 ff ff       	call   f01105c8 <check_block>
f011c401:	83 c4 10             	add    $0x10,%esp
f011c404:	85 c0                	test   %eax,%eax
f011c406:	75 17                	jne    f011c41f <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011c408:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c40f:	83 ec 0c             	sub    $0xc,%esp
f011c412:	68 e1 f4 12 f0       	push   $0xf012f4e1
f011c417:	e8 6f 4b fe ff       	call   f0100f8b <cprintf>
f011c41c:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011c41f:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011c426:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c429:	8b 00                	mov    (%eax),%eax
f011c42b:	83 f8 01             	cmp    $0x1,%eax
f011c42e:	74 17                	je     f011c447 <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011c430:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c437:	83 ec 0c             	sub    $0xc,%esp
f011c43a:	68 f8 f4 12 f0       	push   $0xf012f4f8
f011c43f:	e8 47 4b fe ff       	call   f0100f8b <cprintf>
f011c444:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011c447:	83 ec 0c             	sub    $0xc,%esp
f011c44a:	6a 00                	push   $0x0
f011c44c:	e8 67 cb fe ff       	call   f0108fb8 <sbrk>
f011c451:	83 c4 10             	add    $0x10,%esp
f011c454:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011c457:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011c45e:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c461:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c464:	74 1d                	je     f011c483 <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011c466:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c46d:	83 ec 04             	sub    $0x4,%esp
f011c470:	ff 75 90             	pushl  -0x70(%ebp)
f011c473:	ff 75 8c             	pushl  -0x74(%ebp)
f011c476:	68 24 f5 12 f0       	push   $0xf012f524
f011c47b:	e8 0b 4b fe ff       	call   f0100f8b <cprintf>
f011c480:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011c483:	e8 24 1d ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c488:	89 c2                	mov    %eax,%edx
f011c48a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c48d:	29 d0                	sub    %edx,%eax
f011c48f:	83 f8 01             	cmp    $0x1,%eax
f011c492:	74 17                	je     f011c4ab <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011c494:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c49b:	83 ec 0c             	sub    $0xc,%esp
f011c49e:	68 58 f5 12 f0       	push   $0xf012f558
f011c4a3:	e8 e3 4a fe ff       	call   f0100f8b <cprintf>
f011c4a8:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c4ab:	e8 f5 83 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c4b0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c4b3:	74 17                	je     f011c4cc <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c4b5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4bc:	83 ec 0c             	sub    $0xc,%esp
f011c4bf:	68 78 f5 12 f0       	push   $0xf012f578
f011c4c4:	e8 c2 4a fe ff       	call   f0100f8b <cprintf>
f011c4c9:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011c4cc:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c4d3:	e8 d4 1c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c4d8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c4db:	e8 c5 83 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c4e0:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011c4e3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c4e6:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c4e9:	29 c2                	sub    %eax,%edx
f011c4eb:	89 d0                	mov    %edx,%eax
f011c4ed:	83 ec 0c             	sub    $0xc,%esp
f011c4f0:	50                   	push   %eax
f011c4f1:	e8 f5 cb fe ff       	call   f01090eb <kmalloc>
f011c4f6:	83 c4 10             	add    $0x10,%esp
f011c4f9:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011c4ff:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011c506:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011c50c:	6a 01                	push   $0x1
f011c50e:	ff 75 b8             	pushl  -0x48(%ebp)
f011c511:	ff 75 ac             	pushl  -0x54(%ebp)
f011c514:	50                   	push   %eax
f011c515:	e8 ae 40 ff ff       	call   f01105c8 <check_block>
f011c51a:	83 c4 10             	add    $0x10,%esp
f011c51d:	85 c0                	test   %eax,%eax
f011c51f:	75 17                	jne    f011c538 <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011c521:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c528:	83 ec 0c             	sub    $0xc,%esp
f011c52b:	68 e7 f5 12 f0       	push   $0xf012f5e7
f011c530:	e8 56 4a fe ff       	call   f0100f8b <cprintf>
f011c535:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c538:	e8 6f 1c ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c53d:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c540:	74 17                	je     f011c559 <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011c542:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c549:	83 ec 0c             	sub    $0xc,%esp
f011c54c:	68 00 f6 12 f0       	push   $0xf012f600
f011c551:	e8 35 4a fe ff       	call   f0100f8b <cprintf>
f011c556:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c559:	e8 47 83 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c55e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c561:	74 17                	je     f011c57a <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c563:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c56a:	83 ec 0c             	sub    $0xc,%esp
f011c56d:	68 20 f6 12 f0       	push   $0xf012f620
f011c572:	e8 14 4a fe ff       	call   f0100f8b <cprintf>
f011c577:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011c57a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c57e:	74 04                	je     f011c584 <test_ksbrk+0x493>
		eval += 25;
f011c580:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011c584:	83 ec 0c             	sub    $0xc,%esp
f011c587:	68 90 f6 12 f0       	push   $0xf012f690
f011c58c:	e8 fa 49 fe ff       	call   f0100f8b <cprintf>
f011c591:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011c594:	83 ec 0c             	sub    $0xc,%esp
f011c597:	6a 00                	push   $0x0
f011c599:	e8 1a ca fe ff       	call   f0108fb8 <sbrk>
f011c59e:	83 c4 10             	add    $0x10,%esp
f011c5a1:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011c5a4:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c5ab:	e8 fc 1b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c5b0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c5b3:	e8 ed 82 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c5b8:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c5bb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c5be:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c5c1:	29 c2                	sub    %eax,%edx
f011c5c3:	89 d0                	mov    %edx,%eax
f011c5c5:	83 ec 0c             	sub    $0xc,%esp
f011c5c8:	50                   	push   %eax
f011c5c9:	e8 1d cb fe ff       	call   f01090eb <kmalloc>
f011c5ce:	83 c4 10             	add    $0x10,%esp
f011c5d1:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011c5d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c5da:	89 c2                	mov    %eax,%edx
f011c5dc:	c1 ea 1f             	shr    $0x1f,%edx
f011c5df:	01 d0                	add    %edx,%eax
f011c5e1:	d1 f8                	sar    %eax
f011c5e3:	89 c2                	mov    %eax,%edx
f011c5e5:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c5e8:	01 d0                	add    %edx,%eax
f011c5ea:	83 e8 04             	sub    $0x4,%eax
f011c5ed:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c5f0:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c5f6:	6a 01                	push   $0x1
f011c5f8:	ff 75 b8             	pushl  -0x48(%ebp)
f011c5fb:	ff 75 ac             	pushl  -0x54(%ebp)
f011c5fe:	50                   	push   %eax
f011c5ff:	e8 c4 3f ff ff       	call   f01105c8 <check_block>
f011c604:	83 c4 10             	add    $0x10,%esp
f011c607:	85 c0                	test   %eax,%eax
f011c609:	75 17                	jne    f011c622 <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011c60b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c612:	83 ec 0c             	sub    $0xc,%esp
f011c615:	68 f3 f6 12 f0       	push   $0xf012f6f3
f011c61a:	e8 6c 49 fe ff       	call   f0100f8b <cprintf>
f011c61f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011c622:	e8 85 1b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c627:	89 c2                	mov    %eax,%edx
f011c629:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c62c:	29 d0                	sub    %edx,%eax
f011c62e:	83 f8 01             	cmp    $0x1,%eax
f011c631:	74 17                	je     f011c64a <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011c633:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c63a:	83 ec 0c             	sub    $0xc,%esp
f011c63d:	68 0c f7 12 f0       	push   $0xf012f70c
f011c642:	e8 44 49 fe ff       	call   f0100f8b <cprintf>
f011c647:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c64a:	e8 56 82 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c64f:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c652:	74 17                	je     f011c66b <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c654:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c65b:	83 ec 0c             	sub    $0xc,%esp
f011c65e:	68 2c f7 12 f0       	push   $0xf012f72c
f011c663:	e8 23 49 fe ff       	call   f0100f8b <cprintf>
f011c668:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011c66b:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c672:	e8 35 1b ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c677:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c67a:	e8 26 82 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c67f:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011c682:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c685:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c688:	29 c2                	sub    %eax,%edx
f011c68a:	89 d0                	mov    %edx,%eax
f011c68c:	83 ec 0c             	sub    $0xc,%esp
f011c68f:	50                   	push   %eax
f011c690:	e8 56 ca fe ff       	call   f01090eb <kmalloc>
f011c695:	83 c4 10             	add    $0x10,%esp
f011c698:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011c69e:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011c6a5:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011c6ab:	6a 01                	push   $0x1
f011c6ad:	ff 75 b8             	pushl  -0x48(%ebp)
f011c6b0:	ff 75 ac             	pushl  -0x54(%ebp)
f011c6b3:	50                   	push   %eax
f011c6b4:	e8 0f 3f ff ff       	call   f01105c8 <check_block>
f011c6b9:	83 c4 10             	add    $0x10,%esp
f011c6bc:	85 c0                	test   %eax,%eax
f011c6be:	75 17                	jne    f011c6d7 <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011c6c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6c7:	83 ec 0c             	sub    $0xc,%esp
f011c6ca:	68 9a f7 12 f0       	push   $0xf012f79a
f011c6cf:	e8 b7 48 fe ff       	call   f0100f8b <cprintf>
f011c6d4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c6d7:	e8 d0 1a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c6dc:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c6df:	74 17                	je     f011c6f8 <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011c6e1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6e8:	83 ec 0c             	sub    $0xc,%esp
f011c6eb:	68 b4 f7 12 f0       	push   $0xf012f7b4
f011c6f0:	e8 96 48 fe ff       	call   f0100f8b <cprintf>
f011c6f5:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c6f8:	e8 a8 81 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c6fd:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c700:	74 17                	je     f011c719 <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c702:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c709:	83 ec 0c             	sub    $0xc,%esp
f011c70c:	68 d4 f7 12 f0       	push   $0xf012f7d4
f011c711:	e8 75 48 fe ff       	call   f0100f8b <cprintf>
f011c716:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011c719:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011c720:	e8 87 1a ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c725:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c728:	e8 78 81 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c72d:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011c730:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c733:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c736:	29 c2                	sub    %eax,%edx
f011c738:	89 d0                	mov    %edx,%eax
f011c73a:	83 ec 0c             	sub    $0xc,%esp
f011c73d:	50                   	push   %eax
f011c73e:	e8 a8 c9 fe ff       	call   f01090eb <kmalloc>
f011c743:	83 c4 10             	add    $0x10,%esp
f011c746:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011c74c:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011c753:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011c759:	6a 01                	push   $0x1
f011c75b:	ff 75 b8             	pushl  -0x48(%ebp)
f011c75e:	ff 75 ac             	pushl  -0x54(%ebp)
f011c761:	50                   	push   %eax
f011c762:	e8 61 3e ff ff       	call   f01105c8 <check_block>
f011c767:	83 c4 10             	add    $0x10,%esp
f011c76a:	85 c0                	test   %eax,%eax
f011c76c:	75 17                	jne    f011c785 <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011c76e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c775:	83 ec 0c             	sub    $0xc,%esp
f011c778:	68 42 f8 12 f0       	push   $0xf012f842
f011c77d:	e8 09 48 fe ff       	call   f0100f8b <cprintf>
f011c782:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011c785:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011c788:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011c78b:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011c792:	6a 00                	push   $0x0
f011c794:	ff 75 98             	pushl  -0x68(%ebp)
f011c797:	ff 75 ac             	pushl  -0x54(%ebp)
f011c79a:	ff 75 ac             	pushl  -0x54(%ebp)
f011c79d:	e8 26 3e ff ff       	call   f01105c8 <check_block>
f011c7a2:	83 c4 10             	add    $0x10,%esp
f011c7a5:	85 c0                	test   %eax,%eax
f011c7a7:	75 17                	jne    f011c7c0 <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011c7a9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7b0:	83 ec 0c             	sub    $0xc,%esp
f011c7b3:	68 59 f8 12 f0       	push   $0xf012f859
f011c7b8:	e8 ce 47 fe ff       	call   f0100f8b <cprintf>
f011c7bd:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011c7c0:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c7c3:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011c7c8:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011c7cb:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c7ce:	8b 00                	mov    (%eax),%eax
f011c7d0:	83 f8 01             	cmp    $0x1,%eax
f011c7d3:	74 17                	je     f011c7ec <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011c7d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7dc:	83 ec 0c             	sub    $0xc,%esp
f011c7df:	68 70 f8 12 f0       	push   $0xf012f870
f011c7e4:	e8 a2 47 fe ff       	call   f0100f8b <cprintf>
f011c7e9:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011c7ec:	83 ec 0c             	sub    $0xc,%esp
f011c7ef:	6a 00                	push   $0x0
f011c7f1:	e8 c2 c7 fe ff       	call   f0108fb8 <sbrk>
f011c7f6:	83 c4 10             	add    $0x10,%esp
f011c7f9:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011c7fc:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c7ff:	05 00 20 00 00       	add    $0x2000,%eax
f011c804:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011c807:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c80a:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c80d:	74 1d                	je     f011c82c <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011c80f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c816:	83 ec 04             	sub    $0x4,%esp
f011c819:	ff 75 90             	pushl  -0x70(%ebp)
f011c81c:	ff 75 8c             	pushl  -0x74(%ebp)
f011c81f:	68 9c f8 12 f0       	push   $0xf012f89c
f011c824:	e8 62 47 fe ff       	call   f0100f8b <cprintf>
f011c829:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011c82c:	e8 7b 19 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c831:	89 c2                	mov    %eax,%edx
f011c833:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c836:	29 d0                	sub    %edx,%eax
f011c838:	83 f8 01             	cmp    $0x1,%eax
f011c83b:	74 17                	je     f011c854 <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011c83d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c844:	83 ec 0c             	sub    $0xc,%esp
f011c847:	68 d0 f8 12 f0       	push   $0xf012f8d0
f011c84c:	e8 3a 47 fe ff       	call   f0100f8b <cprintf>
f011c851:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c854:	e8 4c 80 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c859:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c85c:	74 17                	je     f011c875 <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c85e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c865:	83 ec 0c             	sub    $0xc,%esp
f011c868:	68 f0 f8 12 f0       	push   $0xf012f8f0
f011c86d:	e8 19 47 fe ff       	call   f0100f8b <cprintf>
f011c872:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011c875:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c879:	74 04                	je     f011c87f <test_ksbrk+0x78e>
		eval += 25;
f011c87b:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011c87f:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011c886:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011c88c:	bb 2c fc 12 f0       	mov    $0xf012fc2c,%ebx
f011c891:	ba 05 00 00 00       	mov    $0x5,%edx
f011c896:	89 c7                	mov    %eax,%edi
f011c898:	89 de                	mov    %ebx,%esi
f011c89a:	89 d1                	mov    %edx,%ecx
f011c89c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011c89e:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011c8a4:	bb 40 fc 12 f0       	mov    $0xf012fc40,%ebx
f011c8a9:	ba 05 00 00 00       	mov    $0x5,%edx
f011c8ae:	89 c7                	mov    %eax,%edi
f011c8b0:	89 de                	mov    %ebx,%esi
f011c8b2:	89 d1                	mov    %edx,%ecx
f011c8b4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011c8b6:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011c8bc:	bb 54 fc 12 f0       	mov    $0xf012fc54,%ebx
f011c8c1:	ba 05 00 00 00       	mov    $0x5,%edx
f011c8c6:	89 c7                	mov    %eax,%edi
f011c8c8:	89 de                	mov    %ebx,%esi
f011c8ca:	89 d1                	mov    %edx,%ecx
f011c8cc:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011c8ce:	83 ec 04             	sub    $0x4,%esp
f011c8d1:	68 00 00 00 f8       	push   $0xf8000000
f011c8d6:	68 00 10 00 00       	push   $0x1000
f011c8db:	68 00 00 00 f6       	push   $0xf6000000
f011c8e0:	e8 bc c5 fe ff       	call   f0108ea1 <initialize_kheap_dynamic_allocator>
f011c8e5:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011c8e8:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011c8ef:	eb 1b                	jmp    f011c90c <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011c8f1:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011c8f6:	83 ec 08             	sub    $0x8,%esp
f011c8f9:	ff 75 dc             	pushl  -0x24(%ebp)
f011c8fc:	50                   	push   %eax
f011c8fd:	e8 dd be fe ff       	call   f01087df <unmap_frame>
f011c902:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011c905:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011c90c:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011c913:	76 dc                	jbe    f011c8f1 <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011c915:	83 ec 0c             	sub    $0xc,%esp
f011c918:	68 60 f9 12 f0       	push   $0xf012f960
f011c91d:	e8 69 46 fe ff       	call   f0100f8b <cprintf>
f011c922:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011c925:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011c92c:	e9 21 01 00 00       	jmp    f011ca52 <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011c931:	e8 76 18 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c936:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011c939:	e8 67 7f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c93e:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011c941:	83 ec 0c             	sub    $0xc,%esp
f011c944:	6a 00                	push   $0x0
f011c946:	e8 6d c6 fe ff       	call   f0108fb8 <sbrk>
f011c94b:	83 c4 10             	add    $0x10,%esp
f011c94e:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011c951:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c954:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011c95b:	83 ec 0c             	sub    $0xc,%esp
f011c95e:	50                   	push   %eax
f011c95f:	e8 54 c6 fe ff       	call   f0108fb8 <sbrk>
f011c964:	83 c4 10             	add    $0x10,%esp
f011c967:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011c96a:	83 ec 0c             	sub    $0xc,%esp
f011c96d:	6a 00                	push   $0x0
f011c96f:	e8 44 c6 fe ff       	call   f0108fb8 <sbrk>
f011c974:	83 c4 10             	add    $0x10,%esp
f011c977:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011c97a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c981:	e8 1f 7f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c986:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c989:	74 1a                	je     f011c9a5 <test_ksbrk+0x8b4>
			{
				correct = 0;
f011c98b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011c992:	83 ec 08             	sub    $0x8,%esp
f011c995:	ff 75 d8             	pushl  -0x28(%ebp)
f011c998:	68 a4 f9 12 f0       	push   $0xf012f9a4
f011c99d:	e8 e9 45 fe ff       	call   f0100f8b <cprintf>
f011c9a2:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011c9a5:	e8 02 18 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011c9aa:	89 c2                	mov    %eax,%edx
f011c9ac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c9af:	29 d0                	sub    %edx,%eax
f011c9b1:	89 c2                	mov    %eax,%edx
f011c9b3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c9b6:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011c9bd:	39 c2                	cmp    %eax,%edx
f011c9bf:	74 1a                	je     f011c9db <test_ksbrk+0x8ea>
			{
				correct = 0;
f011c9c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011c9c8:	83 ec 08             	sub    $0x8,%esp
f011c9cb:	ff 75 d8             	pushl  -0x28(%ebp)
f011c9ce:	68 14 fa 12 f0       	push   $0xf012fa14
f011c9d3:	e8 b3 45 fe ff       	call   f0100f8b <cprintf>
f011c9d8:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011c9db:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c9de:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011c9e5:	8b 45 80             	mov    -0x80(%ebp),%eax
f011c9e8:	39 c2                	cmp    %eax,%edx
f011c9ea:	74 25                	je     f011ca11 <test_ksbrk+0x920>
			{
				correct = 0;
f011c9ec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011c9f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c9f6:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011c9fd:	ff 75 80             	pushl  -0x80(%ebp)
f011ca00:	50                   	push   %eax
f011ca01:	ff 75 d8             	pushl  -0x28(%ebp)
f011ca04:	68 34 fa 12 f0       	push   $0xf012fa34
f011ca09:	e8 7d 45 fe ff       	call   f0100f8b <cprintf>
f011ca0e:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011ca11:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ca14:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011ca1b:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011ca1e:	74 25                	je     f011ca45 <test_ksbrk+0x954>
			{
				correct = 0;
f011ca20:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011ca27:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ca2a:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011ca31:	ff 75 90             	pushl  -0x70(%ebp)
f011ca34:	50                   	push   %eax
f011ca35:	ff 75 d8             	pushl  -0x28(%ebp)
f011ca38:	68 6c fa 12 f0       	push   $0xf012fa6c
f011ca3d:	e8 49 45 fe ff       	call   f0100f8b <cprintf>
f011ca42:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011ca45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ca49:	74 04                	je     f011ca4f <test_ksbrk+0x95e>
				eval += 10;
f011ca4b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011ca4f:	ff 45 d8             	incl   -0x28(%ebp)
f011ca52:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011ca55:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ca58:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ca5b:	39 c2                	cmp    %eax,%edx
f011ca5d:	0f 87 ce fe ff ff    	ja     f011c931 <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011ca63:	83 ec 0c             	sub    $0xc,%esp
f011ca66:	68 a0 fa 12 f0       	push   $0xf012faa0
f011ca6b:	e8 1b 45 fe ff       	call   f0100f8b <cprintf>
f011ca70:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011ca73:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011ca76:	48                   	dec    %eax
f011ca77:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011ca7a:	e9 18 01 00 00       	jmp    f011cb97 <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011ca7f:	e8 28 17 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011ca84:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011ca87:	e8 19 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ca8c:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011ca8f:	83 ec 0c             	sub    $0xc,%esp
f011ca92:	6a 00                	push   $0x0
f011ca94:	e8 1f c5 fe ff       	call   f0108fb8 <sbrk>
f011ca99:	83 c4 10             	add    $0x10,%esp
f011ca9c:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011ca9f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011caa2:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011caa9:	83 ec 0c             	sub    $0xc,%esp
f011caac:	50                   	push   %eax
f011caad:	e8 06 c5 fe ff       	call   f0108fb8 <sbrk>
f011cab2:	83 c4 10             	add    $0x10,%esp
f011cab5:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011cabb:	83 ec 0c             	sub    $0xc,%esp
f011cabe:	6a 00                	push   $0x0
f011cac0:	e8 f3 c4 fe ff       	call   f0108fb8 <sbrk>
f011cac5:	83 c4 10             	add    $0x10,%esp
f011cac8:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011cacb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cad2:	e8 ce 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cad7:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cada:	74 1a                	je     f011caf6 <test_ksbrk+0xa05>
			{
				correct = 0;
f011cadc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011cae3:	83 ec 08             	sub    $0x8,%esp
f011cae6:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cae9:	68 f0 fa 12 f0       	push   $0xf012faf0
f011caee:	e8 98 44 fe ff       	call   f0100f8b <cprintf>
f011caf3:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011caf6:	e8 b1 16 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011cafb:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cafe:	74 1a                	je     f011cb1a <test_ksbrk+0xa29>
			{
				correct = 0;
f011cb00:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011cb07:	83 ec 08             	sub    $0x8,%esp
f011cb0a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cb0d:	68 60 fb 12 f0       	push   $0xf012fb60
f011cb12:	e8 74 44 fe ff       	call   f0100f8b <cprintf>
f011cb17:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011cb1a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cb1d:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011cb24:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011cb2a:	39 c2                	cmp    %eax,%edx
f011cb2c:	74 28                	je     f011cb56 <test_ksbrk+0xa65>
			{
				correct = 0;
f011cb2e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011cb35:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cb38:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011cb3f:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011cb45:	50                   	push   %eax
f011cb46:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cb49:	68 80 fb 12 f0       	push   $0xf012fb80
f011cb4e:	e8 38 44 fe ff       	call   f0100f8b <cprintf>
f011cb53:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011cb56:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cb59:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cb60:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011cb63:	74 25                	je     f011cb8a <test_ksbrk+0xa99>
			{
				correct = 0;
f011cb65:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011cb6c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cb6f:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cb76:	ff 75 90             	pushl  -0x70(%ebp)
f011cb79:	50                   	push   %eax
f011cb7a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cb7d:	68 b8 fb 12 f0       	push   $0xf012fbb8
f011cb82:	e8 04 44 fe ff       	call   f0100f8b <cprintf>
f011cb87:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011cb8a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cb8e:	74 04                	je     f011cb94 <test_ksbrk+0xaa3>
				eval += 10;
f011cb90:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011cb94:	ff 45 d4             	incl   -0x2c(%ebp)
f011cb97:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cb9a:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011cb9d:	0f 82 dc fe ff ff    	jb     f011ca7f <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011cba3:	83 ec 08             	sub    $0x8,%esp
f011cba6:	ff 75 e4             	pushl  -0x1c(%ebp)
f011cba9:	68 ec fb 12 f0       	push   $0xf012fbec
f011cbae:	e8 d8 43 fe ff       	call   f0100f8b <cprintf>
f011cbb3:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011cbb6:	83 ec 0c             	sub    $0xc,%esp
f011cbb9:	68 16 fc 12 f0       	push   $0xf012fc16
f011cbbe:	e8 c8 43 fe ff       	call   f0100f8b <cprintf>
f011cbc3:	83 c4 10             	add    $0x10,%esp
	return 0;
f011cbc6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011cbcb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011cbce:	5b                   	pop    %ebx
f011cbcf:	5e                   	pop    %esi
f011cbd0:	5f                   	pop    %edi
f011cbd1:	5d                   	pop    %ebp
f011cbd2:	c3                   	ret    

f011cbd3 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011cbd3:	55                   	push   %ebp
f011cbd4:	89 e5                	mov    %esp,%ebp
f011cbd6:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cbd9:	83 ec 04             	sub    $0x4,%esp
f011cbdc:	68 68 fc 12 f0       	push   $0xf012fc68
f011cbe1:	68 c3 08 00 00       	push   $0x8c3
f011cbe6:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cbeb:	e8 49 37 fe ff       	call   f0100339 <_panic>

f011cbf0 <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011cbf0:	55                   	push   %ebp
f011cbf1:	89 e5                	mov    %esp,%ebp
f011cbf3:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cbf6:	83 ec 04             	sub    $0x4,%esp
f011cbf9:	68 68 fc 12 f0       	push   $0xf012fc68
f011cbfe:	68 c8 08 00 00       	push   $0x8c8
f011cc03:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cc08:	e8 2c 37 fe ff       	call   f0100339 <_panic>

f011cc0d <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011cc0d:	55                   	push   %ebp
f011cc0e:	89 e5                	mov    %esp,%ebp
f011cc10:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cc13:	83 ec 04             	sub    $0x4,%esp
f011cc16:	68 68 fc 12 f0       	push   $0xf012fc68
f011cc1b:	68 cd 08 00 00       	push   $0x8cd
f011cc20:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cc25:	e8 0f 37 fe ff       	call   f0100339 <_panic>

f011cc2a <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011cc2a:	55                   	push   %ebp
f011cc2b:	89 e5                	mov    %esp,%ebp
f011cc2d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cc30:	83 ec 04             	sub    $0x4,%esp
f011cc33:	68 68 fc 12 f0       	push   $0xf012fc68
f011cc38:	68 d2 08 00 00       	push   $0x8d2
f011cc3d:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cc42:	e8 f2 36 fe ff       	call   f0100339 <_panic>

f011cc47 <test_kfree>:
}

int test_kfree()
{
f011cc47:	55                   	push   %ebp
f011cc48:	89 e5                	mov    %esp,%ebp
f011cc4a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cc4d:	83 ec 04             	sub    $0x4,%esp
f011cc50:	68 68 fc 12 f0       	push   $0xf012fc68
f011cc55:	68 d7 08 00 00       	push   $0x8d7
f011cc5a:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cc5f:	e8 d5 36 fe ff       	call   f0100339 <_panic>

f011cc64 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011cc64:	55                   	push   %ebp
f011cc65:	89 e5                	mov    %esp,%ebp
f011cc67:	57                   	push   %edi
f011cc68:	56                   	push   %esi
f011cc69:	53                   	push   %ebx
f011cc6a:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011cc70:	a0 dc ed 17 f0       	mov    0xf017eddc,%al
f011cc75:	84 c0                	test   %al,%al
f011cc77:	74 56                	je     f011cccf <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011cc79:	c6 05 dc ed 17 f0 00 	movb   $0x0,0xf017eddc
		initFreeFrames = sys_calculate_free_frames() ;
f011cc80:	e8 27 15 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011cc85:	a3 a8 61 b0 f0       	mov    %eax,0xf0b061a8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011cc8a:	e8 16 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cc8f:	a3 a4 61 b0 f0       	mov    %eax,0xf0b061a4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011cc94:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011cc9a:	bb cd fd 12 f0       	mov    $0xf012fdcd,%ebx
f011cc9f:	ba 11 00 00 00       	mov    $0x11,%edx
f011cca4:	89 c7                	mov    %eax,%edi
f011cca6:	89 de                	mov    %ebx,%esi
f011cca8:	89 d1                	mov    %edx,%ecx
f011ccaa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011ccac:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011ccb2:	b9 53 00 00 00       	mov    $0x53,%ecx
f011ccb7:	b0 00                	mov    $0x0,%al
f011ccb9:	89 d7                	mov    %edx,%edi
f011ccbb:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011ccbd:	83 ec 0c             	sub    $0xc,%esp
f011ccc0:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011ccc6:	50                   	push   %eax
f011ccc7:	e8 2f 52 fe ff       	call   f0101efb <execute_command>
f011cccc:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011cccf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011ccd6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011ccdd:	a1 40 b3 6b f0       	mov    0xf06bb340,%eax
f011cce2:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011cce5:	eb 2b                	jmp    f011cd12 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011cce7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ccea:	83 c0 20             	add    $0x20,%eax
f011cced:	83 ec 08             	sub    $0x8,%esp
f011ccf0:	68 78 fc 12 f0       	push   $0xf012fc78
f011ccf5:	50                   	push   %eax
f011ccf6:	e8 ea 28 00 00       	call   f011f5e5 <strcmp>
f011ccfb:	83 c4 10             	add    $0x10,%esp
f011ccfe:	85 c0                	test   %eax,%eax
f011cd00:	75 08                	jne    f011cd0a <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011cd02:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011cd05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011cd08:	eb 2f                	jmp    f011cd39 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011cd0a:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f011cd0f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011cd12:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cd16:	74 08                	je     f011cd20 <test_three_creation_functions+0xbc>
f011cd18:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011cd1b:	8b 40 08             	mov    0x8(%eax),%eax
f011cd1e:	eb 05                	jmp    f011cd25 <test_three_creation_functions+0xc1>
f011cd20:	b8 00 00 00 00       	mov    $0x0,%eax
f011cd25:	a3 48 b3 6b f0       	mov    %eax,0xf06bb348
f011cd2a:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f011cd2f:	85 c0                	test   %eax,%eax
f011cd31:	75 b4                	jne    f011cce7 <test_three_creation_functions+0x83>
f011cd33:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cd37:	75 ae                	jne    f011cce7 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011cd39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011cd3c:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011cd42:	85 c0                	test   %eax,%eax
f011cd44:	74 17                	je     f011cd5d <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011cd46:	83 ec 04             	sub    $0x4,%esp
f011cd49:	68 80 fc 12 f0       	push   $0xf012fc80
f011cd4e:	68 f8 08 00 00       	push   $0x8f8
f011cd53:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cd58:	e8 dc 35 fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011cd5d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011cd60:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011cd66:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011cd69:	e8 3e 14 ff ff       	call   f010e1ac <sys_calculate_free_frames>
f011cd6e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011cd71:	e8 2f 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cd76:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011cd79:	a1 a4 61 b0 f0       	mov    0xf0b061a4,%eax
f011cd7e:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011cd81:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011cd84:	74 17                	je     f011cd9d <test_three_creation_functions+0x139>
f011cd86:	83 ec 04             	sub    $0x4,%esp
f011cd89:	68 c0 c6 12 f0       	push   $0xf012c6c0
f011cd8e:	68 02 09 00 00       	push   $0x902
f011cd93:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cd98:	e8 9c 35 fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011cd9d:	a1 a8 61 b0 f0       	mov    0xf0b061a8,%eax
f011cda2:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011cda5:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011cda8:	83 c2 15             	add    $0x15,%edx
f011cdab:	39 d0                	cmp    %edx,%eax
f011cdad:	74 17                	je     f011cdc6 <test_three_creation_functions+0x162>
f011cdaf:	83 ec 04             	sub    $0x4,%esp
f011cdb2:	68 d0 fc 12 f0       	push   $0xf012fcd0
f011cdb7:	68 04 09 00 00       	push   $0x904
f011cdbc:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cdc1:	e8 73 35 fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011cdc6:	83 ec 0c             	sub    $0xc,%esp
f011cdc9:	68 00 10 00 00       	push   $0x1000
f011cdce:	e8 18 c3 fe ff       	call   f01090eb <kmalloc>
f011cdd3:	83 c4 10             	add    $0x10,%esp
f011cdd6:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011cdd9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cddc:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011cde1:	74 17                	je     f011cdfa <test_three_creation_functions+0x196>
f011cde3:	83 ec 04             	sub    $0x4,%esp
f011cde6:	68 10 fd 12 f0       	push   $0xf012fd10
f011cdeb:	68 08 09 00 00       	push   $0x908
f011cdf0:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cdf5:	e8 3f 35 fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011cdfa:	83 ec 0c             	sub    $0xc,%esp
f011cdfd:	68 80 fd 12 f0       	push   $0xf012fd80
f011ce02:	e8 84 41 fe ff       	call   f0100f8b <cprintf>
f011ce07:	83 c4 10             	add    $0x10,%esp

	return 1;
f011ce0a:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011ce0f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011ce12:	5b                   	pop    %ebx
f011ce13:	5e                   	pop    %esi
f011ce14:	5f                   	pop    %edi
f011ce15:	5d                   	pop    %ebp
f011ce16:	c3                   	ret    

f011ce17 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011ce17:	55                   	push   %ebp
f011ce18:	89 e5                	mov    %esp,%ebp
f011ce1a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011ce1d:	83 ec 04             	sub    $0x4,%esp
f011ce20:	68 68 fc 12 f0       	push   $0xf012fc68
f011ce25:	68 16 09 00 00       	push   $0x916
f011ce2a:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011ce2f:	e8 05 35 fe ff       	call   f0100339 <_panic>

f011ce34 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011ce34:	55                   	push   %ebp
f011ce35:	89 e5                	mov    %esp,%ebp
f011ce37:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011ce3a:	83 ec 04             	sub    $0x4,%esp
f011ce3d:	68 68 fc 12 f0       	push   $0xf012fc68
f011ce42:	68 1e 09 00 00       	push   $0x91e
f011ce47:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011ce4c:	e8 e8 34 fe ff       	call   f0100339 <_panic>

f011ce51 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011ce51:	55                   	push   %ebp
f011ce52:	89 e5                	mov    %esp,%ebp
f011ce54:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011ce57:	83 ec 04             	sub    $0x4,%esp
f011ce5a:	68 68 fc 12 f0       	push   $0xf012fc68
f011ce5f:	68 25 09 00 00       	push   $0x925
f011ce64:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011ce69:	e8 cb 34 fe ff       	call   f0100339 <_panic>

f011ce6e <test_kfreelast>:

}


int test_kfreelast()
{
f011ce6e:	55                   	push   %ebp
f011ce6f:	89 e5                	mov    %esp,%ebp
f011ce71:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011ce74:	83 ec 04             	sub    $0x4,%esp
f011ce77:	68 68 fc 12 f0       	push   $0xf012fc68
f011ce7c:	68 2c 09 00 00       	push   $0x92c
f011ce81:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011ce86:	e8 ae 34 fe ff       	call   f0100339 <_panic>

f011ce8b <test_krealloc>:

}

int test_krealloc() {
f011ce8b:	55                   	push   %ebp
f011ce8c:	89 e5                	mov    %esp,%ebp
f011ce8e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011ce91:	83 ec 04             	sub    $0x4,%esp
f011ce94:	68 68 fc 12 f0       	push   $0xf012fc68
f011ce99:	68 31 09 00 00       	push   $0x931
f011ce9e:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cea3:	e8 91 34 fe ff       	call   f0100339 <_panic>

f011cea8 <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011cea8:	55                   	push   %ebp
f011cea9:	89 e5                	mov    %esp,%ebp
f011ceab:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011ceae:	83 ec 04             	sub    $0x4,%esp
f011ceb1:	68 68 fc 12 f0       	push   $0xf012fc68
f011ceb6:	68 36 09 00 00       	push   $0x936
f011cebb:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cec0:	e8 74 34 fe ff       	call   f0100339 <_panic>

f011cec5 <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011cec5:	55                   	push   %ebp
f011cec6:	89 e5                	mov    %esp,%ebp
f011cec8:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cecb:	83 ec 04             	sub    $0x4,%esp
f011cece:	68 68 fc 12 f0       	push   $0xf012fc68
f011ced3:	68 3c 09 00 00       	push   $0x93c
f011ced8:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cedd:	e8 57 34 fe ff       	call   f0100339 <_panic>

f011cee2 <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011cee2:	55                   	push   %ebp
f011cee3:	89 e5                	mov    %esp,%ebp
f011cee5:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cee8:	83 ec 04             	sub    $0x4,%esp
f011ceeb:	68 68 fc 12 f0       	push   $0xf012fc68
f011cef0:	68 41 09 00 00       	push   $0x941
f011cef5:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cefa:	e8 3a 34 fe ff       	call   f0100339 <_panic>

f011ceff <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011ceff:	55                   	push   %ebp
f011cf00:	89 e5                	mov    %esp,%ebp
f011cf02:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf05:	83 ec 04             	sub    $0x4,%esp
f011cf08:	68 68 fc 12 f0       	push   $0xf012fc68
f011cf0d:	68 47 09 00 00       	push   $0x947
f011cf12:	68 a7 c6 12 f0       	push   $0xf012c6a7
f011cf17:	e8 1d 34 fe ff       	call   f0100339 <_panic>

f011cf1c <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011cf1c:	55                   	push   %ebp
f011cf1d:	89 e5                	mov    %esp,%ebp
f011cf1f:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011cf22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011cf29:	e9 84 00 00 00       	jmp    f011cfb2 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011cf2e:	83 ec 08             	sub    $0x8,%esp
f011cf31:	ff 75 f4             	pushl  -0xc(%ebp)
f011cf34:	68 34 fe 12 f0       	push   $0xf012fe34
f011cf39:	e8 4d 40 fe ff       	call   f0100f8b <cprintf>
f011cf3e:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011cf41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011cf48:	eb 4c                	jmp    f011cf96 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011cf4a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011cf4d:	89 d0                	mov    %edx,%eax
f011cf4f:	c1 e0 02             	shl    $0x2,%eax
f011cf52:	01 d0                	add    %edx,%eax
f011cf54:	c1 e0 03             	shl    $0x3,%eax
f011cf57:	89 c2                	mov    %eax,%edx
f011cf59:	8b 45 08             	mov    0x8(%ebp),%eax
f011cf5c:	01 c2                	add    %eax,%edx
f011cf5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011cf61:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011cf64:	85 c0                	test   %eax,%eax
f011cf66:	74 36                	je     f011cf9e <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011cf68:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011cf6b:	89 d0                	mov    %edx,%eax
f011cf6d:	c1 e0 02             	shl    $0x2,%eax
f011cf70:	01 d0                	add    %edx,%eax
f011cf72:	c1 e0 03             	shl    $0x3,%eax
f011cf75:	89 c2                	mov    %eax,%edx
f011cf77:	8b 45 08             	mov    0x8(%ebp),%eax
f011cf7a:	01 c2                	add    %eax,%edx
f011cf7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011cf7f:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011cf82:	83 ec 08             	sub    $0x8,%esp
f011cf85:	50                   	push   %eax
f011cf86:	68 3c fe 12 f0       	push   $0xf012fe3c
f011cf8b:	e8 fb 3f fe ff       	call   f0100f8b <cprintf>
f011cf90:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011cf93:	ff 45 f0             	incl   -0x10(%ebp)
f011cf96:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011cf9a:	7e ae                	jle    f011cf4a <print_order+0x2e>
f011cf9c:	eb 01                	jmp    f011cf9f <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011cf9e:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011cf9f:	83 ec 0c             	sub    $0xc,%esp
f011cfa2:	68 41 fe 12 f0       	push   $0xf012fe41
f011cfa7:	e8 df 3f fe ff       	call   f0100f8b <cprintf>
f011cfac:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011cfaf:	ff 45 f4             	incl   -0xc(%ebp)
f011cfb2:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011cfb6:	0f 8e 72 ff ff ff    	jle    f011cf2e <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011cfbc:	90                   	nop
f011cfbd:	c9                   	leave  
f011cfbe:	c3                   	ret    

f011cfbf <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011cfbf:	55                   	push   %ebp
f011cfc0:	89 e5                	mov    %esp,%ebp
f011cfc2:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011cfc5:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011cfcc:	83 ec 0c             	sub    $0xc,%esp
f011cfcf:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011cfd4:	e8 3f 25 ff ff       	call   f010f518 <acquire_spinlock>
f011cfd9:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011cfdc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011cfe3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011cfea:	8b 55 0c             	mov    0xc(%ebp),%edx
f011cfed:	8b 45 10             	mov    0x10(%ebp),%eax
f011cff0:	01 d0                	add    %edx,%eax
f011cff2:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011cff5:	a1 4c b3 6b f0       	mov    0xf06bb34c,%eax
f011cffa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011cffd:	a1 44 b3 6b f0       	mov    0xf06bb344,%eax
f011d002:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011d005:	ff 75 e8             	pushl  -0x18(%ebp)
f011d008:	ff 75 0c             	pushl  0xc(%ebp)
f011d00b:	ff 75 08             	pushl  0x8(%ebp)
f011d00e:	68 44 fe 12 f0       	push   $0xf012fe44
f011d013:	e8 73 3f fe ff       	call   f0100f8b <cprintf>
f011d018:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d01b:	eb 34                	jmp    f011d051 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011d01d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d020:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d023:	7d 05                	jge    f011d02a <find_in_range+0x6b>
			{
				i++;
f011d025:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011d028:	eb 1e                	jmp    f011d048 <find_in_range+0x89>
			}
			if (i >= end)
f011d02a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d02d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011d030:	7d 29                	jge    f011d05b <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011d032:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d035:	8b 40 10             	mov    0x10(%eax),%eax
f011d038:	3b 45 08             	cmp    0x8(%ebp),%eax
f011d03b:	75 08                	jne    f011d045 <find_in_range+0x86>
			{
				ret = i;
f011d03d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d040:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011d043:	eb 17                	jmp    f011d05c <find_in_range+0x9d>
			}
			i++;
f011d045:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d048:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d04b:	8b 40 0c             	mov    0xc(%eax),%eax
f011d04e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d051:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d054:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d057:	7c c4                	jl     f011d01d <find_in_range+0x5e>
f011d059:	eb 01                	jmp    f011d05c <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011d05b:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011d05c:	83 ec 0c             	sub    $0xc,%esp
f011d05f:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011d064:	e8 36 25 ff ff       	call   f010f59f <release_spinlock>
f011d069:	83 c4 10             	add    $0x10,%esp
	return ret;
f011d06c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011d06f:	c9                   	leave  
f011d070:	c3                   	ret    

f011d071 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011d071:	55                   	push   %ebp
f011d072:	89 e5                	mov    %esp,%ebp
f011d074:	57                   	push   %edi
f011d075:	56                   	push   %esi
f011d076:	53                   	push   %ebx
f011d077:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d07a:	a0 dd ed 17 f0       	mov    0xf017eddd,%al
f011d07f:	84 c0                	test   %al,%al
f011d081:	0f 84 9b 01 00 00    	je     f011d222 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011d087:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011d08e:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d091:	bb bc ff 12 f0       	mov    $0xf012ffbc,%ebx
f011d096:	ba 05 00 00 00       	mov    $0x5,%edx
f011d09b:	89 c7                	mov    %eax,%edi
f011d09d:	89 de                	mov    %ebx,%esi
f011d09f:	89 d1                	mov    %edx,%ecx
f011d0a1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d0a3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d0aa:	e9 44 01 00 00       	jmp    f011d1f3 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011d0af:	6a 00                	push   $0x0
f011d0b1:	6a 00                	push   $0x0
f011d0b3:	68 f4 01 00 00       	push   $0x1f4
f011d0b8:	68 75 fe 12 f0       	push   $0xf012fe75
f011d0bd:	e8 4a d7 fe ff       	call   f010a80c <env_create>
f011d0c2:	83 c4 10             	add    $0x10,%esp
f011d0c5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d0c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d0cb:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d0d0:	99                   	cltd   
f011d0d1:	f7 f9                	idiv   %ecx
f011d0d3:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d0d6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d0d9:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d0dd:	83 ec 08             	sub    $0x8,%esp
f011d0e0:	50                   	push   %eax
f011d0e1:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d0e4:	e8 9d 95 fe ff       	call   f0106686 <env_set_nice>
f011d0e9:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d0ec:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d0f0:	75 14                	jne    f011d106 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011d0f2:	83 ec 04             	sub    $0x4,%esp
f011d0f5:	68 7d fe 12 f0       	push   $0xf012fe7d
f011d0fa:	6a 53                	push   $0x53
f011d0fc:	68 96 fe 12 f0       	push   $0xf012fe96
f011d101:	e8 33 32 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011d106:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d109:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d10f:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d114:	74 14                	je     f011d12a <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011d116:	83 ec 04             	sub    $0x4,%esp
f011d119:	68 b4 fe 12 f0       	push   $0xf012feb4
f011d11e:	6a 55                	push   $0x55
f011d120:	68 96 fe 12 f0       	push   $0xf012fe96
f011d125:	e8 0f 32 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d12a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d12d:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d131:	83 c0 0a             	add    $0xa,%eax
f011d134:	83 f8 14             	cmp    $0x14,%eax
f011d137:	0f 87 a5 00 00 00    	ja     f011d1e2 <test_bsd_nice_0+0x171>
f011d13d:	8b 04 85 d0 ff 12 f0 	mov    -0xfed0030(,%eax,4),%eax
f011d144:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d146:	a1 5c b0 6b f0       	mov    0xf06bb05c,%eax
f011d14b:	8d 50 01             	lea    0x1(%eax),%edx
f011d14e:	89 15 5c b0 6b f0    	mov    %edx,0xf06bb05c
f011d154:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d157:	8b 52 10             	mov    0x10(%edx),%edx
f011d15a:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d161:	eb 7f                	jmp    f011d1e2 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d163:	a1 60 b0 6b f0       	mov    0xf06bb060,%eax
f011d168:	8d 50 01             	lea    0x1(%eax),%edx
f011d16b:	89 15 60 b0 6b f0    	mov    %edx,0xf06bb060
f011d171:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d174:	8b 52 10             	mov    0x10(%edx),%edx
f011d177:	83 c0 0a             	add    $0xa,%eax
f011d17a:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d181:	eb 5f                	jmp    f011d1e2 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d183:	a1 64 b0 6b f0       	mov    0xf06bb064,%eax
f011d188:	8d 50 01             	lea    0x1(%eax),%edx
f011d18b:	89 15 64 b0 6b f0    	mov    %edx,0xf06bb064
f011d191:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d194:	8b 52 10             	mov    0x10(%edx),%edx
f011d197:	83 c0 14             	add    $0x14,%eax
f011d19a:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d1a1:	eb 3f                	jmp    f011d1e2 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d1a3:	a1 68 b0 6b f0       	mov    0xf06bb068,%eax
f011d1a8:	8d 50 01             	lea    0x1(%eax),%edx
f011d1ab:	89 15 68 b0 6b f0    	mov    %edx,0xf06bb068
f011d1b1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d1b4:	8b 52 10             	mov    0x10(%edx),%edx
f011d1b7:	83 c0 1e             	add    $0x1e,%eax
f011d1ba:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d1c1:	eb 1f                	jmp    f011d1e2 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d1c3:	a1 6c b0 6b f0       	mov    0xf06bb06c,%eax
f011d1c8:	8d 50 01             	lea    0x1(%eax),%edx
f011d1cb:	89 15 6c b0 6b f0    	mov    %edx,0xf06bb06c
f011d1d1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d1d4:	8b 52 10             	mov    0x10(%edx),%edx
f011d1d7:	83 c0 28             	add    $0x28,%eax
f011d1da:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d1e1:	90                   	nop
			}
			sched_new_env(env);
f011d1e2:	83 ec 0c             	sub    $0xc,%esp
f011d1e5:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d1e8:	e8 2f 85 fe ff       	call   f010571c <sched_new_env>
f011d1ed:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d1f0:	ff 45 e4             	incl   -0x1c(%ebp)
f011d1f3:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011d1f7:	0f 8e b2 fe ff ff    	jle    f011d0af <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d1fd:	83 ec 0c             	sub    $0xc,%esp
f011d200:	68 e4 fe 12 f0       	push   $0xf012fee4
f011d205:	e8 81 3d fe ff       	call   f0100f8b <cprintf>
f011d20a:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d20d:	83 ec 0c             	sub    $0xc,%esp
f011d210:	68 33 ff 12 f0       	push   $0xf012ff33
f011d215:	e8 e1 4c fe ff       	call   f0101efb <execute_command>
f011d21a:	83 c4 10             	add    $0x10,%esp
f011d21d:	e9 c0 00 00 00       	jmp    f011d2e2 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011d222:	83 ec 0c             	sub    $0xc,%esp
f011d225:	68 3a ff 12 f0       	push   $0xf012ff3a
f011d22a:	e8 5c 3d fe ff       	call   f0100f8b <cprintf>
f011d22f:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d232:	e8 1d 8c fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011d237:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d23e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011d245:	e9 87 00 00 00       	jmp    f011d2d1 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d24a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d251:	eb 52                	jmp    f011d2a5 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011d253:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d256:	8b 14 85 5c b0 6b f0 	mov    -0xf944fa4(,%eax,4),%edx
f011d25d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011d260:	89 c8                	mov    %ecx,%eax
f011d262:	c1 e0 02             	shl    $0x2,%eax
f011d265:	01 c8                	add    %ecx,%eax
f011d267:	01 c0                	add    %eax,%eax
f011d269:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011d26c:	01 c8                	add    %ecx,%eax
f011d26e:	8b 04 85 c0 61 b0 f0 	mov    -0xf4f9e40(,%eax,4),%eax
f011d275:	83 ec 04             	sub    $0x4,%esp
f011d278:	52                   	push   %edx
f011d279:	ff 75 e0             	pushl  -0x20(%ebp)
f011d27c:	50                   	push   %eax
f011d27d:	e8 3d fd ff ff       	call   f011cfbf <find_in_range>
f011d282:	83 c4 10             	add    $0x10,%esp
f011d285:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011d288:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011d28c:	75 14                	jne    f011d2a2 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011d28e:	83 ec 04             	sub    $0x4,%esp
f011d291:	68 4c ff 12 f0       	push   $0xf012ff4c
f011d296:	6a 7b                	push   $0x7b
f011d298:	68 96 fe 12 f0       	push   $0xf012fe96
f011d29d:	e8 97 30 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d2a2:	ff 45 d8             	incl   -0x28(%ebp)
f011d2a5:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d2a8:	89 d0                	mov    %edx,%eax
f011d2aa:	c1 e0 02             	shl    $0x2,%eax
f011d2ad:	01 d0                	add    %edx,%eax
f011d2af:	01 c0                	add    %eax,%eax
f011d2b1:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011d2b4:	01 d0                	add    %edx,%eax
f011d2b6:	8b 04 85 c0 61 b0 f0 	mov    -0xf4f9e40(,%eax,4),%eax
f011d2bd:	85 c0                	test   %eax,%eax
f011d2bf:	75 92                	jne    f011d253 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011d2c1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d2c4:	8b 04 85 5c b0 6b f0 	mov    -0xf944fa4(,%eax,4),%eax
f011d2cb:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d2ce:	ff 45 dc             	incl   -0x24(%ebp)
f011d2d1:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011d2d5:	0f 8e 6f ff ff ff    	jle    f011d24a <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011d2db:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011d2e2:	83 ec 0c             	sub    $0xc,%esp
f011d2e5:	68 80 ff 12 f0       	push   $0xf012ff80
f011d2ea:	e8 9c 3c fe ff       	call   f0100f8b <cprintf>
f011d2ef:	83 c4 10             	add    $0x10,%esp
}
f011d2f2:	90                   	nop
f011d2f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d2f6:	5b                   	pop    %ebx
f011d2f7:	5e                   	pop    %esi
f011d2f8:	5f                   	pop    %edi
f011d2f9:	5d                   	pop    %ebp
f011d2fa:	c3                   	ret    

f011d2fb <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011d2fb:	55                   	push   %ebp
f011d2fc:	89 e5                	mov    %esp,%ebp
f011d2fe:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011d301:	a0 dd ed 17 f0       	mov    0xf017eddd,%al
f011d306:	84 c0                	test   %al,%al
f011d308:	0f 84 50 01 00 00    	je     f011d45e <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011d30e:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011d315:	6a 00                	push   $0x0
f011d317:	6a 00                	push   $0x0
f011d319:	68 f4 01 00 00       	push   $0x1f4
f011d31e:	68 75 fe 12 f0       	push   $0xf012fe75
f011d323:	e8 e4 d4 fe ff       	call   f010a80c <env_create>
f011d328:	83 c4 10             	add    $0x10,%esp
f011d32b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011d32e:	6a 00                	push   $0x0
f011d330:	6a 00                	push   $0x0
f011d332:	68 f4 01 00 00       	push   $0x1f4
f011d337:	68 24 00 13 f0       	push   $0xf0130024
f011d33c:	e8 cb d4 fe ff       	call   f010a80c <env_create>
f011d341:	83 c4 10             	add    $0x10,%esp
f011d344:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011d347:	6a 00                	push   $0x0
f011d349:	6a 00                	push   $0x0
f011d34b:	68 f4 01 00 00       	push   $0x1f4
f011d350:	68 31 00 13 f0       	push   $0xf0130031
f011d355:	e8 b2 d4 fe ff       	call   f010a80c <env_create>
f011d35a:	83 c4 10             	add    $0x10,%esp
f011d35d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011d360:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d364:	74 0c                	je     f011d372 <test_bsd_nice_1+0x77>
f011d366:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011d36a:	74 06                	je     f011d372 <test_bsd_nice_1+0x77>
f011d36c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d370:	75 17                	jne    f011d389 <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011d372:	83 ec 04             	sub    $0x4,%esp
f011d375:	68 7d fe 12 f0       	push   $0xf012fe7d
f011d37a:	68 8e 00 00 00       	push   $0x8e
f011d37f:	68 96 fe 12 f0       	push   $0xf012fe96
f011d384:	e8 b0 2f fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011d389:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d38c:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d392:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d397:	75 20                	jne    f011d3b9 <test_bsd_nice_1+0xbe>
f011d399:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d39c:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d3a2:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d3a7:	75 10                	jne    f011d3b9 <test_bsd_nice_1+0xbe>
f011d3a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d3ac:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d3b2:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d3b7:	74 35                	je     f011d3ee <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011d3b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d3bc:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011d3c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d3c5:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011d3cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d3ce:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d3d4:	83 ec 08             	sub    $0x8,%esp
f011d3d7:	51                   	push   %ecx
f011d3d8:	52                   	push   %edx
f011d3d9:	50                   	push   %eax
f011d3da:	68 40 00 13 f0       	push   $0xf0130040
f011d3df:	68 90 00 00 00       	push   $0x90
f011d3e4:	68 96 fe 12 f0       	push   $0xf012fe96
f011d3e9:	e8 4b 2f fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011d3ee:	83 ec 0c             	sub    $0xc,%esp
f011d3f1:	ff 75 ec             	pushl  -0x14(%ebp)
f011d3f4:	e8 23 83 fe ff       	call   f010571c <sched_new_env>
f011d3f9:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011d3fc:	83 ec 0c             	sub    $0xc,%esp
f011d3ff:	ff 75 e8             	pushl  -0x18(%ebp)
f011d402:	e8 15 83 fe ff       	call   f010571c <sched_new_env>
f011d407:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011d40a:	83 ec 0c             	sub    $0xc,%esp
f011d40d:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d410:	e8 07 83 fe ff       	call   f010571c <sched_new_env>
f011d415:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011d418:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d41b:	8b 40 10             	mov    0x10(%eax),%eax
f011d41e:	a3 c0 61 b0 f0       	mov    %eax,0xf0b061c0
		prog_orders[1][0] = fibEnv->env_id;
f011d423:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d426:	8b 40 10             	mov    0x10(%eax),%eax
f011d429:	a3 e8 61 b0 f0       	mov    %eax,0xf0b061e8
		prog_orders[2][0] = fibposnEnv->env_id;
f011d42e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d431:	8b 40 10             	mov    0x10(%eax),%eax
f011d434:	a3 10 62 b0 f0       	mov    %eax,0xf0b06210
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d439:	83 ec 0c             	sub    $0xc,%esp
f011d43c:	68 e4 fe 12 f0       	push   $0xf012fee4
f011d441:	e8 45 3b fe ff       	call   f0100f8b <cprintf>
f011d446:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d449:	83 ec 0c             	sub    $0xc,%esp
f011d44c:	68 33 ff 12 f0       	push   $0xf012ff33
f011d451:	e8 a5 4a fe ff       	call   f0101efb <execute_command>
f011d456:	83 c4 10             	add    $0x10,%esp
f011d459:	e9 9e 00 00 00       	jmp    f011d4fc <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011d45e:	83 ec 0c             	sub    $0xc,%esp
f011d461:	68 3a ff 12 f0       	push   $0xf012ff3a
f011d466:	e8 20 3b fe ff       	call   f0100f8b <cprintf>
f011d46b:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d46e:	e8 e1 89 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011d473:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011d47a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011d481:	83 ec 0c             	sub    $0xc,%esp
f011d484:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011d489:	e8 8a 20 ff ff       	call   f010f518 <acquire_spinlock>
f011d48e:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d491:	a1 4c b3 6b f0       	mov    0xf06bb34c,%eax
f011d496:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d499:	a1 44 b3 6b f0       	mov    0xf06bb344,%eax
f011d49e:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d4a1:	eb 41                	jmp    f011d4e4 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011d4a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d4a6:	89 d0                	mov    %edx,%eax
f011d4a8:	c1 e0 02             	shl    $0x2,%eax
f011d4ab:	01 d0                	add    %edx,%eax
f011d4ad:	c1 e0 03             	shl    $0x3,%eax
f011d4b0:	05 c0 61 b0 f0       	add    $0xf0b061c0,%eax
f011d4b5:	8b 10                	mov    (%eax),%edx
f011d4b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d4ba:	8b 40 10             	mov    0x10(%eax),%eax
f011d4bd:	39 c2                	cmp    %eax,%edx
f011d4bf:	74 17                	je     f011d4d8 <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011d4c1:	83 ec 04             	sub    $0x4,%esp
f011d4c4:	68 4c ff 12 f0       	push   $0xf012ff4c
f011d4c9:	68 ab 00 00 00       	push   $0xab
f011d4ce:	68 96 fe 12 f0       	push   $0xf012fe96
f011d4d3:	e8 61 2e fe ff       	call   f0100339 <_panic>
				i++;
f011d4d8:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d4db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d4de:	8b 40 0c             	mov    0xc(%eax),%eax
f011d4e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d4e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d4e7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011d4ea:	7c b7                	jl     f011d4a3 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011d4ec:	83 ec 0c             	sub    $0xc,%esp
f011d4ef:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011d4f4:	e8 a6 20 ff ff       	call   f010f59f <release_spinlock>
f011d4f9:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011d4fc:	83 ec 0c             	sub    $0xc,%esp
f011d4ff:	68 ac 00 13 f0       	push   $0xf01300ac
f011d504:	e8 82 3a fe ff       	call   f0100f8b <cprintf>
f011d509:	83 c4 10             	add    $0x10,%esp
}
f011d50c:	90                   	nop
f011d50d:	c9                   	leave  
f011d50e:	c3                   	ret    

f011d50f <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011d50f:	55                   	push   %ebp
f011d510:	89 e5                	mov    %esp,%ebp
f011d512:	57                   	push   %edi
f011d513:	56                   	push   %esi
f011d514:	53                   	push   %ebx
f011d515:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d518:	a0 dd ed 17 f0       	mov    0xf017eddd,%al
f011d51d:	84 c0                	test   %al,%al
f011d51f:	0f 84 ae 01 00 00    	je     f011d6d3 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011d525:	83 ec 0c             	sub    $0xc,%esp
f011d528:	6a 01                	push   $0x1
f011d52a:	e8 fe 10 00 00       	call   f011e62d <chksch>
f011d52f:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011d532:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011d539:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d53c:	bb 30 01 13 f0       	mov    $0xf0130130,%ebx
f011d541:	ba 05 00 00 00       	mov    $0x5,%edx
f011d546:	89 c7                	mov    %eax,%edi
f011d548:	89 de                	mov    %ebx,%esi
f011d54a:	89 d1                	mov    %edx,%ecx
f011d54c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011d54e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d555:	e9 4a 01 00 00       	jmp    f011d6a4 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011d55a:	6a 00                	push   $0x0
f011d55c:	6a 00                	push   $0x0
f011d55e:	68 10 27 00 00       	push   $0x2710
f011d563:	68 e8 00 13 f0       	push   $0xf01300e8
f011d568:	e8 9f d2 fe ff       	call   f010a80c <env_create>
f011d56d:	83 c4 10             	add    $0x10,%esp
f011d570:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d573:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d576:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d57b:	99                   	cltd   
f011d57c:	f7 f9                	idiv   %ecx
f011d57e:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d581:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d584:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d588:	83 ec 08             	sub    $0x8,%esp
f011d58b:	50                   	push   %eax
f011d58c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d58f:	e8 f2 90 fe ff       	call   f0106686 <env_set_nice>
f011d594:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d597:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d59b:	75 17                	jne    f011d5b4 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011d59d:	83 ec 04             	sub    $0x4,%esp
f011d5a0:	68 7d fe 12 f0       	push   $0xf012fe7d
f011d5a5:	68 c1 00 00 00       	push   $0xc1
f011d5aa:	68 96 fe 12 f0       	push   $0xf012fe96
f011d5af:	e8 85 2d fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011d5b4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d5b7:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d5bd:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011d5c2:	74 17                	je     f011d5db <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011d5c4:	83 ec 04             	sub    $0x4,%esp
f011d5c7:	68 b4 fe 12 f0       	push   $0xf012feb4
f011d5cc:	68 c3 00 00 00       	push   $0xc3
f011d5d1:	68 96 fe 12 f0       	push   $0xf012fe96
f011d5d6:	e8 5e 2d fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d5db:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d5de:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d5e2:	83 c0 0f             	add    $0xf,%eax
f011d5e5:	83 f8 1e             	cmp    $0x1e,%eax
f011d5e8:	0f 87 a5 00 00 00    	ja     f011d693 <test_bsd_nice_2+0x184>
f011d5ee:	8b 04 85 44 01 13 f0 	mov    -0xfecfebc(,%eax,4),%eax
f011d5f5:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d5f7:	a1 5c b0 6b f0       	mov    0xf06bb05c,%eax
f011d5fc:	8d 50 01             	lea    0x1(%eax),%edx
f011d5ff:	89 15 5c b0 6b f0    	mov    %edx,0xf06bb05c
f011d605:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d608:	8b 52 10             	mov    0x10(%edx),%edx
f011d60b:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d612:	eb 7f                	jmp    f011d693 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d614:	a1 60 b0 6b f0       	mov    0xf06bb060,%eax
f011d619:	8d 50 01             	lea    0x1(%eax),%edx
f011d61c:	89 15 60 b0 6b f0    	mov    %edx,0xf06bb060
f011d622:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d625:	8b 52 10             	mov    0x10(%edx),%edx
f011d628:	83 c0 0a             	add    $0xa,%eax
f011d62b:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d632:	eb 5f                	jmp    f011d693 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d634:	a1 64 b0 6b f0       	mov    0xf06bb064,%eax
f011d639:	8d 50 01             	lea    0x1(%eax),%edx
f011d63c:	89 15 64 b0 6b f0    	mov    %edx,0xf06bb064
f011d642:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d645:	8b 52 10             	mov    0x10(%edx),%edx
f011d648:	83 c0 14             	add    $0x14,%eax
f011d64b:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d652:	eb 3f                	jmp    f011d693 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d654:	a1 68 b0 6b f0       	mov    0xf06bb068,%eax
f011d659:	8d 50 01             	lea    0x1(%eax),%edx
f011d65c:	89 15 68 b0 6b f0    	mov    %edx,0xf06bb068
f011d662:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d665:	8b 52 10             	mov    0x10(%edx),%edx
f011d668:	83 c0 1e             	add    $0x1e,%eax
f011d66b:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d672:	eb 1f                	jmp    f011d693 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d674:	a1 6c b0 6b f0       	mov    0xf06bb06c,%eax
f011d679:	8d 50 01             	lea    0x1(%eax),%edx
f011d67c:	89 15 6c b0 6b f0    	mov    %edx,0xf06bb06c
f011d682:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d685:	8b 52 10             	mov    0x10(%edx),%edx
f011d688:	83 c0 28             	add    $0x28,%eax
f011d68b:	89 14 85 c0 61 b0 f0 	mov    %edx,-0xf4f9e40(,%eax,4)
				break;
f011d692:	90                   	nop
			}
			sched_new_env(env);
f011d693:	83 ec 0c             	sub    $0xc,%esp
f011d696:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d699:	e8 7e 80 fe ff       	call   f010571c <sched_new_env>
f011d69e:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011d6a1:	ff 45 e4             	incl   -0x1c(%ebp)
f011d6a4:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011d6a8:	0f 8e ac fe ff ff    	jle    f011d55a <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d6ae:	83 ec 0c             	sub    $0xc,%esp
f011d6b1:	68 e4 fe 12 f0       	push   $0xf012fee4
f011d6b6:	e8 d0 38 fe ff       	call   f0100f8b <cprintf>
f011d6bb:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d6be:	83 ec 0c             	sub    $0xc,%esp
f011d6c1:	68 33 ff 12 f0       	push   $0xf012ff33
f011d6c6:	e8 30 48 fe ff       	call   f0101efb <execute_command>
f011d6cb:	83 c4 10             	add    $0x10,%esp
f011d6ce:	e9 d0 00 00 00       	jmp    f011d7a3 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011d6d3:	83 ec 0c             	sub    $0xc,%esp
f011d6d6:	6a 00                	push   $0x0
f011d6d8:	e8 50 0f 00 00       	call   f011e62d <chksch>
f011d6dd:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011d6e0:	83 ec 0c             	sub    $0xc,%esp
f011d6e3:	68 3a ff 12 f0       	push   $0xf012ff3a
f011d6e8:	e8 9e 38 fe ff       	call   f0100f8b <cprintf>
f011d6ed:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d6f0:	e8 5f 87 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011d6f5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d6fc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011d703:	e9 8a 00 00 00       	jmp    f011d792 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d708:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d70f:	eb 55                	jmp    f011d766 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011d711:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d714:	8b 14 85 5c b0 6b f0 	mov    -0xf944fa4(,%eax,4),%edx
f011d71b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011d71e:	89 c8                	mov    %ecx,%eax
f011d720:	c1 e0 02             	shl    $0x2,%eax
f011d723:	01 c8                	add    %ecx,%eax
f011d725:	01 c0                	add    %eax,%eax
f011d727:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011d72a:	01 c8                	add    %ecx,%eax
f011d72c:	8b 04 85 c0 61 b0 f0 	mov    -0xf4f9e40(,%eax,4),%eax
f011d733:	83 ec 04             	sub    $0x4,%esp
f011d736:	52                   	push   %edx
f011d737:	ff 75 e0             	pushl  -0x20(%ebp)
f011d73a:	50                   	push   %eax
f011d73b:	e8 7f f8 ff ff       	call   f011cfbf <find_in_range>
f011d740:	83 c4 10             	add    $0x10,%esp
f011d743:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011d746:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011d74a:	75 17                	jne    f011d763 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011d74c:	83 ec 04             	sub    $0x4,%esp
f011d74f:	68 4c ff 12 f0       	push   $0xf012ff4c
f011d754:	68 ea 00 00 00       	push   $0xea
f011d759:	68 96 fe 12 f0       	push   $0xf012fe96
f011d75e:	e8 d6 2b fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d763:	ff 45 d8             	incl   -0x28(%ebp)
f011d766:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d769:	89 d0                	mov    %edx,%eax
f011d76b:	c1 e0 02             	shl    $0x2,%eax
f011d76e:	01 d0                	add    %edx,%eax
f011d770:	01 c0                	add    %eax,%eax
f011d772:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011d775:	01 d0                	add    %edx,%eax
f011d777:	8b 04 85 c0 61 b0 f0 	mov    -0xf4f9e40(,%eax,4),%eax
f011d77e:	85 c0                	test   %eax,%eax
f011d780:	75 8f                	jne    f011d711 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011d782:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d785:	8b 04 85 5c b0 6b f0 	mov    -0xf944fa4(,%eax,4),%eax
f011d78c:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d78f:	ff 45 dc             	incl   -0x24(%ebp)
f011d792:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011d796:	0f 8e 6c ff ff ff    	jle    f011d708 <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011d79c:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011d7a3:	83 ec 0c             	sub    $0xc,%esp
f011d7a6:	68 f4 00 13 f0       	push   $0xf01300f4
f011d7ab:	e8 db 37 fe ff       	call   f0100f8b <cprintf>
f011d7b0:	83 c4 10             	add    $0x10,%esp
}
f011d7b3:	90                   	nop
f011d7b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d7b7:	5b                   	pop    %ebx
f011d7b8:	5e                   	pop    %esi
f011d7b9:	5f                   	pop    %edi
f011d7ba:	5d                   	pop    %ebp
f011d7bb:	c3                   	ret    

f011d7bc <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011d7bc:	55                   	push   %ebp
f011d7bd:	89 e5                	mov    %esp,%ebp
f011d7bf:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011d7c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d7c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011d7c8:	8b 45 08             	mov    0x8(%ebp),%eax
f011d7cb:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011d7ce:	89 10                	mov    %edx,(%eax)
}
f011d7d0:	8b 45 08             	mov    0x8(%ebp),%eax
f011d7d3:	c9                   	leave  
f011d7d4:	c2 04 00             	ret    $0x4

f011d7d7 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011d7d7:	55                   	push   %ebp
f011d7d8:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011d7da:	8b 45 08             	mov    0x8(%ebp),%eax
f011d7dd:	85 c0                	test   %eax,%eax
f011d7df:	78 16                	js     f011d7f7 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011d7e1:	8b 45 08             	mov    0x8(%ebp),%eax
f011d7e4:	05 00 20 00 00       	add    $0x2000,%eax
f011d7e9:	85 c0                	test   %eax,%eax
f011d7eb:	79 05                	jns    f011d7f2 <fix_round+0x1b>
f011d7ed:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011d7f2:	c1 f8 0e             	sar    $0xe,%eax
f011d7f5:	eb 14                	jmp    f011d80b <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011d7f7:	8b 45 08             	mov    0x8(%ebp),%eax
f011d7fa:	2d 00 20 00 00       	sub    $0x2000,%eax
f011d7ff:	85 c0                	test   %eax,%eax
f011d801:	79 05                	jns    f011d808 <fix_round+0x31>
f011d803:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011d808:	c1 f8 0e             	sar    $0xe,%eax
}
f011d80b:	5d                   	pop    %ebp
f011d80c:	c3                   	ret    

f011d80d <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011d80d:	55                   	push   %ebp
f011d80e:	89 e5                	mov    %esp,%ebp
f011d810:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011d813:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011d817:	79 16                	jns    f011d82f <fix_scale+0x22>
f011d819:	68 c0 01 13 f0       	push   $0xf01301c0
f011d81e:	68 c7 01 13 f0       	push   $0xf01301c7
f011d823:	6a 5a                	push   $0x5a
f011d825:	68 dc 01 13 f0       	push   $0xf01301dc
f011d82a:	e8 0a 2b fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011d82f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d832:	0f af 45 10          	imul   0x10(%ebp),%eax
f011d836:	89 c2                	mov    %eax,%edx
f011d838:	8b 45 08             	mov    0x8(%ebp),%eax
f011d83b:	83 ec 08             	sub    $0x8,%esp
f011d83e:	52                   	push   %edx
f011d83f:	50                   	push   %eax
f011d840:	e8 77 ff ff ff       	call   f011d7bc <__mk_fix>
f011d845:	83 c4 0c             	add    $0xc,%esp
}
f011d848:	8b 45 08             	mov    0x8(%ebp),%eax
f011d84b:	c9                   	leave  
f011d84c:	c2 04 00             	ret    $0x4

f011d84f <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011d84f:	55                   	push   %ebp
f011d850:	89 e5                	mov    %esp,%ebp
f011d852:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011d855:	83 ec 08             	sub    $0x8,%esp
f011d858:	68 f0 01 13 f0       	push   $0xf01301f0
f011d85d:	68 c0 ba 6b f0       	push   $0xf06bbac0
f011d862:	e8 80 1c ff ff       	call   f010f4e7 <init_spinlock>
f011d867:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011d86a:	83 ec 0c             	sub    $0xc,%esp
f011d86d:	68 c0 ba 6b f0       	push   $0xf06bbac0
f011d872:	e8 a1 1c ff ff       	call   f010f518 <acquire_spinlock>
f011d877:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011d87a:	c7 05 a8 b1 6b f0 00 	movl   $0x0,0xf06bb1a8
f011d881:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011d884:	83 ec 0c             	sub    $0xc,%esp
f011d887:	68 c0 ba 6b f0       	push   $0xf06bbac0
f011d88c:	e8 0e 1d ff ff       	call   f010f59f <release_spinlock>
f011d891:	83 c4 10             	add    $0x10,%esp
}
f011d894:	90                   	nop
f011d895:	c9                   	leave  
f011d896:	c3                   	ret    

f011d897 <inctst>:
void inctst()
{
f011d897:	55                   	push   %ebp
f011d898:	89 e5                	mov    %esp,%ebp
f011d89a:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011d89d:	83 ec 0c             	sub    $0xc,%esp
f011d8a0:	68 c0 ba 6b f0       	push   $0xf06bbac0
f011d8a5:	e8 6e 1c ff ff       	call   f010f518 <acquire_spinlock>
f011d8aa:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011d8ad:	a1 a8 b1 6b f0       	mov    0xf06bb1a8,%eax
f011d8b2:	40                   	inc    %eax
f011d8b3:	a3 a8 b1 6b f0       	mov    %eax,0xf06bb1a8
	}
	release_spinlock(&tstcntlock);
f011d8b8:	83 ec 0c             	sub    $0xc,%esp
f011d8bb:	68 c0 ba 6b f0       	push   $0xf06bbac0
f011d8c0:	e8 da 1c ff ff       	call   f010f59f <release_spinlock>
f011d8c5:	83 c4 10             	add    $0x10,%esp
}
f011d8c8:	90                   	nop
f011d8c9:	c9                   	leave  
f011d8ca:	c3                   	ret    

f011d8cb <gettst>:
uint32 gettst()
{
f011d8cb:	55                   	push   %ebp
f011d8cc:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011d8ce:	a1 a8 b1 6b f0       	mov    0xf06bb1a8,%eax
}
f011d8d3:	5d                   	pop    %ebp
f011d8d4:	c3                   	ret    

f011d8d5 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011d8d5:	55                   	push   %ebp
f011d8d6:	89 e5                	mov    %esp,%ebp
f011d8d8:	83 ec 28             	sub    $0x28,%esp
f011d8db:	8b 45 14             	mov    0x14(%ebp),%eax
f011d8de:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011d8e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011d8e8:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011d8ec:	83 f8 65             	cmp    $0x65,%eax
f011d8ef:	74 5d                	je     f011d94e <tst+0x79>
f011d8f1:	83 f8 65             	cmp    $0x65,%eax
f011d8f4:	7f 0a                	jg     f011d900 <tst+0x2b>
f011d8f6:	83 f8 62             	cmp    $0x62,%eax
f011d8f9:	74 73                	je     f011d96e <tst+0x99>
f011d8fb:	e9 91 00 00 00       	jmp    f011d991 <tst+0xbc>
f011d900:	83 f8 67             	cmp    $0x67,%eax
f011d903:	74 29                	je     f011d92e <tst+0x59>
f011d905:	83 f8 6c             	cmp    $0x6c,%eax
f011d908:	0f 85 83 00 00 00    	jne    f011d991 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011d90e:	8b 45 08             	mov    0x8(%ebp),%eax
f011d911:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d914:	73 09                	jae    f011d91f <tst+0x4a>
			chk = 1;
f011d916:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011d91d:	eb 68                	jmp    f011d987 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011d91f:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011d923:	74 62                	je     f011d987 <tst+0xb2>
			chk = 1;
f011d925:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011d92c:	eb 59                	jmp    f011d987 <tst+0xb2>
	case 'g':
		if (n > v1)
f011d92e:	8b 45 08             	mov    0x8(%ebp),%eax
f011d931:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d934:	76 09                	jbe    f011d93f <tst+0x6a>
			chk = 1;
f011d936:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011d93d:	eb 4b                	jmp    f011d98a <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011d93f:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011d943:	74 45                	je     f011d98a <tst+0xb5>
			chk = 1;
f011d945:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011d94c:	eb 3c                	jmp    f011d98a <tst+0xb5>
	case 'e':
		if (n == v1)
f011d94e:	8b 45 08             	mov    0x8(%ebp),%eax
f011d951:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d954:	75 09                	jne    f011d95f <tst+0x8a>
			chk = 1;
f011d956:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011d95d:	eb 2e                	jmp    f011d98d <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011d95f:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011d963:	74 28                	je     f011d98d <tst+0xb8>
			chk = 1;
f011d965:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011d96c:	eb 1f                	jmp    f011d98d <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011d96e:	8b 45 08             	mov    0x8(%ebp),%eax
f011d971:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d974:	72 1a                	jb     f011d990 <tst+0xbb>
f011d976:	8b 45 08             	mov    0x8(%ebp),%eax
f011d979:	3b 45 10             	cmp    0x10(%ebp),%eax
f011d97c:	77 12                	ja     f011d990 <tst+0xbb>
			chk = 1;
f011d97e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011d985:	eb 09                	jmp    f011d990 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011d987:	90                   	nop
f011d988:	eb 07                	jmp    f011d991 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011d98a:	90                   	nop
f011d98b:	eb 04                	jmp    f011d991 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011d98d:	90                   	nop
f011d98e:	eb 01                	jmp    f011d991 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011d990:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011d991:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d995:	75 14                	jne    f011d9ab <tst+0xd6>
f011d997:	83 ec 04             	sub    $0x4,%esp
f011d99a:	68 fc 01 13 f0       	push   $0xf01301fc
f011d99f:	6a 48                	push   $0x48
f011d9a1:	68 0f 02 13 f0       	push   $0xf013020f
f011d9a6:	e8 8e 29 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011d9ab:	83 ec 0c             	sub    $0xc,%esp
f011d9ae:	68 c0 ba 6b f0       	push   $0xf06bbac0
f011d9b3:	e8 60 1b ff ff       	call   f010f518 <acquire_spinlock>
f011d9b8:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011d9bb:	a1 a8 b1 6b f0       	mov    0xf06bb1a8,%eax
f011d9c0:	40                   	inc    %eax
f011d9c1:	a3 a8 b1 6b f0       	mov    %eax,0xf06bb1a8
	}
	release_spinlock(&tstcntlock);
f011d9c6:	83 ec 0c             	sub    $0xc,%esp
f011d9c9:	68 c0 ba 6b f0       	push   $0xf06bbac0
f011d9ce:	e8 cc 1b ff ff       	call   f010f59f <release_spinlock>
f011d9d3:	83 c4 10             	add    $0x10,%esp

	return;
f011d9d6:	90                   	nop
}
f011d9d7:	c9                   	leave  
f011d9d8:	c3                   	ret    

f011d9d9 <chktst>:

void chktst(uint32 n)
{
f011d9d9:	55                   	push   %ebp
f011d9da:	89 e5                	mov    %esp,%ebp
f011d9dc:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011d9df:	83 ec 0c             	sub    $0xc,%esp
f011d9e2:	68 c0 ba 6b f0       	push   $0xf06bbac0
f011d9e7:	e8 2c 1b ff ff       	call   f010f518 <acquire_spinlock>
f011d9ec:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011d9ef:	a1 a8 b1 6b f0       	mov    0xf06bb1a8,%eax
f011d9f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011d9f7:	83 ec 0c             	sub    $0xc,%esp
f011d9fa:	68 c0 ba 6b f0       	push   $0xf06bbac0
f011d9ff:	e8 9b 1b ff ff       	call   f010f59f <release_spinlock>
f011da04:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011da07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011da0a:	3b 45 08             	cmp    0x8(%ebp),%eax
f011da0d:	75 12                	jne    f011da21 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011da0f:	83 ec 0c             	sub    $0xc,%esp
f011da12:	68 28 02 13 f0       	push   $0xf0130228
f011da17:	e8 6f 35 fe ff       	call   f0100f8b <cprintf>
f011da1c:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011da1f:	eb 14                	jmp    f011da35 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011da21:	83 ec 04             	sub    $0x4,%esp
f011da24:	68 54 02 13 f0       	push   $0xf0130254
f011da29:	6a 5e                	push   $0x5e
f011da2b:	68 0f 02 13 f0       	push   $0xf013020f
f011da30:	e8 04 29 fe ff       	call   f0100339 <_panic>
}
f011da35:	c9                   	leave  
f011da36:	c3                   	ret    

f011da37 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011da37:	55                   	push   %ebp
f011da38:	89 e5                	mov    %esp,%ebp
f011da3a:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011da3d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011da41:	77 07                	ja     f011da4a <nearest_pow2_ceil+0x13>
f011da43:	b8 01 00 00 00       	mov    $0x1,%eax
f011da48:	eb 20                	jmp    f011da6a <nearest_pow2_ceil+0x33>
	int power = 2;
f011da4a:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011da51:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011da54:	eb 08                	jmp    f011da5e <nearest_pow2_ceil+0x27>
		power <<= 1;
f011da56:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011da59:	01 c0                	add    %eax,%eax
f011da5b:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011da5e:	d1 6d 08             	shrl   0x8(%ebp)
f011da61:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011da65:	75 ef                	jne    f011da56 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011da67:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011da6a:	c9                   	leave  
f011da6b:	c3                   	ret    

f011da6c <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011da6c:	55                   	push   %ebp
f011da6d:	89 e5                	mov    %esp,%ebp
f011da6f:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011da72:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011da76:	77 07                	ja     f011da7f <log2_ceil+0x13>
f011da78:	b8 01 00 00 00       	mov    $0x1,%eax
f011da7d:	eb 1b                	jmp    f011da9a <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011da7f:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011da86:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011da89:	eb 03                	jmp    f011da8e <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011da8b:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011da8e:	d1 6d 08             	shrl   0x8(%ebp)
f011da91:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011da95:	75 f4                	jne    f011da8b <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011da97:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011da9a:	c9                   	leave  
f011da9b:	c3                   	ret    

f011da9c <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011da9c:	55                   	push   %ebp
f011da9d:	89 e5                	mov    %esp,%ebp
f011da9f:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011daa2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011daa9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011dab0:	eb 12                	jmp    f011dac4 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011dab2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dab5:	89 d0                	mov    %edx,%eax
f011dab7:	c1 e0 02             	shl    $0x2,%eax
f011daba:	01 d0                	add    %edx,%eax
f011dabc:	01 c0                	add    %eax,%eax
f011dabe:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011dac1:	ff 45 f0             	incl   -0x10(%ebp)
f011dac4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dac7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011daca:	7c e6                	jl     f011dab2 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011dacc:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011dacf:	83 ec 04             	sub    $0x4,%esp
f011dad2:	ff 75 f4             	pushl  -0xc(%ebp)
f011dad5:	ff 75 08             	pushl  0x8(%ebp)
f011dad8:	50                   	push   %eax
f011dad9:	e8 2f fd ff ff       	call   f011d80d <fix_scale>
f011dade:	83 c4 0c             	add    $0xc,%esp
f011dae1:	83 ec 0c             	sub    $0xc,%esp
f011dae4:	ff 75 dc             	pushl  -0x24(%ebp)
f011dae7:	e8 eb fc ff ff       	call   f011d7d7 <fix_round>
f011daec:	83 c4 10             	add    $0x10,%esp
f011daef:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011daf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011daf5:	99                   	cltd   
f011daf6:	f7 7d f4             	idivl  -0xc(%ebp)
f011daf9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011dafc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011daff:	99                   	cltd   
f011db00:	f7 7d f4             	idivl  -0xc(%ebp)
f011db03:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011db06:	83 ec 08             	sub    $0x8,%esp
f011db09:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011db0c:	50                   	push   %eax
f011db0d:	ff 75 e4             	pushl  -0x1c(%ebp)
f011db10:	e8 6a 1e 00 00       	call   f011f97f <ltostr>
f011db15:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011db18:	83 ec 08             	sub    $0x8,%esp
f011db1b:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011db1e:	50                   	push   %eax
f011db1f:	ff 75 e0             	pushl  -0x20(%ebp)
f011db22:	e8 58 1e 00 00       	call   f011f97f <ltostr>
f011db27:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011db2a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011db2d:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011db32:	f7 e9                	imul   %ecx
f011db34:	c1 fa 02             	sar    $0x2,%edx
f011db37:	89 c8                	mov    %ecx,%eax
f011db39:	c1 f8 1f             	sar    $0x1f,%eax
f011db3c:	29 c2                	sub    %eax,%edx
f011db3e:	89 d0                	mov    %edx,%eax
f011db40:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011db43:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011db4a:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011db51:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011db57:	eb 31                	jmp    f011db8a <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011db59:	83 ec 04             	sub    $0x4,%esp
f011db5c:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011db5f:	50                   	push   %eax
f011db60:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011db63:	50                   	push   %eax
f011db64:	68 70 02 13 f0       	push   $0xf0130270
f011db69:	e8 ea 1e 00 00       	call   f011fa58 <strcconcat>
f011db6e:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011db71:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011db74:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011db79:	f7 e9                	imul   %ecx
f011db7b:	c1 fa 02             	sar    $0x2,%edx
f011db7e:	89 c8                	mov    %ecx,%eax
f011db80:	c1 f8 1f             	sar    $0x1f,%eax
f011db83:	29 c2                	sub    %eax,%edx
f011db85:	89 d0                	mov    %edx,%eax
f011db87:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011db8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011db8d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011db90:	7c c7                	jl     f011db59 <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011db92:	83 ec 04             	sub    $0x4,%esp
f011db95:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011db98:	50                   	push   %eax
f011db99:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011db9c:	50                   	push   %eax
f011db9d:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011dba0:	50                   	push   %eax
f011dba1:	e8 b2 1e 00 00       	call   f011fa58 <strcconcat>
f011dba6:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011dba9:	83 ec 04             	sub    $0x4,%esp
f011dbac:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dbaf:	50                   	push   %eax
f011dbb0:	68 72 02 13 f0       	push   $0xf0130272
f011dbb5:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dbb8:	50                   	push   %eax
f011dbb9:	e8 9a 1e 00 00       	call   f011fa58 <strcconcat>
f011dbbe:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011dbc1:	83 ec 04             	sub    $0x4,%esp
f011dbc4:	ff 75 10             	pushl  0x10(%ebp)
f011dbc7:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011dbca:	50                   	push   %eax
f011dbcb:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dbce:	50                   	push   %eax
f011dbcf:	e8 84 1e 00 00       	call   f011fa58 <strcconcat>
f011dbd4:	83 c4 10             	add    $0x10,%esp

}
f011dbd7:	90                   	nop
f011dbd8:	c9                   	leave  
f011dbd9:	c3                   	ret    

f011dbda <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011dbda:	55                   	push   %ebp
f011dbdb:	89 e5                	mov    %esp,%ebp
f011dbdd:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011dbe3:	83 ec 0c             	sub    $0xc,%esp
f011dbe6:	68 74 02 13 f0       	push   $0xf0130274
f011dbeb:	e8 e9 18 00 00       	call   f011f4d9 <strlen>
f011dbf0:	83 c4 10             	add    $0x10,%esp
f011dbf3:	83 ec 04             	sub    $0x4,%esp
f011dbf6:	50                   	push   %eax
f011dbf7:	68 74 02 13 f0       	push   $0xf0130274
f011dbfc:	ff 75 08             	pushl  0x8(%ebp)
f011dbff:	e8 19 1a 00 00       	call   f011f61d <strncmp>
f011dc04:	83 c4 10             	add    $0x10,%esp
f011dc07:	85 c0                	test   %eax,%eax
f011dc09:	0f 85 8a 00 00 00    	jne    f011dc99 <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011dc0f:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011dc12:	50                   	push   %eax
f011dc13:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011dc19:	50                   	push   %eax
f011dc1a:	68 82 02 13 f0       	push   $0xf0130282
f011dc1f:	ff 75 08             	pushl  0x8(%ebp)
f011dc22:	e8 c7 1e 00 00       	call   f011faee <strsplit>
f011dc27:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011dc2a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011dc30:	83 ec 04             	sub    $0x4,%esp
f011dc33:	6a 0a                	push   $0xa
f011dc35:	6a 00                	push   $0x0
f011dc37:	50                   	push   %eax
f011dc38:	e8 fc 1b 00 00       	call   f011f839 <strtol>
f011dc3d:	83 c4 10             	add    $0x10,%esp
f011dc40:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011dc43:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011dc4a:	83 ec 04             	sub    $0x4,%esp
f011dc4d:	6a 00                	push   $0x0
f011dc4f:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011dc52:	50                   	push   %eax
f011dc53:	ff 75 e0             	pushl  -0x20(%ebp)
f011dc56:	e8 7f d6 fe ff       	call   f010b2da <envid2env>
f011dc5b:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011dc5e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011dc61:	8b 40 10             	mov    0x10(%eax),%eax
f011dc64:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011dc67:	74 19                	je     f011dc82 <sys_utilities+0xa8>
f011dc69:	68 84 02 13 f0       	push   $0xf0130284
f011dc6e:	68 c7 01 13 f0       	push   $0xf01301c7
f011dc73:	68 a4 00 00 00       	push   $0xa4
f011dc78:	68 0f 02 13 f0       	push   $0xf013020f
f011dc7d:	e8 b7 26 fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011dc82:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011dc85:	83 ec 08             	sub    $0x8,%esp
f011dc88:	ff 75 0c             	pushl  0xc(%ebp)
f011dc8b:	50                   	push   %eax
f011dc8c:	e8 f5 89 fe ff       	call   f0106686 <env_set_nice>
f011dc91:	83 c4 10             	add    $0x10,%esp
f011dc94:	e9 12 04 00 00       	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011dc99:	83 ec 0c             	sub    $0xc,%esp
f011dc9c:	68 99 02 13 f0       	push   $0xf0130299
f011dca1:	e8 33 18 00 00       	call   f011f4d9 <strlen>
f011dca6:	83 c4 10             	add    $0x10,%esp
f011dca9:	83 ec 04             	sub    $0x4,%esp
f011dcac:	50                   	push   %eax
f011dcad:	68 99 02 13 f0       	push   $0xf0130299
f011dcb2:	ff 75 08             	pushl  0x8(%ebp)
f011dcb5:	e8 63 19 00 00       	call   f011f61d <strncmp>
f011dcba:	83 c4 10             	add    $0x10,%esp
f011dcbd:	85 c0                	test   %eax,%eax
f011dcbf:	0f 85 a6 01 00 00    	jne    f011de6b <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011dcc5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011dcc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011dccb:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011dcce:	50                   	push   %eax
f011dccf:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011dcd5:	50                   	push   %eax
f011dcd6:	68 82 02 13 f0       	push   $0xf0130282
f011dcdb:	ff 75 08             	pushl  0x8(%ebp)
f011dcde:	e8 0b 1e 00 00       	call   f011faee <strsplit>
f011dce3:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011dce6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011dcec:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011dcef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011dcf6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011dcfd:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011dd04:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dd07:	8b 00                	mov    (%eax),%eax
f011dd09:	85 c0                	test   %eax,%eax
f011dd0b:	79 1c                	jns    f011dd29 <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011dd0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011dd14:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dd17:	8b 00                	mov    (%eax),%eax
f011dd19:	f7 d8                	neg    %eax
f011dd1b:	89 c2                	mov    %eax,%edx
f011dd1d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dd20:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011dd22:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011dd29:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011dd30:	83 ec 0c             	sub    $0xc,%esp
f011dd33:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011dd38:	e8 db 17 ff ff       	call   f010f518 <acquire_spinlock>
f011dd3d:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011dd40:	a1 4c b3 6b f0       	mov    0xf06bb34c,%eax
f011dd45:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011dd48:	a1 44 b3 6b f0       	mov    0xf06bb344,%eax
f011dd4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011dd50:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011dd53:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011dd56:	eb 6c                	jmp    f011ddc4 <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011dd58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dd5b:	83 c0 20             	add    $0x20,%eax
f011dd5e:	83 ec 08             	sub    $0x8,%esp
f011dd61:	ff 75 d8             	pushl  -0x28(%ebp)
f011dd64:	50                   	push   %eax
f011dd65:	e8 7b 18 00 00       	call   f011f5e5 <strcmp>
f011dd6a:	83 c4 10             	add    $0x10,%esp
f011dd6d:	85 c0                	test   %eax,%eax
f011dd6f:	75 46                	jne    f011ddb7 <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011dd71:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dd74:	8b 00                	mov    (%eax),%eax
f011dd76:	8d 50 ff             	lea    -0x1(%eax),%edx
f011dd79:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dd7c:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011dd7e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011dd82:	74 14                	je     f011dd98 <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011dd84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dd87:	8b 40 10             	mov    0x10(%eax),%eax
f011dd8a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dd8d:	7d 1d                	jge    f011ddac <sys_utilities+0x1d2>
					{
						success = 0;
f011dd8f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011dd96:	eb 32                	jmp    f011ddca <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011dd98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dd9b:	8b 40 10             	mov    0x10(%eax),%eax
f011dd9e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dda1:	7e 09                	jle    f011ddac <sys_utilities+0x1d2>
					{
						success = 0;
f011dda3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011ddaa:	eb 1e                	jmp    f011ddca <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011ddac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ddaf:	8b 40 10             	mov    0x10(%eax),%eax
f011ddb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ddb5:	eb 01                	jmp    f011ddb8 <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011ddb7:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011ddb8:	ff 4d e4             	decl   -0x1c(%ebp)
f011ddbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ddbe:	8b 40 0c             	mov    0xc(%eax),%eax
f011ddc1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ddc4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ddc8:	7f 8e                	jg     f011dd58 <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011ddca:	83 ec 0c             	sub    $0xc,%esp
f011ddcd:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011ddd2:	e8 c8 17 ff ff       	call   f010f59f <release_spinlock>
f011ddd7:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011ddda:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dddd:	8b 00                	mov    (%eax),%eax
f011dddf:	85 c0                	test   %eax,%eax
f011dde1:	75 06                	jne    f011dde9 <sys_utilities+0x20f>
f011dde3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011dde7:	75 41                	jne    f011de2a <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011dde9:	83 ec 0c             	sub    $0xc,%esp
f011ddec:	68 ac 02 13 f0       	push   $0xf01302ac
f011ddf1:	e8 95 31 fe ff       	call   f0100f8b <cprintf>
f011ddf6:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011ddf9:	83 ec 08             	sub    $0x8,%esp
f011ddfc:	ff 75 d8             	pushl  -0x28(%ebp)
f011ddff:	68 dc 02 13 f0       	push   $0xf01302dc
f011de04:	e8 82 31 fe ff       	call   f0100f8b <cprintf>
f011de09:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011de0c:	83 ec 0c             	sub    $0xc,%esp
f011de0f:	68 ac 02 13 f0       	push   $0xf01302ac
f011de14:	e8 72 31 fe ff       	call   f0100f8b <cprintf>
f011de19:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011de1c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de1f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011de25:	e9 81 02 00 00       	jmp    f011e0ab <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011de2a:	83 ec 0c             	sub    $0xc,%esp
f011de2d:	68 fc 02 13 f0       	push   $0xf01302fc
f011de32:	e8 54 31 fe ff       	call   f0100f8b <cprintf>
f011de37:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011de3a:	83 ec 08             	sub    $0x8,%esp
f011de3d:	ff 75 d8             	pushl  -0x28(%ebp)
f011de40:	68 34 03 13 f0       	push   $0xf0130334
f011de45:	e8 41 31 fe ff       	call   f0100f8b <cprintf>
f011de4a:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011de4d:	83 ec 0c             	sub    $0xc,%esp
f011de50:	68 fc 02 13 f0       	push   $0xf01302fc
f011de55:	e8 31 31 fe ff       	call   f0100f8b <cprintf>
f011de5a:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011de5d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de60:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011de66:	e9 40 02 00 00       	jmp    f011e0ab <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011de6b:	83 ec 08             	sub    $0x8,%esp
f011de6e:	68 57 03 13 f0       	push   $0xf0130357
f011de73:	ff 75 08             	pushl  0x8(%ebp)
f011de76:	e8 6a 17 00 00       	call   f011f5e5 <strcmp>
f011de7b:	83 c4 10             	add    $0x10,%esp
f011de7e:	85 c0                	test   %eax,%eax
f011de80:	75 77                	jne    f011def9 <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011de82:	a1 e0 ed 17 f0       	mov    0xf017ede0,%eax
f011de87:	85 c0                	test   %eax,%eax
f011de89:	74 34                	je     f011debf <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011de8b:	c7 05 e0 ed 17 f0 00 	movl   $0x0,0xf017ede0
f011de92:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011de95:	83 ec 08             	sub    $0x8,%esp
f011de98:	68 61 03 13 f0       	push   $0xf0130361
f011de9d:	68 a0 62 b0 f0       	push   $0xf0b062a0
f011dea2:	e8 31 1a ff ff       	call   f010f8d8 <init_channel>
f011dea7:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011deaa:	83 ec 08             	sub    $0x8,%esp
f011dead:	68 6e 03 13 f0       	push   $0xf013036e
f011deb2:	68 20 64 b0 f0       	push   $0xf0b06420
f011deb7:	e8 2b 16 ff ff       	call   f010f4e7 <init_spinlock>
f011debc:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011debf:	83 ec 0c             	sub    $0xc,%esp
f011dec2:	68 20 64 b0 f0       	push   $0xf0b06420
f011dec7:	e8 4c 16 ff ff       	call   f010f518 <acquire_spinlock>
f011decc:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011decf:	83 ec 08             	sub    $0x8,%esp
f011ded2:	68 20 64 b0 f0       	push   $0xf0b06420
f011ded7:	68 a0 62 b0 f0       	push   $0xf0b062a0
f011dedc:	e8 24 1a ff ff       	call   f010f905 <sleep>
f011dee1:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011dee4:	83 ec 0c             	sub    $0xc,%esp
f011dee7:	68 20 64 b0 f0       	push   $0xf0b06420
f011deec:	e8 ae 16 ff ff       	call   f010f59f <release_spinlock>
f011def1:	83 c4 10             	add    $0x10,%esp
f011def4:	e9 b2 01 00 00       	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011def9:	83 ec 08             	sub    $0x8,%esp
f011defc:	68 80 03 13 f0       	push   $0xf0130380
f011df01:	ff 75 08             	pushl  0x8(%ebp)
f011df04:	e8 dc 16 00 00       	call   f011f5e5 <strcmp>
f011df09:	83 c4 10             	add    $0x10,%esp
f011df0c:	85 c0                	test   %eax,%eax
f011df0e:	75 15                	jne    f011df25 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011df10:	83 ec 0c             	sub    $0xc,%esp
f011df13:	68 a0 62 b0 f0       	push   $0xf0b062a0
f011df18:	e8 55 1a ff ff       	call   f010f972 <wakeup_one>
f011df1d:	83 c4 10             	add    $0x10,%esp
f011df20:	e9 86 01 00 00       	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011df25:	83 ec 08             	sub    $0x8,%esp
f011df28:	68 8e 03 13 f0       	push   $0xf013038e
f011df2d:	ff 75 08             	pushl  0x8(%ebp)
f011df30:	e8 b0 16 00 00       	call   f011f5e5 <strcmp>
f011df35:	83 c4 10             	add    $0x10,%esp
f011df38:	85 c0                	test   %eax,%eax
f011df3a:	75 15                	jne    f011df51 <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011df3c:	83 ec 0c             	sub    $0xc,%esp
f011df3f:	68 a0 62 b0 f0       	push   $0xf0b062a0
f011df44:	e8 ad 1a ff ff       	call   f010f9f6 <wakeup_all>
f011df49:	83 c4 10             	add    $0x10,%esp
f011df4c:	e9 5a 01 00 00       	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011df51:	83 ec 08             	sub    $0x8,%esp
f011df54:	68 9c 03 13 f0       	push   $0xf013039c
f011df59:	ff 75 08             	pushl  0x8(%ebp)
f011df5c:	e8 84 16 00 00       	call   f011f5e5 <strcmp>
f011df61:	83 c4 10             	add    $0x10,%esp
f011df64:	85 c0                	test   %eax,%eax
f011df66:	75 17                	jne    f011df7f <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011df68:	8b 45 0c             	mov    0xc(%ebp),%eax
f011df6b:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011df6e:	a1 ac 62 b0 f0       	mov    0xf0b062ac,%eax
f011df73:	89 c2                	mov    %eax,%edx
f011df75:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011df78:	89 10                	mov    %edx,(%eax)
f011df7a:	e9 2c 01 00 00       	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011df7f:	83 ec 08             	sub    $0x8,%esp
f011df82:	68 b1 03 13 f0       	push   $0xf01303b1
f011df87:	ff 75 08             	pushl  0x8(%ebp)
f011df8a:	e8 56 16 00 00       	call   f011f5e5 <strcmp>
f011df8f:	83 c4 10             	add    $0x10,%esp
f011df92:	85 c0                	test   %eax,%eax
f011df94:	75 1a                	jne    f011dfb0 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011df96:	8b 45 0c             	mov    0xc(%ebp),%eax
f011df99:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011df9c:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f011dfa1:	8b 40 0c             	mov    0xc(%eax),%eax
f011dfa4:	89 c2                	mov    %eax,%edx
f011dfa6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011dfa9:	89 10                	mov    %edx,(%eax)
f011dfab:	e9 fb 00 00 00       	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011dfb0:	83 ec 08             	sub    $0x8,%esp
f011dfb3:	68 c7 03 13 f0       	push   $0xf01303c7
f011dfb8:	ff 75 08             	pushl  0x8(%ebp)
f011dfbb:	e8 25 16 00 00       	call   f011f5e5 <strcmp>
f011dfc0:	83 c4 10             	add    $0x10,%esp
f011dfc3:	85 c0                	test   %eax,%eax
f011dfc5:	75 3d                	jne    f011e004 <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011dfc7:	a1 e4 ed 17 f0       	mov    0xf017ede4,%eax
f011dfcc:	85 c0                	test   %eax,%eax
f011dfce:	74 1f                	je     f011dfef <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011dfd0:	c7 05 e4 ed 17 f0 00 	movl   $0x0,0xf017ede4
f011dfd7:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011dfda:	83 ec 08             	sub    $0x8,%esp
f011dfdd:	68 dc 03 13 f0       	push   $0xf01303dc
f011dfe2:	68 00 63 b0 f0       	push   $0xf0b06300
f011dfe7:	e8 86 17 ff ff       	call   f010f772 <init_sleeplock>
f011dfec:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011dfef:	83 ec 0c             	sub    $0xc,%esp
f011dff2:	68 00 63 b0 f0       	push   $0xf0b06300
f011dff7:	e8 3a 18 ff ff       	call   f010f836 <acquire_sleeplock>
f011dffc:	83 c4 10             	add    $0x10,%esp
f011dfff:	e9 a7 00 00 00       	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011e004:	83 ec 08             	sub    $0x8,%esp
f011e007:	68 ec 03 13 f0       	push   $0xf01303ec
f011e00c:	ff 75 08             	pushl  0x8(%ebp)
f011e00f:	e8 d1 15 00 00       	call   f011f5e5 <strcmp>
f011e014:	83 c4 10             	add    $0x10,%esp
f011e017:	85 c0                	test   %eax,%eax
f011e019:	75 12                	jne    f011e02d <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011e01b:	83 ec 0c             	sub    $0xc,%esp
f011e01e:	68 00 63 b0 f0       	push   $0xf0b06300
f011e023:	e8 68 18 ff ff       	call   f010f890 <release_sleeplock>
f011e028:	83 c4 10             	add    $0x10,%esp
f011e02b:	eb 7e                	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011e02d:	83 ec 08             	sub    $0x8,%esp
f011e030:	68 01 04 13 f0       	push   $0xf0130401
f011e035:	ff 75 08             	pushl  0x8(%ebp)
f011e038:	e8 a8 15 00 00       	call   f011f5e5 <strcmp>
f011e03d:	83 c4 10             	add    $0x10,%esp
f011e040:	85 c0                	test   %eax,%eax
f011e042:	75 14                	jne    f011e058 <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011e044:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e047:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011e04a:	a1 80 63 b0 f0       	mov    0xf0b06380,%eax
f011e04f:	89 c2                	mov    %eax,%edx
f011e051:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e054:	89 10                	mov    %edx,(%eax)
f011e056:	eb 53                	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011e058:	83 ec 08             	sub    $0x8,%esp
f011e05b:	68 16 04 13 f0       	push   $0xf0130416
f011e060:	ff 75 08             	pushl  0x8(%ebp)
f011e063:	e8 7d 15 00 00       	call   f011f5e5 <strcmp>
f011e068:	83 c4 10             	add    $0x10,%esp
f011e06b:	85 c0                	test   %eax,%eax
f011e06d:	75 13                	jne    f011e082 <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011e06f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e072:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011e075:	8b 15 00 63 b0 f0    	mov    0xf0b06300,%edx
f011e07b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e07e:	89 10                	mov    %edx,(%eax)
f011e080:	eb 29                	jmp    f011e0ab <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011e082:	83 ec 08             	sub    $0x8,%esp
f011e085:	68 27 04 13 f0       	push   $0xf0130427
f011e08a:	ff 75 08             	pushl  0x8(%ebp)
f011e08d:	e8 53 15 00 00       	call   f011f5e5 <strcmp>
f011e092:	83 c4 10             	add    $0x10,%esp
f011e095:	85 c0                	test   %eax,%eax
f011e097:	75 12                	jne    f011e0ab <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011e099:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e09c:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011e09f:	a1 04 64 b0 f0       	mov    0xf0b06404,%eax
f011e0a4:	89 c2                	mov    %eax,%edx
f011e0a6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e0a9:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011e0ab:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e0af:	79 5b                	jns    f011e10c <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011e0b1:	83 ec 08             	sub    $0x8,%esp
f011e0b4:	68 38 04 13 f0       	push   $0xf0130438
f011e0b9:	ff 75 08             	pushl  0x8(%ebp)
f011e0bc:	e8 24 15 00 00       	call   f011f5e5 <strcmp>
f011e0c1:	83 c4 10             	add    $0x10,%esp
f011e0c4:	85 c0                	test   %eax,%eax
f011e0c6:	75 44                	jne    f011e10c <sys_utilities+0x532>
		{
			switch (value)
f011e0c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e0cb:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011e0ce:	74 07                	je     f011e0d7 <sys_utilities+0x4fd>
f011e0d0:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011e0d3:	74 19                	je     f011e0ee <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011e0d5:	eb 35                	jmp    f011e10c <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011e0d7:	83 ec 0c             	sub    $0xc,%esp
f011e0da:	68 48 04 13 f0       	push   $0xf0130448
f011e0df:	e8 a7 2e fe ff       	call   f0100f8b <cprintf>
f011e0e4:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011e0e7:	e8 91 0d ff ff       	call   f010ee7d <setPageReplacmentAlgorithmFIFO>
				break;
f011e0ec:	eb 1e                	jmp    f011e10c <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011e0ee:	83 ec 0c             	sub    $0xc,%esp
f011e0f1:	68 b8 04 13 f0       	push   $0xf01304b8
f011e0f6:	e8 90 2e fe ff       	call   f0100f8b <cprintf>
f011e0fb:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011e0fe:	83 ec 0c             	sub    $0xc,%esp
f011e101:	6a 02                	push   $0x2
f011e103:	e8 32 0d ff ff       	call   f010ee3a <setPageReplacmentAlgorithmLRU>
f011e108:	83 c4 10             	add    $0x10,%esp
				break;
f011e10b:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011e10c:	90                   	nop
f011e10d:	c9                   	leave  
f011e10e:	c3                   	ret    

f011e10f <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011e10f:	55                   	push   %ebp
f011e110:	89 e5                	mov    %esp,%ebp
f011e112:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011e115:	8b 45 08             	mov    0x8(%ebp),%eax
f011e118:	8b 00                	mov    (%eax),%eax
f011e11a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011e11d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e120:	8b 00                	mov    (%eax),%eax
f011e122:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011e125:	eb 52                	jmp    f011e179 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011e127:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e12a:	8b 00                	mov    (%eax),%eax
f011e12c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011e12f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e132:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e135:	75 12                	jne    f011e149 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011e137:	83 ec 0c             	sub    $0xc,%esp
f011e13a:	68 2c 05 13 f0       	push   $0xf013052c
f011e13f:	e8 47 2e fe ff       	call   f0100f8b <cprintf>
f011e144:	83 c4 10             	add    $0x10,%esp
			break;
f011e147:	eb 3f                	jmp    f011e188 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011e149:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e14d:	74 38                	je     f011e187 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011e14f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e152:	8b 00                	mov    (%eax),%eax
f011e154:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011e157:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e15a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e15d:	75 12                	jne    f011e171 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011e15f:	83 ec 0c             	sub    $0xc,%esp
f011e162:	68 48 05 13 f0       	push   $0xf0130548
f011e167:	e8 1f 2e fe ff       	call   f0100f8b <cprintf>
f011e16c:	83 c4 10             	add    $0x10,%esp
			break;
f011e16f:	eb 17                	jmp    f011e188 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011e171:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e174:	8b 00                	mov    (%eax),%eax
f011e176:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011e179:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e17d:	74 09                	je     f011e188 <detect_loop_in_FrameInfo_list+0x79>
f011e17f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e183:	75 a2                	jne    f011e127 <detect_loop_in_FrameInfo_list+0x18>
f011e185:	eb 01                	jmp    f011e188 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011e187:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011e188:	83 ec 0c             	sub    $0xc,%esp
f011e18b:	68 5f 05 13 f0       	push   $0xf013055f
f011e190:	e8 f6 2d fe ff       	call   f0100f8b <cprintf>
f011e195:	83 c4 10             	add    $0x10,%esp
}
f011e198:	90                   	nop
f011e199:	c9                   	leave  
f011e19a:	c3                   	ret    

f011e19b <scarce_memory>:

void scarce_memory()
{
f011e19b:	55                   	push   %ebp
f011e19c:	89 e5                	mov    %esp,%ebp
f011e19e:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011e1a1:	a1 90 b4 6b f0       	mov    0xf06bb490,%eax
f011e1a6:	ba 64 00 00 00       	mov    $0x64,%edx
f011e1ab:	29 c2                	sub    %eax,%edx
f011e1ad:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f011e1b2:	0f af c2             	imul   %edx,%eax
f011e1b5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e1ba:	f7 e2                	mul    %edx
f011e1bc:	89 d0                	mov    %edx,%eax
f011e1be:	c1 e8 05             	shr    $0x5,%eax
f011e1c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011e1c4:	a1 90 b4 6b f0       	mov    0xf06bb490,%eax
f011e1c9:	ba 64 00 00 00       	mov    $0x64,%edx
f011e1ce:	29 c2                	sub    %eax,%edx
f011e1d0:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f011e1d5:	89 d1                	mov    %edx,%ecx
f011e1d7:	0f af c8             	imul   %eax,%ecx
f011e1da:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e1df:	f7 e1                	mul    %ecx
f011e1e1:	c1 ea 05             	shr    $0x5,%edx
f011e1e4:	89 d0                	mov    %edx,%eax
f011e1e6:	c1 e0 02             	shl    $0x2,%eax
f011e1e9:	01 d0                	add    %edx,%eax
f011e1eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e1f2:	01 d0                	add    %edx,%eax
f011e1f4:	c1 e0 02             	shl    $0x2,%eax
f011e1f7:	29 c1                	sub    %eax,%ecx
f011e1f9:	89 ca                	mov    %ecx,%edx
f011e1fb:	85 d2                	test   %edx,%edx
f011e1fd:	74 03                	je     f011e202 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011e1ff:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011e202:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011e209:	83 ec 0c             	sub    $0xc,%esp
f011e20c:	68 80 b3 6b f0       	push   $0xf06bb380
f011e211:	e8 02 13 ff ff       	call   f010f518 <acquire_spinlock>
f011e216:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011e219:	a1 6c b3 6b f0       	mov    0xf06bb36c,%eax
f011e21e:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011e221:	8b 15 58 b5 6b f0    	mov    0xf06bb558,%edx
f011e227:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e22a:	29 c2                	sub    %eax,%edx
f011e22c:	89 d0                	mov    %edx,%eax
f011e22e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011e231:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e234:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011e237:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011e23a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e241:	eb 12                	jmp    f011e255 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011e243:	83 ec 0c             	sub    $0xc,%esp
f011e246:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011e249:	50                   	push   %eax
f011e24a:	e8 63 9f fe ff       	call   f01081b2 <allocate_frame>
f011e24f:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e252:	ff 45 f0             	incl   -0x10(%ebp)
f011e255:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e258:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011e25b:	76 e6                	jbe    f011e243 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011e25d:	83 ec 0c             	sub    $0xc,%esp
f011e260:	68 80 b3 6b f0       	push   $0xf06bb380
f011e265:	e8 35 13 ff ff       	call   f010f59f <release_spinlock>
f011e26a:	83 c4 10             	add    $0x10,%esp

}
f011e26d:	90                   	nop
f011e26e:	c9                   	leave  
f011e26f:	c3                   	ret    

f011e270 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011e270:	55                   	push   %ebp
f011e271:	89 e5                	mov    %esp,%ebp
f011e273:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011e276:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011e27d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011e284:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011e28b:	e8 fa cf fe ff       	call   f010b28a <get_cpu_proc>
f011e290:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011e293:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011e297:	75 19                	jne    f011e2b2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011e299:	68 79 05 13 f0       	push   $0xf0130579
f011e29e:	68 c7 01 13 f0       	push   $0xf01301c7
f011e2a3:	68 79 01 00 00       	push   $0x179
f011e2a8:	68 0f 02 13 f0       	push   $0xf013020f
f011e2ad:	e8 87 20 fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011e2b2:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e2b6:	0f 85 d6 01 00 00    	jne    f011e492 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011e2bc:	83 ec 0c             	sub    $0xc,%esp
f011e2bf:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e2c4:	e8 4f 12 ff ff       	call   f010f518 <acquire_spinlock>
f011e2c9:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011e2cc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011e2d3:	e9 d2 00 00 00       	jmp    f011e3aa <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011e2d8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011e2df:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f011e2e4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e2e7:	c1 e2 04             	shl    $0x4,%edx
f011e2ea:	01 d0                	add    %edx,%eax
f011e2ec:	8b 00                	mov    (%eax),%eax
f011e2ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e2f1:	eb 7c                	jmp    f011e36f <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011e2f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e2f6:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e2fc:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e2ff:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e302:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e308:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e30b:	0f af c2             	imul   %edx,%eax
f011e30e:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e313:	f7 e2                	mul    %edx
f011e315:	89 d0                	mov    %edx,%eax
f011e317:	c1 e8 05             	shr    $0x5,%eax
f011e31a:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011e31d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e320:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e326:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e329:	89 d1                	mov    %edx,%ecx
f011e32b:	0f af c8             	imul   %eax,%ecx
f011e32e:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e333:	f7 e1                	mul    %ecx
f011e335:	c1 ea 05             	shr    $0x5,%edx
f011e338:	89 d0                	mov    %edx,%eax
f011e33a:	c1 e0 02             	shl    $0x2,%eax
f011e33d:	01 d0                	add    %edx,%eax
f011e33f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e346:	01 d0                	add    %edx,%eax
f011e348:	c1 e0 02             	shl    $0x2,%eax
f011e34b:	29 c1                	sub    %eax,%ecx
f011e34d:	89 ca                	mov    %ecx,%edx
f011e34f:	85 d2                	test   %edx,%edx
f011e351:	74 03                	je     f011e356 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011e353:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011e356:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e359:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011e35c:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f011e361:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e364:	c1 e2 04             	shl    $0x4,%edx
f011e367:	01 d0                	add    %edx,%eax
f011e369:	8b 40 08             	mov    0x8(%eax),%eax
f011e36c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e36f:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f011e374:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e377:	c1 e2 04             	shl    $0x4,%edx
f011e37a:	01 d0                	add    %edx,%eax
f011e37c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e380:	74 08                	je     f011e38a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011e382:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011e385:	8b 52 08             	mov    0x8(%edx),%edx
f011e388:	eb 05                	jmp    f011e38f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011e38a:	ba 00 00 00 00       	mov    $0x0,%edx
f011e38f:	89 50 08             	mov    %edx,0x8(%eax)
f011e392:	8b 40 08             	mov    0x8(%eax),%eax
f011e395:	85 c0                	test   %eax,%eax
f011e397:	0f 85 56 ff ff ff    	jne    f011e2f3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011e39d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e3a1:	0f 85 4c ff ff ff    	jne    f011e2f3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011e3a7:	ff 45 e8             	incl   -0x18(%ebp)
f011e3aa:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f011e3af:	0f b6 c0             	movzbl %al,%eax
f011e3b2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e3b5:	0f 8f 1d ff ff ff    	jg     f011e2d8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011e3bb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011e3c2:	a1 40 b3 6b f0       	mov    0xf06bb340,%eax
f011e3c7:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011e3ca:	eb 1a                	jmp    f011e3e6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011e3cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e3cf:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e3d5:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011e3d8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e3db:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011e3de:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f011e3e3:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011e3e6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011e3ea:	74 08                	je     f011e3f4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011e3ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e3ef:	8b 40 08             	mov    0x8(%eax),%eax
f011e3f2:	eb 05                	jmp    f011e3f9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011e3f4:	b8 00 00 00 00       	mov    $0x0,%eax
f011e3f9:	a3 48 b3 6b f0       	mov    %eax,0xf06bb348
f011e3fe:	a1 48 b3 6b f0       	mov    0xf06bb348,%eax
f011e403:	85 c0                	test   %eax,%eax
f011e405:	75 c5                	jne    f011e3cc <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011e407:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011e40b:	75 bf                	jne    f011e3cc <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e40d:	83 ec 0c             	sub    $0xc,%esp
f011e410:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e415:	e8 85 11 ff ff       	call   f010f59f <release_spinlock>
f011e41a:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011e41d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011e421:	0f 84 d4 00 00 00    	je     f011e4fb <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011e427:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e42a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e430:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e433:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e436:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e43c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e43f:	0f af c2             	imul   %edx,%eax
f011e442:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e447:	f7 e2                	mul    %edx
f011e449:	89 d0                	mov    %edx,%eax
f011e44b:	c1 e8 05             	shr    $0x5,%eax
f011e44e:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011e451:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e454:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e45a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e45d:	89 d1                	mov    %edx,%ecx
f011e45f:	0f af c8             	imul   %eax,%ecx
f011e462:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e467:	f7 e1                	mul    %ecx
f011e469:	c1 ea 05             	shr    $0x5,%edx
f011e46c:	89 d0                	mov    %edx,%eax
f011e46e:	c1 e0 02             	shl    $0x2,%eax
f011e471:	01 d0                	add    %edx,%eax
f011e473:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e47a:	01 d0                	add    %edx,%eax
f011e47c:	c1 e0 02             	shl    $0x2,%eax
f011e47f:	29 c1                	sub    %eax,%ecx
f011e481:	89 ca                	mov    %ecx,%edx
f011e483:	85 d2                	test   %edx,%edx
f011e485:	74 03                	je     f011e48a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011e487:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011e48a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011e48d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e490:	eb 69                	jmp    f011e4fb <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011e492:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e495:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e49b:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e49e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e4a1:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e4a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e4aa:	0f af c2             	imul   %edx,%eax
f011e4ad:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e4b2:	f7 e2                	mul    %edx
f011e4b4:	89 d0                	mov    %edx,%eax
f011e4b6:	c1 e8 05             	shr    $0x5,%eax
f011e4b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011e4bc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e4bf:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e4c5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e4c8:	89 d1                	mov    %edx,%ecx
f011e4ca:	0f af c8             	imul   %eax,%ecx
f011e4cd:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e4d2:	f7 e1                	mul    %ecx
f011e4d4:	c1 ea 05             	shr    $0x5,%edx
f011e4d7:	89 d0                	mov    %edx,%eax
f011e4d9:	c1 e0 02             	shl    $0x2,%eax
f011e4dc:	01 d0                	add    %edx,%eax
f011e4de:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e4e5:	01 d0                	add    %edx,%eax
f011e4e7:	c1 e0 02             	shl    $0x2,%eax
f011e4ea:	29 c1                	sub    %eax,%ecx
f011e4ec:	89 ca                	mov    %ecx,%edx
f011e4ee:	85 d2                	test   %edx,%edx
f011e4f0:	74 03                	je     f011e4f5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011e4f2:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011e4f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e4f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011e4fb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011e4fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e501:	01 c2                	add    %eax,%edx
f011e503:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e506:	01 d0                	add    %edx,%eax
}
f011e508:	c9                   	leave  
f011e509:	c3                   	ret    

f011e50a <schenv>:


void schenv()
{
f011e50a:	55                   	push   %ebp
f011e50b:	89 e5                	mov    %esp,%ebp
f011e50d:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011e510:	c6 05 a0 ba 6b f0 00 	movb   $0x0,0xf06bbaa0
	__ne = NULL;
f011e517:	c7 05 ac b7 6b f0 00 	movl   $0x0,0xf06bb7ac
f011e51e:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011e521:	83 ec 0c             	sub    $0xc,%esp
f011e524:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e529:	e8 ea 0f ff ff       	call   f010f518 <acquire_spinlock>
f011e52e:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011e531:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e538:	eb 3f                	jmp    f011e579 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011e53a:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f011e53f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e542:	c1 e2 04             	shl    $0x4,%edx
f011e545:	01 d0                	add    %edx,%eax
f011e547:	83 ec 0c             	sub    $0xc,%esp
f011e54a:	50                   	push   %eax
f011e54b:	e8 42 6a fe ff       	call   f0104f92 <queue_size>
f011e550:	83 c4 10             	add    $0x10,%esp
f011e553:	85 c0                	test   %eax,%eax
f011e555:	74 1f                	je     f011e576 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011e557:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f011e55c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e55f:	c1 e2 04             	shl    $0x4,%edx
f011e562:	01 d0                	add    %edx,%eax
f011e564:	8b 40 04             	mov    0x4(%eax),%eax
f011e567:	a3 ac b7 6b f0       	mov    %eax,0xf06bb7ac
				__nl = i;
f011e56c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e56f:	a2 a0 ba 6b f0       	mov    %al,0xf06bbaa0
				break;
f011e574:	eb 10                	jmp    f011e586 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011e576:	ff 45 f4             	incl   -0xc(%ebp)
f011e579:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f011e57e:	0f b6 c0             	movzbl %al,%eax
f011e581:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e584:	7f b4                	jg     f011e53a <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011e586:	83 ec 0c             	sub    $0xc,%esp
f011e589:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e58e:	e8 0c 10 ff ff       	call   f010f59f <release_spinlock>
f011e593:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011e596:	e8 ef cc fe ff       	call   f010b28a <get_cpu_proc>
f011e59b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011e59e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e5a2:	0f 84 82 00 00 00    	je     f011e62a <schenv+0x120>
	{
		if (__ne != NULL)
f011e5a8:	a1 ac b7 6b f0       	mov    0xf06bb7ac,%eax
f011e5ad:	85 c0                	test   %eax,%eax
f011e5af:	74 49                	je     f011e5fa <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011e5b1:	a0 a1 b2 6b f0       	mov    0xf06bb2a1,%al
f011e5b6:	0f b6 c0             	movzbl %al,%eax
f011e5b9:	8d 50 01             	lea    0x1(%eax),%edx
f011e5bc:	a0 a0 ba 6b f0       	mov    0xf06bbaa0,%al
f011e5c1:	0f b6 c0             	movzbl %al,%eax
f011e5c4:	39 c2                	cmp    %eax,%edx
f011e5c6:	7d 62                	jge    f011e62a <schenv+0x120>
			{
				__ne = cur_env;
f011e5c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e5cb:	a3 ac b7 6b f0       	mov    %eax,0xf06bb7ac
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011e5d0:	a0 a1 b2 6b f0       	mov    0xf06bb2a1,%al
f011e5d5:	0f b6 c0             	movzbl %al,%eax
f011e5d8:	8a 15 04 ba 6b f0    	mov    0xf06bba04,%dl
f011e5de:	0f b6 d2             	movzbl %dl,%edx
f011e5e1:	4a                   	dec    %edx
f011e5e2:	39 d0                	cmp    %edx,%eax
f011e5e4:	7d 08                	jge    f011e5ee <schenv+0xe4>
f011e5e6:	a0 a1 b2 6b f0       	mov    0xf06bb2a1,%al
f011e5eb:	40                   	inc    %eax
f011e5ec:	eb 05                	jmp    f011e5f3 <schenv+0xe9>
f011e5ee:	a0 a1 b2 6b f0       	mov    0xf06bb2a1,%al
f011e5f3:	a2 a0 ba 6b f0       	mov    %al,0xf06bbaa0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011e5f8:	eb 30                	jmp    f011e62a <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011e5fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e5fd:	a3 ac b7 6b f0       	mov    %eax,0xf06bb7ac
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011e602:	a0 a1 b2 6b f0       	mov    0xf06bb2a1,%al
f011e607:	0f b6 c0             	movzbl %al,%eax
f011e60a:	8a 15 04 ba 6b f0    	mov    0xf06bba04,%dl
f011e610:	0f b6 d2             	movzbl %dl,%edx
f011e613:	4a                   	dec    %edx
f011e614:	39 d0                	cmp    %edx,%eax
f011e616:	7d 08                	jge    f011e620 <schenv+0x116>
f011e618:	a0 a1 b2 6b f0       	mov    0xf06bb2a1,%al
f011e61d:	40                   	inc    %eax
f011e61e:	eb 05                	jmp    f011e625 <schenv+0x11b>
f011e620:	a0 a1 b2 6b f0       	mov    0xf06bb2a1,%al
f011e625:	a2 a0 ba 6b f0       	mov    %al,0xf06bbaa0
		}
	}
}
f011e62a:	90                   	nop
f011e62b:	c9                   	leave  
f011e62c:	c3                   	ret    

f011e62d <chksch>:

void chksch(uint8 onoff)
{
f011e62d:	55                   	push   %ebp
f011e62e:	89 e5                	mov    %esp,%ebp
f011e630:	83 ec 18             	sub    $0x18,%esp
f011e633:	8b 45 08             	mov    0x8(%ebp),%eax
f011e636:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011e639:	e8 d4 80 fe ff       	call   f0106712 <isSchedMethodBSD>
f011e63e:	85 c0                	test   %eax,%eax
f011e640:	74 48                	je     f011e68a <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011e642:	e8 79 80 fe ff       	call   f01066c0 <get_load_average>
f011e647:	a3 28 ba 6b f0       	mov    %eax,0xf06bba28
f011e64c:	a1 28 ba 6b f0       	mov    0xf06bba28,%eax
f011e651:	a3 5c b5 6b f0       	mov    %eax,0xf06bb55c
		acquire_spinlock(&ProcessQueues.qlock);
f011e656:	83 ec 0c             	sub    $0xc,%esp
f011e659:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e65e:	e8 b5 0e ff ff       	call   f010f518 <acquire_spinlock>
f011e663:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011e666:	a1 4c b3 6b f0       	mov    0xf06bb34c,%eax
f011e66b:	a3 00 b4 6b f0       	mov    %eax,0xf06bb400
		}
		release_spinlock(&ProcessQueues.qlock);
f011e670:	83 ec 0c             	sub    $0xc,%esp
f011e673:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e678:	e8 22 0f ff ff       	call   f010f59f <release_spinlock>
f011e67d:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011e680:	c7 05 bc b7 6b f0 01 	movl   $0x1,0xf06bb7bc
f011e687:	00 00 00 
	}
	__chkstatus = onoff;
f011e68a:	8a 45 f4             	mov    -0xc(%ebp),%al
f011e68d:	a2 a8 b7 6b f0       	mov    %al,0xf06bb7a8
}
f011e692:	90                   	nop
f011e693:	c9                   	leave  
f011e694:	c3                   	ret    

f011e695 <chk1>:
void chk1()
{
f011e695:	55                   	push   %ebp
f011e696:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011e698:	90                   	nop
f011e699:	5d                   	pop    %ebp
f011e69a:	c3                   	ret    

f011e69b <chk2>:
void chk2(struct Env* __se)
{
f011e69b:	55                   	push   %ebp
f011e69c:	89 e5                	mov    %esp,%ebp
f011e69e:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011e6a1:	a0 a8 b7 6b f0       	mov    0xf06bb7a8,%al
f011e6a6:	84 c0                	test   %al,%al
f011e6a8:	0f 84 59 03 00 00    	je     f011ea07 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011e6ae:	e8 5f 80 fe ff       	call   f0106712 <isSchedMethodBSD>
f011e6b3:	85 c0                	test   %eax,%eax
f011e6b5:	0f 84 4d 03 00 00    	je     f011ea08 <chk2+0x36d>
	{
		__nla = get_load_average();
f011e6bb:	e8 00 80 fe ff       	call   f01066c0 <get_load_average>
f011e6c0:	a3 94 b4 6b f0       	mov    %eax,0xf06bb494
		acquire_spinlock(&ProcessQueues.qlock);
f011e6c5:	83 ec 0c             	sub    $0xc,%esp
f011e6c8:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e6cd:	e8 46 0e ff ff       	call   f010f518 <acquire_spinlock>
f011e6d2:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e6d5:	a1 4c b3 6b f0       	mov    0xf06bb34c,%eax
f011e6da:	a3 b0 b7 6b f0       	mov    %eax,0xf06bb7b0
		}
		release_spinlock(&ProcessQueues.qlock);
f011e6df:	83 ec 0c             	sub    $0xc,%esp
f011e6e2:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e6e7:	e8 b3 0e ff ff       	call   f010f59f <release_spinlock>
f011e6ec:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011e6ef:	a1 bc b7 6b f0       	mov    0xf06bb7bc,%eax
f011e6f4:	85 c0                	test   %eax,%eax
f011e6f6:	74 72                	je     f011e76a <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011e6f8:	83 ec 0c             	sub    $0xc,%esp
f011e6fb:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e700:	e8 13 0e ff ff       	call   f010f518 <acquire_spinlock>
f011e705:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011e708:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e70c:	0f 95 c0             	setne  %al
f011e70f:	0f b6 c0             	movzbl %al,%eax
f011e712:	a3 74 b9 6b f0       	mov    %eax,0xf06bb974
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e717:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f011e71c:	0f b6 c0             	movzbl %al,%eax
f011e71f:	48                   	dec    %eax
f011e720:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e723:	eb 20                	jmp    f011e745 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011e725:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f011e72a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e72d:	c1 e2 04             	shl    $0x4,%edx
f011e730:	01 d0                	add    %edx,%eax
f011e732:	8b 40 0c             	mov    0xc(%eax),%eax
f011e735:	8b 15 74 b9 6b f0    	mov    0xf06bb974,%edx
f011e73b:	01 d0                	add    %edx,%eax
f011e73d:	a3 74 b9 6b f0       	mov    %eax,0xf06bb974
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e742:	ff 4d f4             	decl   -0xc(%ebp)
f011e745:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e749:	79 da                	jns    f011e725 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011e74b:	c7 05 bc b7 6b f0 00 	movl   $0x0,0xf06bb7bc
f011e752:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011e755:	83 ec 0c             	sub    $0xc,%esp
f011e758:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e75d:	e8 3d 0e ff ff       	call   f010f59f <release_spinlock>
f011e762:	83 c4 10             	add    $0x10,%esp
f011e765:	e9 91 02 00 00       	jmp    f011e9fb <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011e76a:	8b 15 00 b4 6b f0    	mov    0xf06bb400,%edx
f011e770:	a1 b0 b7 6b f0       	mov    0xf06bb7b0,%eax
f011e775:	39 c2                	cmp    %eax,%edx
f011e777:	74 63                	je     f011e7dc <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011e779:	83 ec 0c             	sub    $0xc,%esp
f011e77c:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e781:	e8 92 0d ff ff       	call   f010f518 <acquire_spinlock>
f011e786:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011e789:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e78d:	0f 95 c0             	setne  %al
f011e790:	0f b6 c0             	movzbl %al,%eax
f011e793:	a3 74 b9 6b f0       	mov    %eax,0xf06bb974
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e798:	a0 04 ba 6b f0       	mov    0xf06bba04,%al
f011e79d:	0f b6 c0             	movzbl %al,%eax
f011e7a0:	48                   	dec    %eax
f011e7a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e7a4:	eb 20                	jmp    f011e7c6 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011e7a6:	a1 50 b3 6b f0       	mov    0xf06bb350,%eax
f011e7ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011e7ae:	c1 e2 04             	shl    $0x4,%edx
f011e7b1:	01 d0                	add    %edx,%eax
f011e7b3:	8b 40 0c             	mov    0xc(%eax),%eax
f011e7b6:	8b 15 74 b9 6b f0    	mov    0xf06bb974,%edx
f011e7bc:	01 d0                	add    %edx,%eax
f011e7be:	a3 74 b9 6b f0       	mov    %eax,0xf06bb974
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e7c3:	ff 4d f0             	decl   -0x10(%ebp)
f011e7c6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e7ca:	79 da                	jns    f011e7a6 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011e7cc:	83 ec 0c             	sub    $0xc,%esp
f011e7cf:	68 c0 b2 6b f0       	push   $0xf06bb2c0
f011e7d4:	e8 c6 0d ff ff       	call   f010f59f <release_spinlock>
f011e7d9:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011e7dc:	e8 78 7e fe ff       	call   f0106659 <timer_ticks>
f011e7e1:	6a 00                	push   $0x0
f011e7e3:	68 e8 03 00 00       	push   $0x3e8
f011e7e8:	52                   	push   %edx
f011e7e9:	50                   	push   %eax
f011e7ea:	e8 f1 31 00 00       	call   f01219e0 <__moddi3>
f011e7ef:	83 c4 10             	add    $0x10,%esp
f011e7f2:	09 d0                	or     %edx,%eax
f011e7f4:	85 c0                	test   %eax,%eax
f011e7f6:	75 32                	jne    f011e82a <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011e7f8:	8b 15 5c b5 6b f0    	mov    0xf06bb55c,%edx
f011e7fe:	a1 94 b4 6b f0       	mov    0xf06bb494,%eax
f011e803:	39 c2                	cmp    %eax,%edx
f011e805:	75 19                	jne    f011e820 <chk2+0x185>
f011e807:	68 89 05 13 f0       	push   $0xf0130589
f011e80c:	68 c7 01 13 f0       	push   $0xf01301c7
f011e811:	68 35 02 00 00       	push   $0x235
f011e816:	68 0f 02 13 f0       	push   $0xf013020f
f011e81b:	e8 a9 1b fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011e820:	a1 94 b4 6b f0       	mov    0xf06bb494,%eax
f011e825:	a3 5c b5 6b f0       	mov    %eax,0xf06bb55c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011e82a:	e8 2a 7e fe ff       	call   f0106659 <timer_ticks>
f011e82f:	6a 00                	push   $0x0
f011e831:	6a 64                	push   $0x64
f011e833:	52                   	push   %edx
f011e834:	50                   	push   %eax
f011e835:	e8 a6 31 00 00       	call   f01219e0 <__moddi3>
f011e83a:	83 c4 10             	add    $0x10,%esp
f011e83d:	09 d0                	or     %edx,%eax
f011e83f:	85 c0                	test   %eax,%eax
f011e841:	0f 85 b4 01 00 00    	jne    f011e9fb <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011e847:	8b 0d 28 ba 6b f0    	mov    0xf06bba28,%ecx
f011e84d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e852:	f7 e9                	imul   %ecx
f011e854:	c1 fa 05             	sar    $0x5,%edx
f011e857:	89 c8                	mov    %ecx,%eax
f011e859:	c1 f8 1f             	sar    $0x1f,%eax
f011e85c:	29 c2                	sub    %eax,%edx
f011e85e:	89 d0                	mov    %edx,%eax
f011e860:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011e863:	8b 0d 28 ba 6b f0    	mov    0xf06bba28,%ecx
f011e869:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e86e:	f7 e9                	imul   %ecx
f011e870:	c1 fa 05             	sar    $0x5,%edx
f011e873:	89 c8                	mov    %ecx,%eax
f011e875:	c1 f8 1f             	sar    $0x1f,%eax
f011e878:	29 c2                	sub    %eax,%edx
f011e87a:	89 d0                	mov    %edx,%eax
f011e87c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011e87f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e882:	89 d0                	mov    %edx,%eax
f011e884:	c1 e0 02             	shl    $0x2,%eax
f011e887:	01 d0                	add    %edx,%eax
f011e889:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e890:	01 d0                	add    %edx,%eax
f011e892:	c1 e0 02             	shl    $0x2,%eax
f011e895:	29 c1                	sub    %eax,%ecx
f011e897:	89 c8                	mov    %ecx,%eax
f011e899:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011e89c:	8b 0d 94 b4 6b f0    	mov    0xf06bb494,%ecx
f011e8a2:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e8a7:	f7 e9                	imul   %ecx
f011e8a9:	c1 fa 05             	sar    $0x5,%edx
f011e8ac:	89 c8                	mov    %ecx,%eax
f011e8ae:	c1 f8 1f             	sar    $0x1f,%eax
f011e8b1:	29 c2                	sub    %eax,%edx
f011e8b3:	89 d0                	mov    %edx,%eax
f011e8b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011e8b8:	8b 0d 94 b4 6b f0    	mov    0xf06bb494,%ecx
f011e8be:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e8c3:	f7 e9                	imul   %ecx
f011e8c5:	c1 fa 05             	sar    $0x5,%edx
f011e8c8:	89 c8                	mov    %ecx,%eax
f011e8ca:	c1 f8 1f             	sar    $0x1f,%eax
f011e8cd:	29 c2                	sub    %eax,%edx
f011e8cf:	89 d0                	mov    %edx,%eax
f011e8d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011e8d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011e8d7:	89 d0                	mov    %edx,%eax
f011e8d9:	c1 e0 02             	shl    $0x2,%eax
f011e8dc:	01 d0                	add    %edx,%eax
f011e8de:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e8e5:	01 d0                	add    %edx,%eax
f011e8e7:	c1 e0 02             	shl    $0x2,%eax
f011e8ea:	29 c1                	sub    %eax,%ecx
f011e8ec:	89 c8                	mov    %ecx,%eax
f011e8ee:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011e8f1:	8b 15 b0 b7 6b f0    	mov    0xf06bb7b0,%edx
f011e8f7:	a1 00 b4 6b f0       	mov    0xf06bb400,%eax
f011e8fc:	39 c2                	cmp    %eax,%edx
f011e8fe:	0f 85 ed 00 00 00    	jne    f011e9f1 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011e904:	a1 74 b9 6b f0       	mov    0xf06bb974,%eax
f011e909:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e90c:	7e 5b                	jle    f011e969 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011e90e:	a1 74 b9 6b f0       	mov    0xf06bb974,%eax
f011e913:	83 ec 08             	sub    $0x8,%esp
f011e916:	ff 75 e0             	pushl  -0x20(%ebp)
f011e919:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e91c:	ff 75 e8             	pushl  -0x18(%ebp)
f011e91f:	ff 75 ec             	pushl  -0x14(%ebp)
f011e922:	50                   	push   %eax
f011e923:	68 9c 05 13 f0       	push   $0xf013059c
f011e928:	e8 5e 26 fe ff       	call   f0100f8b <cprintf>
f011e92d:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011e930:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e933:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e936:	0f 8f b5 00 00 00    	jg     f011e9f1 <chk2+0x356>
f011e93c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e93f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e942:	75 0c                	jne    f011e950 <chk2+0x2b5>
f011e944:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e947:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e94a:	0f 8d a1 00 00 00    	jge    f011e9f1 <chk2+0x356>
f011e950:	68 e4 05 13 f0       	push   $0xf01305e4
f011e955:	68 c7 01 13 f0       	push   $0xf01301c7
f011e95a:	68 4a 02 00 00       	push   $0x24a
f011e95f:	68 0f 02 13 f0       	push   $0xf013020f
f011e964:	e8 60 1a fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011e969:	a1 74 b9 6b f0       	mov    0xf06bb974,%eax
f011e96e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e971:	7d 53                	jge    f011e9c6 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011e973:	a1 74 b9 6b f0       	mov    0xf06bb974,%eax
f011e978:	83 ec 08             	sub    $0x8,%esp
f011e97b:	ff 75 e0             	pushl  -0x20(%ebp)
f011e97e:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e981:	ff 75 e8             	pushl  -0x18(%ebp)
f011e984:	ff 75 ec             	pushl  -0x14(%ebp)
f011e987:	50                   	push   %eax
f011e988:	68 24 06 13 f0       	push   $0xf0130624
f011e98d:	e8 f9 25 fe ff       	call   f0100f8b <cprintf>
f011e992:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011e995:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e998:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e99b:	7c 54                	jl     f011e9f1 <chk2+0x356>
f011e99d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e9a0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e9a3:	75 08                	jne    f011e9ad <chk2+0x312>
f011e9a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e9a8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e9ab:	7e 44                	jle    f011e9f1 <chk2+0x356>
f011e9ad:	68 6c 06 13 f0       	push   $0xf013066c
f011e9b2:	68 c7 01 13 f0       	push   $0xf01301c7
f011e9b7:	68 50 02 00 00       	push   $0x250
f011e9bc:	68 0f 02 13 f0       	push   $0xf013020f
f011e9c1:	e8 03 1a fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011e9c6:	a1 74 b9 6b f0       	mov    0xf06bb974,%eax
f011e9cb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e9ce:	75 21                	jne    f011e9f1 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011e9d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e9d3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e9d6:	74 19                	je     f011e9f1 <chk2+0x356>
f011e9d8:	68 ac 06 13 f0       	push   $0xf01306ac
f011e9dd:	68 c7 01 13 f0       	push   $0xf01301c7
f011e9e2:	68 54 02 00 00       	push   $0x254
f011e9e7:	68 0f 02 13 f0       	push   $0xf013020f
f011e9ec:	e8 d8 19 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011e9f1:	a1 94 b4 6b f0       	mov    0xf06bb494,%eax
f011e9f6:	a3 28 ba 6b f0       	mov    %eax,0xf06bba28
			}
		}
		__pnexit = __nnexit;
f011e9fb:	a1 b0 b7 6b f0       	mov    0xf06bb7b0,%eax
f011ea00:	a3 00 b4 6b f0       	mov    %eax,0xf06bb400
f011ea05:	eb 01                	jmp    f011ea08 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011ea07:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011ea08:	c9                   	leave  
f011ea09:	c3                   	ret    

f011ea0a <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011ea0a:	55                   	push   %ebp
f011ea0b:	89 e5                	mov    %esp,%ebp
f011ea0d:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011ea10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ea17:	eb 40                	jmp    f011ea59 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011ea19:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ea1c:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011ea22:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011ea27:	83 ec 08             	sub    $0x8,%esp
f011ea2a:	52                   	push   %edx
f011ea2b:	50                   	push   %eax
f011ea2c:	e8 af 01 00 00       	call   f011ebe0 <check_va2pa>
f011ea31:	83 c4 10             	add    $0x10,%esp
f011ea34:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ea37:	74 19                	je     f011ea52 <check_boot_pgdir+0x48>
f011ea39:	68 c0 06 13 f0       	push   $0xf01306c0
f011ea3e:	68 c7 01 13 f0       	push   $0xf01301c7
f011ea43:	68 9b 02 00 00       	push   $0x29b
f011ea48:	68 0f 02 13 f0       	push   $0xf013020f
f011ea4d:	e8 e7 18 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011ea52:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011ea59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ea5c:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011ea62:	a1 78 b9 6b f0       	mov    0xf06bb978,%eax
f011ea67:	39 c2                	cmp    %eax,%edx
f011ea69:	72 ae                	jb     f011ea19 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011ea6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ea72:	e9 81 00 00 00       	jmp    f011eaf8 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011ea77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ea7a:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011ea7f:	85 c0                	test   %eax,%eax
f011ea81:	74 6d                	je     f011eaf0 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011ea83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ea86:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011ea8c:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011ea91:	83 ec 08             	sub    $0x8,%esp
f011ea94:	52                   	push   %edx
f011ea95:	50                   	push   %eax
f011ea96:	e8 45 01 00 00       	call   f011ebe0 <check_va2pa>
f011ea9b:	83 c4 10             	add    $0x10,%esp
f011ea9e:	c7 45 f0 00 60 17 f0 	movl   $0xf0176000,-0x10(%ebp)
f011eaa5:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011eaac:	77 17                	ja     f011eac5 <check_boot_pgdir+0xbb>
f011eaae:	ff 75 f0             	pushl  -0x10(%ebp)
f011eab1:	68 f8 06 13 f0       	push   $0xf01306f8
f011eab6:	68 a9 02 00 00       	push   $0x2a9
f011eabb:	68 0f 02 13 f0       	push   $0xf013020f
f011eac0:	e8 74 18 fe ff       	call   f0100339 <_panic>
f011eac5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011eac8:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011eace:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ead1:	01 ca                	add    %ecx,%edx
f011ead3:	39 d0                	cmp    %edx,%eax
f011ead5:	74 1a                	je     f011eaf1 <check_boot_pgdir+0xe7>
f011ead7:	68 2c 07 13 f0       	push   $0xf013072c
f011eadc:	68 c7 01 13 f0       	push   $0xf01301c7
f011eae1:	68 a9 02 00 00       	push   $0x2a9
f011eae6:	68 0f 02 13 f0       	push   $0xf013020f
f011eaeb:	e8 49 18 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011eaf0:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011eaf1:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011eaf8:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011eaff:	0f 86 72 ff ff ff    	jbe    f011ea77 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011eb05:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011eb0c:	e9 af 00 00 00       	jmp    f011ebc0 <check_boot_pgdir+0x1b6>
		switch (i) {
f011eb11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eb14:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011eb19:	74 11                	je     f011eb2c <check_boot_pgdir+0x122>
f011eb1b:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011eb20:	72 36                	jb     f011eb58 <check_boot_pgdir+0x14e>
f011eb22:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011eb27:	83 f8 02             	cmp    $0x2,%eax
f011eb2a:	77 2c                	ja     f011eb58 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011eb2c:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011eb31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011eb34:	c1 e2 02             	shl    $0x2,%edx
f011eb37:	01 d0                	add    %edx,%eax
f011eb39:	8b 00                	mov    (%eax),%eax
f011eb3b:	85 c0                	test   %eax,%eax
f011eb3d:	75 7a                	jne    f011ebb9 <check_boot_pgdir+0x1af>
f011eb3f:	68 b2 07 13 f0       	push   $0xf01307b2
f011eb44:	68 c7 01 13 f0       	push   $0xf01301c7
f011eb49:	68 b4 02 00 00       	push   $0x2b4
f011eb4e:	68 0f 02 13 f0       	push   $0xf013020f
f011eb53:	e8 e1 17 fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011eb58:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011eb5f:	76 2c                	jbe    f011eb8d <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011eb61:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011eb66:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011eb69:	c1 e2 02             	shl    $0x2,%edx
f011eb6c:	01 d0                	add    %edx,%eax
f011eb6e:	8b 00                	mov    (%eax),%eax
f011eb70:	85 c0                	test   %eax,%eax
f011eb72:	75 48                	jne    f011ebbc <check_boot_pgdir+0x1b2>
f011eb74:	68 b2 07 13 f0       	push   $0xf01307b2
f011eb79:	68 c7 01 13 f0       	push   $0xf01301c7
f011eb7e:	68 b8 02 00 00       	push   $0x2b8
f011eb83:	68 0f 02 13 f0       	push   $0xf013020f
f011eb88:	e8 ac 17 fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011eb8d:	a1 7c b9 6b f0       	mov    0xf06bb97c,%eax
f011eb92:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011eb95:	c1 e2 02             	shl    $0x2,%edx
f011eb98:	01 d0                	add    %edx,%eax
f011eb9a:	8b 00                	mov    (%eax),%eax
f011eb9c:	85 c0                	test   %eax,%eax
f011eb9e:	74 1c                	je     f011ebbc <check_boot_pgdir+0x1b2>
f011eba0:	68 c8 07 13 f0       	push   $0xf01307c8
f011eba5:	68 c7 01 13 f0       	push   $0xf01301c7
f011ebaa:	68 ba 02 00 00       	push   $0x2ba
f011ebaf:	68 0f 02 13 f0       	push   $0xf013020f
f011ebb4:	e8 80 17 fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011ebb9:	90                   	nop
f011ebba:	eb 01                	jmp    f011ebbd <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011ebbc:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011ebbd:	ff 45 f4             	incl   -0xc(%ebp)
f011ebc0:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011ebc7:	0f 86 44 ff ff ff    	jbe    f011eb11 <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011ebcd:	83 ec 0c             	sub    $0xc,%esp
f011ebd0:	68 e4 07 13 f0       	push   $0xf01307e4
f011ebd5:	e8 b1 23 fe ff       	call   f0100f8b <cprintf>
f011ebda:	83 c4 10             	add    $0x10,%esp
}
f011ebdd:	90                   	nop
f011ebde:	c9                   	leave  
f011ebdf:	c3                   	ret    

f011ebe0 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011ebe0:	55                   	push   %ebp
f011ebe1:	89 e5                	mov    %esp,%ebp
f011ebe3:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011ebe6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ebe9:	c1 e8 16             	shr    $0x16,%eax
f011ebec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ebf3:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebf6:	01 d0                	add    %edx,%eax
f011ebf8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011ebfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ebfe:	8b 00                	mov    (%eax),%eax
f011ec00:	83 e0 01             	and    $0x1,%eax
f011ec03:	85 c0                	test   %eax,%eax
f011ec05:	75 0a                	jne    f011ec11 <check_va2pa+0x31>
		return ~0;
f011ec07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011ec0c:	e9 87 00 00 00       	jmp    f011ec98 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011ec11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ec14:	8b 00                	mov    (%eax),%eax
f011ec16:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ec1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ec1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ec21:	c1 e8 0c             	shr    $0xc,%eax
f011ec24:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ec27:	a1 58 b5 6b f0       	mov    0xf06bb558,%eax
f011ec2c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011ec2f:	72 17                	jb     f011ec48 <check_va2pa+0x68>
f011ec31:	ff 75 f0             	pushl  -0x10(%ebp)
f011ec34:	68 08 08 13 f0       	push   $0xf0130808
f011ec39:	68 d0 02 00 00       	push   $0x2d0
f011ec3e:	68 0f 02 13 f0       	push   $0xf013020f
f011ec43:	e8 f1 16 fe ff       	call   f0100339 <_panic>
f011ec48:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ec4b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011ec50:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011ec53:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ec56:	c1 e8 0c             	shr    $0xc,%eax
f011ec59:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ec5e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ec65:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ec68:	01 d0                	add    %edx,%eax
f011ec6a:	8b 00                	mov    (%eax),%eax
f011ec6c:	83 e0 01             	and    $0x1,%eax
f011ec6f:	85 c0                	test   %eax,%eax
f011ec71:	75 07                	jne    f011ec7a <check_va2pa+0x9a>
		return ~0;
f011ec73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011ec78:	eb 1e                	jmp    f011ec98 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011ec7a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ec7d:	c1 e8 0c             	shr    $0xc,%eax
f011ec80:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ec85:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ec8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ec8f:	01 d0                	add    %edx,%eax
f011ec91:	8b 00                	mov    (%eax),%eax
f011ec93:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011ec98:	c9                   	leave  
f011ec99:	c3                   	ret    

f011ec9a <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011ec9a:	55                   	push   %ebp
f011ec9b:	89 e5                	mov    %esp,%ebp
f011ec9d:	53                   	push   %ebx
f011ec9e:	83 ec 14             	sub    $0x14,%esp
f011eca1:	8b 45 10             	mov    0x10(%ebp),%eax
f011eca4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011eca7:	8b 45 14             	mov    0x14(%ebp),%eax
f011ecaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011ecad:	8b 45 18             	mov    0x18(%ebp),%eax
f011ecb0:	ba 00 00 00 00       	mov    $0x0,%edx
f011ecb5:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011ecb8:	77 55                	ja     f011ed0f <printnum+0x75>
f011ecba:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011ecbd:	72 05                	jb     f011ecc4 <printnum+0x2a>
f011ecbf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011ecc2:	77 4b                	ja     f011ed0f <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011ecc4:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011ecc7:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011ecca:	8b 45 18             	mov    0x18(%ebp),%eax
f011eccd:	ba 00 00 00 00       	mov    $0x0,%edx
f011ecd2:	52                   	push   %edx
f011ecd3:	50                   	push   %eax
f011ecd4:	ff 75 f4             	pushl  -0xc(%ebp)
f011ecd7:	ff 75 f0             	pushl  -0x10(%ebp)
f011ecda:	e8 99 2e 00 00       	call   f0121b78 <__udivdi3>
f011ecdf:	83 c4 10             	add    $0x10,%esp
f011ece2:	83 ec 04             	sub    $0x4,%esp
f011ece5:	ff 75 20             	pushl  0x20(%ebp)
f011ece8:	53                   	push   %ebx
f011ece9:	ff 75 18             	pushl  0x18(%ebp)
f011ecec:	52                   	push   %edx
f011eced:	50                   	push   %eax
f011ecee:	ff 75 0c             	pushl  0xc(%ebp)
f011ecf1:	ff 75 08             	pushl  0x8(%ebp)
f011ecf4:	e8 a1 ff ff ff       	call   f011ec9a <printnum>
f011ecf9:	83 c4 20             	add    $0x20,%esp
f011ecfc:	eb 1a                	jmp    f011ed18 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011ecfe:	83 ec 08             	sub    $0x8,%esp
f011ed01:	ff 75 0c             	pushl  0xc(%ebp)
f011ed04:	ff 75 20             	pushl  0x20(%ebp)
f011ed07:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed0a:	ff d0                	call   *%eax
f011ed0c:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011ed0f:	ff 4d 1c             	decl   0x1c(%ebp)
f011ed12:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011ed16:	7f e6                	jg     f011ecfe <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011ed18:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011ed1b:	bb 00 00 00 00       	mov    $0x0,%ebx
f011ed20:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed23:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ed26:	53                   	push   %ebx
f011ed27:	51                   	push   %ecx
f011ed28:	52                   	push   %edx
f011ed29:	50                   	push   %eax
f011ed2a:	e8 59 2f 00 00       	call   f0121c88 <__umoddi3>
f011ed2f:	83 c4 10             	add    $0x10,%esp
f011ed32:	05 54 0a 13 f0       	add    $0xf0130a54,%eax
f011ed37:	8a 00                	mov    (%eax),%al
f011ed39:	0f be c0             	movsbl %al,%eax
f011ed3c:	83 ec 08             	sub    $0x8,%esp
f011ed3f:	ff 75 0c             	pushl  0xc(%ebp)
f011ed42:	50                   	push   %eax
f011ed43:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed46:	ff d0                	call   *%eax
f011ed48:	83 c4 10             	add    $0x10,%esp
}
f011ed4b:	90                   	nop
f011ed4c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011ed4f:	c9                   	leave  
f011ed50:	c3                   	ret    

f011ed51 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011ed51:	55                   	push   %ebp
f011ed52:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011ed54:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011ed58:	7e 1c                	jle    f011ed76 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011ed5a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed5d:	8b 00                	mov    (%eax),%eax
f011ed5f:	8d 50 08             	lea    0x8(%eax),%edx
f011ed62:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed65:	89 10                	mov    %edx,(%eax)
f011ed67:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed6a:	8b 00                	mov    (%eax),%eax
f011ed6c:	83 e8 08             	sub    $0x8,%eax
f011ed6f:	8b 50 04             	mov    0x4(%eax),%edx
f011ed72:	8b 00                	mov    (%eax),%eax
f011ed74:	eb 40                	jmp    f011edb6 <getuint+0x65>
	else if (lflag)
f011ed76:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ed7a:	74 1e                	je     f011ed9a <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011ed7c:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed7f:	8b 00                	mov    (%eax),%eax
f011ed81:	8d 50 04             	lea    0x4(%eax),%edx
f011ed84:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed87:	89 10                	mov    %edx,(%eax)
f011ed89:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed8c:	8b 00                	mov    (%eax),%eax
f011ed8e:	83 e8 04             	sub    $0x4,%eax
f011ed91:	8b 00                	mov    (%eax),%eax
f011ed93:	ba 00 00 00 00       	mov    $0x0,%edx
f011ed98:	eb 1c                	jmp    f011edb6 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011ed9a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed9d:	8b 00                	mov    (%eax),%eax
f011ed9f:	8d 50 04             	lea    0x4(%eax),%edx
f011eda2:	8b 45 08             	mov    0x8(%ebp),%eax
f011eda5:	89 10                	mov    %edx,(%eax)
f011eda7:	8b 45 08             	mov    0x8(%ebp),%eax
f011edaa:	8b 00                	mov    (%eax),%eax
f011edac:	83 e8 04             	sub    $0x4,%eax
f011edaf:	8b 00                	mov    (%eax),%eax
f011edb1:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011edb6:	5d                   	pop    %ebp
f011edb7:	c3                   	ret    

f011edb8 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011edb8:	55                   	push   %ebp
f011edb9:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011edbb:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011edbf:	7e 1c                	jle    f011eddd <getint+0x25>
		return va_arg(*ap, long long);
f011edc1:	8b 45 08             	mov    0x8(%ebp),%eax
f011edc4:	8b 00                	mov    (%eax),%eax
f011edc6:	8d 50 08             	lea    0x8(%eax),%edx
f011edc9:	8b 45 08             	mov    0x8(%ebp),%eax
f011edcc:	89 10                	mov    %edx,(%eax)
f011edce:	8b 45 08             	mov    0x8(%ebp),%eax
f011edd1:	8b 00                	mov    (%eax),%eax
f011edd3:	83 e8 08             	sub    $0x8,%eax
f011edd6:	8b 50 04             	mov    0x4(%eax),%edx
f011edd9:	8b 00                	mov    (%eax),%eax
f011eddb:	eb 38                	jmp    f011ee15 <getint+0x5d>
	else if (lflag)
f011eddd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ede1:	74 1a                	je     f011edfd <getint+0x45>
		return va_arg(*ap, long);
f011ede3:	8b 45 08             	mov    0x8(%ebp),%eax
f011ede6:	8b 00                	mov    (%eax),%eax
f011ede8:	8d 50 04             	lea    0x4(%eax),%edx
f011edeb:	8b 45 08             	mov    0x8(%ebp),%eax
f011edee:	89 10                	mov    %edx,(%eax)
f011edf0:	8b 45 08             	mov    0x8(%ebp),%eax
f011edf3:	8b 00                	mov    (%eax),%eax
f011edf5:	83 e8 04             	sub    $0x4,%eax
f011edf8:	8b 00                	mov    (%eax),%eax
f011edfa:	99                   	cltd   
f011edfb:	eb 18                	jmp    f011ee15 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011edfd:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee00:	8b 00                	mov    (%eax),%eax
f011ee02:	8d 50 04             	lea    0x4(%eax),%edx
f011ee05:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee08:	89 10                	mov    %edx,(%eax)
f011ee0a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee0d:	8b 00                	mov    (%eax),%eax
f011ee0f:	83 e8 04             	sub    $0x4,%eax
f011ee12:	8b 00                	mov    (%eax),%eax
f011ee14:	99                   	cltd   
}
f011ee15:	5d                   	pop    %ebp
f011ee16:	c3                   	ret    

f011ee17 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011ee17:	55                   	push   %ebp
f011ee18:	89 e5                	mov    %esp,%ebp
f011ee1a:	56                   	push   %esi
f011ee1b:	53                   	push   %ebx
f011ee1c:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011ee1f:	eb 17                	jmp    f011ee38 <vprintfmt+0x21>
			if (ch == '\0')
f011ee21:	85 db                	test   %ebx,%ebx
f011ee23:	0f 84 c1 03 00 00    	je     f011f1ea <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011ee29:	83 ec 08             	sub    $0x8,%esp
f011ee2c:	ff 75 0c             	pushl  0xc(%ebp)
f011ee2f:	53                   	push   %ebx
f011ee30:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee33:	ff d0                	call   *%eax
f011ee35:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011ee38:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee3b:	8d 50 01             	lea    0x1(%eax),%edx
f011ee3e:	89 55 10             	mov    %edx,0x10(%ebp)
f011ee41:	8a 00                	mov    (%eax),%al
f011ee43:	0f b6 d8             	movzbl %al,%ebx
f011ee46:	83 fb 25             	cmp    $0x25,%ebx
f011ee49:	75 d6                	jne    f011ee21 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011ee4b:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011ee4f:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011ee56:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011ee5d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011ee64:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011ee6b:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee6e:	8d 50 01             	lea    0x1(%eax),%edx
f011ee71:	89 55 10             	mov    %edx,0x10(%ebp)
f011ee74:	8a 00                	mov    (%eax),%al
f011ee76:	0f b6 d8             	movzbl %al,%ebx
f011ee79:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011ee7c:	83 f8 5b             	cmp    $0x5b,%eax
f011ee7f:	0f 87 3d 03 00 00    	ja     f011f1c2 <vprintfmt+0x3ab>
f011ee85:	8b 04 85 78 0a 13 f0 	mov    -0xfecf588(,%eax,4),%eax
f011ee8c:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011ee8e:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011ee92:	eb d7                	jmp    f011ee6b <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011ee94:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011ee98:	eb d1                	jmp    f011ee6b <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011ee9a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011eea1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011eea4:	89 d0                	mov    %edx,%eax
f011eea6:	c1 e0 02             	shl    $0x2,%eax
f011eea9:	01 d0                	add    %edx,%eax
f011eeab:	01 c0                	add    %eax,%eax
f011eead:	01 d8                	add    %ebx,%eax
f011eeaf:	83 e8 30             	sub    $0x30,%eax
f011eeb2:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011eeb5:	8b 45 10             	mov    0x10(%ebp),%eax
f011eeb8:	8a 00                	mov    (%eax),%al
f011eeba:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011eebd:	83 fb 2f             	cmp    $0x2f,%ebx
f011eec0:	7e 3e                	jle    f011ef00 <vprintfmt+0xe9>
f011eec2:	83 fb 39             	cmp    $0x39,%ebx
f011eec5:	7f 39                	jg     f011ef00 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011eec7:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011eeca:	eb d5                	jmp    f011eea1 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011eecc:	8b 45 14             	mov    0x14(%ebp),%eax
f011eecf:	83 c0 04             	add    $0x4,%eax
f011eed2:	89 45 14             	mov    %eax,0x14(%ebp)
f011eed5:	8b 45 14             	mov    0x14(%ebp),%eax
f011eed8:	83 e8 04             	sub    $0x4,%eax
f011eedb:	8b 00                	mov    (%eax),%eax
f011eedd:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011eee0:	eb 1f                	jmp    f011ef01 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011eee2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eee6:	79 83                	jns    f011ee6b <vprintfmt+0x54>
				width = 0;
f011eee8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011eeef:	e9 77 ff ff ff       	jmp    f011ee6b <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011eef4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011eefb:	e9 6b ff ff ff       	jmp    f011ee6b <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011ef00:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011ef01:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ef05:	0f 89 60 ff ff ff    	jns    f011ee6b <vprintfmt+0x54>
				width = precision, precision = -1;
f011ef0b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ef0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ef11:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011ef18:	e9 4e ff ff ff       	jmp    f011ee6b <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011ef1d:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011ef20:	e9 46 ff ff ff       	jmp    f011ee6b <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011ef25:	8b 45 14             	mov    0x14(%ebp),%eax
f011ef28:	83 c0 04             	add    $0x4,%eax
f011ef2b:	89 45 14             	mov    %eax,0x14(%ebp)
f011ef2e:	8b 45 14             	mov    0x14(%ebp),%eax
f011ef31:	83 e8 04             	sub    $0x4,%eax
f011ef34:	8b 00                	mov    (%eax),%eax
f011ef36:	83 ec 08             	sub    $0x8,%esp
f011ef39:	ff 75 0c             	pushl  0xc(%ebp)
f011ef3c:	50                   	push   %eax
f011ef3d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef40:	ff d0                	call   *%eax
f011ef42:	83 c4 10             	add    $0x10,%esp
			break;
f011ef45:	e9 9b 02 00 00       	jmp    f011f1e5 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011ef4a:	8b 45 14             	mov    0x14(%ebp),%eax
f011ef4d:	83 c0 04             	add    $0x4,%eax
f011ef50:	89 45 14             	mov    %eax,0x14(%ebp)
f011ef53:	8b 45 14             	mov    0x14(%ebp),%eax
f011ef56:	83 e8 04             	sub    $0x4,%eax
f011ef59:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011ef5b:	85 db                	test   %ebx,%ebx
f011ef5d:	79 02                	jns    f011ef61 <vprintfmt+0x14a>
				err = -err;
f011ef5f:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011ef61:	83 fb 64             	cmp    $0x64,%ebx
f011ef64:	7f 0b                	jg     f011ef71 <vprintfmt+0x15a>
f011ef66:	8b 34 9d c0 08 13 f0 	mov    -0xfecf740(,%ebx,4),%esi
f011ef6d:	85 f6                	test   %esi,%esi
f011ef6f:	75 19                	jne    f011ef8a <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011ef71:	53                   	push   %ebx
f011ef72:	68 65 0a 13 f0       	push   $0xf0130a65
f011ef77:	ff 75 0c             	pushl  0xc(%ebp)
f011ef7a:	ff 75 08             	pushl  0x8(%ebp)
f011ef7d:	e8 70 02 00 00       	call   f011f1f2 <printfmt>
f011ef82:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011ef85:	e9 5b 02 00 00       	jmp    f011f1e5 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011ef8a:	56                   	push   %esi
f011ef8b:	68 6e 0a 13 f0       	push   $0xf0130a6e
f011ef90:	ff 75 0c             	pushl  0xc(%ebp)
f011ef93:	ff 75 08             	pushl  0x8(%ebp)
f011ef96:	e8 57 02 00 00       	call   f011f1f2 <printfmt>
f011ef9b:	83 c4 10             	add    $0x10,%esp
			break;
f011ef9e:	e9 42 02 00 00       	jmp    f011f1e5 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011efa3:	8b 45 14             	mov    0x14(%ebp),%eax
f011efa6:	83 c0 04             	add    $0x4,%eax
f011efa9:	89 45 14             	mov    %eax,0x14(%ebp)
f011efac:	8b 45 14             	mov    0x14(%ebp),%eax
f011efaf:	83 e8 04             	sub    $0x4,%eax
f011efb2:	8b 30                	mov    (%eax),%esi
f011efb4:	85 f6                	test   %esi,%esi
f011efb6:	75 05                	jne    f011efbd <vprintfmt+0x1a6>
				p = "(null)";
f011efb8:	be 71 0a 13 f0       	mov    $0xf0130a71,%esi
			if (width > 0 && padc != '-')
f011efbd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011efc1:	7e 6d                	jle    f011f030 <vprintfmt+0x219>
f011efc3:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011efc7:	74 67                	je     f011f030 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011efc9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011efcc:	83 ec 08             	sub    $0x8,%esp
f011efcf:	50                   	push   %eax
f011efd0:	56                   	push   %esi
f011efd1:	e8 26 05 00 00       	call   f011f4fc <strnlen>
f011efd6:	83 c4 10             	add    $0x10,%esp
f011efd9:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011efdc:	eb 16                	jmp    f011eff4 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011efde:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011efe2:	83 ec 08             	sub    $0x8,%esp
f011efe5:	ff 75 0c             	pushl  0xc(%ebp)
f011efe8:	50                   	push   %eax
f011efe9:	8b 45 08             	mov    0x8(%ebp),%eax
f011efec:	ff d0                	call   *%eax
f011efee:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011eff1:	ff 4d e4             	decl   -0x1c(%ebp)
f011eff4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eff8:	7f e4                	jg     f011efde <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011effa:	eb 34                	jmp    f011f030 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011effc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f000:	74 1c                	je     f011f01e <vprintfmt+0x207>
f011f002:	83 fb 1f             	cmp    $0x1f,%ebx
f011f005:	7e 05                	jle    f011f00c <vprintfmt+0x1f5>
f011f007:	83 fb 7e             	cmp    $0x7e,%ebx
f011f00a:	7e 12                	jle    f011f01e <vprintfmt+0x207>
					putch('?', putdat);
f011f00c:	83 ec 08             	sub    $0x8,%esp
f011f00f:	ff 75 0c             	pushl  0xc(%ebp)
f011f012:	6a 3f                	push   $0x3f
f011f014:	8b 45 08             	mov    0x8(%ebp),%eax
f011f017:	ff d0                	call   *%eax
f011f019:	83 c4 10             	add    $0x10,%esp
f011f01c:	eb 0f                	jmp    f011f02d <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011f01e:	83 ec 08             	sub    $0x8,%esp
f011f021:	ff 75 0c             	pushl  0xc(%ebp)
f011f024:	53                   	push   %ebx
f011f025:	8b 45 08             	mov    0x8(%ebp),%eax
f011f028:	ff d0                	call   *%eax
f011f02a:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f02d:	ff 4d e4             	decl   -0x1c(%ebp)
f011f030:	89 f0                	mov    %esi,%eax
f011f032:	8d 70 01             	lea    0x1(%eax),%esi
f011f035:	8a 00                	mov    (%eax),%al
f011f037:	0f be d8             	movsbl %al,%ebx
f011f03a:	85 db                	test   %ebx,%ebx
f011f03c:	74 24                	je     f011f062 <vprintfmt+0x24b>
f011f03e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f042:	78 b8                	js     f011effc <vprintfmt+0x1e5>
f011f044:	ff 4d e0             	decl   -0x20(%ebp)
f011f047:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f04b:	79 af                	jns    f011effc <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f04d:	eb 13                	jmp    f011f062 <vprintfmt+0x24b>
				putch(' ', putdat);
f011f04f:	83 ec 08             	sub    $0x8,%esp
f011f052:	ff 75 0c             	pushl  0xc(%ebp)
f011f055:	6a 20                	push   $0x20
f011f057:	8b 45 08             	mov    0x8(%ebp),%eax
f011f05a:	ff d0                	call   *%eax
f011f05c:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f05f:	ff 4d e4             	decl   -0x1c(%ebp)
f011f062:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f066:	7f e7                	jg     f011f04f <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011f068:	e9 78 01 00 00       	jmp    f011f1e5 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011f06d:	83 ec 08             	sub    $0x8,%esp
f011f070:	ff 75 e8             	pushl  -0x18(%ebp)
f011f073:	8d 45 14             	lea    0x14(%ebp),%eax
f011f076:	50                   	push   %eax
f011f077:	e8 3c fd ff ff       	call   f011edb8 <getint>
f011f07c:	83 c4 10             	add    $0x10,%esp
f011f07f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f082:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011f085:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f088:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f08b:	85 d2                	test   %edx,%edx
f011f08d:	79 23                	jns    f011f0b2 <vprintfmt+0x29b>
				putch('-', putdat);
f011f08f:	83 ec 08             	sub    $0x8,%esp
f011f092:	ff 75 0c             	pushl  0xc(%ebp)
f011f095:	6a 2d                	push   $0x2d
f011f097:	8b 45 08             	mov    0x8(%ebp),%eax
f011f09a:	ff d0                	call   *%eax
f011f09c:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011f09f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f0a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f0a5:	f7 d8                	neg    %eax
f011f0a7:	83 d2 00             	adc    $0x0,%edx
f011f0aa:	f7 da                	neg    %edx
f011f0ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f0af:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011f0b2:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f0b9:	e9 bc 00 00 00       	jmp    f011f17a <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011f0be:	83 ec 08             	sub    $0x8,%esp
f011f0c1:	ff 75 e8             	pushl  -0x18(%ebp)
f011f0c4:	8d 45 14             	lea    0x14(%ebp),%eax
f011f0c7:	50                   	push   %eax
f011f0c8:	e8 84 fc ff ff       	call   f011ed51 <getuint>
f011f0cd:	83 c4 10             	add    $0x10,%esp
f011f0d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f0d3:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011f0d6:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f0dd:	e9 98 00 00 00       	jmp    f011f17a <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011f0e2:	83 ec 08             	sub    $0x8,%esp
f011f0e5:	ff 75 0c             	pushl  0xc(%ebp)
f011f0e8:	6a 58                	push   $0x58
f011f0ea:	8b 45 08             	mov    0x8(%ebp),%eax
f011f0ed:	ff d0                	call   *%eax
f011f0ef:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f0f2:	83 ec 08             	sub    $0x8,%esp
f011f0f5:	ff 75 0c             	pushl  0xc(%ebp)
f011f0f8:	6a 58                	push   $0x58
f011f0fa:	8b 45 08             	mov    0x8(%ebp),%eax
f011f0fd:	ff d0                	call   *%eax
f011f0ff:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f102:	83 ec 08             	sub    $0x8,%esp
f011f105:	ff 75 0c             	pushl  0xc(%ebp)
f011f108:	6a 58                	push   $0x58
f011f10a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f10d:	ff d0                	call   *%eax
f011f10f:	83 c4 10             	add    $0x10,%esp
			break;
f011f112:	e9 ce 00 00 00       	jmp    f011f1e5 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011f117:	83 ec 08             	sub    $0x8,%esp
f011f11a:	ff 75 0c             	pushl  0xc(%ebp)
f011f11d:	6a 30                	push   $0x30
f011f11f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f122:	ff d0                	call   *%eax
f011f124:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011f127:	83 ec 08             	sub    $0x8,%esp
f011f12a:	ff 75 0c             	pushl  0xc(%ebp)
f011f12d:	6a 78                	push   $0x78
f011f12f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f132:	ff d0                	call   *%eax
f011f134:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011f137:	8b 45 14             	mov    0x14(%ebp),%eax
f011f13a:	83 c0 04             	add    $0x4,%eax
f011f13d:	89 45 14             	mov    %eax,0x14(%ebp)
f011f140:	8b 45 14             	mov    0x14(%ebp),%eax
f011f143:	83 e8 04             	sub    $0x4,%eax
f011f146:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011f148:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f14b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011f152:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011f159:	eb 1f                	jmp    f011f17a <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011f15b:	83 ec 08             	sub    $0x8,%esp
f011f15e:	ff 75 e8             	pushl  -0x18(%ebp)
f011f161:	8d 45 14             	lea    0x14(%ebp),%eax
f011f164:	50                   	push   %eax
f011f165:	e8 e7 fb ff ff       	call   f011ed51 <getuint>
f011f16a:	83 c4 10             	add    $0x10,%esp
f011f16d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f170:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011f173:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011f17a:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011f17e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f181:	83 ec 04             	sub    $0x4,%esp
f011f184:	52                   	push   %edx
f011f185:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f188:	50                   	push   %eax
f011f189:	ff 75 f4             	pushl  -0xc(%ebp)
f011f18c:	ff 75 f0             	pushl  -0x10(%ebp)
f011f18f:	ff 75 0c             	pushl  0xc(%ebp)
f011f192:	ff 75 08             	pushl  0x8(%ebp)
f011f195:	e8 00 fb ff ff       	call   f011ec9a <printnum>
f011f19a:	83 c4 20             	add    $0x20,%esp
			break;
f011f19d:	eb 46                	jmp    f011f1e5 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011f19f:	83 ec 08             	sub    $0x8,%esp
f011f1a2:	ff 75 0c             	pushl  0xc(%ebp)
f011f1a5:	53                   	push   %ebx
f011f1a6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1a9:	ff d0                	call   *%eax
f011f1ab:	83 c4 10             	add    $0x10,%esp
			break;
f011f1ae:	eb 35                	jmp    f011f1e5 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011f1b0:	c6 05 a0 b2 6b f0 00 	movb   $0x0,0xf06bb2a0
			break;
f011f1b7:	eb 2c                	jmp    f011f1e5 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011f1b9:	c6 05 a0 b2 6b f0 01 	movb   $0x1,0xf06bb2a0
			break;
f011f1c0:	eb 23                	jmp    f011f1e5 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011f1c2:	83 ec 08             	sub    $0x8,%esp
f011f1c5:	ff 75 0c             	pushl  0xc(%ebp)
f011f1c8:	6a 25                	push   $0x25
f011f1ca:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1cd:	ff d0                	call   *%eax
f011f1cf:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011f1d2:	ff 4d 10             	decl   0x10(%ebp)
f011f1d5:	eb 03                	jmp    f011f1da <vprintfmt+0x3c3>
f011f1d7:	ff 4d 10             	decl   0x10(%ebp)
f011f1da:	8b 45 10             	mov    0x10(%ebp),%eax
f011f1dd:	48                   	dec    %eax
f011f1de:	8a 00                	mov    (%eax),%al
f011f1e0:	3c 25                	cmp    $0x25,%al
f011f1e2:	75 f3                	jne    f011f1d7 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011f1e4:	90                   	nop
		}
	}
f011f1e5:	e9 35 fc ff ff       	jmp    f011ee1f <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011f1ea:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011f1eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f1ee:	5b                   	pop    %ebx
f011f1ef:	5e                   	pop    %esi
f011f1f0:	5d                   	pop    %ebp
f011f1f1:	c3                   	ret    

f011f1f2 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011f1f2:	55                   	push   %ebp
f011f1f3:	89 e5                	mov    %esp,%ebp
f011f1f5:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011f1f8:	8d 45 10             	lea    0x10(%ebp),%eax
f011f1fb:	83 c0 04             	add    $0x4,%eax
f011f1fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011f201:	8b 45 10             	mov    0x10(%ebp),%eax
f011f204:	ff 75 f4             	pushl  -0xc(%ebp)
f011f207:	50                   	push   %eax
f011f208:	ff 75 0c             	pushl  0xc(%ebp)
f011f20b:	ff 75 08             	pushl  0x8(%ebp)
f011f20e:	e8 04 fc ff ff       	call   f011ee17 <vprintfmt>
f011f213:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011f216:	90                   	nop
f011f217:	c9                   	leave  
f011f218:	c3                   	ret    

f011f219 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011f219:	55                   	push   %ebp
f011f21a:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011f21c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f21f:	8b 40 08             	mov    0x8(%eax),%eax
f011f222:	8d 50 01             	lea    0x1(%eax),%edx
f011f225:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f228:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011f22b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f22e:	8b 10                	mov    (%eax),%edx
f011f230:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f233:	8b 40 04             	mov    0x4(%eax),%eax
f011f236:	39 c2                	cmp    %eax,%edx
f011f238:	73 12                	jae    f011f24c <sprintputch+0x33>
		*b->buf++ = ch;
f011f23a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f23d:	8b 00                	mov    (%eax),%eax
f011f23f:	8d 48 01             	lea    0x1(%eax),%ecx
f011f242:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f245:	89 0a                	mov    %ecx,(%edx)
f011f247:	8b 55 08             	mov    0x8(%ebp),%edx
f011f24a:	88 10                	mov    %dl,(%eax)
}
f011f24c:	90                   	nop
f011f24d:	5d                   	pop    %ebp
f011f24e:	c3                   	ret    

f011f24f <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011f24f:	55                   	push   %ebp
f011f250:	89 e5                	mov    %esp,%ebp
f011f252:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011f255:	8b 45 08             	mov    0x8(%ebp),%eax
f011f258:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f25b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f25e:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f261:	8b 45 08             	mov    0x8(%ebp),%eax
f011f264:	01 d0                	add    %edx,%eax
f011f266:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f269:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011f270:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f274:	74 06                	je     f011f27c <vsnprintf+0x2d>
f011f276:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f27a:	7f 07                	jg     f011f283 <vsnprintf+0x34>
		return -E_INVAL;
f011f27c:	b8 03 00 00 00       	mov    $0x3,%eax
f011f281:	eb 20                	jmp    f011f2a3 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011f283:	ff 75 14             	pushl  0x14(%ebp)
f011f286:	ff 75 10             	pushl  0x10(%ebp)
f011f289:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011f28c:	50                   	push   %eax
f011f28d:	68 19 f2 11 f0       	push   $0xf011f219
f011f292:	e8 80 fb ff ff       	call   f011ee17 <vprintfmt>
f011f297:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011f29a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f29d:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011f2a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011f2a3:	c9                   	leave  
f011f2a4:	c3                   	ret    

f011f2a5 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011f2a5:	55                   	push   %ebp
f011f2a6:	89 e5                	mov    %esp,%ebp
f011f2a8:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011f2ab:	8d 45 10             	lea    0x10(%ebp),%eax
f011f2ae:	83 c0 04             	add    $0x4,%eax
f011f2b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011f2b4:	8b 45 10             	mov    0x10(%ebp),%eax
f011f2b7:	ff 75 f4             	pushl  -0xc(%ebp)
f011f2ba:	50                   	push   %eax
f011f2bb:	ff 75 0c             	pushl  0xc(%ebp)
f011f2be:	ff 75 08             	pushl  0x8(%ebp)
f011f2c1:	e8 89 ff ff ff       	call   f011f24f <vsnprintf>
f011f2c6:	83 c4 10             	add    $0x10,%esp
f011f2c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011f2cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011f2cf:	c9                   	leave  
f011f2d0:	c3                   	ret    

f011f2d1 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011f2d1:	55                   	push   %ebp
f011f2d2:	89 e5                	mov    %esp,%ebp
f011f2d4:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011f2d7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f2db:	74 13                	je     f011f2f0 <readline+0x1f>
		cprintf("%s", prompt);
f011f2dd:	83 ec 08             	sub    $0x8,%esp
f011f2e0:	ff 75 08             	pushl  0x8(%ebp)
f011f2e3:	68 e8 0b 13 f0       	push   $0xf0130be8
f011f2e8:	e8 9e 1c fe ff       	call   f0100f8b <cprintf>
f011f2ed:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011f2f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011f2f7:	83 ec 0c             	sub    $0xc,%esp
f011f2fa:	6a 00                	push   $0x0
f011f2fc:	e8 97 1b fe ff       	call   f0100e98 <iscons>
f011f301:	83 c4 10             	add    $0x10,%esp
f011f304:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011f307:	e8 73 1b fe ff       	call   f0100e7f <getchar>
f011f30c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011f30f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011f313:	79 22                	jns    f011f337 <readline+0x66>
			if (c != -E_EOF)
f011f315:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011f319:	0f 84 ad 00 00 00    	je     f011f3cc <readline+0xfb>
				cprintf("read error: %e\n", c);
f011f31f:	83 ec 08             	sub    $0x8,%esp
f011f322:	ff 75 ec             	pushl  -0x14(%ebp)
f011f325:	68 eb 0b 13 f0       	push   $0xf0130beb
f011f32a:	e8 5c 1c fe ff       	call   f0100f8b <cprintf>
f011f32f:	83 c4 10             	add    $0x10,%esp
			break;
f011f332:	e9 95 00 00 00       	jmp    f011f3cc <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011f337:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011f33b:	7e 34                	jle    f011f371 <readline+0xa0>
f011f33d:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011f344:	7f 2b                	jg     f011f371 <readline+0xa0>
			if (echoing)
f011f346:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f34a:	74 0e                	je     f011f35a <readline+0x89>
				cputchar(c);
f011f34c:	83 ec 0c             	sub    $0xc,%esp
f011f34f:	ff 75 ec             	pushl  -0x14(%ebp)
f011f352:	e8 11 1b fe ff       	call   f0100e68 <cputchar>
f011f357:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011f35a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f35d:	8d 50 01             	lea    0x1(%eax),%edx
f011f360:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011f363:	89 c2                	mov    %eax,%edx
f011f365:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f368:	01 d0                	add    %edx,%eax
f011f36a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f36d:	88 10                	mov    %dl,(%eax)
f011f36f:	eb 56                	jmp    f011f3c7 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011f371:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011f375:	75 1f                	jne    f011f396 <readline+0xc5>
f011f377:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f37b:	7e 19                	jle    f011f396 <readline+0xc5>
			if (echoing)
f011f37d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f381:	74 0e                	je     f011f391 <readline+0xc0>
				cputchar(c);
f011f383:	83 ec 0c             	sub    $0xc,%esp
f011f386:	ff 75 ec             	pushl  -0x14(%ebp)
f011f389:	e8 da 1a fe ff       	call   f0100e68 <cputchar>
f011f38e:	83 c4 10             	add    $0x10,%esp

			i--;
f011f391:	ff 4d f4             	decl   -0xc(%ebp)
f011f394:	eb 31                	jmp    f011f3c7 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011f396:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011f39a:	74 0a                	je     f011f3a6 <readline+0xd5>
f011f39c:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011f3a0:	0f 85 61 ff ff ff    	jne    f011f307 <readline+0x36>
			if (echoing)
f011f3a6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f3aa:	74 0e                	je     f011f3ba <readline+0xe9>
				cputchar(c);
f011f3ac:	83 ec 0c             	sub    $0xc,%esp
f011f3af:	ff 75 ec             	pushl  -0x14(%ebp)
f011f3b2:	e8 b1 1a fe ff       	call   f0100e68 <cputchar>
f011f3b7:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011f3ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f3bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f3c0:	01 d0                	add    %edx,%eax
f011f3c2:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011f3c5:	eb 06                	jmp    f011f3cd <readline+0xfc>
		}
	}
f011f3c7:	e9 3b ff ff ff       	jmp    f011f307 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011f3cc:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011f3cd:	90                   	nop
f011f3ce:	c9                   	leave  
f011f3cf:	c3                   	ret    

f011f3d0 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011f3d0:	55                   	push   %ebp
f011f3d1:	89 e5                	mov    %esp,%ebp
f011f3d3:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011f3d6:	e8 40 ec fe ff       	call   f010e01b <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011f3db:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f3df:	74 13                	je     f011f3f4 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011f3e1:	83 ec 08             	sub    $0x8,%esp
f011f3e4:	ff 75 08             	pushl  0x8(%ebp)
f011f3e7:	68 e8 0b 13 f0       	push   $0xf0130be8
f011f3ec:	e8 9a 1b fe ff       	call   f0100f8b <cprintf>
f011f3f1:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011f3f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011f3fb:	83 ec 0c             	sub    $0xc,%esp
f011f3fe:	6a 00                	push   $0x0
f011f400:	e8 93 1a fe ff       	call   f0100e98 <iscons>
f011f405:	83 c4 10             	add    $0x10,%esp
f011f408:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011f40b:	e8 6f 1a fe ff       	call   f0100e7f <getchar>
f011f410:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011f413:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011f417:	79 22                	jns    f011f43b <atomic_readline+0x6b>
				if (c != -E_EOF)
f011f419:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011f41d:	0f 84 ad 00 00 00    	je     f011f4d0 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011f423:	83 ec 08             	sub    $0x8,%esp
f011f426:	ff 75 ec             	pushl  -0x14(%ebp)
f011f429:	68 eb 0b 13 f0       	push   $0xf0130beb
f011f42e:	e8 58 1b fe ff       	call   f0100f8b <cprintf>
f011f433:	83 c4 10             	add    $0x10,%esp
				break;
f011f436:	e9 95 00 00 00       	jmp    f011f4d0 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011f43b:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011f43f:	7e 34                	jle    f011f475 <atomic_readline+0xa5>
f011f441:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011f448:	7f 2b                	jg     f011f475 <atomic_readline+0xa5>
				if (echoing)
f011f44a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f44e:	74 0e                	je     f011f45e <atomic_readline+0x8e>
					cputchar(c);
f011f450:	83 ec 0c             	sub    $0xc,%esp
f011f453:	ff 75 ec             	pushl  -0x14(%ebp)
f011f456:	e8 0d 1a fe ff       	call   f0100e68 <cputchar>
f011f45b:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011f45e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f461:	8d 50 01             	lea    0x1(%eax),%edx
f011f464:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011f467:	89 c2                	mov    %eax,%edx
f011f469:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f46c:	01 d0                	add    %edx,%eax
f011f46e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f471:	88 10                	mov    %dl,(%eax)
f011f473:	eb 56                	jmp    f011f4cb <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011f475:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011f479:	75 1f                	jne    f011f49a <atomic_readline+0xca>
f011f47b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f47f:	7e 19                	jle    f011f49a <atomic_readline+0xca>
				if (echoing)
f011f481:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f485:	74 0e                	je     f011f495 <atomic_readline+0xc5>
					cputchar(c);
f011f487:	83 ec 0c             	sub    $0xc,%esp
f011f48a:	ff 75 ec             	pushl  -0x14(%ebp)
f011f48d:	e8 d6 19 fe ff       	call   f0100e68 <cputchar>
f011f492:	83 c4 10             	add    $0x10,%esp
				i--;
f011f495:	ff 4d f4             	decl   -0xc(%ebp)
f011f498:	eb 31                	jmp    f011f4cb <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011f49a:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011f49e:	74 0a                	je     f011f4aa <atomic_readline+0xda>
f011f4a0:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011f4a4:	0f 85 61 ff ff ff    	jne    f011f40b <atomic_readline+0x3b>
				if (echoing)
f011f4aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f4ae:	74 0e                	je     f011f4be <atomic_readline+0xee>
					cputchar(c);
f011f4b0:	83 ec 0c             	sub    $0xc,%esp
f011f4b3:	ff 75 ec             	pushl  -0x14(%ebp)
f011f4b6:	e8 ad 19 fe ff       	call   f0100e68 <cputchar>
f011f4bb:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011f4be:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f4c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f4c4:	01 d0                	add    %edx,%eax
f011f4c6:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011f4c9:	eb 06                	jmp    f011f4d1 <atomic_readline+0x101>
			}
		}
f011f4cb:	e9 3b ff ff ff       	jmp    f011f40b <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011f4d0:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011f4d1:	e8 53 eb fe ff       	call   f010e029 <sys_unlock_cons>
}
f011f4d6:	90                   	nop
f011f4d7:	c9                   	leave  
f011f4d8:	c3                   	ret    

f011f4d9 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011f4d9:	55                   	push   %ebp
f011f4da:	89 e5                	mov    %esp,%ebp
f011f4dc:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011f4df:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f4e6:	eb 06                	jmp    f011f4ee <strlen+0x15>
		n++;
f011f4e8:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011f4eb:	ff 45 08             	incl   0x8(%ebp)
f011f4ee:	8b 45 08             	mov    0x8(%ebp),%eax
f011f4f1:	8a 00                	mov    (%eax),%al
f011f4f3:	84 c0                	test   %al,%al
f011f4f5:	75 f1                	jne    f011f4e8 <strlen+0xf>
		n++;
	return n;
f011f4f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011f4fa:	c9                   	leave  
f011f4fb:	c3                   	ret    

f011f4fc <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011f4fc:	55                   	push   %ebp
f011f4fd:	89 e5                	mov    %esp,%ebp
f011f4ff:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011f502:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f509:	eb 09                	jmp    f011f514 <strnlen+0x18>
		n++;
f011f50b:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011f50e:	ff 45 08             	incl   0x8(%ebp)
f011f511:	ff 4d 0c             	decl   0xc(%ebp)
f011f514:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f518:	74 09                	je     f011f523 <strnlen+0x27>
f011f51a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f51d:	8a 00                	mov    (%eax),%al
f011f51f:	84 c0                	test   %al,%al
f011f521:	75 e8                	jne    f011f50b <strnlen+0xf>
		n++;
	return n;
f011f523:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011f526:	c9                   	leave  
f011f527:	c3                   	ret    

f011f528 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011f528:	55                   	push   %ebp
f011f529:	89 e5                	mov    %esp,%ebp
f011f52b:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011f52e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f531:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011f534:	90                   	nop
f011f535:	8b 45 08             	mov    0x8(%ebp),%eax
f011f538:	8d 50 01             	lea    0x1(%eax),%edx
f011f53b:	89 55 08             	mov    %edx,0x8(%ebp)
f011f53e:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f541:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f544:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011f547:	8a 12                	mov    (%edx),%dl
f011f549:	88 10                	mov    %dl,(%eax)
f011f54b:	8a 00                	mov    (%eax),%al
f011f54d:	84 c0                	test   %al,%al
f011f54f:	75 e4                	jne    f011f535 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011f551:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011f554:	c9                   	leave  
f011f555:	c3                   	ret    

f011f556 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011f556:	55                   	push   %ebp
f011f557:	89 e5                	mov    %esp,%ebp
f011f559:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011f55c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f55f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011f562:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f569:	eb 1f                	jmp    f011f58a <strncpy+0x34>
		*dst++ = *src;
f011f56b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f56e:	8d 50 01             	lea    0x1(%eax),%edx
f011f571:	89 55 08             	mov    %edx,0x8(%ebp)
f011f574:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f577:	8a 12                	mov    (%edx),%dl
f011f579:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011f57b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f57e:	8a 00                	mov    (%eax),%al
f011f580:	84 c0                	test   %al,%al
f011f582:	74 03                	je     f011f587 <strncpy+0x31>
			src++;
f011f584:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011f587:	ff 45 fc             	incl   -0x4(%ebp)
f011f58a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f58d:	3b 45 10             	cmp    0x10(%ebp),%eax
f011f590:	72 d9                	jb     f011f56b <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011f592:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011f595:	c9                   	leave  
f011f596:	c3                   	ret    

f011f597 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011f597:	55                   	push   %ebp
f011f598:	89 e5                	mov    %esp,%ebp
f011f59a:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011f59d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5a0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011f5a3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f5a7:	74 30                	je     f011f5d9 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011f5a9:	eb 16                	jmp    f011f5c1 <strlcpy+0x2a>
			*dst++ = *src++;
f011f5ab:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5ae:	8d 50 01             	lea    0x1(%eax),%edx
f011f5b1:	89 55 08             	mov    %edx,0x8(%ebp)
f011f5b4:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f5b7:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f5ba:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011f5bd:	8a 12                	mov    (%edx),%dl
f011f5bf:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011f5c1:	ff 4d 10             	decl   0x10(%ebp)
f011f5c4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f5c8:	74 09                	je     f011f5d3 <strlcpy+0x3c>
f011f5ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f5cd:	8a 00                	mov    (%eax),%al
f011f5cf:	84 c0                	test   %al,%al
f011f5d1:	75 d8                	jne    f011f5ab <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011f5d3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5d6:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011f5d9:	8b 55 08             	mov    0x8(%ebp),%edx
f011f5dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f5df:	29 c2                	sub    %eax,%edx
f011f5e1:	89 d0                	mov    %edx,%eax
}
f011f5e3:	c9                   	leave  
f011f5e4:	c3                   	ret    

f011f5e5 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011f5e5:	55                   	push   %ebp
f011f5e6:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011f5e8:	eb 06                	jmp    f011f5f0 <strcmp+0xb>
		p++, q++;
f011f5ea:	ff 45 08             	incl   0x8(%ebp)
f011f5ed:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011f5f0:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5f3:	8a 00                	mov    (%eax),%al
f011f5f5:	84 c0                	test   %al,%al
f011f5f7:	74 0e                	je     f011f607 <strcmp+0x22>
f011f5f9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5fc:	8a 10                	mov    (%eax),%dl
f011f5fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f601:	8a 00                	mov    (%eax),%al
f011f603:	38 c2                	cmp    %al,%dl
f011f605:	74 e3                	je     f011f5ea <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011f607:	8b 45 08             	mov    0x8(%ebp),%eax
f011f60a:	8a 00                	mov    (%eax),%al
f011f60c:	0f b6 d0             	movzbl %al,%edx
f011f60f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f612:	8a 00                	mov    (%eax),%al
f011f614:	0f b6 c0             	movzbl %al,%eax
f011f617:	29 c2                	sub    %eax,%edx
f011f619:	89 d0                	mov    %edx,%eax
}
f011f61b:	5d                   	pop    %ebp
f011f61c:	c3                   	ret    

f011f61d <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011f61d:	55                   	push   %ebp
f011f61e:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011f620:	eb 09                	jmp    f011f62b <strncmp+0xe>
		n--, p++, q++;
f011f622:	ff 4d 10             	decl   0x10(%ebp)
f011f625:	ff 45 08             	incl   0x8(%ebp)
f011f628:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011f62b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f62f:	74 17                	je     f011f648 <strncmp+0x2b>
f011f631:	8b 45 08             	mov    0x8(%ebp),%eax
f011f634:	8a 00                	mov    (%eax),%al
f011f636:	84 c0                	test   %al,%al
f011f638:	74 0e                	je     f011f648 <strncmp+0x2b>
f011f63a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f63d:	8a 10                	mov    (%eax),%dl
f011f63f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f642:	8a 00                	mov    (%eax),%al
f011f644:	38 c2                	cmp    %al,%dl
f011f646:	74 da                	je     f011f622 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011f648:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f64c:	75 07                	jne    f011f655 <strncmp+0x38>
		return 0;
f011f64e:	b8 00 00 00 00       	mov    $0x0,%eax
f011f653:	eb 14                	jmp    f011f669 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011f655:	8b 45 08             	mov    0x8(%ebp),%eax
f011f658:	8a 00                	mov    (%eax),%al
f011f65a:	0f b6 d0             	movzbl %al,%edx
f011f65d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f660:	8a 00                	mov    (%eax),%al
f011f662:	0f b6 c0             	movzbl %al,%eax
f011f665:	29 c2                	sub    %eax,%edx
f011f667:	89 d0                	mov    %edx,%eax
}
f011f669:	5d                   	pop    %ebp
f011f66a:	c3                   	ret    

f011f66b <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011f66b:	55                   	push   %ebp
f011f66c:	89 e5                	mov    %esp,%ebp
f011f66e:	83 ec 04             	sub    $0x4,%esp
f011f671:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f674:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011f677:	eb 12                	jmp    f011f68b <strchr+0x20>
		if (*s == c)
f011f679:	8b 45 08             	mov    0x8(%ebp),%eax
f011f67c:	8a 00                	mov    (%eax),%al
f011f67e:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011f681:	75 05                	jne    f011f688 <strchr+0x1d>
			return (char *) s;
f011f683:	8b 45 08             	mov    0x8(%ebp),%eax
f011f686:	eb 11                	jmp    f011f699 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011f688:	ff 45 08             	incl   0x8(%ebp)
f011f68b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f68e:	8a 00                	mov    (%eax),%al
f011f690:	84 c0                	test   %al,%al
f011f692:	75 e5                	jne    f011f679 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011f694:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f699:	c9                   	leave  
f011f69a:	c3                   	ret    

f011f69b <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011f69b:	55                   	push   %ebp
f011f69c:	89 e5                	mov    %esp,%ebp
f011f69e:	83 ec 04             	sub    $0x4,%esp
f011f6a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f6a4:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011f6a7:	eb 0d                	jmp    f011f6b6 <strfind+0x1b>
		if (*s == c)
f011f6a9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6ac:	8a 00                	mov    (%eax),%al
f011f6ae:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011f6b1:	74 0e                	je     f011f6c1 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011f6b3:	ff 45 08             	incl   0x8(%ebp)
f011f6b6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6b9:	8a 00                	mov    (%eax),%al
f011f6bb:	84 c0                	test   %al,%al
f011f6bd:	75 ea                	jne    f011f6a9 <strfind+0xe>
f011f6bf:	eb 01                	jmp    f011f6c2 <strfind+0x27>
		if (*s == c)
			break;
f011f6c1:	90                   	nop
	return (char *) s;
f011f6c2:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f6c5:	c9                   	leave  
f011f6c6:	c3                   	ret    

f011f6c7 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011f6c7:	55                   	push   %ebp
f011f6c8:	89 e5                	mov    %esp,%ebp
f011f6ca:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011f6cd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011f6d3:	8b 45 10             	mov    0x10(%ebp),%eax
f011f6d6:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011f6d9:	eb 0e                	jmp    f011f6e9 <memset+0x22>
		*p++ = c;
f011f6db:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f6de:	8d 50 01             	lea    0x1(%eax),%edx
f011f6e1:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011f6e4:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f6e7:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011f6e9:	ff 4d f8             	decl   -0x8(%ebp)
f011f6ec:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011f6f0:	79 e9                	jns    f011f6db <memset+0x14>
		*p++ = c;

	return v;
f011f6f2:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f6f5:	c9                   	leave  
f011f6f6:	c3                   	ret    

f011f6f7 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011f6f7:	55                   	push   %ebp
f011f6f8:	89 e5                	mov    %esp,%ebp
f011f6fa:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011f6fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f700:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011f703:	8b 45 08             	mov    0x8(%ebp),%eax
f011f706:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011f709:	eb 16                	jmp    f011f721 <memcpy+0x2a>
		*d++ = *s++;
f011f70b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f70e:	8d 50 01             	lea    0x1(%eax),%edx
f011f711:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011f714:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f717:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f71a:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011f71d:	8a 12                	mov    (%edx),%dl
f011f71f:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011f721:	8b 45 10             	mov    0x10(%ebp),%eax
f011f724:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f727:	89 55 10             	mov    %edx,0x10(%ebp)
f011f72a:	85 c0                	test   %eax,%eax
f011f72c:	75 dd                	jne    f011f70b <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011f72e:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f731:	c9                   	leave  
f011f732:	c3                   	ret    

f011f733 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011f733:	55                   	push   %ebp
f011f734:	89 e5                	mov    %esp,%ebp
f011f736:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011f739:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f73c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011f73f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f742:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011f745:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f748:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011f74b:	73 50                	jae    f011f79d <memmove+0x6a>
f011f74d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f750:	8b 45 10             	mov    0x10(%ebp),%eax
f011f753:	01 d0                	add    %edx,%eax
f011f755:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011f758:	76 43                	jbe    f011f79d <memmove+0x6a>
		s += n;
f011f75a:	8b 45 10             	mov    0x10(%ebp),%eax
f011f75d:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011f760:	8b 45 10             	mov    0x10(%ebp),%eax
f011f763:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011f766:	eb 10                	jmp    f011f778 <memmove+0x45>
			*--d = *--s;
f011f768:	ff 4d f8             	decl   -0x8(%ebp)
f011f76b:	ff 4d fc             	decl   -0x4(%ebp)
f011f76e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f771:	8a 10                	mov    (%eax),%dl
f011f773:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f776:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011f778:	8b 45 10             	mov    0x10(%ebp),%eax
f011f77b:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f77e:	89 55 10             	mov    %edx,0x10(%ebp)
f011f781:	85 c0                	test   %eax,%eax
f011f783:	75 e3                	jne    f011f768 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011f785:	eb 23                	jmp    f011f7aa <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011f787:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f78a:	8d 50 01             	lea    0x1(%eax),%edx
f011f78d:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011f790:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f793:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f796:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011f799:	8a 12                	mov    (%edx),%dl
f011f79b:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011f79d:	8b 45 10             	mov    0x10(%ebp),%eax
f011f7a0:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f7a3:	89 55 10             	mov    %edx,0x10(%ebp)
f011f7a6:	85 c0                	test   %eax,%eax
f011f7a8:	75 dd                	jne    f011f787 <memmove+0x54>
			*d++ = *s++;

	return dst;
f011f7aa:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f7ad:	c9                   	leave  
f011f7ae:	c3                   	ret    

f011f7af <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011f7af:	55                   	push   %ebp
f011f7b0:	89 e5                	mov    %esp,%ebp
f011f7b2:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011f7b5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011f7bb:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f7be:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011f7c1:	eb 2a                	jmp    f011f7ed <memcmp+0x3e>
		if (*s1 != *s2)
f011f7c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f7c6:	8a 10                	mov    (%eax),%dl
f011f7c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f7cb:	8a 00                	mov    (%eax),%al
f011f7cd:	38 c2                	cmp    %al,%dl
f011f7cf:	74 16                	je     f011f7e7 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011f7d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f7d4:	8a 00                	mov    (%eax),%al
f011f7d6:	0f b6 d0             	movzbl %al,%edx
f011f7d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f7dc:	8a 00                	mov    (%eax),%al
f011f7de:	0f b6 c0             	movzbl %al,%eax
f011f7e1:	29 c2                	sub    %eax,%edx
f011f7e3:	89 d0                	mov    %edx,%eax
f011f7e5:	eb 18                	jmp    f011f7ff <memcmp+0x50>
		s1++, s2++;
f011f7e7:	ff 45 fc             	incl   -0x4(%ebp)
f011f7ea:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011f7ed:	8b 45 10             	mov    0x10(%ebp),%eax
f011f7f0:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f7f3:	89 55 10             	mov    %edx,0x10(%ebp)
f011f7f6:	85 c0                	test   %eax,%eax
f011f7f8:	75 c9                	jne    f011f7c3 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011f7fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f7ff:	c9                   	leave  
f011f800:	c3                   	ret    

f011f801 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011f801:	55                   	push   %ebp
f011f802:	89 e5                	mov    %esp,%ebp
f011f804:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011f807:	8b 55 08             	mov    0x8(%ebp),%edx
f011f80a:	8b 45 10             	mov    0x10(%ebp),%eax
f011f80d:	01 d0                	add    %edx,%eax
f011f80f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011f812:	eb 15                	jmp    f011f829 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011f814:	8b 45 08             	mov    0x8(%ebp),%eax
f011f817:	8a 00                	mov    (%eax),%al
f011f819:	0f b6 d0             	movzbl %al,%edx
f011f81c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f81f:	0f b6 c0             	movzbl %al,%eax
f011f822:	39 c2                	cmp    %eax,%edx
f011f824:	74 0d                	je     f011f833 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011f826:	ff 45 08             	incl   0x8(%ebp)
f011f829:	8b 45 08             	mov    0x8(%ebp),%eax
f011f82c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011f82f:	72 e3                	jb     f011f814 <memfind+0x13>
f011f831:	eb 01                	jmp    f011f834 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011f833:	90                   	nop
	return (void *) s;
f011f834:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f837:	c9                   	leave  
f011f838:	c3                   	ret    

f011f839 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011f839:	55                   	push   %ebp
f011f83a:	89 e5                	mov    %esp,%ebp
f011f83c:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011f83f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011f846:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011f84d:	eb 03                	jmp    f011f852 <strtol+0x19>
		s++;
f011f84f:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011f852:	8b 45 08             	mov    0x8(%ebp),%eax
f011f855:	8a 00                	mov    (%eax),%al
f011f857:	3c 20                	cmp    $0x20,%al
f011f859:	74 f4                	je     f011f84f <strtol+0x16>
f011f85b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f85e:	8a 00                	mov    (%eax),%al
f011f860:	3c 09                	cmp    $0x9,%al
f011f862:	74 eb                	je     f011f84f <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011f864:	8b 45 08             	mov    0x8(%ebp),%eax
f011f867:	8a 00                	mov    (%eax),%al
f011f869:	3c 2b                	cmp    $0x2b,%al
f011f86b:	75 05                	jne    f011f872 <strtol+0x39>
		s++;
f011f86d:	ff 45 08             	incl   0x8(%ebp)
f011f870:	eb 13                	jmp    f011f885 <strtol+0x4c>
	else if (*s == '-')
f011f872:	8b 45 08             	mov    0x8(%ebp),%eax
f011f875:	8a 00                	mov    (%eax),%al
f011f877:	3c 2d                	cmp    $0x2d,%al
f011f879:	75 0a                	jne    f011f885 <strtol+0x4c>
		s++, neg = 1;
f011f87b:	ff 45 08             	incl   0x8(%ebp)
f011f87e:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011f885:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f889:	74 06                	je     f011f891 <strtol+0x58>
f011f88b:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011f88f:	75 20                	jne    f011f8b1 <strtol+0x78>
f011f891:	8b 45 08             	mov    0x8(%ebp),%eax
f011f894:	8a 00                	mov    (%eax),%al
f011f896:	3c 30                	cmp    $0x30,%al
f011f898:	75 17                	jne    f011f8b1 <strtol+0x78>
f011f89a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f89d:	40                   	inc    %eax
f011f89e:	8a 00                	mov    (%eax),%al
f011f8a0:	3c 78                	cmp    $0x78,%al
f011f8a2:	75 0d                	jne    f011f8b1 <strtol+0x78>
		s += 2, base = 16;
f011f8a4:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011f8a8:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011f8af:	eb 28                	jmp    f011f8d9 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011f8b1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f8b5:	75 15                	jne    f011f8cc <strtol+0x93>
f011f8b7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8ba:	8a 00                	mov    (%eax),%al
f011f8bc:	3c 30                	cmp    $0x30,%al
f011f8be:	75 0c                	jne    f011f8cc <strtol+0x93>
		s++, base = 8;
f011f8c0:	ff 45 08             	incl   0x8(%ebp)
f011f8c3:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011f8ca:	eb 0d                	jmp    f011f8d9 <strtol+0xa0>
	else if (base == 0)
f011f8cc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f8d0:	75 07                	jne    f011f8d9 <strtol+0xa0>
		base = 10;
f011f8d2:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011f8d9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8dc:	8a 00                	mov    (%eax),%al
f011f8de:	3c 2f                	cmp    $0x2f,%al
f011f8e0:	7e 19                	jle    f011f8fb <strtol+0xc2>
f011f8e2:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8e5:	8a 00                	mov    (%eax),%al
f011f8e7:	3c 39                	cmp    $0x39,%al
f011f8e9:	7f 10                	jg     f011f8fb <strtol+0xc2>
			dig = *s - '0';
f011f8eb:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8ee:	8a 00                	mov    (%eax),%al
f011f8f0:	0f be c0             	movsbl %al,%eax
f011f8f3:	83 e8 30             	sub    $0x30,%eax
f011f8f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f8f9:	eb 42                	jmp    f011f93d <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011f8fb:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8fe:	8a 00                	mov    (%eax),%al
f011f900:	3c 60                	cmp    $0x60,%al
f011f902:	7e 19                	jle    f011f91d <strtol+0xe4>
f011f904:	8b 45 08             	mov    0x8(%ebp),%eax
f011f907:	8a 00                	mov    (%eax),%al
f011f909:	3c 7a                	cmp    $0x7a,%al
f011f90b:	7f 10                	jg     f011f91d <strtol+0xe4>
			dig = *s - 'a' + 10;
f011f90d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f910:	8a 00                	mov    (%eax),%al
f011f912:	0f be c0             	movsbl %al,%eax
f011f915:	83 e8 57             	sub    $0x57,%eax
f011f918:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f91b:	eb 20                	jmp    f011f93d <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f011f91d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f920:	8a 00                	mov    (%eax),%al
f011f922:	3c 40                	cmp    $0x40,%al
f011f924:	7e 39                	jle    f011f95f <strtol+0x126>
f011f926:	8b 45 08             	mov    0x8(%ebp),%eax
f011f929:	8a 00                	mov    (%eax),%al
f011f92b:	3c 5a                	cmp    $0x5a,%al
f011f92d:	7f 30                	jg     f011f95f <strtol+0x126>
			dig = *s - 'A' + 10;
f011f92f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f932:	8a 00                	mov    (%eax),%al
f011f934:	0f be c0             	movsbl %al,%eax
f011f937:	83 e8 37             	sub    $0x37,%eax
f011f93a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f011f93d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f940:	3b 45 10             	cmp    0x10(%ebp),%eax
f011f943:	7d 19                	jge    f011f95e <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f011f945:	ff 45 08             	incl   0x8(%ebp)
f011f948:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f94b:	0f af 45 10          	imul   0x10(%ebp),%eax
f011f94f:	89 c2                	mov    %eax,%edx
f011f951:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f954:	01 d0                	add    %edx,%eax
f011f956:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f011f959:	e9 7b ff ff ff       	jmp    f011f8d9 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f011f95e:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f011f95f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f963:	74 08                	je     f011f96d <strtol+0x134>
		*endptr = (char *) s;
f011f965:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f968:	8b 55 08             	mov    0x8(%ebp),%edx
f011f96b:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f011f96d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011f971:	74 07                	je     f011f97a <strtol+0x141>
f011f973:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f976:	f7 d8                	neg    %eax
f011f978:	eb 03                	jmp    f011f97d <strtol+0x144>
f011f97a:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011f97d:	c9                   	leave  
f011f97e:	c3                   	ret    

f011f97f <ltostr>:

void
ltostr(long value, char *str)
{
f011f97f:	55                   	push   %ebp
f011f980:	89 e5                	mov    %esp,%ebp
f011f982:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f011f985:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f011f98c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f011f993:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f997:	79 13                	jns    f011f9ac <ltostr+0x2d>
	{
		neg = 1;
f011f999:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f011f9a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f9a3:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f011f9a6:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f011f9a9:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f011f9ac:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9af:	b9 0a 00 00 00       	mov    $0xa,%ecx
f011f9b4:	99                   	cltd   
f011f9b5:	f7 f9                	idiv   %ecx
f011f9b7:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f011f9ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f9bd:	8d 50 01             	lea    0x1(%eax),%edx
f011f9c0:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011f9c3:	89 c2                	mov    %eax,%edx
f011f9c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f9c8:	01 d0                	add    %edx,%eax
f011f9ca:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f9cd:	83 c2 30             	add    $0x30,%edx
f011f9d0:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f011f9d2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f011f9d5:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011f9da:	f7 e9                	imul   %ecx
f011f9dc:	c1 fa 02             	sar    $0x2,%edx
f011f9df:	89 c8                	mov    %ecx,%eax
f011f9e1:	c1 f8 1f             	sar    $0x1f,%eax
f011f9e4:	29 c2                	sub    %eax,%edx
f011f9e6:	89 d0                	mov    %edx,%eax
f011f9e8:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f011f9eb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f9ef:	75 bb                	jne    f011f9ac <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f011f9f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f011f9f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f9fb:	48                   	dec    %eax
f011f9fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f011f9ff:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011fa03:	74 3d                	je     f011fa42 <ltostr+0xc3>
		start = 1 ;
f011fa05:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f011fa0c:	eb 34                	jmp    f011fa42 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f011fa0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fa11:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa14:	01 d0                	add    %edx,%eax
f011fa16:	8a 00                	mov    (%eax),%al
f011fa18:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f011fa1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fa1e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa21:	01 c2                	add    %eax,%edx
f011fa23:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f011fa26:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa29:	01 c8                	add    %ecx,%eax
f011fa2b:	8a 00                	mov    (%eax),%al
f011fa2d:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f011fa2f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fa32:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa35:	01 c2                	add    %eax,%edx
f011fa37:	8a 45 eb             	mov    -0x15(%ebp),%al
f011fa3a:	88 02                	mov    %al,(%edx)
		start++ ;
f011fa3c:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f011fa3f:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f011fa42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa45:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011fa48:	7c c4                	jl     f011fa0e <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f011fa4a:	8b 55 f8             	mov    -0x8(%ebp),%edx
f011fa4d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa50:	01 d0                	add    %edx,%eax
f011fa52:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f011fa55:	90                   	nop
f011fa56:	c9                   	leave  
f011fa57:	c3                   	ret    

f011fa58 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f011fa58:	55                   	push   %ebp
f011fa59:	89 e5                	mov    %esp,%ebp
f011fa5b:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f011fa5e:	ff 75 08             	pushl  0x8(%ebp)
f011fa61:	e8 73 fa ff ff       	call   f011f4d9 <strlen>
f011fa66:	83 c4 04             	add    $0x4,%esp
f011fa69:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f011fa6c:	ff 75 0c             	pushl  0xc(%ebp)
f011fa6f:	e8 65 fa ff ff       	call   f011f4d9 <strlen>
f011fa74:	83 c4 04             	add    $0x4,%esp
f011fa77:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f011fa7a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f011fa81:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fa88:	eb 17                	jmp    f011faa1 <strcconcat+0x49>
		final[s] = str1[s] ;
f011fa8a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fa8d:	8b 45 10             	mov    0x10(%ebp),%eax
f011fa90:	01 c2                	add    %eax,%edx
f011fa92:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011fa95:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa98:	01 c8                	add    %ecx,%eax
f011fa9a:	8a 00                	mov    (%eax),%al
f011fa9c:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f011fa9e:	ff 45 fc             	incl   -0x4(%ebp)
f011faa1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011faa4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011faa7:	7c e1                	jl     f011fa8a <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f011faa9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f011fab0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f011fab7:	eb 1f                	jmp    f011fad8 <strcconcat+0x80>
		final[s++] = str2[i] ;
f011fab9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fabc:	8d 50 01             	lea    0x1(%eax),%edx
f011fabf:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011fac2:	89 c2                	mov    %eax,%edx
f011fac4:	8b 45 10             	mov    0x10(%ebp),%eax
f011fac7:	01 c2                	add    %eax,%edx
f011fac9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011facc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011facf:	01 c8                	add    %ecx,%eax
f011fad1:	8a 00                	mov    (%eax),%al
f011fad3:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f011fad5:	ff 45 f8             	incl   -0x8(%ebp)
f011fad8:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fadb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011fade:	7c d9                	jl     f011fab9 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f011fae0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fae3:	8b 45 10             	mov    0x10(%ebp),%eax
f011fae6:	01 d0                	add    %edx,%eax
f011fae8:	c6 00 00             	movb   $0x0,(%eax)
}
f011faeb:	90                   	nop
f011faec:	c9                   	leave  
f011faed:	c3                   	ret    

f011faee <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f011faee:	55                   	push   %ebp
f011faef:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f011faf1:	8b 45 14             	mov    0x14(%ebp),%eax
f011faf4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f011fafa:	8b 45 14             	mov    0x14(%ebp),%eax
f011fafd:	8b 00                	mov    (%eax),%eax
f011faff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fb06:	8b 45 10             	mov    0x10(%ebp),%eax
f011fb09:	01 d0                	add    %edx,%eax
f011fb0b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011fb11:	eb 0c                	jmp    f011fb1f <strsplit+0x31>
			*string++ = 0;
f011fb13:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb16:	8d 50 01             	lea    0x1(%eax),%edx
f011fb19:	89 55 08             	mov    %edx,0x8(%ebp)
f011fb1c:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011fb1f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb22:	8a 00                	mov    (%eax),%al
f011fb24:	84 c0                	test   %al,%al
f011fb26:	74 18                	je     f011fb40 <strsplit+0x52>
f011fb28:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb2b:	8a 00                	mov    (%eax),%al
f011fb2d:	0f be c0             	movsbl %al,%eax
f011fb30:	50                   	push   %eax
f011fb31:	ff 75 0c             	pushl  0xc(%ebp)
f011fb34:	e8 32 fb ff ff       	call   f011f66b <strchr>
f011fb39:	83 c4 08             	add    $0x8,%esp
f011fb3c:	85 c0                	test   %eax,%eax
f011fb3e:	75 d3                	jne    f011fb13 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f011fb40:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb43:	8a 00                	mov    (%eax),%al
f011fb45:	84 c0                	test   %al,%al
f011fb47:	74 5a                	je     f011fba3 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f011fb49:	8b 45 14             	mov    0x14(%ebp),%eax
f011fb4c:	8b 00                	mov    (%eax),%eax
f011fb4e:	83 f8 0f             	cmp    $0xf,%eax
f011fb51:	75 07                	jne    f011fb5a <strsplit+0x6c>
		{
			return 0;
f011fb53:	b8 00 00 00 00       	mov    $0x0,%eax
f011fb58:	eb 66                	jmp    f011fbc0 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f011fb5a:	8b 45 14             	mov    0x14(%ebp),%eax
f011fb5d:	8b 00                	mov    (%eax),%eax
f011fb5f:	8d 48 01             	lea    0x1(%eax),%ecx
f011fb62:	8b 55 14             	mov    0x14(%ebp),%edx
f011fb65:	89 0a                	mov    %ecx,(%edx)
f011fb67:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fb6e:	8b 45 10             	mov    0x10(%ebp),%eax
f011fb71:	01 c2                	add    %eax,%edx
f011fb73:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb76:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f011fb78:	eb 03                	jmp    f011fb7d <strsplit+0x8f>
			string++;
f011fb7a:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f011fb7d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb80:	8a 00                	mov    (%eax),%al
f011fb82:	84 c0                	test   %al,%al
f011fb84:	74 8b                	je     f011fb11 <strsplit+0x23>
f011fb86:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb89:	8a 00                	mov    (%eax),%al
f011fb8b:	0f be c0             	movsbl %al,%eax
f011fb8e:	50                   	push   %eax
f011fb8f:	ff 75 0c             	pushl  0xc(%ebp)
f011fb92:	e8 d4 fa ff ff       	call   f011f66b <strchr>
f011fb97:	83 c4 08             	add    $0x8,%esp
f011fb9a:	85 c0                	test   %eax,%eax
f011fb9c:	74 dc                	je     f011fb7a <strsplit+0x8c>
			string++;
	}
f011fb9e:	e9 6e ff ff ff       	jmp    f011fb11 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f011fba3:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f011fba4:	8b 45 14             	mov    0x14(%ebp),%eax
f011fba7:	8b 00                	mov    (%eax),%eax
f011fba9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fbb0:	8b 45 10             	mov    0x10(%ebp),%eax
f011fbb3:	01 d0                	add    %edx,%eax
f011fbb5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f011fbbb:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011fbc0:	c9                   	leave  
f011fbc1:	c3                   	ret    

f011fbc2 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f011fbc2:	55                   	push   %ebp
f011fbc3:	89 e5                	mov    %esp,%ebp
f011fbc5:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f011fbc8:	83 ec 04             	sub    $0x4,%esp
f011fbcb:	68 fc 0b 13 f0       	push   $0xf0130bfc
f011fbd0:	68 3f 01 00 00       	push   $0x13f
f011fbd5:	68 1e 0c 13 f0       	push   $0xf0130c1e
f011fbda:	e8 5a 07 fe ff       	call   f0100339 <_panic>

f011fbdf <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f011fbdf:	55                   	push   %ebp
f011fbe0:	89 e5                	mov    %esp,%ebp
f011fbe2:	83 ec 18             	sub    $0x18,%esp
f011fbe5:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011fbec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fbef:	89 c2                	mov    %eax,%edx
f011fbf1:	ec                   	in     (%dx),%al
f011fbf2:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011fbf5:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011fbf8:	0f b6 c0             	movzbl %al,%eax
f011fbfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fbfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc01:	25 c0 00 00 00       	and    $0xc0,%eax
f011fc06:	83 f8 40             	cmp    $0x40,%eax
f011fc09:	75 10                	jne    f011fc1b <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f011fc0b:	83 ec 0c             	sub    $0xc,%esp
f011fc0e:	68 c0 b1 6b f0       	push   $0xf06bb1c0
f011fc13:	e8 5a fd fe ff       	call   f010f972 <wakeup_one>
f011fc18:	83 c4 10             	add    $0x10,%esp
	}

}
f011fc1b:	90                   	nop
f011fc1c:	c9                   	leave  
f011fc1d:	c3                   	ret    

f011fc1e <ide_init>:

void ide_init()
{
f011fc1e:	55                   	push   %ebp
f011fc1f:	89 e5                	mov    %esp,%ebp
f011fc21:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f011fc24:	83 ec 08             	sub    $0x8,%esp
f011fc27:	68 df fb 11 f0       	push   $0xf011fbdf
f011fc2c:	6a 0e                	push   $0xe
f011fc2e:	e8 f0 de fe ff       	call   f010db23 <irq_install_handler>
f011fc33:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f011fc36:	83 ec 08             	sub    $0x8,%esp
f011fc39:	68 2c 0c 13 f0       	push   $0xf0130c2c
f011fc3e:	68 c0 b1 6b f0       	push   $0xf06bb1c0
f011fc43:	e8 90 fc fe ff       	call   f010f8d8 <init_channel>
f011fc48:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f011fc4b:	83 ec 08             	sub    $0x8,%esp
f011fc4e:	68 39 0c 13 f0       	push   $0xf0130c39
f011fc53:	68 e0 b7 6b f0       	push   $0xf06bb7e0
f011fc58:	e8 8a f8 fe ff       	call   f010f4e7 <init_spinlock>
f011fc5d:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f011fc60:	90                   	nop
f011fc61:	c9                   	leave  
f011fc62:	c3                   	ret    

f011fc63 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f011fc63:	55                   	push   %ebp
f011fc64:	89 e5                	mov    %esp,%ebp
f011fc66:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011fc69:	90                   	nop
f011fc6a:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011fc71:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fc74:	89 c2                	mov    %eax,%edx
f011fc76:	ec                   	in     (%dx),%al
f011fc77:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011fc7a:	8a 45 ef             	mov    -0x11(%ebp),%al
f011fc7d:	0f b6 c0             	movzbl %al,%eax
f011fc80:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fc83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc86:	25 c0 00 00 00       	and    $0xc0,%eax
f011fc8b:	83 f8 40             	cmp    $0x40,%eax
f011fc8e:	75 da                	jne    f011fc6a <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f011fc90:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fc94:	74 24                	je     f011fcba <ide_wait_ready+0x57>
f011fc96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc99:	83 e0 21             	and    $0x21,%eax
f011fc9c:	85 c0                	test   %eax,%eax
f011fc9e:	74 1a                	je     f011fcba <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f011fca0:	83 ec 0c             	sub    $0xc,%esp
f011fca3:	ff 75 f4             	pushl  -0xc(%ebp)
f011fca6:	ff 75 f4             	pushl  -0xc(%ebp)
f011fca9:	68 4c 0c 13 f0       	push   $0xf0130c4c
f011fcae:	6a 5d                	push   $0x5d
f011fcb0:	68 6f 0c 13 f0       	push   $0xf0130c6f
f011fcb5:	e8 7f 06 fe ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f011fcba:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fcbf:	c9                   	leave  
f011fcc0:	c3                   	ret    

f011fcc1 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f011fcc1:	55                   	push   %ebp
f011fcc2:	89 e5                	mov    %esp,%ebp
f011fcc4:	57                   	push   %edi
f011fcc5:	53                   	push   %ebx
f011fcc6:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f011fcc9:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011fcd0:	76 16                	jbe    f011fce8 <ide_read+0x27>
f011fcd2:	68 7a 0c 13 f0       	push   $0xf0130c7a
f011fcd7:	68 87 0c 13 f0       	push   $0xf0130c87
f011fcdc:	6a 68                	push   $0x68
f011fcde:	68 6f 0c 13 f0       	push   $0xf0130c6f
f011fce3:	e8 51 06 fe ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f011fce8:	83 ec 0c             	sub    $0xc,%esp
f011fceb:	6a 00                	push   $0x0
f011fced:	e8 71 ff ff ff       	call   f011fc63 <ide_wait_ready>
f011fcf2:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f011fcf5:	8b 45 10             	mov    0x10(%ebp),%eax
f011fcf8:	0f b6 c0             	movzbl %al,%eax
f011fcfb:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011fd02:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011fd05:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011fd08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fd0b:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011fd0c:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd0f:	0f b6 c0             	movzbl %al,%eax
f011fd12:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011fd19:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011fd1c:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011fd1f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fd22:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011fd23:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd26:	c1 e8 08             	shr    $0x8,%eax
f011fd29:	0f b6 c0             	movzbl %al,%eax
f011fd2c:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011fd33:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011fd36:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011fd39:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011fd3c:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011fd3d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd40:	c1 e8 10             	shr    $0x10,%eax
f011fd43:	0f b6 c0             	movzbl %al,%eax
f011fd46:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011fd4d:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011fd50:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011fd53:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011fd56:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011fd57:	a1 70 b0 6b f0       	mov    0xf06bb070,%eax
f011fd5c:	83 e0 01             	and    $0x1,%eax
f011fd5f:	c1 e0 04             	shl    $0x4,%eax
f011fd62:	88 c2                	mov    %al,%dl
f011fd64:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd67:	c1 e8 18             	shr    $0x18,%eax
f011fd6a:	83 e0 0f             	and    $0xf,%eax
f011fd6d:	09 d0                	or     %edx,%eax
f011fd6f:	83 c8 e0             	or     $0xffffffe0,%eax
f011fd72:	0f b6 c0             	movzbl %al,%eax
f011fd75:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011fd7c:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011fd7f:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011fd82:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011fd85:	ee                   	out    %al,(%dx)
f011fd86:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011fd8d:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f011fd91:	8a 45 d7             	mov    -0x29(%ebp),%al
f011fd94:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011fd97:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011fd98:	eb 55                	jmp    f011fdef <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f011fd9a:	83 ec 0c             	sub    $0xc,%esp
f011fd9d:	6a 01                	push   $0x1
f011fd9f:	e8 bf fe ff ff       	call   f011fc63 <ide_wait_ready>
f011fda4:	83 c4 10             	add    $0x10,%esp
f011fda7:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011fdaa:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011fdae:	79 05                	jns    f011fdb5 <ide_read+0xf4>
			return r;
f011fdb0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fdb3:	eb 45                	jmp    f011fdfa <ide_read+0x139>
f011fdb5:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011fdbc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fdbf:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011fdc2:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f011fdc9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fdcc:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011fdcf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fdd2:	89 cb                	mov    %ecx,%ebx
f011fdd4:	89 df                	mov    %ebx,%edi
f011fdd6:	89 c1                	mov    %eax,%ecx
f011fdd8:	fc                   	cld    
f011fdd9:	f2 6d                	repnz insl (%dx),%es:(%edi)
f011fddb:	89 c8                	mov    %ecx,%eax
f011fddd:	89 fb                	mov    %edi,%ebx
f011fddf:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011fde2:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011fde5:	ff 4d 10             	decl   0x10(%ebp)
f011fde8:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011fdef:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fdf3:	75 a5                	jne    f011fd9a <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f011fdf5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fdfa:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011fdfd:	5b                   	pop    %ebx
f011fdfe:	5f                   	pop    %edi
f011fdff:	5d                   	pop    %ebp
f011fe00:	c3                   	ret    

f011fe01 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f011fe01:	55                   	push   %ebp
f011fe02:	89 e5                	mov    %esp,%ebp
f011fe04:	56                   	push   %esi
f011fe05:	53                   	push   %ebx
f011fe06:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f011fe09:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011fe10:	76 19                	jbe    f011fe2b <ide_write+0x2a>
f011fe12:	68 7a 0c 13 f0       	push   $0xf0130c7a
f011fe17:	68 87 0c 13 f0       	push   $0xf0130c87
f011fe1c:	68 82 00 00 00       	push   $0x82
f011fe21:	68 6f 0c 13 f0       	push   $0xf0130c6f
f011fe26:	e8 0e 05 fe ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f011fe2b:	83 ec 0c             	sub    $0xc,%esp
f011fe2e:	6a 00                	push   $0x0
f011fe30:	e8 2e fe ff ff       	call   f011fc63 <ide_wait_ready>
f011fe35:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f011fe38:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe3b:	0f b6 c0             	movzbl %al,%eax
f011fe3e:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011fe45:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011fe48:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011fe4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fe4e:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011fe4f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe52:	0f b6 c0             	movzbl %al,%eax
f011fe55:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011fe5c:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011fe5f:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011fe62:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fe65:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011fe66:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe69:	c1 e8 08             	shr    $0x8,%eax
f011fe6c:	0f b6 c0             	movzbl %al,%eax
f011fe6f:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011fe76:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011fe79:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011fe7c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011fe7f:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011fe80:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe83:	c1 e8 10             	shr    $0x10,%eax
f011fe86:	0f b6 c0             	movzbl %al,%eax
f011fe89:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011fe90:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011fe93:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011fe96:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011fe99:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011fe9a:	a1 70 b0 6b f0       	mov    0xf06bb070,%eax
f011fe9f:	83 e0 01             	and    $0x1,%eax
f011fea2:	c1 e0 04             	shl    $0x4,%eax
f011fea5:	88 c2                	mov    %al,%dl
f011fea7:	8b 45 08             	mov    0x8(%ebp),%eax
f011feaa:	c1 e8 18             	shr    $0x18,%eax
f011fead:	83 e0 0f             	and    $0xf,%eax
f011feb0:	09 d0                	or     %edx,%eax
f011feb2:	83 c8 e0             	or     $0xffffffe0,%eax
f011feb5:	0f b6 c0             	movzbl %al,%eax
f011feb8:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011febf:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011fec2:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011fec5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011fec8:	ee                   	out    %al,(%dx)
f011fec9:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011fed0:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f011fed4:	8a 45 d7             	mov    -0x29(%ebp),%al
f011fed7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011feda:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011fedb:	eb 55                	jmp    f011ff32 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f011fedd:	83 ec 0c             	sub    $0xc,%esp
f011fee0:	6a 01                	push   $0x1
f011fee2:	e8 7c fd ff ff       	call   f011fc63 <ide_wait_ready>
f011fee7:	83 c4 10             	add    $0x10,%esp
f011feea:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011feed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011fef1:	79 05                	jns    f011fef8 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f011fef3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fef6:	eb 45                	jmp    f011ff3d <ide_write+0x13c>
f011fef8:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011feff:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff02:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011ff05:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f011ff0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ff0f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011ff12:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ff15:	89 cb                	mov    %ecx,%ebx
f011ff17:	89 de                	mov    %ebx,%esi
f011ff19:	89 c1                	mov    %eax,%ecx
f011ff1b:	fc                   	cld    
f011ff1c:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f011ff1e:	89 c8                	mov    %ecx,%eax
f011ff20:	89 f3                	mov    %esi,%ebx
f011ff22:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011ff25:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011ff28:	ff 4d 10             	decl   0x10(%ebp)
f011ff2b:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011ff32:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ff36:	75 a5                	jne    f011fedd <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f011ff38:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ff3d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011ff40:	5b                   	pop    %ebx
f011ff41:	5e                   	pop    %esi
f011ff42:	5d                   	pop    %ebp
f011ff43:	c3                   	ret    

f011ff44 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f011ff44:	55                   	push   %ebp
f011ff45:	89 e5                	mov    %esp,%ebp
f011ff47:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f011ff4a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff4d:	83 e8 04             	sub    $0x4,%eax
f011ff50:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f011ff53:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff56:	8b 00                	mov    (%eax),%eax
f011ff58:	83 e0 fe             	and    $0xfffffffe,%eax
}
f011ff5b:	c9                   	leave  
f011ff5c:	c3                   	ret    

f011ff5d <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f011ff5d:	55                   	push   %ebp
f011ff5e:	89 e5                	mov    %esp,%ebp
f011ff60:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f011ff63:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff66:	83 e8 04             	sub    $0x4,%eax
f011ff69:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f011ff6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff6f:	8b 00                	mov    (%eax),%eax
f011ff71:	83 e0 01             	and    $0x1,%eax
f011ff74:	85 c0                	test   %eax,%eax
f011ff76:	0f 94 c0             	sete   %al
}
f011ff79:	c9                   	leave  
f011ff7a:	c3                   	ret    

f011ff7b <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f011ff7b:	55                   	push   %ebp
f011ff7c:	89 e5                	mov    %esp,%ebp
f011ff7e:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f011ff81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f011ff88:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff8b:	83 f8 02             	cmp    $0x2,%eax
f011ff8e:	74 2b                	je     f011ffbb <alloc_block+0x40>
f011ff90:	83 f8 02             	cmp    $0x2,%eax
f011ff93:	7f 07                	jg     f011ff9c <alloc_block+0x21>
f011ff95:	83 f8 01             	cmp    $0x1,%eax
f011ff98:	74 0e                	je     f011ffa8 <alloc_block+0x2d>
f011ff9a:	eb 58                	jmp    f011fff4 <alloc_block+0x79>
f011ff9c:	83 f8 03             	cmp    $0x3,%eax
f011ff9f:	74 2d                	je     f011ffce <alloc_block+0x53>
f011ffa1:	83 f8 04             	cmp    $0x4,%eax
f011ffa4:	74 3b                	je     f011ffe1 <alloc_block+0x66>
f011ffa6:	eb 4c                	jmp    f011fff4 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f011ffa8:	83 ec 0c             	sub    $0xc,%esp
f011ffab:	ff 75 08             	pushl  0x8(%ebp)
f011ffae:	e8 11 03 00 00       	call   f01202c4 <alloc_block_FF>
f011ffb3:	83 c4 10             	add    $0x10,%esp
f011ffb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011ffb9:	eb 4a                	jmp    f0120005 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f011ffbb:	83 ec 0c             	sub    $0xc,%esp
f011ffbe:	ff 75 08             	pushl  0x8(%ebp)
f011ffc1:	e8 fa 19 00 00       	call   f01219c0 <alloc_block_NF>
f011ffc6:	83 c4 10             	add    $0x10,%esp
f011ffc9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011ffcc:	eb 37                	jmp    f0120005 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f011ffce:	83 ec 0c             	sub    $0xc,%esp
f011ffd1:	ff 75 08             	pushl  0x8(%ebp)
f011ffd4:	e8 a7 07 00 00       	call   f0120780 <alloc_block_BF>
f011ffd9:	83 c4 10             	add    $0x10,%esp
f011ffdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011ffdf:	eb 24                	jmp    f0120005 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f011ffe1:	83 ec 0c             	sub    $0xc,%esp
f011ffe4:	ff 75 08             	pushl  0x8(%ebp)
f011ffe7:	e8 b7 19 00 00       	call   f01219a3 <alloc_block_WF>
f011ffec:	83 c4 10             	add    $0x10,%esp
f011ffef:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011fff2:	eb 11                	jmp    f0120005 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f011fff4:	83 ec 0c             	sub    $0xc,%esp
f011fff7:	68 9c 0c 13 f0       	push   $0xf0130c9c
f011fffc:	e8 8a 0f fe ff       	call   f0100f8b <cprintf>
f0120001:	83 c4 10             	add    $0x10,%esp
		break;
f0120004:	90                   	nop
	}
	return va;
f0120005:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0120008:	c9                   	leave  
f0120009:	c3                   	ret    

f012000a <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f012000a:	55                   	push   %ebp
f012000b:	89 e5                	mov    %esp,%ebp
f012000d:	53                   	push   %ebx
f012000e:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f0120011:	83 ec 0c             	sub    $0xc,%esp
f0120014:	68 bc 0c 13 f0       	push   $0xf0130cbc
f0120019:	e8 6d 0f fe ff       	call   f0100f8b <cprintf>
f012001e:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f0120021:	83 ec 0c             	sub    $0xc,%esp
f0120024:	68 e7 0c 13 f0       	push   $0xf0130ce7
f0120029:	e8 5d 0f fe ff       	call   f0100f8b <cprintf>
f012002e:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f0120031:	8b 45 08             	mov    0x8(%ebp),%eax
f0120034:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120037:	eb 37                	jmp    f0120070 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0120039:	83 ec 0c             	sub    $0xc,%esp
f012003c:	ff 75 f4             	pushl  -0xc(%ebp)
f012003f:	e8 19 ff ff ff       	call   f011ff5d <is_free_block>
f0120044:	83 c4 10             	add    $0x10,%esp
f0120047:	0f be d8             	movsbl %al,%ebx
f012004a:	83 ec 0c             	sub    $0xc,%esp
f012004d:	ff 75 f4             	pushl  -0xc(%ebp)
f0120050:	e8 ef fe ff ff       	call   f011ff44 <get_block_size>
f0120055:	83 c4 10             	add    $0x10,%esp
f0120058:	83 ec 04             	sub    $0x4,%esp
f012005b:	53                   	push   %ebx
f012005c:	50                   	push   %eax
f012005d:	68 ff 0c 13 f0       	push   $0xf0130cff
f0120062:	e8 24 0f fe ff       	call   f0100f8b <cprintf>
f0120067:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f012006a:	8b 45 10             	mov    0x10(%ebp),%eax
f012006d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120070:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120074:	74 07                	je     f012007d <print_blocks_list+0x73>
f0120076:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120079:	8b 00                	mov    (%eax),%eax
f012007b:	eb 05                	jmp    f0120082 <print_blocks_list+0x78>
f012007d:	b8 00 00 00 00       	mov    $0x0,%eax
f0120082:	89 45 10             	mov    %eax,0x10(%ebp)
f0120085:	8b 45 10             	mov    0x10(%ebp),%eax
f0120088:	85 c0                	test   %eax,%eax
f012008a:	75 ad                	jne    f0120039 <print_blocks_list+0x2f>
f012008c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120090:	75 a7                	jne    f0120039 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f0120092:	83 ec 0c             	sub    $0xc,%esp
f0120095:	68 bc 0c 13 f0       	push   $0xf0130cbc
f012009a:	e8 ec 0e fe ff       	call   f0100f8b <cprintf>
f012009f:	83 c4 10             	add    $0x10,%esp

}
f01200a2:	90                   	nop
f01200a3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01200a6:	c9                   	leave  
f01200a7:	c3                   	ret    

f01200a8 <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f01200a8:	55                   	push   %ebp
f01200a9:	89 e5                	mov    %esp,%ebp
f01200ab:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f01200ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200b1:	83 e0 01             	and    $0x1,%eax
f01200b4:	85 c0                	test   %eax,%eax
f01200b6:	74 03                	je     f01200bb <initialize_dynamic_allocator+0x13>
f01200b8:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f01200bb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01200bf:	0f 84 c7 01 00 00    	je     f012028c <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f01200c5:	c7 05 74 b0 6b f0 01 	movl   $0x1,0xf06bb074
f01200cc:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f01200cf:	8b 55 08             	mov    0x8(%ebp),%edx
f01200d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200d5:	01 d0                	add    %edx,%eax
f01200d7:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f01200dc:	0f 87 ad 01 00 00    	ja     f012028f <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f01200e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01200e5:	85 c0                	test   %eax,%eax
f01200e7:	0f 89 a5 01 00 00    	jns    f0120292 <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f01200ed:	8b 55 08             	mov    0x8(%ebp),%edx
f01200f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200f3:	01 d0                	add    %edx,%eax
f01200f5:	83 e8 04             	sub    $0x4,%eax
f01200f8:	a3 14 ba 6b f0       	mov    %eax,0xf06bba14
     struct BlockElement * element = NULL;
f01200fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f0120104:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f0120109:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012010c:	e9 87 00 00 00       	jmp    f0120198 <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f0120111:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120115:	75 14                	jne    f012012b <initialize_dynamic_allocator+0x83>
f0120117:	83 ec 04             	sub    $0x4,%esp
f012011a:	68 17 0d 13 f0       	push   $0xf0130d17
f012011f:	6a 79                	push   $0x79
f0120121:	68 35 0d 13 f0       	push   $0xf0130d35
f0120126:	e8 0e 02 fe ff       	call   f0100339 <_panic>
f012012b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012012e:	8b 00                	mov    (%eax),%eax
f0120130:	85 c0                	test   %eax,%eax
f0120132:	74 10                	je     f0120144 <initialize_dynamic_allocator+0x9c>
f0120134:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120137:	8b 00                	mov    (%eax),%eax
f0120139:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012013c:	8b 52 04             	mov    0x4(%edx),%edx
f012013f:	89 50 04             	mov    %edx,0x4(%eax)
f0120142:	eb 0b                	jmp    f012014f <initialize_dynamic_allocator+0xa7>
f0120144:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120147:	8b 40 04             	mov    0x4(%eax),%eax
f012014a:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f012014f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120152:	8b 40 04             	mov    0x4(%eax),%eax
f0120155:	85 c0                	test   %eax,%eax
f0120157:	74 0f                	je     f0120168 <initialize_dynamic_allocator+0xc0>
f0120159:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012015c:	8b 40 04             	mov    0x4(%eax),%eax
f012015f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120162:	8b 12                	mov    (%edx),%edx
f0120164:	89 10                	mov    %edx,(%eax)
f0120166:	eb 0a                	jmp    f0120172 <initialize_dynamic_allocator+0xca>
f0120168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012016b:	8b 00                	mov    (%eax),%eax
f012016d:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120172:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120175:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012017b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012017e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120185:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f012018a:	48                   	dec    %eax
f012018b:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f0120190:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f0120195:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120198:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012019c:	74 07                	je     f01201a5 <initialize_dynamic_allocator+0xfd>
f012019e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01201a1:	8b 00                	mov    (%eax),%eax
f01201a3:	eb 05                	jmp    f01201aa <initialize_dynamic_allocator+0x102>
f01201a5:	b8 00 00 00 00       	mov    $0x0,%eax
f01201aa:	a3 f8 b3 6b f0       	mov    %eax,0xf06bb3f8
f01201af:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f01201b4:	85 c0                	test   %eax,%eax
f01201b6:	0f 85 55 ff ff ff    	jne    f0120111 <initialize_dynamic_allocator+0x69>
f01201bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01201c0:	0f 85 4b ff ff ff    	jne    f0120111 <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f01201c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01201c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f01201cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01201cf:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f01201d5:	a1 14 ba 6b f0       	mov    0xf06bba14,%eax
f01201da:	a3 50 b8 6b f0       	mov    %eax,0xf06bb850
    end_block->info = 1;
f01201df:	a1 50 b8 6b f0       	mov    0xf06bb850,%eax
f01201e4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f01201ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01201ed:	83 c0 08             	add    $0x8,%eax
f01201f0:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f01201f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01201f6:	83 c0 04             	add    $0x4,%eax
f01201f9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01201fc:	83 ea 08             	sub    $0x8,%edx
f01201ff:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120201:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120204:	8b 45 08             	mov    0x8(%ebp),%eax
f0120207:	01 d0                	add    %edx,%eax
f0120209:	83 e8 08             	sub    $0x8,%eax
f012020c:	8b 55 0c             	mov    0xc(%ebp),%edx
f012020f:	83 ea 08             	sub    $0x8,%edx
f0120212:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f0120214:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120217:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f012021d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120220:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f0120227:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012022b:	75 17                	jne    f0120244 <initialize_dynamic_allocator+0x19c>
f012022d:	83 ec 04             	sub    $0x4,%esp
f0120230:	68 50 0d 13 f0       	push   $0xf0130d50
f0120235:	68 90 00 00 00       	push   $0x90
f012023a:	68 35 0d 13 f0       	push   $0xf0130d35
f012023f:	e8 f5 00 fe ff       	call   f0100339 <_panic>
f0120244:	8b 15 f0 b3 6b f0    	mov    0xf06bb3f0,%edx
f012024a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012024d:	89 10                	mov    %edx,(%eax)
f012024f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120252:	8b 00                	mov    (%eax),%eax
f0120254:	85 c0                	test   %eax,%eax
f0120256:	74 0d                	je     f0120265 <initialize_dynamic_allocator+0x1bd>
f0120258:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f012025d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120260:	89 50 04             	mov    %edx,0x4(%eax)
f0120263:	eb 08                	jmp    f012026d <initialize_dynamic_allocator+0x1c5>
f0120265:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120268:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f012026d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120270:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120275:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120278:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012027f:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120284:	40                   	inc    %eax
f0120285:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f012028a:	eb 07                	jmp    f0120293 <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f012028c:	90                   	nop
f012028d:	eb 04                	jmp    f0120293 <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f012028f:	90                   	nop
f0120290:	eb 01                	jmp    f0120293 <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f0120292:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f0120293:	c9                   	leave  
f0120294:	c3                   	ret    

f0120295 <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f0120295:	55                   	push   %ebp
f0120296:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f0120298:	8b 45 10             	mov    0x10(%ebp),%eax
f012029b:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f012029e:	8b 45 08             	mov    0x8(%ebp),%eax
f01202a1:	8d 50 fc             	lea    -0x4(%eax),%edx
f01202a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202a7:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f01202a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01202ac:	83 e8 04             	sub    $0x4,%eax
f01202af:	8b 00                	mov    (%eax),%eax
f01202b1:	83 e0 fe             	and    $0xfffffffe,%eax
f01202b4:	8d 50 f8             	lea    -0x8(%eax),%edx
f01202b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01202ba:	01 c2                	add    %eax,%edx
f01202bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202bf:	89 02                	mov    %eax,(%edx)
}
f01202c1:	90                   	nop
f01202c2:	5d                   	pop    %ebp
f01202c3:	c3                   	ret    

f01202c4 <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f01202c4:	55                   	push   %ebp
f01202c5:	89 e5                	mov    %esp,%ebp
f01202c7:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f01202ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01202cd:	83 e0 01             	and    $0x1,%eax
f01202d0:	85 c0                	test   %eax,%eax
f01202d2:	74 03                	je     f01202d7 <alloc_block_FF+0x13>
f01202d4:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f01202d7:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f01202db:	77 07                	ja     f01202e4 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f01202dd:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f01202e4:	a1 74 b0 6b f0       	mov    0xf06bb074,%eax
f01202e9:	85 c0                	test   %eax,%eax
f01202eb:	75 73                	jne    f0120360 <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f01202ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01202f0:	83 c0 10             	add    $0x10,%eax
f01202f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f01202f6:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f01202fd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120300:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120303:	01 d0                	add    %edx,%eax
f0120305:	48                   	dec    %eax
f0120306:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0120309:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012030c:	ba 00 00 00 00       	mov    $0x0,%edx
f0120311:	f7 75 ec             	divl   -0x14(%ebp)
f0120314:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120317:	29 d0                	sub    %edx,%eax
f0120319:	c1 e8 0c             	shr    $0xc,%eax
f012031c:	83 ec 0c             	sub    $0xc,%esp
f012031f:	50                   	push   %eax
f0120320:	e8 93 8c fe ff       	call   f0108fb8 <sbrk>
f0120325:	83 c4 10             	add    $0x10,%esp
f0120328:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f012032b:	83 ec 0c             	sub    $0xc,%esp
f012032e:	6a 00                	push   $0x0
f0120330:	e8 83 8c fe ff       	call   f0108fb8 <sbrk>
f0120335:	83 c4 10             	add    $0x10,%esp
f0120338:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f012033b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012033e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0120341:	83 ec 08             	sub    $0x8,%esp
f0120344:	50                   	push   %eax
f0120345:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120348:	e8 5b fd ff ff       	call   f01200a8 <initialize_dynamic_allocator>
f012034d:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120350:	83 ec 0c             	sub    $0xc,%esp
f0120353:	68 73 0d 13 f0       	push   $0xf0130d73
f0120358:	e8 2e 0c fe ff       	call   f0100f8b <cprintf>
f012035d:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0120360:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120364:	75 0a                	jne    f0120370 <alloc_block_FF+0xac>
	        return NULL;
f0120366:	b8 00 00 00 00       	mov    $0x0,%eax
f012036b:	e9 0e 04 00 00       	jmp    f012077e <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f0120370:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120377:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f012037c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012037f:	e9 f3 02 00 00       	jmp    f0120677 <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f0120384:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120387:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f012038a:	83 ec 0c             	sub    $0xc,%esp
f012038d:	ff 75 bc             	pushl  -0x44(%ebp)
f0120390:	e8 af fb ff ff       	call   f011ff44 <get_block_size>
f0120395:	83 c4 10             	add    $0x10,%esp
f0120398:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f012039b:	8b 45 08             	mov    0x8(%ebp),%eax
f012039e:	83 c0 08             	add    $0x8,%eax
f01203a1:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01203a4:	0f 87 c5 02 00 00    	ja     f012066f <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f01203aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01203ad:	83 c0 18             	add    $0x18,%eax
f01203b0:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01203b3:	0f 87 19 02 00 00    	ja     f01205d2 <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f01203b9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01203bc:	2b 45 08             	sub    0x8(%ebp),%eax
f01203bf:	83 e8 08             	sub    $0x8,%eax
f01203c2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f01203c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01203c8:	8d 50 08             	lea    0x8(%eax),%edx
f01203cb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01203ce:	01 d0                	add    %edx,%eax
f01203d0:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f01203d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01203d6:	83 c0 08             	add    $0x8,%eax
f01203d9:	83 ec 04             	sub    $0x4,%esp
f01203dc:	6a 01                	push   $0x1
f01203de:	50                   	push   %eax
f01203df:	ff 75 bc             	pushl  -0x44(%ebp)
f01203e2:	e8 ae fe ff ff       	call   f0120295 <set_block_data>
f01203e7:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f01203ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203ed:	8b 40 04             	mov    0x4(%eax),%eax
f01203f0:	85 c0                	test   %eax,%eax
f01203f2:	75 68                	jne    f012045c <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f01203f4:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f01203f8:	75 17                	jne    f0120411 <alloc_block_FF+0x14d>
f01203fa:	83 ec 04             	sub    $0x4,%esp
f01203fd:	68 50 0d 13 f0       	push   $0xf0130d50
f0120402:	68 d7 00 00 00       	push   $0xd7
f0120407:	68 35 0d 13 f0       	push   $0xf0130d35
f012040c:	e8 28 ff fd ff       	call   f0100339 <_panic>
f0120411:	8b 15 f0 b3 6b f0    	mov    0xf06bb3f0,%edx
f0120417:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012041a:	89 10                	mov    %edx,(%eax)
f012041c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012041f:	8b 00                	mov    (%eax),%eax
f0120421:	85 c0                	test   %eax,%eax
f0120423:	74 0d                	je     f0120432 <alloc_block_FF+0x16e>
f0120425:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f012042a:	8b 55 b0             	mov    -0x50(%ebp),%edx
f012042d:	89 50 04             	mov    %edx,0x4(%eax)
f0120430:	eb 08                	jmp    f012043a <alloc_block_FF+0x176>
f0120432:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120435:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f012043a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012043d:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120442:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120445:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012044c:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120451:	40                   	inc    %eax
f0120452:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f0120457:	e9 dc 00 00 00       	jmp    f0120538 <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f012045c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012045f:	8b 00                	mov    (%eax),%eax
f0120461:	85 c0                	test   %eax,%eax
f0120463:	75 65                	jne    f01204ca <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120465:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120469:	75 17                	jne    f0120482 <alloc_block_FF+0x1be>
f012046b:	83 ec 04             	sub    $0x4,%esp
f012046e:	68 84 0d 13 f0       	push   $0xf0130d84
f0120473:	68 db 00 00 00       	push   $0xdb
f0120478:	68 35 0d 13 f0       	push   $0xf0130d35
f012047d:	e8 b7 fe fd ff       	call   f0100339 <_panic>
f0120482:	8b 15 f4 b3 6b f0    	mov    0xf06bb3f4,%edx
f0120488:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012048b:	89 50 04             	mov    %edx,0x4(%eax)
f012048e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120491:	8b 40 04             	mov    0x4(%eax),%eax
f0120494:	85 c0                	test   %eax,%eax
f0120496:	74 0c                	je     f01204a4 <alloc_block_FF+0x1e0>
f0120498:	a1 f4 b3 6b f0       	mov    0xf06bb3f4,%eax
f012049d:	8b 55 b0             	mov    -0x50(%ebp),%edx
f01204a0:	89 10                	mov    %edx,(%eax)
f01204a2:	eb 08                	jmp    f01204ac <alloc_block_FF+0x1e8>
f01204a4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01204a7:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f01204ac:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01204af:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f01204b4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01204b7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01204bd:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f01204c2:	40                   	inc    %eax
f01204c3:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f01204c8:	eb 6e                	jmp    f0120538 <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f01204ca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01204ce:	74 06                	je     f01204d6 <alloc_block_FF+0x212>
f01204d0:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f01204d4:	75 17                	jne    f01204ed <alloc_block_FF+0x229>
f01204d6:	83 ec 04             	sub    $0x4,%esp
f01204d9:	68 a8 0d 13 f0       	push   $0xf0130da8
f01204de:	68 df 00 00 00       	push   $0xdf
f01204e3:	68 35 0d 13 f0       	push   $0xf0130d35
f01204e8:	e8 4c fe fd ff       	call   f0100339 <_panic>
f01204ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01204f0:	8b 10                	mov    (%eax),%edx
f01204f2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01204f5:	89 10                	mov    %edx,(%eax)
f01204f7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01204fa:	8b 00                	mov    (%eax),%eax
f01204fc:	85 c0                	test   %eax,%eax
f01204fe:	74 0b                	je     f012050b <alloc_block_FF+0x247>
f0120500:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120503:	8b 00                	mov    (%eax),%eax
f0120505:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120508:	89 50 04             	mov    %edx,0x4(%eax)
f012050b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012050e:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120511:	89 10                	mov    %edx,(%eax)
f0120513:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120516:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120519:	89 50 04             	mov    %edx,0x4(%eax)
f012051c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012051f:	8b 00                	mov    (%eax),%eax
f0120521:	85 c0                	test   %eax,%eax
f0120523:	75 08                	jne    f012052d <alloc_block_FF+0x269>
f0120525:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120528:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f012052d:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120532:	40                   	inc    %eax
f0120533:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
				}
				LIST_REMOVE(&freeBlocksList, blk);
f0120538:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012053c:	75 17                	jne    f0120555 <alloc_block_FF+0x291>
f012053e:	83 ec 04             	sub    $0x4,%esp
f0120541:	68 17 0d 13 f0       	push   $0xf0130d17
f0120546:	68 e1 00 00 00       	push   $0xe1
f012054b:	68 35 0d 13 f0       	push   $0xf0130d35
f0120550:	e8 e4 fd fd ff       	call   f0100339 <_panic>
f0120555:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120558:	8b 00                	mov    (%eax),%eax
f012055a:	85 c0                	test   %eax,%eax
f012055c:	74 10                	je     f012056e <alloc_block_FF+0x2aa>
f012055e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120561:	8b 00                	mov    (%eax),%eax
f0120563:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120566:	8b 52 04             	mov    0x4(%edx),%edx
f0120569:	89 50 04             	mov    %edx,0x4(%eax)
f012056c:	eb 0b                	jmp    f0120579 <alloc_block_FF+0x2b5>
f012056e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120571:	8b 40 04             	mov    0x4(%eax),%eax
f0120574:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0120579:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012057c:	8b 40 04             	mov    0x4(%eax),%eax
f012057f:	85 c0                	test   %eax,%eax
f0120581:	74 0f                	je     f0120592 <alloc_block_FF+0x2ce>
f0120583:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120586:	8b 40 04             	mov    0x4(%eax),%eax
f0120589:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012058c:	8b 12                	mov    (%edx),%edx
f012058e:	89 10                	mov    %edx,(%eax)
f0120590:	eb 0a                	jmp    f012059c <alloc_block_FF+0x2d8>
f0120592:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120595:	8b 00                	mov    (%eax),%eax
f0120597:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f012059c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012059f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01205a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01205a8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01205af:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f01205b4:	48                   	dec    %eax
f01205b5:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
				set_block_data(new_block_va, remaining_size, 0);
f01205ba:	83 ec 04             	sub    $0x4,%esp
f01205bd:	6a 00                	push   $0x0
f01205bf:	ff 75 b4             	pushl  -0x4c(%ebp)
f01205c2:	ff 75 b0             	pushl  -0x50(%ebp)
f01205c5:	e8 cb fc ff ff       	call   f0120295 <set_block_data>
f01205ca:	83 c4 10             	add    $0x10,%esp
f01205cd:	e9 95 00 00 00       	jmp    f0120667 <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f01205d2:	83 ec 04             	sub    $0x4,%esp
f01205d5:	6a 01                	push   $0x1
f01205d7:	ff 75 b8             	pushl  -0x48(%ebp)
f01205da:	ff 75 bc             	pushl  -0x44(%ebp)
f01205dd:	e8 b3 fc ff ff       	call   f0120295 <set_block_data>
f01205e2:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f01205e5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01205e9:	75 17                	jne    f0120602 <alloc_block_FF+0x33e>
f01205eb:	83 ec 04             	sub    $0x4,%esp
f01205ee:	68 17 0d 13 f0       	push   $0xf0130d17
f01205f3:	68 e8 00 00 00       	push   $0xe8
f01205f8:	68 35 0d 13 f0       	push   $0xf0130d35
f01205fd:	e8 37 fd fd ff       	call   f0100339 <_panic>
f0120602:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120605:	8b 00                	mov    (%eax),%eax
f0120607:	85 c0                	test   %eax,%eax
f0120609:	74 10                	je     f012061b <alloc_block_FF+0x357>
f012060b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012060e:	8b 00                	mov    (%eax),%eax
f0120610:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120613:	8b 52 04             	mov    0x4(%edx),%edx
f0120616:	89 50 04             	mov    %edx,0x4(%eax)
f0120619:	eb 0b                	jmp    f0120626 <alloc_block_FF+0x362>
f012061b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012061e:	8b 40 04             	mov    0x4(%eax),%eax
f0120621:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0120626:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120629:	8b 40 04             	mov    0x4(%eax),%eax
f012062c:	85 c0                	test   %eax,%eax
f012062e:	74 0f                	je     f012063f <alloc_block_FF+0x37b>
f0120630:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120633:	8b 40 04             	mov    0x4(%eax),%eax
f0120636:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120639:	8b 12                	mov    (%edx),%edx
f012063b:	89 10                	mov    %edx,(%eax)
f012063d:	eb 0a                	jmp    f0120649 <alloc_block_FF+0x385>
f012063f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120642:	8b 00                	mov    (%eax),%eax
f0120644:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120649:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012064c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120652:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120655:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012065c:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120661:	48                   	dec    %eax
f0120662:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
	            }
	            return va;
f0120667:	8b 45 bc             	mov    -0x44(%ebp),%eax
f012066a:	e9 0f 01 00 00       	jmp    f012077e <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f012066f:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f0120674:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120677:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012067b:	74 07                	je     f0120684 <alloc_block_FF+0x3c0>
f012067d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120680:	8b 00                	mov    (%eax),%eax
f0120682:	eb 05                	jmp    f0120689 <alloc_block_FF+0x3c5>
f0120684:	b8 00 00 00 00       	mov    $0x0,%eax
f0120689:	a3 f8 b3 6b f0       	mov    %eax,0xf06bb3f8
f012068e:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f0120693:	85 c0                	test   %eax,%eax
f0120695:	0f 85 e9 fc ff ff    	jne    f0120384 <alloc_block_FF+0xc0>
f012069b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012069f:	0f 85 df fc ff ff    	jne    f0120384 <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f01206a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01206a8:	83 c0 08             	add    $0x8,%eax
f01206ab:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f01206ae:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01206b5:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01206b8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01206bb:	01 d0                	add    %edx,%eax
f01206bd:	48                   	dec    %eax
f01206be:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01206c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01206c4:	ba 00 00 00 00       	mov    $0x0,%edx
f01206c9:	f7 75 d8             	divl   -0x28(%ebp)
f01206cc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01206cf:	29 d0                	sub    %edx,%eax
f01206d1:	c1 e8 0c             	shr    $0xc,%eax
f01206d4:	83 ec 0c             	sub    $0xc,%esp
f01206d7:	50                   	push   %eax
f01206d8:	e8 db 88 fe ff       	call   f0108fb8 <sbrk>
f01206dd:	83 c4 10             	add    $0x10,%esp
f01206e0:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f01206e3:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f01206e7:	75 0a                	jne    f01206f3 <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f01206e9:	b8 00 00 00 00       	mov    $0x0,%eax
f01206ee:	e9 8b 00 00 00       	jmp    f012077e <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f01206f3:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f01206fa:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01206fd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120700:	01 d0                	add    %edx,%eax
f0120702:	48                   	dec    %eax
f0120703:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0120706:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120709:	ba 00 00 00 00       	mov    $0x0,%edx
f012070e:	f7 75 cc             	divl   -0x34(%ebp)
f0120711:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120714:	29 d0                	sub    %edx,%eax
f0120716:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120719:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012071c:	01 d0                	add    %edx,%eax
f012071e:	a3 50 b8 6b f0       	mov    %eax,0xf06bb850
			end_block->info = 1;
f0120723:	a1 50 b8 6b f0       	mov    0xf06bb850,%eax
f0120728:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f012072e:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120735:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120738:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012073b:	01 d0                	add    %edx,%eax
f012073d:	48                   	dec    %eax
f012073e:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0120741:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120744:	ba 00 00 00 00       	mov    $0x0,%edx
f0120749:	f7 75 c4             	divl   -0x3c(%ebp)
f012074c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012074f:	29 d0                	sub    %edx,%eax
f0120751:	83 ec 04             	sub    $0x4,%esp
f0120754:	6a 01                	push   $0x1
f0120756:	50                   	push   %eax
f0120757:	ff 75 d0             	pushl  -0x30(%ebp)
f012075a:	e8 36 fb ff ff       	call   f0120295 <set_block_data>
f012075f:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f0120762:	83 ec 0c             	sub    $0xc,%esp
f0120765:	ff 75 d0             	pushl  -0x30(%ebp)
f0120768:	e8 1b 0a 00 00       	call   f0121188 <free_block>
f012076d:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f0120770:	83 ec 0c             	sub    $0xc,%esp
f0120773:	ff 75 08             	pushl  0x8(%ebp)
f0120776:	e8 49 fb ff ff       	call   f01202c4 <alloc_block_FF>
f012077b:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f012077e:	c9                   	leave  
f012077f:	c3                   	ret    

f0120780 <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f0120780:	55                   	push   %ebp
f0120781:	89 e5                	mov    %esp,%ebp
f0120783:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120786:	8b 45 08             	mov    0x8(%ebp),%eax
f0120789:	83 e0 01             	and    $0x1,%eax
f012078c:	85 c0                	test   %eax,%eax
f012078e:	74 03                	je     f0120793 <alloc_block_BF+0x13>
f0120790:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120793:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120797:	77 07                	ja     f01207a0 <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120799:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f01207a0:	a1 74 b0 6b f0       	mov    0xf06bb074,%eax
f01207a5:	85 c0                	test   %eax,%eax
f01207a7:	75 73                	jne    f012081c <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f01207a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01207ac:	83 c0 10             	add    $0x10,%eax
f01207af:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f01207b2:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f01207b9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01207bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01207bf:	01 d0                	add    %edx,%eax
f01207c1:	48                   	dec    %eax
f01207c2:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01207c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207c8:	ba 00 00 00 00       	mov    $0x0,%edx
f01207cd:	f7 75 e0             	divl   -0x20(%ebp)
f01207d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207d3:	29 d0                	sub    %edx,%eax
f01207d5:	c1 e8 0c             	shr    $0xc,%eax
f01207d8:	83 ec 0c             	sub    $0xc,%esp
f01207db:	50                   	push   %eax
f01207dc:	e8 d7 87 fe ff       	call   f0108fb8 <sbrk>
f01207e1:	83 c4 10             	add    $0x10,%esp
f01207e4:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f01207e7:	83 ec 0c             	sub    $0xc,%esp
f01207ea:	6a 00                	push   $0x0
f01207ec:	e8 c7 87 fe ff       	call   f0108fb8 <sbrk>
f01207f1:	83 c4 10             	add    $0x10,%esp
f01207f4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f01207f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207fa:	2b 45 d8             	sub    -0x28(%ebp),%eax
f01207fd:	83 ec 08             	sub    $0x8,%esp
f0120800:	50                   	push   %eax
f0120801:	ff 75 d8             	pushl  -0x28(%ebp)
f0120804:	e8 9f f8 ff ff       	call   f01200a8 <initialize_dynamic_allocator>
f0120809:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f012080c:	83 ec 0c             	sub    $0xc,%esp
f012080f:	68 73 0d 13 f0       	push   $0xf0130d73
f0120814:	e8 72 07 fe ff       	call   f0100f8b <cprintf>
f0120819:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f012081c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f0120823:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f012082a:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f0120831:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f0120838:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f012083d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120840:	e9 1d 01 00 00       	jmp    f0120962 <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f0120845:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120848:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f012084b:	83 ec 0c             	sub    $0xc,%esp
f012084e:	ff 75 a8             	pushl  -0x58(%ebp)
f0120851:	e8 ee f6 ff ff       	call   f011ff44 <get_block_size>
f0120856:	83 c4 10             	add    $0x10,%esp
f0120859:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f012085c:	8b 45 08             	mov    0x8(%ebp),%eax
f012085f:	83 c0 08             	add    $0x8,%eax
f0120862:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120865:	0f 87 ef 00 00 00    	ja     f012095a <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f012086b:	8b 45 08             	mov    0x8(%ebp),%eax
f012086e:	83 c0 18             	add    $0x18,%eax
f0120871:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120874:	77 1d                	ja     f0120893 <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f0120876:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120879:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f012087c:	0f 86 d8 00 00 00    	jbe    f012095a <alloc_block_BF+0x1da>
				{
					best_va = va;
f0120882:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0120885:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f0120888:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f012088b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f012088e:	e9 c7 00 00 00       	jmp    f012095a <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f0120893:	8b 45 08             	mov    0x8(%ebp),%eax
f0120896:	83 c0 08             	add    $0x8,%eax
f0120899:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f012089c:	0f 85 9d 00 00 00    	jne    f012093f <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f01208a2:	83 ec 04             	sub    $0x4,%esp
f01208a5:	6a 01                	push   $0x1
f01208a7:	ff 75 a4             	pushl  -0x5c(%ebp)
f01208aa:	ff 75 a8             	pushl  -0x58(%ebp)
f01208ad:	e8 e3 f9 ff ff       	call   f0120295 <set_block_data>
f01208b2:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f01208b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01208b9:	75 17                	jne    f01208d2 <alloc_block_BF+0x152>
f01208bb:	83 ec 04             	sub    $0x4,%esp
f01208be:	68 17 0d 13 f0       	push   $0xf0130d17
f01208c3:	68 2c 01 00 00       	push   $0x12c
f01208c8:	68 35 0d 13 f0       	push   $0xf0130d35
f01208cd:	e8 67 fa fd ff       	call   f0100339 <_panic>
f01208d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208d5:	8b 00                	mov    (%eax),%eax
f01208d7:	85 c0                	test   %eax,%eax
f01208d9:	74 10                	je     f01208eb <alloc_block_BF+0x16b>
f01208db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208de:	8b 00                	mov    (%eax),%eax
f01208e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01208e3:	8b 52 04             	mov    0x4(%edx),%edx
f01208e6:	89 50 04             	mov    %edx,0x4(%eax)
f01208e9:	eb 0b                	jmp    f01208f6 <alloc_block_BF+0x176>
f01208eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208ee:	8b 40 04             	mov    0x4(%eax),%eax
f01208f1:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f01208f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208f9:	8b 40 04             	mov    0x4(%eax),%eax
f01208fc:	85 c0                	test   %eax,%eax
f01208fe:	74 0f                	je     f012090f <alloc_block_BF+0x18f>
f0120900:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120903:	8b 40 04             	mov    0x4(%eax),%eax
f0120906:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120909:	8b 12                	mov    (%edx),%edx
f012090b:	89 10                	mov    %edx,(%eax)
f012090d:	eb 0a                	jmp    f0120919 <alloc_block_BF+0x199>
f012090f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120912:	8b 00                	mov    (%eax),%eax
f0120914:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120919:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012091c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120922:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120925:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012092c:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120931:	48                   	dec    %eax
f0120932:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
					return va;
f0120937:	8b 45 a8             	mov    -0x58(%ebp),%eax
f012093a:	e9 24 04 00 00       	jmp    f0120d63 <alloc_block_BF+0x5e3>
				}
				else
				{
					if (best_blk_size > blk_size)
f012093f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120942:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120945:	76 13                	jbe    f012095a <alloc_block_BF+0x1da>
					{
						internal = 1;
f0120947:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f012094e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0120951:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f0120954:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0120957:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f012095a:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f012095f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120962:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120966:	74 07                	je     f012096f <alloc_block_BF+0x1ef>
f0120968:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012096b:	8b 00                	mov    (%eax),%eax
f012096d:	eb 05                	jmp    f0120974 <alloc_block_BF+0x1f4>
f012096f:	b8 00 00 00 00       	mov    $0x0,%eax
f0120974:	a3 f8 b3 6b f0       	mov    %eax,0xf06bb3f8
f0120979:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f012097e:	85 c0                	test   %eax,%eax
f0120980:	0f 85 bf fe ff ff    	jne    f0120845 <alloc_block_BF+0xc5>
f0120986:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012098a:	0f 85 b5 fe ff ff    	jne    f0120845 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f0120990:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120994:	0f 84 26 02 00 00    	je     f0120bc0 <alloc_block_BF+0x440>
f012099a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f012099e:	0f 85 1c 02 00 00    	jne    f0120bc0 <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f01209a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209a7:	2b 45 08             	sub    0x8(%ebp),%eax
f01209aa:	83 e8 08             	sub    $0x8,%eax
f01209ad:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f01209b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01209b3:	8d 50 08             	lea    0x8(%eax),%edx
f01209b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01209b9:	01 d0                	add    %edx,%eax
f01209bb:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f01209be:	8b 45 08             	mov    0x8(%ebp),%eax
f01209c1:	83 c0 08             	add    $0x8,%eax
f01209c4:	83 ec 04             	sub    $0x4,%esp
f01209c7:	6a 01                	push   $0x1
f01209c9:	50                   	push   %eax
f01209ca:	ff 75 f0             	pushl  -0x10(%ebp)
f01209cd:	e8 c3 f8 ff ff       	call   f0120295 <set_block_data>
f01209d2:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f01209d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01209d8:	8b 40 04             	mov    0x4(%eax),%eax
f01209db:	85 c0                	test   %eax,%eax
f01209dd:	75 68                	jne    f0120a47 <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f01209df:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01209e3:	75 17                	jne    f01209fc <alloc_block_BF+0x27c>
f01209e5:	83 ec 04             	sub    $0x4,%esp
f01209e8:	68 50 0d 13 f0       	push   $0xf0130d50
f01209ed:	68 45 01 00 00       	push   $0x145
f01209f2:	68 35 0d 13 f0       	push   $0xf0130d35
f01209f7:	e8 3d f9 fd ff       	call   f0100339 <_panic>
f01209fc:	8b 15 f0 b3 6b f0    	mov    0xf06bb3f0,%edx
f0120a02:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a05:	89 10                	mov    %edx,(%eax)
f0120a07:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a0a:	8b 00                	mov    (%eax),%eax
f0120a0c:	85 c0                	test   %eax,%eax
f0120a0e:	74 0d                	je     f0120a1d <alloc_block_BF+0x29d>
f0120a10:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f0120a15:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120a18:	89 50 04             	mov    %edx,0x4(%eax)
f0120a1b:	eb 08                	jmp    f0120a25 <alloc_block_BF+0x2a5>
f0120a1d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a20:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0120a25:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a28:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120a2d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a30:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120a37:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120a3c:	40                   	inc    %eax
f0120a3d:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f0120a42:	e9 dc 00 00 00       	jmp    f0120b23 <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f0120a47:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120a4a:	8b 00                	mov    (%eax),%eax
f0120a4c:	85 c0                	test   %eax,%eax
f0120a4e:	75 65                	jne    f0120ab5 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120a50:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0120a54:	75 17                	jne    f0120a6d <alloc_block_BF+0x2ed>
f0120a56:	83 ec 04             	sub    $0x4,%esp
f0120a59:	68 84 0d 13 f0       	push   $0xf0130d84
f0120a5e:	68 4a 01 00 00       	push   $0x14a
f0120a63:	68 35 0d 13 f0       	push   $0xf0130d35
f0120a68:	e8 cc f8 fd ff       	call   f0100339 <_panic>
f0120a6d:	8b 15 f4 b3 6b f0    	mov    0xf06bb3f4,%edx
f0120a73:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a76:	89 50 04             	mov    %edx,0x4(%eax)
f0120a79:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a7c:	8b 40 04             	mov    0x4(%eax),%eax
f0120a7f:	85 c0                	test   %eax,%eax
f0120a81:	74 0c                	je     f0120a8f <alloc_block_BF+0x30f>
f0120a83:	a1 f4 b3 6b f0       	mov    0xf06bb3f4,%eax
f0120a88:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120a8b:	89 10                	mov    %edx,(%eax)
f0120a8d:	eb 08                	jmp    f0120a97 <alloc_block_BF+0x317>
f0120a8f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a92:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120a97:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a9a:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0120a9f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120aa2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120aa8:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120aad:	40                   	inc    %eax
f0120aae:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f0120ab3:	eb 6e                	jmp    f0120b23 <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f0120ab5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120ab9:	74 06                	je     f0120ac1 <alloc_block_BF+0x341>
f0120abb:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0120abf:	75 17                	jne    f0120ad8 <alloc_block_BF+0x358>
f0120ac1:	83 ec 04             	sub    $0x4,%esp
f0120ac4:	68 a8 0d 13 f0       	push   $0xf0130da8
f0120ac9:	68 4f 01 00 00       	push   $0x14f
f0120ace:	68 35 0d 13 f0       	push   $0xf0130d35
f0120ad3:	e8 61 f8 fd ff       	call   f0100339 <_panic>
f0120ad8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120adb:	8b 10                	mov    (%eax),%edx
f0120add:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120ae0:	89 10                	mov    %edx,(%eax)
f0120ae2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120ae5:	8b 00                	mov    (%eax),%eax
f0120ae7:	85 c0                	test   %eax,%eax
f0120ae9:	74 0b                	je     f0120af6 <alloc_block_BF+0x376>
f0120aeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120aee:	8b 00                	mov    (%eax),%eax
f0120af0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120af3:	89 50 04             	mov    %edx,0x4(%eax)
f0120af6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120af9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120afc:	89 10                	mov    %edx,(%eax)
f0120afe:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b01:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120b04:	89 50 04             	mov    %edx,0x4(%eax)
f0120b07:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b0a:	8b 00                	mov    (%eax),%eax
f0120b0c:	85 c0                	test   %eax,%eax
f0120b0e:	75 08                	jne    f0120b18 <alloc_block_BF+0x398>
f0120b10:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b13:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0120b18:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120b1d:	40                   	inc    %eax
f0120b1e:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f0120b23:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120b27:	75 17                	jne    f0120b40 <alloc_block_BF+0x3c0>
f0120b29:	83 ec 04             	sub    $0x4,%esp
f0120b2c:	68 17 0d 13 f0       	push   $0xf0130d17
f0120b31:	68 51 01 00 00       	push   $0x151
f0120b36:	68 35 0d 13 f0       	push   $0xf0130d35
f0120b3b:	e8 f9 f7 fd ff       	call   f0100339 <_panic>
f0120b40:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b43:	8b 00                	mov    (%eax),%eax
f0120b45:	85 c0                	test   %eax,%eax
f0120b47:	74 10                	je     f0120b59 <alloc_block_BF+0x3d9>
f0120b49:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b4c:	8b 00                	mov    (%eax),%eax
f0120b4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120b51:	8b 52 04             	mov    0x4(%edx),%edx
f0120b54:	89 50 04             	mov    %edx,0x4(%eax)
f0120b57:	eb 0b                	jmp    f0120b64 <alloc_block_BF+0x3e4>
f0120b59:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b5c:	8b 40 04             	mov    0x4(%eax),%eax
f0120b5f:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0120b64:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b67:	8b 40 04             	mov    0x4(%eax),%eax
f0120b6a:	85 c0                	test   %eax,%eax
f0120b6c:	74 0f                	je     f0120b7d <alloc_block_BF+0x3fd>
f0120b6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b71:	8b 40 04             	mov    0x4(%eax),%eax
f0120b74:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120b77:	8b 12                	mov    (%edx),%edx
f0120b79:	89 10                	mov    %edx,(%eax)
f0120b7b:	eb 0a                	jmp    f0120b87 <alloc_block_BF+0x407>
f0120b7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b80:	8b 00                	mov    (%eax),%eax
f0120b82:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120b87:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b8a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120b90:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b93:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120b9a:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120b9f:	48                   	dec    %eax
f0120ba0:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
			set_block_data(new_block_va, remaining_size, 0);
f0120ba5:	83 ec 04             	sub    $0x4,%esp
f0120ba8:	6a 00                	push   $0x0
f0120baa:	ff 75 d0             	pushl  -0x30(%ebp)
f0120bad:	ff 75 cc             	pushl  -0x34(%ebp)
f0120bb0:	e8 e0 f6 ff ff       	call   f0120295 <set_block_data>
f0120bb5:	83 c4 10             	add    $0x10,%esp
			return best_va;
f0120bb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120bbb:	e9 a3 01 00 00       	jmp    f0120d63 <alloc_block_BF+0x5e3>
	}
	else if(internal == 1)
f0120bc0:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0120bc4:	0f 85 9d 00 00 00    	jne    f0120c67 <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f0120bca:	83 ec 04             	sub    $0x4,%esp
f0120bcd:	6a 01                	push   $0x1
f0120bcf:	ff 75 ec             	pushl  -0x14(%ebp)
f0120bd2:	ff 75 f0             	pushl  -0x10(%ebp)
f0120bd5:	e8 bb f6 ff ff       	call   f0120295 <set_block_data>
f0120bda:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f0120bdd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120be1:	75 17                	jne    f0120bfa <alloc_block_BF+0x47a>
f0120be3:	83 ec 04             	sub    $0x4,%esp
f0120be6:	68 17 0d 13 f0       	push   $0xf0130d17
f0120beb:	68 58 01 00 00       	push   $0x158
f0120bf0:	68 35 0d 13 f0       	push   $0xf0130d35
f0120bf5:	e8 3f f7 fd ff       	call   f0100339 <_panic>
f0120bfa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120bfd:	8b 00                	mov    (%eax),%eax
f0120bff:	85 c0                	test   %eax,%eax
f0120c01:	74 10                	je     f0120c13 <alloc_block_BF+0x493>
f0120c03:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c06:	8b 00                	mov    (%eax),%eax
f0120c08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120c0b:	8b 52 04             	mov    0x4(%edx),%edx
f0120c0e:	89 50 04             	mov    %edx,0x4(%eax)
f0120c11:	eb 0b                	jmp    f0120c1e <alloc_block_BF+0x49e>
f0120c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c16:	8b 40 04             	mov    0x4(%eax),%eax
f0120c19:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0120c1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c21:	8b 40 04             	mov    0x4(%eax),%eax
f0120c24:	85 c0                	test   %eax,%eax
f0120c26:	74 0f                	je     f0120c37 <alloc_block_BF+0x4b7>
f0120c28:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c2b:	8b 40 04             	mov    0x4(%eax),%eax
f0120c2e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120c31:	8b 12                	mov    (%edx),%edx
f0120c33:	89 10                	mov    %edx,(%eax)
f0120c35:	eb 0a                	jmp    f0120c41 <alloc_block_BF+0x4c1>
f0120c37:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c3a:	8b 00                	mov    (%eax),%eax
f0120c3c:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120c41:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c44:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120c4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c4d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120c54:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120c59:	48                   	dec    %eax
f0120c5a:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
		return best_va;
f0120c5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c62:	e9 fc 00 00 00       	jmp    f0120d63 <alloc_block_BF+0x5e3>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f0120c67:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c6a:	83 c0 08             	add    $0x8,%eax
f0120c6d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0120c70:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120c77:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120c7a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120c7d:	01 d0                	add    %edx,%eax
f0120c7f:	48                   	dec    %eax
f0120c80:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0120c83:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120c86:	ba 00 00 00 00       	mov    $0x0,%edx
f0120c8b:	f7 75 c4             	divl   -0x3c(%ebp)
f0120c8e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120c91:	29 d0                	sub    %edx,%eax
f0120c93:	c1 e8 0c             	shr    $0xc,%eax
f0120c96:	83 ec 0c             	sub    $0xc,%esp
f0120c99:	50                   	push   %eax
f0120c9a:	e8 19 83 fe ff       	call   f0108fb8 <sbrk>
f0120c9f:	83 c4 10             	add    $0x10,%esp
f0120ca2:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f0120ca5:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f0120ca9:	75 0a                	jne    f0120cb5 <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f0120cab:	b8 00 00 00 00       	mov    $0x0,%eax
f0120cb0:	e9 ae 00 00 00       	jmp    f0120d63 <alloc_block_BF+0x5e3>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0120cb5:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f0120cbc:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120cbf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120cc2:	01 d0                	add    %edx,%eax
f0120cc4:	48                   	dec    %eax
f0120cc5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0120cc8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0120ccb:	ba 00 00 00 00       	mov    $0x0,%edx
f0120cd0:	f7 75 b8             	divl   -0x48(%ebp)
f0120cd3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0120cd6:	29 d0                	sub    %edx,%eax
f0120cd8:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120cdb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120cde:	01 d0                	add    %edx,%eax
f0120ce0:	a3 50 b8 6b f0       	mov    %eax,0xf06bb850
				end_block->info = 1;
f0120ce5:	a1 50 b8 6b f0       	mov    0xf06bb850,%eax
f0120cea:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				cprintf("251\n");
f0120cf0:	83 ec 0c             	sub    $0xc,%esp
f0120cf3:	68 dc 0d 13 f0       	push   $0xf0130ddc
f0120cf8:	e8 8e 02 fe ff       	call   f0100f8b <cprintf>
f0120cfd:	83 c4 10             	add    $0x10,%esp
			cprintf("address : %x\n",new_mem);
f0120d00:	83 ec 08             	sub    $0x8,%esp
f0120d03:	ff 75 bc             	pushl  -0x44(%ebp)
f0120d06:	68 e1 0d 13 f0       	push   $0xf0130de1
f0120d0b:	e8 7b 02 fe ff       	call   f0100f8b <cprintf>
f0120d10:	83 c4 10             	add    $0x10,%esp
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0120d13:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f0120d1a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120d1d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120d20:	01 d0                	add    %edx,%eax
f0120d22:	48                   	dec    %eax
f0120d23:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0120d26:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0120d29:	ba 00 00 00 00       	mov    $0x0,%edx
f0120d2e:	f7 75 b0             	divl   -0x50(%ebp)
f0120d31:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0120d34:	29 d0                	sub    %edx,%eax
f0120d36:	83 ec 04             	sub    $0x4,%esp
f0120d39:	6a 01                	push   $0x1
f0120d3b:	50                   	push   %eax
f0120d3c:	ff 75 bc             	pushl  -0x44(%ebp)
f0120d3f:	e8 51 f5 ff ff       	call   f0120295 <set_block_data>
f0120d44:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f0120d47:	83 ec 0c             	sub    $0xc,%esp
f0120d4a:	ff 75 bc             	pushl  -0x44(%ebp)
f0120d4d:	e8 36 04 00 00       	call   f0121188 <free_block>
f0120d52:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f0120d55:	83 ec 0c             	sub    $0xc,%esp
f0120d58:	ff 75 08             	pushl  0x8(%ebp)
f0120d5b:	e8 20 fa ff ff       	call   f0120780 <alloc_block_BF>
f0120d60:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f0120d63:	c9                   	leave  
f0120d64:	c3                   	ret    

f0120d65 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f0120d65:	55                   	push   %ebp
f0120d66:	89 e5                	mov    %esp,%ebp
f0120d68:	53                   	push   %ebx
f0120d69:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f0120d6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0120d73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f0120d7a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120d7e:	74 1e                	je     f0120d9e <merging+0x39>
f0120d80:	ff 75 08             	pushl  0x8(%ebp)
f0120d83:	e8 bc f1 ff ff       	call   f011ff44 <get_block_size>
f0120d88:	83 c4 04             	add    $0x4,%esp
f0120d8b:	89 c2                	mov    %eax,%edx
f0120d8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d90:	01 d0                	add    %edx,%eax
f0120d92:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120d95:	75 07                	jne    f0120d9e <merging+0x39>
		prev_is_free = 1;
f0120d97:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f0120d9e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120da2:	74 1e                	je     f0120dc2 <merging+0x5d>
f0120da4:	ff 75 10             	pushl  0x10(%ebp)
f0120da7:	e8 98 f1 ff ff       	call   f011ff44 <get_block_size>
f0120dac:	83 c4 04             	add    $0x4,%esp
f0120daf:	89 c2                	mov    %eax,%edx
f0120db1:	8b 45 10             	mov    0x10(%ebp),%eax
f0120db4:	01 d0                	add    %edx,%eax
f0120db6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120db9:	75 07                	jne    f0120dc2 <merging+0x5d>
		next_is_free = 1;
f0120dbb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f0120dc2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120dc6:	0f 84 cc 00 00 00    	je     f0120e98 <merging+0x133>
f0120dcc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120dd0:	0f 84 c2 00 00 00    	je     f0120e98 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f0120dd6:	ff 75 08             	pushl  0x8(%ebp)
f0120dd9:	e8 66 f1 ff ff       	call   f011ff44 <get_block_size>
f0120dde:	83 c4 04             	add    $0x4,%esp
f0120de1:	89 c3                	mov    %eax,%ebx
f0120de3:	ff 75 10             	pushl  0x10(%ebp)
f0120de6:	e8 59 f1 ff ff       	call   f011ff44 <get_block_size>
f0120deb:	83 c4 04             	add    $0x4,%esp
f0120dee:	01 c3                	add    %eax,%ebx
f0120df0:	ff 75 0c             	pushl  0xc(%ebp)
f0120df3:	e8 4c f1 ff ff       	call   f011ff44 <get_block_size>
f0120df8:	83 c4 04             	add    $0x4,%esp
f0120dfb:	01 d8                	add    %ebx,%eax
f0120dfd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0120e00:	6a 00                	push   $0x0
f0120e02:	ff 75 ec             	pushl  -0x14(%ebp)
f0120e05:	ff 75 08             	pushl  0x8(%ebp)
f0120e08:	e8 88 f4 ff ff       	call   f0120295 <set_block_data>
f0120e0d:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f0120e10:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120e14:	75 17                	jne    f0120e2d <merging+0xc8>
f0120e16:	83 ec 04             	sub    $0x4,%esp
f0120e19:	68 17 0d 13 f0       	push   $0xf0130d17
f0120e1e:	68 7d 01 00 00       	push   $0x17d
f0120e23:	68 35 0d 13 f0       	push   $0xf0130d35
f0120e28:	e8 0c f5 fd ff       	call   f0100339 <_panic>
f0120e2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e30:	8b 00                	mov    (%eax),%eax
f0120e32:	85 c0                	test   %eax,%eax
f0120e34:	74 10                	je     f0120e46 <merging+0xe1>
f0120e36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e39:	8b 00                	mov    (%eax),%eax
f0120e3b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120e3e:	8b 52 04             	mov    0x4(%edx),%edx
f0120e41:	89 50 04             	mov    %edx,0x4(%eax)
f0120e44:	eb 0b                	jmp    f0120e51 <merging+0xec>
f0120e46:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e49:	8b 40 04             	mov    0x4(%eax),%eax
f0120e4c:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0120e51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e54:	8b 40 04             	mov    0x4(%eax),%eax
f0120e57:	85 c0                	test   %eax,%eax
f0120e59:	74 0f                	je     f0120e6a <merging+0x105>
f0120e5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e5e:	8b 40 04             	mov    0x4(%eax),%eax
f0120e61:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120e64:	8b 12                	mov    (%edx),%edx
f0120e66:	89 10                	mov    %edx,(%eax)
f0120e68:	eb 0a                	jmp    f0120e74 <merging+0x10f>
f0120e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e6d:	8b 00                	mov    (%eax),%eax
f0120e6f:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120e74:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e77:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120e7d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e80:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120e87:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120e8c:	48                   	dec    %eax
f0120e8d:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f0120e92:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0120e93:	e9 ea 02 00 00       	jmp    f0121182 <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0120e98:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120e9c:	74 3b                	je     f0120ed9 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f0120e9e:	83 ec 0c             	sub    $0xc,%esp
f0120ea1:	ff 75 08             	pushl  0x8(%ebp)
f0120ea4:	e8 9b f0 ff ff       	call   f011ff44 <get_block_size>
f0120ea9:	83 c4 10             	add    $0x10,%esp
f0120eac:	89 c3                	mov    %eax,%ebx
f0120eae:	83 ec 0c             	sub    $0xc,%esp
f0120eb1:	ff 75 10             	pushl  0x10(%ebp)
f0120eb4:	e8 8b f0 ff ff       	call   f011ff44 <get_block_size>
f0120eb9:	83 c4 10             	add    $0x10,%esp
f0120ebc:	01 d8                	add    %ebx,%eax
f0120ebe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0120ec1:	83 ec 04             	sub    $0x4,%esp
f0120ec4:	6a 00                	push   $0x0
f0120ec6:	ff 75 e8             	pushl  -0x18(%ebp)
f0120ec9:	ff 75 08             	pushl  0x8(%ebp)
f0120ecc:	e8 c4 f3 ff ff       	call   f0120295 <set_block_data>
f0120ed1:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0120ed4:	e9 a9 02 00 00       	jmp    f0121182 <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f0120ed9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120edd:	0f 84 2d 01 00 00    	je     f0121010 <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f0120ee3:	83 ec 0c             	sub    $0xc,%esp
f0120ee6:	ff 75 10             	pushl  0x10(%ebp)
f0120ee9:	e8 56 f0 ff ff       	call   f011ff44 <get_block_size>
f0120eee:	83 c4 10             	add    $0x10,%esp
f0120ef1:	89 c3                	mov    %eax,%ebx
f0120ef3:	83 ec 0c             	sub    $0xc,%esp
f0120ef6:	ff 75 0c             	pushl  0xc(%ebp)
f0120ef9:	e8 46 f0 ff ff       	call   f011ff44 <get_block_size>
f0120efe:	83 c4 10             	add    $0x10,%esp
f0120f01:	01 d8                	add    %ebx,%eax
f0120f03:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f0120f06:	83 ec 04             	sub    $0x4,%esp
f0120f09:	6a 00                	push   $0x0
f0120f0b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120f0e:	ff 75 10             	pushl  0x10(%ebp)
f0120f11:	e8 7f f3 ff ff       	call   f0120295 <set_block_data>
f0120f16:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f0120f19:	8b 45 10             	mov    0x10(%ebp),%eax
f0120f1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f0120f1f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120f23:	74 06                	je     f0120f2b <merging+0x1c6>
f0120f25:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0120f29:	75 17                	jne    f0120f42 <merging+0x1dd>
f0120f2b:	83 ec 04             	sub    $0x4,%esp
f0120f2e:	68 f0 0d 13 f0       	push   $0xf0130df0
f0120f33:	68 8d 01 00 00       	push   $0x18d
f0120f38:	68 35 0d 13 f0       	push   $0xf0130d35
f0120f3d:	e8 f7 f3 fd ff       	call   f0100339 <_panic>
f0120f42:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f45:	8b 50 04             	mov    0x4(%eax),%edx
f0120f48:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120f4b:	89 50 04             	mov    %edx,0x4(%eax)
f0120f4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120f51:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120f54:	89 10                	mov    %edx,(%eax)
f0120f56:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f59:	8b 40 04             	mov    0x4(%eax),%eax
f0120f5c:	85 c0                	test   %eax,%eax
f0120f5e:	74 0d                	je     f0120f6d <merging+0x208>
f0120f60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f63:	8b 40 04             	mov    0x4(%eax),%eax
f0120f66:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120f69:	89 10                	mov    %edx,(%eax)
f0120f6b:	eb 08                	jmp    f0120f75 <merging+0x210>
f0120f6d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120f70:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120f75:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f78:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120f7b:	89 50 04             	mov    %edx,0x4(%eax)
f0120f7e:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0120f83:	40                   	inc    %eax
f0120f84:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
		LIST_REMOVE(&freeBlocksList, next_block);
f0120f89:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120f8d:	75 17                	jne    f0120fa6 <merging+0x241>
f0120f8f:	83 ec 04             	sub    $0x4,%esp
f0120f92:	68 17 0d 13 f0       	push   $0xf0130d17
f0120f97:	68 8e 01 00 00       	push   $0x18e
f0120f9c:	68 35 0d 13 f0       	push   $0xf0130d35
f0120fa1:	e8 93 f3 fd ff       	call   f0100339 <_panic>
f0120fa6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fa9:	8b 00                	mov    (%eax),%eax
f0120fab:	85 c0                	test   %eax,%eax
f0120fad:	74 10                	je     f0120fbf <merging+0x25a>
f0120faf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fb2:	8b 00                	mov    (%eax),%eax
f0120fb4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120fb7:	8b 52 04             	mov    0x4(%edx),%edx
f0120fba:	89 50 04             	mov    %edx,0x4(%eax)
f0120fbd:	eb 0b                	jmp    f0120fca <merging+0x265>
f0120fbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fc2:	8b 40 04             	mov    0x4(%eax),%eax
f0120fc5:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0120fca:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fcd:	8b 40 04             	mov    0x4(%eax),%eax
f0120fd0:	85 c0                	test   %eax,%eax
f0120fd2:	74 0f                	je     f0120fe3 <merging+0x27e>
f0120fd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fd7:	8b 40 04             	mov    0x4(%eax),%eax
f0120fda:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120fdd:	8b 12                	mov    (%edx),%edx
f0120fdf:	89 10                	mov    %edx,(%eax)
f0120fe1:	eb 0a                	jmp    f0120fed <merging+0x288>
f0120fe3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fe6:	8b 00                	mov    (%eax),%eax
f0120fe8:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0120fed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120ff0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120ff6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120ff9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121000:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0121005:	48                   	dec    %eax
f0121006:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f012100b:	e9 72 01 00 00       	jmp    f0121182 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f0121010:	8b 45 10             	mov    0x10(%ebp),%eax
f0121013:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0121016:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012101a:	74 79                	je     f0121095 <merging+0x330>
f012101c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121020:	74 73                	je     f0121095 <merging+0x330>
f0121022:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121026:	74 06                	je     f012102e <merging+0x2c9>
f0121028:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012102c:	75 17                	jne    f0121045 <merging+0x2e0>
f012102e:	83 ec 04             	sub    $0x4,%esp
f0121031:	68 a8 0d 13 f0       	push   $0xf0130da8
f0121036:	68 94 01 00 00       	push   $0x194
f012103b:	68 35 0d 13 f0       	push   $0xf0130d35
f0121040:	e8 f4 f2 fd ff       	call   f0100339 <_panic>
f0121045:	8b 45 08             	mov    0x8(%ebp),%eax
f0121048:	8b 10                	mov    (%eax),%edx
f012104a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012104d:	89 10                	mov    %edx,(%eax)
f012104f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121052:	8b 00                	mov    (%eax),%eax
f0121054:	85 c0                	test   %eax,%eax
f0121056:	74 0b                	je     f0121063 <merging+0x2fe>
f0121058:	8b 45 08             	mov    0x8(%ebp),%eax
f012105b:	8b 00                	mov    (%eax),%eax
f012105d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121060:	89 50 04             	mov    %edx,0x4(%eax)
f0121063:	8b 45 08             	mov    0x8(%ebp),%eax
f0121066:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121069:	89 10                	mov    %edx,(%eax)
f012106b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012106e:	8b 55 08             	mov    0x8(%ebp),%edx
f0121071:	89 50 04             	mov    %edx,0x4(%eax)
f0121074:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121077:	8b 00                	mov    (%eax),%eax
f0121079:	85 c0                	test   %eax,%eax
f012107b:	75 08                	jne    f0121085 <merging+0x320>
f012107d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121080:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0121085:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f012108a:	40                   	inc    %eax
f012108b:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f0121090:	e9 ce 00 00 00       	jmp    f0121163 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0121095:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121099:	74 65                	je     f0121100 <merging+0x39b>
f012109b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012109f:	75 17                	jne    f01210b8 <merging+0x353>
f01210a1:	83 ec 04             	sub    $0x4,%esp
f01210a4:	68 84 0d 13 f0       	push   $0xf0130d84
f01210a9:	68 95 01 00 00       	push   $0x195
f01210ae:	68 35 0d 13 f0       	push   $0xf0130d35
f01210b3:	e8 81 f2 fd ff       	call   f0100339 <_panic>
f01210b8:	8b 15 f4 b3 6b f0    	mov    0xf06bb3f4,%edx
f01210be:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01210c1:	89 50 04             	mov    %edx,0x4(%eax)
f01210c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01210c7:	8b 40 04             	mov    0x4(%eax),%eax
f01210ca:	85 c0                	test   %eax,%eax
f01210cc:	74 0c                	je     f01210da <merging+0x375>
f01210ce:	a1 f4 b3 6b f0       	mov    0xf06bb3f4,%eax
f01210d3:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01210d6:	89 10                	mov    %edx,(%eax)
f01210d8:	eb 08                	jmp    f01210e2 <merging+0x37d>
f01210da:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01210dd:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f01210e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01210e5:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f01210ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01210ed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01210f3:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f01210f8:	40                   	inc    %eax
f01210f9:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f01210fe:	eb 63                	jmp    f0121163 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f0121100:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121104:	75 17                	jne    f012111d <merging+0x3b8>
f0121106:	83 ec 04             	sub    $0x4,%esp
f0121109:	68 50 0d 13 f0       	push   $0xf0130d50
f012110e:	68 98 01 00 00       	push   $0x198
f0121113:	68 35 0d 13 f0       	push   $0xf0130d35
f0121118:	e8 1c f2 fd ff       	call   f0100339 <_panic>
f012111d:	8b 15 f0 b3 6b f0    	mov    0xf06bb3f0,%edx
f0121123:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121126:	89 10                	mov    %edx,(%eax)
f0121128:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012112b:	8b 00                	mov    (%eax),%eax
f012112d:	85 c0                	test   %eax,%eax
f012112f:	74 0d                	je     f012113e <merging+0x3d9>
f0121131:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f0121136:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121139:	89 50 04             	mov    %edx,0x4(%eax)
f012113c:	eb 08                	jmp    f0121146 <merging+0x3e1>
f012113e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121141:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0121146:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121149:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f012114e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121151:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121158:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f012115d:	40                   	inc    %eax
f012115e:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
		}
		set_block_data(va, get_block_size(va), 0);
f0121163:	83 ec 0c             	sub    $0xc,%esp
f0121166:	ff 75 10             	pushl  0x10(%ebp)
f0121169:	e8 d6 ed ff ff       	call   f011ff44 <get_block_size>
f012116e:	83 c4 10             	add    $0x10,%esp
f0121171:	83 ec 04             	sub    $0x4,%esp
f0121174:	6a 00                	push   $0x0
f0121176:	50                   	push   %eax
f0121177:	ff 75 10             	pushl  0x10(%ebp)
f012117a:	e8 16 f1 ff ff       	call   f0120295 <set_block_data>
f012117f:	83 c4 10             	add    $0x10,%esp
	}
}
f0121182:	90                   	nop
f0121183:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121186:	c9                   	leave  
f0121187:	c3                   	ret    

f0121188 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121188:	55                   	push   %ebp
f0121189:	89 e5                	mov    %esp,%ebp
f012118b:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f012118e:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f0121193:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0121196:	a1 f4 b3 6b f0       	mov    0xf06bb3f4,%eax
f012119b:	3b 45 08             	cmp    0x8(%ebp),%eax
f012119e:	73 1b                	jae    f01211bb <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f01211a0:	a1 f4 b3 6b f0       	mov    0xf06bb3f4,%eax
f01211a5:	83 ec 04             	sub    $0x4,%esp
f01211a8:	ff 75 08             	pushl  0x8(%ebp)
f01211ab:	6a 00                	push   $0x0
f01211ad:	50                   	push   %eax
f01211ae:	e8 b2 fb ff ff       	call   f0120d65 <merging>
f01211b3:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01211b6:	e9 8b 00 00 00       	jmp    f0121246 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f01211bb:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f01211c0:	3b 45 08             	cmp    0x8(%ebp),%eax
f01211c3:	76 18                	jbe    f01211dd <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f01211c5:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f01211ca:	83 ec 04             	sub    $0x4,%esp
f01211cd:	ff 75 08             	pushl  0x8(%ebp)
f01211d0:	50                   	push   %eax
f01211d1:	6a 00                	push   $0x0
f01211d3:	e8 8d fb ff ff       	call   f0120d65 <merging>
f01211d8:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01211db:	eb 69                	jmp    f0121246 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f01211dd:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f01211e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01211e5:	eb 39                	jmp    f0121220 <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f01211e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01211ea:	3b 45 08             	cmp    0x8(%ebp),%eax
f01211ed:	73 29                	jae    f0121218 <free_block+0x90>
f01211ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01211f2:	8b 00                	mov    (%eax),%eax
f01211f4:	3b 45 08             	cmp    0x8(%ebp),%eax
f01211f7:	76 1f                	jbe    f0121218 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f01211f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01211fc:	8b 00                	mov    (%eax),%eax
f01211fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f0121201:	83 ec 04             	sub    $0x4,%esp
f0121204:	ff 75 08             	pushl  0x8(%ebp)
f0121207:	ff 75 f0             	pushl  -0x10(%ebp)
f012120a:	ff 75 f4             	pushl  -0xc(%ebp)
f012120d:	e8 53 fb ff ff       	call   f0120d65 <merging>
f0121212:	83 c4 10             	add    $0x10,%esp
			break;
f0121215:	90                   	nop
		}
	}
}
f0121216:	eb 2e                	jmp    f0121246 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121218:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f012121d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121220:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121224:	74 07                	je     f012122d <free_block+0xa5>
f0121226:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121229:	8b 00                	mov    (%eax),%eax
f012122b:	eb 05                	jmp    f0121232 <free_block+0xaa>
f012122d:	b8 00 00 00 00       	mov    $0x0,%eax
f0121232:	a3 f8 b3 6b f0       	mov    %eax,0xf06bb3f8
f0121237:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f012123c:	85 c0                	test   %eax,%eax
f012123e:	75 a7                	jne    f01211e7 <free_block+0x5f>
f0121240:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121244:	75 a1                	jne    f01211e7 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121246:	90                   	nop
f0121247:	c9                   	leave  
f0121248:	c3                   	ret    

f0121249 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f0121249:	55                   	push   %ebp
f012124a:	89 e5                	mov    %esp,%ebp
f012124c:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f012124f:	ff 75 08             	pushl  0x8(%ebp)
f0121252:	e8 ed ec ff ff       	call   f011ff44 <get_block_size>
f0121257:	83 c4 04             	add    $0x4,%esp
f012125a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f012125d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121264:	eb 17                	jmp    f012127d <copy_data+0x34>
f0121266:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0121269:	8b 45 0c             	mov    0xc(%ebp),%eax
f012126c:	01 c2                	add    %eax,%edx
f012126e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0121271:	8b 45 08             	mov    0x8(%ebp),%eax
f0121274:	01 c8                	add    %ecx,%eax
f0121276:	8a 00                	mov    (%eax),%al
f0121278:	88 02                	mov    %al,(%edx)
f012127a:	ff 45 fc             	incl   -0x4(%ebp)
f012127d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0121280:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0121283:	72 e1                	jb     f0121266 <copy_data+0x1d>
}
f0121285:	90                   	nop
f0121286:	c9                   	leave  
f0121287:	c3                   	ret    

f0121288 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0121288:	55                   	push   %ebp
f0121289:	89 e5                	mov    %esp,%ebp
f012128b:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f012128e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121292:	75 23                	jne    f01212b7 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0121294:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121298:	74 13                	je     f01212ad <realloc_block_FF+0x25>
f012129a:	83 ec 0c             	sub    $0xc,%esp
f012129d:	ff 75 0c             	pushl  0xc(%ebp)
f01212a0:	e8 1f f0 ff ff       	call   f01202c4 <alloc_block_FF>
f01212a5:	83 c4 10             	add    $0x10,%esp
f01212a8:	e9 f4 06 00 00       	jmp    f01219a1 <realloc_block_FF+0x719>
		return NULL;
f01212ad:	b8 00 00 00 00       	mov    $0x0,%eax
f01212b2:	e9 ea 06 00 00       	jmp    f01219a1 <realloc_block_FF+0x719>
	}

	if(new_size == 0)
f01212b7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01212bb:	75 18                	jne    f01212d5 <realloc_block_FF+0x4d>
	{
		free_block(va);
f01212bd:	83 ec 0c             	sub    $0xc,%esp
f01212c0:	ff 75 08             	pushl  0x8(%ebp)
f01212c3:	e8 c0 fe ff ff       	call   f0121188 <free_block>
f01212c8:	83 c4 10             	add    $0x10,%esp
		return NULL;
f01212cb:	b8 00 00 00 00       	mov    $0x0,%eax
f01212d0:	e9 cc 06 00 00       	jmp    f01219a1 <realloc_block_FF+0x719>
	}


	if(new_size < 8) new_size = 8;
f01212d5:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f01212d9:	77 07                	ja     f01212e2 <realloc_block_FF+0x5a>
f01212db:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f01212e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01212e5:	83 e0 01             	and    $0x1,%eax
f01212e8:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f01212eb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01212ee:	83 c0 08             	add    $0x8,%eax
f01212f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f01212f4:	83 ec 0c             	sub    $0xc,%esp
f01212f7:	ff 75 08             	pushl  0x8(%ebp)
f01212fa:	e8 45 ec ff ff       	call   f011ff44 <get_block_size>
f01212ff:	83 c4 10             	add    $0x10,%esp
f0121302:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121305:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121308:	83 e8 08             	sub    $0x8,%eax
f012130b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f012130e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121311:	83 e8 04             	sub    $0x4,%eax
f0121314:	8b 00                	mov    (%eax),%eax
f0121316:	83 e0 fe             	and    $0xfffffffe,%eax
f0121319:	89 c2                	mov    %eax,%edx
f012131b:	8b 45 08             	mov    0x8(%ebp),%eax
f012131e:	01 d0                	add    %edx,%eax
f0121320:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0121323:	83 ec 0c             	sub    $0xc,%esp
f0121326:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121329:	e8 16 ec ff ff       	call   f011ff44 <get_block_size>
f012132e:	83 c4 10             	add    $0x10,%esp
f0121331:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121334:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121337:	83 e8 08             	sub    $0x8,%eax
f012133a:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f012133d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121340:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121343:	75 08                	jne    f012134d <realloc_block_FF+0xc5>
	{
		 return va;
f0121345:	8b 45 08             	mov    0x8(%ebp),%eax
f0121348:	e9 54 06 00 00       	jmp    f01219a1 <realloc_block_FF+0x719>

	}


	if(new_size < cur_size)
f012134d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121350:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121353:	0f 83 e5 03 00 00    	jae    f012173e <realloc_block_FF+0x4b6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121359:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012135c:	2b 45 0c             	sub    0xc(%ebp),%eax
f012135f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0121362:	83 ec 0c             	sub    $0xc,%esp
f0121365:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121368:	e8 f0 eb ff ff       	call   f011ff5d <is_free_block>
f012136d:	83 c4 10             	add    $0x10,%esp
f0121370:	84 c0                	test   %al,%al
f0121372:	0f 84 3b 01 00 00    	je     f01214b3 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0121378:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012137b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f012137e:	01 d0                	add    %edx,%eax
f0121380:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0121383:	83 ec 04             	sub    $0x4,%esp
f0121386:	6a 01                	push   $0x1
f0121388:	ff 75 f0             	pushl  -0x10(%ebp)
f012138b:	ff 75 08             	pushl  0x8(%ebp)
f012138e:	e8 02 ef ff ff       	call   f0120295 <set_block_data>
f0121393:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0121396:	8b 45 08             	mov    0x8(%ebp),%eax
f0121399:	83 e8 04             	sub    $0x4,%eax
f012139c:	8b 00                	mov    (%eax),%eax
f012139e:	83 e0 fe             	and    $0xfffffffe,%eax
f01213a1:	89 c2                	mov    %eax,%edx
f01213a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01213a6:	01 d0                	add    %edx,%eax
f01213a8:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f01213ab:	83 ec 04             	sub    $0x4,%esp
f01213ae:	6a 00                	push   $0x0
f01213b0:	ff 75 cc             	pushl  -0x34(%ebp)
f01213b3:	ff 75 c8             	pushl  -0x38(%ebp)
f01213b6:	e8 da ee ff ff       	call   f0120295 <set_block_data>
f01213bb:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f01213be:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01213c2:	74 06                	je     f01213ca <realloc_block_FF+0x142>
f01213c4:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01213c8:	75 17                	jne    f01213e1 <realloc_block_FF+0x159>
f01213ca:	83 ec 04             	sub    $0x4,%esp
f01213cd:	68 a8 0d 13 f0       	push   $0xf0130da8
f01213d2:	68 f6 01 00 00       	push   $0x1f6
f01213d7:	68 35 0d 13 f0       	push   $0xf0130d35
f01213dc:	e8 58 ef fd ff       	call   f0100339 <_panic>
f01213e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01213e4:	8b 10                	mov    (%eax),%edx
f01213e6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01213e9:	89 10                	mov    %edx,(%eax)
f01213eb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01213ee:	8b 00                	mov    (%eax),%eax
f01213f0:	85 c0                	test   %eax,%eax
f01213f2:	74 0b                	je     f01213ff <realloc_block_FF+0x177>
f01213f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01213f7:	8b 00                	mov    (%eax),%eax
f01213f9:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01213fc:	89 50 04             	mov    %edx,0x4(%eax)
f01213ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121402:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121405:	89 10                	mov    %edx,(%eax)
f0121407:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012140a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012140d:	89 50 04             	mov    %edx,0x4(%eax)
f0121410:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121413:	8b 00                	mov    (%eax),%eax
f0121415:	85 c0                	test   %eax,%eax
f0121417:	75 08                	jne    f0121421 <realloc_block_FF+0x199>
f0121419:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012141c:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0121421:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0121426:	40                   	inc    %eax
f0121427:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f012142c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121430:	75 17                	jne    f0121449 <realloc_block_FF+0x1c1>
f0121432:	83 ec 04             	sub    $0x4,%esp
f0121435:	68 17 0d 13 f0       	push   $0xf0130d17
f012143a:	68 f7 01 00 00       	push   $0x1f7
f012143f:	68 35 0d 13 f0       	push   $0xf0130d35
f0121444:	e8 f0 ee fd ff       	call   f0100339 <_panic>
f0121449:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012144c:	8b 00                	mov    (%eax),%eax
f012144e:	85 c0                	test   %eax,%eax
f0121450:	74 10                	je     f0121462 <realloc_block_FF+0x1da>
f0121452:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121455:	8b 00                	mov    (%eax),%eax
f0121457:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012145a:	8b 52 04             	mov    0x4(%edx),%edx
f012145d:	89 50 04             	mov    %edx,0x4(%eax)
f0121460:	eb 0b                	jmp    f012146d <realloc_block_FF+0x1e5>
f0121462:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121465:	8b 40 04             	mov    0x4(%eax),%eax
f0121468:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f012146d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121470:	8b 40 04             	mov    0x4(%eax),%eax
f0121473:	85 c0                	test   %eax,%eax
f0121475:	74 0f                	je     f0121486 <realloc_block_FF+0x1fe>
f0121477:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012147a:	8b 40 04             	mov    0x4(%eax),%eax
f012147d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121480:	8b 12                	mov    (%edx),%edx
f0121482:	89 10                	mov    %edx,(%eax)
f0121484:	eb 0a                	jmp    f0121490 <realloc_block_FF+0x208>
f0121486:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121489:	8b 00                	mov    (%eax),%eax
f012148b:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0121490:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121493:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121499:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012149c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01214a3:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f01214a8:	48                   	dec    %eax
f01214a9:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f01214ae:	e9 83 02 00 00       	jmp    f0121736 <realloc_block_FF+0x4ae>
		}
		else
		{
			if(remaining_size>=16)
f01214b3:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f01214b7:	0f 86 69 02 00 00    	jbe    f0121726 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f01214bd:	83 ec 04             	sub    $0x4,%esp
f01214c0:	6a 01                	push   $0x1
f01214c2:	ff 75 f0             	pushl  -0x10(%ebp)
f01214c5:	ff 75 08             	pushl  0x8(%ebp)
f01214c8:	e8 c8 ed ff ff       	call   f0120295 <set_block_data>
f01214cd:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f01214d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01214d3:	83 e8 04             	sub    $0x4,%eax
f01214d6:	8b 00                	mov    (%eax),%eax
f01214d8:	83 e0 fe             	and    $0xfffffffe,%eax
f01214db:	89 c2                	mov    %eax,%edx
f01214dd:	8b 45 08             	mov    0x8(%ebp),%eax
f01214e0:	01 d0                	add    %edx,%eax
f01214e2:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f01214e5:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f01214ea:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f01214ed:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01214f1:	75 68                	jne    f012155b <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f01214f3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01214f7:	75 17                	jne    f0121510 <realloc_block_FF+0x288>
f01214f9:	83 ec 04             	sub    $0x4,%esp
f01214fc:	68 50 0d 13 f0       	push   $0xf0130d50
f0121501:	68 06 02 00 00       	push   $0x206
f0121506:	68 35 0d 13 f0       	push   $0xf0130d35
f012150b:	e8 29 ee fd ff       	call   f0100339 <_panic>
f0121510:	8b 15 f0 b3 6b f0    	mov    0xf06bb3f0,%edx
f0121516:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121519:	89 10                	mov    %edx,(%eax)
f012151b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012151e:	8b 00                	mov    (%eax),%eax
f0121520:	85 c0                	test   %eax,%eax
f0121522:	74 0d                	je     f0121531 <realloc_block_FF+0x2a9>
f0121524:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f0121529:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012152c:	89 50 04             	mov    %edx,0x4(%eax)
f012152f:	eb 08                	jmp    f0121539 <realloc_block_FF+0x2b1>
f0121531:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121534:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0121539:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012153c:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0121541:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121544:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012154b:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0121550:	40                   	inc    %eax
f0121551:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f0121556:	e9 b0 01 00 00       	jmp    f012170b <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f012155b:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f0121560:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121563:	76 68                	jbe    f01215cd <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121565:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121569:	75 17                	jne    f0121582 <realloc_block_FF+0x2fa>
f012156b:	83 ec 04             	sub    $0x4,%esp
f012156e:	68 50 0d 13 f0       	push   $0xf0130d50
f0121573:	68 0b 02 00 00       	push   $0x20b
f0121578:	68 35 0d 13 f0       	push   $0xf0130d35
f012157d:	e8 b7 ed fd ff       	call   f0100339 <_panic>
f0121582:	8b 15 f0 b3 6b f0    	mov    0xf06bb3f0,%edx
f0121588:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012158b:	89 10                	mov    %edx,(%eax)
f012158d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121590:	8b 00                	mov    (%eax),%eax
f0121592:	85 c0                	test   %eax,%eax
f0121594:	74 0d                	je     f01215a3 <realloc_block_FF+0x31b>
f0121596:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f012159b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012159e:	89 50 04             	mov    %edx,0x4(%eax)
f01215a1:	eb 08                	jmp    f01215ab <realloc_block_FF+0x323>
f01215a3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01215a6:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f01215ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01215ae:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f01215b3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01215b6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01215bd:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f01215c2:	40                   	inc    %eax
f01215c3:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f01215c8:	e9 3e 01 00 00       	jmp    f012170b <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f01215cd:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f01215d2:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01215d5:	73 68                	jae    f012163f <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f01215d7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01215db:	75 17                	jne    f01215f4 <realloc_block_FF+0x36c>
f01215dd:	83 ec 04             	sub    $0x4,%esp
f01215e0:	68 84 0d 13 f0       	push   $0xf0130d84
f01215e5:	68 10 02 00 00       	push   $0x210
f01215ea:	68 35 0d 13 f0       	push   $0xf0130d35
f01215ef:	e8 45 ed fd ff       	call   f0100339 <_panic>
f01215f4:	8b 15 f4 b3 6b f0    	mov    0xf06bb3f4,%edx
f01215fa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01215fd:	89 50 04             	mov    %edx,0x4(%eax)
f0121600:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121603:	8b 40 04             	mov    0x4(%eax),%eax
f0121606:	85 c0                	test   %eax,%eax
f0121608:	74 0c                	je     f0121616 <realloc_block_FF+0x38e>
f012160a:	a1 f4 b3 6b f0       	mov    0xf06bb3f4,%eax
f012160f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121612:	89 10                	mov    %edx,(%eax)
f0121614:	eb 08                	jmp    f012161e <realloc_block_FF+0x396>
f0121616:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121619:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f012161e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121621:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f0121626:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121629:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012162f:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0121634:	40                   	inc    %eax
f0121635:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
f012163a:	e9 cc 00 00 00       	jmp    f012170b <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f012163f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0121646:	a1 f0 b3 6b f0       	mov    0xf06bb3f0,%eax
f012164b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012164e:	e9 8a 00 00 00       	jmp    f01216dd <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0121653:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121656:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121659:	73 7a                	jae    f01216d5 <realloc_block_FF+0x44d>
f012165b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012165e:	8b 00                	mov    (%eax),%eax
f0121660:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121663:	73 70                	jae    f01216d5 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0121665:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121669:	74 06                	je     f0121671 <realloc_block_FF+0x3e9>
f012166b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f012166f:	75 17                	jne    f0121688 <realloc_block_FF+0x400>
f0121671:	83 ec 04             	sub    $0x4,%esp
f0121674:	68 a8 0d 13 f0       	push   $0xf0130da8
f0121679:	68 1a 02 00 00       	push   $0x21a
f012167e:	68 35 0d 13 f0       	push   $0xf0130d35
f0121683:	e8 b1 ec fd ff       	call   f0100339 <_panic>
f0121688:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012168b:	8b 10                	mov    (%eax),%edx
f012168d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121690:	89 10                	mov    %edx,(%eax)
f0121692:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121695:	8b 00                	mov    (%eax),%eax
f0121697:	85 c0                	test   %eax,%eax
f0121699:	74 0b                	je     f01216a6 <realloc_block_FF+0x41e>
f012169b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012169e:	8b 00                	mov    (%eax),%eax
f01216a0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01216a3:	89 50 04             	mov    %edx,0x4(%eax)
f01216a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01216a9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01216ac:	89 10                	mov    %edx,(%eax)
f01216ae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01216b4:	89 50 04             	mov    %edx,0x4(%eax)
f01216b7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216ba:	8b 00                	mov    (%eax),%eax
f01216bc:	85 c0                	test   %eax,%eax
f01216be:	75 08                	jne    f01216c8 <realloc_block_FF+0x440>
f01216c0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216c3:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f01216c8:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f01216cd:	40                   	inc    %eax
f01216ce:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
							break;
f01216d3:	eb 36                	jmp    f012170b <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f01216d5:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f01216da:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01216dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01216e1:	74 07                	je     f01216ea <realloc_block_FF+0x462>
f01216e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01216e6:	8b 00                	mov    (%eax),%eax
f01216e8:	eb 05                	jmp    f01216ef <realloc_block_FF+0x467>
f01216ea:	b8 00 00 00 00       	mov    $0x0,%eax
f01216ef:	a3 f8 b3 6b f0       	mov    %eax,0xf06bb3f8
f01216f4:	a1 f8 b3 6b f0       	mov    0xf06bb3f8,%eax
f01216f9:	85 c0                	test   %eax,%eax
f01216fb:	0f 85 52 ff ff ff    	jne    f0121653 <realloc_block_FF+0x3cb>
f0121701:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121705:	0f 85 48 ff ff ff    	jne    f0121653 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f012170b:	83 ec 04             	sub    $0x4,%esp
f012170e:	6a 00                	push   $0x0
f0121710:	ff 75 d8             	pushl  -0x28(%ebp)
f0121713:	ff 75 d4             	pushl  -0x2c(%ebp)
f0121716:	e8 7a eb ff ff       	call   f0120295 <set_block_data>
f012171b:	83 c4 10             	add    $0x10,%esp
				return va;
f012171e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121721:	e9 7b 02 00 00       	jmp    f01219a1 <realloc_block_FF+0x719>
			}
			cprintf("16\n");
f0121726:	83 ec 0c             	sub    $0xc,%esp
f0121729:	68 25 0e 13 f0       	push   $0xf0130e25
f012172e:	e8 58 f8 fd ff       	call   f0100f8b <cprintf>
f0121733:	83 c4 10             	add    $0x10,%esp
		}
		return va;
f0121736:	8b 45 08             	mov    0x8(%ebp),%eax
f0121739:	e9 63 02 00 00       	jmp    f01219a1 <realloc_block_FF+0x719>
	}

	if(new_size > cur_size)
f012173e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121741:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121744:	0f 86 4d 02 00 00    	jbe    f0121997 <realloc_block_FF+0x70f>
	{
		if(is_free_block(next_va))
f012174a:	83 ec 0c             	sub    $0xc,%esp
f012174d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121750:	e8 08 e8 ff ff       	call   f011ff5d <is_free_block>
f0121755:	83 c4 10             	add    $0x10,%esp
f0121758:	84 c0                	test   %al,%al
f012175a:	0f 84 37 02 00 00    	je     f0121997 <realloc_block_FF+0x70f>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f0121760:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121763:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0121766:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0121769:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012176c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f012176f:	76 38                	jbe    f01217a9 <realloc_block_FF+0x521>
			{
				free_block(va); //set it free
f0121771:	83 ec 0c             	sub    $0xc,%esp
f0121774:	ff 75 08             	pushl  0x8(%ebp)
f0121777:	e8 0c fa ff ff       	call   f0121188 <free_block>
f012177c:	83 c4 10             	add    $0x10,%esp
				void *new_va = alloc_block_FF(new_size); //new allocation
f012177f:	83 ec 0c             	sub    $0xc,%esp
f0121782:	ff 75 0c             	pushl  0xc(%ebp)
f0121785:	e8 3a eb ff ff       	call   f01202c4 <alloc_block_FF>
f012178a:	83 c4 10             	add    $0x10,%esp
f012178d:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f0121790:	83 ec 08             	sub    $0x8,%esp
f0121793:	ff 75 c0             	pushl  -0x40(%ebp)
f0121796:	ff 75 08             	pushl  0x8(%ebp)
f0121799:	e8 ab fa ff ff       	call   f0121249 <copy_data>
f012179e:	83 c4 10             	add    $0x10,%esp
				return new_va;
f01217a1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01217a4:	e9 f8 01 00 00       	jmp    f01219a1 <realloc_block_FF+0x719>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f01217a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01217ac:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f01217af:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f01217b2:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f01217b6:	0f 87 a0 00 00 00    	ja     f012185c <realloc_block_FF+0x5d4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f01217bc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01217c0:	75 17                	jne    f01217d9 <realloc_block_FF+0x551>
f01217c2:	83 ec 04             	sub    $0x4,%esp
f01217c5:	68 17 0d 13 f0       	push   $0xf0130d17
f01217ca:	68 38 02 00 00       	push   $0x238
f01217cf:	68 35 0d 13 f0       	push   $0xf0130d35
f01217d4:	e8 60 eb fd ff       	call   f0100339 <_panic>
f01217d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01217dc:	8b 00                	mov    (%eax),%eax
f01217de:	85 c0                	test   %eax,%eax
f01217e0:	74 10                	je     f01217f2 <realloc_block_FF+0x56a>
f01217e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01217e5:	8b 00                	mov    (%eax),%eax
f01217e7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01217ea:	8b 52 04             	mov    0x4(%edx),%edx
f01217ed:	89 50 04             	mov    %edx,0x4(%eax)
f01217f0:	eb 0b                	jmp    f01217fd <realloc_block_FF+0x575>
f01217f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01217f5:	8b 40 04             	mov    0x4(%eax),%eax
f01217f8:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f01217fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121800:	8b 40 04             	mov    0x4(%eax),%eax
f0121803:	85 c0                	test   %eax,%eax
f0121805:	74 0f                	je     f0121816 <realloc_block_FF+0x58e>
f0121807:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012180a:	8b 40 04             	mov    0x4(%eax),%eax
f012180d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121810:	8b 12                	mov    (%edx),%edx
f0121812:	89 10                	mov    %edx,(%eax)
f0121814:	eb 0a                	jmp    f0121820 <realloc_block_FF+0x598>
f0121816:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121819:	8b 00                	mov    (%eax),%eax
f012181b:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0121820:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121823:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121829:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012182c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121833:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0121838:	48                   	dec    %eax
f0121839:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f012183e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121841:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121844:	01 d0                	add    %edx,%eax
f0121846:	83 ec 04             	sub    $0x4,%esp
f0121849:	6a 01                	push   $0x1
f012184b:	50                   	push   %eax
f012184c:	ff 75 08             	pushl  0x8(%ebp)
f012184f:	e8 41 ea ff ff       	call   f0120295 <set_block_data>
f0121854:	83 c4 10             	add    $0x10,%esp
f0121857:	e9 36 01 00 00       	jmp    f0121992 <realloc_block_FF+0x70a>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f012185c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012185f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121862:	01 d0                	add    %edx,%eax
f0121864:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0121867:	83 ec 04             	sub    $0x4,%esp
f012186a:	6a 01                	push   $0x1
f012186c:	ff 75 f0             	pushl  -0x10(%ebp)
f012186f:	ff 75 08             	pushl  0x8(%ebp)
f0121872:	e8 1e ea ff ff       	call   f0120295 <set_block_data>
f0121877:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f012187a:	8b 45 08             	mov    0x8(%ebp),%eax
f012187d:	83 e8 04             	sub    $0x4,%eax
f0121880:	8b 00                	mov    (%eax),%eax
f0121882:	83 e0 fe             	and    $0xfffffffe,%eax
f0121885:	89 c2                	mov    %eax,%edx
f0121887:	8b 45 08             	mov    0x8(%ebp),%eax
f012188a:	01 d0                	add    %edx,%eax
f012188c:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f012188f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121893:	74 06                	je     f012189b <realloc_block_FF+0x613>
f0121895:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0121899:	75 17                	jne    f01218b2 <realloc_block_FF+0x62a>
f012189b:	83 ec 04             	sub    $0x4,%esp
f012189e:	68 a8 0d 13 f0       	push   $0xf0130da8
f01218a3:	68 44 02 00 00       	push   $0x244
f01218a8:	68 35 0d 13 f0       	push   $0xf0130d35
f01218ad:	e8 87 ea fd ff       	call   f0100339 <_panic>
f01218b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218b5:	8b 10                	mov    (%eax),%edx
f01218b7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01218ba:	89 10                	mov    %edx,(%eax)
f01218bc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01218bf:	8b 00                	mov    (%eax),%eax
f01218c1:	85 c0                	test   %eax,%eax
f01218c3:	74 0b                	je     f01218d0 <realloc_block_FF+0x648>
f01218c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218c8:	8b 00                	mov    (%eax),%eax
f01218ca:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01218cd:	89 50 04             	mov    %edx,0x4(%eax)
f01218d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218d3:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01218d6:	89 10                	mov    %edx,(%eax)
f01218d8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01218db:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01218de:	89 50 04             	mov    %edx,0x4(%eax)
f01218e1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01218e4:	8b 00                	mov    (%eax),%eax
f01218e6:	85 c0                	test   %eax,%eax
f01218e8:	75 08                	jne    f01218f2 <realloc_block_FF+0x66a>
f01218ea:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01218ed:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f01218f2:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f01218f7:	40                   	inc    %eax
f01218f8:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f01218fd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121901:	75 17                	jne    f012191a <realloc_block_FF+0x692>
f0121903:	83 ec 04             	sub    $0x4,%esp
f0121906:	68 17 0d 13 f0       	push   $0xf0130d17
f012190b:	68 45 02 00 00       	push   $0x245
f0121910:	68 35 0d 13 f0       	push   $0xf0130d35
f0121915:	e8 1f ea fd ff       	call   f0100339 <_panic>
f012191a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012191d:	8b 00                	mov    (%eax),%eax
f012191f:	85 c0                	test   %eax,%eax
f0121921:	74 10                	je     f0121933 <realloc_block_FF+0x6ab>
f0121923:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121926:	8b 00                	mov    (%eax),%eax
f0121928:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012192b:	8b 52 04             	mov    0x4(%edx),%edx
f012192e:	89 50 04             	mov    %edx,0x4(%eax)
f0121931:	eb 0b                	jmp    f012193e <realloc_block_FF+0x6b6>
f0121933:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121936:	8b 40 04             	mov    0x4(%eax),%eax
f0121939:	a3 f4 b3 6b f0       	mov    %eax,0xf06bb3f4
f012193e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121941:	8b 40 04             	mov    0x4(%eax),%eax
f0121944:	85 c0                	test   %eax,%eax
f0121946:	74 0f                	je     f0121957 <realloc_block_FF+0x6cf>
f0121948:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012194b:	8b 40 04             	mov    0x4(%eax),%eax
f012194e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121951:	8b 12                	mov    (%edx),%edx
f0121953:	89 10                	mov    %edx,(%eax)
f0121955:	eb 0a                	jmp    f0121961 <realloc_block_FF+0x6d9>
f0121957:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012195a:	8b 00                	mov    (%eax),%eax
f012195c:	a3 f0 b3 6b f0       	mov    %eax,0xf06bb3f0
f0121961:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121964:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012196a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012196d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121974:	a1 fc b3 6b f0       	mov    0xf06bb3fc,%eax
f0121979:	48                   	dec    %eax
f012197a:	a3 fc b3 6b f0       	mov    %eax,0xf06bb3fc
				set_block_data(next_new_va, remaining_size, 0);
f012197f:	83 ec 04             	sub    $0x4,%esp
f0121982:	6a 00                	push   $0x0
f0121984:	ff 75 bc             	pushl  -0x44(%ebp)
f0121987:	ff 75 b8             	pushl  -0x48(%ebp)
f012198a:	e8 06 e9 ff ff       	call   f0120295 <set_block_data>
f012198f:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f0121992:	8b 45 08             	mov    0x8(%ebp),%eax
f0121995:	eb 0a                	jmp    f01219a1 <realloc_block_FF+0x719>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f0121997:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f012199e:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01219a1:	c9                   	leave  
f01219a2:	c3                   	ret    

f01219a3 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f01219a3:	55                   	push   %ebp
f01219a4:	89 e5                	mov    %esp,%ebp
f01219a6:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f01219a9:	83 ec 04             	sub    $0x4,%esp
f01219ac:	68 2c 0e 13 f0       	push   $0xf0130e2c
f01219b1:	68 58 02 00 00       	push   $0x258
f01219b6:	68 35 0d 13 f0       	push   $0xf0130d35
f01219bb:	e8 79 e9 fd ff       	call   f0100339 <_panic>

f01219c0 <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f01219c0:	55                   	push   %ebp
f01219c1:	89 e5                	mov    %esp,%ebp
f01219c3:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f01219c6:	83 ec 04             	sub    $0x4,%esp
f01219c9:	68 54 0e 13 f0       	push   $0xf0130e54
f01219ce:	68 61 02 00 00       	push   $0x261
f01219d3:	68 35 0d 13 f0       	push   $0xf0130d35
f01219d8:	e8 5c e9 fd ff       	call   f0100339 <_panic>
f01219dd:	66 90                	xchg   %ax,%ax
f01219df:	90                   	nop

f01219e0 <__moddi3>:
f01219e0:	55                   	push   %ebp
f01219e1:	57                   	push   %edi
f01219e2:	56                   	push   %esi
f01219e3:	53                   	push   %ebx
f01219e4:	83 ec 2c             	sub    $0x2c,%esp
f01219e7:	8b 74 24 40          	mov    0x40(%esp),%esi
f01219eb:	8b 7c 24 44          	mov    0x44(%esp),%edi
f01219ef:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f01219f3:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f01219f7:	89 d8                	mov    %ebx,%eax
f01219f9:	85 ff                	test   %edi,%edi
f01219fb:	0f 88 d3 00 00 00    	js     f0121ad4 <__moddi3+0xf4>
f0121a01:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0121a08:	00 
f0121a09:	85 c0                	test   %eax,%eax
f0121a0b:	0f 88 ab 00 00 00    	js     f0121abc <__moddi3+0xdc>
f0121a11:	89 0c 24             	mov    %ecx,(%esp)
f0121a14:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0121a18:	89 74 24 10          	mov    %esi,0x10(%esp)
f0121a1c:	89 fb                	mov    %edi,%ebx
f0121a1e:	8b 14 24             	mov    (%esp),%edx
f0121a21:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0121a25:	89 d0                	mov    %edx,%eax
f0121a27:	89 54 24 18          	mov    %edx,0x18(%esp)
f0121a2b:	89 ca                	mov    %ecx,%edx
f0121a2d:	8b 0c 24             	mov    (%esp),%ecx
f0121a30:	89 34 24             	mov    %esi,(%esp)
f0121a33:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0121a37:	85 d2                	test   %edx,%edx
f0121a39:	75 15                	jne    f0121a50 <__moddi3+0x70>
f0121a3b:	89 c7                	mov    %eax,%edi
f0121a3d:	39 d8                	cmp    %ebx,%eax
f0121a3f:	76 5b                	jbe    f0121a9c <__moddi3+0xbc>
f0121a41:	89 f0                	mov    %esi,%eax
f0121a43:	89 da                	mov    %ebx,%edx
f0121a45:	f7 f7                	div    %edi
f0121a47:	89 d3                	mov    %edx,%ebx
f0121a49:	89 d8                	mov    %ebx,%eax
f0121a4b:	31 d2                	xor    %edx,%edx
f0121a4d:	eb 09                	jmp    f0121a58 <__moddi3+0x78>
f0121a4f:	90                   	nop
f0121a50:	39 fa                	cmp    %edi,%edx
f0121a52:	76 1c                	jbe    f0121a70 <__moddi3+0x90>
f0121a54:	89 f0                	mov    %esi,%eax
f0121a56:	89 fa                	mov    %edi,%edx
f0121a58:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0121a5c:	85 c9                	test   %ecx,%ecx
f0121a5e:	74 07                	je     f0121a67 <__moddi3+0x87>
f0121a60:	f7 d8                	neg    %eax
f0121a62:	83 d2 00             	adc    $0x0,%edx
f0121a65:	f7 da                	neg    %edx
f0121a67:	83 c4 2c             	add    $0x2c,%esp
f0121a6a:	5b                   	pop    %ebx
f0121a6b:	5e                   	pop    %esi
f0121a6c:	5f                   	pop    %edi
f0121a6d:	5d                   	pop    %ebp
f0121a6e:	c3                   	ret    
f0121a6f:	90                   	nop
f0121a70:	0f bd c2             	bsr    %edx,%eax
f0121a73:	83 f0 1f             	xor    $0x1f,%eax
f0121a76:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0121a7a:	75 6c                	jne    f0121ae8 <__moddi3+0x108>
f0121a7c:	39 fa                	cmp    %edi,%edx
f0121a7e:	72 05                	jb     f0121a85 <__moddi3+0xa5>
f0121a80:	3b 0c 24             	cmp    (%esp),%ecx
f0121a83:	77 0e                	ja     f0121a93 <__moddi3+0xb3>
f0121a85:	8b 34 24             	mov    (%esp),%esi
f0121a88:	29 ce                	sub    %ecx,%esi
f0121a8a:	19 d3                	sbb    %edx,%ebx
f0121a8c:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0121a90:	89 34 24             	mov    %esi,(%esp)
f0121a93:	8b 04 24             	mov    (%esp),%eax
f0121a96:	8b 54 24 14          	mov    0x14(%esp),%edx
f0121a9a:	eb bc                	jmp    f0121a58 <__moddi3+0x78>
f0121a9c:	85 c9                	test   %ecx,%ecx
f0121a9e:	75 0b                	jne    f0121aab <__moddi3+0xcb>
f0121aa0:	b8 01 00 00 00       	mov    $0x1,%eax
f0121aa5:	31 d2                	xor    %edx,%edx
f0121aa7:	f7 f1                	div    %ecx
f0121aa9:	89 c1                	mov    %eax,%ecx
f0121aab:	89 d8                	mov    %ebx,%eax
f0121aad:	31 d2                	xor    %edx,%edx
f0121aaf:	f7 f1                	div    %ecx
f0121ab1:	8b 04 24             	mov    (%esp),%eax
f0121ab4:	f7 f1                	div    %ecx
f0121ab6:	89 d3                	mov    %edx,%ebx
f0121ab8:	eb 8f                	jmp    f0121a49 <__moddi3+0x69>
f0121aba:	66 90                	xchg   %ax,%ax
f0121abc:	89 c8                	mov    %ecx,%eax
f0121abe:	89 da                	mov    %ebx,%edx
f0121ac0:	f7 d8                	neg    %eax
f0121ac2:	83 d2 00             	adc    $0x0,%edx
f0121ac5:	f7 da                	neg    %edx
f0121ac7:	89 04 24             	mov    %eax,(%esp)
f0121aca:	89 54 24 04          	mov    %edx,0x4(%esp)
f0121ace:	e9 45 ff ff ff       	jmp    f0121a18 <__moddi3+0x38>
f0121ad3:	90                   	nop
f0121ad4:	f7 de                	neg    %esi
f0121ad6:	83 d7 00             	adc    $0x0,%edi
f0121ad9:	f7 df                	neg    %edi
f0121adb:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0121ae2:	ff 
f0121ae3:	e9 21 ff ff ff       	jmp    f0121a09 <__moddi3+0x29>
f0121ae8:	b8 20 00 00 00       	mov    $0x20,%eax
f0121aed:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0121af1:	29 f8                	sub    %edi,%eax
f0121af3:	89 c6                	mov    %eax,%esi
f0121af5:	89 44 24 14          	mov    %eax,0x14(%esp)
f0121af9:	89 f9                	mov    %edi,%ecx
f0121afb:	d3 e2                	shl    %cl,%edx
f0121afd:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0121b01:	89 e8                	mov    %ebp,%eax
f0121b03:	89 f1                	mov    %esi,%ecx
f0121b05:	d3 e8                	shr    %cl,%eax
f0121b07:	09 d0                	or     %edx,%eax
f0121b09:	89 04 24             	mov    %eax,(%esp)
f0121b0c:	89 ea                	mov    %ebp,%edx
f0121b0e:	89 f9                	mov    %edi,%ecx
f0121b10:	d3 e2                	shl    %cl,%edx
f0121b12:	89 d7                	mov    %edx,%edi
f0121b14:	89 da                	mov    %ebx,%edx
f0121b16:	d3 e2                	shl    %cl,%edx
f0121b18:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0121b1c:	d3 e5                	shl    %cl,%ebp
f0121b1e:	8b 44 24 10          	mov    0x10(%esp),%eax
f0121b22:	89 f1                	mov    %esi,%ecx
f0121b24:	d3 e8                	shr    %cl,%eax
f0121b26:	09 d0                	or     %edx,%eax
f0121b28:	d3 eb                	shr    %cl,%ebx
f0121b2a:	89 da                	mov    %ebx,%edx
f0121b2c:	f7 34 24             	divl   (%esp)
f0121b2f:	89 d3                	mov    %edx,%ebx
f0121b31:	f7 e7                	mul    %edi
f0121b33:	89 c6                	mov    %eax,%esi
f0121b35:	89 d1                	mov    %edx,%ecx
f0121b37:	39 d3                	cmp    %edx,%ebx
f0121b39:	72 29                	jb     f0121b64 <__moddi3+0x184>
f0121b3b:	74 33                	je     f0121b70 <__moddi3+0x190>
f0121b3d:	89 e8                	mov    %ebp,%eax
f0121b3f:	29 f0                	sub    %esi,%eax
f0121b41:	19 cb                	sbb    %ecx,%ebx
f0121b43:	89 de                	mov    %ebx,%esi
f0121b45:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0121b49:	d3 e6                	shl    %cl,%esi
f0121b4b:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0121b4f:	89 f9                	mov    %edi,%ecx
f0121b51:	d3 e8                	shr    %cl,%eax
f0121b53:	09 c6                	or     %eax,%esi
f0121b55:	89 f0                	mov    %esi,%eax
f0121b57:	89 f9                	mov    %edi,%ecx
f0121b59:	d3 eb                	shr    %cl,%ebx
f0121b5b:	89 da                	mov    %ebx,%edx
f0121b5d:	e9 f6 fe ff ff       	jmp    f0121a58 <__moddi3+0x78>
f0121b62:	66 90                	xchg   %ax,%ax
f0121b64:	29 f8                	sub    %edi,%eax
f0121b66:	1b 14 24             	sbb    (%esp),%edx
f0121b69:	89 d1                	mov    %edx,%ecx
f0121b6b:	89 c6                	mov    %eax,%esi
f0121b6d:	eb ce                	jmp    f0121b3d <__moddi3+0x15d>
f0121b6f:	90                   	nop
f0121b70:	39 c5                	cmp    %eax,%ebp
f0121b72:	72 f0                	jb     f0121b64 <__moddi3+0x184>
f0121b74:	89 d9                	mov    %ebx,%ecx
f0121b76:	eb c5                	jmp    f0121b3d <__moddi3+0x15d>

f0121b78 <__udivdi3>:
f0121b78:	55                   	push   %ebp
f0121b79:	57                   	push   %edi
f0121b7a:	56                   	push   %esi
f0121b7b:	53                   	push   %ebx
f0121b7c:	83 ec 1c             	sub    $0x1c,%esp
f0121b7f:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0121b83:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0121b87:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121b8b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0121b8f:	89 ca                	mov    %ecx,%edx
f0121b91:	89 f8                	mov    %edi,%eax
f0121b93:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0121b97:	85 f6                	test   %esi,%esi
f0121b99:	75 2d                	jne    f0121bc8 <__udivdi3+0x50>
f0121b9b:	39 cf                	cmp    %ecx,%edi
f0121b9d:	77 65                	ja     f0121c04 <__udivdi3+0x8c>
f0121b9f:	89 fd                	mov    %edi,%ebp
f0121ba1:	85 ff                	test   %edi,%edi
f0121ba3:	75 0b                	jne    f0121bb0 <__udivdi3+0x38>
f0121ba5:	b8 01 00 00 00       	mov    $0x1,%eax
f0121baa:	31 d2                	xor    %edx,%edx
f0121bac:	f7 f7                	div    %edi
f0121bae:	89 c5                	mov    %eax,%ebp
f0121bb0:	31 d2                	xor    %edx,%edx
f0121bb2:	89 c8                	mov    %ecx,%eax
f0121bb4:	f7 f5                	div    %ebp
f0121bb6:	89 c1                	mov    %eax,%ecx
f0121bb8:	89 d8                	mov    %ebx,%eax
f0121bba:	f7 f5                	div    %ebp
f0121bbc:	89 cf                	mov    %ecx,%edi
f0121bbe:	89 fa                	mov    %edi,%edx
f0121bc0:	83 c4 1c             	add    $0x1c,%esp
f0121bc3:	5b                   	pop    %ebx
f0121bc4:	5e                   	pop    %esi
f0121bc5:	5f                   	pop    %edi
f0121bc6:	5d                   	pop    %ebp
f0121bc7:	c3                   	ret    
f0121bc8:	39 ce                	cmp    %ecx,%esi
f0121bca:	77 28                	ja     f0121bf4 <__udivdi3+0x7c>
f0121bcc:	0f bd fe             	bsr    %esi,%edi
f0121bcf:	83 f7 1f             	xor    $0x1f,%edi
f0121bd2:	75 40                	jne    f0121c14 <__udivdi3+0x9c>
f0121bd4:	39 ce                	cmp    %ecx,%esi
f0121bd6:	72 0a                	jb     f0121be2 <__udivdi3+0x6a>
f0121bd8:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0121bdc:	0f 87 9e 00 00 00    	ja     f0121c80 <__udivdi3+0x108>
f0121be2:	b8 01 00 00 00       	mov    $0x1,%eax
f0121be7:	89 fa                	mov    %edi,%edx
f0121be9:	83 c4 1c             	add    $0x1c,%esp
f0121bec:	5b                   	pop    %ebx
f0121bed:	5e                   	pop    %esi
f0121bee:	5f                   	pop    %edi
f0121bef:	5d                   	pop    %ebp
f0121bf0:	c3                   	ret    
f0121bf1:	8d 76 00             	lea    0x0(%esi),%esi
f0121bf4:	31 ff                	xor    %edi,%edi
f0121bf6:	31 c0                	xor    %eax,%eax
f0121bf8:	89 fa                	mov    %edi,%edx
f0121bfa:	83 c4 1c             	add    $0x1c,%esp
f0121bfd:	5b                   	pop    %ebx
f0121bfe:	5e                   	pop    %esi
f0121bff:	5f                   	pop    %edi
f0121c00:	5d                   	pop    %ebp
f0121c01:	c3                   	ret    
f0121c02:	66 90                	xchg   %ax,%ax
f0121c04:	89 d8                	mov    %ebx,%eax
f0121c06:	f7 f7                	div    %edi
f0121c08:	31 ff                	xor    %edi,%edi
f0121c0a:	89 fa                	mov    %edi,%edx
f0121c0c:	83 c4 1c             	add    $0x1c,%esp
f0121c0f:	5b                   	pop    %ebx
f0121c10:	5e                   	pop    %esi
f0121c11:	5f                   	pop    %edi
f0121c12:	5d                   	pop    %ebp
f0121c13:	c3                   	ret    
f0121c14:	bd 20 00 00 00       	mov    $0x20,%ebp
f0121c19:	89 eb                	mov    %ebp,%ebx
f0121c1b:	29 fb                	sub    %edi,%ebx
f0121c1d:	89 f9                	mov    %edi,%ecx
f0121c1f:	d3 e6                	shl    %cl,%esi
f0121c21:	89 c5                	mov    %eax,%ebp
f0121c23:	88 d9                	mov    %bl,%cl
f0121c25:	d3 ed                	shr    %cl,%ebp
f0121c27:	89 e9                	mov    %ebp,%ecx
f0121c29:	09 f1                	or     %esi,%ecx
f0121c2b:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f0121c2f:	89 f9                	mov    %edi,%ecx
f0121c31:	d3 e0                	shl    %cl,%eax
f0121c33:	89 c5                	mov    %eax,%ebp
f0121c35:	89 d6                	mov    %edx,%esi
f0121c37:	88 d9                	mov    %bl,%cl
f0121c39:	d3 ee                	shr    %cl,%esi
f0121c3b:	89 f9                	mov    %edi,%ecx
f0121c3d:	d3 e2                	shl    %cl,%edx
f0121c3f:	8b 44 24 08          	mov    0x8(%esp),%eax
f0121c43:	88 d9                	mov    %bl,%cl
f0121c45:	d3 e8                	shr    %cl,%eax
f0121c47:	09 c2                	or     %eax,%edx
f0121c49:	89 d0                	mov    %edx,%eax
f0121c4b:	89 f2                	mov    %esi,%edx
f0121c4d:	f7 74 24 0c          	divl   0xc(%esp)
f0121c51:	89 d6                	mov    %edx,%esi
f0121c53:	89 c3                	mov    %eax,%ebx
f0121c55:	f7 e5                	mul    %ebp
f0121c57:	39 d6                	cmp    %edx,%esi
f0121c59:	72 19                	jb     f0121c74 <__udivdi3+0xfc>
f0121c5b:	74 0b                	je     f0121c68 <__udivdi3+0xf0>
f0121c5d:	89 d8                	mov    %ebx,%eax
f0121c5f:	31 ff                	xor    %edi,%edi
f0121c61:	e9 58 ff ff ff       	jmp    f0121bbe <__udivdi3+0x46>
f0121c66:	66 90                	xchg   %ax,%ax
f0121c68:	8b 54 24 08          	mov    0x8(%esp),%edx
f0121c6c:	89 f9                	mov    %edi,%ecx
f0121c6e:	d3 e2                	shl    %cl,%edx
f0121c70:	39 c2                	cmp    %eax,%edx
f0121c72:	73 e9                	jae    f0121c5d <__udivdi3+0xe5>
f0121c74:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0121c77:	31 ff                	xor    %edi,%edi
f0121c79:	e9 40 ff ff ff       	jmp    f0121bbe <__udivdi3+0x46>
f0121c7e:	66 90                	xchg   %ax,%ax
f0121c80:	31 c0                	xor    %eax,%eax
f0121c82:	e9 37 ff ff ff       	jmp    f0121bbe <__udivdi3+0x46>
f0121c87:	90                   	nop

f0121c88 <__umoddi3>:
f0121c88:	55                   	push   %ebp
f0121c89:	57                   	push   %edi
f0121c8a:	56                   	push   %esi
f0121c8b:	53                   	push   %ebx
f0121c8c:	83 ec 1c             	sub    $0x1c,%esp
f0121c8f:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f0121c93:	8b 74 24 34          	mov    0x34(%esp),%esi
f0121c97:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121c9b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0121c9f:	89 44 24 0c          	mov    %eax,0xc(%esp)
f0121ca3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0121ca7:	89 f3                	mov    %esi,%ebx
f0121ca9:	89 fa                	mov    %edi,%edx
f0121cab:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0121caf:	89 34 24             	mov    %esi,(%esp)
f0121cb2:	85 c0                	test   %eax,%eax
f0121cb4:	75 1a                	jne    f0121cd0 <__umoddi3+0x48>
f0121cb6:	39 f7                	cmp    %esi,%edi
f0121cb8:	0f 86 a2 00 00 00    	jbe    f0121d60 <__umoddi3+0xd8>
f0121cbe:	89 c8                	mov    %ecx,%eax
f0121cc0:	89 f2                	mov    %esi,%edx
f0121cc2:	f7 f7                	div    %edi
f0121cc4:	89 d0                	mov    %edx,%eax
f0121cc6:	31 d2                	xor    %edx,%edx
f0121cc8:	83 c4 1c             	add    $0x1c,%esp
f0121ccb:	5b                   	pop    %ebx
f0121ccc:	5e                   	pop    %esi
f0121ccd:	5f                   	pop    %edi
f0121cce:	5d                   	pop    %ebp
f0121ccf:	c3                   	ret    
f0121cd0:	39 f0                	cmp    %esi,%eax
f0121cd2:	0f 87 ac 00 00 00    	ja     f0121d84 <__umoddi3+0xfc>
f0121cd8:	0f bd e8             	bsr    %eax,%ebp
f0121cdb:	83 f5 1f             	xor    $0x1f,%ebp
f0121cde:	0f 84 ac 00 00 00    	je     f0121d90 <__umoddi3+0x108>
f0121ce4:	bf 20 00 00 00       	mov    $0x20,%edi
f0121ce9:	29 ef                	sub    %ebp,%edi
f0121ceb:	89 fe                	mov    %edi,%esi
f0121ced:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0121cf1:	89 e9                	mov    %ebp,%ecx
f0121cf3:	d3 e0                	shl    %cl,%eax
f0121cf5:	89 d7                	mov    %edx,%edi
f0121cf7:	89 f1                	mov    %esi,%ecx
f0121cf9:	d3 ef                	shr    %cl,%edi
f0121cfb:	09 c7                	or     %eax,%edi
f0121cfd:	89 e9                	mov    %ebp,%ecx
f0121cff:	d3 e2                	shl    %cl,%edx
f0121d01:	89 14 24             	mov    %edx,(%esp)
f0121d04:	89 d8                	mov    %ebx,%eax
f0121d06:	d3 e0                	shl    %cl,%eax
f0121d08:	89 c2                	mov    %eax,%edx
f0121d0a:	8b 44 24 08          	mov    0x8(%esp),%eax
f0121d0e:	d3 e0                	shl    %cl,%eax
f0121d10:	89 44 24 04          	mov    %eax,0x4(%esp)
f0121d14:	8b 44 24 08          	mov    0x8(%esp),%eax
f0121d18:	89 f1                	mov    %esi,%ecx
f0121d1a:	d3 e8                	shr    %cl,%eax
f0121d1c:	09 d0                	or     %edx,%eax
f0121d1e:	d3 eb                	shr    %cl,%ebx
f0121d20:	89 da                	mov    %ebx,%edx
f0121d22:	f7 f7                	div    %edi
f0121d24:	89 d3                	mov    %edx,%ebx
f0121d26:	f7 24 24             	mull   (%esp)
f0121d29:	89 c6                	mov    %eax,%esi
f0121d2b:	89 d1                	mov    %edx,%ecx
f0121d2d:	39 d3                	cmp    %edx,%ebx
f0121d2f:	0f 82 87 00 00 00    	jb     f0121dbc <__umoddi3+0x134>
f0121d35:	0f 84 91 00 00 00    	je     f0121dcc <__umoddi3+0x144>
f0121d3b:	8b 54 24 04          	mov    0x4(%esp),%edx
f0121d3f:	29 f2                	sub    %esi,%edx
f0121d41:	19 cb                	sbb    %ecx,%ebx
f0121d43:	89 d8                	mov    %ebx,%eax
f0121d45:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0121d49:	d3 e0                	shl    %cl,%eax
f0121d4b:	89 e9                	mov    %ebp,%ecx
f0121d4d:	d3 ea                	shr    %cl,%edx
f0121d4f:	09 d0                	or     %edx,%eax
f0121d51:	89 e9                	mov    %ebp,%ecx
f0121d53:	d3 eb                	shr    %cl,%ebx
f0121d55:	89 da                	mov    %ebx,%edx
f0121d57:	83 c4 1c             	add    $0x1c,%esp
f0121d5a:	5b                   	pop    %ebx
f0121d5b:	5e                   	pop    %esi
f0121d5c:	5f                   	pop    %edi
f0121d5d:	5d                   	pop    %ebp
f0121d5e:	c3                   	ret    
f0121d5f:	90                   	nop
f0121d60:	89 fd                	mov    %edi,%ebp
f0121d62:	85 ff                	test   %edi,%edi
f0121d64:	75 0b                	jne    f0121d71 <__umoddi3+0xe9>
f0121d66:	b8 01 00 00 00       	mov    $0x1,%eax
f0121d6b:	31 d2                	xor    %edx,%edx
f0121d6d:	f7 f7                	div    %edi
f0121d6f:	89 c5                	mov    %eax,%ebp
f0121d71:	89 f0                	mov    %esi,%eax
f0121d73:	31 d2                	xor    %edx,%edx
f0121d75:	f7 f5                	div    %ebp
f0121d77:	89 c8                	mov    %ecx,%eax
f0121d79:	f7 f5                	div    %ebp
f0121d7b:	89 d0                	mov    %edx,%eax
f0121d7d:	e9 44 ff ff ff       	jmp    f0121cc6 <__umoddi3+0x3e>
f0121d82:	66 90                	xchg   %ax,%ax
f0121d84:	89 c8                	mov    %ecx,%eax
f0121d86:	89 f2                	mov    %esi,%edx
f0121d88:	83 c4 1c             	add    $0x1c,%esp
f0121d8b:	5b                   	pop    %ebx
f0121d8c:	5e                   	pop    %esi
f0121d8d:	5f                   	pop    %edi
f0121d8e:	5d                   	pop    %ebp
f0121d8f:	c3                   	ret    
f0121d90:	3b 04 24             	cmp    (%esp),%eax
f0121d93:	72 06                	jb     f0121d9b <__umoddi3+0x113>
f0121d95:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0121d99:	77 0f                	ja     f0121daa <__umoddi3+0x122>
f0121d9b:	89 f2                	mov    %esi,%edx
f0121d9d:	29 f9                	sub    %edi,%ecx
f0121d9f:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f0121da3:	89 14 24             	mov    %edx,(%esp)
f0121da6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0121daa:	8b 44 24 04          	mov    0x4(%esp),%eax
f0121dae:	8b 14 24             	mov    (%esp),%edx
f0121db1:	83 c4 1c             	add    $0x1c,%esp
f0121db4:	5b                   	pop    %ebx
f0121db5:	5e                   	pop    %esi
f0121db6:	5f                   	pop    %edi
f0121db7:	5d                   	pop    %ebp
f0121db8:	c3                   	ret    
f0121db9:	8d 76 00             	lea    0x0(%esi),%esi
f0121dbc:	2b 04 24             	sub    (%esp),%eax
f0121dbf:	19 fa                	sbb    %edi,%edx
f0121dc1:	89 d1                	mov    %edx,%ecx
f0121dc3:	89 c6                	mov    %eax,%esi
f0121dc5:	e9 71 ff ff ff       	jmp    f0121d3b <__umoddi3+0xb3>
f0121dca:	66 90                	xchg   %ax,%ax
f0121dcc:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0121dd0:	72 ea                	jb     f0121dbc <__umoddi3+0x134>
f0121dd2:	89 d9                	mov    %ebx,%ecx
f0121dd4:	e9 62 ff ff ff       	jmp    f0121d3b <__umoddi3+0xb3>
